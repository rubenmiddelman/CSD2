@gsxtmmath0 = hidden constant [31 x i8] c"vsum_adhoc_W2kzMixpMzIqLGk2NF0\00"
@gsxtmmath1 = hidden constant [41 x i8] c"{i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**\00"
define dllexport fastcc i32 @vsum_adhoc_W2kzMixpMzIqLGk2NF0__1(i8* %_impz,i8* %_impenv, i32* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***}*
%vsum_adhoc_W2kzMixpMzIqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***}, {{i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***}* %impenv, i32 0, i32 0
%vsum_adhoc_W2kzMixpMzIqLGk2NF0Ptr = load {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**** %vsum_adhoc_W2kzMixpMzIqLGk2NF0Ptr_

; setup arguments
%bufPtr = alloca i32*
store i32* %buf, i32** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone3 = load i8*, i8** %_impzPtr
%zone4 = bitcast i8* %tzone3 to %mzone*

; let assign value to symbol tot
%totPtr = alloca i32
%tzone5 = load i8*, i8** %_impzPtr
%zone6 = bitcast i8* %tzone5 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%tot = select i1 true, i32 0, i32 0
store i32 %tot, i32* %totPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; promote local stack var allocations
%tzone87 = load i8*, i8** %_impzPtr
%zone88 = bitcast i8* %tzone87 to %mzone*
%ifptr7 = alloca i32*
%val8 = load i64, i64* %lenPtr
%cmp9 = icmp sgt i64 %val8, 3
br i1 %cmp9, label %then7, label %else7

then7:
%tzone12 = load i8*, i8** %_impzPtr
%zone13 = bitcast i8* %tzone12 to %mzone*

; let assign value to symbol chunks
%chunksPtr = alloca i64
%tzone16 = load i8*, i8** %_impzPtr
%zone17 = bitcast i8* %tzone16 to %mzone*

; let assign value to symbol vbuf
%vbufPtr = alloca <4 x i32>*
%tzone19 = load i8*, i8** %_impzPtr
%zone20 = bitcast i8* %tzone19 to %mzone*

; let assign value to symbol vtot
%vtotPtr = alloca <4 x i32>*
%val10 = load i64, i64* %lenPtr
%val11 = sdiv i64 %val10, 4

; let value assignment
%chunks = select i1 true, i64 %val11, i64 %val11
store i64 %chunks, i64* %chunksPtr

%val14 = load i32*, i32** %bufPtr
%val15 = bitcast i32* %val14 to <4 x i32>*

; let value assignment
%vbuf = select i1 true, <4 x i32>* %val15, <4 x i32>* %val15
store <4 x i32>* %vbuf, <4 x i32>** %vbufPtr

%dat18 = alloca <4 x i32>, align 16

; let value assignment
%vtot = select i1 true, <4 x i32>* %dat18, <4 x i32>* %dat18
store <4 x i32>* %vtot, <4 x i32>** %vtotPtr

%val21 = load <4 x i32>*, <4 x i32>** %vtotPtr
; set vector
%vect22 = load <4 x i32>, <4 x i32>* %val21
%vect223 = insertelement <4 x i32> %vect22, i32 0, i32 0
store <4 x i32> %vect223, <4 x i32>* %val21
%val25 = load <4 x i32>*, <4 x i32>** %vtotPtr
; set vector
%vect26 = load <4 x i32>, <4 x i32>* %val25
%vect227 = insertelement <4 x i32> %vect26, i32 0, i32 1
store <4 x i32> %vect227, <4 x i32>* %val25
%val29 = load <4 x i32>*, <4 x i32>** %vtotPtr
; set vector
%vect30 = load <4 x i32>, <4 x i32>* %val29
%vect231 = insertelement <4 x i32> %vect30, i32 0, i32 2
store <4 x i32> %vect231, <4 x i32>* %val29
%val33 = load <4 x i32>*, <4 x i32>** %vtotPtr
; set vector
%vect34 = load <4 x i32>, <4 x i32>* %val33
%vect235 = insertelement <4 x i32> %vect34, i32 0, i32 3
store <4 x i32> %vect235, <4 x i32>* %val33
%tzone40 = load i8*, i8** %_impzPtr
%zone41 = bitcast i8* %tzone40 to %mzone*

; let assign value to symbol totref
%totrefPtr = alloca <4 x i32>
%val37 = load <4 x i32>*, <4 x i32>** %vtotPtr
; pointer ref
%val38 = getelementptr <4 x i32>, <4 x i32>* %val37, i64 0
%val39 = load <4 x i32>, <4 x i32>* %val38

; let value assignment
%totref = select i1 true, <4 x i32> %val39, <4 x i32> %val39
store <4 x i32> %totref, <4 x i32>* %totrefPtr

; setup loop
%val44 = load i64, i64* %chunksPtr
store i64 0, i64* %iPtr
%val51 = load i64, i64* %iPtr
%num52 = add i64 %val44, %val51
%comp53 = icmp ult i64 %val44, 1
br i1 %comp53, label %after42, label %loop42

loop42:
; do set!
%val45 = load <4 x i32>, <4 x i32>* %totrefPtr
%val46 = load i64, i64* %iPtr
%val47 = load <4 x i32>*, <4 x i32>** %vbufPtr
; pointer ref
%val48 = getelementptr <4 x i32>, <4 x i32>* %val47, i64 %val46
%val49 = load <4 x i32>, <4 x i32>* %val48
%val50 = add <4 x i32> %val45, %val49
store <4 x i32> %val50, <4 x i32>* %totrefPtr
%loop_cnt42 = load i64, i64* %iPtr
%next42 = add i64 %loop_cnt42, 1
store i64 %next42, i64* %iPtr
%cmp42 = icmp ult i64 %next42, %num52
br i1 %cmp42, label %loop42, label %after42

after42:
; do set!
%val55 = load <4 x i32>, <4 x i32>* %totrefPtr
; vector ref
%val56 = extractelement <4 x i32> %val55, i32 0
%val57 = load <4 x i32>, <4 x i32>* %totrefPtr
; vector ref
%val58 = extractelement <4 x i32> %val57, i32 1
%val59 = add i32 %val56, %val58
%val60 = load <4 x i32>, <4 x i32>* %totrefPtr
; vector ref
%val61 = extractelement <4 x i32> %val60, i32 2
%val62 = add i32 %val59, %val61
%val63 = load <4 x i32>, <4 x i32>* %totrefPtr
; vector ref
%val64 = extractelement <4 x i32> %val63, i32 3
%val65 = add i32 %val62, %val64
store i32 %val65, i32* %totPtr
; do set!
%val66 = load i64, i64* %lenPtr
%val67 = and i64 %val66, 3
store i64 %val67, i64* %lenPtr
; do set!
%val68 = load i64, i64* %iPtr
%val69 = mul i64 %val68, 4
%val70 = load i32*, i32** %bufPtr
; pointer ref
%val71 = getelementptr i32, i32* %val70, i64 %val69
store i32* %val71, i32** %bufPtr
store i32* %val71, i32** %ifptr7
br label %ifcont7

else7:
br label %ifcont7

ifcont7:
%ifres72 = load i32*, i32** %ifptr7

; setup loop
%val75 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val82 = load i64, i64* %iPtr
%num83 = add i64 %val75, %val82
%comp84 = icmp ult i64 %val75, 1
br i1 %comp84, label %after73, label %loop73

loop73:
; do set!
%val76 = load i32, i32* %totPtr
%val77 = load i64, i64* %iPtr
%val78 = load i32*, i32** %bufPtr
; pointer ref
%val79 = getelementptr i32, i32* %val78, i64 %val77
%val80 = load i32, i32* %val79
%val81 = add i32 %val76, %val80
store i32 %val81, i32* %totPtr
%loop_cnt73 = load i64, i64* %iPtr
%next73 = add i64 %loop_cnt73, 1
store i64 %next73, i64* %iPtr
%cmp73 = icmp ult i64 %next73, %num83
br i1 %cmp73, label %loop73, label %after73

after73:
%val86 = load i32, i32* %totPtr
ret i32 %val86
}
@gsxtmmath2 = hidden constant [84 x i8] c"vsum_adhoc_W2kzMixpMzIqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** @vsum_adhoc_W2kzMixpMzIqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone108 = load i8*, i8** %_impzPtr
%zone109 = bitcast i8* %tzone108 to %mzone*

; let assign value to symbol vsum_adhoc_W2kzMixpMzIqLGk2NF0
%dat_vsum_adhoc_W2kzMixpMzIqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone109, i64 8)
%vsum_adhoc_W2kzMixpMzIqLGk2NF0Ptr = bitcast i8* %dat_vsum_adhoc_W2kzMixpMzIqLGk2NF0 to { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***
%tzone89 = load i8*, i8** %_impzPtr
%zone90 = bitcast i8* %tzone89 to %mzone*
call void @llvm_zone_mark(%mzone* %zone90)
; malloc closure structure
%clsptr91 = call i8* @llvm_zone_malloc(%mzone* %zone90, i64 24)
%closure92 = bitcast i8* %clsptr91 to { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*

; malloc environment structure
%envptr93 = call i8* @llvm_zone_malloc(%mzone* %zone90, i64 8)
%environment94 = bitcast i8* %envptr93 to {{i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***}*

; malloc closure address table
%addytable95 = call %clsvar* @new_address_table()
%var96 = bitcast [31 x i8]* @gsxtmmath0 to i8*
%var97 = bitcast [41 x i8]* @gsxtmmath1 to i8*
%addytable98 = call %clsvar* @add_address_table(%mzone* %zone90, i8* %var96, i32 0, i8* %var97, i32 3, %clsvar* %addytable95)
%address-table99 = bitcast %clsvar* %addytable98 to i8*

; insert table, function and environment into closure struct
%closure.table102 = getelementptr { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure92, i32 0, i32 0
store i8* %address-table99, i8** %closure.table102
%closure.env103 = getelementptr { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure92, i32 0, i32 1
store i8* %envptr93, i8** %closure.env103
%closure.func104 = getelementptr { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure92, i32 0, i32 2
store i32 (i8*, i8*, i32*, i64)* @vsum_adhoc_W2kzMixpMzIqLGk2NF0__1, i32 (i8*, i8*, i32*, i64)** %closure.func104
%closure_size105 = call i64 @llvm_zone_mark_size(%mzone* %zone90)
call void @llvm_zone_ptr_set_size(i8* %clsptr91, i64 %closure_size105)
%wrapper_ptr106 = call i8* @llvm_zone_malloc(%mzone* %zone90, i64 8)
%closure_wrapper107 = bitcast i8* %wrapper_ptr106 to { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**
store { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure92, { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure_wrapper107

; let value assignment
%vsum_adhoc_W2kzMixpMzIqLGk2NF0 = select i1 true, { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure_wrapper107, { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure_wrapper107
store { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %vsum_adhoc_W2kzMixpMzIqLGk2NF0, { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*** %vsum_adhoc_W2kzMixpMzIqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var vsum_adhoc_W2kzMixpMzIqLGk2NF0
%tmp_envptr101 = getelementptr {{i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***}, {{i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***}* %environment94, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*** %vsum_adhoc_W2kzMixpMzIqLGk2NF0Ptr, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**** %tmp_envptr101


%val110 = load {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*** %vsum_adhoc_W2kzMixpMzIqLGk2NF0Ptr
ret {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %val110
}


@vsum_adhoc_W2kzMixpMzIqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@vsum_adhoc_W2kzMixpMzIqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vsum_adhoc_W2kzMixpMzIqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2kzMixpMzIqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** @vsum_adhoc_W2kzMixpMzIqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vsum_adhoc_W2kzMixpMzIqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vsum_adhoc_W2kzMixpMzIqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2kzMixpMzIqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @vsum_adhoc_W2kzMixpMzIqLGk2NF0(i32* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2kzMixpMzIqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32*, i64)*,  i32 (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
ret i32 %result
}


define dllexport ccc i32 @vsum_adhoc_W2kzMixpMzIqLGk2NF0_native(i32* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2kzMixpMzIqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32*, i64)*,  i32 (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
ret i32 %result
}


define dllexport ccc i8*  @vsum_adhoc_W2kzMixpMzIqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var111 = bitcast [84 x i8]* @gsxtmmath2 to i8*
call i32 (i8*, ...) @printf(i8* %var111)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i32*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var112 = bitcast [84 x i8]* @gsxtmmath2 to i8*
call i32 (i8*, ...) @printf(i8* %var112)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2kzMixpMzIqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32*, i64)*,  i32 (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @vsum_adhoc_W2kzMixpMzIqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32*, i64}*
%arg_p_0 = getelementptr {i32*, i64}, {i32*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i32*, i32** %arg_p_0
%arg_p_1 = getelementptr {i32*, i64}, {i32*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2kzMixpMzIqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32*, i64)*,  i32 (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath3 = hidden constant [31 x i8] c"vsum_adhoc_W2k2NCxpNjQqLGk2NF0\00"
@gsxtmmath4 = hidden constant [41 x i8] c"{i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**\00"
define dllexport fastcc i64 @vsum_adhoc_W2k2NCxpNjQqLGk2NF0__113(i8* %_impz,i8* %_impenv, i64* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone114 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***}*
%vsum_adhoc_W2k2NCxpNjQqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***}, {{i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***}* %impenv, i32 0, i32 0
%vsum_adhoc_W2k2NCxpNjQqLGk2NF0Ptr = load {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**** %vsum_adhoc_W2k2NCxpNjQqLGk2NF0Ptr_

; setup arguments
%bufPtr = alloca i64*
store i64* %buf, i64** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone115 = load i8*, i8** %_impzPtr
%zone116 = bitcast i8* %tzone115 to %mzone*

; let assign value to symbol tot
%totPtr = alloca i64
%tzone117 = load i8*, i8** %_impzPtr
%zone118 = bitcast i8* %tzone117 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%tot = select i1 true, i64 0, i64 0
store i64 %tot, i64* %totPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; promote local stack var allocations
%tzone185 = load i8*, i8** %_impzPtr
%zone186 = bitcast i8* %tzone185 to %mzone*
%ifptr119 = alloca i64*
%val120 = load i64, i64* %lenPtr
%cmp121 = icmp sgt i64 %val120, 1
br i1 %cmp121, label %then119, label %else119

then119:
%tzone124 = load i8*, i8** %_impzPtr
%zone125 = bitcast i8* %tzone124 to %mzone*

; let assign value to symbol chunks
%chunksPtr = alloca i64
%tzone128 = load i8*, i8** %_impzPtr
%zone129 = bitcast i8* %tzone128 to %mzone*

; let assign value to symbol vbuf
%vbufPtr = alloca <2 x i64>*
%tzone131 = load i8*, i8** %_impzPtr
%zone132 = bitcast i8* %tzone131 to %mzone*

; let assign value to symbol vtot
%vtotPtr = alloca <2 x i64>*
%val122 = load i64, i64* %lenPtr
%val123 = sdiv i64 %val122, 2

; let value assignment
%chunks = select i1 true, i64 %val123, i64 %val123
store i64 %chunks, i64* %chunksPtr

%val126 = load i64*, i64** %bufPtr
%val127 = bitcast i64* %val126 to <2 x i64>*

; let value assignment
%vbuf = select i1 true, <2 x i64>* %val127, <2 x i64>* %val127
store <2 x i64>* %vbuf, <2 x i64>** %vbufPtr

%dat130 = alloca <2 x i64>, align 16

; let value assignment
%vtot = select i1 true, <2 x i64>* %dat130, <2 x i64>* %dat130
store <2 x i64>* %vtot, <2 x i64>** %vtotPtr

%val133 = load <2 x i64>*, <2 x i64>** %vtotPtr
; set vector
%vect134 = load <2 x i64>, <2 x i64>* %val133
%vect2135 = insertelement <2 x i64> %vect134, i64 0, i32 0
store <2 x i64> %vect2135, <2 x i64>* %val133
%val137 = load <2 x i64>*, <2 x i64>** %vtotPtr
; set vector
%vect138 = load <2 x i64>, <2 x i64>* %val137
%vect2139 = insertelement <2 x i64> %vect138, i64 0, i32 1
store <2 x i64> %vect2139, <2 x i64>* %val137
%tzone144 = load i8*, i8** %_impzPtr
%zone145 = bitcast i8* %tzone144 to %mzone*

; let assign value to symbol totref
%totrefPtr = alloca <2 x i64>
%val141 = load <2 x i64>*, <2 x i64>** %vtotPtr
; pointer ref
%val142 = getelementptr <2 x i64>, <2 x i64>* %val141, i64 0
%val143 = load <2 x i64>, <2 x i64>* %val142

; let value assignment
%totref = select i1 true, <2 x i64> %val143, <2 x i64> %val143
store <2 x i64> %totref, <2 x i64>* %totrefPtr

; setup loop
%val148 = load i64, i64* %chunksPtr
store i64 0, i64* %iPtr
%val155 = load i64, i64* %iPtr
%num156 = add i64 %val148, %val155
%comp157 = icmp ult i64 %val148, 1
br i1 %comp157, label %after146, label %loop146

loop146:
; do set!
%val149 = load <2 x i64>, <2 x i64>* %totrefPtr
%val150 = load i64, i64* %iPtr
%val151 = load <2 x i64>*, <2 x i64>** %vbufPtr
; pointer ref
%val152 = getelementptr <2 x i64>, <2 x i64>* %val151, i64 %val150
%val153 = load <2 x i64>, <2 x i64>* %val152
%val154 = add <2 x i64> %val149, %val153
store <2 x i64> %val154, <2 x i64>* %totrefPtr
%loop_cnt146 = load i64, i64* %iPtr
%next146 = add i64 %loop_cnt146, 1
store i64 %next146, i64* %iPtr
%cmp146 = icmp ult i64 %next146, %num156
br i1 %cmp146, label %loop146, label %after146

after146:
; do set!
%val159 = load <2 x i64>, <2 x i64>* %totrefPtr
; vector ref
%val160 = extractelement <2 x i64> %val159, i32 0
%val161 = load <2 x i64>, <2 x i64>* %totrefPtr
; vector ref
%val162 = extractelement <2 x i64> %val161, i32 1
%val163 = add i64 %val160, %val162
store i64 %val163, i64* %totPtr
; do set!
%val164 = load i64, i64* %lenPtr
%val165 = and i64 %val164, 1
store i64 %val165, i64* %lenPtr
; do set!
%val166 = load i64, i64* %iPtr
%val167 = mul i64 %val166, 2
%val168 = load i64*, i64** %bufPtr
; pointer ref
%val169 = getelementptr i64, i64* %val168, i64 %val167
store i64* %val169, i64** %bufPtr
store i64* %val169, i64** %ifptr119
br label %ifcont119

else119:
br label %ifcont119

ifcont119:
%ifres170 = load i64*, i64** %ifptr119

; setup loop
%val173 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val180 = load i64, i64* %iPtr
%num181 = add i64 %val173, %val180
%comp182 = icmp ult i64 %val173, 1
br i1 %comp182, label %after171, label %loop171

loop171:
; do set!
%val174 = load i64, i64* %totPtr
%val175 = load i64, i64* %iPtr
%val176 = load i64*, i64** %bufPtr
; pointer ref
%val177 = getelementptr i64, i64* %val176, i64 %val175
%val178 = load i64, i64* %val177
%val179 = add i64 %val174, %val178
store i64 %val179, i64* %totPtr
%loop_cnt171 = load i64, i64* %iPtr
%next171 = add i64 %loop_cnt171, 1
store i64 %next171, i64* %iPtr
%cmp171 = icmp ult i64 %next171, %num181
br i1 %cmp171, label %loop171, label %after171

after171:
%val184 = load i64, i64* %totPtr
ret i64 %val184
}
@gsxtmmath5 = hidden constant [84 x i8] c"vsum_adhoc_W2k2NCxpNjQqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** @vsum_adhoc_W2k2NCxpNjQqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone206 = load i8*, i8** %_impzPtr
%zone207 = bitcast i8* %tzone206 to %mzone*

; let assign value to symbol vsum_adhoc_W2k2NCxpNjQqLGk2NF0
%dat_vsum_adhoc_W2k2NCxpNjQqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone207, i64 8)
%vsum_adhoc_W2k2NCxpNjQqLGk2NF0Ptr = bitcast i8* %dat_vsum_adhoc_W2k2NCxpNjQqLGk2NF0 to { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***
%tzone187 = load i8*, i8** %_impzPtr
%zone188 = bitcast i8* %tzone187 to %mzone*
call void @llvm_zone_mark(%mzone* %zone188)
; malloc closure structure
%clsptr189 = call i8* @llvm_zone_malloc(%mzone* %zone188, i64 24)
%closure190 = bitcast i8* %clsptr189 to { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*

; malloc environment structure
%envptr191 = call i8* @llvm_zone_malloc(%mzone* %zone188, i64 8)
%environment192 = bitcast i8* %envptr191 to {{i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***}*

; malloc closure address table
%addytable193 = call %clsvar* @new_address_table()
%var194 = bitcast [31 x i8]* @gsxtmmath3 to i8*
%var195 = bitcast [41 x i8]* @gsxtmmath4 to i8*
%addytable196 = call %clsvar* @add_address_table(%mzone* %zone188, i8* %var194, i32 0, i8* %var195, i32 3, %clsvar* %addytable193)
%address-table197 = bitcast %clsvar* %addytable196 to i8*

; insert table, function and environment into closure struct
%closure.table200 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure190, i32 0, i32 0
store i8* %address-table197, i8** %closure.table200
%closure.env201 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure190, i32 0, i32 1
store i8* %envptr191, i8** %closure.env201
%closure.func202 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure190, i32 0, i32 2
store i64 (i8*, i8*, i64*, i64)* @vsum_adhoc_W2k2NCxpNjQqLGk2NF0__113, i64 (i8*, i8*, i64*, i64)** %closure.func202
%closure_size203 = call i64 @llvm_zone_mark_size(%mzone* %zone188)
call void @llvm_zone_ptr_set_size(i8* %clsptr189, i64 %closure_size203)
%wrapper_ptr204 = call i8* @llvm_zone_malloc(%mzone* %zone188, i64 8)
%closure_wrapper205 = bitcast i8* %wrapper_ptr204 to { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**
store { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure190, { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure_wrapper205

; let value assignment
%vsum_adhoc_W2k2NCxpNjQqLGk2NF0 = select i1 true, { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure_wrapper205, { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure_wrapper205
store { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %vsum_adhoc_W2k2NCxpNjQqLGk2NF0, { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*** %vsum_adhoc_W2k2NCxpNjQqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var vsum_adhoc_W2k2NCxpNjQqLGk2NF0
%tmp_envptr199 = getelementptr {{i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***}, {{i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***}* %environment192, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*** %vsum_adhoc_W2k2NCxpNjQqLGk2NF0Ptr, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**** %tmp_envptr199


%val208 = load {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*** %vsum_adhoc_W2k2NCxpNjQqLGk2NF0Ptr
ret {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %val208
}


@vsum_adhoc_W2k2NCxpNjQqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@vsum_adhoc_W2k2NCxpNjQqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vsum_adhoc_W2k2NCxpNjQqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2k2NCxpNjQqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** @vsum_adhoc_W2k2NCxpNjQqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vsum_adhoc_W2k2NCxpNjQqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vsum_adhoc_W2k2NCxpNjQqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2k2NCxpNjQqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @vsum_adhoc_W2k2NCxpNjQqLGk2NF0(i64* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2k2NCxpNjQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64*, i64)*,  i64 (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
ret i64 %result
}


define dllexport ccc i64 @vsum_adhoc_W2k2NCxpNjQqLGk2NF0_native(i64* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2k2NCxpNjQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64*, i64)*,  i64 (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
ret i64 %result
}


define dllexport ccc i8*  @vsum_adhoc_W2k2NCxpNjQqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var209 = bitcast [84 x i8]* @gsxtmmath5 to i8*
call i32 (i8*, ...) @printf(i8* %var209)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i64*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var210 = bitcast [84 x i8]* @gsxtmmath5 to i8*
call i32 (i8*, ...) @printf(i8* %var210)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2k2NCxpNjQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64*, i64)*,  i64 (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @vsum_adhoc_W2k2NCxpNjQqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64*, i64}*
%arg_p_0 = getelementptr {i64*, i64}, {i64*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64*, i64** %arg_p_0
%arg_p_1 = getelementptr {i64*, i64}, {i64*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2k2NCxpNjQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64*, i64)*,  i64 (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath6 = hidden constant [36 x i8] c"vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd\00"
@gsxtmmath7 = hidden constant [45 x i8] c"{i8*, i8*, float (i8*, i8*, float*, i64)*}**\00"
define dllexport fastcc float @vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd__211(i8* %_impz,i8* %_impenv, float* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone212 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}*
%vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 0
%vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr = load {i8*, i8*, float (i8*, i8*, float*, i64)*}***, {i8*, i8*, float (i8*, i8*, float*, i64)*}**** %vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr_

; setup arguments
%bufPtr = alloca float*
store float* %buf, float** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone213 = load i8*, i8** %_impzPtr
%zone214 = bitcast i8* %tzone213 to %mzone*

; let assign value to symbol tot
%totPtr = alloca float
%tzone215 = load i8*, i8** %_impzPtr
%zone216 = bitcast i8* %tzone215 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%tot = select i1 true, float 0x0, float 0x0
store float %tot, float* %totPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; promote local stack var allocations
%tzone297 = load i8*, i8** %_impzPtr
%zone298 = bitcast i8* %tzone297 to %mzone*
%ifptr217 = alloca float*
%val218 = load i64, i64* %lenPtr
%cmp219 = icmp sgt i64 %val218, 3
br i1 %cmp219, label %then217, label %else217

then217:
%tzone222 = load i8*, i8** %_impzPtr
%zone223 = bitcast i8* %tzone222 to %mzone*

; let assign value to symbol chunks
%chunksPtr = alloca i64
%tzone226 = load i8*, i8** %_impzPtr
%zone227 = bitcast i8* %tzone226 to %mzone*

; let assign value to symbol vbuf
%vbufPtr = alloca <4 x float>*
%tzone229 = load i8*, i8** %_impzPtr
%zone230 = bitcast i8* %tzone229 to %mzone*

; let assign value to symbol vtot
%vtotPtr = alloca <4 x float>*
%val220 = load i64, i64* %lenPtr
%val221 = sdiv i64 %val220, 4

; let value assignment
%chunks = select i1 true, i64 %val221, i64 %val221
store i64 %chunks, i64* %chunksPtr

%val224 = load float*, float** %bufPtr
%val225 = bitcast float* %val224 to <4 x float>*

; let value assignment
%vbuf = select i1 true, <4 x float>* %val225, <4 x float>* %val225
store <4 x float>* %vbuf, <4 x float>** %vbufPtr

%dat228 = alloca <4 x float>, align 16

; let value assignment
%vtot = select i1 true, <4 x float>* %dat228, <4 x float>* %dat228
store <4 x float>* %vtot, <4 x float>** %vtotPtr

%val231 = load <4 x float>*, <4 x float>** %vtotPtr
; set vector
%vect232 = load <4 x float>, <4 x float>* %val231
%vect2233 = insertelement <4 x float> %vect232, float 0x0, i32 0
store <4 x float> %vect2233, <4 x float>* %val231
%val235 = load <4 x float>*, <4 x float>** %vtotPtr
; set vector
%vect236 = load <4 x float>, <4 x float>* %val235
%vect2237 = insertelement <4 x float> %vect236, float 0x0, i32 1
store <4 x float> %vect2237, <4 x float>* %val235
%val239 = load <4 x float>*, <4 x float>** %vtotPtr
; set vector
%vect240 = load <4 x float>, <4 x float>* %val239
%vect2241 = insertelement <4 x float> %vect240, float 0x0, i32 2
store <4 x float> %vect2241, <4 x float>* %val239
%val243 = load <4 x float>*, <4 x float>** %vtotPtr
; set vector
%vect244 = load <4 x float>, <4 x float>* %val243
%vect2245 = insertelement <4 x float> %vect244, float 0x0, i32 3
store <4 x float> %vect2245, <4 x float>* %val243
%tzone250 = load i8*, i8** %_impzPtr
%zone251 = bitcast i8* %tzone250 to %mzone*

; let assign value to symbol totref
%totrefPtr = alloca <4 x float>
%val247 = load <4 x float>*, <4 x float>** %vtotPtr
; pointer ref
%val248 = getelementptr <4 x float>, <4 x float>* %val247, i64 0
%val249 = load <4 x float>, <4 x float>* %val248

; let value assignment
%totref = select i1 true, <4 x float> %val249, <4 x float> %val249
store <4 x float> %totref, <4 x float>* %totrefPtr

; setup loop
%val254 = load i64, i64* %chunksPtr
store i64 0, i64* %iPtr
%val261 = load i64, i64* %iPtr
%num262 = add i64 %val254, %val261
%comp263 = icmp ult i64 %val254, 1
br i1 %comp263, label %after252, label %loop252

loop252:
; do set!
%val255 = load <4 x float>, <4 x float>* %totrefPtr
%val256 = load i64, i64* %iPtr
%val257 = load <4 x float>*, <4 x float>** %vbufPtr
; pointer ref
%val258 = getelementptr <4 x float>, <4 x float>* %val257, i64 %val256
%val259 = load <4 x float>, <4 x float>* %val258
%val260 = fadd <4 x float> %val255, %val259
store <4 x float> %val260, <4 x float>* %totrefPtr
%loop_cnt252 = load i64, i64* %iPtr
%next252 = add i64 %loop_cnt252, 1
store i64 %next252, i64* %iPtr
%cmp252 = icmp ult i64 %next252, %num262
br i1 %cmp252, label %loop252, label %after252

after252:
; do set!
%val265 = load <4 x float>, <4 x float>* %totrefPtr
; vector ref
%val266 = extractelement <4 x float> %val265, i32 0
%val267 = load <4 x float>, <4 x float>* %totrefPtr
; vector ref
%val268 = extractelement <4 x float> %val267, i32 1
%val269 = fadd float %val266, %val268
%val270 = load <4 x float>, <4 x float>* %totrefPtr
; vector ref
%val271 = extractelement <4 x float> %val270, i32 2
%val272 = fadd float %val269, %val271
%val273 = load <4 x float>, <4 x float>* %totrefPtr
; vector ref
%val274 = extractelement <4 x float> %val273, i32 3
%val275 = fadd float %val272, %val274
store float %val275, float* %totPtr
; do set!
%val276 = load i64, i64* %lenPtr
%val277 = and i64 %val276, 3
store i64 %val277, i64* %lenPtr
; do set!
%val278 = load i64, i64* %iPtr
%val279 = mul i64 %val278, 4
%val280 = load float*, float** %bufPtr
; pointer ref
%val281 = getelementptr float, float* %val280, i64 %val279
store float* %val281, float** %bufPtr
store float* %val281, float** %ifptr217
br label %ifcont217

else217:
br label %ifcont217

ifcont217:
%ifres282 = load float*, float** %ifptr217

; setup loop
%val285 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val292 = load i64, i64* %iPtr
%num293 = add i64 %val285, %val292
%comp294 = icmp ult i64 %val285, 1
br i1 %comp294, label %after283, label %loop283

loop283:
; do set!
%val286 = load float, float* %totPtr
%val287 = load i64, i64* %iPtr
%val288 = load float*, float** %bufPtr
; pointer ref
%val289 = getelementptr float, float* %val288, i64 %val287
%val290 = load float, float* %val289
%val291 = fadd float %val286, %val290
store float %val291, float* %totPtr
%loop_cnt283 = load i64, i64* %iPtr
%next283 = add i64 %loop_cnt283, 1
store i64 %next283, i64* %iPtr
%cmp283 = icmp ult i64 %next283, %num293
br i1 %cmp283, label %loop283, label %after283

after283:
%val296 = load float, float* %totPtr
ret float %val296
}
@gsxtmmath8 = hidden constant [89 x i8] c"vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, float*, i64)*}** @vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone318 = load i8*, i8** %_impzPtr
%zone319 = bitcast i8* %tzone318 to %mzone*

; let assign value to symbol vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd
%dat_vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone319, i64 8)
%vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr = bitcast i8* %dat_vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd to { i8*, i8*, float (i8*, i8*, float*, i64)*}***
%tzone299 = load i8*, i8** %_impzPtr
%zone300 = bitcast i8* %tzone299 to %mzone*
call void @llvm_zone_mark(%mzone* %zone300)
; malloc closure structure
%clsptr301 = call i8* @llvm_zone_malloc(%mzone* %zone300, i64 24)
%closure302 = bitcast i8* %clsptr301 to { i8*, i8*, float (i8*, i8*, float*, i64)*}*

; malloc environment structure
%envptr303 = call i8* @llvm_zone_malloc(%mzone* %zone300, i64 8)
%environment304 = bitcast i8* %envptr303 to {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}*

; malloc closure address table
%addytable305 = call %clsvar* @new_address_table()
%var306 = bitcast [36 x i8]* @gsxtmmath6 to i8*
%var307 = bitcast [45 x i8]* @gsxtmmath7 to i8*
%addytable308 = call %clsvar* @add_address_table(%mzone* %zone300, i8* %var306, i32 0, i8* %var307, i32 3, %clsvar* %addytable305)
%address-table309 = bitcast %clsvar* %addytable308 to i8*

; insert table, function and environment into closure struct
%closure.table312 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure302, i32 0, i32 0
store i8* %address-table309, i8** %closure.table312
%closure.env313 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure302, i32 0, i32 1
store i8* %envptr303, i8** %closure.env313
%closure.func314 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure302, i32 0, i32 2
store float (i8*, i8*, float*, i64)* @vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd__211, float (i8*, i8*, float*, i64)** %closure.func314
%closure_size315 = call i64 @llvm_zone_mark_size(%mzone* %zone300)
call void @llvm_zone_ptr_set_size(i8* %clsptr301, i64 %closure_size315)
%wrapper_ptr316 = call i8* @llvm_zone_malloc(%mzone* %zone300, i64 8)
%closure_wrapper317 = bitcast i8* %wrapper_ptr316 to { i8*, i8*, float (i8*, i8*, float*, i64)*}**
store { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure302, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper317

; let value assignment
%vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd = select i1 true, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper317, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper317
store { i8*, i8*, float (i8*, i8*, float*, i64)*}** %vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd, { i8*, i8*, float (i8*, i8*, float*, i64)*}*** %vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr

; add data to environment
; don't need to alloc for env var vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd
%tmp_envptr311 = getelementptr {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}* %environment304, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, float*, i64)*}*** %vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr, {i8*, i8*, float (i8*, i8*, float*, i64)*}**** %tmp_envptr311


%val320 = load {i8*, i8*, float (i8*, i8*, float*, i64)*}**, {i8*, i8*, float (i8*, i8*, float*, i64)*}*** %vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr
ret {i8*, i8*, float (i8*, i8*, float*, i64)*}** %val320
}


@vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, float*, i64)*}** @vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret float %result
}


define dllexport ccc float @vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_native(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret float %result
}


define dllexport ccc i8*  @vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var321 = bitcast [89 x i8]* @gsxtmmath8 to i8*
call i32 (i8*, ...) @printf(i8* %var321)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var322 = bitcast [89 x i8]* @gsxtmmath8 to i8*
call i32 (i8*, ...) @printf(i8* %var322)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64}*
%arg_p_0 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath9 = hidden constant [39 x i8] c"vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0\00"
@gsxtmmath10 = hidden constant [47 x i8] c"{i8*, i8*, double (i8*, i8*, double*, i64)*}**\00"
define dllexport fastcc double @vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0__323(i8* %_impz,i8* %_impenv, double* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone324 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}*
%vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}* %impenv, i32 0, i32 0
%vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr = load {i8*, i8*, double (i8*, i8*, double*, i64)*}***, {i8*, i8*, double (i8*, i8*, double*, i64)*}**** %vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr_

; setup arguments
%bufPtr = alloca double*
store double* %buf, double** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone325 = load i8*, i8** %_impzPtr
%zone326 = bitcast i8* %tzone325 to %mzone*

; let assign value to symbol tot
%totPtr = alloca double
%tzone327 = load i8*, i8** %_impzPtr
%zone328 = bitcast i8* %tzone327 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%tot = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %tot, double* %totPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; promote local stack var allocations
%tzone395 = load i8*, i8** %_impzPtr
%zone396 = bitcast i8* %tzone395 to %mzone*
%ifptr329 = alloca double*
%val330 = load i64, i64* %lenPtr
%cmp331 = icmp sgt i64 %val330, 1
br i1 %cmp331, label %then329, label %else329

then329:
%tzone334 = load i8*, i8** %_impzPtr
%zone335 = bitcast i8* %tzone334 to %mzone*

; let assign value to symbol chunks
%chunksPtr = alloca i64
%tzone338 = load i8*, i8** %_impzPtr
%zone339 = bitcast i8* %tzone338 to %mzone*

; let assign value to symbol vbuf
%vbufPtr = alloca <2 x double>*
%tzone341 = load i8*, i8** %_impzPtr
%zone342 = bitcast i8* %tzone341 to %mzone*

; let assign value to symbol vtot
%vtotPtr = alloca <2 x double>*
%val332 = load i64, i64* %lenPtr
%val333 = sdiv i64 %val332, 2

; let value assignment
%chunks = select i1 true, i64 %val333, i64 %val333
store i64 %chunks, i64* %chunksPtr

%val336 = load double*, double** %bufPtr
%val337 = bitcast double* %val336 to <2 x double>*

; let value assignment
%vbuf = select i1 true, <2 x double>* %val337, <2 x double>* %val337
store <2 x double>* %vbuf, <2 x double>** %vbufPtr

%dat340 = alloca <2 x double>, align 16

; let value assignment
%vtot = select i1 true, <2 x double>* %dat340, <2 x double>* %dat340
store <2 x double>* %vtot, <2 x double>** %vtotPtr

%val343 = load <2 x double>*, <2 x double>** %vtotPtr
; set vector
%vect344 = load <2 x double>, <2 x double>* %val343
%vect2345 = insertelement <2 x double> %vect344, double 0.00000000000000000000, i32 0
store <2 x double> %vect2345, <2 x double>* %val343
%val347 = load <2 x double>*, <2 x double>** %vtotPtr
; set vector
%vect348 = load <2 x double>, <2 x double>* %val347
%vect2349 = insertelement <2 x double> %vect348, double 0.00000000000000000000, i32 1
store <2 x double> %vect2349, <2 x double>* %val347
%tzone354 = load i8*, i8** %_impzPtr
%zone355 = bitcast i8* %tzone354 to %mzone*

; let assign value to symbol totref
%totrefPtr = alloca <2 x double>
%val351 = load <2 x double>*, <2 x double>** %vtotPtr
; pointer ref
%val352 = getelementptr <2 x double>, <2 x double>* %val351, i64 0
%val353 = load <2 x double>, <2 x double>* %val352

; let value assignment
%totref = select i1 true, <2 x double> %val353, <2 x double> %val353
store <2 x double> %totref, <2 x double>* %totrefPtr

; setup loop
%val358 = load i64, i64* %chunksPtr
store i64 0, i64* %iPtr
%val365 = load i64, i64* %iPtr
%num366 = add i64 %val358, %val365
%comp367 = icmp ult i64 %val358, 1
br i1 %comp367, label %after356, label %loop356

loop356:
; do set!
%val359 = load <2 x double>, <2 x double>* %totrefPtr
%val360 = load i64, i64* %iPtr
%val361 = load <2 x double>*, <2 x double>** %vbufPtr
; pointer ref
%val362 = getelementptr <2 x double>, <2 x double>* %val361, i64 %val360
%val363 = load <2 x double>, <2 x double>* %val362
%val364 = fadd <2 x double> %val359, %val363
store <2 x double> %val364, <2 x double>* %totrefPtr
%loop_cnt356 = load i64, i64* %iPtr
%next356 = add i64 %loop_cnt356, 1
store i64 %next356, i64* %iPtr
%cmp356 = icmp ult i64 %next356, %num366
br i1 %cmp356, label %loop356, label %after356

after356:
; do set!
%val369 = load <2 x double>, <2 x double>* %totrefPtr
; vector ref
%val370 = extractelement <2 x double> %val369, i32 0
%val371 = load <2 x double>, <2 x double>* %totrefPtr
; vector ref
%val372 = extractelement <2 x double> %val371, i32 1
%val373 = fadd double %val370, %val372
store double %val373, double* %totPtr
; do set!
%val374 = load i64, i64* %lenPtr
%val375 = and i64 %val374, 1
store i64 %val375, i64* %lenPtr
; do set!
%val376 = load i64, i64* %iPtr
%val377 = mul i64 %val376, 2
%val378 = load double*, double** %bufPtr
; pointer ref
%val379 = getelementptr double, double* %val378, i64 %val377
store double* %val379, double** %bufPtr
store double* %val379, double** %ifptr329
br label %ifcont329

else329:
br label %ifcont329

ifcont329:
%ifres380 = load double*, double** %ifptr329

; setup loop
%val383 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val390 = load i64, i64* %iPtr
%num391 = add i64 %val383, %val390
%comp392 = icmp ult i64 %val383, 1
br i1 %comp392, label %after381, label %loop381

loop381:
; do set!
%val384 = load double, double* %totPtr
%val385 = load i64, i64* %iPtr
%val386 = load double*, double** %bufPtr
; pointer ref
%val387 = getelementptr double, double* %val386, i64 %val385
%val388 = load double, double* %val387
%val389 = fadd double %val384, %val388
store double %val389, double* %totPtr
%loop_cnt381 = load i64, i64* %iPtr
%next381 = add i64 %loop_cnt381, 1
store i64 %next381, i64* %iPtr
%cmp381 = icmp ult i64 %next381, %num391
br i1 %cmp381, label %loop381, label %after381

after381:
%val394 = load double, double* %totPtr
ret double %val394
}
@gsxtmmath11 = hidden constant [92 x i8] c"vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, double*, i64)*}** @vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone416 = load i8*, i8** %_impzPtr
%zone417 = bitcast i8* %tzone416 to %mzone*

; let assign value to symbol vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0
%dat_vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone417, i64 8)
%vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr = bitcast i8* %dat_vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 to { i8*, i8*, double (i8*, i8*, double*, i64)*}***
%tzone397 = load i8*, i8** %_impzPtr
%zone398 = bitcast i8* %tzone397 to %mzone*
call void @llvm_zone_mark(%mzone* %zone398)
; malloc closure structure
%clsptr399 = call i8* @llvm_zone_malloc(%mzone* %zone398, i64 24)
%closure400 = bitcast i8* %clsptr399 to { i8*, i8*, double (i8*, i8*, double*, i64)*}*

; malloc environment structure
%envptr401 = call i8* @llvm_zone_malloc(%mzone* %zone398, i64 8)
%environment402 = bitcast i8* %envptr401 to {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}*

; malloc closure address table
%addytable403 = call %clsvar* @new_address_table()
%var404 = bitcast [39 x i8]* @gsxtmmath9 to i8*
%var405 = bitcast [47 x i8]* @gsxtmmath10 to i8*
%addytable406 = call %clsvar* @add_address_table(%mzone* %zone398, i8* %var404, i32 0, i8* %var405, i32 3, %clsvar* %addytable403)
%address-table407 = bitcast %clsvar* %addytable406 to i8*

; insert table, function and environment into closure struct
%closure.table410 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure400, i32 0, i32 0
store i8* %address-table407, i8** %closure.table410
%closure.env411 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure400, i32 0, i32 1
store i8* %envptr401, i8** %closure.env411
%closure.func412 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure400, i32 0, i32 2
store double (i8*, i8*, double*, i64)* @vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0__323, double (i8*, i8*, double*, i64)** %closure.func412
%closure_size413 = call i64 @llvm_zone_mark_size(%mzone* %zone398)
call void @llvm_zone_ptr_set_size(i8* %clsptr399, i64 %closure_size413)
%wrapper_ptr414 = call i8* @llvm_zone_malloc(%mzone* %zone398, i64 8)
%closure_wrapper415 = bitcast i8* %wrapper_ptr414 to { i8*, i8*, double (i8*, i8*, double*, i64)*}**
store { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure400, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper415

; let value assignment
%vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 = select i1 true, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper415, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper415
store { i8*, i8*, double (i8*, i8*, double*, i64)*}** %vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0, { i8*, i8*, double (i8*, i8*, double*, i64)*}*** %vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0
%tmp_envptr409 = getelementptr {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}* %environment402, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, double*, i64)*}*** %vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr, {i8*, i8*, double (i8*, i8*, double*, i64)*}**** %tmp_envptr409


%val418 = load {i8*, i8*, double (i8*, i8*, double*, i64)*}**, {i8*, i8*, double (i8*, i8*, double*, i64)*}*** %vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr
ret {i8*, i8*, double (i8*, i8*, double*, i64)*}** %val418
}


@vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, double*, i64)*}** @vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret double %result
}


define dllexport ccc double @vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_native(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret double %result
}


define dllexport ccc i8*  @vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var419 = bitcast [92 x i8]* @gsxtmmath11 to i8*
call i32 (i8*, ...) @printf(i8* %var419)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var420 = bitcast [92 x i8]* @gsxtmmath11 to i8*
call i32 (i8*, ...) @printf(i8* %var420)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, i64}*
%arg_p_0 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath12 = hidden constant [36 x i8] c"vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0\00"
@gsxtmmath13 = hidden constant [44 x i8] c"{i8*, i8*, double (i8*, i8*, i32*, i64)*}**\00"
define dllexport fastcc double @vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0__421(i8* %_impz,i8* %_impenv, i32* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone422 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, i32*, i64)*}***}*
%vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, i32*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, i32*, i64)*}***}* %impenv, i32 0, i32 0
%vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0Ptr = load {i8*, i8*, double (i8*, i8*, i32*, i64)*}***, {i8*, i8*, double (i8*, i8*, i32*, i64)*}**** %vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0Ptr_

; setup arguments
%bufPtr = alloca i32*
store i32* %buf, i32** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%val423 = load i32*, i32** %bufPtr
%val424 = load i64, i64* %lenPtr
%res425 = call fastcc i32 @vsum_adhoc_W2kzMixpMzIqLGk2NF0(i32* %val423, i64 %val424)
%res426 = call ccc double @i32tod(i32 %res425)
%val427 = load i64, i64* %lenPtr
%val428 = sitofp i64 %val427 to double
%val429 = fdiv double %res426, %val428
ret double %val429
}
@gsxtmmath14 = hidden constant [89 x i8] c"vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, i32*, i64)*}** @vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone449 = load i8*, i8** %_impzPtr
%zone450 = bitcast i8* %tzone449 to %mzone*

; let assign value to symbol vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0
%dat_vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone450, i64 8)
%vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0Ptr = bitcast i8* %dat_vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0 to { i8*, i8*, double (i8*, i8*, i32*, i64)*}***
%tzone430 = load i8*, i8** %_impzPtr
%zone431 = bitcast i8* %tzone430 to %mzone*
call void @llvm_zone_mark(%mzone* %zone431)
; malloc closure structure
%clsptr432 = call i8* @llvm_zone_malloc(%mzone* %zone431, i64 24)
%closure433 = bitcast i8* %clsptr432 to { i8*, i8*, double (i8*, i8*, i32*, i64)*}*

; malloc environment structure
%envptr434 = call i8* @llvm_zone_malloc(%mzone* %zone431, i64 8)
%environment435 = bitcast i8* %envptr434 to {{i8*, i8*, double (i8*, i8*, i32*, i64)*}***}*

; malloc closure address table
%addytable436 = call %clsvar* @new_address_table()
%var437 = bitcast [36 x i8]* @gsxtmmath12 to i8*
%var438 = bitcast [44 x i8]* @gsxtmmath13 to i8*
%addytable439 = call %clsvar* @add_address_table(%mzone* %zone431, i8* %var437, i32 0, i8* %var438, i32 3, %clsvar* %addytable436)
%address-table440 = bitcast %clsvar* %addytable439 to i8*

; insert table, function and environment into closure struct
%closure.table443 = getelementptr { i8*, i8*, double (i8*, i8*, i32*, i64)*}, { i8*, i8*, double (i8*, i8*, i32*, i64)*}* %closure433, i32 0, i32 0
store i8* %address-table440, i8** %closure.table443
%closure.env444 = getelementptr { i8*, i8*, double (i8*, i8*, i32*, i64)*}, { i8*, i8*, double (i8*, i8*, i32*, i64)*}* %closure433, i32 0, i32 1
store i8* %envptr434, i8** %closure.env444
%closure.func445 = getelementptr { i8*, i8*, double (i8*, i8*, i32*, i64)*}, { i8*, i8*, double (i8*, i8*, i32*, i64)*}* %closure433, i32 0, i32 2
store double (i8*, i8*, i32*, i64)* @vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0__421, double (i8*, i8*, i32*, i64)** %closure.func445
%closure_size446 = call i64 @llvm_zone_mark_size(%mzone* %zone431)
call void @llvm_zone_ptr_set_size(i8* %clsptr432, i64 %closure_size446)
%wrapper_ptr447 = call i8* @llvm_zone_malloc(%mzone* %zone431, i64 8)
%closure_wrapper448 = bitcast i8* %wrapper_ptr447 to { i8*, i8*, double (i8*, i8*, i32*, i64)*}**
store { i8*, i8*, double (i8*, i8*, i32*, i64)*}* %closure433, { i8*, i8*, double (i8*, i8*, i32*, i64)*}** %closure_wrapper448

; let value assignment
%vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0 = select i1 true, { i8*, i8*, double (i8*, i8*, i32*, i64)*}** %closure_wrapper448, { i8*, i8*, double (i8*, i8*, i32*, i64)*}** %closure_wrapper448
store { i8*, i8*, double (i8*, i8*, i32*, i64)*}** %vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0, { i8*, i8*, double (i8*, i8*, i32*, i64)*}*** %vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0
%tmp_envptr442 = getelementptr {{i8*, i8*, double (i8*, i8*, i32*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, i32*, i64)*}***}* %environment435, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, i32*, i64)*}*** %vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0Ptr, {i8*, i8*, double (i8*, i8*, i32*, i64)*}**** %tmp_envptr442


%val451 = load {i8*, i8*, double (i8*, i8*, i32*, i64)*}**, {i8*, i8*, double (i8*, i8*, i32*, i64)*}*** %vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0Ptr
ret {i8*, i8*, double (i8*, i8*, i32*, i64)*}** %val451
}


@vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, i32*, i64)*}** @vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, i32*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0(i32* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, i32*, i64)*}*, {i8*, i8*, double (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, i32*, i64)*}, {i8*, i8*, double (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, i32*, i64)*}, {i8*, i8*, double (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, i32*, i64)*,  double (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
ret double %result
}


define dllexport ccc double @vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0_native(i32* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, i32*, i64)*}*, {i8*, i8*, double (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, i32*, i64)*}, {i8*, i8*, double (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, i32*, i64)*}, {i8*, i8*, double (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, i32*, i64)*,  double (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
ret double %result
}


define dllexport ccc i8*  @vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var452 = bitcast [89 x i8]* @gsxtmmath14 to i8*
call i32 (i8*, ...) @printf(i8* %var452)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i32*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var453 = bitcast [89 x i8]* @gsxtmmath14 to i8*
call i32 (i8*, ...) @printf(i8* %var453)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, i32*, i64)*}*, {i8*, i8*, double (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, i32*, i64)*}, {i8*, i8*, double (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, i32*, i64)*}, {i8*, i8*, double (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, i32*, i64)*,  double (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32*, i64}*
%arg_p_0 = getelementptr {i32*, i64}, {i32*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i32*, i32** %arg_p_0
%arg_p_1 = getelementptr {i32*, i64}, {i32*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2RvdWJsZSxpMzIqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, i32*, i64)*}*, {i8*, i8*, double (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, i32*, i64)*}, {i8*, i8*, double (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, i32*, i64)*}, {i8*, i8*, double (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, i32*, i64)*,  double (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath15 = hidden constant [36 x i8] c"vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0\00"
@gsxtmmath16 = hidden constant [44 x i8] c"{i8*, i8*, double (i8*, i8*, i64*, i64)*}**\00"
define dllexport fastcc double @vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0__454(i8* %_impz,i8* %_impenv, i64* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone455 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, i64*, i64)*}***}*
%vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, i64*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, i64*, i64)*}***}* %impenv, i32 0, i32 0
%vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0Ptr = load {i8*, i8*, double (i8*, i8*, i64*, i64)*}***, {i8*, i8*, double (i8*, i8*, i64*, i64)*}**** %vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0Ptr_

; setup arguments
%bufPtr = alloca i64*
store i64* %buf, i64** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%val456 = load i64*, i64** %bufPtr
%val457 = load i64, i64* %lenPtr
%res458 = call fastcc i64 @vsum_adhoc_W2k2NCxpNjQqLGk2NF0(i64* %val456, i64 %val457)
%res459 = call ccc double @i64tod(i64 %res458)
%val460 = load i64, i64* %lenPtr
%val461 = sitofp i64 %val460 to double
%val462 = fdiv double %res459, %val461
ret double %val462
}
@gsxtmmath17 = hidden constant [89 x i8] c"vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, i64*, i64)*}** @vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone482 = load i8*, i8** %_impzPtr
%zone483 = bitcast i8* %tzone482 to %mzone*

; let assign value to symbol vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0
%dat_vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone483, i64 8)
%vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0Ptr = bitcast i8* %dat_vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0 to { i8*, i8*, double (i8*, i8*, i64*, i64)*}***
%tzone463 = load i8*, i8** %_impzPtr
%zone464 = bitcast i8* %tzone463 to %mzone*
call void @llvm_zone_mark(%mzone* %zone464)
; malloc closure structure
%clsptr465 = call i8* @llvm_zone_malloc(%mzone* %zone464, i64 24)
%closure466 = bitcast i8* %clsptr465 to { i8*, i8*, double (i8*, i8*, i64*, i64)*}*

; malloc environment structure
%envptr467 = call i8* @llvm_zone_malloc(%mzone* %zone464, i64 8)
%environment468 = bitcast i8* %envptr467 to {{i8*, i8*, double (i8*, i8*, i64*, i64)*}***}*

; malloc closure address table
%addytable469 = call %clsvar* @new_address_table()
%var470 = bitcast [36 x i8]* @gsxtmmath15 to i8*
%var471 = bitcast [44 x i8]* @gsxtmmath16 to i8*
%addytable472 = call %clsvar* @add_address_table(%mzone* %zone464, i8* %var470, i32 0, i8* %var471, i32 3, %clsvar* %addytable469)
%address-table473 = bitcast %clsvar* %addytable472 to i8*

; insert table, function and environment into closure struct
%closure.table476 = getelementptr { i8*, i8*, double (i8*, i8*, i64*, i64)*}, { i8*, i8*, double (i8*, i8*, i64*, i64)*}* %closure466, i32 0, i32 0
store i8* %address-table473, i8** %closure.table476
%closure.env477 = getelementptr { i8*, i8*, double (i8*, i8*, i64*, i64)*}, { i8*, i8*, double (i8*, i8*, i64*, i64)*}* %closure466, i32 0, i32 1
store i8* %envptr467, i8** %closure.env477
%closure.func478 = getelementptr { i8*, i8*, double (i8*, i8*, i64*, i64)*}, { i8*, i8*, double (i8*, i8*, i64*, i64)*}* %closure466, i32 0, i32 2
store double (i8*, i8*, i64*, i64)* @vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0__454, double (i8*, i8*, i64*, i64)** %closure.func478
%closure_size479 = call i64 @llvm_zone_mark_size(%mzone* %zone464)
call void @llvm_zone_ptr_set_size(i8* %clsptr465, i64 %closure_size479)
%wrapper_ptr480 = call i8* @llvm_zone_malloc(%mzone* %zone464, i64 8)
%closure_wrapper481 = bitcast i8* %wrapper_ptr480 to { i8*, i8*, double (i8*, i8*, i64*, i64)*}**
store { i8*, i8*, double (i8*, i8*, i64*, i64)*}* %closure466, { i8*, i8*, double (i8*, i8*, i64*, i64)*}** %closure_wrapper481

; let value assignment
%vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0 = select i1 true, { i8*, i8*, double (i8*, i8*, i64*, i64)*}** %closure_wrapper481, { i8*, i8*, double (i8*, i8*, i64*, i64)*}** %closure_wrapper481
store { i8*, i8*, double (i8*, i8*, i64*, i64)*}** %vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0, { i8*, i8*, double (i8*, i8*, i64*, i64)*}*** %vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0
%tmp_envptr475 = getelementptr {{i8*, i8*, double (i8*, i8*, i64*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, i64*, i64)*}***}* %environment468, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, i64*, i64)*}*** %vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0Ptr, {i8*, i8*, double (i8*, i8*, i64*, i64)*}**** %tmp_envptr475


%val484 = load {i8*, i8*, double (i8*, i8*, i64*, i64)*}**, {i8*, i8*, double (i8*, i8*, i64*, i64)*}*** %vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0Ptr
ret {i8*, i8*, double (i8*, i8*, i64*, i64)*}** %val484
}


@vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, i64*, i64)*}** @vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, i64*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0(i64* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, i64*, i64)*}*, {i8*, i8*, double (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, i64*, i64)*}, {i8*, i8*, double (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, i64*, i64)*}, {i8*, i8*, double (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, i64*, i64)*,  double (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
ret double %result
}


define dllexport ccc double @vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0_native(i64* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, i64*, i64)*}*, {i8*, i8*, double (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, i64*, i64)*}, {i8*, i8*, double (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, i64*, i64)*}, {i8*, i8*, double (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, i64*, i64)*,  double (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
ret double %result
}


define dllexport ccc i8*  @vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var485 = bitcast [89 x i8]* @gsxtmmath17 to i8*
call i32 (i8*, ...) @printf(i8* %var485)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i64*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var486 = bitcast [89 x i8]* @gsxtmmath17 to i8*
call i32 (i8*, ...) @printf(i8* %var486)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, i64*, i64)*}*, {i8*, i8*, double (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, i64*, i64)*}, {i8*, i8*, double (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, i64*, i64)*}, {i8*, i8*, double (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, i64*, i64)*,  double (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64*, i64}*
%arg_p_0 = getelementptr {i64*, i64}, {i64*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64*, i64** %arg_p_0
%arg_p_1 = getelementptr {i64*, i64}, {i64*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2RvdWJsZSxpNjQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, i64*, i64)*}*, {i8*, i8*, double (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, i64*, i64)*}, {i8*, i8*, double (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, i64*, i64)*}, {i8*, i8*, double (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, i64*, i64)*,  double (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath18 = hidden constant [37 x i8] c"vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd\00"
define dllexport fastcc float @vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd__487(i8* %_impz,i8* %_impenv, float* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone488 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}*
%vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 0
%vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr = load {i8*, i8*, float (i8*, i8*, float*, i64)*}***, {i8*, i8*, float (i8*, i8*, float*, i64)*}**** %vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr_

; setup arguments
%bufPtr = alloca float*
store float* %buf, float** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%val489 = load float*, float** %bufPtr
%val490 = load i64, i64* %lenPtr
%res491 = call fastcc float @vsum_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd(float* %val489, i64 %val490)
%val492 = load i64, i64* %lenPtr
%val493 = sitofp i64 %val492 to float
%val494 = fdiv float %res491, %val493
ret float %val494
}
@gsxtmmath19 = hidden constant [90 x i8] c"vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, float*, i64)*}** @vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone514 = load i8*, i8** %_impzPtr
%zone515 = bitcast i8* %tzone514 to %mzone*

; let assign value to symbol vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd
%dat_vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone515, i64 8)
%vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr = bitcast i8* %dat_vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd to { i8*, i8*, float (i8*, i8*, float*, i64)*}***
%tzone495 = load i8*, i8** %_impzPtr
%zone496 = bitcast i8* %tzone495 to %mzone*
call void @llvm_zone_mark(%mzone* %zone496)
; malloc closure structure
%clsptr497 = call i8* @llvm_zone_malloc(%mzone* %zone496, i64 24)
%closure498 = bitcast i8* %clsptr497 to { i8*, i8*, float (i8*, i8*, float*, i64)*}*

; malloc environment structure
%envptr499 = call i8* @llvm_zone_malloc(%mzone* %zone496, i64 8)
%environment500 = bitcast i8* %envptr499 to {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}*

; malloc closure address table
%addytable501 = call %clsvar* @new_address_table()
%var502 = bitcast [37 x i8]* @gsxtmmath18 to i8*
%var503 = bitcast [45 x i8]* @gsxtmmath7 to i8*
%addytable504 = call %clsvar* @add_address_table(%mzone* %zone496, i8* %var502, i32 0, i8* %var503, i32 3, %clsvar* %addytable501)
%address-table505 = bitcast %clsvar* %addytable504 to i8*

; insert table, function and environment into closure struct
%closure.table508 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure498, i32 0, i32 0
store i8* %address-table505, i8** %closure.table508
%closure.env509 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure498, i32 0, i32 1
store i8* %envptr499, i8** %closure.env509
%closure.func510 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure498, i32 0, i32 2
store float (i8*, i8*, float*, i64)* @vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd__487, float (i8*, i8*, float*, i64)** %closure.func510
%closure_size511 = call i64 @llvm_zone_mark_size(%mzone* %zone496)
call void @llvm_zone_ptr_set_size(i8* %clsptr497, i64 %closure_size511)
%wrapper_ptr512 = call i8* @llvm_zone_malloc(%mzone* %zone496, i64 8)
%closure_wrapper513 = bitcast i8* %wrapper_ptr512 to { i8*, i8*, float (i8*, i8*, float*, i64)*}**
store { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure498, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper513

; let value assignment
%vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd = select i1 true, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper513, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper513
store { i8*, i8*, float (i8*, i8*, float*, i64)*}** %vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd, { i8*, i8*, float (i8*, i8*, float*, i64)*}*** %vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr

; add data to environment
; don't need to alloc for env var vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd
%tmp_envptr507 = getelementptr {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}* %environment500, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, float*, i64)*}*** %vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr, {i8*, i8*, float (i8*, i8*, float*, i64)*}**** %tmp_envptr507


%val516 = load {i8*, i8*, float (i8*, i8*, float*, i64)*}**, {i8*, i8*, float (i8*, i8*, float*, i64)*}*** %vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr
ret {i8*, i8*, float (i8*, i8*, float*, i64)*}** %val516
}


@vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, float*, i64)*}** @vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret float %result
}


define dllexport ccc float @vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_native(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret float %result
}


define dllexport ccc i8*  @vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var517 = bitcast [90 x i8]* @gsxtmmath19 to i8*
call i32 (i8*, ...) @printf(i8* %var517)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var518 = bitcast [90 x i8]* @gsxtmmath19 to i8*
call i32 (i8*, ...) @printf(i8* %var518)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64}*
%arg_p_0 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath20 = hidden constant [40 x i8] c"vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0\00"
define dllexport fastcc double @vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0__519(i8* %_impz,i8* %_impenv, double* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone520 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}*
%vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}* %impenv, i32 0, i32 0
%vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr = load {i8*, i8*, double (i8*, i8*, double*, i64)*}***, {i8*, i8*, double (i8*, i8*, double*, i64)*}**** %vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr_

; setup arguments
%bufPtr = alloca double*
store double* %buf, double** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%val521 = load double*, double** %bufPtr
%val522 = load i64, i64* %lenPtr
%res523 = call fastcc double @vsum_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0(double* %val521, i64 %val522)
%val524 = load i64, i64* %lenPtr
%val525 = sitofp i64 %val524 to double
%val526 = fdiv double %res523, %val525
ret double %val526
}
@gsxtmmath21 = hidden constant [93 x i8] c"vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, double*, i64)*}** @vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone546 = load i8*, i8** %_impzPtr
%zone547 = bitcast i8* %tzone546 to %mzone*

; let assign value to symbol vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0
%dat_vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone547, i64 8)
%vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr = bitcast i8* %dat_vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 to { i8*, i8*, double (i8*, i8*, double*, i64)*}***
%tzone527 = load i8*, i8** %_impzPtr
%zone528 = bitcast i8* %tzone527 to %mzone*
call void @llvm_zone_mark(%mzone* %zone528)
; malloc closure structure
%clsptr529 = call i8* @llvm_zone_malloc(%mzone* %zone528, i64 24)
%closure530 = bitcast i8* %clsptr529 to { i8*, i8*, double (i8*, i8*, double*, i64)*}*

; malloc environment structure
%envptr531 = call i8* @llvm_zone_malloc(%mzone* %zone528, i64 8)
%environment532 = bitcast i8* %envptr531 to {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}*

; malloc closure address table
%addytable533 = call %clsvar* @new_address_table()
%var534 = bitcast [40 x i8]* @gsxtmmath20 to i8*
%var535 = bitcast [47 x i8]* @gsxtmmath10 to i8*
%addytable536 = call %clsvar* @add_address_table(%mzone* %zone528, i8* %var534, i32 0, i8* %var535, i32 3, %clsvar* %addytable533)
%address-table537 = bitcast %clsvar* %addytable536 to i8*

; insert table, function and environment into closure struct
%closure.table540 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure530, i32 0, i32 0
store i8* %address-table537, i8** %closure.table540
%closure.env541 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure530, i32 0, i32 1
store i8* %envptr531, i8** %closure.env541
%closure.func542 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure530, i32 0, i32 2
store double (i8*, i8*, double*, i64)* @vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0__519, double (i8*, i8*, double*, i64)** %closure.func542
%closure_size543 = call i64 @llvm_zone_mark_size(%mzone* %zone528)
call void @llvm_zone_ptr_set_size(i8* %clsptr529, i64 %closure_size543)
%wrapper_ptr544 = call i8* @llvm_zone_malloc(%mzone* %zone528, i64 8)
%closure_wrapper545 = bitcast i8* %wrapper_ptr544 to { i8*, i8*, double (i8*, i8*, double*, i64)*}**
store { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure530, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper545

; let value assignment
%vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 = select i1 true, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper545, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper545
store { i8*, i8*, double (i8*, i8*, double*, i64)*}** %vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0, { i8*, i8*, double (i8*, i8*, double*, i64)*}*** %vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0
%tmp_envptr539 = getelementptr {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}* %environment532, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, double*, i64)*}*** %vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr, {i8*, i8*, double (i8*, i8*, double*, i64)*}**** %tmp_envptr539


%val548 = load {i8*, i8*, double (i8*, i8*, double*, i64)*}**, {i8*, i8*, double (i8*, i8*, double*, i64)*}*** %vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr
ret {i8*, i8*, double (i8*, i8*, double*, i64)*}** %val548
}


@vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, double*, i64)*}** @vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret double %result
}


define dllexport ccc double @vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_native(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret double %result
}


define dllexport ccc i8*  @vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var549 = bitcast [93 x i8]* @gsxtmmath21 to i8*
call i32 (i8*, ...) @printf(i8* %var549)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var550 = bitcast [93 x i8]* @gsxtmmath21 to i8*
call i32 (i8*, ...) @printf(i8* %var550)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, i64}*
%arg_p_0 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmean_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath22 = hidden constant [31 x i8] c"vmin_adhoc_W2kzMixpMzIqLGk2NF0\00"
define dllexport fastcc i32 @vmin_adhoc_W2kzMixpMzIqLGk2NF0__551(i8* %_impz,i8* %_impenv, i32* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone552 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***}*
%vmin_adhoc_W2kzMixpMzIqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***}, {{i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***}* %impenv, i32 0, i32 0
%vmin_adhoc_W2kzMixpMzIqLGk2NF0Ptr = load {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**** %vmin_adhoc_W2kzMixpMzIqLGk2NF0Ptr_

; setup arguments
%bufPtr = alloca i32*
store i32* %buf, i32** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone556 = load i8*, i8** %_impzPtr
%zone557 = bitcast i8* %tzone556 to %mzone*

; let assign value to symbol min_val
%min_valPtr = alloca i32
%tzone558 = load i8*, i8** %_impzPtr
%zone559 = bitcast i8* %tzone558 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val553 = load i32*, i32** %bufPtr
; pointer ref
%val554 = getelementptr i32, i32* %val553, i64 0
%val555 = load i32, i32* %val554

; let value assignment
%min_val = select i1 true, i32 %val555, i32 %val555
store i32 %min_val, i32* %min_valPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; promote local stack var allocations
%tzone580 = load i8*, i8** %_impzPtr
%zone581 = bitcast i8* %tzone580 to %mzone*
%ifptr563 = alloca i32
; setup loop
%val562 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val575 = load i64, i64* %iPtr
%num576 = add i64 %val562, %val575
%comp577 = icmp ult i64 %val562, 1
br i1 %comp577, label %after560, label %loop560

loop560:
%val564 = load i64, i64* %iPtr
%val565 = load i32*, i32** %bufPtr
; pointer ref
%val566 = getelementptr i32, i32* %val565, i64 %val564
%val567 = load i32, i32* %val566
%val568 = load i32, i32* %min_valPtr
%cmp569 = icmp slt i32 %val567, %val568
br i1 %cmp569, label %then563, label %else563

then563:
; do set!
%val570 = load i64, i64* %iPtr
%val571 = load i32*, i32** %bufPtr
; pointer ref
%val572 = getelementptr i32, i32* %val571, i64 %val570
%val573 = load i32, i32* %val572
store i32 %val573, i32* %min_valPtr
store i32 %val573, i32* %ifptr563
br label %ifcont563

else563:
br label %ifcont563

ifcont563:
%ifres574 = load i32, i32* %ifptr563

%loop_cnt560 = load i64, i64* %iPtr
%next560 = add i64 %loop_cnt560, 1
store i64 %next560, i64* %iPtr
%cmp560 = icmp ult i64 %next560, %num576
br i1 %cmp560, label %loop560, label %after560

after560:
%val579 = load i32, i32* %min_valPtr
ret i32 %val579
}
@gsxtmmath23 = hidden constant [84 x i8] c"vmin_adhoc_W2kzMixpMzIqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** @vmin_adhoc_W2kzMixpMzIqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone601 = load i8*, i8** %_impzPtr
%zone602 = bitcast i8* %tzone601 to %mzone*

; let assign value to symbol vmin_adhoc_W2kzMixpMzIqLGk2NF0
%dat_vmin_adhoc_W2kzMixpMzIqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone602, i64 8)
%vmin_adhoc_W2kzMixpMzIqLGk2NF0Ptr = bitcast i8* %dat_vmin_adhoc_W2kzMixpMzIqLGk2NF0 to { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***
%tzone582 = load i8*, i8** %_impzPtr
%zone583 = bitcast i8* %tzone582 to %mzone*
call void @llvm_zone_mark(%mzone* %zone583)
; malloc closure structure
%clsptr584 = call i8* @llvm_zone_malloc(%mzone* %zone583, i64 24)
%closure585 = bitcast i8* %clsptr584 to { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*

; malloc environment structure
%envptr586 = call i8* @llvm_zone_malloc(%mzone* %zone583, i64 8)
%environment587 = bitcast i8* %envptr586 to {{i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***}*

; malloc closure address table
%addytable588 = call %clsvar* @new_address_table()
%var589 = bitcast [31 x i8]* @gsxtmmath22 to i8*
%var590 = bitcast [41 x i8]* @gsxtmmath1 to i8*
%addytable591 = call %clsvar* @add_address_table(%mzone* %zone583, i8* %var589, i32 0, i8* %var590, i32 3, %clsvar* %addytable588)
%address-table592 = bitcast %clsvar* %addytable591 to i8*

; insert table, function and environment into closure struct
%closure.table595 = getelementptr { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure585, i32 0, i32 0
store i8* %address-table592, i8** %closure.table595
%closure.env596 = getelementptr { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure585, i32 0, i32 1
store i8* %envptr586, i8** %closure.env596
%closure.func597 = getelementptr { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure585, i32 0, i32 2
store i32 (i8*, i8*, i32*, i64)* @vmin_adhoc_W2kzMixpMzIqLGk2NF0__551, i32 (i8*, i8*, i32*, i64)** %closure.func597
%closure_size598 = call i64 @llvm_zone_mark_size(%mzone* %zone583)
call void @llvm_zone_ptr_set_size(i8* %clsptr584, i64 %closure_size598)
%wrapper_ptr599 = call i8* @llvm_zone_malloc(%mzone* %zone583, i64 8)
%closure_wrapper600 = bitcast i8* %wrapper_ptr599 to { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**
store { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure585, { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure_wrapper600

; let value assignment
%vmin_adhoc_W2kzMixpMzIqLGk2NF0 = select i1 true, { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure_wrapper600, { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure_wrapper600
store { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %vmin_adhoc_W2kzMixpMzIqLGk2NF0, { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*** %vmin_adhoc_W2kzMixpMzIqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var vmin_adhoc_W2kzMixpMzIqLGk2NF0
%tmp_envptr594 = getelementptr {{i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***}, {{i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***}* %environment587, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*** %vmin_adhoc_W2kzMixpMzIqLGk2NF0Ptr, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**** %tmp_envptr594


%val603 = load {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*** %vmin_adhoc_W2kzMixpMzIqLGk2NF0Ptr
ret {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %val603
}


@vmin_adhoc_W2kzMixpMzIqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@vmin_adhoc_W2kzMixpMzIqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vmin_adhoc_W2kzMixpMzIqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2kzMixpMzIqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** @vmin_adhoc_W2kzMixpMzIqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vmin_adhoc_W2kzMixpMzIqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vmin_adhoc_W2kzMixpMzIqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2kzMixpMzIqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @vmin_adhoc_W2kzMixpMzIqLGk2NF0(i32* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2kzMixpMzIqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32*, i64)*,  i32 (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
ret i32 %result
}


define dllexport ccc i32 @vmin_adhoc_W2kzMixpMzIqLGk2NF0_native(i32* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2kzMixpMzIqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32*, i64)*,  i32 (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
ret i32 %result
}


define dllexport ccc i8*  @vmin_adhoc_W2kzMixpMzIqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var604 = bitcast [84 x i8]* @gsxtmmath23 to i8*
call i32 (i8*, ...) @printf(i8* %var604)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i32*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var605 = bitcast [84 x i8]* @gsxtmmath23 to i8*
call i32 (i8*, ...) @printf(i8* %var605)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2kzMixpMzIqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32*, i64)*,  i32 (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @vmin_adhoc_W2kzMixpMzIqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32*, i64}*
%arg_p_0 = getelementptr {i32*, i64}, {i32*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i32*, i32** %arg_p_0
%arg_p_1 = getelementptr {i32*, i64}, {i32*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2kzMixpMzIqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32*, i64)*,  i32 (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath24 = hidden constant [31 x i8] c"vmin_adhoc_W2k2NCxpNjQqLGk2NF0\00"
define dllexport fastcc i64 @vmin_adhoc_W2k2NCxpNjQqLGk2NF0__606(i8* %_impz,i8* %_impenv, i64* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone607 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***}*
%vmin_adhoc_W2k2NCxpNjQqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***}, {{i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***}* %impenv, i32 0, i32 0
%vmin_adhoc_W2k2NCxpNjQqLGk2NF0Ptr = load {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**** %vmin_adhoc_W2k2NCxpNjQqLGk2NF0Ptr_

; setup arguments
%bufPtr = alloca i64*
store i64* %buf, i64** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone611 = load i8*, i8** %_impzPtr
%zone612 = bitcast i8* %tzone611 to %mzone*

; let assign value to symbol min_val
%min_valPtr = alloca i64
%tzone613 = load i8*, i8** %_impzPtr
%zone614 = bitcast i8* %tzone613 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val608 = load i64*, i64** %bufPtr
; pointer ref
%val609 = getelementptr i64, i64* %val608, i64 0
%val610 = load i64, i64* %val609

; let value assignment
%min_val = select i1 true, i64 %val610, i64 %val610
store i64 %min_val, i64* %min_valPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; promote local stack var allocations
%tzone635 = load i8*, i8** %_impzPtr
%zone636 = bitcast i8* %tzone635 to %mzone*
%ifptr618 = alloca i64
; setup loop
%val617 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val630 = load i64, i64* %iPtr
%num631 = add i64 %val617, %val630
%comp632 = icmp ult i64 %val617, 1
br i1 %comp632, label %after615, label %loop615

loop615:
%val619 = load i64, i64* %iPtr
%val620 = load i64*, i64** %bufPtr
; pointer ref
%val621 = getelementptr i64, i64* %val620, i64 %val619
%val622 = load i64, i64* %val621
%val623 = load i64, i64* %min_valPtr
%cmp624 = icmp slt i64 %val622, %val623
br i1 %cmp624, label %then618, label %else618

then618:
; do set!
%val625 = load i64, i64* %iPtr
%val626 = load i64*, i64** %bufPtr
; pointer ref
%val627 = getelementptr i64, i64* %val626, i64 %val625
%val628 = load i64, i64* %val627
store i64 %val628, i64* %min_valPtr
store i64 %val628, i64* %ifptr618
br label %ifcont618

else618:
br label %ifcont618

ifcont618:
%ifres629 = load i64, i64* %ifptr618

%loop_cnt615 = load i64, i64* %iPtr
%next615 = add i64 %loop_cnt615, 1
store i64 %next615, i64* %iPtr
%cmp615 = icmp ult i64 %next615, %num631
br i1 %cmp615, label %loop615, label %after615

after615:
%val634 = load i64, i64* %min_valPtr
ret i64 %val634
}
@gsxtmmath25 = hidden constant [84 x i8] c"vmin_adhoc_W2k2NCxpNjQqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** @vmin_adhoc_W2k2NCxpNjQqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone656 = load i8*, i8** %_impzPtr
%zone657 = bitcast i8* %tzone656 to %mzone*

; let assign value to symbol vmin_adhoc_W2k2NCxpNjQqLGk2NF0
%dat_vmin_adhoc_W2k2NCxpNjQqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone657, i64 8)
%vmin_adhoc_W2k2NCxpNjQqLGk2NF0Ptr = bitcast i8* %dat_vmin_adhoc_W2k2NCxpNjQqLGk2NF0 to { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***
%tzone637 = load i8*, i8** %_impzPtr
%zone638 = bitcast i8* %tzone637 to %mzone*
call void @llvm_zone_mark(%mzone* %zone638)
; malloc closure structure
%clsptr639 = call i8* @llvm_zone_malloc(%mzone* %zone638, i64 24)
%closure640 = bitcast i8* %clsptr639 to { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*

; malloc environment structure
%envptr641 = call i8* @llvm_zone_malloc(%mzone* %zone638, i64 8)
%environment642 = bitcast i8* %envptr641 to {{i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***}*

; malloc closure address table
%addytable643 = call %clsvar* @new_address_table()
%var644 = bitcast [31 x i8]* @gsxtmmath24 to i8*
%var645 = bitcast [41 x i8]* @gsxtmmath4 to i8*
%addytable646 = call %clsvar* @add_address_table(%mzone* %zone638, i8* %var644, i32 0, i8* %var645, i32 3, %clsvar* %addytable643)
%address-table647 = bitcast %clsvar* %addytable646 to i8*

; insert table, function and environment into closure struct
%closure.table650 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure640, i32 0, i32 0
store i8* %address-table647, i8** %closure.table650
%closure.env651 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure640, i32 0, i32 1
store i8* %envptr641, i8** %closure.env651
%closure.func652 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure640, i32 0, i32 2
store i64 (i8*, i8*, i64*, i64)* @vmin_adhoc_W2k2NCxpNjQqLGk2NF0__606, i64 (i8*, i8*, i64*, i64)** %closure.func652
%closure_size653 = call i64 @llvm_zone_mark_size(%mzone* %zone638)
call void @llvm_zone_ptr_set_size(i8* %clsptr639, i64 %closure_size653)
%wrapper_ptr654 = call i8* @llvm_zone_malloc(%mzone* %zone638, i64 8)
%closure_wrapper655 = bitcast i8* %wrapper_ptr654 to { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**
store { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure640, { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure_wrapper655

; let value assignment
%vmin_adhoc_W2k2NCxpNjQqLGk2NF0 = select i1 true, { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure_wrapper655, { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure_wrapper655
store { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %vmin_adhoc_W2k2NCxpNjQqLGk2NF0, { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*** %vmin_adhoc_W2k2NCxpNjQqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var vmin_adhoc_W2k2NCxpNjQqLGk2NF0
%tmp_envptr649 = getelementptr {{i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***}, {{i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***}* %environment642, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*** %vmin_adhoc_W2k2NCxpNjQqLGk2NF0Ptr, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**** %tmp_envptr649


%val658 = load {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*** %vmin_adhoc_W2k2NCxpNjQqLGk2NF0Ptr
ret {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %val658
}


@vmin_adhoc_W2k2NCxpNjQqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@vmin_adhoc_W2k2NCxpNjQqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vmin_adhoc_W2k2NCxpNjQqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2k2NCxpNjQqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** @vmin_adhoc_W2k2NCxpNjQqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vmin_adhoc_W2k2NCxpNjQqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vmin_adhoc_W2k2NCxpNjQqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2k2NCxpNjQqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @vmin_adhoc_W2k2NCxpNjQqLGk2NF0(i64* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2k2NCxpNjQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64*, i64)*,  i64 (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
ret i64 %result
}


define dllexport ccc i64 @vmin_adhoc_W2k2NCxpNjQqLGk2NF0_native(i64* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2k2NCxpNjQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64*, i64)*,  i64 (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
ret i64 %result
}


define dllexport ccc i8*  @vmin_adhoc_W2k2NCxpNjQqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var659 = bitcast [84 x i8]* @gsxtmmath25 to i8*
call i32 (i8*, ...) @printf(i8* %var659)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i64*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var660 = bitcast [84 x i8]* @gsxtmmath25 to i8*
call i32 (i8*, ...) @printf(i8* %var660)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2k2NCxpNjQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64*, i64)*,  i64 (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @vmin_adhoc_W2k2NCxpNjQqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64*, i64}*
%arg_p_0 = getelementptr {i64*, i64}, {i64*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64*, i64** %arg_p_0
%arg_p_1 = getelementptr {i64*, i64}, {i64*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2k2NCxpNjQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64*, i64)*,  i64 (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath26 = hidden constant [36 x i8] c"vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd\00"
define dllexport fastcc float @vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd__661(i8* %_impz,i8* %_impenv, float* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone662 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}*
%vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 0
%vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr = load {i8*, i8*, float (i8*, i8*, float*, i64)*}***, {i8*, i8*, float (i8*, i8*, float*, i64)*}**** %vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr_

; setup arguments
%bufPtr = alloca float*
store float* %buf, float** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone666 = load i8*, i8** %_impzPtr
%zone667 = bitcast i8* %tzone666 to %mzone*

; let assign value to symbol min_val
%min_valPtr = alloca float
%tzone668 = load i8*, i8** %_impzPtr
%zone669 = bitcast i8* %tzone668 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val663 = load float*, float** %bufPtr
; pointer ref
%val664 = getelementptr float, float* %val663, i64 0
%val665 = load float, float* %val664

; let value assignment
%min_val = select i1 true, float %val665, float %val665
store float %min_val, float* %min_valPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; promote local stack var allocations
%tzone690 = load i8*, i8** %_impzPtr
%zone691 = bitcast i8* %tzone690 to %mzone*
%ifptr673 = alloca float
; setup loop
%val672 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val685 = load i64, i64* %iPtr
%num686 = add i64 %val672, %val685
%comp687 = icmp ult i64 %val672, 1
br i1 %comp687, label %after670, label %loop670

loop670:
%val674 = load i64, i64* %iPtr
%val675 = load float*, float** %bufPtr
; pointer ref
%val676 = getelementptr float, float* %val675, i64 %val674
%val677 = load float, float* %val676
%val678 = load float, float* %min_valPtr
%cmp679 = fcmp ult float %val677, %val678
br i1 %cmp679, label %then673, label %else673

then673:
; do set!
%val680 = load i64, i64* %iPtr
%val681 = load float*, float** %bufPtr
; pointer ref
%val682 = getelementptr float, float* %val681, i64 %val680
%val683 = load float, float* %val682
store float %val683, float* %min_valPtr
store float %val683, float* %ifptr673
br label %ifcont673

else673:
br label %ifcont673

ifcont673:
%ifres684 = load float, float* %ifptr673

%loop_cnt670 = load i64, i64* %iPtr
%next670 = add i64 %loop_cnt670, 1
store i64 %next670, i64* %iPtr
%cmp670 = icmp ult i64 %next670, %num686
br i1 %cmp670, label %loop670, label %after670

after670:
%val689 = load float, float* %min_valPtr
ret float %val689
}
@gsxtmmath27 = hidden constant [89 x i8] c"vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, float*, i64)*}** @vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone711 = load i8*, i8** %_impzPtr
%zone712 = bitcast i8* %tzone711 to %mzone*

; let assign value to symbol vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd
%dat_vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone712, i64 8)
%vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr = bitcast i8* %dat_vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd to { i8*, i8*, float (i8*, i8*, float*, i64)*}***
%tzone692 = load i8*, i8** %_impzPtr
%zone693 = bitcast i8* %tzone692 to %mzone*
call void @llvm_zone_mark(%mzone* %zone693)
; malloc closure structure
%clsptr694 = call i8* @llvm_zone_malloc(%mzone* %zone693, i64 24)
%closure695 = bitcast i8* %clsptr694 to { i8*, i8*, float (i8*, i8*, float*, i64)*}*

; malloc environment structure
%envptr696 = call i8* @llvm_zone_malloc(%mzone* %zone693, i64 8)
%environment697 = bitcast i8* %envptr696 to {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}*

; malloc closure address table
%addytable698 = call %clsvar* @new_address_table()
%var699 = bitcast [36 x i8]* @gsxtmmath26 to i8*
%var700 = bitcast [45 x i8]* @gsxtmmath7 to i8*
%addytable701 = call %clsvar* @add_address_table(%mzone* %zone693, i8* %var699, i32 0, i8* %var700, i32 3, %clsvar* %addytable698)
%address-table702 = bitcast %clsvar* %addytable701 to i8*

; insert table, function and environment into closure struct
%closure.table705 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure695, i32 0, i32 0
store i8* %address-table702, i8** %closure.table705
%closure.env706 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure695, i32 0, i32 1
store i8* %envptr696, i8** %closure.env706
%closure.func707 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure695, i32 0, i32 2
store float (i8*, i8*, float*, i64)* @vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd__661, float (i8*, i8*, float*, i64)** %closure.func707
%closure_size708 = call i64 @llvm_zone_mark_size(%mzone* %zone693)
call void @llvm_zone_ptr_set_size(i8* %clsptr694, i64 %closure_size708)
%wrapper_ptr709 = call i8* @llvm_zone_malloc(%mzone* %zone693, i64 8)
%closure_wrapper710 = bitcast i8* %wrapper_ptr709 to { i8*, i8*, float (i8*, i8*, float*, i64)*}**
store { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure695, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper710

; let value assignment
%vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd = select i1 true, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper710, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper710
store { i8*, i8*, float (i8*, i8*, float*, i64)*}** %vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd, { i8*, i8*, float (i8*, i8*, float*, i64)*}*** %vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr

; add data to environment
; don't need to alloc for env var vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd
%tmp_envptr704 = getelementptr {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}* %environment697, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, float*, i64)*}*** %vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr, {i8*, i8*, float (i8*, i8*, float*, i64)*}**** %tmp_envptr704


%val713 = load {i8*, i8*, float (i8*, i8*, float*, i64)*}**, {i8*, i8*, float (i8*, i8*, float*, i64)*}*** %vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr
ret {i8*, i8*, float (i8*, i8*, float*, i64)*}** %val713
}


@vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, float*, i64)*}** @vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret float %result
}


define dllexport ccc float @vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_native(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret float %result
}


define dllexport ccc i8*  @vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var714 = bitcast [89 x i8]* @gsxtmmath27 to i8*
call i32 (i8*, ...) @printf(i8* %var714)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var715 = bitcast [89 x i8]* @gsxtmmath27 to i8*
call i32 (i8*, ...) @printf(i8* %var715)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64}*
%arg_p_0 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath28 = hidden constant [39 x i8] c"vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0\00"
define dllexport fastcc double @vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0__716(i8* %_impz,i8* %_impenv, double* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone717 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}*
%vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}* %impenv, i32 0, i32 0
%vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr = load {i8*, i8*, double (i8*, i8*, double*, i64)*}***, {i8*, i8*, double (i8*, i8*, double*, i64)*}**** %vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr_

; setup arguments
%bufPtr = alloca double*
store double* %buf, double** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone721 = load i8*, i8** %_impzPtr
%zone722 = bitcast i8* %tzone721 to %mzone*

; let assign value to symbol min_val
%min_valPtr = alloca double
%tzone723 = load i8*, i8** %_impzPtr
%zone724 = bitcast i8* %tzone723 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val718 = load double*, double** %bufPtr
; pointer ref
%val719 = getelementptr double, double* %val718, i64 0
%val720 = load double, double* %val719

; let value assignment
%min_val = select i1 true, double %val720, double %val720
store double %min_val, double* %min_valPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; promote local stack var allocations
%tzone745 = load i8*, i8** %_impzPtr
%zone746 = bitcast i8* %tzone745 to %mzone*
%ifptr728 = alloca double
; setup loop
%val727 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val740 = load i64, i64* %iPtr
%num741 = add i64 %val727, %val740
%comp742 = icmp ult i64 %val727, 1
br i1 %comp742, label %after725, label %loop725

loop725:
%val729 = load i64, i64* %iPtr
%val730 = load double*, double** %bufPtr
; pointer ref
%val731 = getelementptr double, double* %val730, i64 %val729
%val732 = load double, double* %val731
%val733 = load double, double* %min_valPtr
%cmp734 = fcmp ult double %val732, %val733
br i1 %cmp734, label %then728, label %else728

then728:
; do set!
%val735 = load i64, i64* %iPtr
%val736 = load double*, double** %bufPtr
; pointer ref
%val737 = getelementptr double, double* %val736, i64 %val735
%val738 = load double, double* %val737
store double %val738, double* %min_valPtr
store double %val738, double* %ifptr728
br label %ifcont728

else728:
br label %ifcont728

ifcont728:
%ifres739 = load double, double* %ifptr728

%loop_cnt725 = load i64, i64* %iPtr
%next725 = add i64 %loop_cnt725, 1
store i64 %next725, i64* %iPtr
%cmp725 = icmp ult i64 %next725, %num741
br i1 %cmp725, label %loop725, label %after725

after725:
%val744 = load double, double* %min_valPtr
ret double %val744
}
@gsxtmmath29 = hidden constant [92 x i8] c"vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, double*, i64)*}** @vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone766 = load i8*, i8** %_impzPtr
%zone767 = bitcast i8* %tzone766 to %mzone*

; let assign value to symbol vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0
%dat_vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone767, i64 8)
%vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr = bitcast i8* %dat_vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 to { i8*, i8*, double (i8*, i8*, double*, i64)*}***
%tzone747 = load i8*, i8** %_impzPtr
%zone748 = bitcast i8* %tzone747 to %mzone*
call void @llvm_zone_mark(%mzone* %zone748)
; malloc closure structure
%clsptr749 = call i8* @llvm_zone_malloc(%mzone* %zone748, i64 24)
%closure750 = bitcast i8* %clsptr749 to { i8*, i8*, double (i8*, i8*, double*, i64)*}*

; malloc environment structure
%envptr751 = call i8* @llvm_zone_malloc(%mzone* %zone748, i64 8)
%environment752 = bitcast i8* %envptr751 to {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}*

; malloc closure address table
%addytable753 = call %clsvar* @new_address_table()
%var754 = bitcast [39 x i8]* @gsxtmmath28 to i8*
%var755 = bitcast [47 x i8]* @gsxtmmath10 to i8*
%addytable756 = call %clsvar* @add_address_table(%mzone* %zone748, i8* %var754, i32 0, i8* %var755, i32 3, %clsvar* %addytable753)
%address-table757 = bitcast %clsvar* %addytable756 to i8*

; insert table, function and environment into closure struct
%closure.table760 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure750, i32 0, i32 0
store i8* %address-table757, i8** %closure.table760
%closure.env761 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure750, i32 0, i32 1
store i8* %envptr751, i8** %closure.env761
%closure.func762 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure750, i32 0, i32 2
store double (i8*, i8*, double*, i64)* @vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0__716, double (i8*, i8*, double*, i64)** %closure.func762
%closure_size763 = call i64 @llvm_zone_mark_size(%mzone* %zone748)
call void @llvm_zone_ptr_set_size(i8* %clsptr749, i64 %closure_size763)
%wrapper_ptr764 = call i8* @llvm_zone_malloc(%mzone* %zone748, i64 8)
%closure_wrapper765 = bitcast i8* %wrapper_ptr764 to { i8*, i8*, double (i8*, i8*, double*, i64)*}**
store { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure750, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper765

; let value assignment
%vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 = select i1 true, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper765, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper765
store { i8*, i8*, double (i8*, i8*, double*, i64)*}** %vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0, { i8*, i8*, double (i8*, i8*, double*, i64)*}*** %vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0
%tmp_envptr759 = getelementptr {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}* %environment752, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, double*, i64)*}*** %vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr, {i8*, i8*, double (i8*, i8*, double*, i64)*}**** %tmp_envptr759


%val768 = load {i8*, i8*, double (i8*, i8*, double*, i64)*}**, {i8*, i8*, double (i8*, i8*, double*, i64)*}*** %vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr
ret {i8*, i8*, double (i8*, i8*, double*, i64)*}** %val768
}


@vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, double*, i64)*}** @vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret double %result
}


define dllexport ccc double @vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_native(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret double %result
}


define dllexport ccc i8*  @vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var769 = bitcast [92 x i8]* @gsxtmmath29 to i8*
call i32 (i8*, ...) @printf(i8* %var769)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var770 = bitcast [92 x i8]* @gsxtmmath29 to i8*
call i32 (i8*, ...) @printf(i8* %var770)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, i64}*
%arg_p_0 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmin_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath30 = hidden constant [31 x i8] c"vmax_adhoc_W2kzMixpMzIqLGk2NF0\00"
define dllexport fastcc i32 @vmax_adhoc_W2kzMixpMzIqLGk2NF0__771(i8* %_impz,i8* %_impenv, i32* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone772 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***}*
%vmax_adhoc_W2kzMixpMzIqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***}, {{i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***}* %impenv, i32 0, i32 0
%vmax_adhoc_W2kzMixpMzIqLGk2NF0Ptr = load {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**** %vmax_adhoc_W2kzMixpMzIqLGk2NF0Ptr_

; setup arguments
%bufPtr = alloca i32*
store i32* %buf, i32** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone776 = load i8*, i8** %_impzPtr
%zone777 = bitcast i8* %tzone776 to %mzone*

; let assign value to symbol max_val
%max_valPtr = alloca i32
%tzone778 = load i8*, i8** %_impzPtr
%zone779 = bitcast i8* %tzone778 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val773 = load i32*, i32** %bufPtr
; pointer ref
%val774 = getelementptr i32, i32* %val773, i64 0
%val775 = load i32, i32* %val774

; let value assignment
%max_val = select i1 true, i32 %val775, i32 %val775
store i32 %max_val, i32* %max_valPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; promote local stack var allocations
%tzone800 = load i8*, i8** %_impzPtr
%zone801 = bitcast i8* %tzone800 to %mzone*
%ifptr783 = alloca i32
; setup loop
%val782 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val795 = load i64, i64* %iPtr
%num796 = add i64 %val782, %val795
%comp797 = icmp ult i64 %val782, 1
br i1 %comp797, label %after780, label %loop780

loop780:
%val784 = load i64, i64* %iPtr
%val785 = load i32*, i32** %bufPtr
; pointer ref
%val786 = getelementptr i32, i32* %val785, i64 %val784
%val787 = load i32, i32* %val786
%val788 = load i32, i32* %max_valPtr
%cmp789 = icmp sgt i32 %val787, %val788
br i1 %cmp789, label %then783, label %else783

then783:
; do set!
%val790 = load i64, i64* %iPtr
%val791 = load i32*, i32** %bufPtr
; pointer ref
%val792 = getelementptr i32, i32* %val791, i64 %val790
%val793 = load i32, i32* %val792
store i32 %val793, i32* %max_valPtr
store i32 %val793, i32* %ifptr783
br label %ifcont783

else783:
br label %ifcont783

ifcont783:
%ifres794 = load i32, i32* %ifptr783

%loop_cnt780 = load i64, i64* %iPtr
%next780 = add i64 %loop_cnt780, 1
store i64 %next780, i64* %iPtr
%cmp780 = icmp ult i64 %next780, %num796
br i1 %cmp780, label %loop780, label %after780

after780:
%val799 = load i32, i32* %max_valPtr
ret i32 %val799
}
@gsxtmmath31 = hidden constant [84 x i8] c"vmax_adhoc_W2kzMixpMzIqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** @vmax_adhoc_W2kzMixpMzIqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone821 = load i8*, i8** %_impzPtr
%zone822 = bitcast i8* %tzone821 to %mzone*

; let assign value to symbol vmax_adhoc_W2kzMixpMzIqLGk2NF0
%dat_vmax_adhoc_W2kzMixpMzIqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone822, i64 8)
%vmax_adhoc_W2kzMixpMzIqLGk2NF0Ptr = bitcast i8* %dat_vmax_adhoc_W2kzMixpMzIqLGk2NF0 to { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***
%tzone802 = load i8*, i8** %_impzPtr
%zone803 = bitcast i8* %tzone802 to %mzone*
call void @llvm_zone_mark(%mzone* %zone803)
; malloc closure structure
%clsptr804 = call i8* @llvm_zone_malloc(%mzone* %zone803, i64 24)
%closure805 = bitcast i8* %clsptr804 to { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*

; malloc environment structure
%envptr806 = call i8* @llvm_zone_malloc(%mzone* %zone803, i64 8)
%environment807 = bitcast i8* %envptr806 to {{i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***}*

; malloc closure address table
%addytable808 = call %clsvar* @new_address_table()
%var809 = bitcast [31 x i8]* @gsxtmmath30 to i8*
%var810 = bitcast [41 x i8]* @gsxtmmath1 to i8*
%addytable811 = call %clsvar* @add_address_table(%mzone* %zone803, i8* %var809, i32 0, i8* %var810, i32 3, %clsvar* %addytable808)
%address-table812 = bitcast %clsvar* %addytable811 to i8*

; insert table, function and environment into closure struct
%closure.table815 = getelementptr { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure805, i32 0, i32 0
store i8* %address-table812, i8** %closure.table815
%closure.env816 = getelementptr { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure805, i32 0, i32 1
store i8* %envptr806, i8** %closure.env816
%closure.func817 = getelementptr { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure805, i32 0, i32 2
store i32 (i8*, i8*, i32*, i64)* @vmax_adhoc_W2kzMixpMzIqLGk2NF0__771, i32 (i8*, i8*, i32*, i64)** %closure.func817
%closure_size818 = call i64 @llvm_zone_mark_size(%mzone* %zone803)
call void @llvm_zone_ptr_set_size(i8* %clsptr804, i64 %closure_size818)
%wrapper_ptr819 = call i8* @llvm_zone_malloc(%mzone* %zone803, i64 8)
%closure_wrapper820 = bitcast i8* %wrapper_ptr819 to { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**
store { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure805, { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure_wrapper820

; let value assignment
%vmax_adhoc_W2kzMixpMzIqLGk2NF0 = select i1 true, { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure_wrapper820, { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure_wrapper820
store { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %vmax_adhoc_W2kzMixpMzIqLGk2NF0, { i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*** %vmax_adhoc_W2kzMixpMzIqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var vmax_adhoc_W2kzMixpMzIqLGk2NF0
%tmp_envptr814 = getelementptr {{i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***}, {{i8*, i8*, i32 (i8*, i8*, i32*, i64)*}***}* %environment807, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*** %vmax_adhoc_W2kzMixpMzIqLGk2NF0Ptr, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**** %tmp_envptr814


%val823 = load {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*** %vmax_adhoc_W2kzMixpMzIqLGk2NF0Ptr
ret {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %val823
}


@vmax_adhoc_W2kzMixpMzIqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@vmax_adhoc_W2kzMixpMzIqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vmax_adhoc_W2kzMixpMzIqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2kzMixpMzIqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** @vmax_adhoc_W2kzMixpMzIqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vmax_adhoc_W2kzMixpMzIqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vmax_adhoc_W2kzMixpMzIqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2kzMixpMzIqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @vmax_adhoc_W2kzMixpMzIqLGk2NF0(i32* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2kzMixpMzIqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32*, i64)*,  i32 (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
ret i32 %result
}


define dllexport ccc i32 @vmax_adhoc_W2kzMixpMzIqLGk2NF0_native(i32* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2kzMixpMzIqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32*, i64)*,  i32 (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
ret i32 %result
}


define dllexport ccc i8*  @vmax_adhoc_W2kzMixpMzIqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var824 = bitcast [84 x i8]* @gsxtmmath31 to i8*
call i32 (i8*, ...) @printf(i8* %var824)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i32*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var825 = bitcast [84 x i8]* @gsxtmmath31 to i8*
call i32 (i8*, ...) @printf(i8* %var825)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2kzMixpMzIqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32*, i64)*,  i32 (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @vmax_adhoc_W2kzMixpMzIqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32*, i64}*
%arg_p_0 = getelementptr {i32*, i64}, {i32*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i32*, i32** %arg_p_0
%arg_p_1 = getelementptr {i32*, i64}, {i32*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2kzMixpMzIqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}*, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32 (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32*, i64)*,  i32 (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath32 = hidden constant [31 x i8] c"vmax_adhoc_W2k2NCxpNjQqLGk2NF0\00"
define dllexport fastcc i64 @vmax_adhoc_W2k2NCxpNjQqLGk2NF0__826(i8* %_impz,i8* %_impenv, i64* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone827 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***}*
%vmax_adhoc_W2k2NCxpNjQqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***}, {{i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***}* %impenv, i32 0, i32 0
%vmax_adhoc_W2k2NCxpNjQqLGk2NF0Ptr = load {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**** %vmax_adhoc_W2k2NCxpNjQqLGk2NF0Ptr_

; setup arguments
%bufPtr = alloca i64*
store i64* %buf, i64** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone831 = load i8*, i8** %_impzPtr
%zone832 = bitcast i8* %tzone831 to %mzone*

; let assign value to symbol max_val
%max_valPtr = alloca i64
%tzone833 = load i8*, i8** %_impzPtr
%zone834 = bitcast i8* %tzone833 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val828 = load i64*, i64** %bufPtr
; pointer ref
%val829 = getelementptr i64, i64* %val828, i64 0
%val830 = load i64, i64* %val829

; let value assignment
%max_val = select i1 true, i64 %val830, i64 %val830
store i64 %max_val, i64* %max_valPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; promote local stack var allocations
%tzone855 = load i8*, i8** %_impzPtr
%zone856 = bitcast i8* %tzone855 to %mzone*
%ifptr838 = alloca i64
; setup loop
%val837 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val850 = load i64, i64* %iPtr
%num851 = add i64 %val837, %val850
%comp852 = icmp ult i64 %val837, 1
br i1 %comp852, label %after835, label %loop835

loop835:
%val839 = load i64, i64* %iPtr
%val840 = load i64*, i64** %bufPtr
; pointer ref
%val841 = getelementptr i64, i64* %val840, i64 %val839
%val842 = load i64, i64* %val841
%val843 = load i64, i64* %max_valPtr
%cmp844 = icmp sgt i64 %val842, %val843
br i1 %cmp844, label %then838, label %else838

then838:
; do set!
%val845 = load i64, i64* %iPtr
%val846 = load i64*, i64** %bufPtr
; pointer ref
%val847 = getelementptr i64, i64* %val846, i64 %val845
%val848 = load i64, i64* %val847
store i64 %val848, i64* %max_valPtr
store i64 %val848, i64* %ifptr838
br label %ifcont838

else838:
br label %ifcont838

ifcont838:
%ifres849 = load i64, i64* %ifptr838

%loop_cnt835 = load i64, i64* %iPtr
%next835 = add i64 %loop_cnt835, 1
store i64 %next835, i64* %iPtr
%cmp835 = icmp ult i64 %next835, %num851
br i1 %cmp835, label %loop835, label %after835

after835:
%val854 = load i64, i64* %max_valPtr
ret i64 %val854
}
@gsxtmmath33 = hidden constant [84 x i8] c"vmax_adhoc_W2k2NCxpNjQqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** @vmax_adhoc_W2k2NCxpNjQqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone876 = load i8*, i8** %_impzPtr
%zone877 = bitcast i8* %tzone876 to %mzone*

; let assign value to symbol vmax_adhoc_W2k2NCxpNjQqLGk2NF0
%dat_vmax_adhoc_W2k2NCxpNjQqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone877, i64 8)
%vmax_adhoc_W2k2NCxpNjQqLGk2NF0Ptr = bitcast i8* %dat_vmax_adhoc_W2k2NCxpNjQqLGk2NF0 to { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***
%tzone857 = load i8*, i8** %_impzPtr
%zone858 = bitcast i8* %tzone857 to %mzone*
call void @llvm_zone_mark(%mzone* %zone858)
; malloc closure structure
%clsptr859 = call i8* @llvm_zone_malloc(%mzone* %zone858, i64 24)
%closure860 = bitcast i8* %clsptr859 to { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*

; malloc environment structure
%envptr861 = call i8* @llvm_zone_malloc(%mzone* %zone858, i64 8)
%environment862 = bitcast i8* %envptr861 to {{i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***}*

; malloc closure address table
%addytable863 = call %clsvar* @new_address_table()
%var864 = bitcast [31 x i8]* @gsxtmmath32 to i8*
%var865 = bitcast [41 x i8]* @gsxtmmath4 to i8*
%addytable866 = call %clsvar* @add_address_table(%mzone* %zone858, i8* %var864, i32 0, i8* %var865, i32 3, %clsvar* %addytable863)
%address-table867 = bitcast %clsvar* %addytable866 to i8*

; insert table, function and environment into closure struct
%closure.table870 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure860, i32 0, i32 0
store i8* %address-table867, i8** %closure.table870
%closure.env871 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure860, i32 0, i32 1
store i8* %envptr861, i8** %closure.env871
%closure.func872 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure860, i32 0, i32 2
store i64 (i8*, i8*, i64*, i64)* @vmax_adhoc_W2k2NCxpNjQqLGk2NF0__826, i64 (i8*, i8*, i64*, i64)** %closure.func872
%closure_size873 = call i64 @llvm_zone_mark_size(%mzone* %zone858)
call void @llvm_zone_ptr_set_size(i8* %clsptr859, i64 %closure_size873)
%wrapper_ptr874 = call i8* @llvm_zone_malloc(%mzone* %zone858, i64 8)
%closure_wrapper875 = bitcast i8* %wrapper_ptr874 to { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**
store { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure860, { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure_wrapper875

; let value assignment
%vmax_adhoc_W2k2NCxpNjQqLGk2NF0 = select i1 true, { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure_wrapper875, { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure_wrapper875
store { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %vmax_adhoc_W2k2NCxpNjQqLGk2NF0, { i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*** %vmax_adhoc_W2k2NCxpNjQqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var vmax_adhoc_W2k2NCxpNjQqLGk2NF0
%tmp_envptr869 = getelementptr {{i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***}, {{i8*, i8*, i64 (i8*, i8*, i64*, i64)*}***}* %environment862, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*** %vmax_adhoc_W2k2NCxpNjQqLGk2NF0Ptr, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**** %tmp_envptr869


%val878 = load {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*** %vmax_adhoc_W2k2NCxpNjQqLGk2NF0Ptr
ret {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %val878
}


@vmax_adhoc_W2k2NCxpNjQqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@vmax_adhoc_W2k2NCxpNjQqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vmax_adhoc_W2k2NCxpNjQqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2k2NCxpNjQqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** @vmax_adhoc_W2k2NCxpNjQqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vmax_adhoc_W2k2NCxpNjQqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vmax_adhoc_W2k2NCxpNjQqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2k2NCxpNjQqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @vmax_adhoc_W2k2NCxpNjQqLGk2NF0(i64* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2k2NCxpNjQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64*, i64)*,  i64 (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
ret i64 %result
}


define dllexport ccc i64 @vmax_adhoc_W2k2NCxpNjQqLGk2NF0_native(i64* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2k2NCxpNjQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64*, i64)*,  i64 (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
ret i64 %result
}


define dllexport ccc i8*  @vmax_adhoc_W2k2NCxpNjQqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var879 = bitcast [84 x i8]* @gsxtmmath33 to i8*
call i32 (i8*, ...) @printf(i8* %var879)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i64*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var880 = bitcast [84 x i8]* @gsxtmmath33 to i8*
call i32 (i8*, ...) @printf(i8* %var880)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2k2NCxpNjQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64*, i64)*,  i64 (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @vmax_adhoc_W2k2NCxpNjQqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64*, i64}*
%arg_p_0 = getelementptr {i64*, i64}, {i64*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64*, i64** %arg_p_0
%arg_p_1 = getelementptr {i64*, i64}, {i64*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2k2NCxpNjQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}*, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64*, i64)*,  i64 (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath34 = hidden constant [36 x i8] c"vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd\00"
define dllexport fastcc float @vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd__881(i8* %_impz,i8* %_impenv, float* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone882 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}*
%vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 0
%vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr = load {i8*, i8*, float (i8*, i8*, float*, i64)*}***, {i8*, i8*, float (i8*, i8*, float*, i64)*}**** %vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr_

; setup arguments
%bufPtr = alloca float*
store float* %buf, float** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone886 = load i8*, i8** %_impzPtr
%zone887 = bitcast i8* %tzone886 to %mzone*

; let assign value to symbol max_val
%max_valPtr = alloca float
%tzone888 = load i8*, i8** %_impzPtr
%zone889 = bitcast i8* %tzone888 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val883 = load float*, float** %bufPtr
; pointer ref
%val884 = getelementptr float, float* %val883, i64 0
%val885 = load float, float* %val884

; let value assignment
%max_val = select i1 true, float %val885, float %val885
store float %max_val, float* %max_valPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; promote local stack var allocations
%tzone910 = load i8*, i8** %_impzPtr
%zone911 = bitcast i8* %tzone910 to %mzone*
%ifptr893 = alloca float
; setup loop
%val892 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val905 = load i64, i64* %iPtr
%num906 = add i64 %val892, %val905
%comp907 = icmp ult i64 %val892, 1
br i1 %comp907, label %after890, label %loop890

loop890:
%val894 = load i64, i64* %iPtr
%val895 = load float*, float** %bufPtr
; pointer ref
%val896 = getelementptr float, float* %val895, i64 %val894
%val897 = load float, float* %val896
%val898 = load float, float* %max_valPtr
%cmp899 = fcmp ugt float %val897, %val898
br i1 %cmp899, label %then893, label %else893

then893:
; do set!
%val900 = load i64, i64* %iPtr
%val901 = load float*, float** %bufPtr
; pointer ref
%val902 = getelementptr float, float* %val901, i64 %val900
%val903 = load float, float* %val902
store float %val903, float* %max_valPtr
store float %val903, float* %ifptr893
br label %ifcont893

else893:
br label %ifcont893

ifcont893:
%ifres904 = load float, float* %ifptr893

%loop_cnt890 = load i64, i64* %iPtr
%next890 = add i64 %loop_cnt890, 1
store i64 %next890, i64* %iPtr
%cmp890 = icmp ult i64 %next890, %num906
br i1 %cmp890, label %loop890, label %after890

after890:
%val909 = load float, float* %max_valPtr
ret float %val909
}
@gsxtmmath35 = hidden constant [89 x i8] c"vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, float*, i64)*}** @vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone931 = load i8*, i8** %_impzPtr
%zone932 = bitcast i8* %tzone931 to %mzone*

; let assign value to symbol vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd
%dat_vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone932, i64 8)
%vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr = bitcast i8* %dat_vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd to { i8*, i8*, float (i8*, i8*, float*, i64)*}***
%tzone912 = load i8*, i8** %_impzPtr
%zone913 = bitcast i8* %tzone912 to %mzone*
call void @llvm_zone_mark(%mzone* %zone913)
; malloc closure structure
%clsptr914 = call i8* @llvm_zone_malloc(%mzone* %zone913, i64 24)
%closure915 = bitcast i8* %clsptr914 to { i8*, i8*, float (i8*, i8*, float*, i64)*}*

; malloc environment structure
%envptr916 = call i8* @llvm_zone_malloc(%mzone* %zone913, i64 8)
%environment917 = bitcast i8* %envptr916 to {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}*

; malloc closure address table
%addytable918 = call %clsvar* @new_address_table()
%var919 = bitcast [36 x i8]* @gsxtmmath34 to i8*
%var920 = bitcast [45 x i8]* @gsxtmmath7 to i8*
%addytable921 = call %clsvar* @add_address_table(%mzone* %zone913, i8* %var919, i32 0, i8* %var920, i32 3, %clsvar* %addytable918)
%address-table922 = bitcast %clsvar* %addytable921 to i8*

; insert table, function and environment into closure struct
%closure.table925 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure915, i32 0, i32 0
store i8* %address-table922, i8** %closure.table925
%closure.env926 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure915, i32 0, i32 1
store i8* %envptr916, i8** %closure.env926
%closure.func927 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure915, i32 0, i32 2
store float (i8*, i8*, float*, i64)* @vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd__881, float (i8*, i8*, float*, i64)** %closure.func927
%closure_size928 = call i64 @llvm_zone_mark_size(%mzone* %zone913)
call void @llvm_zone_ptr_set_size(i8* %clsptr914, i64 %closure_size928)
%wrapper_ptr929 = call i8* @llvm_zone_malloc(%mzone* %zone913, i64 8)
%closure_wrapper930 = bitcast i8* %wrapper_ptr929 to { i8*, i8*, float (i8*, i8*, float*, i64)*}**
store { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure915, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper930

; let value assignment
%vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd = select i1 true, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper930, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper930
store { i8*, i8*, float (i8*, i8*, float*, i64)*}** %vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd, { i8*, i8*, float (i8*, i8*, float*, i64)*}*** %vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr

; add data to environment
; don't need to alloc for env var vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd
%tmp_envptr924 = getelementptr {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}* %environment917, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, float*, i64)*}*** %vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr, {i8*, i8*, float (i8*, i8*, float*, i64)*}**** %tmp_envptr924


%val933 = load {i8*, i8*, float (i8*, i8*, float*, i64)*}**, {i8*, i8*, float (i8*, i8*, float*, i64)*}*** %vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr
ret {i8*, i8*, float (i8*, i8*, float*, i64)*}** %val933
}


@vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, float*, i64)*}** @vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret float %result
}


define dllexport ccc float @vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_native(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret float %result
}


define dllexport ccc i8*  @vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var934 = bitcast [89 x i8]* @gsxtmmath35 to i8*
call i32 (i8*, ...) @printf(i8* %var934)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var935 = bitcast [89 x i8]* @gsxtmmath35 to i8*
call i32 (i8*, ...) @printf(i8* %var935)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64}*
%arg_p_0 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath36 = hidden constant [39 x i8] c"vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0\00"
define dllexport fastcc double @vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0__936(i8* %_impz,i8* %_impenv, double* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone937 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}*
%vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}* %impenv, i32 0, i32 0
%vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr = load {i8*, i8*, double (i8*, i8*, double*, i64)*}***, {i8*, i8*, double (i8*, i8*, double*, i64)*}**** %vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr_

; setup arguments
%bufPtr = alloca double*
store double* %buf, double** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone941 = load i8*, i8** %_impzPtr
%zone942 = bitcast i8* %tzone941 to %mzone*

; let assign value to symbol max_val
%max_valPtr = alloca double
%tzone943 = load i8*, i8** %_impzPtr
%zone944 = bitcast i8* %tzone943 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val938 = load double*, double** %bufPtr
; pointer ref
%val939 = getelementptr double, double* %val938, i64 0
%val940 = load double, double* %val939

; let value assignment
%max_val = select i1 true, double %val940, double %val940
store double %max_val, double* %max_valPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; promote local stack var allocations
%tzone965 = load i8*, i8** %_impzPtr
%zone966 = bitcast i8* %tzone965 to %mzone*
%ifptr948 = alloca double
; setup loop
%val947 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val960 = load i64, i64* %iPtr
%num961 = add i64 %val947, %val960
%comp962 = icmp ult i64 %val947, 1
br i1 %comp962, label %after945, label %loop945

loop945:
%val949 = load i64, i64* %iPtr
%val950 = load double*, double** %bufPtr
; pointer ref
%val951 = getelementptr double, double* %val950, i64 %val949
%val952 = load double, double* %val951
%val953 = load double, double* %max_valPtr
%cmp954 = fcmp ugt double %val952, %val953
br i1 %cmp954, label %then948, label %else948

then948:
; do set!
%val955 = load i64, i64* %iPtr
%val956 = load double*, double** %bufPtr
; pointer ref
%val957 = getelementptr double, double* %val956, i64 %val955
%val958 = load double, double* %val957
store double %val958, double* %max_valPtr
store double %val958, double* %ifptr948
br label %ifcont948

else948:
br label %ifcont948

ifcont948:
%ifres959 = load double, double* %ifptr948

%loop_cnt945 = load i64, i64* %iPtr
%next945 = add i64 %loop_cnt945, 1
store i64 %next945, i64* %iPtr
%cmp945 = icmp ult i64 %next945, %num961
br i1 %cmp945, label %loop945, label %after945

after945:
%val964 = load double, double* %max_valPtr
ret double %val964
}
@gsxtmmath37 = hidden constant [92 x i8] c"vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, double*, i64)*}** @vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone986 = load i8*, i8** %_impzPtr
%zone987 = bitcast i8* %tzone986 to %mzone*

; let assign value to symbol vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0
%dat_vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone987, i64 8)
%vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr = bitcast i8* %dat_vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 to { i8*, i8*, double (i8*, i8*, double*, i64)*}***
%tzone967 = load i8*, i8** %_impzPtr
%zone968 = bitcast i8* %tzone967 to %mzone*
call void @llvm_zone_mark(%mzone* %zone968)
; malloc closure structure
%clsptr969 = call i8* @llvm_zone_malloc(%mzone* %zone968, i64 24)
%closure970 = bitcast i8* %clsptr969 to { i8*, i8*, double (i8*, i8*, double*, i64)*}*

; malloc environment structure
%envptr971 = call i8* @llvm_zone_malloc(%mzone* %zone968, i64 8)
%environment972 = bitcast i8* %envptr971 to {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}*

; malloc closure address table
%addytable973 = call %clsvar* @new_address_table()
%var974 = bitcast [39 x i8]* @gsxtmmath36 to i8*
%var975 = bitcast [47 x i8]* @gsxtmmath10 to i8*
%addytable976 = call %clsvar* @add_address_table(%mzone* %zone968, i8* %var974, i32 0, i8* %var975, i32 3, %clsvar* %addytable973)
%address-table977 = bitcast %clsvar* %addytable976 to i8*

; insert table, function and environment into closure struct
%closure.table980 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure970, i32 0, i32 0
store i8* %address-table977, i8** %closure.table980
%closure.env981 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure970, i32 0, i32 1
store i8* %envptr971, i8** %closure.env981
%closure.func982 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure970, i32 0, i32 2
store double (i8*, i8*, double*, i64)* @vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0__936, double (i8*, i8*, double*, i64)** %closure.func982
%closure_size983 = call i64 @llvm_zone_mark_size(%mzone* %zone968)
call void @llvm_zone_ptr_set_size(i8* %clsptr969, i64 %closure_size983)
%wrapper_ptr984 = call i8* @llvm_zone_malloc(%mzone* %zone968, i64 8)
%closure_wrapper985 = bitcast i8* %wrapper_ptr984 to { i8*, i8*, double (i8*, i8*, double*, i64)*}**
store { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure970, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper985

; let value assignment
%vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 = select i1 true, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper985, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper985
store { i8*, i8*, double (i8*, i8*, double*, i64)*}** %vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0, { i8*, i8*, double (i8*, i8*, double*, i64)*}*** %vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0
%tmp_envptr979 = getelementptr {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}* %environment972, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, double*, i64)*}*** %vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr, {i8*, i8*, double (i8*, i8*, double*, i64)*}**** %tmp_envptr979


%val988 = load {i8*, i8*, double (i8*, i8*, double*, i64)*}**, {i8*, i8*, double (i8*, i8*, double*, i64)*}*** %vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr
ret {i8*, i8*, double (i8*, i8*, double*, i64)*}** %val988
}


@vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, double*, i64)*}** @vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret double %result
}


define dllexport ccc double @vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_native(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret double %result
}


define dllexport ccc i8*  @vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var989 = bitcast [92 x i8]* @gsxtmmath37 to i8*
call i32 (i8*, ...) @printf(i8* %var989)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var990 = bitcast [92 x i8]* @gsxtmmath37 to i8*
call i32 (i8*, ...) @printf(i8* %var990)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, i64}*
%arg_p_0 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmax_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath38 = hidden constant [22 x i8] c"buf[%. 3lld] = %. 6d \00"
@gsxtmmath39 = hidden constant [40 x i8] c"vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ\00"
@gsxtmmath40 = hidden constant [47 x i8] c"{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**\00"
define dllexport fastcc void @vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ__991(i8* %_impz,i8* %_impenv, i32* %buf, i64 %len, i64 %ncols) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone992 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***}*
%vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***}* %impenv, i32 0, i32 0
%vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**** %vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr_

; setup arguments
%bufPtr = alloca i32*
store i32* %buf, i32** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%ncolsPtr = alloca i64
store i64 %ncols, i64* %ncolsPtr


%tzone994 = load i8*, i8** %_impzPtr
%zone995 = bitcast i8* %tzone994 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val993 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val993, i64 %val993
store i64 %i, i64* %iPtr

; setup loop
%val998 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val1014 = load i64, i64* %iPtr
%num1015 = add i64 %val998, %val1014
%comp1016 = icmp ult i64 %val998, 1
br i1 %comp1016, label %after996, label %loop996

loop996:
%var999 = bitcast [22 x i8]* @gsxtmmath38 to i8*
%val1000 = load i64, i64* %iPtr
%val1001 = load i64, i64* %iPtr
%val1002 = load i32*, i32** %bufPtr
; pointer ref
%val1003 = getelementptr i32, i32* %val1002, i64 %val1001
%val1004 = load i32, i32* %val1003

%val1005 = call i32 (i8*, ...) @printf(i8* %var999, i64 %val1000, i32 %val1004)
%val1007 = load i64, i64* %iPtr
%val1008 = load i64, i64* %ncolsPtr
%val1009 = srem i64 %val1007, %val1008
%val1010 = load i64, i64* %ncolsPtr
%val1011 = sub i64 %val1010, 1
%cmp1012 = icmp eq i64 %val1009, %val1011
br i1 %cmp1012, label %then1006, label %else1006

then1006:
call fastcc void @print_return_adhoc_W3ZvaWRd()
br label %ifcont1006

else1006:
br label %ifcont1006

ifcont1006:
%loop_cnt996 = load i64, i64* %iPtr
%next996 = add i64 %loop_cnt996, 1
store i64 %next996, i64* %iPtr
%cmp996 = icmp ult i64 %next996, %num1015
br i1 %cmp996, label %loop996, label %after996

after996:
call fastcc void @print_return_adhoc_W3ZvaWRd()
ret void
}
@gsxtmmath41 = hidden constant [93 x i8] c"vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** @vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1038 = load i8*, i8** %_impzPtr
%zone1039 = bitcast i8* %tzone1038 to %mzone*

; let assign value to symbol vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ
%dat_vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone1039, i64 8)
%vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr = bitcast i8* %dat_vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ to { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***
%tzone1019 = load i8*, i8** %_impzPtr
%zone1020 = bitcast i8* %tzone1019 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1020)
; malloc closure structure
%clsptr1021 = call i8* @llvm_zone_malloc(%mzone* %zone1020, i64 24)
%closure1022 = bitcast i8* %clsptr1021 to { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*

; malloc environment structure
%envptr1023 = call i8* @llvm_zone_malloc(%mzone* %zone1020, i64 8)
%environment1024 = bitcast i8* %envptr1023 to {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***}*

; malloc closure address table
%addytable1025 = call %clsvar* @new_address_table()
%var1026 = bitcast [40 x i8]* @gsxtmmath39 to i8*
%var1027 = bitcast [47 x i8]* @gsxtmmath40 to i8*
%addytable1028 = call %clsvar* @add_address_table(%mzone* %zone1020, i8* %var1026, i32 0, i8* %var1027, i32 3, %clsvar* %addytable1025)
%address-table1029 = bitcast %clsvar* %addytable1028 to i8*

; insert table, function and environment into closure struct
%closure.table1032 = getelementptr { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure1022, i32 0, i32 0
store i8* %address-table1029, i8** %closure.table1032
%closure.env1033 = getelementptr { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure1022, i32 0, i32 1
store i8* %envptr1023, i8** %closure.env1033
%closure.func1034 = getelementptr { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure1022, i32 0, i32 2
store void (i8*, i8*, i32*, i64, i64)* @vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ__991, void (i8*, i8*, i32*, i64, i64)** %closure.func1034
%closure_size1035 = call i64 @llvm_zone_mark_size(%mzone* %zone1020)
call void @llvm_zone_ptr_set_size(i8* %clsptr1021, i64 %closure_size1035)
%wrapper_ptr1036 = call i8* @llvm_zone_malloc(%mzone* %zone1020, i64 8)
%closure_wrapper1037 = bitcast i8* %wrapper_ptr1036 to { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**
store { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure1022, { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure_wrapper1037

; let value assignment
%vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure_wrapper1037, { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure_wrapper1037
store { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ, { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*** %vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ
%tmp_envptr1031 = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***}* %environment1024, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*** %vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**** %tmp_envptr1031


%val1040 = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*** %vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %val1040
}


@vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** @vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ(i32* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32*, i64, i64)*,  void (i8*, i8*, i32*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_native(i32* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32*, i64, i64)*,  void (i8*, i8*, i32*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1041 = bitcast [93 x i8]* @gsxtmmath41 to i8*
call i32 (i8*, ...) @printf(i8* %var1041)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i32*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1042 = bitcast [93 x i8]* @gsxtmmath41 to i8*
call i32 (i8*, ...) @printf(i8* %var1042)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1043 = bitcast [93 x i8]* @gsxtmmath41 to i8*
call i32 (i8*, ...) @printf(i8* %var1043)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32*, i64, i64)*,  void (i8*, i8*, i32*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32*, i64, i64}*
%arg_p_0 = getelementptr {i32*, i64, i64}, {i32*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i32*, i32** %arg_p_0
%arg_p_1 = getelementptr {i32*, i64, i64}, {i32*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {i32*, i64, i64}, {i32*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32*, i64, i64)*,  void (i8*, i8*, i32*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath42 = hidden constant [34 x i8] c"vprint_adhoc_W3ZvaWQsaTMyKixpNjRd\00"
@gsxtmmath43 = hidden constant [42 x i8] c"{i8*, i8*, void (i8*, i8*, i32*, i64)*}**\00"
define dllexport fastcc void @vprint_adhoc_W3ZvaWQsaTMyKixpNjRd__1044(i8* %_impz,i8* %_impenv, i32* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1045 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i32*, i64)*}***}*
%vprint_adhoc_W3ZvaWQsaTMyKixpNjRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i32*, i64)*}***}* %impenv, i32 0, i32 0
%vprint_adhoc_W3ZvaWQsaTMyKixpNjRdPtr = load {i8*, i8*, void (i8*, i8*, i32*, i64)*}***, {i8*, i8*, void (i8*, i8*, i32*, i64)*}**** %vprint_adhoc_W3ZvaWQsaTMyKixpNjRdPtr_

; setup arguments
%bufPtr = alloca i32*
store i32* %buf, i32** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%val1046 = load i32*, i32** %bufPtr
%val1047 = load i64, i64* %lenPtr
call fastcc void @vprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ(i32* %val1046, i64 %val1047, i64 1)
ret void
}
@gsxtmmath44 = hidden constant [87 x i8] c"vprint_adhoc_W3ZvaWQsaTMyKixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i32*, i64)*}** @vprint_adhoc_W3ZvaWQsaTMyKixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1068 = load i8*, i8** %_impzPtr
%zone1069 = bitcast i8* %tzone1068 to %mzone*

; let assign value to symbol vprint_adhoc_W3ZvaWQsaTMyKixpNjRd
%dat_vprint_adhoc_W3ZvaWQsaTMyKixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone1069, i64 8)
%vprint_adhoc_W3ZvaWQsaTMyKixpNjRdPtr = bitcast i8* %dat_vprint_adhoc_W3ZvaWQsaTMyKixpNjRd to { i8*, i8*, void (i8*, i8*, i32*, i64)*}***
%tzone1049 = load i8*, i8** %_impzPtr
%zone1050 = bitcast i8* %tzone1049 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1050)
; malloc closure structure
%clsptr1051 = call i8* @llvm_zone_malloc(%mzone* %zone1050, i64 24)
%closure1052 = bitcast i8* %clsptr1051 to { i8*, i8*, void (i8*, i8*, i32*, i64)*}*

; malloc environment structure
%envptr1053 = call i8* @llvm_zone_malloc(%mzone* %zone1050, i64 8)
%environment1054 = bitcast i8* %envptr1053 to {{i8*, i8*, void (i8*, i8*, i32*, i64)*}***}*

; malloc closure address table
%addytable1055 = call %clsvar* @new_address_table()
%var1056 = bitcast [34 x i8]* @gsxtmmath42 to i8*
%var1057 = bitcast [42 x i8]* @gsxtmmath43 to i8*
%addytable1058 = call %clsvar* @add_address_table(%mzone* %zone1050, i8* %var1056, i32 0, i8* %var1057, i32 3, %clsvar* %addytable1055)
%address-table1059 = bitcast %clsvar* %addytable1058 to i8*

; insert table, function and environment into closure struct
%closure.table1062 = getelementptr { i8*, i8*, void (i8*, i8*, i32*, i64)*}, { i8*, i8*, void (i8*, i8*, i32*, i64)*}* %closure1052, i32 0, i32 0
store i8* %address-table1059, i8** %closure.table1062
%closure.env1063 = getelementptr { i8*, i8*, void (i8*, i8*, i32*, i64)*}, { i8*, i8*, void (i8*, i8*, i32*, i64)*}* %closure1052, i32 0, i32 1
store i8* %envptr1053, i8** %closure.env1063
%closure.func1064 = getelementptr { i8*, i8*, void (i8*, i8*, i32*, i64)*}, { i8*, i8*, void (i8*, i8*, i32*, i64)*}* %closure1052, i32 0, i32 2
store void (i8*, i8*, i32*, i64)* @vprint_adhoc_W3ZvaWQsaTMyKixpNjRd__1044, void (i8*, i8*, i32*, i64)** %closure.func1064
%closure_size1065 = call i64 @llvm_zone_mark_size(%mzone* %zone1050)
call void @llvm_zone_ptr_set_size(i8* %clsptr1051, i64 %closure_size1065)
%wrapper_ptr1066 = call i8* @llvm_zone_malloc(%mzone* %zone1050, i64 8)
%closure_wrapper1067 = bitcast i8* %wrapper_ptr1066 to { i8*, i8*, void (i8*, i8*, i32*, i64)*}**
store { i8*, i8*, void (i8*, i8*, i32*, i64)*}* %closure1052, { i8*, i8*, void (i8*, i8*, i32*, i64)*}** %closure_wrapper1067

; let value assignment
%vprint_adhoc_W3ZvaWQsaTMyKixpNjRd = select i1 true, { i8*, i8*, void (i8*, i8*, i32*, i64)*}** %closure_wrapper1067, { i8*, i8*, void (i8*, i8*, i32*, i64)*}** %closure_wrapper1067
store { i8*, i8*, void (i8*, i8*, i32*, i64)*}** %vprint_adhoc_W3ZvaWQsaTMyKixpNjRd, { i8*, i8*, void (i8*, i8*, i32*, i64)*}*** %vprint_adhoc_W3ZvaWQsaTMyKixpNjRdPtr

; add data to environment
; don't need to alloc for env var vprint_adhoc_W3ZvaWQsaTMyKixpNjRd
%tmp_envptr1061 = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i32*, i64)*}***}* %environment1054, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i32*, i64)*}*** %vprint_adhoc_W3ZvaWQsaTMyKixpNjRdPtr, {i8*, i8*, void (i8*, i8*, i32*, i64)*}**** %tmp_envptr1061


%val1070 = load {i8*, i8*, void (i8*, i8*, i32*, i64)*}**, {i8*, i8*, void (i8*, i8*, i32*, i64)*}*** %vprint_adhoc_W3ZvaWQsaTMyKixpNjRdPtr
ret {i8*, i8*, void (i8*, i8*, i32*, i64)*}** %val1070
}


@vprint_adhoc_W3ZvaWQsaTMyKixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@vprint_adhoc_W3ZvaWQsaTMyKixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vprint_adhoc_W3ZvaWQsaTMyKixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTMyKixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i32*, i64)*}** @vprint_adhoc_W3ZvaWQsaTMyKixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i32*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTMyKixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vprint_adhoc_W3ZvaWQsaTMyKixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTMyKixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vprint_adhoc_W3ZvaWQsaTMyKixpNjRd(i32* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTMyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32*, i64)*}*, {i8*, i8*, void (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32*, i64)*,  void (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc void @vprint_adhoc_W3ZvaWQsaTMyKixpNjRd_native(i32* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTMyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32*, i64)*}*, {i8*, i8*, void (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32*, i64)*,  void (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc i8*  @vprint_adhoc_W3ZvaWQsaTMyKixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1071 = bitcast [87 x i8]* @gsxtmmath44 to i8*
call i32 (i8*, ...) @printf(i8* %var1071)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i32*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1072 = bitcast [87 x i8]* @gsxtmmath44 to i8*
call i32 (i8*, ...) @printf(i8* %var1072)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTMyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32*, i64)*}*, {i8*, i8*, void (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32*, i64)*,  void (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vprint_adhoc_W3ZvaWQsaTMyKixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32*, i64}*
%arg_p_0 = getelementptr {i32*, i64}, {i32*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i32*, i32** %arg_p_0
%arg_p_1 = getelementptr {i32*, i64}, {i32*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTMyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32*, i64)*}*, {i8*, i8*, void (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32*, i64)*,  void (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath45 = hidden constant [24 x i8] c"buf[%. 3lld] = %. 6lld \00"
@gsxtmmath46 = hidden constant [40 x i8] c"vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ\00"
@gsxtmmath47 = hidden constant [47 x i8] c"{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**\00"
define dllexport fastcc void @vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ__1073(i8* %_impz,i8* %_impenv, i64* %buf, i64 %len, i64 %ncols) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1074 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***}*
%vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***}* %impenv, i32 0, i32 0
%vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**** %vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr_

; setup arguments
%bufPtr = alloca i64*
store i64* %buf, i64** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%ncolsPtr = alloca i64
store i64 %ncols, i64* %ncolsPtr


%tzone1076 = load i8*, i8** %_impzPtr
%zone1077 = bitcast i8* %tzone1076 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val1075 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val1075, i64 %val1075
store i64 %i, i64* %iPtr

; setup loop
%val1080 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val1096 = load i64, i64* %iPtr
%num1097 = add i64 %val1080, %val1096
%comp1098 = icmp ult i64 %val1080, 1
br i1 %comp1098, label %after1078, label %loop1078

loop1078:
%var1081 = bitcast [24 x i8]* @gsxtmmath45 to i8*
%val1082 = load i64, i64* %iPtr
%val1083 = load i64, i64* %iPtr
%val1084 = load i64*, i64** %bufPtr
; pointer ref
%val1085 = getelementptr i64, i64* %val1084, i64 %val1083
%val1086 = load i64, i64* %val1085

%val1087 = call i32 (i8*, ...) @printf(i8* %var1081, i64 %val1082, i64 %val1086)
%val1089 = load i64, i64* %iPtr
%val1090 = load i64, i64* %ncolsPtr
%val1091 = srem i64 %val1089, %val1090
%val1092 = load i64, i64* %ncolsPtr
%val1093 = sub i64 %val1092, 1
%cmp1094 = icmp eq i64 %val1091, %val1093
br i1 %cmp1094, label %then1088, label %else1088

then1088:
call fastcc void @print_return_adhoc_W3ZvaWRd()
br label %ifcont1088

else1088:
br label %ifcont1088

ifcont1088:
%loop_cnt1078 = load i64, i64* %iPtr
%next1078 = add i64 %loop_cnt1078, 1
store i64 %next1078, i64* %iPtr
%cmp1078 = icmp ult i64 %next1078, %num1097
br i1 %cmp1078, label %loop1078, label %after1078

after1078:
call fastcc void @print_return_adhoc_W3ZvaWRd()
ret void
}
@gsxtmmath48 = hidden constant [93 x i8] c"vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** @vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1120 = load i8*, i8** %_impzPtr
%zone1121 = bitcast i8* %tzone1120 to %mzone*

; let assign value to symbol vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ
%dat_vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone1121, i64 8)
%vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr = bitcast i8* %dat_vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ to { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***
%tzone1101 = load i8*, i8** %_impzPtr
%zone1102 = bitcast i8* %tzone1101 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1102)
; malloc closure structure
%clsptr1103 = call i8* @llvm_zone_malloc(%mzone* %zone1102, i64 24)
%closure1104 = bitcast i8* %clsptr1103 to { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*

; malloc environment structure
%envptr1105 = call i8* @llvm_zone_malloc(%mzone* %zone1102, i64 8)
%environment1106 = bitcast i8* %envptr1105 to {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***}*

; malloc closure address table
%addytable1107 = call %clsvar* @new_address_table()
%var1108 = bitcast [40 x i8]* @gsxtmmath46 to i8*
%var1109 = bitcast [47 x i8]* @gsxtmmath47 to i8*
%addytable1110 = call %clsvar* @add_address_table(%mzone* %zone1102, i8* %var1108, i32 0, i8* %var1109, i32 3, %clsvar* %addytable1107)
%address-table1111 = bitcast %clsvar* %addytable1110 to i8*

; insert table, function and environment into closure struct
%closure.table1114 = getelementptr { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure1104, i32 0, i32 0
store i8* %address-table1111, i8** %closure.table1114
%closure.env1115 = getelementptr { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure1104, i32 0, i32 1
store i8* %envptr1105, i8** %closure.env1115
%closure.func1116 = getelementptr { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure1104, i32 0, i32 2
store void (i8*, i8*, i64*, i64, i64)* @vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ__1073, void (i8*, i8*, i64*, i64, i64)** %closure.func1116
%closure_size1117 = call i64 @llvm_zone_mark_size(%mzone* %zone1102)
call void @llvm_zone_ptr_set_size(i8* %clsptr1103, i64 %closure_size1117)
%wrapper_ptr1118 = call i8* @llvm_zone_malloc(%mzone* %zone1102, i64 8)
%closure_wrapper1119 = bitcast i8* %wrapper_ptr1118 to { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**
store { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure1104, { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure_wrapper1119

; let value assignment
%vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure_wrapper1119, { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure_wrapper1119
store { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ, { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*** %vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ
%tmp_envptr1113 = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***}* %environment1106, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*** %vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**** %tmp_envptr1113


%val1122 = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*** %vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %val1122
}


@vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** @vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ(i64* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64*, i64, i64)*,  void (i8*, i8*, i64*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_native(i64* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64*, i64, i64)*,  void (i8*, i8*, i64*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1123 = bitcast [93 x i8]* @gsxtmmath48 to i8*
call i32 (i8*, ...) @printf(i8* %var1123)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i64*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1124 = bitcast [93 x i8]* @gsxtmmath48 to i8*
call i32 (i8*, ...) @printf(i8* %var1124)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1125 = bitcast [93 x i8]* @gsxtmmath48 to i8*
call i32 (i8*, ...) @printf(i8* %var1125)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64*, i64, i64)*,  void (i8*, i8*, i64*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64*, i64, i64}*
%arg_p_0 = getelementptr {i64*, i64, i64}, {i64*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64*, i64** %arg_p_0
%arg_p_1 = getelementptr {i64*, i64, i64}, {i64*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {i64*, i64, i64}, {i64*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64*, i64, i64)*,  void (i8*, i8*, i64*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath49 = hidden constant [34 x i8] c"vprint_adhoc_W3ZvaWQsaTY0KixpNjRd\00"
@gsxtmmath50 = hidden constant [42 x i8] c"{i8*, i8*, void (i8*, i8*, i64*, i64)*}**\00"
define dllexport fastcc void @vprint_adhoc_W3ZvaWQsaTY0KixpNjRd__1126(i8* %_impz,i8* %_impenv, i64* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1127 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i64*, i64)*}***}*
%vprint_adhoc_W3ZvaWQsaTY0KixpNjRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i64*, i64)*}***}* %impenv, i32 0, i32 0
%vprint_adhoc_W3ZvaWQsaTY0KixpNjRdPtr = load {i8*, i8*, void (i8*, i8*, i64*, i64)*}***, {i8*, i8*, void (i8*, i8*, i64*, i64)*}**** %vprint_adhoc_W3ZvaWQsaTY0KixpNjRdPtr_

; setup arguments
%bufPtr = alloca i64*
store i64* %buf, i64** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%val1128 = load i64*, i64** %bufPtr
%val1129 = load i64, i64* %lenPtr
call fastcc void @vprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ(i64* %val1128, i64 %val1129, i64 1)
ret void
}
@gsxtmmath51 = hidden constant [87 x i8] c"vprint_adhoc_W3ZvaWQsaTY0KixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i64*, i64)*}** @vprint_adhoc_W3ZvaWQsaTY0KixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1150 = load i8*, i8** %_impzPtr
%zone1151 = bitcast i8* %tzone1150 to %mzone*

; let assign value to symbol vprint_adhoc_W3ZvaWQsaTY0KixpNjRd
%dat_vprint_adhoc_W3ZvaWQsaTY0KixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone1151, i64 8)
%vprint_adhoc_W3ZvaWQsaTY0KixpNjRdPtr = bitcast i8* %dat_vprint_adhoc_W3ZvaWQsaTY0KixpNjRd to { i8*, i8*, void (i8*, i8*, i64*, i64)*}***
%tzone1131 = load i8*, i8** %_impzPtr
%zone1132 = bitcast i8* %tzone1131 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1132)
; malloc closure structure
%clsptr1133 = call i8* @llvm_zone_malloc(%mzone* %zone1132, i64 24)
%closure1134 = bitcast i8* %clsptr1133 to { i8*, i8*, void (i8*, i8*, i64*, i64)*}*

; malloc environment structure
%envptr1135 = call i8* @llvm_zone_malloc(%mzone* %zone1132, i64 8)
%environment1136 = bitcast i8* %envptr1135 to {{i8*, i8*, void (i8*, i8*, i64*, i64)*}***}*

; malloc closure address table
%addytable1137 = call %clsvar* @new_address_table()
%var1138 = bitcast [34 x i8]* @gsxtmmath49 to i8*
%var1139 = bitcast [42 x i8]* @gsxtmmath50 to i8*
%addytable1140 = call %clsvar* @add_address_table(%mzone* %zone1132, i8* %var1138, i32 0, i8* %var1139, i32 3, %clsvar* %addytable1137)
%address-table1141 = bitcast %clsvar* %addytable1140 to i8*

; insert table, function and environment into closure struct
%closure.table1144 = getelementptr { i8*, i8*, void (i8*, i8*, i64*, i64)*}, { i8*, i8*, void (i8*, i8*, i64*, i64)*}* %closure1134, i32 0, i32 0
store i8* %address-table1141, i8** %closure.table1144
%closure.env1145 = getelementptr { i8*, i8*, void (i8*, i8*, i64*, i64)*}, { i8*, i8*, void (i8*, i8*, i64*, i64)*}* %closure1134, i32 0, i32 1
store i8* %envptr1135, i8** %closure.env1145
%closure.func1146 = getelementptr { i8*, i8*, void (i8*, i8*, i64*, i64)*}, { i8*, i8*, void (i8*, i8*, i64*, i64)*}* %closure1134, i32 0, i32 2
store void (i8*, i8*, i64*, i64)* @vprint_adhoc_W3ZvaWQsaTY0KixpNjRd__1126, void (i8*, i8*, i64*, i64)** %closure.func1146
%closure_size1147 = call i64 @llvm_zone_mark_size(%mzone* %zone1132)
call void @llvm_zone_ptr_set_size(i8* %clsptr1133, i64 %closure_size1147)
%wrapper_ptr1148 = call i8* @llvm_zone_malloc(%mzone* %zone1132, i64 8)
%closure_wrapper1149 = bitcast i8* %wrapper_ptr1148 to { i8*, i8*, void (i8*, i8*, i64*, i64)*}**
store { i8*, i8*, void (i8*, i8*, i64*, i64)*}* %closure1134, { i8*, i8*, void (i8*, i8*, i64*, i64)*}** %closure_wrapper1149

; let value assignment
%vprint_adhoc_W3ZvaWQsaTY0KixpNjRd = select i1 true, { i8*, i8*, void (i8*, i8*, i64*, i64)*}** %closure_wrapper1149, { i8*, i8*, void (i8*, i8*, i64*, i64)*}** %closure_wrapper1149
store { i8*, i8*, void (i8*, i8*, i64*, i64)*}** %vprint_adhoc_W3ZvaWQsaTY0KixpNjRd, { i8*, i8*, void (i8*, i8*, i64*, i64)*}*** %vprint_adhoc_W3ZvaWQsaTY0KixpNjRdPtr

; add data to environment
; don't need to alloc for env var vprint_adhoc_W3ZvaWQsaTY0KixpNjRd
%tmp_envptr1143 = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i64*, i64)*}***}* %environment1136, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i64*, i64)*}*** %vprint_adhoc_W3ZvaWQsaTY0KixpNjRdPtr, {i8*, i8*, void (i8*, i8*, i64*, i64)*}**** %tmp_envptr1143


%val1152 = load {i8*, i8*, void (i8*, i8*, i64*, i64)*}**, {i8*, i8*, void (i8*, i8*, i64*, i64)*}*** %vprint_adhoc_W3ZvaWQsaTY0KixpNjRdPtr
ret {i8*, i8*, void (i8*, i8*, i64*, i64)*}** %val1152
}


@vprint_adhoc_W3ZvaWQsaTY0KixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@vprint_adhoc_W3ZvaWQsaTY0KixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vprint_adhoc_W3ZvaWQsaTY0KixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTY0KixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i64*, i64)*}** @vprint_adhoc_W3ZvaWQsaTY0KixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i64*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTY0KixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vprint_adhoc_W3ZvaWQsaTY0KixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTY0KixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vprint_adhoc_W3ZvaWQsaTY0KixpNjRd(i64* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTY0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64*, i64)*}*, {i8*, i8*, void (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64*, i64)*,  void (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc void @vprint_adhoc_W3ZvaWQsaTY0KixpNjRd_native(i64* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTY0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64*, i64)*}*, {i8*, i8*, void (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64*, i64)*,  void (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc i8*  @vprint_adhoc_W3ZvaWQsaTY0KixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1153 = bitcast [87 x i8]* @gsxtmmath51 to i8*
call i32 (i8*, ...) @printf(i8* %var1153)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i64*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1154 = bitcast [87 x i8]* @gsxtmmath51 to i8*
call i32 (i8*, ...) @printf(i8* %var1154)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTY0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64*, i64)*}*, {i8*, i8*, void (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64*, i64)*,  void (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vprint_adhoc_W3ZvaWQsaTY0KixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64*, i64}*
%arg_p_0 = getelementptr {i64*, i64}, {i64*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64*, i64** %arg_p_0
%arg_p_1 = getelementptr {i64*, i64}, {i64*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsaTY0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64*, i64)*}*, {i8*, i8*, void (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64*, i64)*,  void (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath52 = hidden constant [21 x i8] c"buf[%. 3lld] = %.4f \00"
@gsxtmmath53 = hidden constant [42 x i8] c"vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd\00"
@gsxtmmath54 = hidden constant [49 x i8] c"{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**\00"
define dllexport fastcc void @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd__1155(i8* %_impz,i8* %_impenv, float* %buf, i64 %len, i64 %ncols) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1156 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***}*
%vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***}* %impenv, i32 0, i32 0
%vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**** %vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr_

; setup arguments
%bufPtr = alloca float*
store float* %buf, float** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%ncolsPtr = alloca i64
store i64 %ncols, i64* %ncolsPtr


%tzone1158 = load i8*, i8** %_impzPtr
%zone1159 = bitcast i8* %tzone1158 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val1157 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val1157, i64 %val1157
store i64 %i, i64* %iPtr

; setup loop
%val1162 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val1179 = load i64, i64* %iPtr
%num1180 = add i64 %val1162, %val1179
%comp1181 = icmp ult i64 %val1162, 1
br i1 %comp1181, label %after1160, label %loop1160

loop1160:
%var1163 = bitcast [21 x i8]* @gsxtmmath52 to i8*
%val1164 = load i64, i64* %iPtr
%val1165 = load i64, i64* %iPtr
%val1166 = load float*, float** %bufPtr
; pointer ref
%val1167 = getelementptr float, float* %val1166, i64 %val1165
%val1168 = load float, float* %val1167
%val1169 = fpext float %val1168 to double

%val1170 = call i32 (i8*, ...) @printf(i8* %var1163, i64 %val1164, double %val1169)
%val1172 = load i64, i64* %iPtr
%val1173 = load i64, i64* %ncolsPtr
%val1174 = srem i64 %val1172, %val1173
%val1175 = load i64, i64* %ncolsPtr
%val1176 = sub i64 %val1175, 1
%cmp1177 = icmp eq i64 %val1174, %val1176
br i1 %cmp1177, label %then1171, label %else1171

then1171:
call fastcc void @print_return_adhoc_W3ZvaWRd()
br label %ifcont1171

else1171:
br label %ifcont1171

ifcont1171:
%loop_cnt1160 = load i64, i64* %iPtr
%next1160 = add i64 %loop_cnt1160, 1
store i64 %next1160, i64* %iPtr
%cmp1160 = icmp ult i64 %next1160, %num1180
br i1 %cmp1160, label %loop1160, label %after1160

after1160:
call fastcc void @print_return_adhoc_W3ZvaWRd()
ret void
}
@gsxtmmath55 = hidden constant [95 x i8] c"vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1203 = load i8*, i8** %_impzPtr
%zone1204 = bitcast i8* %tzone1203 to %mzone*

; let assign value to symbol vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd
%dat_vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone1204, i64 8)
%vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr = bitcast i8* %dat_vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd to { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***
%tzone1184 = load i8*, i8** %_impzPtr
%zone1185 = bitcast i8* %tzone1184 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1185)
; malloc closure structure
%clsptr1186 = call i8* @llvm_zone_malloc(%mzone* %zone1185, i64 24)
%closure1187 = bitcast i8* %clsptr1186 to { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*

; malloc environment structure
%envptr1188 = call i8* @llvm_zone_malloc(%mzone* %zone1185, i64 8)
%environment1189 = bitcast i8* %envptr1188 to {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***}*

; malloc closure address table
%addytable1190 = call %clsvar* @new_address_table()
%var1191 = bitcast [42 x i8]* @gsxtmmath53 to i8*
%var1192 = bitcast [49 x i8]* @gsxtmmath54 to i8*
%addytable1193 = call %clsvar* @add_address_table(%mzone* %zone1185, i8* %var1191, i32 0, i8* %var1192, i32 3, %clsvar* %addytable1190)
%address-table1194 = bitcast %clsvar* %addytable1193 to i8*

; insert table, function and environment into closure struct
%closure.table1197 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure1187, i32 0, i32 0
store i8* %address-table1194, i8** %closure.table1197
%closure.env1198 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure1187, i32 0, i32 1
store i8* %envptr1188, i8** %closure.env1198
%closure.func1199 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure1187, i32 0, i32 2
store void (i8*, i8*, float*, i64, i64)* @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd__1155, void (i8*, i8*, float*, i64, i64)** %closure.func1199
%closure_size1200 = call i64 @llvm_zone_mark_size(%mzone* %zone1185)
call void @llvm_zone_ptr_set_size(i8* %clsptr1186, i64 %closure_size1200)
%wrapper_ptr1201 = call i8* @llvm_zone_malloc(%mzone* %zone1185, i64 8)
%closure_wrapper1202 = bitcast i8* %wrapper_ptr1201 to { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**
store { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure1187, { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure_wrapper1202

; let value assignment
%vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd = select i1 true, { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure_wrapper1202, { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure_wrapper1202
store { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd, { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*** %vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr

; add data to environment
; don't need to alloc for env var vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd
%tmp_envptr1196 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***}* %environment1189, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*** %vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**** %tmp_envptr1196


%val1205 = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*** %vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr
ret {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %val1205
}


@vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd(float* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, i64)*,  void (i8*, i8*, float*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_native(float* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, i64)*,  void (i8*, i8*, float*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1206 = bitcast [95 x i8]* @gsxtmmath55 to i8*
call i32 (i8*, ...) @printf(i8* %var1206)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1207 = bitcast [95 x i8]* @gsxtmmath55 to i8*
call i32 (i8*, ...) @printf(i8* %var1207)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1208 = bitcast [95 x i8]* @gsxtmmath55 to i8*
call i32 (i8*, ...) @printf(i8* %var1208)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, i64)*,  void (i8*, i8*, float*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64, i64}*
%arg_p_0 = getelementptr {float*, i64, i64}, {float*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64, i64}, {float*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {float*, i64, i64}, {float*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, i64)*,  void (i8*, i8*, float*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath56 = hidden constant [37 x i8] c"vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0\00"
@gsxtmmath57 = hidden constant [44 x i8] c"{i8*, i8*, void (i8*, i8*, float*, i64)*}**\00"
define dllexport fastcc void @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0__1209(i8* %_impz,i8* %_impenv, float* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1210 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, i64)*}***}*
%vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 0
%vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0Ptr = load {i8*, i8*, void (i8*, i8*, float*, i64)*}***, {i8*, i8*, void (i8*, i8*, float*, i64)*}**** %vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0Ptr_

; setup arguments
%bufPtr = alloca float*
store float* %buf, float** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%val1211 = load float*, float** %bufPtr
%val1212 = load i64, i64* %lenPtr
call fastcc void @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd(float* %val1211, i64 %val1212, i64 1)
ret void
}
@gsxtmmath58 = hidden constant [90 x i8] c"vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, i64)*}** @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1233 = load i8*, i8** %_impzPtr
%zone1234 = bitcast i8* %tzone1233 to %mzone*

; let assign value to symbol vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0
%dat_vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone1234, i64 8)
%vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0Ptr = bitcast i8* %dat_vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0 to { i8*, i8*, void (i8*, i8*, float*, i64)*}***
%tzone1214 = load i8*, i8** %_impzPtr
%zone1215 = bitcast i8* %tzone1214 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1215)
; malloc closure structure
%clsptr1216 = call i8* @llvm_zone_malloc(%mzone* %zone1215, i64 24)
%closure1217 = bitcast i8* %clsptr1216 to { i8*, i8*, void (i8*, i8*, float*, i64)*}*

; malloc environment structure
%envptr1218 = call i8* @llvm_zone_malloc(%mzone* %zone1215, i64 8)
%environment1219 = bitcast i8* %envptr1218 to {{i8*, i8*, void (i8*, i8*, float*, i64)*}***}*

; malloc closure address table
%addytable1220 = call %clsvar* @new_address_table()
%var1221 = bitcast [37 x i8]* @gsxtmmath56 to i8*
%var1222 = bitcast [44 x i8]* @gsxtmmath57 to i8*
%addytable1223 = call %clsvar* @add_address_table(%mzone* %zone1215, i8* %var1221, i32 0, i8* %var1222, i32 3, %clsvar* %addytable1220)
%address-table1224 = bitcast %clsvar* %addytable1223 to i8*

; insert table, function and environment into closure struct
%closure.table1227 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure1217, i32 0, i32 0
store i8* %address-table1224, i8** %closure.table1227
%closure.env1228 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure1217, i32 0, i32 1
store i8* %envptr1218, i8** %closure.env1228
%closure.func1229 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure1217, i32 0, i32 2
store void (i8*, i8*, float*, i64)* @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0__1209, void (i8*, i8*, float*, i64)** %closure.func1229
%closure_size1230 = call i64 @llvm_zone_mark_size(%mzone* %zone1215)
call void @llvm_zone_ptr_set_size(i8* %clsptr1216, i64 %closure_size1230)
%wrapper_ptr1231 = call i8* @llvm_zone_malloc(%mzone* %zone1215, i64 8)
%closure_wrapper1232 = bitcast i8* %wrapper_ptr1231 to { i8*, i8*, void (i8*, i8*, float*, i64)*}**
store { i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure1217, { i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure_wrapper1232

; let value assignment
%vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0 = select i1 true, { i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure_wrapper1232, { i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure_wrapper1232
store { i8*, i8*, void (i8*, i8*, float*, i64)*}** %vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0, { i8*, i8*, void (i8*, i8*, float*, i64)*}*** %vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0
%tmp_envptr1226 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64)*}***}* %environment1219, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, i64)*}*** %vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0Ptr, {i8*, i8*, void (i8*, i8*, float*, i64)*}**** %tmp_envptr1226


%val1235 = load {i8*, i8*, void (i8*, i8*, float*, i64)*}**, {i8*, i8*, void (i8*, i8*, float*, i64)*}*** %vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0Ptr
ret {i8*, i8*, void (i8*, i8*, float*, i64)*}** %val1235
}


@vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, i64)*}** @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64)*,  void (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc void @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_native(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64)*,  void (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc i8*  @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1236 = bitcast [90 x i8]* @gsxtmmath58 to i8*
call i32 (i8*, ...) @printf(i8* %var1236)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1237 = bitcast [90 x i8]* @gsxtmmath58 to i8*
call i32 (i8*, ...) @printf(i8* %var1237)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64)*,  void (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64}*
%arg_p_0 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64)*,  void (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath59 = hidden constant [44 x i8] c"vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ\00"
@gsxtmmath60 = hidden constant [50 x i8] c"{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**\00"
define dllexport fastcc void @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ__1238(i8* %_impz,i8* %_impenv, double* %buf, i64 %len, i64 %ncols) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1239 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***}*
%vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***}* %impenv, i32 0, i32 0
%vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**** %vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr_

; setup arguments
%bufPtr = alloca double*
store double* %buf, double** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%ncolsPtr = alloca i64
store i64 %ncols, i64* %ncolsPtr


%tzone1241 = load i8*, i8** %_impzPtr
%zone1242 = bitcast i8* %tzone1241 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val1240 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val1240, i64 %val1240
store i64 %i, i64* %iPtr

; setup loop
%val1245 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val1261 = load i64, i64* %iPtr
%num1262 = add i64 %val1245, %val1261
%comp1263 = icmp ult i64 %val1245, 1
br i1 %comp1263, label %after1243, label %loop1243

loop1243:
%var1246 = bitcast [21 x i8]* @gsxtmmath52 to i8*
%val1247 = load i64, i64* %iPtr
%val1248 = load i64, i64* %iPtr
%val1249 = load double*, double** %bufPtr
; pointer ref
%val1250 = getelementptr double, double* %val1249, i64 %val1248
%val1251 = load double, double* %val1250

%val1252 = call i32 (i8*, ...) @printf(i8* %var1246, i64 %val1247, double %val1251)
%val1254 = load i64, i64* %iPtr
%val1255 = load i64, i64* %ncolsPtr
%val1256 = srem i64 %val1254, %val1255
%val1257 = load i64, i64* %ncolsPtr
%val1258 = sub i64 %val1257, 1
%cmp1259 = icmp eq i64 %val1256, %val1258
br i1 %cmp1259, label %then1253, label %else1253

then1253:
call fastcc void @print_return_adhoc_W3ZvaWRd()
br label %ifcont1253

else1253:
br label %ifcont1253

ifcont1253:
%loop_cnt1243 = load i64, i64* %iPtr
%next1243 = add i64 %loop_cnt1243, 1
store i64 %next1243, i64* %iPtr
%cmp1243 = icmp ult i64 %next1243, %num1262
br i1 %cmp1243, label %loop1243, label %after1243

after1243:
call fastcc void @print_return_adhoc_W3ZvaWRd()
ret void
}
@gsxtmmath61 = hidden constant [97 x i8] c"vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1285 = load i8*, i8** %_impzPtr
%zone1286 = bitcast i8* %tzone1285 to %mzone*

; let assign value to symbol vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ
%dat_vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone1286, i64 8)
%vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr = bitcast i8* %dat_vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ to { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***
%tzone1266 = load i8*, i8** %_impzPtr
%zone1267 = bitcast i8* %tzone1266 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1267)
; malloc closure structure
%clsptr1268 = call i8* @llvm_zone_malloc(%mzone* %zone1267, i64 24)
%closure1269 = bitcast i8* %clsptr1268 to { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*

; malloc environment structure
%envptr1270 = call i8* @llvm_zone_malloc(%mzone* %zone1267, i64 8)
%environment1271 = bitcast i8* %envptr1270 to {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***}*

; malloc closure address table
%addytable1272 = call %clsvar* @new_address_table()
%var1273 = bitcast [44 x i8]* @gsxtmmath59 to i8*
%var1274 = bitcast [50 x i8]* @gsxtmmath60 to i8*
%addytable1275 = call %clsvar* @add_address_table(%mzone* %zone1267, i8* %var1273, i32 0, i8* %var1274, i32 3, %clsvar* %addytable1272)
%address-table1276 = bitcast %clsvar* %addytable1275 to i8*

; insert table, function and environment into closure struct
%closure.table1279 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure1269, i32 0, i32 0
store i8* %address-table1276, i8** %closure.table1279
%closure.env1280 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure1269, i32 0, i32 1
store i8* %envptr1270, i8** %closure.env1280
%closure.func1281 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure1269, i32 0, i32 2
store void (i8*, i8*, double*, i64, i64)* @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ__1238, void (i8*, i8*, double*, i64, i64)** %closure.func1281
%closure_size1282 = call i64 @llvm_zone_mark_size(%mzone* %zone1267)
call void @llvm_zone_ptr_set_size(i8* %clsptr1268, i64 %closure_size1282)
%wrapper_ptr1283 = call i8* @llvm_zone_malloc(%mzone* %zone1267, i64 8)
%closure_wrapper1284 = bitcast i8* %wrapper_ptr1283 to { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**
store { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure1269, { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure_wrapper1284

; let value assignment
%vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure_wrapper1284, { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure_wrapper1284
store { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ, { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*** %vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ
%tmp_envptr1278 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***}* %environment1271, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*** %vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**** %tmp_envptr1278


%val1287 = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*** %vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %val1287
}


@vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ(double* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, i64)*,  void (i8*, i8*, double*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_native(double* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, i64)*,  void (i8*, i8*, double*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1288 = bitcast [97 x i8]* @gsxtmmath61 to i8*
call i32 (i8*, ...) @printf(i8* %var1288)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1289 = bitcast [97 x i8]* @gsxtmmath61 to i8*
call i32 (i8*, ...) @printf(i8* %var1289)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1290 = bitcast [97 x i8]* @gsxtmmath61 to i8*
call i32 (i8*, ...) @printf(i8* %var1290)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, i64)*,  void (i8*, i8*, double*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, i64, i64}*
%arg_p_0 = getelementptr {double*, i64, i64}, {double*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, i64, i64}, {double*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {double*, i64, i64}, {double*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, i64)*,  void (i8*, i8*, double*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath62 = hidden constant [38 x i8] c"vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd\00"
@gsxtmmath63 = hidden constant [45 x i8] c"{i8*, i8*, void (i8*, i8*, double*, i64)*}**\00"
define dllexport fastcc void @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd__1291(i8* %_impz,i8* %_impenv, double* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1292 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, i64)*}***}*
%vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64)*}***}* %impenv, i32 0, i32 0
%vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRdPtr = load {i8*, i8*, void (i8*, i8*, double*, i64)*}***, {i8*, i8*, void (i8*, i8*, double*, i64)*}**** %vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRdPtr_

; setup arguments
%bufPtr = alloca double*
store double* %buf, double** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%val1293 = load double*, double** %bufPtr
%val1294 = load i64, i64* %lenPtr
call fastcc void @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ(double* %val1293, i64 %val1294, i64 1)
ret void
}
@gsxtmmath64 = hidden constant [91 x i8] c"vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, i64)*}** @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1315 = load i8*, i8** %_impzPtr
%zone1316 = bitcast i8* %tzone1315 to %mzone*

; let assign value to symbol vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd
%dat_vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone1316, i64 8)
%vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRdPtr = bitcast i8* %dat_vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd to { i8*, i8*, void (i8*, i8*, double*, i64)*}***
%tzone1296 = load i8*, i8** %_impzPtr
%zone1297 = bitcast i8* %tzone1296 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1297)
; malloc closure structure
%clsptr1298 = call i8* @llvm_zone_malloc(%mzone* %zone1297, i64 24)
%closure1299 = bitcast i8* %clsptr1298 to { i8*, i8*, void (i8*, i8*, double*, i64)*}*

; malloc environment structure
%envptr1300 = call i8* @llvm_zone_malloc(%mzone* %zone1297, i64 8)
%environment1301 = bitcast i8* %envptr1300 to {{i8*, i8*, void (i8*, i8*, double*, i64)*}***}*

; malloc closure address table
%addytable1302 = call %clsvar* @new_address_table()
%var1303 = bitcast [38 x i8]* @gsxtmmath62 to i8*
%var1304 = bitcast [45 x i8]* @gsxtmmath63 to i8*
%addytable1305 = call %clsvar* @add_address_table(%mzone* %zone1297, i8* %var1303, i32 0, i8* %var1304, i32 3, %clsvar* %addytable1302)
%address-table1306 = bitcast %clsvar* %addytable1305 to i8*

; insert table, function and environment into closure struct
%closure.table1309 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64)*}, { i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure1299, i32 0, i32 0
store i8* %address-table1306, i8** %closure.table1309
%closure.env1310 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64)*}, { i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure1299, i32 0, i32 1
store i8* %envptr1300, i8** %closure.env1310
%closure.func1311 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64)*}, { i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure1299, i32 0, i32 2
store void (i8*, i8*, double*, i64)* @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd__1291, void (i8*, i8*, double*, i64)** %closure.func1311
%closure_size1312 = call i64 @llvm_zone_mark_size(%mzone* %zone1297)
call void @llvm_zone_ptr_set_size(i8* %clsptr1298, i64 %closure_size1312)
%wrapper_ptr1313 = call i8* @llvm_zone_malloc(%mzone* %zone1297, i64 8)
%closure_wrapper1314 = bitcast i8* %wrapper_ptr1313 to { i8*, i8*, void (i8*, i8*, double*, i64)*}**
store { i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure1299, { i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure_wrapper1314

; let value assignment
%vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd = select i1 true, { i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure_wrapper1314, { i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure_wrapper1314
store { i8*, i8*, void (i8*, i8*, double*, i64)*}** %vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd, { i8*, i8*, void (i8*, i8*, double*, i64)*}*** %vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRdPtr

; add data to environment
; don't need to alloc for env var vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd
%tmp_envptr1308 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64)*}***}* %environment1301, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, i64)*}*** %vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRdPtr, {i8*, i8*, void (i8*, i8*, double*, i64)*}**** %tmp_envptr1308


%val1317 = load {i8*, i8*, void (i8*, i8*, double*, i64)*}**, {i8*, i8*, void (i8*, i8*, double*, i64)*}*** %vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRdPtr
ret {i8*, i8*, void (i8*, i8*, double*, i64)*}** %val1317
}


@vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, i64)*}** @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64)*,  void (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc void @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_native(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64)*,  void (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc i8*  @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1318 = bitcast [91 x i8]* @gsxtmmath64 to i8*
call i32 (i8*, ...) @printf(i8* %var1318)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1319 = bitcast [91 x i8]* @gsxtmmath64 to i8*
call i32 (i8*, ...) @printf(i8* %var1319)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64)*,  void (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, i64}*
%arg_p_0 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vprint_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64)*,  void (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath65 = hidden constant [63 x i8] c"vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0\00"
@gsxtmmath66 = hidden constant [62 x i8] c"{i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}**\00"
define dllexport fastcc void @vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0__1320(i8* %_impz,i8* %_impenv, float* %src, float* %dest, i64 %stride, i64 %neighbors, i64 %srclen) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1321 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}***}*
%vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}***}* %impenv, i32 0, i32 0
%vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0Ptr = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}**** %vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0Ptr_

; setup arguments
%srcPtr = alloca float*
store float* %src, float** %srcPtr
%destPtr = alloca float*
store float* %dest, float** %destPtr
%stridePtr = alloca i64
store i64 %stride, i64* %stridePtr
%neighborsPtr = alloca i64
store i64 %neighbors, i64* %neighborsPtr
%srclenPtr = alloca i64
store i64 %srclen, i64* %srclenPtr


%tzone1323 = load i8*, i8** %_impzPtr
%zone1324 = bitcast i8* %tzone1323 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val1322 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val1322, i64 %val1322
store i64 %i, i64* %iPtr

; setup loop
%val1327 = load i64, i64* %srclenPtr
store i64 0, i64* %iPtr
%val1353 = load i64, i64* %iPtr
%num1354 = add i64 %val1327, %val1353
%comp1355 = icmp ult i64 %val1327, 1
br i1 %comp1355, label %after1325, label %loop1325

loop1325:
%tzone1329 = load i8*, i8** %_impzPtr
%zone1330 = bitcast i8* %tzone1329 to %mzone*

; let assign value to symbol j
%jPtr = alloca i64
%val1328 = bitcast i64 0 to i64

; let value assignment
%j = select i1 true, i64 %val1328, i64 %val1328
store i64 %j, i64* %jPtr

; setup loop
%val1333 = load i64, i64* %neighborsPtr
store i64 0, i64* %jPtr
%val1349 = load i64, i64* %jPtr
%num1350 = add i64 %val1333, %val1349
%comp1351 = icmp ult i64 %val1333, 1
br i1 %comp1351, label %after1331, label %loop1331

loop1331:
%val1334 = load i64, i64* %stridePtr
%val1335 = load i64, i64* %iPtr
%val1336 = mul i64 %val1334, %val1335
%val1337 = load i64, i64* %jPtr
%val1338 = add i64 %val1336, %val1337
%val1339 = load float*, float** %destPtr
%val1340 = load i64, i64* %neighborsPtr
%val1341 = load i64, i64* %iPtr
%val1342 = mul i64 %val1340, %val1341
%val1343 = load i64, i64* %jPtr
%val1344 = add i64 %val1342, %val1343
%val1345 = load float*, float** %srcPtr
; pointer ref
%val1346 = getelementptr float, float* %val1345, i64 %val1344
%val1347 = load float, float* %val1346
; set pointer
%val1348 = getelementptr float, float* %val1339, i64 %val1338
store float %val1347, float* %val1348
%loop_cnt1331 = load i64, i64* %jPtr
%next1331 = add i64 %loop_cnt1331, 1
store i64 %next1331, i64* %jPtr
%cmp1331 = icmp ult i64 %next1331, %num1350
br i1 %cmp1331, label %loop1331, label %after1331

after1331:
%loop_cnt1325 = load i64, i64* %iPtr
%next1325 = add i64 %loop_cnt1325, 1
store i64 %next1325, i64* %iPtr
%cmp1325 = icmp ult i64 %next1325, %num1354
br i1 %cmp1325, label %loop1325, label %after1325

after1325:
ret void
}
@gsxtmmath67 = hidden constant [116 x i8] c"vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** @vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1376 = load i8*, i8** %_impzPtr
%zone1377 = bitcast i8* %tzone1376 to %mzone*

; let assign value to symbol vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0
%dat_vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone1377, i64 8)
%vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0Ptr = bitcast i8* %dat_vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0 to { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}***
%tzone1357 = load i8*, i8** %_impzPtr
%zone1358 = bitcast i8* %tzone1357 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1358)
; malloc closure structure
%clsptr1359 = call i8* @llvm_zone_malloc(%mzone* %zone1358, i64 24)
%closure1360 = bitcast i8* %clsptr1359 to { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}*

; malloc environment structure
%envptr1361 = call i8* @llvm_zone_malloc(%mzone* %zone1358, i64 8)
%environment1362 = bitcast i8* %envptr1361 to {{i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}***}*

; malloc closure address table
%addytable1363 = call %clsvar* @new_address_table()
%var1364 = bitcast [63 x i8]* @gsxtmmath65 to i8*
%var1365 = bitcast [62 x i8]* @gsxtmmath66 to i8*
%addytable1366 = call %clsvar* @add_address_table(%mzone* %zone1358, i8* %var1364, i32 0, i8* %var1365, i32 3, %clsvar* %addytable1363)
%address-table1367 = bitcast %clsvar* %addytable1366 to i8*

; insert table, function and environment into closure struct
%closure.table1370 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure1360, i32 0, i32 0
store i8* %address-table1367, i8** %closure.table1370
%closure.env1371 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure1360, i32 0, i32 1
store i8* %envptr1361, i8** %closure.env1371
%closure.func1372 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure1360, i32 0, i32 2
store void (i8*, i8*, float*, float*, i64, i64, i64)* @vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0__1320, void (i8*, i8*, float*, float*, i64, i64, i64)** %closure.func1372
%closure_size1373 = call i64 @llvm_zone_mark_size(%mzone* %zone1358)
call void @llvm_zone_ptr_set_size(i8* %clsptr1359, i64 %closure_size1373)
%wrapper_ptr1374 = call i8* @llvm_zone_malloc(%mzone* %zone1358, i64 8)
%closure_wrapper1375 = bitcast i8* %wrapper_ptr1374 to { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}**
store { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure1360, { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** %closure_wrapper1375

; let value assignment
%vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0 = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** %closure_wrapper1375, { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** %closure_wrapper1375
store { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** %vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0, { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}*** %vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0Ptr

; add data to environment
; don't need to alloc for env var vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0
%tmp_envptr1369 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}***}* %environment1362, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}*** %vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0Ptr, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}**** %tmp_envptr1369


%val1378 = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}*** %vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0Ptr
ret {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** %val1378
}


@vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** @vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0(float* %arg_0,float* %arg_1,i64 %arg_2,i64 %arg_3,i64 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, i64, i64, i64)*,  void (i8*, i8*, float*, float*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2, i64 %arg_3, i64 %arg_4)
ret void
}


define dllexport ccc void @vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_native(float* %arg_0,float* %arg_1,i64 %arg_2,i64 %arg_3,i64 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, i64, i64, i64)*,  void (i8*, i8*, float*, float*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2, i64 %arg_3, i64 %arg_4)
ret void
}


define dllexport ccc i8*  @vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1379 = bitcast [116 x i8]* @gsxtmmath67 to i8*
call i32 (i8*, ...) @printf(i8* %var1379)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1380 = bitcast [116 x i8]* @gsxtmmath67 to i8*
call i32 (i8*, ...) @printf(i8* %var1380)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1381 = bitcast [116 x i8]* @gsxtmmath67 to i8*
call i32 (i8*, ...) @printf(i8* %var1381)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var1382 = bitcast [116 x i8]* @gsxtmmath67 to i8*
call i32 (i8*, ...) @printf(i8* %var1382)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var1383 = bitcast [116 x i8]* @gsxtmmath67 to i8*
call i32 (i8*, ...) @printf(i8* %var1383)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i64  @i64value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, i64, i64, i64)*,  void (i8*, i8*, float*, float*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2, i64 %arg_3, i64 %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, i64, i64, i64}*
%arg_p_0 = getelementptr {float*, float*, i64, i64, i64}, {float*, float*, i64, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, i64, i64, i64}, {float*, float*, i64, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, i64, i64, i64}, {float*, float*, i64, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {float*, float*, i64, i64, i64}, {float*, float*, i64, i64, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
%arg_p_4 = getelementptr {float*, float*, i64, i64, i64}, {float*, float*, i64, i64, i64}* %fstruct, i32 0, i32 4
%arg_4 = load i64, i64* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_unpack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, i64, i64, i64)*,  void (i8*, i8*, float*, float*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2, i64 %arg_3, i64 %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath68 = hidden constant [66 x i8] c"vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ\00"
@gsxtmmath69 = hidden constant [64 x i8] c"{i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}**\00"
define dllexport fastcc void @vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ__1384(i8* %_impz,i8* %_impenv, double* %src, double* %dest, i64 %stride, i64 %neighbors, i64 %srclen) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1385 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}***}*
%vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}***}* %impenv, i32 0, i32 0
%vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}**** %vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQPtr_

; setup arguments
%srcPtr = alloca double*
store double* %src, double** %srcPtr
%destPtr = alloca double*
store double* %dest, double** %destPtr
%stridePtr = alloca i64
store i64 %stride, i64* %stridePtr
%neighborsPtr = alloca i64
store i64 %neighbors, i64* %neighborsPtr
%srclenPtr = alloca i64
store i64 %srclen, i64* %srclenPtr


%tzone1387 = load i8*, i8** %_impzPtr
%zone1388 = bitcast i8* %tzone1387 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val1386 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val1386, i64 %val1386
store i64 %i, i64* %iPtr

; setup loop
%val1391 = load i64, i64* %srclenPtr
store i64 0, i64* %iPtr
%val1417 = load i64, i64* %iPtr
%num1418 = add i64 %val1391, %val1417
%comp1419 = icmp ult i64 %val1391, 1
br i1 %comp1419, label %after1389, label %loop1389

loop1389:
%tzone1393 = load i8*, i8** %_impzPtr
%zone1394 = bitcast i8* %tzone1393 to %mzone*

; let assign value to symbol j
%jPtr = alloca i64
%val1392 = bitcast i64 0 to i64

; let value assignment
%j = select i1 true, i64 %val1392, i64 %val1392
store i64 %j, i64* %jPtr

; setup loop
%val1397 = load i64, i64* %neighborsPtr
store i64 0, i64* %jPtr
%val1413 = load i64, i64* %jPtr
%num1414 = add i64 %val1397, %val1413
%comp1415 = icmp ult i64 %val1397, 1
br i1 %comp1415, label %after1395, label %loop1395

loop1395:
%val1398 = load i64, i64* %stridePtr
%val1399 = load i64, i64* %iPtr
%val1400 = mul i64 %val1398, %val1399
%val1401 = load i64, i64* %jPtr
%val1402 = add i64 %val1400, %val1401
%val1403 = load double*, double** %destPtr
%val1404 = load i64, i64* %neighborsPtr
%val1405 = load i64, i64* %iPtr
%val1406 = mul i64 %val1404, %val1405
%val1407 = load i64, i64* %jPtr
%val1408 = add i64 %val1406, %val1407
%val1409 = load double*, double** %srcPtr
; pointer ref
%val1410 = getelementptr double, double* %val1409, i64 %val1408
%val1411 = load double, double* %val1410
; set pointer
%val1412 = getelementptr double, double* %val1403, i64 %val1402
store double %val1411, double* %val1412
%loop_cnt1395 = load i64, i64* %jPtr
%next1395 = add i64 %loop_cnt1395, 1
store i64 %next1395, i64* %jPtr
%cmp1395 = icmp ult i64 %next1395, %num1414
br i1 %cmp1395, label %loop1395, label %after1395

after1395:
%loop_cnt1389 = load i64, i64* %iPtr
%next1389 = add i64 %loop_cnt1389, 1
store i64 %next1389, i64* %iPtr
%cmp1389 = icmp ult i64 %next1389, %num1418
br i1 %cmp1389, label %loop1389, label %after1389

after1389:
ret void
}
@gsxtmmath70 = hidden constant [119 x i8] c"vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** @vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1440 = load i8*, i8** %_impzPtr
%zone1441 = bitcast i8* %tzone1440 to %mzone*

; let assign value to symbol vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ
%dat_vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone1441, i64 8)
%vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQPtr = bitcast i8* %dat_vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ to { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}***
%tzone1421 = load i8*, i8** %_impzPtr
%zone1422 = bitcast i8* %tzone1421 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1422)
; malloc closure structure
%clsptr1423 = call i8* @llvm_zone_malloc(%mzone* %zone1422, i64 24)
%closure1424 = bitcast i8* %clsptr1423 to { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}*

; malloc environment structure
%envptr1425 = call i8* @llvm_zone_malloc(%mzone* %zone1422, i64 8)
%environment1426 = bitcast i8* %envptr1425 to {{i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}***}*

; malloc closure address table
%addytable1427 = call %clsvar* @new_address_table()
%var1428 = bitcast [66 x i8]* @gsxtmmath68 to i8*
%var1429 = bitcast [64 x i8]* @gsxtmmath69 to i8*
%addytable1430 = call %clsvar* @add_address_table(%mzone* %zone1422, i8* %var1428, i32 0, i8* %var1429, i32 3, %clsvar* %addytable1427)
%address-table1431 = bitcast %clsvar* %addytable1430 to i8*

; insert table, function and environment into closure struct
%closure.table1434 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure1424, i32 0, i32 0
store i8* %address-table1431, i8** %closure.table1434
%closure.env1435 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure1424, i32 0, i32 1
store i8* %envptr1425, i8** %closure.env1435
%closure.func1436 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure1424, i32 0, i32 2
store void (i8*, i8*, double*, double*, i64, i64, i64)* @vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ__1384, void (i8*, i8*, double*, double*, i64, i64, i64)** %closure.func1436
%closure_size1437 = call i64 @llvm_zone_mark_size(%mzone* %zone1422)
call void @llvm_zone_ptr_set_size(i8* %clsptr1423, i64 %closure_size1437)
%wrapper_ptr1438 = call i8* @llvm_zone_malloc(%mzone* %zone1422, i64 8)
%closure_wrapper1439 = bitcast i8* %wrapper_ptr1438 to { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}**
store { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure1424, { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** %closure_wrapper1439

; let value assignment
%vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** %closure_wrapper1439, { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** %closure_wrapper1439
store { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** %vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ, { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}*** %vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ
%tmp_envptr1433 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}***}* %environment1426, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}*** %vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQPtr, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}**** %tmp_envptr1433


%val1442 = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}*** %vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** %val1442
}


@vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** @vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ(double* %arg_0,double* %arg_1,i64 %arg_2,i64 %arg_3,i64 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, i64, i64, i64)*,  void (i8*, i8*, double*, double*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2, i64 %arg_3, i64 %arg_4)
ret void
}


define dllexport ccc void @vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_native(double* %arg_0,double* %arg_1,i64 %arg_2,i64 %arg_3,i64 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, i64, i64, i64)*,  void (i8*, i8*, double*, double*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2, i64 %arg_3, i64 %arg_4)
ret void
}


define dllexport ccc i8*  @vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1443 = bitcast [119 x i8]* @gsxtmmath70 to i8*
call i32 (i8*, ...) @printf(i8* %var1443)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1444 = bitcast [119 x i8]* @gsxtmmath70 to i8*
call i32 (i8*, ...) @printf(i8* %var1444)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to double*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1445 = bitcast [119 x i8]* @gsxtmmath70 to i8*
call i32 (i8*, ...) @printf(i8* %var1445)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var1446 = bitcast [119 x i8]* @gsxtmmath70 to i8*
call i32 (i8*, ...) @printf(i8* %var1446)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var1447 = bitcast [119 x i8]* @gsxtmmath70 to i8*
call i32 (i8*, ...) @printf(i8* %var1447)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i64  @i64value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, i64, i64, i64)*,  void (i8*, i8*, double*, double*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2, i64 %arg_3, i64 %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, double*, i64, i64, i64}*
%arg_p_0 = getelementptr {double*, double*, i64, i64, i64}, {double*, double*, i64, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, double*, i64, i64, i64}, {double*, double*, i64, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load double*, double** %arg_p_1
%arg_p_2 = getelementptr {double*, double*, i64, i64, i64}, {double*, double*, i64, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {double*, double*, i64, i64, i64}, {double*, double*, i64, i64, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
%arg_p_4 = getelementptr {double*, double*, i64, i64, i64}, {double*, double*, i64, i64, i64}* %fstruct, i32 0, i32 4
%arg_4 = load i64, i64* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_unpack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, i64, i64, i64)*,  void (i8*, i8*, double*, double*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2, i64 %arg_3, i64 %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath71 = hidden constant [61 x i8] c"vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0\00"
define dllexport fastcc void @vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0__1448(i8* %_impz,i8* %_impenv, float* %src, float* %dest, i64 %stride, i64 %neighbors, i64 %srclen) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1449 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}***}*
%vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}***}* %impenv, i32 0, i32 0
%vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0Ptr = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}**** %vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0Ptr_

; setup arguments
%srcPtr = alloca float*
store float* %src, float** %srcPtr
%destPtr = alloca float*
store float* %dest, float** %destPtr
%stridePtr = alloca i64
store i64 %stride, i64* %stridePtr
%neighborsPtr = alloca i64
store i64 %neighbors, i64* %neighborsPtr
%srclenPtr = alloca i64
store i64 %srclen, i64* %srclenPtr


%tzone1451 = load i8*, i8** %_impzPtr
%zone1452 = bitcast i8* %tzone1451 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val1450 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val1450, i64 %val1450
store i64 %i, i64* %iPtr

; setup loop
%val1455 = load i64, i64* %srclenPtr
store i64 0, i64* %iPtr
%val1481 = load i64, i64* %iPtr
%num1482 = add i64 %val1455, %val1481
%comp1483 = icmp ult i64 %val1455, 1
br i1 %comp1483, label %after1453, label %loop1453

loop1453:
%tzone1457 = load i8*, i8** %_impzPtr
%zone1458 = bitcast i8* %tzone1457 to %mzone*

; let assign value to symbol j
%jPtr = alloca i64
%val1456 = bitcast i64 0 to i64

; let value assignment
%j = select i1 true, i64 %val1456, i64 %val1456
store i64 %j, i64* %jPtr

; setup loop
%val1461 = load i64, i64* %neighborsPtr
store i64 0, i64* %jPtr
%val1477 = load i64, i64* %jPtr
%num1478 = add i64 %val1461, %val1477
%comp1479 = icmp ult i64 %val1461, 1
br i1 %comp1479, label %after1459, label %loop1459

loop1459:
%val1462 = load i64, i64* %neighborsPtr
%val1463 = load i64, i64* %iPtr
%val1464 = mul i64 %val1462, %val1463
%val1465 = load i64, i64* %jPtr
%val1466 = add i64 %val1464, %val1465
%val1467 = load float*, float** %destPtr
%val1468 = load i64, i64* %stridePtr
%val1469 = load i64, i64* %iPtr
%val1470 = mul i64 %val1468, %val1469
%val1471 = load i64, i64* %jPtr
%val1472 = add i64 %val1470, %val1471
%val1473 = load float*, float** %srcPtr
; pointer ref
%val1474 = getelementptr float, float* %val1473, i64 %val1472
%val1475 = load float, float* %val1474
; set pointer
%val1476 = getelementptr float, float* %val1467, i64 %val1466
store float %val1475, float* %val1476
%loop_cnt1459 = load i64, i64* %jPtr
%next1459 = add i64 %loop_cnt1459, 1
store i64 %next1459, i64* %jPtr
%cmp1459 = icmp ult i64 %next1459, %num1478
br i1 %cmp1459, label %loop1459, label %after1459

after1459:
%loop_cnt1453 = load i64, i64* %iPtr
%next1453 = add i64 %loop_cnt1453, 1
store i64 %next1453, i64* %iPtr
%cmp1453 = icmp ult i64 %next1453, %num1482
br i1 %cmp1453, label %loop1453, label %after1453

after1453:
ret void
}
@gsxtmmath72 = hidden constant [114 x i8] c"vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** @vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1504 = load i8*, i8** %_impzPtr
%zone1505 = bitcast i8* %tzone1504 to %mzone*

; let assign value to symbol vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0
%dat_vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone1505, i64 8)
%vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0Ptr = bitcast i8* %dat_vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0 to { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}***
%tzone1485 = load i8*, i8** %_impzPtr
%zone1486 = bitcast i8* %tzone1485 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1486)
; malloc closure structure
%clsptr1487 = call i8* @llvm_zone_malloc(%mzone* %zone1486, i64 24)
%closure1488 = bitcast i8* %clsptr1487 to { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}*

; malloc environment structure
%envptr1489 = call i8* @llvm_zone_malloc(%mzone* %zone1486, i64 8)
%environment1490 = bitcast i8* %envptr1489 to {{i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}***}*

; malloc closure address table
%addytable1491 = call %clsvar* @new_address_table()
%var1492 = bitcast [61 x i8]* @gsxtmmath71 to i8*
%var1493 = bitcast [62 x i8]* @gsxtmmath66 to i8*
%addytable1494 = call %clsvar* @add_address_table(%mzone* %zone1486, i8* %var1492, i32 0, i8* %var1493, i32 3, %clsvar* %addytable1491)
%address-table1495 = bitcast %clsvar* %addytable1494 to i8*

; insert table, function and environment into closure struct
%closure.table1498 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure1488, i32 0, i32 0
store i8* %address-table1495, i8** %closure.table1498
%closure.env1499 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure1488, i32 0, i32 1
store i8* %envptr1489, i8** %closure.env1499
%closure.func1500 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure1488, i32 0, i32 2
store void (i8*, i8*, float*, float*, i64, i64, i64)* @vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0__1448, void (i8*, i8*, float*, float*, i64, i64, i64)** %closure.func1500
%closure_size1501 = call i64 @llvm_zone_mark_size(%mzone* %zone1486)
call void @llvm_zone_ptr_set_size(i8* %clsptr1487, i64 %closure_size1501)
%wrapper_ptr1502 = call i8* @llvm_zone_malloc(%mzone* %zone1486, i64 8)
%closure_wrapper1503 = bitcast i8* %wrapper_ptr1502 to { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}**
store { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure1488, { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** %closure_wrapper1503

; let value assignment
%vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0 = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** %closure_wrapper1503, { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** %closure_wrapper1503
store { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** %vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0, { i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}*** %vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0Ptr

; add data to environment
; don't need to alloc for env var vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0
%tmp_envptr1497 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}***}* %environment1490, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}*** %vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0Ptr, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}**** %tmp_envptr1497


%val1506 = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}*** %vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0Ptr
ret {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** %val1506
}


@vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** @vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0(float* %arg_0,float* %arg_1,i64 %arg_2,i64 %arg_3,i64 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, i64, i64, i64)*,  void (i8*, i8*, float*, float*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2, i64 %arg_3, i64 %arg_4)
ret void
}


define dllexport ccc void @vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_native(float* %arg_0,float* %arg_1,i64 %arg_2,i64 %arg_3,i64 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, i64, i64, i64)*,  void (i8*, i8*, float*, float*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2, i64 %arg_3, i64 %arg_4)
ret void
}


define dllexport ccc i8*  @vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1507 = bitcast [114 x i8]* @gsxtmmath72 to i8*
call i32 (i8*, ...) @printf(i8* %var1507)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1508 = bitcast [114 x i8]* @gsxtmmath72 to i8*
call i32 (i8*, ...) @printf(i8* %var1508)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1509 = bitcast [114 x i8]* @gsxtmmath72 to i8*
call i32 (i8*, ...) @printf(i8* %var1509)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var1510 = bitcast [114 x i8]* @gsxtmmath72 to i8*
call i32 (i8*, ...) @printf(i8* %var1510)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var1511 = bitcast [114 x i8]* @gsxtmmath72 to i8*
call i32 (i8*, ...) @printf(i8* %var1511)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i64  @i64value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, i64, i64, i64)*,  void (i8*, i8*, float*, float*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2, i64 %arg_3, i64 %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, i64, i64, i64}*
%arg_p_0 = getelementptr {float*, float*, i64, i64, i64}, {float*, float*, i64, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, i64, i64, i64}, {float*, float*, i64, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, i64, i64, i64}, {float*, float*, i64, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {float*, float*, i64, i64, i64}, {float*, float*, i64, i64, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
%arg_p_4 = getelementptr {float*, float*, i64, i64, i64}, {float*, float*, i64, i64, i64}* %fstruct, i32 0, i32 4
%arg_4 = load i64, i64* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_pack_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, i64, i64, i64)*,  void (i8*, i8*, float*, float*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2, i64 %arg_3, i64 %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath73 = hidden constant [64 x i8] c"vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ\00"
define dllexport fastcc void @vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ__1512(i8* %_impz,i8* %_impenv, double* %src, double* %dest, i64 %stride, i64 %neighbors, i64 %srclen) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1513 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}***}*
%vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}***}* %impenv, i32 0, i32 0
%vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}**** %vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQPtr_

; setup arguments
%srcPtr = alloca double*
store double* %src, double** %srcPtr
%destPtr = alloca double*
store double* %dest, double** %destPtr
%stridePtr = alloca i64
store i64 %stride, i64* %stridePtr
%neighborsPtr = alloca i64
store i64 %neighbors, i64* %neighborsPtr
%srclenPtr = alloca i64
store i64 %srclen, i64* %srclenPtr


%tzone1515 = load i8*, i8** %_impzPtr
%zone1516 = bitcast i8* %tzone1515 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val1514 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val1514, i64 %val1514
store i64 %i, i64* %iPtr

; setup loop
%val1519 = load i64, i64* %srclenPtr
store i64 0, i64* %iPtr
%val1545 = load i64, i64* %iPtr
%num1546 = add i64 %val1519, %val1545
%comp1547 = icmp ult i64 %val1519, 1
br i1 %comp1547, label %after1517, label %loop1517

loop1517:
%tzone1521 = load i8*, i8** %_impzPtr
%zone1522 = bitcast i8* %tzone1521 to %mzone*

; let assign value to symbol j
%jPtr = alloca i64
%val1520 = bitcast i64 0 to i64

; let value assignment
%j = select i1 true, i64 %val1520, i64 %val1520
store i64 %j, i64* %jPtr

; setup loop
%val1525 = load i64, i64* %neighborsPtr
store i64 0, i64* %jPtr
%val1541 = load i64, i64* %jPtr
%num1542 = add i64 %val1525, %val1541
%comp1543 = icmp ult i64 %val1525, 1
br i1 %comp1543, label %after1523, label %loop1523

loop1523:
%val1526 = load i64, i64* %neighborsPtr
%val1527 = load i64, i64* %iPtr
%val1528 = mul i64 %val1526, %val1527
%val1529 = load i64, i64* %jPtr
%val1530 = add i64 %val1528, %val1529
%val1531 = load double*, double** %destPtr
%val1532 = load i64, i64* %stridePtr
%val1533 = load i64, i64* %iPtr
%val1534 = mul i64 %val1532, %val1533
%val1535 = load i64, i64* %jPtr
%val1536 = add i64 %val1534, %val1535
%val1537 = load double*, double** %srcPtr
; pointer ref
%val1538 = getelementptr double, double* %val1537, i64 %val1536
%val1539 = load double, double* %val1538
; set pointer
%val1540 = getelementptr double, double* %val1531, i64 %val1530
store double %val1539, double* %val1540
%loop_cnt1523 = load i64, i64* %jPtr
%next1523 = add i64 %loop_cnt1523, 1
store i64 %next1523, i64* %jPtr
%cmp1523 = icmp ult i64 %next1523, %num1542
br i1 %cmp1523, label %loop1523, label %after1523

after1523:
%loop_cnt1517 = load i64, i64* %iPtr
%next1517 = add i64 %loop_cnt1517, 1
store i64 %next1517, i64* %iPtr
%cmp1517 = icmp ult i64 %next1517, %num1546
br i1 %cmp1517, label %loop1517, label %after1517

after1517:
ret void
}
@gsxtmmath74 = hidden constant [117 x i8] c"vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** @vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1568 = load i8*, i8** %_impzPtr
%zone1569 = bitcast i8* %tzone1568 to %mzone*

; let assign value to symbol vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ
%dat_vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone1569, i64 8)
%vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQPtr = bitcast i8* %dat_vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ to { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}***
%tzone1549 = load i8*, i8** %_impzPtr
%zone1550 = bitcast i8* %tzone1549 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1550)
; malloc closure structure
%clsptr1551 = call i8* @llvm_zone_malloc(%mzone* %zone1550, i64 24)
%closure1552 = bitcast i8* %clsptr1551 to { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}*

; malloc environment structure
%envptr1553 = call i8* @llvm_zone_malloc(%mzone* %zone1550, i64 8)
%environment1554 = bitcast i8* %envptr1553 to {{i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}***}*

; malloc closure address table
%addytable1555 = call %clsvar* @new_address_table()
%var1556 = bitcast [64 x i8]* @gsxtmmath73 to i8*
%var1557 = bitcast [64 x i8]* @gsxtmmath69 to i8*
%addytable1558 = call %clsvar* @add_address_table(%mzone* %zone1550, i8* %var1556, i32 0, i8* %var1557, i32 3, %clsvar* %addytable1555)
%address-table1559 = bitcast %clsvar* %addytable1558 to i8*

; insert table, function and environment into closure struct
%closure.table1562 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure1552, i32 0, i32 0
store i8* %address-table1559, i8** %closure.table1562
%closure.env1563 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure1552, i32 0, i32 1
store i8* %envptr1553, i8** %closure.env1563
%closure.func1564 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure1552, i32 0, i32 2
store void (i8*, i8*, double*, double*, i64, i64, i64)* @vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ__1512, void (i8*, i8*, double*, double*, i64, i64, i64)** %closure.func1564
%closure_size1565 = call i64 @llvm_zone_mark_size(%mzone* %zone1550)
call void @llvm_zone_ptr_set_size(i8* %clsptr1551, i64 %closure_size1565)
%wrapper_ptr1566 = call i8* @llvm_zone_malloc(%mzone* %zone1550, i64 8)
%closure_wrapper1567 = bitcast i8* %wrapper_ptr1566 to { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}**
store { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure1552, { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** %closure_wrapper1567

; let value assignment
%vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** %closure_wrapper1567, { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** %closure_wrapper1567
store { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** %vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ, { i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}*** %vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ
%tmp_envptr1561 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}***}* %environment1554, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}*** %vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQPtr, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}**** %tmp_envptr1561


%val1570 = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}*** %vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** %val1570
}


@vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** @vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ(double* %arg_0,double* %arg_1,i64 %arg_2,i64 %arg_3,i64 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, i64, i64, i64)*,  void (i8*, i8*, double*, double*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2, i64 %arg_3, i64 %arg_4)
ret void
}


define dllexport ccc void @vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_native(double* %arg_0,double* %arg_1,i64 %arg_2,i64 %arg_3,i64 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, i64, i64, i64)*,  void (i8*, i8*, double*, double*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2, i64 %arg_3, i64 %arg_4)
ret void
}


define dllexport ccc i8*  @vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1571 = bitcast [117 x i8]* @gsxtmmath74 to i8*
call i32 (i8*, ...) @printf(i8* %var1571)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1572 = bitcast [117 x i8]* @gsxtmmath74 to i8*
call i32 (i8*, ...) @printf(i8* %var1572)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to double*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1573 = bitcast [117 x i8]* @gsxtmmath74 to i8*
call i32 (i8*, ...) @printf(i8* %var1573)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var1574 = bitcast [117 x i8]* @gsxtmmath74 to i8*
call i32 (i8*, ...) @printf(i8* %var1574)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var1575 = bitcast [117 x i8]* @gsxtmmath74 to i8*
call i32 (i8*, ...) @printf(i8* %var1575)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i64  @i64value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, i64, i64, i64)*,  void (i8*, i8*, double*, double*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2, i64 %arg_3, i64 %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, double*, i64, i64, i64}*
%arg_p_0 = getelementptr {double*, double*, i64, i64, i64}, {double*, double*, i64, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, double*, i64, i64, i64}, {double*, double*, i64, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load double*, double** %arg_p_1
%arg_p_2 = getelementptr {double*, double*, i64, i64, i64}, {double*, double*, i64, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {double*, double*, i64, i64, i64}, {double*, double*, i64, i64, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
%arg_p_4 = getelementptr {double*, double*, i64, i64, i64}, {double*, double*, i64, i64, i64}* %fstruct, i32 0, i32 4
%arg_4 = load i64, i64* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_pack_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, i64, i64, i64)*,  void (i8*, i8*, double*, double*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2, i64 %arg_3, i64 %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath75 = hidden constant [48 x i8] c"vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0\00"
@gsxtmmath76 = hidden constant [54 x i8] c"{i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**\00"
define dllexport fastcc void @vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0__1576(i8* %_impz,i8* %_impenv, double* %src, i64 %len, double* %dest) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1577 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***}*
%vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***}* %impenv, i32 0, i32 0
%vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0Ptr = load {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**** %vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0Ptr_

; setup arguments
%srcPtr = alloca double*
store double* %src, double** %srcPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%destPtr = alloca double*
store double* %dest, double** %destPtr


%tzone1579 = load i8*, i8** %_impzPtr
%zone1580 = bitcast i8* %tzone1579 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val1578 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val1578, i64 %val1578
store i64 %i, i64* %iPtr

; setup loop
%val1583 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val1591 = load i64, i64* %iPtr
%num1592 = add i64 %val1583, %val1591
%comp1593 = icmp ult i64 %val1583, 1
br i1 %comp1593, label %after1581, label %loop1581

loop1581:
%val1584 = load i64, i64* %iPtr
%val1585 = load double*, double** %destPtr
%val1586 = load i64, i64* %iPtr
%val1587 = load double*, double** %srcPtr
; pointer ref
%val1588 = getelementptr double, double* %val1587, i64 %val1586
%val1589 = load double, double* %val1588
; set pointer
%val1590 = getelementptr double, double* %val1585, i64 %val1584
store double %val1589, double* %val1590
%loop_cnt1581 = load i64, i64* %iPtr
%next1581 = add i64 %loop_cnt1581, 1
store i64 %next1581, i64* %iPtr
%cmp1581 = icmp ult i64 %next1581, %num1592
br i1 %cmp1581, label %loop1581, label %after1581

after1581:
ret void
}
@gsxtmmath77 = hidden constant [101 x i8] c"vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** @vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1615 = load i8*, i8** %_impzPtr
%zone1616 = bitcast i8* %tzone1615 to %mzone*

; let assign value to symbol vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0
%dat_vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1616, i64 8)
%vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0Ptr = bitcast i8* %dat_vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0 to { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***
%tzone1596 = load i8*, i8** %_impzPtr
%zone1597 = bitcast i8* %tzone1596 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1597)
; malloc closure structure
%clsptr1598 = call i8* @llvm_zone_malloc(%mzone* %zone1597, i64 24)
%closure1599 = bitcast i8* %clsptr1598 to { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*

; malloc environment structure
%envptr1600 = call i8* @llvm_zone_malloc(%mzone* %zone1597, i64 8)
%environment1601 = bitcast i8* %envptr1600 to {{i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***}*

; malloc closure address table
%addytable1602 = call %clsvar* @new_address_table()
%var1603 = bitcast [48 x i8]* @gsxtmmath75 to i8*
%var1604 = bitcast [54 x i8]* @gsxtmmath76 to i8*
%addytable1605 = call %clsvar* @add_address_table(%mzone* %zone1597, i8* %var1603, i32 0, i8* %var1604, i32 3, %clsvar* %addytable1602)
%address-table1606 = bitcast %clsvar* %addytable1605 to i8*

; insert table, function and environment into closure struct
%closure.table1609 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure1599, i32 0, i32 0
store i8* %address-table1606, i8** %closure.table1609
%closure.env1610 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure1599, i32 0, i32 1
store i8* %envptr1600, i8** %closure.env1610
%closure.func1611 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure1599, i32 0, i32 2
store void (i8*, i8*, double*, i64, double*)* @vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0__1576, void (i8*, i8*, double*, i64, double*)** %closure.func1611
%closure_size1612 = call i64 @llvm_zone_mark_size(%mzone* %zone1597)
call void @llvm_zone_ptr_set_size(i8* %clsptr1598, i64 %closure_size1612)
%wrapper_ptr1613 = call i8* @llvm_zone_malloc(%mzone* %zone1597, i64 8)
%closure_wrapper1614 = bitcast i8* %wrapper_ptr1613 to { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**
store { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure1599, { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure_wrapper1614

; let value assignment
%vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure_wrapper1614, { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure_wrapper1614
store { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0, { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*** %vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0Ptr

; add data to environment
; don't need to alloc for env var vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0
%tmp_envptr1608 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***}* %environment1601, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*** %vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0Ptr, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**** %tmp_envptr1608


%val1617 = load {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*** %vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0Ptr
ret {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %val1617
}


@vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var = dllexport global [1 x i8*] [ i8* null ]

@vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** @vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0(double* %arg_0,i64 %arg_1,double* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, double*)*,  void (i8*, i8*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, double* %arg_2)
ret void
}


define dllexport ccc void @vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_native(double* %arg_0,i64 %arg_1,double* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, double*)*,  void (i8*, i8*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, double* %arg_2)
ret void
}


define dllexport ccc i8*  @vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1618 = bitcast [101 x i8]* @gsxtmmath77 to i8*
call i32 (i8*, ...) @printf(i8* %var1618)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1619 = bitcast [101 x i8]* @gsxtmmath77 to i8*
call i32 (i8*, ...) @printf(i8* %var1619)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1620 = bitcast [101 x i8]* @gsxtmmath77 to i8*
call i32 (i8*, ...) @printf(i8* %var1620)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to double*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, double*)*,  void (i8*, i8*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, double* %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, i64, double*}*
%arg_p_0 = getelementptr {double*, i64, double*}, {double*, i64, double*}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, i64, double*}, {double*, i64, double*}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {double*, i64, double*}, {double*, i64, double*}* %fstruct, i32 0, i32 2
%arg_2 = load double*, double** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, double*)*,  void (i8*, i8*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, double* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath78 = hidden constant [45 x i8] c"vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd\00"
@gsxtmmath79 = hidden constant [52 x i8] c"{i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**\00"
define dllexport fastcc void @vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd__1621(i8* %_impz,i8* %_impenv, float* %src, i64 %len, float* %dest) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1622 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***}*
%vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***}* %impenv, i32 0, i32 0
%vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpdPtr = load {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**** %vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpdPtr_

; setup arguments
%srcPtr = alloca float*
store float* %src, float** %srcPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%destPtr = alloca float*
store float* %dest, float** %destPtr


%tzone1624 = load i8*, i8** %_impzPtr
%zone1625 = bitcast i8* %tzone1624 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val1623 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val1623, i64 %val1623
store i64 %i, i64* %iPtr

; setup loop
%val1628 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val1636 = load i64, i64* %iPtr
%num1637 = add i64 %val1628, %val1636
%comp1638 = icmp ult i64 %val1628, 1
br i1 %comp1638, label %after1626, label %loop1626

loop1626:
%val1629 = load i64, i64* %iPtr
%val1630 = load float*, float** %destPtr
%val1631 = load i64, i64* %iPtr
%val1632 = load float*, float** %srcPtr
; pointer ref
%val1633 = getelementptr float, float* %val1632, i64 %val1631
%val1634 = load float, float* %val1633
; set pointer
%val1635 = getelementptr float, float* %val1630, i64 %val1629
store float %val1634, float* %val1635
%loop_cnt1626 = load i64, i64* %iPtr
%next1626 = add i64 %loop_cnt1626, 1
store i64 %next1626, i64* %iPtr
%cmp1626 = icmp ult i64 %next1626, %num1637
br i1 %cmp1626, label %loop1626, label %after1626

after1626:
ret void
}
@gsxtmmath80 = hidden constant [98 x i8] c"vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** @vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1660 = load i8*, i8** %_impzPtr
%zone1661 = bitcast i8* %tzone1660 to %mzone*

; let assign value to symbol vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd
%dat_vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd = call i8* @llvm_zone_malloc(%mzone* %zone1661, i64 8)
%vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpdPtr = bitcast i8* %dat_vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd to { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***
%tzone1641 = load i8*, i8** %_impzPtr
%zone1642 = bitcast i8* %tzone1641 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1642)
; malloc closure structure
%clsptr1643 = call i8* @llvm_zone_malloc(%mzone* %zone1642, i64 24)
%closure1644 = bitcast i8* %clsptr1643 to { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*

; malloc environment structure
%envptr1645 = call i8* @llvm_zone_malloc(%mzone* %zone1642, i64 8)
%environment1646 = bitcast i8* %envptr1645 to {{i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***}*

; malloc closure address table
%addytable1647 = call %clsvar* @new_address_table()
%var1648 = bitcast [45 x i8]* @gsxtmmath78 to i8*
%var1649 = bitcast [52 x i8]* @gsxtmmath79 to i8*
%addytable1650 = call %clsvar* @add_address_table(%mzone* %zone1642, i8* %var1648, i32 0, i8* %var1649, i32 3, %clsvar* %addytable1647)
%address-table1651 = bitcast %clsvar* %addytable1650 to i8*

; insert table, function and environment into closure struct
%closure.table1654 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure1644, i32 0, i32 0
store i8* %address-table1651, i8** %closure.table1654
%closure.env1655 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure1644, i32 0, i32 1
store i8* %envptr1645, i8** %closure.env1655
%closure.func1656 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure1644, i32 0, i32 2
store void (i8*, i8*, float*, i64, float*)* @vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd__1621, void (i8*, i8*, float*, i64, float*)** %closure.func1656
%closure_size1657 = call i64 @llvm_zone_mark_size(%mzone* %zone1642)
call void @llvm_zone_ptr_set_size(i8* %clsptr1643, i64 %closure_size1657)
%wrapper_ptr1658 = call i8* @llvm_zone_malloc(%mzone* %zone1642, i64 8)
%closure_wrapper1659 = bitcast i8* %wrapper_ptr1658 to { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure1644, { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure_wrapper1659

; let value assignment
%vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd = select i1 true, { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure_wrapper1659, { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure_wrapper1659
store { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd, { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*** %vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpdPtr

; add data to environment
; don't need to alloc for env var vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd
%tmp_envptr1653 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***}* %environment1646, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*** %vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpdPtr, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**** %tmp_envptr1653


%val1662 = load {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*** %vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpdPtr
ret {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %val1662
}


@vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** @vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd(float* %arg_0,i64 %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, float*)*,  void (i8*, i8*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, float* %arg_2)
ret void
}


define dllexport ccc void @vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_native(float* %arg_0,i64 %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, float*)*,  void (i8*, i8*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, float* %arg_2)
ret void
}


define dllexport ccc i8*  @vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1663 = bitcast [98 x i8]* @gsxtmmath80 to i8*
call i32 (i8*, ...) @printf(i8* %var1663)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1664 = bitcast [98 x i8]* @gsxtmmath80 to i8*
call i32 (i8*, ...) @printf(i8* %var1664)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1665 = bitcast [98 x i8]* @gsxtmmath80 to i8*
call i32 (i8*, ...) @printf(i8* %var1665)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, float*)*,  void (i8*, i8*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, float* %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64, float*}*
%arg_p_0 = getelementptr {float*, i64, float*}, {float*, i64, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64, float*}, {float*, i64, float*}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {float*, i64, float*}, {float*, i64, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, float*)*,  void (i8*, i8*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, float* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath81 = hidden constant [40 x i8] c"vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0\00"
@gsxtmmath82 = hidden constant [48 x i8] c"{i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}**\00"
define dllexport fastcc void @vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0__1666(i8* %_impz,i8* %_impenv, i64* %src, i64 %len, i64* %dest) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1667 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}***}*
%vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}***}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}***}* %impenv, i32 0, i32 0
%vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0Ptr = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}***, {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}**** %vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0Ptr_

; setup arguments
%srcPtr = alloca i64*
store i64* %src, i64** %srcPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%destPtr = alloca i64*
store i64* %dest, i64** %destPtr


%tzone1669 = load i8*, i8** %_impzPtr
%zone1670 = bitcast i8* %tzone1669 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val1668 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val1668, i64 %val1668
store i64 %i, i64* %iPtr

; setup loop
%val1673 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val1681 = load i64, i64* %iPtr
%num1682 = add i64 %val1673, %val1681
%comp1683 = icmp ult i64 %val1673, 1
br i1 %comp1683, label %after1671, label %loop1671

loop1671:
%val1674 = load i64, i64* %iPtr
%val1675 = load i64*, i64** %destPtr
%val1676 = load i64, i64* %iPtr
%val1677 = load i64*, i64** %srcPtr
; pointer ref
%val1678 = getelementptr i64, i64* %val1677, i64 %val1676
%val1679 = load i64, i64* %val1678
; set pointer
%val1680 = getelementptr i64, i64* %val1675, i64 %val1674
store i64 %val1679, i64* %val1680
%loop_cnt1671 = load i64, i64* %iPtr
%next1671 = add i64 %loop_cnt1671, 1
store i64 %next1671, i64* %iPtr
%cmp1671 = icmp ult i64 %next1671, %num1682
br i1 %cmp1671, label %loop1671, label %after1671

after1671:
ret void
}
@gsxtmmath83 = hidden constant [93 x i8] c"vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}** @vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1705 = load i8*, i8** %_impzPtr
%zone1706 = bitcast i8* %tzone1705 to %mzone*

; let assign value to symbol vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0
%dat_vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone1706, i64 8)
%vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0Ptr = bitcast i8* %dat_vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0 to { i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}***
%tzone1686 = load i8*, i8** %_impzPtr
%zone1687 = bitcast i8* %tzone1686 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1687)
; malloc closure structure
%clsptr1688 = call i8* @llvm_zone_malloc(%mzone* %zone1687, i64 24)
%closure1689 = bitcast i8* %clsptr1688 to { i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}*

; malloc environment structure
%envptr1690 = call i8* @llvm_zone_malloc(%mzone* %zone1687, i64 8)
%environment1691 = bitcast i8* %envptr1690 to {{i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}***}*

; malloc closure address table
%addytable1692 = call %clsvar* @new_address_table()
%var1693 = bitcast [40 x i8]* @gsxtmmath81 to i8*
%var1694 = bitcast [48 x i8]* @gsxtmmath82 to i8*
%addytable1695 = call %clsvar* @add_address_table(%mzone* %zone1687, i8* %var1693, i32 0, i8* %var1694, i32 3, %clsvar* %addytable1692)
%address-table1696 = bitcast %clsvar* %addytable1695 to i8*

; insert table, function and environment into closure struct
%closure.table1699 = getelementptr { i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}, { i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}* %closure1689, i32 0, i32 0
store i8* %address-table1696, i8** %closure.table1699
%closure.env1700 = getelementptr { i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}, { i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}* %closure1689, i32 0, i32 1
store i8* %envptr1690, i8** %closure.env1700
%closure.func1701 = getelementptr { i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}, { i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}* %closure1689, i32 0, i32 2
store void (i8*, i8*, i64*, i64, i64*)* @vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0__1666, void (i8*, i8*, i64*, i64, i64*)** %closure.func1701
%closure_size1702 = call i64 @llvm_zone_mark_size(%mzone* %zone1687)
call void @llvm_zone_ptr_set_size(i8* %clsptr1688, i64 %closure_size1702)
%wrapper_ptr1703 = call i8* @llvm_zone_malloc(%mzone* %zone1687, i64 8)
%closure_wrapper1704 = bitcast i8* %wrapper_ptr1703 to { i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}**
store { i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}* %closure1689, { i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}** %closure_wrapper1704

; let value assignment
%vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}** %closure_wrapper1704, { i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}** %closure_wrapper1704
store { i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}** %vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0, { i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}*** %vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0Ptr

; add data to environment
; don't need to alloc for env var vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0
%tmp_envptr1698 = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}***}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}***}* %environment1691, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}*** %vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0Ptr, {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}**** %tmp_envptr1698


%val1707 = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}**, {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}*** %vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}** %val1707
}


@vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}** @vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0(i64* %arg_0,i64 %arg_1,i64* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}*, {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64*, i64, i64*)*,  void (i8*, i8*, i64*, i64, i64*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1, i64* %arg_2)
ret void
}


define dllexport ccc void @vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0_native(i64* %arg_0,i64 %arg_1,i64* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}*, {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64*, i64, i64*)*,  void (i8*, i8*, i64*, i64, i64*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1, i64* %arg_2)
ret void
}


define dllexport ccc i8*  @vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1708 = bitcast [93 x i8]* @gsxtmmath83 to i8*
call i32 (i8*, ...) @printf(i8* %var1708)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i64*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1709 = bitcast [93 x i8]* @gsxtmmath83 to i8*
call i32 (i8*, ...) @printf(i8* %var1709)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1710 = bitcast [93 x i8]* @gsxtmmath83 to i8*
call i32 (i8*, ...) @printf(i8* %var1710)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to i64*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}*, {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64*, i64, i64*)*,  void (i8*, i8*, i64*, i64, i64*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1, i64* %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64*, i64, i64*}*
%arg_p_0 = getelementptr {i64*, i64, i64*}, {i64*, i64, i64*}* %fstruct, i32 0, i32 0
%arg_0 = load i64*, i64** %arg_p_0
%arg_p_1 = getelementptr {i64*, i64, i64*}, {i64*, i64, i64*}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {i64*, i64, i64*}, {i64*, i64, i64*}* %fstruct, i32 0, i32 2
%arg_2 = load i64*, i64** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}*, {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64*, i64, i64*)*,  void (i8*, i8*, i64*, i64, i64*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1, i64* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath84 = hidden constant [40 x i8] c"vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0\00"
@gsxtmmath85 = hidden constant [48 x i8] c"{i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}**\00"
define dllexport fastcc void @vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0__1711(i8* %_impz,i8* %_impenv, i32* %src, i64 %len, i32* %dest) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1712 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}***}*
%vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}***}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}***}* %impenv, i32 0, i32 0
%vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0Ptr = load {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}***, {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}**** %vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0Ptr_

; setup arguments
%srcPtr = alloca i32*
store i32* %src, i32** %srcPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%destPtr = alloca i32*
store i32* %dest, i32** %destPtr


%tzone1714 = load i8*, i8** %_impzPtr
%zone1715 = bitcast i8* %tzone1714 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val1713 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val1713, i64 %val1713
store i64 %i, i64* %iPtr

; setup loop
%val1718 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val1726 = load i64, i64* %iPtr
%num1727 = add i64 %val1718, %val1726
%comp1728 = icmp ult i64 %val1718, 1
br i1 %comp1728, label %after1716, label %loop1716

loop1716:
%val1719 = load i64, i64* %iPtr
%val1720 = load i32*, i32** %destPtr
%val1721 = load i64, i64* %iPtr
%val1722 = load i32*, i32** %srcPtr
; pointer ref
%val1723 = getelementptr i32, i32* %val1722, i64 %val1721
%val1724 = load i32, i32* %val1723
; set pointer
%val1725 = getelementptr i32, i32* %val1720, i64 %val1719
store i32 %val1724, i32* %val1725
%loop_cnt1716 = load i64, i64* %iPtr
%next1716 = add i64 %loop_cnt1716, 1
store i64 %next1716, i64* %iPtr
%cmp1716 = icmp ult i64 %next1716, %num1727
br i1 %cmp1716, label %loop1716, label %after1716

after1716:
ret void
}
@gsxtmmath86 = hidden constant [93 x i8] c"vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}** @vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1750 = load i8*, i8** %_impzPtr
%zone1751 = bitcast i8* %tzone1750 to %mzone*

; let assign value to symbol vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0
%dat_vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1751, i64 8)
%vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0Ptr = bitcast i8* %dat_vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0 to { i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}***
%tzone1731 = load i8*, i8** %_impzPtr
%zone1732 = bitcast i8* %tzone1731 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1732)
; malloc closure structure
%clsptr1733 = call i8* @llvm_zone_malloc(%mzone* %zone1732, i64 24)
%closure1734 = bitcast i8* %clsptr1733 to { i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}*

; malloc environment structure
%envptr1735 = call i8* @llvm_zone_malloc(%mzone* %zone1732, i64 8)
%environment1736 = bitcast i8* %envptr1735 to {{i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}***}*

; malloc closure address table
%addytable1737 = call %clsvar* @new_address_table()
%var1738 = bitcast [40 x i8]* @gsxtmmath84 to i8*
%var1739 = bitcast [48 x i8]* @gsxtmmath85 to i8*
%addytable1740 = call %clsvar* @add_address_table(%mzone* %zone1732, i8* %var1738, i32 0, i8* %var1739, i32 3, %clsvar* %addytable1737)
%address-table1741 = bitcast %clsvar* %addytable1740 to i8*

; insert table, function and environment into closure struct
%closure.table1744 = getelementptr { i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}, { i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}* %closure1734, i32 0, i32 0
store i8* %address-table1741, i8** %closure.table1744
%closure.env1745 = getelementptr { i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}, { i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}* %closure1734, i32 0, i32 1
store i8* %envptr1735, i8** %closure.env1745
%closure.func1746 = getelementptr { i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}, { i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}* %closure1734, i32 0, i32 2
store void (i8*, i8*, i32*, i64, i32*)* @vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0__1711, void (i8*, i8*, i32*, i64, i32*)** %closure.func1746
%closure_size1747 = call i64 @llvm_zone_mark_size(%mzone* %zone1732)
call void @llvm_zone_ptr_set_size(i8* %clsptr1733, i64 %closure_size1747)
%wrapper_ptr1748 = call i8* @llvm_zone_malloc(%mzone* %zone1732, i64 8)
%closure_wrapper1749 = bitcast i8* %wrapper_ptr1748 to { i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}**
store { i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}* %closure1734, { i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}** %closure_wrapper1749

; let value assignment
%vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}** %closure_wrapper1749, { i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}** %closure_wrapper1749
store { i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}** %vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0, { i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}*** %vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0Ptr

; add data to environment
; don't need to alloc for env var vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0
%tmp_envptr1743 = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}***}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}***}* %environment1736, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}*** %vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0Ptr, {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}**** %tmp_envptr1743


%val1752 = load {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}**, {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}*** %vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0Ptr
ret {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}** %val1752
}


@vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0_var = dllexport global [1 x i8*] [ i8* null ]

@vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}** @vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0(i32* %arg_0,i64 %arg_1,i32* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}*, {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32*, i64, i32*)*,  void (i8*, i8*, i32*, i64, i32*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i32* %arg_2)
ret void
}


define dllexport ccc void @vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0_native(i32* %arg_0,i64 %arg_1,i32* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}*, {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32*, i64, i32*)*,  void (i8*, i8*, i32*, i64, i32*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i32* %arg_2)
ret void
}


define dllexport ccc i8*  @vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1753 = bitcast [93 x i8]* @gsxtmmath86 to i8*
call i32 (i8*, ...) @printf(i8* %var1753)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i32*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1754 = bitcast [93 x i8]* @gsxtmmath86 to i8*
call i32 (i8*, ...) @printf(i8* %var1754)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1755 = bitcast [93 x i8]* @gsxtmmath86 to i8*
call i32 (i8*, ...) @printf(i8* %var1755)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to i32*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}*, {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32*, i64, i32*)*,  void (i8*, i8*, i32*, i64, i32*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i32* %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32*, i64, i32*}*
%arg_p_0 = getelementptr {i32*, i64, i32*}, {i32*, i64, i32*}* %fstruct, i32 0, i32 0
%arg_0 = load i32*, i32** %arg_p_0
%arg_p_1 = getelementptr {i32*, i64, i32*}, {i32*, i64, i32*}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {i32*, i64, i32*}, {i32*, i64, i32*}* %fstruct, i32 0, i32 2
%arg_2 = load i32*, i32** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vcopy_adhoc_W3ZvaWQsaTMyKixpNjQsaTMyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}*, {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i32*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32*, i64, i32*)*,  void (i8*, i8*, i32*, i64, i32*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i32* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath87 = hidden constant [50 x i8] c"vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd\00"
define dllexport fastcc void @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd__1756(i8* %_impz,i8* %_impenv, float* %v1, i64 %len, float* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1757 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***}*
%vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***}* %impenv, i32 0, i32 0
%vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpdPtr = load {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**** %vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpdPtr_

; setup arguments
%v1Ptr = alloca float*
store float* %v1, float** %v1Ptr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%resultPtr = alloca float*
store float* %result, float** %resultPtr


%tzone1758 = load i8*, i8** %_impzPtr
%zone1759 = bitcast i8* %tzone1758 to %mzone*

; let assign value to symbol mag
%magPtr = alloca float
%tzone1760 = load i8*, i8** %_impzPtr
%zone1761 = bitcast i8* %tzone1760 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%mag = select i1 true, float 0x0, float 0x0
store float %mag, float* %magPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val1764 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val1776 = load i64, i64* %iPtr
%num1777 = add i64 %val1764, %val1776
%comp1778 = icmp ult i64 %val1764, 1
br i1 %comp1778, label %after1762, label %loop1762

loop1762:
; do set!
%val1765 = load float, float* %magPtr
%val1766 = load i64, i64* %iPtr
%val1767 = load float*, float** %v1Ptr
; pointer ref
%val1768 = getelementptr float, float* %val1767, i64 %val1766
%val1769 = load float, float* %val1768
%val1770 = load i64, i64* %iPtr
%val1771 = load float*, float** %v1Ptr
; pointer ref
%val1772 = getelementptr float, float* %val1771, i64 %val1770
%val1773 = load float, float* %val1772
%val1774 = fmul float %val1769, %val1773
%val1775 = fadd float %val1765, %val1774
store float %val1775, float* %magPtr
%loop_cnt1762 = load i64, i64* %iPtr
%next1762 = add i64 %loop_cnt1762, 1
store i64 %next1762, i64* %iPtr
%cmp1762 = icmp ult i64 %next1762, %num1777
br i1 %cmp1762, label %loop1762, label %after1762

after1762:
; do set!
%val1780 = load float, float* %magPtr
%val1781 = call float @llvm.sqrt.f32(float %val1780)
store float %val1781, float* %magPtr
; setup loop
%val1784 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val1794 = load i64, i64* %iPtr
%num1795 = add i64 %val1784, %val1794
%comp1796 = icmp ult i64 %val1784, 1
br i1 %comp1796, label %after1782, label %loop1782

loop1782:
%val1785 = load i64, i64* %iPtr
%val1786 = load float*, float** %resultPtr
%val1787 = load i64, i64* %iPtr
%val1788 = load float*, float** %v1Ptr
; pointer ref
%val1789 = getelementptr float, float* %val1788, i64 %val1787
%val1790 = load float, float* %val1789
%val1791 = load float, float* %magPtr
%val1792 = fdiv float %val1790, %val1791
; set pointer
%val1793 = getelementptr float, float* %val1786, i64 %val1785
store float %val1792, float* %val1793
%loop_cnt1782 = load i64, i64* %iPtr
%next1782 = add i64 %loop_cnt1782, 1
store i64 %next1782, i64* %iPtr
%cmp1782 = icmp ult i64 %next1782, %num1795
br i1 %cmp1782, label %loop1782, label %after1782

after1782:
ret void
}
@gsxtmmath88 = hidden constant [103 x i8] c"vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1818 = load i8*, i8** %_impzPtr
%zone1819 = bitcast i8* %tzone1818 to %mzone*

; let assign value to symbol vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd
%dat_vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd = call i8* @llvm_zone_malloc(%mzone* %zone1819, i64 8)
%vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpdPtr = bitcast i8* %dat_vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd to { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***
%tzone1799 = load i8*, i8** %_impzPtr
%zone1800 = bitcast i8* %tzone1799 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1800)
; malloc closure structure
%clsptr1801 = call i8* @llvm_zone_malloc(%mzone* %zone1800, i64 24)
%closure1802 = bitcast i8* %clsptr1801 to { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*

; malloc environment structure
%envptr1803 = call i8* @llvm_zone_malloc(%mzone* %zone1800, i64 8)
%environment1804 = bitcast i8* %envptr1803 to {{i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***}*

; malloc closure address table
%addytable1805 = call %clsvar* @new_address_table()
%var1806 = bitcast [50 x i8]* @gsxtmmath87 to i8*
%var1807 = bitcast [52 x i8]* @gsxtmmath79 to i8*
%addytable1808 = call %clsvar* @add_address_table(%mzone* %zone1800, i8* %var1806, i32 0, i8* %var1807, i32 3, %clsvar* %addytable1805)
%address-table1809 = bitcast %clsvar* %addytable1808 to i8*

; insert table, function and environment into closure struct
%closure.table1812 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure1802, i32 0, i32 0
store i8* %address-table1809, i8** %closure.table1812
%closure.env1813 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure1802, i32 0, i32 1
store i8* %envptr1803, i8** %closure.env1813
%closure.func1814 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure1802, i32 0, i32 2
store void (i8*, i8*, float*, i64, float*)* @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd__1756, void (i8*, i8*, float*, i64, float*)** %closure.func1814
%closure_size1815 = call i64 @llvm_zone_mark_size(%mzone* %zone1800)
call void @llvm_zone_ptr_set_size(i8* %clsptr1801, i64 %closure_size1815)
%wrapper_ptr1816 = call i8* @llvm_zone_malloc(%mzone* %zone1800, i64 8)
%closure_wrapper1817 = bitcast i8* %wrapper_ptr1816 to { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure1802, { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure_wrapper1817

; let value assignment
%vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd = select i1 true, { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure_wrapper1817, { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure_wrapper1817
store { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd, { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*** %vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpdPtr

; add data to environment
; don't need to alloc for env var vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd
%tmp_envptr1811 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***}* %environment1804, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*** %vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpdPtr, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**** %tmp_envptr1811


%val1820 = load {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*** %vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpdPtr
ret {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %val1820
}


@vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd(float* %arg_0,i64 %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, float*)*,  void (i8*, i8*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, float* %arg_2)
ret void
}


define dllexport ccc void @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_native(float* %arg_0,i64 %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, float*)*,  void (i8*, i8*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, float* %arg_2)
ret void
}


define dllexport ccc i8*  @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1821 = bitcast [103 x i8]* @gsxtmmath88 to i8*
call i32 (i8*, ...) @printf(i8* %var1821)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1822 = bitcast [103 x i8]* @gsxtmmath88 to i8*
call i32 (i8*, ...) @printf(i8* %var1822)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1823 = bitcast [103 x i8]* @gsxtmmath88 to i8*
call i32 (i8*, ...) @printf(i8* %var1823)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, float*)*,  void (i8*, i8*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, float* %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64, float*}*
%arg_p_0 = getelementptr {float*, i64, float*}, {float*, i64, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64, float*}, {float*, i64, float*}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {float*, i64, float*}, {float*, i64, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, float*)*,  void (i8*, i8*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, float* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath89 = hidden constant [53 x i8] c"vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0\00"
define dllexport fastcc void @vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0__1824(i8* %_impz,i8* %_impenv, double* %v1, i64 %len, double* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1825 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***}*
%vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***}* %impenv, i32 0, i32 0
%vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0Ptr = load {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**** %vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0Ptr_

; setup arguments
%v1Ptr = alloca double*
store double* %v1, double** %v1Ptr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%resultPtr = alloca double*
store double* %result, double** %resultPtr


%tzone1826 = load i8*, i8** %_impzPtr
%zone1827 = bitcast i8* %tzone1826 to %mzone*

; let assign value to symbol mag
%magPtr = alloca double
%tzone1828 = load i8*, i8** %_impzPtr
%zone1829 = bitcast i8* %tzone1828 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%mag = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %mag, double* %magPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val1832 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val1844 = load i64, i64* %iPtr
%num1845 = add i64 %val1832, %val1844
%comp1846 = icmp ult i64 %val1832, 1
br i1 %comp1846, label %after1830, label %loop1830

loop1830:
; do set!
%val1833 = load double, double* %magPtr
%val1834 = load i64, i64* %iPtr
%val1835 = load double*, double** %v1Ptr
; pointer ref
%val1836 = getelementptr double, double* %val1835, i64 %val1834
%val1837 = load double, double* %val1836
%val1838 = load i64, i64* %iPtr
%val1839 = load double*, double** %v1Ptr
; pointer ref
%val1840 = getelementptr double, double* %val1839, i64 %val1838
%val1841 = load double, double* %val1840
%val1842 = fmul double %val1837, %val1841
%val1843 = fadd double %val1833, %val1842
store double %val1843, double* %magPtr
%loop_cnt1830 = load i64, i64* %iPtr
%next1830 = add i64 %loop_cnt1830, 1
store i64 %next1830, i64* %iPtr
%cmp1830 = icmp ult i64 %next1830, %num1845
br i1 %cmp1830, label %loop1830, label %after1830

after1830:
; do set!
%val1848 = load double, double* %magPtr
%val1849 = call double @llvm.sqrt.f64(double %val1848)
store double %val1849, double* %magPtr
; setup loop
%val1852 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val1862 = load i64, i64* %iPtr
%num1863 = add i64 %val1852, %val1862
%comp1864 = icmp ult i64 %val1852, 1
br i1 %comp1864, label %after1850, label %loop1850

loop1850:
%val1853 = load i64, i64* %iPtr
%val1854 = load double*, double** %resultPtr
%val1855 = load i64, i64* %iPtr
%val1856 = load double*, double** %v1Ptr
; pointer ref
%val1857 = getelementptr double, double* %val1856, i64 %val1855
%val1858 = load double, double* %val1857
%val1859 = load double, double* %magPtr
%val1860 = fdiv double %val1858, %val1859
; set pointer
%val1861 = getelementptr double, double* %val1854, i64 %val1853
store double %val1860, double* %val1861
%loop_cnt1850 = load i64, i64* %iPtr
%next1850 = add i64 %loop_cnt1850, 1
store i64 %next1850, i64* %iPtr
%cmp1850 = icmp ult i64 %next1850, %num1863
br i1 %cmp1850, label %loop1850, label %after1850

after1850:
ret void
}
@gsxtmmath90 = hidden constant [106 x i8] c"vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** @vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1886 = load i8*, i8** %_impzPtr
%zone1887 = bitcast i8* %tzone1886 to %mzone*

; let assign value to symbol vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0
%dat_vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1887, i64 8)
%vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0Ptr = bitcast i8* %dat_vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0 to { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***
%tzone1867 = load i8*, i8** %_impzPtr
%zone1868 = bitcast i8* %tzone1867 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1868)
; malloc closure structure
%clsptr1869 = call i8* @llvm_zone_malloc(%mzone* %zone1868, i64 24)
%closure1870 = bitcast i8* %clsptr1869 to { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*

; malloc environment structure
%envptr1871 = call i8* @llvm_zone_malloc(%mzone* %zone1868, i64 8)
%environment1872 = bitcast i8* %envptr1871 to {{i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***}*

; malloc closure address table
%addytable1873 = call %clsvar* @new_address_table()
%var1874 = bitcast [53 x i8]* @gsxtmmath89 to i8*
%var1875 = bitcast [54 x i8]* @gsxtmmath76 to i8*
%addytable1876 = call %clsvar* @add_address_table(%mzone* %zone1868, i8* %var1874, i32 0, i8* %var1875, i32 3, %clsvar* %addytable1873)
%address-table1877 = bitcast %clsvar* %addytable1876 to i8*

; insert table, function and environment into closure struct
%closure.table1880 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure1870, i32 0, i32 0
store i8* %address-table1877, i8** %closure.table1880
%closure.env1881 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure1870, i32 0, i32 1
store i8* %envptr1871, i8** %closure.env1881
%closure.func1882 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure1870, i32 0, i32 2
store void (i8*, i8*, double*, i64, double*)* @vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0__1824, void (i8*, i8*, double*, i64, double*)** %closure.func1882
%closure_size1883 = call i64 @llvm_zone_mark_size(%mzone* %zone1868)
call void @llvm_zone_ptr_set_size(i8* %clsptr1869, i64 %closure_size1883)
%wrapper_ptr1884 = call i8* @llvm_zone_malloc(%mzone* %zone1868, i64 8)
%closure_wrapper1885 = bitcast i8* %wrapper_ptr1884 to { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**
store { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure1870, { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure_wrapper1885

; let value assignment
%vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure_wrapper1885, { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure_wrapper1885
store { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0, { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*** %vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0Ptr

; add data to environment
; don't need to alloc for env var vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0
%tmp_envptr1879 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***}* %environment1872, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*** %vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0Ptr, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**** %tmp_envptr1879


%val1888 = load {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*** %vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0Ptr
ret {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %val1888
}


@vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var = dllexport global [1 x i8*] [ i8* null ]

@vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** @vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0(double* %arg_0,i64 %arg_1,double* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, double*)*,  void (i8*, i8*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, double* %arg_2)
ret void
}


define dllexport ccc void @vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_native(double* %arg_0,i64 %arg_1,double* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, double*)*,  void (i8*, i8*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, double* %arg_2)
ret void
}


define dllexport ccc i8*  @vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1889 = bitcast [106 x i8]* @gsxtmmath90 to i8*
call i32 (i8*, ...) @printf(i8* %var1889)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1890 = bitcast [106 x i8]* @gsxtmmath90 to i8*
call i32 (i8*, ...) @printf(i8* %var1890)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1891 = bitcast [106 x i8]* @gsxtmmath90 to i8*
call i32 (i8*, ...) @printf(i8* %var1891)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to double*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, double*)*,  void (i8*, i8*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, double* %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, i64, double*}*
%arg_p_0 = getelementptr {double*, i64, double*}, {double*, i64, double*}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, i64, double*}, {double*, i64, double*}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {double*, i64, double*}, {double*, i64, double*}* %fstruct, i32 0, i32 2
%arg_2 = load double*, double** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vnormalise_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, double*)*,  void (i8*, i8*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, double* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath91 = hidden constant [47 x i8] c"vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ\00"
@gsxtmmath92 = hidden constant [53 x i8] c"{i8*, i8*, float (i8*, i8*, float*, float*, i64)*}**\00"
@gsxtmmath93 = hidden constant [2 x i8] c"i\00"
@gsxtmmath94 = hidden constant [4 x i8] c"i64\00"
@gsxtmmath95 = hidden constant [15 x i8] c"_anon_lambda_1\00"
define dllexport fastcc float @vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ__1892(i8* %_impz,i8* %_impenv, float* %v1, float* %v2, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1895 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***, i64*, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***}*
%vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***, i64*, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***, i64*, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***}* %impenv, i32 0, i32 0
%vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQPtr = load {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}**** %vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQPtr_
%iPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***, i64*, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***, i64*, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***}* %impenv, i32 0, i32 1
%iPtr = load i64*, i64** %iPtr_
%_anon_lambda_1Ptr_ = getelementptr {{i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***, i64*, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***, i64*, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_1Ptr = load {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}**** %_anon_lambda_1Ptr_

; setup arguments
%v1Ptr = alloca float*
store float* %v1, float** %v1Ptr
%v2Ptr = alloca float*
store float* %v2, float** %v2Ptr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone1896 = load i8*, i8** %_impzPtr
%zone1897 = bitcast i8* %tzone1896 to %mzone*

; let assign value to symbol res
%resPtr = alloca float

; let value assignment
%res = select i1 true, float 0x0, float 0x0
store float %res, float* %resPtr

; setup loop
%val1900 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val1912 = load i64, i64* %iPtr
%num1913 = add i64 %val1900, %val1912
%comp1914 = icmp ult i64 %val1900, 1
br i1 %comp1914, label %after1898, label %loop1898

loop1898:
; do set!
%val1901 = load float, float* %resPtr
%val1902 = load i64, i64* %iPtr
%val1903 = load float*, float** %v1Ptr
; pointer ref
%val1904 = getelementptr float, float* %val1903, i64 %val1902
%val1905 = load float, float* %val1904
%val1906 = load i64, i64* %iPtr
%val1907 = load float*, float** %v2Ptr
; pointer ref
%val1908 = getelementptr float, float* %val1907, i64 %val1906
%val1909 = load float, float* %val1908
%val1910 = fmul float %val1905, %val1909
%val1911 = fadd float %val1901, %val1910
store float %val1911, float* %resPtr
%loop_cnt1898 = load i64, i64* %iPtr
%next1898 = add i64 %loop_cnt1898, 1
store i64 %next1898, i64* %iPtr
%cmp1898 = icmp ult i64 %next1898, %num1913
br i1 %cmp1898, label %loop1898, label %after1898

after1898:
%val1916 = load float, float* %resPtr
ret float %val1916
}
@gsxtmmath96 = hidden constant [100 x i8] c"vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}** @vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1949 = load i8*, i8** %_impzPtr
%zone1950 = bitcast i8* %tzone1949 to %mzone*

; let assign value to symbol vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ
%dat_vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone1950, i64 8)
%vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQPtr = bitcast i8* %dat_vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ to {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***
%tzone1893 = load i8*, i8** %_impzPtr
%zone1894 = bitcast i8* %tzone1893 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone1894, i64 8)
%iPtr = bitcast i8* %dat_i to i64*

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

%tzone1946 = load i8*, i8** %_impzPtr
%zone1947 = bitcast i8* %tzone1946 to %mzone*

; let assign value to symbol _anon_lambda_1
%dat__anon_lambda_1 = call i8* @llvm_zone_malloc(%mzone* %zone1947, i64 8)
%_anon_lambda_1Ptr = bitcast i8* %dat__anon_lambda_1 to { i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***
%tzone1917 = load i8*, i8** %_impzPtr
%zone1918 = bitcast i8* %tzone1917 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1918)
; malloc closure structure
%clsptr1919 = call i8* @llvm_zone_malloc(%mzone* %zone1918, i64 24)
%closure1920 = bitcast i8* %clsptr1919 to { i8*, i8*, float (i8*, i8*, float*, float*, i64)*}*

; malloc environment structure
%envptr1921 = call i8* @llvm_zone_malloc(%mzone* %zone1918, i64 24)
%environment1922 = bitcast i8* %envptr1921 to {{i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***, i64*, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***}*

; malloc closure address table
%addytable1923 = call %clsvar* @new_address_table()
%var1924 = bitcast [47 x i8]* @gsxtmmath91 to i8*
%var1925 = bitcast [53 x i8]* @gsxtmmath92 to i8*
%addytable1926 = call %clsvar* @add_address_table(%mzone* %zone1918, i8* %var1924, i32 0, i8* %var1925, i32 3, %clsvar* %addytable1923)
%var1927 = bitcast [2 x i8]* @gsxtmmath93 to i8*
%var1928 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable1929 = call %clsvar* @add_address_table(%mzone* %zone1918, i8* %var1927, i32 8, i8* %var1928, i32 3, %clsvar* %addytable1926)
%var1930 = bitcast [15 x i8]* @gsxtmmath95 to i8*
%var1931 = bitcast [53 x i8]* @gsxtmmath92 to i8*
%addytable1932 = call %clsvar* @add_address_table(%mzone* %zone1918, i8* %var1930, i32 16, i8* %var1931, i32 3, %clsvar* %addytable1929)
%address-table1933 = bitcast %clsvar* %addytable1932 to i8*

; insert table, function and environment into closure struct
%closure.table1940 = getelementptr { i8*, i8*, float (i8*, i8*, float*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, float*, i64)*}* %closure1920, i32 0, i32 0
store i8* %address-table1933, i8** %closure.table1940
%closure.env1941 = getelementptr { i8*, i8*, float (i8*, i8*, float*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, float*, i64)*}* %closure1920, i32 0, i32 1
store i8* %envptr1921, i8** %closure.env1941
%closure.func1942 = getelementptr { i8*, i8*, float (i8*, i8*, float*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, float*, i64)*}* %closure1920, i32 0, i32 2
store float (i8*, i8*, float*, float*, i64)* @vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ__1892, float (i8*, i8*, float*, float*, i64)** %closure.func1942
%closure_size1943 = call i64 @llvm_zone_mark_size(%mzone* %zone1918)
call void @llvm_zone_ptr_set_size(i8* %clsptr1919, i64 %closure_size1943)
%wrapper_ptr1944 = call i8* @llvm_zone_malloc(%mzone* %zone1918, i64 8)
%closure_wrapper1945 = bitcast i8* %wrapper_ptr1944 to { i8*, i8*, float (i8*, i8*, float*, float*, i64)*}**
store { i8*, i8*, float (i8*, i8*, float*, float*, i64)*}* %closure1920, { i8*, i8*, float (i8*, i8*, float*, float*, i64)*}** %closure_wrapper1945

; let value assignment
%_anon_lambda_1 = select i1 true, { i8*, i8*, float (i8*, i8*, float*, float*, i64)*}** %closure_wrapper1945, { i8*, i8*, float (i8*, i8*, float*, float*, i64)*}** %closure_wrapper1945
store { i8*, i8*, float (i8*, i8*, float*, float*, i64)*}** %_anon_lambda_1, { i8*, i8*, float (i8*, i8*, float*, float*, i64)*}*** %_anon_lambda_1Ptr

; add data to environment
; don't need to alloc for env var vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ
%tmp_envptr1935 = getelementptr {{i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***, i64*, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***, i64*, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***}* %environment1922, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}*** %vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQPtr, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}**** %tmp_envptr1935

; don't need to alloc for env var i
%tmp_envptr1937 = getelementptr {{i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***, i64*, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***, i64*, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***}* %environment1922, i32 0, i32 1
store i64* %iPtr, i64** %tmp_envptr1937

; don't need to alloc for env var _anon_lambda_1
%tmp_envptr1939 = getelementptr {{i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***, i64*, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***, i64*, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}***}* %environment1922, i32 0, i32 2
store {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}*** %_anon_lambda_1Ptr, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}**** %tmp_envptr1939


%val1948 = load {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}**, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}*** %_anon_lambda_1Ptr

; let value assignment
%vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ = select i1 true, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}** %val1948, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}** %val1948
store {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}** %vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}*** %vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQPtr

%val1951 = load {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}**, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}*** %vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQPtr
ret {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}** %val1951
}


@vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}** @vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ(float* %arg_0,float* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, float*, i64)*,  float (i8*, i8*, float*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2)
ret float %result
}


define dllexport ccc float @vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ_native(float* %arg_0,float* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, float*, i64)*,  float (i8*, i8*, float*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2)
ret float %result
}


define dllexport ccc i8*  @vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1952 = bitcast [100 x i8]* @gsxtmmath96 to i8*
call i32 (i8*, ...) @printf(i8* %var1952)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1953 = bitcast [100 x i8]* @gsxtmmath96 to i8*
call i32 (i8*, ...) @printf(i8* %var1953)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1954 = bitcast [100 x i8]* @gsxtmmath96 to i8*
call i32 (i8*, ...) @printf(i8* %var1954)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, float*, i64)*,  float (i8*, i8*, float*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, i64}*
%arg_p_0 = getelementptr {float*, float*, i64}, {float*, float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, i64}, {float*, float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, i64}, {float*, float*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, float*, i64)*,  float (i8*, i8*, float*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath97 = hidden constant [51 x i8] c"vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ\00"
@gsxtmmath98 = hidden constant [56 x i8] c"{i8*, i8*, double (i8*, i8*, double*, double*, i64)*}**\00"
@gsxtmmath99 = hidden constant [15 x i8] c"_anon_lambda_2\00"
define dllexport fastcc double @vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ__1955(i8* %_impz,i8* %_impenv, double* %v1, double* %v2, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1958 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***, i64*, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***}*
%vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***, i64*, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***, i64*, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***}* %impenv, i32 0, i32 0
%vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQPtr = load {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}**** %vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQPtr_
%iPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***, i64*, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***, i64*, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***}* %impenv, i32 0, i32 1
%iPtr = load i64*, i64** %iPtr_
%_anon_lambda_2Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***, i64*, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***, i64*, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_2Ptr = load {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}**** %_anon_lambda_2Ptr_

; setup arguments
%v1Ptr = alloca double*
store double* %v1, double** %v1Ptr
%v2Ptr = alloca double*
store double* %v2, double** %v2Ptr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone1959 = load i8*, i8** %_impzPtr
%zone1960 = bitcast i8* %tzone1959 to %mzone*

; let assign value to symbol res
%resPtr = alloca double

; let value assignment
%res = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %res, double* %resPtr

; setup loop
%val1963 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val1975 = load i64, i64* %iPtr
%num1976 = add i64 %val1963, %val1975
%comp1977 = icmp ult i64 %val1963, 1
br i1 %comp1977, label %after1961, label %loop1961

loop1961:
; do set!
%val1964 = load double, double* %resPtr
%val1965 = load i64, i64* %iPtr
%val1966 = load double*, double** %v1Ptr
; pointer ref
%val1967 = getelementptr double, double* %val1966, i64 %val1965
%val1968 = load double, double* %val1967
%val1969 = load i64, i64* %iPtr
%val1970 = load double*, double** %v2Ptr
; pointer ref
%val1971 = getelementptr double, double* %val1970, i64 %val1969
%val1972 = load double, double* %val1971
%val1973 = fmul double %val1968, %val1972
%val1974 = fadd double %val1964, %val1973
store double %val1974, double* %resPtr
%loop_cnt1961 = load i64, i64* %iPtr
%next1961 = add i64 %loop_cnt1961, 1
store i64 %next1961, i64* %iPtr
%cmp1961 = icmp ult i64 %next1961, %num1976
br i1 %cmp1961, label %loop1961, label %after1961

after1961:
%val1979 = load double, double* %resPtr
ret double %val1979
}
@gsxtmmath100 = hidden constant [104 x i8] c"vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}** @vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2012 = load i8*, i8** %_impzPtr
%zone2013 = bitcast i8* %tzone2012 to %mzone*

; let assign value to symbol vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ
%dat_vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone2013, i64 8)
%vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQPtr = bitcast i8* %dat_vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ to {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***
%tzone1956 = load i8*, i8** %_impzPtr
%zone1957 = bitcast i8* %tzone1956 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone1957, i64 8)
%iPtr = bitcast i8* %dat_i to i64*

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

%tzone2009 = load i8*, i8** %_impzPtr
%zone2010 = bitcast i8* %tzone2009 to %mzone*

; let assign value to symbol _anon_lambda_2
%dat__anon_lambda_2 = call i8* @llvm_zone_malloc(%mzone* %zone2010, i64 8)
%_anon_lambda_2Ptr = bitcast i8* %dat__anon_lambda_2 to { i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***
%tzone1980 = load i8*, i8** %_impzPtr
%zone1981 = bitcast i8* %tzone1980 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1981)
; malloc closure structure
%clsptr1982 = call i8* @llvm_zone_malloc(%mzone* %zone1981, i64 24)
%closure1983 = bitcast i8* %clsptr1982 to { i8*, i8*, double (i8*, i8*, double*, double*, i64)*}*

; malloc environment structure
%envptr1984 = call i8* @llvm_zone_malloc(%mzone* %zone1981, i64 24)
%environment1985 = bitcast i8* %envptr1984 to {{i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***, i64*, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***}*

; malloc closure address table
%addytable1986 = call %clsvar* @new_address_table()
%var1987 = bitcast [51 x i8]* @gsxtmmath97 to i8*
%var1988 = bitcast [56 x i8]* @gsxtmmath98 to i8*
%addytable1989 = call %clsvar* @add_address_table(%mzone* %zone1981, i8* %var1987, i32 0, i8* %var1988, i32 3, %clsvar* %addytable1986)
%var1990 = bitcast [2 x i8]* @gsxtmmath93 to i8*
%var1991 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable1992 = call %clsvar* @add_address_table(%mzone* %zone1981, i8* %var1990, i32 8, i8* %var1991, i32 3, %clsvar* %addytable1989)
%var1993 = bitcast [15 x i8]* @gsxtmmath99 to i8*
%var1994 = bitcast [56 x i8]* @gsxtmmath98 to i8*
%addytable1995 = call %clsvar* @add_address_table(%mzone* %zone1981, i8* %var1993, i32 16, i8* %var1994, i32 3, %clsvar* %addytable1992)
%address-table1996 = bitcast %clsvar* %addytable1995 to i8*

; insert table, function and environment into closure struct
%closure.table2003 = getelementptr { i8*, i8*, double (i8*, i8*, double*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, double*, i64)*}* %closure1983, i32 0, i32 0
store i8* %address-table1996, i8** %closure.table2003
%closure.env2004 = getelementptr { i8*, i8*, double (i8*, i8*, double*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, double*, i64)*}* %closure1983, i32 0, i32 1
store i8* %envptr1984, i8** %closure.env2004
%closure.func2005 = getelementptr { i8*, i8*, double (i8*, i8*, double*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, double*, i64)*}* %closure1983, i32 0, i32 2
store double (i8*, i8*, double*, double*, i64)* @vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ__1955, double (i8*, i8*, double*, double*, i64)** %closure.func2005
%closure_size2006 = call i64 @llvm_zone_mark_size(%mzone* %zone1981)
call void @llvm_zone_ptr_set_size(i8* %clsptr1982, i64 %closure_size2006)
%wrapper_ptr2007 = call i8* @llvm_zone_malloc(%mzone* %zone1981, i64 8)
%closure_wrapper2008 = bitcast i8* %wrapper_ptr2007 to { i8*, i8*, double (i8*, i8*, double*, double*, i64)*}**
store { i8*, i8*, double (i8*, i8*, double*, double*, i64)*}* %closure1983, { i8*, i8*, double (i8*, i8*, double*, double*, i64)*}** %closure_wrapper2008

; let value assignment
%_anon_lambda_2 = select i1 true, { i8*, i8*, double (i8*, i8*, double*, double*, i64)*}** %closure_wrapper2008, { i8*, i8*, double (i8*, i8*, double*, double*, i64)*}** %closure_wrapper2008
store { i8*, i8*, double (i8*, i8*, double*, double*, i64)*}** %_anon_lambda_2, { i8*, i8*, double (i8*, i8*, double*, double*, i64)*}*** %_anon_lambda_2Ptr

; add data to environment
; don't need to alloc for env var vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ
%tmp_envptr1998 = getelementptr {{i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***, i64*, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***, i64*, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***}* %environment1985, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}*** %vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQPtr, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}**** %tmp_envptr1998

; don't need to alloc for env var i
%tmp_envptr2000 = getelementptr {{i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***, i64*, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***, i64*, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***}* %environment1985, i32 0, i32 1
store i64* %iPtr, i64** %tmp_envptr2000

; don't need to alloc for env var _anon_lambda_2
%tmp_envptr2002 = getelementptr {{i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***, i64*, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***, i64*, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}***}* %environment1985, i32 0, i32 2
store {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}*** %_anon_lambda_2Ptr, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}**** %tmp_envptr2002


%val2011 = load {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}**, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}*** %_anon_lambda_2Ptr

; let value assignment
%vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ = select i1 true, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}** %val2011, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}** %val2011
store {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}** %vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}*** %vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQPtr

%val2014 = load {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}**, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}*** %vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQPtr
ret {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}** %val2014
}


@vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}** @vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ(double* %arg_0,double* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, double*, i64)*,  double (i8*, i8*, double*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2)
ret double %result
}


define dllexport ccc double @vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ_native(double* %arg_0,double* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, double*, i64)*,  double (i8*, i8*, double*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2)
ret double %result
}


define dllexport ccc i8*  @vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2015 = bitcast [104 x i8]* @gsxtmmath100 to i8*
call i32 (i8*, ...) @printf(i8* %var2015)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2016 = bitcast [104 x i8]* @gsxtmmath100 to i8*
call i32 (i8*, ...) @printf(i8* %var2016)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to double*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2017 = bitcast [104 x i8]* @gsxtmmath100 to i8*
call i32 (i8*, ...) @printf(i8* %var2017)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, double*, i64)*,  double (i8*, i8*, double*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, double*, i64}*
%arg_p_0 = getelementptr {double*, double*, i64}, {double*, double*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, double*, i64}, {double*, double*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load double*, double** %arg_p_1
%arg_p_2 = getelementptr {double*, double*, i64}, {double*, double*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvdot_adhoc_W2RvdWJsZSxkb3VibGUqLGRvdWJsZSosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, double*, i64)*,  double (i8*, i8*, double*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath101 = hidden constant [51 x i8] c"vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd\00"
@gsxtmmath102 = hidden constant [55 x i8] c"{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}**\00"
@gsxtmmath103 = hidden constant [15 x i8] c"_anon_lambda_3\00"
define dllexport fastcc void @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd__2018(i8* %_impz,i8* %_impenv, float* %v1, float* %v2, float* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2021 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***}*
%vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr = load {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}**** %vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***}* %impenv, i32 0, i32 1
%iPtr = load i64*, i64** %iPtr_
%_anon_lambda_3Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_3Ptr = load {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}**** %_anon_lambda_3Ptr_

; setup arguments
%v1Ptr = alloca float*
store float* %v1, float** %v1Ptr
%v2Ptr = alloca float*
store float* %v2, float** %v2Ptr
%resultPtr = alloca float*
store float* %result, float** %resultPtr


%val2022 = load float*, float** %resultPtr
%val2023 = load float*, float** %v1Ptr
; pointer ref
%val2024 = getelementptr float, float* %val2023, i64 1
%val2025 = load float, float* %val2024
%val2026 = load float*, float** %v2Ptr
; pointer ref
%val2027 = getelementptr float, float* %val2026, i64 2
%val2028 = load float, float* %val2027
%val2029 = fmul float %val2025, %val2028
%val2030 = load float*, float** %v2Ptr
; pointer ref
%val2031 = getelementptr float, float* %val2030, i64 1
%val2032 = load float, float* %val2031
%val2033 = load float*, float** %v1Ptr
; pointer ref
%val2034 = getelementptr float, float* %val2033, i64 2
%val2035 = load float, float* %val2034
%val2036 = fmul float %val2032, %val2035
%val2037 = fsub float %val2029, %val2036
; set pointer
%val2038 = getelementptr float, float* %val2022, i64 0
store float %val2037, float* %val2038
%val2039 = load float*, float** %resultPtr
%val2040 = load float*, float** %v2Ptr
; pointer ref
%val2041 = getelementptr float, float* %val2040, i64 0
%val2042 = load float, float* %val2041
%val2043 = load float*, float** %v1Ptr
; pointer ref
%val2044 = getelementptr float, float* %val2043, i64 2
%val2045 = load float, float* %val2044
%val2046 = fmul float %val2042, %val2045
%val2047 = load float*, float** %v1Ptr
; pointer ref
%val2048 = getelementptr float, float* %val2047, i64 0
%val2049 = load float, float* %val2048
%val2050 = load float*, float** %v2Ptr
; pointer ref
%val2051 = getelementptr float, float* %val2050, i64 2
%val2052 = load float, float* %val2051
%val2053 = fmul float %val2049, %val2052
%val2054 = fsub float %val2046, %val2053
; set pointer
%val2055 = getelementptr float, float* %val2039, i64 1
store float %val2054, float* %val2055
%val2056 = load float*, float** %resultPtr
%val2057 = load float*, float** %v1Ptr
; pointer ref
%val2058 = getelementptr float, float* %val2057, i64 0
%val2059 = load float, float* %val2058
%val2060 = load float*, float** %v2Ptr
; pointer ref
%val2061 = getelementptr float, float* %val2060, i64 1
%val2062 = load float, float* %val2061
%val2063 = fmul float %val2059, %val2062
%val2064 = load float*, float** %v2Ptr
; pointer ref
%val2065 = getelementptr float, float* %val2064, i64 0
%val2066 = load float, float* %val2065
%val2067 = load float*, float** %v1Ptr
; pointer ref
%val2068 = getelementptr float, float* %val2067, i64 1
%val2069 = load float, float* %val2068
%val2070 = fmul float %val2066, %val2069
%val2071 = fsub float %val2063, %val2070
; set pointer
%val2072 = getelementptr float, float* %val2056, i64 2
store float %val2071, float* %val2072
ret void
}
@gsxtmmath104 = hidden constant [104 x i8] c"vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2106 = load i8*, i8** %_impzPtr
%zone2107 = bitcast i8* %tzone2106 to %mzone*

; let assign value to symbol vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd
%dat_vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd = call i8* @llvm_zone_malloc(%mzone* %zone2107, i64 8)
%vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr = bitcast i8* %dat_vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd to {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***
%tzone2019 = load i8*, i8** %_impzPtr
%zone2020 = bitcast i8* %tzone2019 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone2020, i64 8)
%iPtr = bitcast i8* %dat_i to i64*

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

%tzone2103 = load i8*, i8** %_impzPtr
%zone2104 = bitcast i8* %tzone2103 to %mzone*

; let assign value to symbol _anon_lambda_3
%dat__anon_lambda_3 = call i8* @llvm_zone_malloc(%mzone* %zone2104, i64 8)
%_anon_lambda_3Ptr = bitcast i8* %dat__anon_lambda_3 to { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***
%tzone2074 = load i8*, i8** %_impzPtr
%zone2075 = bitcast i8* %tzone2074 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2075)
; malloc closure structure
%clsptr2076 = call i8* @llvm_zone_malloc(%mzone* %zone2075, i64 24)
%closure2077 = bitcast i8* %clsptr2076 to { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}*

; malloc environment structure
%envptr2078 = call i8* @llvm_zone_malloc(%mzone* %zone2075, i64 24)
%environment2079 = bitcast i8* %envptr2078 to {{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***}*

; malloc closure address table
%addytable2080 = call %clsvar* @new_address_table()
%var2081 = bitcast [51 x i8]* @gsxtmmath101 to i8*
%var2082 = bitcast [55 x i8]* @gsxtmmath102 to i8*
%addytable2083 = call %clsvar* @add_address_table(%mzone* %zone2075, i8* %var2081, i32 0, i8* %var2082, i32 3, %clsvar* %addytable2080)
%var2084 = bitcast [2 x i8]* @gsxtmmath93 to i8*
%var2085 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable2086 = call %clsvar* @add_address_table(%mzone* %zone2075, i8* %var2084, i32 8, i8* %var2085, i32 3, %clsvar* %addytable2083)
%var2087 = bitcast [15 x i8]* @gsxtmmath103 to i8*
%var2088 = bitcast [55 x i8]* @gsxtmmath102 to i8*
%addytable2089 = call %clsvar* @add_address_table(%mzone* %zone2075, i8* %var2087, i32 16, i8* %var2088, i32 3, %clsvar* %addytable2086)
%address-table2090 = bitcast %clsvar* %addytable2089 to i8*

; insert table, function and environment into closure struct
%closure.table2097 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure2077, i32 0, i32 0
store i8* %address-table2090, i8** %closure.table2097
%closure.env2098 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure2077, i32 0, i32 1
store i8* %envptr2078, i8** %closure.env2098
%closure.func2099 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure2077, i32 0, i32 2
store void (i8*, i8*, float*, float*, float*)* @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd__2018, void (i8*, i8*, float*, float*, float*)** %closure.func2099
%closure_size2100 = call i64 @llvm_zone_mark_size(%mzone* %zone2075)
call void @llvm_zone_ptr_set_size(i8* %clsptr2076, i64 %closure_size2100)
%wrapper_ptr2101 = call i8* @llvm_zone_malloc(%mzone* %zone2075, i64 8)
%closure_wrapper2102 = bitcast i8* %wrapper_ptr2101 to { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure2077, { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %closure_wrapper2102

; let value assignment
%_anon_lambda_3 = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %closure_wrapper2102, { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %closure_wrapper2102
store { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %_anon_lambda_3, { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}*** %_anon_lambda_3Ptr

; add data to environment
; don't need to alloc for env var vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd
%tmp_envptr2092 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***}* %environment2079, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}*** %vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}**** %tmp_envptr2092

; don't need to alloc for env var i
%tmp_envptr2094 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***}* %environment2079, i32 0, i32 1
store i64* %iPtr, i64** %tmp_envptr2094

; don't need to alloc for env var _anon_lambda_3
%tmp_envptr2096 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***}* %environment2079, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}*** %_anon_lambda_3Ptr, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}**** %tmp_envptr2096


%val2105 = load {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}*** %_anon_lambda_3Ptr

; let value assignment
%vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd = select i1 true, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %val2105, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %val2105
store {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}*** %vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr

%val2108 = load {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}*** %vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr
ret {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %val2108
}


@vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd(float* %arg_0,float* %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
ret void
}


define dllexport ccc void @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_native(float* %arg_0,float* %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
ret void
}


define dllexport ccc i8*  @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2109 = bitcast [104 x i8]* @gsxtmmath104 to i8*
call i32 (i8*, ...) @printf(i8* %var2109)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2110 = bitcast [104 x i8]* @gsxtmmath104 to i8*
call i32 (i8*, ...) @printf(i8* %var2110)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2111 = bitcast [104 x i8]* @gsxtmmath104 to i8*
call i32 (i8*, ...) @printf(i8* %var2111)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, float*}*
%arg_p_0 = getelementptr {float*, float*, float*}, {float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, float*}, {float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, float*}, {float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath105 = hidden constant [55 x i8] c"vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd\00"
@gsxtmmath106 = hidden constant [58 x i8] c"{i8*, i8*, void (i8*, i8*, double*, double*, double*)*}**\00"
@gsxtmmath107 = hidden constant [15 x i8] c"_anon_lambda_4\00"
define dllexport fastcc void @vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd__2112(i8* %_impz,i8* %_impenv, double* %v1, double* %v2, double* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2115 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***}*
%vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***}* %impenv, i32 0, i32 0
%vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpdPtr = load {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}**** %vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpdPtr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***}* %impenv, i32 0, i32 1
%iPtr = load i64*, i64** %iPtr_
%_anon_lambda_4Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_4Ptr = load {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}**** %_anon_lambda_4Ptr_

; setup arguments
%v1Ptr = alloca double*
store double* %v1, double** %v1Ptr
%v2Ptr = alloca double*
store double* %v2, double** %v2Ptr
%resultPtr = alloca double*
store double* %result, double** %resultPtr


%val2116 = load double*, double** %resultPtr
%val2117 = load double*, double** %v1Ptr
; pointer ref
%val2118 = getelementptr double, double* %val2117, i64 1
%val2119 = load double, double* %val2118
%val2120 = load double*, double** %v2Ptr
; pointer ref
%val2121 = getelementptr double, double* %val2120, i64 2
%val2122 = load double, double* %val2121
%val2123 = fmul double %val2119, %val2122
%val2124 = load double*, double** %v2Ptr
; pointer ref
%val2125 = getelementptr double, double* %val2124, i64 1
%val2126 = load double, double* %val2125
%val2127 = load double*, double** %v1Ptr
; pointer ref
%val2128 = getelementptr double, double* %val2127, i64 2
%val2129 = load double, double* %val2128
%val2130 = fmul double %val2126, %val2129
%val2131 = fsub double %val2123, %val2130
; set pointer
%val2132 = getelementptr double, double* %val2116, i64 0
store double %val2131, double* %val2132
%val2133 = load double*, double** %resultPtr
%val2134 = load double*, double** %v2Ptr
; pointer ref
%val2135 = getelementptr double, double* %val2134, i64 0
%val2136 = load double, double* %val2135
%val2137 = load double*, double** %v1Ptr
; pointer ref
%val2138 = getelementptr double, double* %val2137, i64 2
%val2139 = load double, double* %val2138
%val2140 = fmul double %val2136, %val2139
%val2141 = load double*, double** %v1Ptr
; pointer ref
%val2142 = getelementptr double, double* %val2141, i64 0
%val2143 = load double, double* %val2142
%val2144 = load double*, double** %v2Ptr
; pointer ref
%val2145 = getelementptr double, double* %val2144, i64 2
%val2146 = load double, double* %val2145
%val2147 = fmul double %val2143, %val2146
%val2148 = fsub double %val2140, %val2147
; set pointer
%val2149 = getelementptr double, double* %val2133, i64 1
store double %val2148, double* %val2149
%val2150 = load double*, double** %resultPtr
%val2151 = load double*, double** %v1Ptr
; pointer ref
%val2152 = getelementptr double, double* %val2151, i64 0
%val2153 = load double, double* %val2152
%val2154 = load double*, double** %v2Ptr
; pointer ref
%val2155 = getelementptr double, double* %val2154, i64 1
%val2156 = load double, double* %val2155
%val2157 = fmul double %val2153, %val2156
%val2158 = load double*, double** %v2Ptr
; pointer ref
%val2159 = getelementptr double, double* %val2158, i64 0
%val2160 = load double, double* %val2159
%val2161 = load double*, double** %v1Ptr
; pointer ref
%val2162 = getelementptr double, double* %val2161, i64 1
%val2163 = load double, double* %val2162
%val2164 = fmul double %val2160, %val2163
%val2165 = fsub double %val2157, %val2164
; set pointer
%val2166 = getelementptr double, double* %val2150, i64 2
store double %val2165, double* %val2166
ret void
}
@gsxtmmath108 = hidden constant [108 x i8] c"vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}** @vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2200 = load i8*, i8** %_impzPtr
%zone2201 = bitcast i8* %tzone2200 to %mzone*

; let assign value to symbol vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd
%dat_vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd = call i8* @llvm_zone_malloc(%mzone* %zone2201, i64 8)
%vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpdPtr = bitcast i8* %dat_vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd to {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***
%tzone2113 = load i8*, i8** %_impzPtr
%zone2114 = bitcast i8* %tzone2113 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone2114, i64 8)
%iPtr = bitcast i8* %dat_i to i64*

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

%tzone2197 = load i8*, i8** %_impzPtr
%zone2198 = bitcast i8* %tzone2197 to %mzone*

; let assign value to symbol _anon_lambda_4
%dat__anon_lambda_4 = call i8* @llvm_zone_malloc(%mzone* %zone2198, i64 8)
%_anon_lambda_4Ptr = bitcast i8* %dat__anon_lambda_4 to { i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***
%tzone2168 = load i8*, i8** %_impzPtr
%zone2169 = bitcast i8* %tzone2168 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2169)
; malloc closure structure
%clsptr2170 = call i8* @llvm_zone_malloc(%mzone* %zone2169, i64 24)
%closure2171 = bitcast i8* %clsptr2170 to { i8*, i8*, void (i8*, i8*, double*, double*, double*)*}*

; malloc environment structure
%envptr2172 = call i8* @llvm_zone_malloc(%mzone* %zone2169, i64 24)
%environment2173 = bitcast i8* %envptr2172 to {{i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***}*

; malloc closure address table
%addytable2174 = call %clsvar* @new_address_table()
%var2175 = bitcast [55 x i8]* @gsxtmmath105 to i8*
%var2176 = bitcast [58 x i8]* @gsxtmmath106 to i8*
%addytable2177 = call %clsvar* @add_address_table(%mzone* %zone2169, i8* %var2175, i32 0, i8* %var2176, i32 3, %clsvar* %addytable2174)
%var2178 = bitcast [2 x i8]* @gsxtmmath93 to i8*
%var2179 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable2180 = call %clsvar* @add_address_table(%mzone* %zone2169, i8* %var2178, i32 8, i8* %var2179, i32 3, %clsvar* %addytable2177)
%var2181 = bitcast [15 x i8]* @gsxtmmath107 to i8*
%var2182 = bitcast [58 x i8]* @gsxtmmath106 to i8*
%addytable2183 = call %clsvar* @add_address_table(%mzone* %zone2169, i8* %var2181, i32 16, i8* %var2182, i32 3, %clsvar* %addytable2180)
%address-table2184 = bitcast %clsvar* %addytable2183 to i8*

; insert table, function and environment into closure struct
%closure.table2191 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double*, double*)*}, { i8*, i8*, void (i8*, i8*, double*, double*, double*)*}* %closure2171, i32 0, i32 0
store i8* %address-table2184, i8** %closure.table2191
%closure.env2192 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double*, double*)*}, { i8*, i8*, void (i8*, i8*, double*, double*, double*)*}* %closure2171, i32 0, i32 1
store i8* %envptr2172, i8** %closure.env2192
%closure.func2193 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double*, double*)*}, { i8*, i8*, void (i8*, i8*, double*, double*, double*)*}* %closure2171, i32 0, i32 2
store void (i8*, i8*, double*, double*, double*)* @vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd__2112, void (i8*, i8*, double*, double*, double*)** %closure.func2193
%closure_size2194 = call i64 @llvm_zone_mark_size(%mzone* %zone2169)
call void @llvm_zone_ptr_set_size(i8* %clsptr2170, i64 %closure_size2194)
%wrapper_ptr2195 = call i8* @llvm_zone_malloc(%mzone* %zone2169, i64 8)
%closure_wrapper2196 = bitcast i8* %wrapper_ptr2195 to { i8*, i8*, void (i8*, i8*, double*, double*, double*)*}**
store { i8*, i8*, void (i8*, i8*, double*, double*, double*)*}* %closure2171, { i8*, i8*, void (i8*, i8*, double*, double*, double*)*}** %closure_wrapper2196

; let value assignment
%_anon_lambda_4 = select i1 true, { i8*, i8*, void (i8*, i8*, double*, double*, double*)*}** %closure_wrapper2196, { i8*, i8*, void (i8*, i8*, double*, double*, double*)*}** %closure_wrapper2196
store { i8*, i8*, void (i8*, i8*, double*, double*, double*)*}** %_anon_lambda_4, { i8*, i8*, void (i8*, i8*, double*, double*, double*)*}*** %_anon_lambda_4Ptr

; add data to environment
; don't need to alloc for env var vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd
%tmp_envptr2186 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***}* %environment2173, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}*** %vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpdPtr, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}**** %tmp_envptr2186

; don't need to alloc for env var i
%tmp_envptr2188 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***}* %environment2173, i32 0, i32 1
store i64* %iPtr, i64** %tmp_envptr2188

; don't need to alloc for env var _anon_lambda_4
%tmp_envptr2190 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}***}* %environment2173, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}*** %_anon_lambda_4Ptr, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}**** %tmp_envptr2190


%val2199 = load {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}**, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}*** %_anon_lambda_4Ptr

; let value assignment
%vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd = select i1 true, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}** %val2199, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}** %val2199
store {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}** %vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}*** %vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpdPtr

%val2202 = load {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}**, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}*** %vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpdPtr
ret {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}** %val2202
}


@vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}** @vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd(double* %arg_0,double* %arg_1,double* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, double*)*,  void (i8*, i8*, double*, double*, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, double* %arg_2)
ret void
}


define dllexport ccc void @vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd_native(double* %arg_0,double* %arg_1,double* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, double*)*,  void (i8*, i8*, double*, double*, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, double* %arg_2)
ret void
}


define dllexport ccc i8*  @vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2203 = bitcast [108 x i8]* @gsxtmmath108 to i8*
call i32 (i8*, ...) @printf(i8* %var2203)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2204 = bitcast [108 x i8]* @gsxtmmath108 to i8*
call i32 (i8*, ...) @printf(i8* %var2204)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to double*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2205 = bitcast [108 x i8]* @gsxtmmath108 to i8*
call i32 (i8*, ...) @printf(i8* %var2205)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to double*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, double*)*,  void (i8*, i8*, double*, double*, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, double* %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, double*, double*}*
%arg_p_0 = getelementptr {double*, double*, double*}, {double*, double*, double*}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, double*, double*}, {double*, double*, double*}* %fstruct, i32 0, i32 1
%arg_1 = load double*, double** %arg_p_1
%arg_p_2 = getelementptr {double*, double*, double*}, {double*, double*, double*}* %fstruct, i32 0, i32 2
%arg_2 = load double*, double** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvcross_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGRvdWJsZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, double*)*,  void (i8*, i8*, double*, double*, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, double* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath109 = hidden constant [53 x i8] c"vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd\00"
@gsxtmmath110 = hidden constant [59 x i8] c"{i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}**\00"
define dllexport fastcc void @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd__2206(i8* %_impz,i8* %_impenv, float* %v1, float %s, i64 %len, float* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2207 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}***}*
%vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}***}* %impenv, i32 0, i32 0
%vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpdPtr = load {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}**** %vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpdPtr_

; setup arguments
%v1Ptr = alloca float*
store float* %v1, float** %v1Ptr
%sPtr = alloca float
store float %s, float* %sPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%resultPtr = alloca float*
store float* %result, float** %resultPtr


%tzone2208 = load i8*, i8** %_impzPtr
%zone2209 = bitcast i8* %tzone2208 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val2212 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val2222 = load i64, i64* %iPtr
%num2223 = add i64 %val2212, %val2222
%comp2224 = icmp ult i64 %val2212, 1
br i1 %comp2224, label %after2210, label %loop2210

loop2210:
%val2213 = load i64, i64* %iPtr
%val2214 = load float*, float** %resultPtr
%val2215 = load float, float* %sPtr
%val2216 = load i64, i64* %iPtr
%val2217 = load float*, float** %v1Ptr
; pointer ref
%val2218 = getelementptr float, float* %val2217, i64 %val2216
%val2219 = load float, float* %val2218
%val2220 = fmul float %val2215, %val2219
; set pointer
%val2221 = getelementptr float, float* %val2214, i64 %val2213
store float %val2220, float* %val2221
%loop_cnt2210 = load i64, i64* %iPtr
%next2210 = add i64 %loop_cnt2210, 1
store i64 %next2210, i64* %iPtr
%cmp2210 = icmp ult i64 %next2210, %num2223
br i1 %cmp2210, label %loop2210, label %after2210

after2210:
ret void
}
@gsxtmmath111 = hidden constant [106 x i8] c"vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2246 = load i8*, i8** %_impzPtr
%zone2247 = bitcast i8* %tzone2246 to %mzone*

; let assign value to symbol vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd
%dat_vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd = call i8* @llvm_zone_malloc(%mzone* %zone2247, i64 8)
%vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpdPtr = bitcast i8* %dat_vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd to { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}***
%tzone2227 = load i8*, i8** %_impzPtr
%zone2228 = bitcast i8* %tzone2227 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2228)
; malloc closure structure
%clsptr2229 = call i8* @llvm_zone_malloc(%mzone* %zone2228, i64 24)
%closure2230 = bitcast i8* %clsptr2229 to { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}*

; malloc environment structure
%envptr2231 = call i8* @llvm_zone_malloc(%mzone* %zone2228, i64 8)
%environment2232 = bitcast i8* %envptr2231 to {{i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}***}*

; malloc closure address table
%addytable2233 = call %clsvar* @new_address_table()
%var2234 = bitcast [53 x i8]* @gsxtmmath109 to i8*
%var2235 = bitcast [59 x i8]* @gsxtmmath110 to i8*
%addytable2236 = call %clsvar* @add_address_table(%mzone* %zone2228, i8* %var2234, i32 0, i8* %var2235, i32 3, %clsvar* %addytable2233)
%address-table2237 = bitcast %clsvar* %addytable2236 to i8*

; insert table, function and environment into closure struct
%closure.table2240 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure2230, i32 0, i32 0
store i8* %address-table2237, i8** %closure.table2240
%closure.env2241 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure2230, i32 0, i32 1
store i8* %envptr2231, i8** %closure.env2241
%closure.func2242 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure2230, i32 0, i32 2
store void (i8*, i8*, float*, float, i64, float*)* @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd__2206, void (i8*, i8*, float*, float, i64, float*)** %closure.func2242
%closure_size2243 = call i64 @llvm_zone_mark_size(%mzone* %zone2228)
call void @llvm_zone_ptr_set_size(i8* %clsptr2229, i64 %closure_size2243)
%wrapper_ptr2244 = call i8* @llvm_zone_malloc(%mzone* %zone2228, i64 8)
%closure_wrapper2245 = bitcast i8* %wrapper_ptr2244 to { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure2230, { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** %closure_wrapper2245

; let value assignment
%vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** %closure_wrapper2245, { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** %closure_wrapper2245
store { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** %vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd, { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}*** %vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpdPtr

; add data to environment
; don't need to alloc for env var vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd
%tmp_envptr2239 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}***}* %environment2232, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}*** %vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpdPtr, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}**** %tmp_envptr2239


%val2248 = load {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}*** %vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpdPtr
ret {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** %val2248
}


@vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd(float* %arg_0,float %arg_1,i64 %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, i64, float*)*,  void (i8*, i8*, float*, float, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, i64 %arg_2, float* %arg_3)
ret void
}


define dllexport ccc void @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_native(float* %arg_0,float %arg_1,i64 %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, i64, float*)*,  void (i8*, i8*, float*, float, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, i64 %arg_2, float* %arg_3)
ret void
}


define dllexport ccc i8*  @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2249 = bitcast [106 x i8]* @gsxtmmath111 to i8*
call i32 (i8*, ...) @printf(i8* %var2249)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2250 = bitcast [106 x i8]* @gsxtmmath111 to i8*
call i32 (i8*, ...) @printf(i8* %var2250)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2251 = bitcast [106 x i8]* @gsxtmmath111 to i8*
call i32 (i8*, ...) @printf(i8* %var2251)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2252 = bitcast [106 x i8]* @gsxtmmath111 to i8*
call i32 (i8*, ...) @printf(i8* %var2252)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, i64, float*)*,  void (i8*, i8*, float*, float, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, i64 %arg_2, float* %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float, i64, float*}*
%arg_p_0 = getelementptr {float*, float, i64, float*}, {float*, float, i64, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float, i64, float*}, {float*, float, i64, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float*, float, i64, float*}, {float*, float, i64, float*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {float*, float, i64, float*}, {float*, float, i64, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, i64, float*)*,  void (i8*, i8*, float*, float, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, i64 %arg_2, float* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath112 = hidden constant [57 x i8] c"vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd\00"
@gsxtmmath113 = hidden constant [62 x i8] c"{i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}**\00"
define dllexport fastcc void @vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd__2253(i8* %_impz,i8* %_impenv, double* %v1, double %s, i64 %len, double* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2254 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}***}*
%vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}***}* %impenv, i32 0, i32 0
%vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpdPtr = load {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}***, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}**** %vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpdPtr_

; setup arguments
%v1Ptr = alloca double*
store double* %v1, double** %v1Ptr
%sPtr = alloca double
store double %s, double* %sPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%resultPtr = alloca double*
store double* %result, double** %resultPtr


%tzone2255 = load i8*, i8** %_impzPtr
%zone2256 = bitcast i8* %tzone2255 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val2259 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val2269 = load i64, i64* %iPtr
%num2270 = add i64 %val2259, %val2269
%comp2271 = icmp ult i64 %val2259, 1
br i1 %comp2271, label %after2257, label %loop2257

loop2257:
%val2260 = load i64, i64* %iPtr
%val2261 = load double*, double** %resultPtr
%val2262 = load double, double* %sPtr
%val2263 = load i64, i64* %iPtr
%val2264 = load double*, double** %v1Ptr
; pointer ref
%val2265 = getelementptr double, double* %val2264, i64 %val2263
%val2266 = load double, double* %val2265
%val2267 = fmul double %val2262, %val2266
; set pointer
%val2268 = getelementptr double, double* %val2261, i64 %val2260
store double %val2267, double* %val2268
%loop_cnt2257 = load i64, i64* %iPtr
%next2257 = add i64 %loop_cnt2257, 1
store i64 %next2257, i64* %iPtr
%cmp2257 = icmp ult i64 %next2257, %num2270
br i1 %cmp2257, label %loop2257, label %after2257

after2257:
ret void
}
@gsxtmmath114 = hidden constant [110 x i8] c"vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** @vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2293 = load i8*, i8** %_impzPtr
%zone2294 = bitcast i8* %tzone2293 to %mzone*

; let assign value to symbol vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd
%dat_vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd = call i8* @llvm_zone_malloc(%mzone* %zone2294, i64 8)
%vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpdPtr = bitcast i8* %dat_vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd to { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}***
%tzone2274 = load i8*, i8** %_impzPtr
%zone2275 = bitcast i8* %tzone2274 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2275)
; malloc closure structure
%clsptr2276 = call i8* @llvm_zone_malloc(%mzone* %zone2275, i64 24)
%closure2277 = bitcast i8* %clsptr2276 to { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}*

; malloc environment structure
%envptr2278 = call i8* @llvm_zone_malloc(%mzone* %zone2275, i64 8)
%environment2279 = bitcast i8* %envptr2278 to {{i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}***}*

; malloc closure address table
%addytable2280 = call %clsvar* @new_address_table()
%var2281 = bitcast [57 x i8]* @gsxtmmath112 to i8*
%var2282 = bitcast [62 x i8]* @gsxtmmath113 to i8*
%addytable2283 = call %clsvar* @add_address_table(%mzone* %zone2275, i8* %var2281, i32 0, i8* %var2282, i32 3, %clsvar* %addytable2280)
%address-table2284 = bitcast %clsvar* %addytable2283 to i8*

; insert table, function and environment into closure struct
%closure.table2287 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure2277, i32 0, i32 0
store i8* %address-table2284, i8** %closure.table2287
%closure.env2288 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure2277, i32 0, i32 1
store i8* %envptr2278, i8** %closure.env2288
%closure.func2289 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure2277, i32 0, i32 2
store void (i8*, i8*, double*, double, i64, double*)* @vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd__2253, void (i8*, i8*, double*, double, i64, double*)** %closure.func2289
%closure_size2290 = call i64 @llvm_zone_mark_size(%mzone* %zone2275)
call void @llvm_zone_ptr_set_size(i8* %clsptr2276, i64 %closure_size2290)
%wrapper_ptr2291 = call i8* @llvm_zone_malloc(%mzone* %zone2275, i64 8)
%closure_wrapper2292 = bitcast i8* %wrapper_ptr2291 to { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}**
store { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure2277, { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** %closure_wrapper2292

; let value assignment
%vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd = select i1 true, { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** %closure_wrapper2292, { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** %closure_wrapper2292
store { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** %vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd, { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}*** %vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpdPtr

; add data to environment
; don't need to alloc for env var vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd
%tmp_envptr2286 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}***}* %environment2279, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}*** %vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpdPtr, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}**** %tmp_envptr2286


%val2295 = load {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}**, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}*** %vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpdPtr
ret {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** %val2295
}


@vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** @vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd(double* %arg_0,double %arg_1,i64 %arg_2,double* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double, i64, double*)*,  void (i8*, i8*, double*, double, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double %arg_1, i64 %arg_2, double* %arg_3)
ret void
}


define dllexport ccc void @vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_native(double* %arg_0,double %arg_1,i64 %arg_2,double* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double, i64, double*)*,  void (i8*, i8*, double*, double, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double %arg_1, i64 %arg_2, double* %arg_3)
ret void
}


define dllexport ccc i8*  @vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2296 = bitcast [110 x i8]* @gsxtmmath114 to i8*
call i32 (i8*, ...) @printf(i8* %var2296)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2297 = bitcast [110 x i8]* @gsxtmmath114 to i8*
call i32 (i8*, ...) @printf(i8* %var2297)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2298 = bitcast [110 x i8]* @gsxtmmath114 to i8*
call i32 (i8*, ...) @printf(i8* %var2298)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2299 = bitcast [110 x i8]* @gsxtmmath114 to i8*
call i32 (i8*, ...) @printf(i8* %var2299)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to double*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double, i64, double*)*,  void (i8*, i8*, double*, double, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double %arg_1, i64 %arg_2, double* %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, double, i64, double*}*
%arg_p_0 = getelementptr {double*, double, i64, double*}, {double*, double, i64, double*}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, double, i64, double*}, {double*, double, i64, double*}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
%arg_p_2 = getelementptr {double*, double, i64, double*}, {double*, double, i64, double*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {double*, double, i64, double*}, {double*, double, i64, double*}* %fstruct, i32 0, i32 3
%arg_3 = load double*, double** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double, i64, double*)*,  void (i8*, i8*, double*, double, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double %arg_1, i64 %arg_2, double* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath115 = hidden constant [53 x i8] c"vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd\00"
define dllexport fastcc void @vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd__2300(i8* %_impz,i8* %_impenv, float* %v1, float %s, i64 %len, float* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2301 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}***}*
%vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}***}* %impenv, i32 0, i32 0
%vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpdPtr = load {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}**** %vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpdPtr_

; setup arguments
%v1Ptr = alloca float*
store float* %v1, float** %v1Ptr
%sPtr = alloca float
store float %s, float* %sPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%resultPtr = alloca float*
store float* %result, float** %resultPtr


%tzone2302 = load i8*, i8** %_impzPtr
%zone2303 = bitcast i8* %tzone2302 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val2306 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val2316 = load i64, i64* %iPtr
%num2317 = add i64 %val2306, %val2316
%comp2318 = icmp ult i64 %val2306, 1
br i1 %comp2318, label %after2304, label %loop2304

loop2304:
%val2307 = load i64, i64* %iPtr
%val2308 = load float*, float** %resultPtr
%val2309 = load i64, i64* %iPtr
%val2310 = load float*, float** %v1Ptr
; pointer ref
%val2311 = getelementptr float, float* %val2310, i64 %val2309
%val2312 = load float, float* %val2311
%val2313 = load float, float* %sPtr
%val2314 = fdiv float %val2312, %val2313
; set pointer
%val2315 = getelementptr float, float* %val2308, i64 %val2307
store float %val2314, float* %val2315
%loop_cnt2304 = load i64, i64* %iPtr
%next2304 = add i64 %loop_cnt2304, 1
store i64 %next2304, i64* %iPtr
%cmp2304 = icmp ult i64 %next2304, %num2317
br i1 %cmp2304, label %loop2304, label %after2304

after2304:
ret void
}
@gsxtmmath116 = hidden constant [106 x i8] c"vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** @vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2340 = load i8*, i8** %_impzPtr
%zone2341 = bitcast i8* %tzone2340 to %mzone*

; let assign value to symbol vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd
%dat_vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd = call i8* @llvm_zone_malloc(%mzone* %zone2341, i64 8)
%vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpdPtr = bitcast i8* %dat_vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd to { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}***
%tzone2321 = load i8*, i8** %_impzPtr
%zone2322 = bitcast i8* %tzone2321 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2322)
; malloc closure structure
%clsptr2323 = call i8* @llvm_zone_malloc(%mzone* %zone2322, i64 24)
%closure2324 = bitcast i8* %clsptr2323 to { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}*

; malloc environment structure
%envptr2325 = call i8* @llvm_zone_malloc(%mzone* %zone2322, i64 8)
%environment2326 = bitcast i8* %envptr2325 to {{i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}***}*

; malloc closure address table
%addytable2327 = call %clsvar* @new_address_table()
%var2328 = bitcast [53 x i8]* @gsxtmmath115 to i8*
%var2329 = bitcast [59 x i8]* @gsxtmmath110 to i8*
%addytable2330 = call %clsvar* @add_address_table(%mzone* %zone2322, i8* %var2328, i32 0, i8* %var2329, i32 3, %clsvar* %addytable2327)
%address-table2331 = bitcast %clsvar* %addytable2330 to i8*

; insert table, function and environment into closure struct
%closure.table2334 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure2324, i32 0, i32 0
store i8* %address-table2331, i8** %closure.table2334
%closure.env2335 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure2324, i32 0, i32 1
store i8* %envptr2325, i8** %closure.env2335
%closure.func2336 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure2324, i32 0, i32 2
store void (i8*, i8*, float*, float, i64, float*)* @vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd__2300, void (i8*, i8*, float*, float, i64, float*)** %closure.func2336
%closure_size2337 = call i64 @llvm_zone_mark_size(%mzone* %zone2322)
call void @llvm_zone_ptr_set_size(i8* %clsptr2323, i64 %closure_size2337)
%wrapper_ptr2338 = call i8* @llvm_zone_malloc(%mzone* %zone2322, i64 8)
%closure_wrapper2339 = bitcast i8* %wrapper_ptr2338 to { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure2324, { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** %closure_wrapper2339

; let value assignment
%vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** %closure_wrapper2339, { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** %closure_wrapper2339
store { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** %vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd, { i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}*** %vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpdPtr

; add data to environment
; don't need to alloc for env var vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd
%tmp_envptr2333 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}***}* %environment2326, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}*** %vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpdPtr, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}**** %tmp_envptr2333


%val2342 = load {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}*** %vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpdPtr
ret {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** %val2342
}


@vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** @vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd(float* %arg_0,float %arg_1,i64 %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, i64, float*)*,  void (i8*, i8*, float*, float, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, i64 %arg_2, float* %arg_3)
ret void
}


define dllexport ccc void @vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_native(float* %arg_0,float %arg_1,i64 %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, i64, float*)*,  void (i8*, i8*, float*, float, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, i64 %arg_2, float* %arg_3)
ret void
}


define dllexport ccc i8*  @vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2343 = bitcast [106 x i8]* @gsxtmmath116 to i8*
call i32 (i8*, ...) @printf(i8* %var2343)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2344 = bitcast [106 x i8]* @gsxtmmath116 to i8*
call i32 (i8*, ...) @printf(i8* %var2344)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2345 = bitcast [106 x i8]* @gsxtmmath116 to i8*
call i32 (i8*, ...) @printf(i8* %var2345)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2346 = bitcast [106 x i8]* @gsxtmmath116 to i8*
call i32 (i8*, ...) @printf(i8* %var2346)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, i64, float*)*,  void (i8*, i8*, float*, float, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, i64 %arg_2, float* %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float, i64, float*}*
%arg_p_0 = getelementptr {float*, float, i64, float*}, {float*, float, i64, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float, i64, float*}, {float*, float, i64, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float*, float, i64, float*}, {float*, float, i64, float*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {float*, float, i64, float*}, {float*, float, i64, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, i64, float*)*,  void (i8*, i8*, float*, float, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, i64 %arg_2, float* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath117 = hidden constant [57 x i8] c"vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd\00"
define dllexport fastcc void @vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd__2347(i8* %_impz,i8* %_impenv, double* %v1, double %s, i64 %len, double* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2348 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}***}*
%vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}***}* %impenv, i32 0, i32 0
%vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpdPtr = load {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}***, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}**** %vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpdPtr_

; setup arguments
%v1Ptr = alloca double*
store double* %v1, double** %v1Ptr
%sPtr = alloca double
store double %s, double* %sPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%resultPtr = alloca double*
store double* %result, double** %resultPtr


%tzone2349 = load i8*, i8** %_impzPtr
%zone2350 = bitcast i8* %tzone2349 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val2353 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val2363 = load i64, i64* %iPtr
%num2364 = add i64 %val2353, %val2363
%comp2365 = icmp ult i64 %val2353, 1
br i1 %comp2365, label %after2351, label %loop2351

loop2351:
%val2354 = load i64, i64* %iPtr
%val2355 = load double*, double** %resultPtr
%val2356 = load i64, i64* %iPtr
%val2357 = load double*, double** %v1Ptr
; pointer ref
%val2358 = getelementptr double, double* %val2357, i64 %val2356
%val2359 = load double, double* %val2358
%val2360 = load double, double* %sPtr
%val2361 = fdiv double %val2359, %val2360
; set pointer
%val2362 = getelementptr double, double* %val2355, i64 %val2354
store double %val2361, double* %val2362
%loop_cnt2351 = load i64, i64* %iPtr
%next2351 = add i64 %loop_cnt2351, 1
store i64 %next2351, i64* %iPtr
%cmp2351 = icmp ult i64 %next2351, %num2364
br i1 %cmp2351, label %loop2351, label %after2351

after2351:
ret void
}
@gsxtmmath118 = hidden constant [110 x i8] c"vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** @vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2387 = load i8*, i8** %_impzPtr
%zone2388 = bitcast i8* %tzone2387 to %mzone*

; let assign value to symbol vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd
%dat_vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd = call i8* @llvm_zone_malloc(%mzone* %zone2388, i64 8)
%vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpdPtr = bitcast i8* %dat_vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd to { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}***
%tzone2368 = load i8*, i8** %_impzPtr
%zone2369 = bitcast i8* %tzone2368 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2369)
; malloc closure structure
%clsptr2370 = call i8* @llvm_zone_malloc(%mzone* %zone2369, i64 24)
%closure2371 = bitcast i8* %clsptr2370 to { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}*

; malloc environment structure
%envptr2372 = call i8* @llvm_zone_malloc(%mzone* %zone2369, i64 8)
%environment2373 = bitcast i8* %envptr2372 to {{i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}***}*

; malloc closure address table
%addytable2374 = call %clsvar* @new_address_table()
%var2375 = bitcast [57 x i8]* @gsxtmmath117 to i8*
%var2376 = bitcast [62 x i8]* @gsxtmmath113 to i8*
%addytable2377 = call %clsvar* @add_address_table(%mzone* %zone2369, i8* %var2375, i32 0, i8* %var2376, i32 3, %clsvar* %addytable2374)
%address-table2378 = bitcast %clsvar* %addytable2377 to i8*

; insert table, function and environment into closure struct
%closure.table2381 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure2371, i32 0, i32 0
store i8* %address-table2378, i8** %closure.table2381
%closure.env2382 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure2371, i32 0, i32 1
store i8* %envptr2372, i8** %closure.env2382
%closure.func2383 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure2371, i32 0, i32 2
store void (i8*, i8*, double*, double, i64, double*)* @vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd__2347, void (i8*, i8*, double*, double, i64, double*)** %closure.func2383
%closure_size2384 = call i64 @llvm_zone_mark_size(%mzone* %zone2369)
call void @llvm_zone_ptr_set_size(i8* %clsptr2370, i64 %closure_size2384)
%wrapper_ptr2385 = call i8* @llvm_zone_malloc(%mzone* %zone2369, i64 8)
%closure_wrapper2386 = bitcast i8* %wrapper_ptr2385 to { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}**
store { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure2371, { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** %closure_wrapper2386

; let value assignment
%vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd = select i1 true, { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** %closure_wrapper2386, { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** %closure_wrapper2386
store { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** %vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd, { i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}*** %vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpdPtr

; add data to environment
; don't need to alloc for env var vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd
%tmp_envptr2380 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}***}* %environment2373, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}*** %vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpdPtr, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}**** %tmp_envptr2380


%val2389 = load {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}**, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}*** %vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpdPtr
ret {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** %val2389
}


@vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** @vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd(double* %arg_0,double %arg_1,i64 %arg_2,double* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double, i64, double*)*,  void (i8*, i8*, double*, double, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double %arg_1, i64 %arg_2, double* %arg_3)
ret void
}


define dllexport ccc void @vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_native(double* %arg_0,double %arg_1,i64 %arg_2,double* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double, i64, double*)*,  void (i8*, i8*, double*, double, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double %arg_1, i64 %arg_2, double* %arg_3)
ret void
}


define dllexport ccc i8*  @vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2390 = bitcast [110 x i8]* @gsxtmmath118 to i8*
call i32 (i8*, ...) @printf(i8* %var2390)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2391 = bitcast [110 x i8]* @gsxtmmath118 to i8*
call i32 (i8*, ...) @printf(i8* %var2391)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2392 = bitcast [110 x i8]* @gsxtmmath118 to i8*
call i32 (i8*, ...) @printf(i8* %var2392)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2393 = bitcast [110 x i8]* @gsxtmmath118 to i8*
call i32 (i8*, ...) @printf(i8* %var2393)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to double*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double, i64, double*)*,  void (i8*, i8*, double*, double, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double %arg_1, i64 %arg_2, double* %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, double, i64, double*}*
%arg_p_0 = getelementptr {double*, double, i64, double*}, {double*, double, i64, double*}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, double, i64, double*}, {double*, double, i64, double*}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
%arg_p_2 = getelementptr {double*, double, i64, double*}, {double*, double, i64, double*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {double*, double, i64, double*}, {double*, double, i64, double*}* %fstruct, i32 0, i32 3
%arg_3 = load double*, double** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsdiv_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsaTY0LGRvdWJsZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double, i64, double*)*,  void (i8*, i8*, double*, double, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double %arg_1, i64 %arg_2, double* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath119 = hidden constant [55 x i8] c"vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ\00"
@gsxtmmath120 = hidden constant [60 x i8] c"{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**\00"
@gsxtmmath121 = hidden constant [15 x i8] c"_anon_lambda_5\00"
define dllexport fastcc void @vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ__2394(i8* %_impz,i8* %_impenv, float* %v1, float* %v2, i64 %len, float* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2397 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}*
%vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}* %impenv, i32 0, i32 0
%vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQPtr = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**** %vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQPtr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}* %impenv, i32 0, i32 1
%iPtr = load i64*, i64** %iPtr_
%_anon_lambda_5Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_5Ptr = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**** %_anon_lambda_5Ptr_

; setup arguments
%v1Ptr = alloca float*
store float* %v1, float** %v1Ptr
%v2Ptr = alloca float*
store float* %v2, float** %v2Ptr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%resultPtr = alloca float*
store float* %result, float** %resultPtr


; setup loop
%val2400 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val2413 = load i64, i64* %iPtr
%num2414 = add i64 %val2400, %val2413
%comp2415 = icmp ult i64 %val2400, 1
br i1 %comp2415, label %after2398, label %loop2398

loop2398:
%val2401 = load i64, i64* %iPtr
%val2402 = load float*, float** %resultPtr
%val2403 = load i64, i64* %iPtr
%val2404 = load float*, float** %v1Ptr
; pointer ref
%val2405 = getelementptr float, float* %val2404, i64 %val2403
%val2406 = load float, float* %val2405
%val2407 = load i64, i64* %iPtr
%val2408 = load float*, float** %v2Ptr
; pointer ref
%val2409 = getelementptr float, float* %val2408, i64 %val2407
%val2410 = load float, float* %val2409
%val2411 = fadd float %val2406, %val2410
; set pointer
%val2412 = getelementptr float, float* %val2402, i64 %val2401
store float %val2411, float* %val2412
%loop_cnt2398 = load i64, i64* %iPtr
%next2398 = add i64 %loop_cnt2398, 1
store i64 %next2398, i64* %iPtr
%cmp2398 = icmp ult i64 %next2398, %num2414
br i1 %cmp2398, label %loop2398, label %after2398

after2398:
ret void
}
@gsxtmmath122 = hidden constant [108 x i8] c"vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** @vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2450 = load i8*, i8** %_impzPtr
%zone2451 = bitcast i8* %tzone2450 to %mzone*

; let assign value to symbol vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ
%dat_vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2451, i64 8)
%vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQPtr = bitcast i8* %dat_vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ to {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***
%tzone2395 = load i8*, i8** %_impzPtr
%zone2396 = bitcast i8* %tzone2395 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone2396, i64 8)
%iPtr = bitcast i8* %dat_i to i64*

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

%tzone2447 = load i8*, i8** %_impzPtr
%zone2448 = bitcast i8* %tzone2447 to %mzone*

; let assign value to symbol _anon_lambda_5
%dat__anon_lambda_5 = call i8* @llvm_zone_malloc(%mzone* %zone2448, i64 8)
%_anon_lambda_5Ptr = bitcast i8* %dat__anon_lambda_5 to { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***
%tzone2418 = load i8*, i8** %_impzPtr
%zone2419 = bitcast i8* %tzone2418 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2419)
; malloc closure structure
%clsptr2420 = call i8* @llvm_zone_malloc(%mzone* %zone2419, i64 24)
%closure2421 = bitcast i8* %clsptr2420 to { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*

; malloc environment structure
%envptr2422 = call i8* @llvm_zone_malloc(%mzone* %zone2419, i64 24)
%environment2423 = bitcast i8* %envptr2422 to {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}*

; malloc closure address table
%addytable2424 = call %clsvar* @new_address_table()
%var2425 = bitcast [55 x i8]* @gsxtmmath119 to i8*
%var2426 = bitcast [60 x i8]* @gsxtmmath120 to i8*
%addytable2427 = call %clsvar* @add_address_table(%mzone* %zone2419, i8* %var2425, i32 0, i8* %var2426, i32 3, %clsvar* %addytable2424)
%var2428 = bitcast [2 x i8]* @gsxtmmath93 to i8*
%var2429 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable2430 = call %clsvar* @add_address_table(%mzone* %zone2419, i8* %var2428, i32 8, i8* %var2429, i32 3, %clsvar* %addytable2427)
%var2431 = bitcast [15 x i8]* @gsxtmmath121 to i8*
%var2432 = bitcast [60 x i8]* @gsxtmmath120 to i8*
%addytable2433 = call %clsvar* @add_address_table(%mzone* %zone2419, i8* %var2431, i32 16, i8* %var2432, i32 3, %clsvar* %addytable2430)
%address-table2434 = bitcast %clsvar* %addytable2433 to i8*

; insert table, function and environment into closure struct
%closure.table2441 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure2421, i32 0, i32 0
store i8* %address-table2434, i8** %closure.table2441
%closure.env2442 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure2421, i32 0, i32 1
store i8* %envptr2422, i8** %closure.env2442
%closure.func2443 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure2421, i32 0, i32 2
store void (i8*, i8*, float*, float*, i64, float*)* @vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ__2394, void (i8*, i8*, float*, float*, i64, float*)** %closure.func2443
%closure_size2444 = call i64 @llvm_zone_mark_size(%mzone* %zone2419)
call void @llvm_zone_ptr_set_size(i8* %clsptr2420, i64 %closure_size2444)
%wrapper_ptr2445 = call i8* @llvm_zone_malloc(%mzone* %zone2419, i64 8)
%closure_wrapper2446 = bitcast i8* %wrapper_ptr2445 to { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure2421, { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure_wrapper2446

; let value assignment
%_anon_lambda_5 = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure_wrapper2446, { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure_wrapper2446
store { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %_anon_lambda_5, { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*** %_anon_lambda_5Ptr

; add data to environment
; don't need to alloc for env var vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ
%tmp_envptr2436 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}* %environment2423, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*** %vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQPtr, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**** %tmp_envptr2436

; don't need to alloc for env var i
%tmp_envptr2438 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}* %environment2423, i32 0, i32 1
store i64* %iPtr, i64** %tmp_envptr2438

; don't need to alloc for env var _anon_lambda_5
%tmp_envptr2440 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}* %environment2423, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*** %_anon_lambda_5Ptr, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**** %tmp_envptr2440


%val2449 = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*** %_anon_lambda_5Ptr

; let value assignment
%vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ = select i1 true, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %val2449, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %val2449
store {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*** %vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQPtr

%val2452 = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*** %vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQPtr
ret {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %val2452
}


@vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** @vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ(float* %arg_0,float* %arg_1,i64 %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, i64, float*)*,  void (i8*, i8*, float*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2, float* %arg_3)
ret void
}


define dllexport ccc void @vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_native(float* %arg_0,float* %arg_1,i64 %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, i64, float*)*,  void (i8*, i8*, float*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2, float* %arg_3)
ret void
}


define dllexport ccc i8*  @vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2453 = bitcast [108 x i8]* @gsxtmmath122 to i8*
call i32 (i8*, ...) @printf(i8* %var2453)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2454 = bitcast [108 x i8]* @gsxtmmath122 to i8*
call i32 (i8*, ...) @printf(i8* %var2454)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2455 = bitcast [108 x i8]* @gsxtmmath122 to i8*
call i32 (i8*, ...) @printf(i8* %var2455)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2456 = bitcast [108 x i8]* @gsxtmmath122 to i8*
call i32 (i8*, ...) @printf(i8* %var2456)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, i64, float*)*,  void (i8*, i8*, float*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2, float* %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, i64, float*}*
%arg_p_0 = getelementptr {float*, float*, i64, float*}, {float*, float*, i64, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, i64, float*}, {float*, float*, i64, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, i64, float*}, {float*, float*, i64, float*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {float*, float*, i64, float*}, {float*, float*, i64, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, i64, float*)*,  void (i8*, i8*, float*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2, float* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath123 = hidden constant [59 x i8] c"vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ\00"
@gsxtmmath124 = hidden constant [63 x i8] c"{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**\00"
@gsxtmmath125 = hidden constant [15 x i8] c"_anon_lambda_6\00"
define dllexport fastcc void @vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ__2457(i8* %_impz,i8* %_impenv, double* %v1, double* %v2, i64 %len, double* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2460 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}*
%vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}* %impenv, i32 0, i32 0
%vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQPtr = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**** %vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQPtr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}* %impenv, i32 0, i32 1
%iPtr = load i64*, i64** %iPtr_
%_anon_lambda_6Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_6Ptr = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**** %_anon_lambda_6Ptr_

; setup arguments
%v1Ptr = alloca double*
store double* %v1, double** %v1Ptr
%v2Ptr = alloca double*
store double* %v2, double** %v2Ptr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%resultPtr = alloca double*
store double* %result, double** %resultPtr


; setup loop
%val2463 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val2476 = load i64, i64* %iPtr
%num2477 = add i64 %val2463, %val2476
%comp2478 = icmp ult i64 %val2463, 1
br i1 %comp2478, label %after2461, label %loop2461

loop2461:
%val2464 = load i64, i64* %iPtr
%val2465 = load double*, double** %resultPtr
%val2466 = load i64, i64* %iPtr
%val2467 = load double*, double** %v1Ptr
; pointer ref
%val2468 = getelementptr double, double* %val2467, i64 %val2466
%val2469 = load double, double* %val2468
%val2470 = load i64, i64* %iPtr
%val2471 = load double*, double** %v2Ptr
; pointer ref
%val2472 = getelementptr double, double* %val2471, i64 %val2470
%val2473 = load double, double* %val2472
%val2474 = fadd double %val2469, %val2473
; set pointer
%val2475 = getelementptr double, double* %val2465, i64 %val2464
store double %val2474, double* %val2475
%loop_cnt2461 = load i64, i64* %iPtr
%next2461 = add i64 %loop_cnt2461, 1
store i64 %next2461, i64* %iPtr
%cmp2461 = icmp ult i64 %next2461, %num2477
br i1 %cmp2461, label %loop2461, label %after2461

after2461:
ret void
}
@gsxtmmath126 = hidden constant [112 x i8] c"vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** @vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2513 = load i8*, i8** %_impzPtr
%zone2514 = bitcast i8* %tzone2513 to %mzone*

; let assign value to symbol vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ
%dat_vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2514, i64 8)
%vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQPtr = bitcast i8* %dat_vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ to {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***
%tzone2458 = load i8*, i8** %_impzPtr
%zone2459 = bitcast i8* %tzone2458 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone2459, i64 8)
%iPtr = bitcast i8* %dat_i to i64*

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

%tzone2510 = load i8*, i8** %_impzPtr
%zone2511 = bitcast i8* %tzone2510 to %mzone*

; let assign value to symbol _anon_lambda_6
%dat__anon_lambda_6 = call i8* @llvm_zone_malloc(%mzone* %zone2511, i64 8)
%_anon_lambda_6Ptr = bitcast i8* %dat__anon_lambda_6 to { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***
%tzone2481 = load i8*, i8** %_impzPtr
%zone2482 = bitcast i8* %tzone2481 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2482)
; malloc closure structure
%clsptr2483 = call i8* @llvm_zone_malloc(%mzone* %zone2482, i64 24)
%closure2484 = bitcast i8* %clsptr2483 to { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*

; malloc environment structure
%envptr2485 = call i8* @llvm_zone_malloc(%mzone* %zone2482, i64 24)
%environment2486 = bitcast i8* %envptr2485 to {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}*

; malloc closure address table
%addytable2487 = call %clsvar* @new_address_table()
%var2488 = bitcast [59 x i8]* @gsxtmmath123 to i8*
%var2489 = bitcast [63 x i8]* @gsxtmmath124 to i8*
%addytable2490 = call %clsvar* @add_address_table(%mzone* %zone2482, i8* %var2488, i32 0, i8* %var2489, i32 3, %clsvar* %addytable2487)
%var2491 = bitcast [2 x i8]* @gsxtmmath93 to i8*
%var2492 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable2493 = call %clsvar* @add_address_table(%mzone* %zone2482, i8* %var2491, i32 8, i8* %var2492, i32 3, %clsvar* %addytable2490)
%var2494 = bitcast [15 x i8]* @gsxtmmath125 to i8*
%var2495 = bitcast [63 x i8]* @gsxtmmath124 to i8*
%addytable2496 = call %clsvar* @add_address_table(%mzone* %zone2482, i8* %var2494, i32 16, i8* %var2495, i32 3, %clsvar* %addytable2493)
%address-table2497 = bitcast %clsvar* %addytable2496 to i8*

; insert table, function and environment into closure struct
%closure.table2504 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure2484, i32 0, i32 0
store i8* %address-table2497, i8** %closure.table2504
%closure.env2505 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure2484, i32 0, i32 1
store i8* %envptr2485, i8** %closure.env2505
%closure.func2506 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure2484, i32 0, i32 2
store void (i8*, i8*, double*, double*, i64, double*)* @vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ__2457, void (i8*, i8*, double*, double*, i64, double*)** %closure.func2506
%closure_size2507 = call i64 @llvm_zone_mark_size(%mzone* %zone2482)
call void @llvm_zone_ptr_set_size(i8* %clsptr2483, i64 %closure_size2507)
%wrapper_ptr2508 = call i8* @llvm_zone_malloc(%mzone* %zone2482, i64 8)
%closure_wrapper2509 = bitcast i8* %wrapper_ptr2508 to { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**
store { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure2484, { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure_wrapper2509

; let value assignment
%_anon_lambda_6 = select i1 true, { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure_wrapper2509, { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure_wrapper2509
store { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %_anon_lambda_6, { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*** %_anon_lambda_6Ptr

; add data to environment
; don't need to alloc for env var vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ
%tmp_envptr2499 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}* %environment2486, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*** %vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQPtr, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**** %tmp_envptr2499

; don't need to alloc for env var i
%tmp_envptr2501 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}* %environment2486, i32 0, i32 1
store i64* %iPtr, i64** %tmp_envptr2501

; don't need to alloc for env var _anon_lambda_6
%tmp_envptr2503 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}* %environment2486, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*** %_anon_lambda_6Ptr, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**** %tmp_envptr2503


%val2512 = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*** %_anon_lambda_6Ptr

; let value assignment
%vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ = select i1 true, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %val2512, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %val2512
store {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*** %vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQPtr

%val2515 = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*** %vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQPtr
ret {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %val2515
}


@vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** @vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ(double* %arg_0,double* %arg_1,i64 %arg_2,double* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, i64, double*)*,  void (i8*, i8*, double*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2, double* %arg_3)
ret void
}


define dllexport ccc void @vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_native(double* %arg_0,double* %arg_1,i64 %arg_2,double* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, i64, double*)*,  void (i8*, i8*, double*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2, double* %arg_3)
ret void
}


define dllexport ccc i8*  @vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2516 = bitcast [112 x i8]* @gsxtmmath126 to i8*
call i32 (i8*, ...) @printf(i8* %var2516)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2517 = bitcast [112 x i8]* @gsxtmmath126 to i8*
call i32 (i8*, ...) @printf(i8* %var2517)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to double*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2518 = bitcast [112 x i8]* @gsxtmmath126 to i8*
call i32 (i8*, ...) @printf(i8* %var2518)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2519 = bitcast [112 x i8]* @gsxtmmath126 to i8*
call i32 (i8*, ...) @printf(i8* %var2519)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to double*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, i64, double*)*,  void (i8*, i8*, double*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2, double* %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, double*, i64, double*}*
%arg_p_0 = getelementptr {double*, double*, i64, double*}, {double*, double*, i64, double*}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, double*, i64, double*}, {double*, double*, i64, double*}* %fstruct, i32 0, i32 1
%arg_1 = load double*, double** %arg_p_1
%arg_p_2 = getelementptr {double*, double*, i64, double*}, {double*, double*, i64, double*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {double*, double*, i64, double*}, {double*, double*, i64, double*}* %fstruct, i32 0, i32 3
%arg_3 = load double*, double** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvsum_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, i64, double*)*,  void (i8*, i8*, double*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2, double* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath127 = hidden constant [55 x i8] c"vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ\00"
@gsxtmmath128 = hidden constant [15 x i8] c"_anon_lambda_7\00"
define dllexport fastcc void @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ__2520(i8* %_impz,i8* %_impenv, float* %v1, float* %v2, i64 %len, float* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2523 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}*
%vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}* %impenv, i32 0, i32 0
%vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQPtr = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**** %vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQPtr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}* %impenv, i32 0, i32 1
%iPtr = load i64*, i64** %iPtr_
%_anon_lambda_7Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_7Ptr = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**** %_anon_lambda_7Ptr_

; setup arguments
%v1Ptr = alloca float*
store float* %v1, float** %v1Ptr
%v2Ptr = alloca float*
store float* %v2, float** %v2Ptr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%resultPtr = alloca float*
store float* %result, float** %resultPtr


; setup loop
%val2526 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val2539 = load i64, i64* %iPtr
%num2540 = add i64 %val2526, %val2539
%comp2541 = icmp ult i64 %val2526, 1
br i1 %comp2541, label %after2524, label %loop2524

loop2524:
%val2527 = load i64, i64* %iPtr
%val2528 = load float*, float** %resultPtr
%val2529 = load i64, i64* %iPtr
%val2530 = load float*, float** %v1Ptr
; pointer ref
%val2531 = getelementptr float, float* %val2530, i64 %val2529
%val2532 = load float, float* %val2531
%val2533 = load i64, i64* %iPtr
%val2534 = load float*, float** %v2Ptr
; pointer ref
%val2535 = getelementptr float, float* %val2534, i64 %val2533
%val2536 = load float, float* %val2535
%val2537 = fsub float %val2532, %val2536
; set pointer
%val2538 = getelementptr float, float* %val2528, i64 %val2527
store float %val2537, float* %val2538
%loop_cnt2524 = load i64, i64* %iPtr
%next2524 = add i64 %loop_cnt2524, 1
store i64 %next2524, i64* %iPtr
%cmp2524 = icmp ult i64 %next2524, %num2540
br i1 %cmp2524, label %loop2524, label %after2524

after2524:
ret void
}
@gsxtmmath129 = hidden constant [108 x i8] c"vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2576 = load i8*, i8** %_impzPtr
%zone2577 = bitcast i8* %tzone2576 to %mzone*

; let assign value to symbol vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ
%dat_vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2577, i64 8)
%vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQPtr = bitcast i8* %dat_vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ to {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***
%tzone2521 = load i8*, i8** %_impzPtr
%zone2522 = bitcast i8* %tzone2521 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone2522, i64 8)
%iPtr = bitcast i8* %dat_i to i64*

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

%tzone2573 = load i8*, i8** %_impzPtr
%zone2574 = bitcast i8* %tzone2573 to %mzone*

; let assign value to symbol _anon_lambda_7
%dat__anon_lambda_7 = call i8* @llvm_zone_malloc(%mzone* %zone2574, i64 8)
%_anon_lambda_7Ptr = bitcast i8* %dat__anon_lambda_7 to { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***
%tzone2544 = load i8*, i8** %_impzPtr
%zone2545 = bitcast i8* %tzone2544 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2545)
; malloc closure structure
%clsptr2546 = call i8* @llvm_zone_malloc(%mzone* %zone2545, i64 24)
%closure2547 = bitcast i8* %clsptr2546 to { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*

; malloc environment structure
%envptr2548 = call i8* @llvm_zone_malloc(%mzone* %zone2545, i64 24)
%environment2549 = bitcast i8* %envptr2548 to {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}*

; malloc closure address table
%addytable2550 = call %clsvar* @new_address_table()
%var2551 = bitcast [55 x i8]* @gsxtmmath127 to i8*
%var2552 = bitcast [60 x i8]* @gsxtmmath120 to i8*
%addytable2553 = call %clsvar* @add_address_table(%mzone* %zone2545, i8* %var2551, i32 0, i8* %var2552, i32 3, %clsvar* %addytable2550)
%var2554 = bitcast [2 x i8]* @gsxtmmath93 to i8*
%var2555 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable2556 = call %clsvar* @add_address_table(%mzone* %zone2545, i8* %var2554, i32 8, i8* %var2555, i32 3, %clsvar* %addytable2553)
%var2557 = bitcast [15 x i8]* @gsxtmmath128 to i8*
%var2558 = bitcast [60 x i8]* @gsxtmmath120 to i8*
%addytable2559 = call %clsvar* @add_address_table(%mzone* %zone2545, i8* %var2557, i32 16, i8* %var2558, i32 3, %clsvar* %addytable2556)
%address-table2560 = bitcast %clsvar* %addytable2559 to i8*

; insert table, function and environment into closure struct
%closure.table2567 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure2547, i32 0, i32 0
store i8* %address-table2560, i8** %closure.table2567
%closure.env2568 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure2547, i32 0, i32 1
store i8* %envptr2548, i8** %closure.env2568
%closure.func2569 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure2547, i32 0, i32 2
store void (i8*, i8*, float*, float*, i64, float*)* @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ__2520, void (i8*, i8*, float*, float*, i64, float*)** %closure.func2569
%closure_size2570 = call i64 @llvm_zone_mark_size(%mzone* %zone2545)
call void @llvm_zone_ptr_set_size(i8* %clsptr2546, i64 %closure_size2570)
%wrapper_ptr2571 = call i8* @llvm_zone_malloc(%mzone* %zone2545, i64 8)
%closure_wrapper2572 = bitcast i8* %wrapper_ptr2571 to { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure2547, { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure_wrapper2572

; let value assignment
%_anon_lambda_7 = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure_wrapper2572, { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure_wrapper2572
store { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %_anon_lambda_7, { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*** %_anon_lambda_7Ptr

; add data to environment
; don't need to alloc for env var vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ
%tmp_envptr2562 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}* %environment2549, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*** %vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQPtr, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**** %tmp_envptr2562

; don't need to alloc for env var i
%tmp_envptr2564 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}* %environment2549, i32 0, i32 1
store i64* %iPtr, i64** %tmp_envptr2564

; don't need to alloc for env var _anon_lambda_7
%tmp_envptr2566 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}* %environment2549, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*** %_anon_lambda_7Ptr, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**** %tmp_envptr2566


%val2575 = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*** %_anon_lambda_7Ptr

; let value assignment
%vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ = select i1 true, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %val2575, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %val2575
store {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*** %vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQPtr

%val2578 = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*** %vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQPtr
ret {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %val2578
}


@vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ(float* %arg_0,float* %arg_1,i64 %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, i64, float*)*,  void (i8*, i8*, float*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2, float* %arg_3)
ret void
}


define dllexport ccc void @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_native(float* %arg_0,float* %arg_1,i64 %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, i64, float*)*,  void (i8*, i8*, float*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2, float* %arg_3)
ret void
}


define dllexport ccc i8*  @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2579 = bitcast [108 x i8]* @gsxtmmath129 to i8*
call i32 (i8*, ...) @printf(i8* %var2579)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2580 = bitcast [108 x i8]* @gsxtmmath129 to i8*
call i32 (i8*, ...) @printf(i8* %var2580)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2581 = bitcast [108 x i8]* @gsxtmmath129 to i8*
call i32 (i8*, ...) @printf(i8* %var2581)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2582 = bitcast [108 x i8]* @gsxtmmath129 to i8*
call i32 (i8*, ...) @printf(i8* %var2582)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, i64, float*)*,  void (i8*, i8*, float*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2, float* %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, i64, float*}*
%arg_p_0 = getelementptr {float*, float*, i64, float*}, {float*, float*, i64, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, i64, float*}, {float*, float*, i64, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, i64, float*}, {float*, float*, i64, float*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {float*, float*, i64, float*}, {float*, float*, i64, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, i64, float*)*,  void (i8*, i8*, float*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2, float* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath130 = hidden constant [59 x i8] c"vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ\00"
@gsxtmmath131 = hidden constant [15 x i8] c"_anon_lambda_8\00"
define dllexport fastcc void @vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ__2583(i8* %_impz,i8* %_impenv, double* %v1, double* %v2, i64 %len, double* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2586 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}*
%vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}* %impenv, i32 0, i32 0
%vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQPtr = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**** %vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQPtr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}* %impenv, i32 0, i32 1
%iPtr = load i64*, i64** %iPtr_
%_anon_lambda_8Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_8Ptr = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**** %_anon_lambda_8Ptr_

; setup arguments
%v1Ptr = alloca double*
store double* %v1, double** %v1Ptr
%v2Ptr = alloca double*
store double* %v2, double** %v2Ptr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%resultPtr = alloca double*
store double* %result, double** %resultPtr


; setup loop
%val2589 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val2602 = load i64, i64* %iPtr
%num2603 = add i64 %val2589, %val2602
%comp2604 = icmp ult i64 %val2589, 1
br i1 %comp2604, label %after2587, label %loop2587

loop2587:
%val2590 = load i64, i64* %iPtr
%val2591 = load double*, double** %resultPtr
%val2592 = load i64, i64* %iPtr
%val2593 = load double*, double** %v1Ptr
; pointer ref
%val2594 = getelementptr double, double* %val2593, i64 %val2592
%val2595 = load double, double* %val2594
%val2596 = load i64, i64* %iPtr
%val2597 = load double*, double** %v2Ptr
; pointer ref
%val2598 = getelementptr double, double* %val2597, i64 %val2596
%val2599 = load double, double* %val2598
%val2600 = fsub double %val2595, %val2599
; set pointer
%val2601 = getelementptr double, double* %val2591, i64 %val2590
store double %val2600, double* %val2601
%loop_cnt2587 = load i64, i64* %iPtr
%next2587 = add i64 %loop_cnt2587, 1
store i64 %next2587, i64* %iPtr
%cmp2587 = icmp ult i64 %next2587, %num2603
br i1 %cmp2587, label %loop2587, label %after2587

after2587:
ret void
}
@gsxtmmath132 = hidden constant [112 x i8] c"vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** @vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2639 = load i8*, i8** %_impzPtr
%zone2640 = bitcast i8* %tzone2639 to %mzone*

; let assign value to symbol vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ
%dat_vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2640, i64 8)
%vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQPtr = bitcast i8* %dat_vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ to {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***
%tzone2584 = load i8*, i8** %_impzPtr
%zone2585 = bitcast i8* %tzone2584 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone2585, i64 8)
%iPtr = bitcast i8* %dat_i to i64*

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

%tzone2636 = load i8*, i8** %_impzPtr
%zone2637 = bitcast i8* %tzone2636 to %mzone*

; let assign value to symbol _anon_lambda_8
%dat__anon_lambda_8 = call i8* @llvm_zone_malloc(%mzone* %zone2637, i64 8)
%_anon_lambda_8Ptr = bitcast i8* %dat__anon_lambda_8 to { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***
%tzone2607 = load i8*, i8** %_impzPtr
%zone2608 = bitcast i8* %tzone2607 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2608)
; malloc closure structure
%clsptr2609 = call i8* @llvm_zone_malloc(%mzone* %zone2608, i64 24)
%closure2610 = bitcast i8* %clsptr2609 to { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*

; malloc environment structure
%envptr2611 = call i8* @llvm_zone_malloc(%mzone* %zone2608, i64 24)
%environment2612 = bitcast i8* %envptr2611 to {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}*

; malloc closure address table
%addytable2613 = call %clsvar* @new_address_table()
%var2614 = bitcast [59 x i8]* @gsxtmmath130 to i8*
%var2615 = bitcast [63 x i8]* @gsxtmmath124 to i8*
%addytable2616 = call %clsvar* @add_address_table(%mzone* %zone2608, i8* %var2614, i32 0, i8* %var2615, i32 3, %clsvar* %addytable2613)
%var2617 = bitcast [2 x i8]* @gsxtmmath93 to i8*
%var2618 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable2619 = call %clsvar* @add_address_table(%mzone* %zone2608, i8* %var2617, i32 8, i8* %var2618, i32 3, %clsvar* %addytable2616)
%var2620 = bitcast [15 x i8]* @gsxtmmath131 to i8*
%var2621 = bitcast [63 x i8]* @gsxtmmath124 to i8*
%addytable2622 = call %clsvar* @add_address_table(%mzone* %zone2608, i8* %var2620, i32 16, i8* %var2621, i32 3, %clsvar* %addytable2619)
%address-table2623 = bitcast %clsvar* %addytable2622 to i8*

; insert table, function and environment into closure struct
%closure.table2630 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure2610, i32 0, i32 0
store i8* %address-table2623, i8** %closure.table2630
%closure.env2631 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure2610, i32 0, i32 1
store i8* %envptr2611, i8** %closure.env2631
%closure.func2632 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure2610, i32 0, i32 2
store void (i8*, i8*, double*, double*, i64, double*)* @vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ__2583, void (i8*, i8*, double*, double*, i64, double*)** %closure.func2632
%closure_size2633 = call i64 @llvm_zone_mark_size(%mzone* %zone2608)
call void @llvm_zone_ptr_set_size(i8* %clsptr2609, i64 %closure_size2633)
%wrapper_ptr2634 = call i8* @llvm_zone_malloc(%mzone* %zone2608, i64 8)
%closure_wrapper2635 = bitcast i8* %wrapper_ptr2634 to { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**
store { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure2610, { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure_wrapper2635

; let value assignment
%_anon_lambda_8 = select i1 true, { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure_wrapper2635, { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure_wrapper2635
store { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %_anon_lambda_8, { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*** %_anon_lambda_8Ptr

; add data to environment
; don't need to alloc for env var vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ
%tmp_envptr2625 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}* %environment2612, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*** %vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQPtr, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**** %tmp_envptr2625

; don't need to alloc for env var i
%tmp_envptr2627 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}* %environment2612, i32 0, i32 1
store i64* %iPtr, i64** %tmp_envptr2627

; don't need to alloc for env var _anon_lambda_8
%tmp_envptr2629 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}* %environment2612, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*** %_anon_lambda_8Ptr, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**** %tmp_envptr2629


%val2638 = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*** %_anon_lambda_8Ptr

; let value assignment
%vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ = select i1 true, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %val2638, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %val2638
store {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*** %vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQPtr

%val2641 = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*** %vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQPtr
ret {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %val2641
}


@vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** @vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ(double* %arg_0,double* %arg_1,i64 %arg_2,double* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, i64, double*)*,  void (i8*, i8*, double*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2, double* %arg_3)
ret void
}


define dllexport ccc void @vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_native(double* %arg_0,double* %arg_1,i64 %arg_2,double* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, i64, double*)*,  void (i8*, i8*, double*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2, double* %arg_3)
ret void
}


define dllexport ccc i8*  @vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2642 = bitcast [112 x i8]* @gsxtmmath132 to i8*
call i32 (i8*, ...) @printf(i8* %var2642)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2643 = bitcast [112 x i8]* @gsxtmmath132 to i8*
call i32 (i8*, ...) @printf(i8* %var2643)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to double*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2644 = bitcast [112 x i8]* @gsxtmmath132 to i8*
call i32 (i8*, ...) @printf(i8* %var2644)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2645 = bitcast [112 x i8]* @gsxtmmath132 to i8*
call i32 (i8*, ...) @printf(i8* %var2645)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to double*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, i64, double*)*,  void (i8*, i8*, double*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2, double* %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, double*, i64, double*}*
%arg_p_0 = getelementptr {double*, double*, i64, double*}, {double*, double*, i64, double*}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, double*, i64, double*}, {double*, double*, i64, double*}* %fstruct, i32 0, i32 1
%arg_1 = load double*, double** %arg_p_1
%arg_p_2 = getelementptr {double*, double*, i64, double*}, {double*, double*, i64, double*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {double*, double*, i64, double*}, {double*, double*, i64, double*}* %fstruct, i32 0, i32 3
%arg_3 = load double*, double** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvsub_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, i64, double*)*,  void (i8*, i8*, double*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2, double* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath133 = hidden constant [55 x i8] c"vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ\00"
@gsxtmmath134 = hidden constant [15 x i8] c"_anon_lambda_9\00"
define dllexport fastcc void @vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ__2646(i8* %_impz,i8* %_impenv, float* %v1, float* %v2, i64 %len, float* %v3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2649 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}*
%vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}* %impenv, i32 0, i32 0
%vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQPtr = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**** %vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQPtr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}* %impenv, i32 0, i32 1
%iPtr = load i64*, i64** %iPtr_
%_anon_lambda_9Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_9Ptr = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**** %_anon_lambda_9Ptr_

; setup arguments
%v1Ptr = alloca float*
store float* %v1, float** %v1Ptr
%v2Ptr = alloca float*
store float* %v2, float** %v2Ptr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%v3Ptr = alloca float*
store float* %v3, float** %v3Ptr


; setup loop
%val2652 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val2665 = load i64, i64* %iPtr
%num2666 = add i64 %val2652, %val2665
%comp2667 = icmp ult i64 %val2652, 1
br i1 %comp2667, label %after2650, label %loop2650

loop2650:
%val2653 = load i64, i64* %iPtr
%val2654 = load float*, float** %v3Ptr
%val2655 = load i64, i64* %iPtr
%val2656 = load float*, float** %v1Ptr
; pointer ref
%val2657 = getelementptr float, float* %val2656, i64 %val2655
%val2658 = load float, float* %val2657
%val2659 = load i64, i64* %iPtr
%val2660 = load float*, float** %v2Ptr
; pointer ref
%val2661 = getelementptr float, float* %val2660, i64 %val2659
%val2662 = load float, float* %val2661
%val2663 = fmul float %val2658, %val2662
; set pointer
%val2664 = getelementptr float, float* %val2654, i64 %val2653
store float %val2663, float* %val2664
%loop_cnt2650 = load i64, i64* %iPtr
%next2650 = add i64 %loop_cnt2650, 1
store i64 %next2650, i64* %iPtr
%cmp2650 = icmp ult i64 %next2650, %num2666
br i1 %cmp2650, label %loop2650, label %after2650

after2650:
ret void
}
@gsxtmmath135 = hidden constant [108 x i8] c"vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** @vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2702 = load i8*, i8** %_impzPtr
%zone2703 = bitcast i8* %tzone2702 to %mzone*

; let assign value to symbol vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ
%dat_vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2703, i64 8)
%vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQPtr = bitcast i8* %dat_vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ to {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***
%tzone2647 = load i8*, i8** %_impzPtr
%zone2648 = bitcast i8* %tzone2647 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone2648, i64 8)
%iPtr = bitcast i8* %dat_i to i64*

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

%tzone2699 = load i8*, i8** %_impzPtr
%zone2700 = bitcast i8* %tzone2699 to %mzone*

; let assign value to symbol _anon_lambda_9
%dat__anon_lambda_9 = call i8* @llvm_zone_malloc(%mzone* %zone2700, i64 8)
%_anon_lambda_9Ptr = bitcast i8* %dat__anon_lambda_9 to { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***
%tzone2670 = load i8*, i8** %_impzPtr
%zone2671 = bitcast i8* %tzone2670 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2671)
; malloc closure structure
%clsptr2672 = call i8* @llvm_zone_malloc(%mzone* %zone2671, i64 24)
%closure2673 = bitcast i8* %clsptr2672 to { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*

; malloc environment structure
%envptr2674 = call i8* @llvm_zone_malloc(%mzone* %zone2671, i64 24)
%environment2675 = bitcast i8* %envptr2674 to {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}*

; malloc closure address table
%addytable2676 = call %clsvar* @new_address_table()
%var2677 = bitcast [55 x i8]* @gsxtmmath133 to i8*
%var2678 = bitcast [60 x i8]* @gsxtmmath120 to i8*
%addytable2679 = call %clsvar* @add_address_table(%mzone* %zone2671, i8* %var2677, i32 0, i8* %var2678, i32 3, %clsvar* %addytable2676)
%var2680 = bitcast [2 x i8]* @gsxtmmath93 to i8*
%var2681 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable2682 = call %clsvar* @add_address_table(%mzone* %zone2671, i8* %var2680, i32 8, i8* %var2681, i32 3, %clsvar* %addytable2679)
%var2683 = bitcast [15 x i8]* @gsxtmmath134 to i8*
%var2684 = bitcast [60 x i8]* @gsxtmmath120 to i8*
%addytable2685 = call %clsvar* @add_address_table(%mzone* %zone2671, i8* %var2683, i32 16, i8* %var2684, i32 3, %clsvar* %addytable2682)
%address-table2686 = bitcast %clsvar* %addytable2685 to i8*

; insert table, function and environment into closure struct
%closure.table2693 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure2673, i32 0, i32 0
store i8* %address-table2686, i8** %closure.table2693
%closure.env2694 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure2673, i32 0, i32 1
store i8* %envptr2674, i8** %closure.env2694
%closure.func2695 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure2673, i32 0, i32 2
store void (i8*, i8*, float*, float*, i64, float*)* @vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ__2646, void (i8*, i8*, float*, float*, i64, float*)** %closure.func2695
%closure_size2696 = call i64 @llvm_zone_mark_size(%mzone* %zone2671)
call void @llvm_zone_ptr_set_size(i8* %clsptr2672, i64 %closure_size2696)
%wrapper_ptr2697 = call i8* @llvm_zone_malloc(%mzone* %zone2671, i64 8)
%closure_wrapper2698 = bitcast i8* %wrapper_ptr2697 to { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure2673, { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure_wrapper2698

; let value assignment
%_anon_lambda_9 = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure_wrapper2698, { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure_wrapper2698
store { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %_anon_lambda_9, { i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*** %_anon_lambda_9Ptr

; add data to environment
; don't need to alloc for env var vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ
%tmp_envptr2688 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}* %environment2675, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*** %vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQPtr, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**** %tmp_envptr2688

; don't need to alloc for env var i
%tmp_envptr2690 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}* %environment2675, i32 0, i32 1
store i64* %iPtr, i64** %tmp_envptr2690

; don't need to alloc for env var _anon_lambda_9
%tmp_envptr2692 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}***}* %environment2675, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*** %_anon_lambda_9Ptr, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**** %tmp_envptr2692


%val2701 = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*** %_anon_lambda_9Ptr

; let value assignment
%vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ = select i1 true, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %val2701, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %val2701
store {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*** %vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQPtr

%val2704 = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*** %vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQPtr
ret {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %val2704
}


@vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** @vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ(float* %arg_0,float* %arg_1,i64 %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, i64, float*)*,  void (i8*, i8*, float*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2, float* %arg_3)
ret void
}


define dllexport ccc void @vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_native(float* %arg_0,float* %arg_1,i64 %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, i64, float*)*,  void (i8*, i8*, float*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2, float* %arg_3)
ret void
}


define dllexport ccc i8*  @vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2705 = bitcast [108 x i8]* @gsxtmmath135 to i8*
call i32 (i8*, ...) @printf(i8* %var2705)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2706 = bitcast [108 x i8]* @gsxtmmath135 to i8*
call i32 (i8*, ...) @printf(i8* %var2706)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2707 = bitcast [108 x i8]* @gsxtmmath135 to i8*
call i32 (i8*, ...) @printf(i8* %var2707)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2708 = bitcast [108 x i8]* @gsxtmmath135 to i8*
call i32 (i8*, ...) @printf(i8* %var2708)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, i64, float*)*,  void (i8*, i8*, float*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2, float* %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, i64, float*}*
%arg_p_0 = getelementptr {float*, float*, i64, float*}, {float*, float*, i64, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, i64, float*}, {float*, float*, i64, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, i64, float*}, {float*, float*, i64, float*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {float*, float*, i64, float*}, {float*, float*, i64, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, i64, float*)*,  void (i8*, i8*, float*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, i64 %arg_2, float* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath136 = hidden constant [59 x i8] c"vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ\00"
@gsxtmmath137 = hidden constant [16 x i8] c"_anon_lambda_10\00"
define dllexport fastcc void @vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ__2709(i8* %_impz,i8* %_impenv, double* %v1, double* %v2, i64 %len, double* %v3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2712 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}*
%vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}* %impenv, i32 0, i32 0
%vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQPtr = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**** %vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQPtr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}* %impenv, i32 0, i32 1
%iPtr = load i64*, i64** %iPtr_
%_anon_lambda_10Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_10Ptr = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**** %_anon_lambda_10Ptr_

; setup arguments
%v1Ptr = alloca double*
store double* %v1, double** %v1Ptr
%v2Ptr = alloca double*
store double* %v2, double** %v2Ptr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%v3Ptr = alloca double*
store double* %v3, double** %v3Ptr


; setup loop
%val2715 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val2728 = load i64, i64* %iPtr
%num2729 = add i64 %val2715, %val2728
%comp2730 = icmp ult i64 %val2715, 1
br i1 %comp2730, label %after2713, label %loop2713

loop2713:
%val2716 = load i64, i64* %iPtr
%val2717 = load double*, double** %v3Ptr
%val2718 = load i64, i64* %iPtr
%val2719 = load double*, double** %v1Ptr
; pointer ref
%val2720 = getelementptr double, double* %val2719, i64 %val2718
%val2721 = load double, double* %val2720
%val2722 = load i64, i64* %iPtr
%val2723 = load double*, double** %v2Ptr
; pointer ref
%val2724 = getelementptr double, double* %val2723, i64 %val2722
%val2725 = load double, double* %val2724
%val2726 = fmul double %val2721, %val2725
; set pointer
%val2727 = getelementptr double, double* %val2717, i64 %val2716
store double %val2726, double* %val2727
%loop_cnt2713 = load i64, i64* %iPtr
%next2713 = add i64 %loop_cnt2713, 1
store i64 %next2713, i64* %iPtr
%cmp2713 = icmp ult i64 %next2713, %num2729
br i1 %cmp2713, label %loop2713, label %after2713

after2713:
ret void
}
@gsxtmmath138 = hidden constant [112 x i8] c"vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** @vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2765 = load i8*, i8** %_impzPtr
%zone2766 = bitcast i8* %tzone2765 to %mzone*

; let assign value to symbol vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ
%dat_vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2766, i64 8)
%vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQPtr = bitcast i8* %dat_vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ to {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***
%tzone2710 = load i8*, i8** %_impzPtr
%zone2711 = bitcast i8* %tzone2710 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone2711, i64 8)
%iPtr = bitcast i8* %dat_i to i64*

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

%tzone2762 = load i8*, i8** %_impzPtr
%zone2763 = bitcast i8* %tzone2762 to %mzone*

; let assign value to symbol _anon_lambda_10
%dat__anon_lambda_10 = call i8* @llvm_zone_malloc(%mzone* %zone2763, i64 8)
%_anon_lambda_10Ptr = bitcast i8* %dat__anon_lambda_10 to { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***
%tzone2733 = load i8*, i8** %_impzPtr
%zone2734 = bitcast i8* %tzone2733 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2734)
; malloc closure structure
%clsptr2735 = call i8* @llvm_zone_malloc(%mzone* %zone2734, i64 24)
%closure2736 = bitcast i8* %clsptr2735 to { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*

; malloc environment structure
%envptr2737 = call i8* @llvm_zone_malloc(%mzone* %zone2734, i64 24)
%environment2738 = bitcast i8* %envptr2737 to {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}*

; malloc closure address table
%addytable2739 = call %clsvar* @new_address_table()
%var2740 = bitcast [59 x i8]* @gsxtmmath136 to i8*
%var2741 = bitcast [63 x i8]* @gsxtmmath124 to i8*
%addytable2742 = call %clsvar* @add_address_table(%mzone* %zone2734, i8* %var2740, i32 0, i8* %var2741, i32 3, %clsvar* %addytable2739)
%var2743 = bitcast [2 x i8]* @gsxtmmath93 to i8*
%var2744 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable2745 = call %clsvar* @add_address_table(%mzone* %zone2734, i8* %var2743, i32 8, i8* %var2744, i32 3, %clsvar* %addytable2742)
%var2746 = bitcast [16 x i8]* @gsxtmmath137 to i8*
%var2747 = bitcast [63 x i8]* @gsxtmmath124 to i8*
%addytable2748 = call %clsvar* @add_address_table(%mzone* %zone2734, i8* %var2746, i32 16, i8* %var2747, i32 3, %clsvar* %addytable2745)
%address-table2749 = bitcast %clsvar* %addytable2748 to i8*

; insert table, function and environment into closure struct
%closure.table2756 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure2736, i32 0, i32 0
store i8* %address-table2749, i8** %closure.table2756
%closure.env2757 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure2736, i32 0, i32 1
store i8* %envptr2737, i8** %closure.env2757
%closure.func2758 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure2736, i32 0, i32 2
store void (i8*, i8*, double*, double*, i64, double*)* @vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ__2709, void (i8*, i8*, double*, double*, i64, double*)** %closure.func2758
%closure_size2759 = call i64 @llvm_zone_mark_size(%mzone* %zone2734)
call void @llvm_zone_ptr_set_size(i8* %clsptr2735, i64 %closure_size2759)
%wrapper_ptr2760 = call i8* @llvm_zone_malloc(%mzone* %zone2734, i64 8)
%closure_wrapper2761 = bitcast i8* %wrapper_ptr2760 to { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**
store { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure2736, { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure_wrapper2761

; let value assignment
%_anon_lambda_10 = select i1 true, { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure_wrapper2761, { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure_wrapper2761
store { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %_anon_lambda_10, { i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*** %_anon_lambda_10Ptr

; add data to environment
; don't need to alloc for env var vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ
%tmp_envptr2751 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}* %environment2738, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*** %vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQPtr, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**** %tmp_envptr2751

; don't need to alloc for env var i
%tmp_envptr2753 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}* %environment2738, i32 0, i32 1
store i64* %iPtr, i64** %tmp_envptr2753

; don't need to alloc for env var _anon_lambda_10
%tmp_envptr2755 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}***}* %environment2738, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*** %_anon_lambda_10Ptr, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**** %tmp_envptr2755


%val2764 = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*** %_anon_lambda_10Ptr

; let value assignment
%vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ = select i1 true, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %val2764, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %val2764
store {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*** %vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQPtr

%val2767 = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*** %vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQPtr
ret {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %val2767
}


@vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** @vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ(double* %arg_0,double* %arg_1,i64 %arg_2,double* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, i64, double*)*,  void (i8*, i8*, double*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2, double* %arg_3)
ret void
}


define dllexport ccc void @vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_native(double* %arg_0,double* %arg_1,i64 %arg_2,double* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, i64, double*)*,  void (i8*, i8*, double*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2, double* %arg_3)
ret void
}


define dllexport ccc i8*  @vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2768 = bitcast [112 x i8]* @gsxtmmath138 to i8*
call i32 (i8*, ...) @printf(i8* %var2768)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2769 = bitcast [112 x i8]* @gsxtmmath138 to i8*
call i32 (i8*, ...) @printf(i8* %var2769)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to double*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2770 = bitcast [112 x i8]* @gsxtmmath138 to i8*
call i32 (i8*, ...) @printf(i8* %var2770)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2771 = bitcast [112 x i8]* @gsxtmmath138 to i8*
call i32 (i8*, ...) @printf(i8* %var2771)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to double*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, i64, double*)*,  void (i8*, i8*, double*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2, double* %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, double*, i64, double*}*
%arg_p_0 = getelementptr {double*, double*, i64, double*}, {double*, double*, i64, double*}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, double*, i64, double*}, {double*, double*, i64, double*}* %fstruct, i32 0, i32 1
%arg_1 = load double*, double** %arg_p_1
%arg_p_2 = getelementptr {double*, double*, i64, double*}, {double*, double*, i64, double*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {double*, double*, i64, double*}, {double*, double*, i64, double*}* %fstruct, i32 0, i32 3
%arg_3 = load double*, double** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vvmul_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLGk2NCxkb3VibGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, i64, double*)*,  void (i8*, i8*, double*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, i64 %arg_2, double* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath139 = hidden constant [36 x i8] c"vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd\00"
define dllexport fastcc float @vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd__2772(i8* %_impz,i8* %_impenv, float* %v, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2773 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}*
%vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 0
%vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr = load {i8*, i8*, float (i8*, i8*, float*, i64)*}***, {i8*, i8*, float (i8*, i8*, float*, i64)*}**** %vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr_

; setup arguments
%vPtr = alloca float*
store float* %v, float** %vPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone2774 = load i8*, i8** %_impzPtr
%zone2775 = bitcast i8* %tzone2774 to %mzone*

; let assign value to symbol mag
%magPtr = alloca float
%tzone2776 = load i8*, i8** %_impzPtr
%zone2777 = bitcast i8* %tzone2776 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%mag = select i1 true, float 0x0, float 0x0
store float %mag, float* %magPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val2780 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val2792 = load i64, i64* %iPtr
%num2793 = add i64 %val2780, %val2792
%comp2794 = icmp ult i64 %val2780, 1
br i1 %comp2794, label %after2778, label %loop2778

loop2778:
; do set!
%val2781 = load float, float* %magPtr
%val2782 = load i64, i64* %iPtr
%val2783 = load float*, float** %vPtr
; pointer ref
%val2784 = getelementptr float, float* %val2783, i64 %val2782
%val2785 = load float, float* %val2784
%val2786 = load i64, i64* %iPtr
%val2787 = load float*, float** %vPtr
; pointer ref
%val2788 = getelementptr float, float* %val2787, i64 %val2786
%val2789 = load float, float* %val2788
%val2790 = fmul float %val2785, %val2789
%val2791 = fadd float %val2781, %val2790
store float %val2791, float* %magPtr
%loop_cnt2778 = load i64, i64* %iPtr
%next2778 = add i64 %loop_cnt2778, 1
store i64 %next2778, i64* %iPtr
%cmp2778 = icmp ult i64 %next2778, %num2793
br i1 %cmp2778, label %loop2778, label %after2778

after2778:
%val2796 = load float, float* %magPtr
%val2797 = call float @llvm.sqrt.f32(float %val2796)
ret float %val2797
}
@gsxtmmath140 = hidden constant [89 x i8] c"vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, float*, i64)*}** @vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2817 = load i8*, i8** %_impzPtr
%zone2818 = bitcast i8* %tzone2817 to %mzone*

; let assign value to symbol vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd
%dat_vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone2818, i64 8)
%vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr = bitcast i8* %dat_vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd to { i8*, i8*, float (i8*, i8*, float*, i64)*}***
%tzone2798 = load i8*, i8** %_impzPtr
%zone2799 = bitcast i8* %tzone2798 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2799)
; malloc closure structure
%clsptr2800 = call i8* @llvm_zone_malloc(%mzone* %zone2799, i64 24)
%closure2801 = bitcast i8* %clsptr2800 to { i8*, i8*, float (i8*, i8*, float*, i64)*}*

; malloc environment structure
%envptr2802 = call i8* @llvm_zone_malloc(%mzone* %zone2799, i64 8)
%environment2803 = bitcast i8* %envptr2802 to {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}*

; malloc closure address table
%addytable2804 = call %clsvar* @new_address_table()
%var2805 = bitcast [36 x i8]* @gsxtmmath139 to i8*
%var2806 = bitcast [45 x i8]* @gsxtmmath7 to i8*
%addytable2807 = call %clsvar* @add_address_table(%mzone* %zone2799, i8* %var2805, i32 0, i8* %var2806, i32 3, %clsvar* %addytable2804)
%address-table2808 = bitcast %clsvar* %addytable2807 to i8*

; insert table, function and environment into closure struct
%closure.table2811 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure2801, i32 0, i32 0
store i8* %address-table2808, i8** %closure.table2811
%closure.env2812 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure2801, i32 0, i32 1
store i8* %envptr2802, i8** %closure.env2812
%closure.func2813 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure2801, i32 0, i32 2
store float (i8*, i8*, float*, i64)* @vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd__2772, float (i8*, i8*, float*, i64)** %closure.func2813
%closure_size2814 = call i64 @llvm_zone_mark_size(%mzone* %zone2799)
call void @llvm_zone_ptr_set_size(i8* %clsptr2800, i64 %closure_size2814)
%wrapper_ptr2815 = call i8* @llvm_zone_malloc(%mzone* %zone2799, i64 8)
%closure_wrapper2816 = bitcast i8* %wrapper_ptr2815 to { i8*, i8*, float (i8*, i8*, float*, i64)*}**
store { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure2801, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper2816

; let value assignment
%vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd = select i1 true, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper2816, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper2816
store { i8*, i8*, float (i8*, i8*, float*, i64)*}** %vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd, { i8*, i8*, float (i8*, i8*, float*, i64)*}*** %vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr

; add data to environment
; don't need to alloc for env var vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd
%tmp_envptr2810 = getelementptr {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}* %environment2803, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, float*, i64)*}*** %vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr, {i8*, i8*, float (i8*, i8*, float*, i64)*}**** %tmp_envptr2810


%val2819 = load {i8*, i8*, float (i8*, i8*, float*, i64)*}**, {i8*, i8*, float (i8*, i8*, float*, i64)*}*** %vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr
ret {i8*, i8*, float (i8*, i8*, float*, i64)*}** %val2819
}


@vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, float*, i64)*}** @vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret float %result
}


define dllexport ccc float @vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_native(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret float %result
}


define dllexport ccc i8*  @vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2820 = bitcast [89 x i8]* @gsxtmmath140 to i8*
call i32 (i8*, ...) @printf(i8* %var2820)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2821 = bitcast [89 x i8]* @gsxtmmath140 to i8*
call i32 (i8*, ...) @printf(i8* %var2821)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64}*
%arg_p_0 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath141 = hidden constant [39 x i8] c"vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0\00"
define dllexport fastcc double @vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0__2822(i8* %_impz,i8* %_impenv, double* %v, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2823 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}*
%vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}* %impenv, i32 0, i32 0
%vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr = load {i8*, i8*, double (i8*, i8*, double*, i64)*}***, {i8*, i8*, double (i8*, i8*, double*, i64)*}**** %vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr_

; setup arguments
%vPtr = alloca double*
store double* %v, double** %vPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone2824 = load i8*, i8** %_impzPtr
%zone2825 = bitcast i8* %tzone2824 to %mzone*

; let assign value to symbol mag
%magPtr = alloca double
%tzone2826 = load i8*, i8** %_impzPtr
%zone2827 = bitcast i8* %tzone2826 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%mag = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %mag, double* %magPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val2830 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val2842 = load i64, i64* %iPtr
%num2843 = add i64 %val2830, %val2842
%comp2844 = icmp ult i64 %val2830, 1
br i1 %comp2844, label %after2828, label %loop2828

loop2828:
; do set!
%val2831 = load double, double* %magPtr
%val2832 = load i64, i64* %iPtr
%val2833 = load double*, double** %vPtr
; pointer ref
%val2834 = getelementptr double, double* %val2833, i64 %val2832
%val2835 = load double, double* %val2834
%val2836 = load i64, i64* %iPtr
%val2837 = load double*, double** %vPtr
; pointer ref
%val2838 = getelementptr double, double* %val2837, i64 %val2836
%val2839 = load double, double* %val2838
%val2840 = fmul double %val2835, %val2839
%val2841 = fadd double %val2831, %val2840
store double %val2841, double* %magPtr
%loop_cnt2828 = load i64, i64* %iPtr
%next2828 = add i64 %loop_cnt2828, 1
store i64 %next2828, i64* %iPtr
%cmp2828 = icmp ult i64 %next2828, %num2843
br i1 %cmp2828, label %loop2828, label %after2828

after2828:
%val2846 = load double, double* %magPtr
%val2847 = call double @llvm.sqrt.f64(double %val2846)
ret double %val2847
}
@gsxtmmath142 = hidden constant [92 x i8] c"vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, double*, i64)*}** @vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2867 = load i8*, i8** %_impzPtr
%zone2868 = bitcast i8* %tzone2867 to %mzone*

; let assign value to symbol vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0
%dat_vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone2868, i64 8)
%vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr = bitcast i8* %dat_vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 to { i8*, i8*, double (i8*, i8*, double*, i64)*}***
%tzone2848 = load i8*, i8** %_impzPtr
%zone2849 = bitcast i8* %tzone2848 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2849)
; malloc closure structure
%clsptr2850 = call i8* @llvm_zone_malloc(%mzone* %zone2849, i64 24)
%closure2851 = bitcast i8* %clsptr2850 to { i8*, i8*, double (i8*, i8*, double*, i64)*}*

; malloc environment structure
%envptr2852 = call i8* @llvm_zone_malloc(%mzone* %zone2849, i64 8)
%environment2853 = bitcast i8* %envptr2852 to {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}*

; malloc closure address table
%addytable2854 = call %clsvar* @new_address_table()
%var2855 = bitcast [39 x i8]* @gsxtmmath141 to i8*
%var2856 = bitcast [47 x i8]* @gsxtmmath10 to i8*
%addytable2857 = call %clsvar* @add_address_table(%mzone* %zone2849, i8* %var2855, i32 0, i8* %var2856, i32 3, %clsvar* %addytable2854)
%address-table2858 = bitcast %clsvar* %addytable2857 to i8*

; insert table, function and environment into closure struct
%closure.table2861 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure2851, i32 0, i32 0
store i8* %address-table2858, i8** %closure.table2861
%closure.env2862 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure2851, i32 0, i32 1
store i8* %envptr2852, i8** %closure.env2862
%closure.func2863 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure2851, i32 0, i32 2
store double (i8*, i8*, double*, i64)* @vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0__2822, double (i8*, i8*, double*, i64)** %closure.func2863
%closure_size2864 = call i64 @llvm_zone_mark_size(%mzone* %zone2849)
call void @llvm_zone_ptr_set_size(i8* %clsptr2850, i64 %closure_size2864)
%wrapper_ptr2865 = call i8* @llvm_zone_malloc(%mzone* %zone2849, i64 8)
%closure_wrapper2866 = bitcast i8* %wrapper_ptr2865 to { i8*, i8*, double (i8*, i8*, double*, i64)*}**
store { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure2851, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper2866

; let value assignment
%vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 = select i1 true, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper2866, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper2866
store { i8*, i8*, double (i8*, i8*, double*, i64)*}** %vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0, { i8*, i8*, double (i8*, i8*, double*, i64)*}*** %vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0
%tmp_envptr2860 = getelementptr {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}* %environment2853, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, double*, i64)*}*** %vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr, {i8*, i8*, double (i8*, i8*, double*, i64)*}**** %tmp_envptr2860


%val2869 = load {i8*, i8*, double (i8*, i8*, double*, i64)*}**, {i8*, i8*, double (i8*, i8*, double*, i64)*}*** %vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr
ret {i8*, i8*, double (i8*, i8*, double*, i64)*}** %val2869
}


@vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, double*, i64)*}** @vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret double %result
}


define dllexport ccc double @vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_native(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret double %result
}


define dllexport ccc i8*  @vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2870 = bitcast [92 x i8]* @gsxtmmath142 to i8*
call i32 (i8*, ...) @printf(i8* %var2870)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2871 = bitcast [92 x i8]* @gsxtmmath142 to i8*
call i32 (i8*, ...) @printf(i8* %var2871)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, i64}*
%arg_p_0 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath143 = hidden constant [49 x i8] c"vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0\00"
@gsxtmmath144 = hidden constant [54 x i8] c"{i8*, i8*, void (i8*, i8*, float*, float, float*)*}**\00"
define dllexport fastcc void @vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0__2872(i8* %_impz,i8* %_impenv, float* %v, float %angle, float* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2873 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float, float*)*}***}*
%vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, float*)*}***}* %impenv, i32 0, i32 0
%vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0Ptr = load {i8*, i8*, void (i8*, i8*, float*, float, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, float, float*)*}**** %vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0Ptr_

; setup arguments
%vPtr = alloca float*
store float* %v, float** %vPtr
%anglePtr = alloca float
store float %angle, float* %anglePtr
%resultPtr = alloca float*
store float* %result, float** %resultPtr


%tzone2876 = load i8*, i8** %_impzPtr
%zone2877 = bitcast i8* %tzone2876 to %mzone*

; let assign value to symbol m
%mPtr = alloca float
%tzone2883 = load i8*, i8** %_impzPtr
%zone2884 = bitcast i8* %tzone2883 to %mzone*

; let assign value to symbol s
%sPtr = alloca float
%val2874 = load float*, float** %vPtr
%res2875 = call fastcc float @vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd(float* %val2874, i64 3)

; let value assignment
%m = select i1 true, float %res2875, float %res2875
store float %m, float* %mPtr

%val2878 = load float, float* %anglePtr
%val2879 = fmul float 0x3fe0000000000000, %val2878
%val2880 = call float @llvm.sin.f32(float %val2879)
%val2881 = load float, float* %mPtr
%val2882 = fdiv float %val2880, %val2881

; let value assignment
%s = select i1 true, float %val2882, float %val2882
store float %s, float* %sPtr

%val2885 = load float*, float** %resultPtr
%val2886 = load float*, float** %vPtr
; pointer ref
%val2887 = getelementptr float, float* %val2886, i64 0
%val2888 = load float, float* %val2887
%val2889 = load float, float* %sPtr
%val2890 = fmul float %val2888, %val2889
; set pointer
%val2891 = getelementptr float, float* %val2885, i64 0
store float %val2890, float* %val2891
%val2892 = load float*, float** %resultPtr
%val2893 = load float*, float** %vPtr
; pointer ref
%val2894 = getelementptr float, float* %val2893, i64 1
%val2895 = load float, float* %val2894
%val2896 = load float, float* %sPtr
%val2897 = fmul float %val2895, %val2896
; set pointer
%val2898 = getelementptr float, float* %val2892, i64 1
store float %val2897, float* %val2898
%val2899 = load float*, float** %resultPtr
%val2900 = load float*, float** %vPtr
; pointer ref
%val2901 = getelementptr float, float* %val2900, i64 2
%val2902 = load float, float* %val2901
%val2903 = load float, float* %sPtr
%val2904 = fmul float %val2902, %val2903
; set pointer
%val2905 = getelementptr float, float* %val2899, i64 2
store float %val2904, float* %val2905
%val2906 = load float*, float** %resultPtr
%val2907 = load float, float* %anglePtr
%val2908 = fmul float 0x3fe0000000000000, %val2907
%val2909 = call float @llvm.cos.f32(float %val2908)
; set pointer
%val2910 = getelementptr float, float* %val2906, i64 3
store float %val2909, float* %val2910
ret void
}
@gsxtmmath145 = hidden constant [102 x i8] c"vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float, float*)*}** @vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2931 = load i8*, i8** %_impzPtr
%zone2932 = bitcast i8* %tzone2931 to %mzone*

; let assign value to symbol vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0
%dat_vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone2932, i64 8)
%vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0Ptr = bitcast i8* %dat_vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0 to { i8*, i8*, void (i8*, i8*, float*, float, float*)*}***
%tzone2912 = load i8*, i8** %_impzPtr
%zone2913 = bitcast i8* %tzone2912 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2913)
; malloc closure structure
%clsptr2914 = call i8* @llvm_zone_malloc(%mzone* %zone2913, i64 24)
%closure2915 = bitcast i8* %clsptr2914 to { i8*, i8*, void (i8*, i8*, float*, float, float*)*}*

; malloc environment structure
%envptr2916 = call i8* @llvm_zone_malloc(%mzone* %zone2913, i64 8)
%environment2917 = bitcast i8* %envptr2916 to {{i8*, i8*, void (i8*, i8*, float*, float, float*)*}***}*

; malloc closure address table
%addytable2918 = call %clsvar* @new_address_table()
%var2919 = bitcast [49 x i8]* @gsxtmmath143 to i8*
%var2920 = bitcast [54 x i8]* @gsxtmmath144 to i8*
%addytable2921 = call %clsvar* @add_address_table(%mzone* %zone2913, i8* %var2919, i32 0, i8* %var2920, i32 3, %clsvar* %addytable2918)
%address-table2922 = bitcast %clsvar* %addytable2921 to i8*

; insert table, function and environment into closure struct
%closure.table2925 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float, float*)*}* %closure2915, i32 0, i32 0
store i8* %address-table2922, i8** %closure.table2925
%closure.env2926 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float, float*)*}* %closure2915, i32 0, i32 1
store i8* %envptr2916, i8** %closure.env2926
%closure.func2927 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float, float*)*}* %closure2915, i32 0, i32 2
store void (i8*, i8*, float*, float, float*)* @vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0__2872, void (i8*, i8*, float*, float, float*)** %closure.func2927
%closure_size2928 = call i64 @llvm_zone_mark_size(%mzone* %zone2913)
call void @llvm_zone_ptr_set_size(i8* %clsptr2914, i64 %closure_size2928)
%wrapper_ptr2929 = call i8* @llvm_zone_malloc(%mzone* %zone2913, i64 8)
%closure_wrapper2930 = bitcast i8* %wrapper_ptr2929 to { i8*, i8*, void (i8*, i8*, float*, float, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*, float, float*)*}* %closure2915, { i8*, i8*, void (i8*, i8*, float*, float, float*)*}** %closure_wrapper2930

; let value assignment
%vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float, float*)*}** %closure_wrapper2930, { i8*, i8*, void (i8*, i8*, float*, float, float*)*}** %closure_wrapper2930
store { i8*, i8*, void (i8*, i8*, float*, float, float*)*}** %vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0, { i8*, i8*, void (i8*, i8*, float*, float, float*)*}*** %vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0Ptr

; add data to environment
; don't need to alloc for env var vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0
%tmp_envptr2924 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, float*)*}***}* %environment2917, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float, float*)*}*** %vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0Ptr, {i8*, i8*, void (i8*, i8*, float*, float, float*)*}**** %tmp_envptr2924


%val2933 = load {i8*, i8*, void (i8*, i8*, float*, float, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, float, float*)*}*** %vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, float*, float, float*)*}** %val2933
}


@vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float, float*)*}** @vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0(float* %arg_0,float %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float*)*,  void (i8*, i8*, float*, float, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float* %arg_2)
ret void
}


define dllexport ccc void @vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0_native(float* %arg_0,float %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float*)*,  void (i8*, i8*, float*, float, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float* %arg_2)
ret void
}


define dllexport ccc i8*  @vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2934 = bitcast [102 x i8]* @gsxtmmath145 to i8*
call i32 (i8*, ...) @printf(i8* %var2934)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2935 = bitcast [102 x i8]* @gsxtmmath145 to i8*
call i32 (i8*, ...) @printf(i8* %var2935)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2936 = bitcast [102 x i8]* @gsxtmmath145 to i8*
call i32 (i8*, ...) @printf(i8* %var2936)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float*)*,  void (i8*, i8*, float*, float, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float* %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float, float*}*
%arg_p_0 = getelementptr {float*, float, float*}, {float*, float, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float, float*}, {float*, float, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float*, float, float*}, {float*, float, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vaquat_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float*)*,  void (i8*, i8*, float*, float, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath146 = hidden constant [53 x i8] c"vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0\00"
@gsxtmmath147 = hidden constant [57 x i8] c"{i8*, i8*, void (i8*, i8*, double*, double, double*)*}**\00"
define dllexport fastcc void @vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0__2937(i8* %_impz,i8* %_impenv, double* %v, double %angle, double* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2938 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, double, double*)*}***}*
%vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double, double*)*}***}* %impenv, i32 0, i32 0
%vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0Ptr = load {i8*, i8*, void (i8*, i8*, double*, double, double*)*}***, {i8*, i8*, void (i8*, i8*, double*, double, double*)*}**** %vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0Ptr_

; setup arguments
%vPtr = alloca double*
store double* %v, double** %vPtr
%anglePtr = alloca double
store double %angle, double* %anglePtr
%resultPtr = alloca double*
store double* %result, double** %resultPtr


%tzone2941 = load i8*, i8** %_impzPtr
%zone2942 = bitcast i8* %tzone2941 to %mzone*

; let assign value to symbol m
%mPtr = alloca double
%tzone2948 = load i8*, i8** %_impzPtr
%zone2949 = bitcast i8* %tzone2948 to %mzone*

; let assign value to symbol s
%sPtr = alloca double
%val2939 = load double*, double** %vPtr
%res2940 = call fastcc double @vmag_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0(double* %val2939, i64 3)

; let value assignment
%m = select i1 true, double %res2940, double %res2940
store double %m, double* %mPtr

%val2943 = load double, double* %anglePtr
%val2944 = fmul double 0.50000000000000000000, %val2943
%val2945 = call double @llvm.sin.f64(double %val2944)
%val2946 = load double, double* %mPtr
%val2947 = fdiv double %val2945, %val2946

; let value assignment
%s = select i1 true, double %val2947, double %val2947
store double %s, double* %sPtr

%val2950 = load double*, double** %resultPtr
%val2951 = load double*, double** %vPtr
; pointer ref
%val2952 = getelementptr double, double* %val2951, i64 0
%val2953 = load double, double* %val2952
%val2954 = load double, double* %sPtr
%val2955 = fmul double %val2953, %val2954
; set pointer
%val2956 = getelementptr double, double* %val2950, i64 0
store double %val2955, double* %val2956
%val2957 = load double*, double** %resultPtr
%val2958 = load double*, double** %vPtr
; pointer ref
%val2959 = getelementptr double, double* %val2958, i64 1
%val2960 = load double, double* %val2959
%val2961 = load double, double* %sPtr
%val2962 = fmul double %val2960, %val2961
; set pointer
%val2963 = getelementptr double, double* %val2957, i64 1
store double %val2962, double* %val2963
%val2964 = load double*, double** %resultPtr
%val2965 = load double*, double** %vPtr
; pointer ref
%val2966 = getelementptr double, double* %val2965, i64 2
%val2967 = load double, double* %val2966
%val2968 = load double, double* %sPtr
%val2969 = fmul double %val2967, %val2968
; set pointer
%val2970 = getelementptr double, double* %val2964, i64 2
store double %val2969, double* %val2970
%val2971 = load double*, double** %resultPtr
%val2972 = load double, double* %anglePtr
%val2973 = fmul double 0.50000000000000000000, %val2972
%val2974 = call double @llvm.cos.f64(double %val2973)
; set pointer
%val2975 = getelementptr double, double* %val2971, i64 3
store double %val2974, double* %val2975
ret void
}
@gsxtmmath148 = hidden constant [106 x i8] c"vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, double, double*)*}** @vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2996 = load i8*, i8** %_impzPtr
%zone2997 = bitcast i8* %tzone2996 to %mzone*

; let assign value to symbol vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0
%dat_vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0 = call i8* @llvm_zone_malloc(%mzone* %zone2997, i64 8)
%vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0Ptr = bitcast i8* %dat_vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0 to { i8*, i8*, void (i8*, i8*, double*, double, double*)*}***
%tzone2977 = load i8*, i8** %_impzPtr
%zone2978 = bitcast i8* %tzone2977 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2978)
; malloc closure structure
%clsptr2979 = call i8* @llvm_zone_malloc(%mzone* %zone2978, i64 24)
%closure2980 = bitcast i8* %clsptr2979 to { i8*, i8*, void (i8*, i8*, double*, double, double*)*}*

; malloc environment structure
%envptr2981 = call i8* @llvm_zone_malloc(%mzone* %zone2978, i64 8)
%environment2982 = bitcast i8* %envptr2981 to {{i8*, i8*, void (i8*, i8*, double*, double, double*)*}***}*

; malloc closure address table
%addytable2983 = call %clsvar* @new_address_table()
%var2984 = bitcast [53 x i8]* @gsxtmmath146 to i8*
%var2985 = bitcast [57 x i8]* @gsxtmmath147 to i8*
%addytable2986 = call %clsvar* @add_address_table(%mzone* %zone2978, i8* %var2984, i32 0, i8* %var2985, i32 3, %clsvar* %addytable2983)
%address-table2987 = bitcast %clsvar* %addytable2986 to i8*

; insert table, function and environment into closure struct
%closure.table2990 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double, double*)*}, { i8*, i8*, void (i8*, i8*, double*, double, double*)*}* %closure2980, i32 0, i32 0
store i8* %address-table2987, i8** %closure.table2990
%closure.env2991 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double, double*)*}, { i8*, i8*, void (i8*, i8*, double*, double, double*)*}* %closure2980, i32 0, i32 1
store i8* %envptr2981, i8** %closure.env2991
%closure.func2992 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double, double*)*}, { i8*, i8*, void (i8*, i8*, double*, double, double*)*}* %closure2980, i32 0, i32 2
store void (i8*, i8*, double*, double, double*)* @vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0__2937, void (i8*, i8*, double*, double, double*)** %closure.func2992
%closure_size2993 = call i64 @llvm_zone_mark_size(%mzone* %zone2978)
call void @llvm_zone_ptr_set_size(i8* %clsptr2979, i64 %closure_size2993)
%wrapper_ptr2994 = call i8* @llvm_zone_malloc(%mzone* %zone2978, i64 8)
%closure_wrapper2995 = bitcast i8* %wrapper_ptr2994 to { i8*, i8*, void (i8*, i8*, double*, double, double*)*}**
store { i8*, i8*, void (i8*, i8*, double*, double, double*)*}* %closure2980, { i8*, i8*, void (i8*, i8*, double*, double, double*)*}** %closure_wrapper2995

; let value assignment
%vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, double*, double, double*)*}** %closure_wrapper2995, { i8*, i8*, void (i8*, i8*, double*, double, double*)*}** %closure_wrapper2995
store { i8*, i8*, void (i8*, i8*, double*, double, double*)*}** %vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0, { i8*, i8*, void (i8*, i8*, double*, double, double*)*}*** %vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0Ptr

; add data to environment
; don't need to alloc for env var vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0
%tmp_envptr2989 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double, double*)*}***}* %environment2982, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, double, double*)*}*** %vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0Ptr, {i8*, i8*, void (i8*, i8*, double*, double, double*)*}**** %tmp_envptr2989


%val2998 = load {i8*, i8*, void (i8*, i8*, double*, double, double*)*}**, {i8*, i8*, void (i8*, i8*, double*, double, double*)*}*** %vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0Ptr
ret {i8*, i8*, void (i8*, i8*, double*, double, double*)*}** %val2998
}


@vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0_var = dllexport global [1 x i8*] [ i8* null ]

@vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, double, double*)*}** @vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, double, double*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0(double* %arg_0,double %arg_1,double* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double, double*)*,  void (i8*, i8*, double*, double, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double %arg_1, double* %arg_2)
ret void
}


define dllexport ccc void @vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0_native(double* %arg_0,double %arg_1,double* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double, double*)*,  void (i8*, i8*, double*, double, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double %arg_1, double* %arg_2)
ret void
}


define dllexport ccc i8*  @vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2999 = bitcast [106 x i8]* @gsxtmmath148 to i8*
call i32 (i8*, ...) @printf(i8* %var2999)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3000 = bitcast [106 x i8]* @gsxtmmath148 to i8*
call i32 (i8*, ...) @printf(i8* %var3000)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3001 = bitcast [106 x i8]* @gsxtmmath148 to i8*
call i32 (i8*, ...) @printf(i8* %var3001)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to double*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double, double*)*,  void (i8*, i8*, double*, double, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double %arg_1, double* %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, double, double*}*
%arg_p_0 = getelementptr {double*, double, double*}, {double*, double, double*}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, double, double*}, {double*, double, double*}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
%arg_p_2 = getelementptr {double*, double, double*}, {double*, double, double*}* %fstruct, i32 0, i32 2
%arg_2 = load double*, double** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vaquat_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUsZG91YmxlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, double, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double, double*)*}, {i8*, i8*, void (i8*, i8*, double*, double, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double, double*)*,  void (i8*, i8*, double*, double, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double %arg_1, double* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath149 = hidden constant [2 x i8] c"[\00"
@gsxtmmath150 = hidden constant [4 x i8] c" %f\00"
@gsxtmmath151 = hidden constant [4 x i8] c" ]
\00"
@gsxtmmath152 = hidden constant [42 x i8] c"mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd\00"
define dllexport fastcc void @mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd__3002(i8* %_impz,i8* %_impenv, float* %m, i64 %nrows, i64 %ncols) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3003 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***}*
%mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***}* %impenv, i32 0, i32 0
%mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**** %mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr_

; setup arguments
%mPtr = alloca float*
store float* %m, float** %mPtr
%nrowsPtr = alloca i64
store i64 %nrows, i64* %nrowsPtr
%ncolsPtr = alloca i64
store i64 %ncols, i64* %ncolsPtr


%tzone3004 = load i8*, i8** %_impzPtr
%zone3005 = bitcast i8* %tzone3004 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%tzone3006 = load i8*, i8** %_impzPtr
%zone3007 = bitcast i8* %tzone3006 to %mzone*

; let assign value to symbol j
%jPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr


; let value assignment
%j = select i1 true, i64 0, i64 0
store i64 %j, i64* %jPtr

; setup loop
%val3010 = load i64, i64* %nrowsPtr
store i64 0, i64* %iPtr
%val3033 = load i64, i64* %iPtr
%num3034 = add i64 %val3010, %val3033
%comp3035 = icmp ult i64 %val3010, 1
br i1 %comp3035, label %after3008, label %loop3008

loop3008:
%var3011 = bitcast [2 x i8]* @gsxtmmath149 to i8*

%val3012 = call i32 (i8*, ...) @printf(i8* %var3011)
; setup loop
%val3015 = load i64, i64* %ncolsPtr
store i64 0, i64* %jPtr
%val3027 = load i64, i64* %jPtr
%num3028 = add i64 %val3015, %val3027
%comp3029 = icmp ult i64 %val3015, 1
br i1 %comp3029, label %after3013, label %loop3013

loop3013:
%var3016 = bitcast [4 x i8]* @gsxtmmath150 to i8*
%val3017 = load i64, i64* %jPtr
%val3018 = load i64, i64* %iPtr
%val3019 = load i64, i64* %ncolsPtr
%val3020 = mul i64 %val3018, %val3019
%val3021 = add i64 %val3017, %val3020
%val3022 = load float*, float** %mPtr
; pointer ref
%val3023 = getelementptr float, float* %val3022, i64 %val3021
%val3024 = load float, float* %val3023
%res3025 = call ccc double @ftod(float %val3024)

%val3026 = call i32 (i8*, ...) @printf(i8* %var3016, double %res3025)
%loop_cnt3013 = load i64, i64* %jPtr
%next3013 = add i64 %loop_cnt3013, 1
store i64 %next3013, i64* %jPtr
%cmp3013 = icmp ult i64 %next3013, %num3028
br i1 %cmp3013, label %loop3013, label %after3013

after3013:
%var3031 = bitcast [4 x i8]* @gsxtmmath151 to i8*

%val3032 = call i32 (i8*, ...) @printf(i8* %var3031)
%loop_cnt3008 = load i64, i64* %iPtr
%next3008 = add i64 %loop_cnt3008, 1
store i64 %next3008, i64* %iPtr
%cmp3008 = icmp ult i64 %next3008, %num3034
br i1 %cmp3008, label %loop3008, label %after3008

after3008:
ret void
}
@gsxtmmath153 = hidden constant [95 x i8] c"mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** @mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3057 = load i8*, i8** %_impzPtr
%zone3058 = bitcast i8* %tzone3057 to %mzone*

; let assign value to symbol mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd
%dat_mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone3058, i64 8)
%mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr = bitcast i8* %dat_mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd to { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***
%tzone3038 = load i8*, i8** %_impzPtr
%zone3039 = bitcast i8* %tzone3038 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3039)
; malloc closure structure
%clsptr3040 = call i8* @llvm_zone_malloc(%mzone* %zone3039, i64 24)
%closure3041 = bitcast i8* %clsptr3040 to { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*

; malloc environment structure
%envptr3042 = call i8* @llvm_zone_malloc(%mzone* %zone3039, i64 8)
%environment3043 = bitcast i8* %envptr3042 to {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***}*

; malloc closure address table
%addytable3044 = call %clsvar* @new_address_table()
%var3045 = bitcast [42 x i8]* @gsxtmmath152 to i8*
%var3046 = bitcast [49 x i8]* @gsxtmmath54 to i8*
%addytable3047 = call %clsvar* @add_address_table(%mzone* %zone3039, i8* %var3045, i32 0, i8* %var3046, i32 3, %clsvar* %addytable3044)
%address-table3048 = bitcast %clsvar* %addytable3047 to i8*

; insert table, function and environment into closure struct
%closure.table3051 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure3041, i32 0, i32 0
store i8* %address-table3048, i8** %closure.table3051
%closure.env3052 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure3041, i32 0, i32 1
store i8* %envptr3042, i8** %closure.env3052
%closure.func3053 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure3041, i32 0, i32 2
store void (i8*, i8*, float*, i64, i64)* @mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd__3002, void (i8*, i8*, float*, i64, i64)** %closure.func3053
%closure_size3054 = call i64 @llvm_zone_mark_size(%mzone* %zone3039)
call void @llvm_zone_ptr_set_size(i8* %clsptr3040, i64 %closure_size3054)
%wrapper_ptr3055 = call i8* @llvm_zone_malloc(%mzone* %zone3039, i64 8)
%closure_wrapper3056 = bitcast i8* %wrapper_ptr3055 to { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**
store { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure3041, { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure_wrapper3056

; let value assignment
%mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd = select i1 true, { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure_wrapper3056, { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure_wrapper3056
store { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd, { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*** %mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr

; add data to environment
; don't need to alloc for env var mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd
%tmp_envptr3050 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***}* %environment3043, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*** %mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**** %tmp_envptr3050


%val3059 = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*** %mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr
ret {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %val3059
}


@mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** @mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd(float* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, i64)*,  void (i8*, i8*, float*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_native(float* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, i64)*,  void (i8*, i8*, float*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3060 = bitcast [95 x i8]* @gsxtmmath153 to i8*
call i32 (i8*, ...) @printf(i8* %var3060)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3061 = bitcast [95 x i8]* @gsxtmmath153 to i8*
call i32 (i8*, ...) @printf(i8* %var3061)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3062 = bitcast [95 x i8]* @gsxtmmath153 to i8*
call i32 (i8*, ...) @printf(i8* %var3062)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, i64)*,  void (i8*, i8*, float*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64, i64}*
%arg_p_0 = getelementptr {float*, i64, i64}, {float*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64, i64}, {float*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {float*, i64, i64}, {float*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, i64)*,  void (i8*, i8*, float*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath154 = hidden constant [44 x i8] c"mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ\00"
define dllexport fastcc void @mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ__3063(i8* %_impz,i8* %_impenv, double* %m, i64 %nrows, i64 %ncols) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3064 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***}*
%mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***}* %impenv, i32 0, i32 0
%mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**** %mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr_

; setup arguments
%mPtr = alloca double*
store double* %m, double** %mPtr
%nrowsPtr = alloca i64
store i64 %nrows, i64* %nrowsPtr
%ncolsPtr = alloca i64
store i64 %ncols, i64* %ncolsPtr


%tzone3065 = load i8*, i8** %_impzPtr
%zone3066 = bitcast i8* %tzone3065 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%tzone3067 = load i8*, i8** %_impzPtr
%zone3068 = bitcast i8* %tzone3067 to %mzone*

; let assign value to symbol j
%jPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr


; let value assignment
%j = select i1 true, i64 0, i64 0
store i64 %j, i64* %jPtr

; setup loop
%val3071 = load i64, i64* %nrowsPtr
store i64 0, i64* %iPtr
%val3093 = load i64, i64* %iPtr
%num3094 = add i64 %val3071, %val3093
%comp3095 = icmp ult i64 %val3071, 1
br i1 %comp3095, label %after3069, label %loop3069

loop3069:
%var3072 = bitcast [2 x i8]* @gsxtmmath149 to i8*

%val3073 = call i32 (i8*, ...) @printf(i8* %var3072)
; setup loop
%val3076 = load i64, i64* %ncolsPtr
store i64 0, i64* %jPtr
%val3087 = load i64, i64* %jPtr
%num3088 = add i64 %val3076, %val3087
%comp3089 = icmp ult i64 %val3076, 1
br i1 %comp3089, label %after3074, label %loop3074

loop3074:
%var3077 = bitcast [4 x i8]* @gsxtmmath150 to i8*
%val3078 = load i64, i64* %jPtr
%val3079 = load i64, i64* %iPtr
%val3080 = load i64, i64* %ncolsPtr
%val3081 = mul i64 %val3079, %val3080
%val3082 = add i64 %val3078, %val3081
%val3083 = load double*, double** %mPtr
; pointer ref
%val3084 = getelementptr double, double* %val3083, i64 %val3082
%val3085 = load double, double* %val3084

%val3086 = call i32 (i8*, ...) @printf(i8* %var3077, double %val3085)
%loop_cnt3074 = load i64, i64* %jPtr
%next3074 = add i64 %loop_cnt3074, 1
store i64 %next3074, i64* %jPtr
%cmp3074 = icmp ult i64 %next3074, %num3088
br i1 %cmp3074, label %loop3074, label %after3074

after3074:
%var3091 = bitcast [4 x i8]* @gsxtmmath151 to i8*

%val3092 = call i32 (i8*, ...) @printf(i8* %var3091)
%loop_cnt3069 = load i64, i64* %iPtr
%next3069 = add i64 %loop_cnt3069, 1
store i64 %next3069, i64* %iPtr
%cmp3069 = icmp ult i64 %next3069, %num3094
br i1 %cmp3069, label %loop3069, label %after3069

after3069:
ret void
}
@gsxtmmath155 = hidden constant [97 x i8] c"mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** @mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3117 = load i8*, i8** %_impzPtr
%zone3118 = bitcast i8* %tzone3117 to %mzone*

; let assign value to symbol mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ
%dat_mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone3118, i64 8)
%mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr = bitcast i8* %dat_mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ to { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***
%tzone3098 = load i8*, i8** %_impzPtr
%zone3099 = bitcast i8* %tzone3098 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3099)
; malloc closure structure
%clsptr3100 = call i8* @llvm_zone_malloc(%mzone* %zone3099, i64 24)
%closure3101 = bitcast i8* %clsptr3100 to { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*

; malloc environment structure
%envptr3102 = call i8* @llvm_zone_malloc(%mzone* %zone3099, i64 8)
%environment3103 = bitcast i8* %envptr3102 to {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***}*

; malloc closure address table
%addytable3104 = call %clsvar* @new_address_table()
%var3105 = bitcast [44 x i8]* @gsxtmmath154 to i8*
%var3106 = bitcast [50 x i8]* @gsxtmmath60 to i8*
%addytable3107 = call %clsvar* @add_address_table(%mzone* %zone3099, i8* %var3105, i32 0, i8* %var3106, i32 3, %clsvar* %addytable3104)
%address-table3108 = bitcast %clsvar* %addytable3107 to i8*

; insert table, function and environment into closure struct
%closure.table3111 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure3101, i32 0, i32 0
store i8* %address-table3108, i8** %closure.table3111
%closure.env3112 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure3101, i32 0, i32 1
store i8* %envptr3102, i8** %closure.env3112
%closure.func3113 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure3101, i32 0, i32 2
store void (i8*, i8*, double*, i64, i64)* @mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ__3063, void (i8*, i8*, double*, i64, i64)** %closure.func3113
%closure_size3114 = call i64 @llvm_zone_mark_size(%mzone* %zone3099)
call void @llvm_zone_ptr_set_size(i8* %clsptr3100, i64 %closure_size3114)
%wrapper_ptr3115 = call i8* @llvm_zone_malloc(%mzone* %zone3099, i64 8)
%closure_wrapper3116 = bitcast i8* %wrapper_ptr3115 to { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**
store { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure3101, { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure_wrapper3116

; let value assignment
%mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure_wrapper3116, { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure_wrapper3116
store { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ, { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*** %mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ
%tmp_envptr3110 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***}* %environment3103, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*** %mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**** %tmp_envptr3110


%val3119 = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*** %mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %val3119
}


@mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** @mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ(double* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, i64)*,  void (i8*, i8*, double*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_native(double* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, i64)*,  void (i8*, i8*, double*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3120 = bitcast [97 x i8]* @gsxtmmath155 to i8*
call i32 (i8*, ...) @printf(i8* %var3120)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3121 = bitcast [97 x i8]* @gsxtmmath155 to i8*
call i32 (i8*, ...) @printf(i8* %var3121)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3122 = bitcast [97 x i8]* @gsxtmmath155 to i8*
call i32 (i8*, ...) @printf(i8* %var3122)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, i64)*,  void (i8*, i8*, double*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, i64, i64}*
%arg_p_0 = getelementptr {double*, i64, i64}, {double*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, i64, i64}, {double*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {double*, i64, i64}, {double*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, i64)*,  void (i8*, i8*, double*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath156 = hidden constant [4 x i8] c" %d\00"
@gsxtmmath157 = hidden constant [40 x i8] c"mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ\00"
define dllexport fastcc void @mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ__3123(i8* %_impz,i8* %_impenv, i32* %m, i64 %nrows, i64 %ncols) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3124 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***}*
%mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***}* %impenv, i32 0, i32 0
%mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**** %mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr_

; setup arguments
%mPtr = alloca i32*
store i32* %m, i32** %mPtr
%nrowsPtr = alloca i64
store i64 %nrows, i64* %nrowsPtr
%ncolsPtr = alloca i64
store i64 %ncols, i64* %ncolsPtr


%tzone3125 = load i8*, i8** %_impzPtr
%zone3126 = bitcast i8* %tzone3125 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%tzone3127 = load i8*, i8** %_impzPtr
%zone3128 = bitcast i8* %tzone3127 to %mzone*

; let assign value to symbol j
%jPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr


; let value assignment
%j = select i1 true, i64 0, i64 0
store i64 %j, i64* %jPtr

; setup loop
%val3131 = load i64, i64* %nrowsPtr
store i64 0, i64* %iPtr
%val3153 = load i64, i64* %iPtr
%num3154 = add i64 %val3131, %val3153
%comp3155 = icmp ult i64 %val3131, 1
br i1 %comp3155, label %after3129, label %loop3129

loop3129:
%var3132 = bitcast [2 x i8]* @gsxtmmath149 to i8*

%val3133 = call i32 (i8*, ...) @printf(i8* %var3132)
; setup loop
%val3136 = load i64, i64* %ncolsPtr
store i64 0, i64* %jPtr
%val3147 = load i64, i64* %jPtr
%num3148 = add i64 %val3136, %val3147
%comp3149 = icmp ult i64 %val3136, 1
br i1 %comp3149, label %after3134, label %loop3134

loop3134:
%var3137 = bitcast [4 x i8]* @gsxtmmath156 to i8*
%val3138 = load i64, i64* %jPtr
%val3139 = load i64, i64* %iPtr
%val3140 = load i64, i64* %ncolsPtr
%val3141 = mul i64 %val3139, %val3140
%val3142 = add i64 %val3138, %val3141
%val3143 = load i32*, i32** %mPtr
; pointer ref
%val3144 = getelementptr i32, i32* %val3143, i64 %val3142
%val3145 = load i32, i32* %val3144

%val3146 = call i32 (i8*, ...) @printf(i8* %var3137, i32 %val3145)
%loop_cnt3134 = load i64, i64* %jPtr
%next3134 = add i64 %loop_cnt3134, 1
store i64 %next3134, i64* %jPtr
%cmp3134 = icmp ult i64 %next3134, %num3148
br i1 %cmp3134, label %loop3134, label %after3134

after3134:
%var3151 = bitcast [4 x i8]* @gsxtmmath151 to i8*

%val3152 = call i32 (i8*, ...) @printf(i8* %var3151)
%loop_cnt3129 = load i64, i64* %iPtr
%next3129 = add i64 %loop_cnt3129, 1
store i64 %next3129, i64* %iPtr
%cmp3129 = icmp ult i64 %next3129, %num3154
br i1 %cmp3129, label %loop3129, label %after3129

after3129:
ret void
}
@gsxtmmath158 = hidden constant [93 x i8] c"mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** @mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3177 = load i8*, i8** %_impzPtr
%zone3178 = bitcast i8* %tzone3177 to %mzone*

; let assign value to symbol mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ
%dat_mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone3178, i64 8)
%mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr = bitcast i8* %dat_mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ to { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***
%tzone3158 = load i8*, i8** %_impzPtr
%zone3159 = bitcast i8* %tzone3158 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3159)
; malloc closure structure
%clsptr3160 = call i8* @llvm_zone_malloc(%mzone* %zone3159, i64 24)
%closure3161 = bitcast i8* %clsptr3160 to { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*

; malloc environment structure
%envptr3162 = call i8* @llvm_zone_malloc(%mzone* %zone3159, i64 8)
%environment3163 = bitcast i8* %envptr3162 to {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***}*

; malloc closure address table
%addytable3164 = call %clsvar* @new_address_table()
%var3165 = bitcast [40 x i8]* @gsxtmmath157 to i8*
%var3166 = bitcast [47 x i8]* @gsxtmmath40 to i8*
%addytable3167 = call %clsvar* @add_address_table(%mzone* %zone3159, i8* %var3165, i32 0, i8* %var3166, i32 3, %clsvar* %addytable3164)
%address-table3168 = bitcast %clsvar* %addytable3167 to i8*

; insert table, function and environment into closure struct
%closure.table3171 = getelementptr { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure3161, i32 0, i32 0
store i8* %address-table3168, i8** %closure.table3171
%closure.env3172 = getelementptr { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure3161, i32 0, i32 1
store i8* %envptr3162, i8** %closure.env3172
%closure.func3173 = getelementptr { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure3161, i32 0, i32 2
store void (i8*, i8*, i32*, i64, i64)* @mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ__3123, void (i8*, i8*, i32*, i64, i64)** %closure.func3173
%closure_size3174 = call i64 @llvm_zone_mark_size(%mzone* %zone3159)
call void @llvm_zone_ptr_set_size(i8* %clsptr3160, i64 %closure_size3174)
%wrapper_ptr3175 = call i8* @llvm_zone_malloc(%mzone* %zone3159, i64 8)
%closure_wrapper3176 = bitcast i8* %wrapper_ptr3175 to { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**
store { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure3161, { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure_wrapper3176

; let value assignment
%mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure_wrapper3176, { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure_wrapper3176
store { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ, { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*** %mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ
%tmp_envptr3170 = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***}* %environment3163, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*** %mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**** %tmp_envptr3170


%val3179 = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*** %mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %val3179
}


@mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** @mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ(i32* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32*, i64, i64)*,  void (i8*, i8*, i32*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_native(i32* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32*, i64, i64)*,  void (i8*, i8*, i32*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3180 = bitcast [93 x i8]* @gsxtmmath158 to i8*
call i32 (i8*, ...) @printf(i8* %var3180)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i32*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3181 = bitcast [93 x i8]* @gsxtmmath158 to i8*
call i32 (i8*, ...) @printf(i8* %var3181)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3182 = bitcast [93 x i8]* @gsxtmmath158 to i8*
call i32 (i8*, ...) @printf(i8* %var3182)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32*, i64, i64)*,  void (i8*, i8*, i32*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32*, i64, i64}*
%arg_p_0 = getelementptr {i32*, i64, i64}, {i32*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i32*, i32** %arg_p_0
%arg_p_1 = getelementptr {i32*, i64, i64}, {i32*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {i32*, i64, i64}, {i32*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32*, i64, i64)*,  void (i8*, i8*, i32*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath159 = hidden constant [6 x i8] c" %lld\00"
@gsxtmmath160 = hidden constant [40 x i8] c"mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ\00"
define dllexport fastcc void @mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ__3183(i8* %_impz,i8* %_impenv, i64* %m, i64 %nrows, i64 %ncols) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3184 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***}*
%mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***}* %impenv, i32 0, i32 0
%mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**** %mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr_

; setup arguments
%mPtr = alloca i64*
store i64* %m, i64** %mPtr
%nrowsPtr = alloca i64
store i64 %nrows, i64* %nrowsPtr
%ncolsPtr = alloca i64
store i64 %ncols, i64* %ncolsPtr


%tzone3185 = load i8*, i8** %_impzPtr
%zone3186 = bitcast i8* %tzone3185 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%tzone3187 = load i8*, i8** %_impzPtr
%zone3188 = bitcast i8* %tzone3187 to %mzone*

; let assign value to symbol j
%jPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr


; let value assignment
%j = select i1 true, i64 0, i64 0
store i64 %j, i64* %jPtr

; setup loop
%val3191 = load i64, i64* %nrowsPtr
store i64 0, i64* %iPtr
%val3213 = load i64, i64* %iPtr
%num3214 = add i64 %val3191, %val3213
%comp3215 = icmp ult i64 %val3191, 1
br i1 %comp3215, label %after3189, label %loop3189

loop3189:
%var3192 = bitcast [2 x i8]* @gsxtmmath149 to i8*

%val3193 = call i32 (i8*, ...) @printf(i8* %var3192)
; setup loop
%val3196 = load i64, i64* %ncolsPtr
store i64 0, i64* %jPtr
%val3207 = load i64, i64* %jPtr
%num3208 = add i64 %val3196, %val3207
%comp3209 = icmp ult i64 %val3196, 1
br i1 %comp3209, label %after3194, label %loop3194

loop3194:
%var3197 = bitcast [6 x i8]* @gsxtmmath159 to i8*
%val3198 = load i64, i64* %jPtr
%val3199 = load i64, i64* %iPtr
%val3200 = load i64, i64* %ncolsPtr
%val3201 = mul i64 %val3199, %val3200
%val3202 = add i64 %val3198, %val3201
%val3203 = load i64*, i64** %mPtr
; pointer ref
%val3204 = getelementptr i64, i64* %val3203, i64 %val3202
%val3205 = load i64, i64* %val3204

%val3206 = call i32 (i8*, ...) @printf(i8* %var3197, i64 %val3205)
%loop_cnt3194 = load i64, i64* %jPtr
%next3194 = add i64 %loop_cnt3194, 1
store i64 %next3194, i64* %jPtr
%cmp3194 = icmp ult i64 %next3194, %num3208
br i1 %cmp3194, label %loop3194, label %after3194

after3194:
%var3211 = bitcast [4 x i8]* @gsxtmmath151 to i8*

%val3212 = call i32 (i8*, ...) @printf(i8* %var3211)
%loop_cnt3189 = load i64, i64* %iPtr
%next3189 = add i64 %loop_cnt3189, 1
store i64 %next3189, i64* %iPtr
%cmp3189 = icmp ult i64 %next3189, %num3214
br i1 %cmp3189, label %loop3189, label %after3189

after3189:
ret void
}
@gsxtmmath161 = hidden constant [93 x i8] c"mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** @mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3237 = load i8*, i8** %_impzPtr
%zone3238 = bitcast i8* %tzone3237 to %mzone*

; let assign value to symbol mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ
%dat_mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone3238, i64 8)
%mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr = bitcast i8* %dat_mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ to { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***
%tzone3218 = load i8*, i8** %_impzPtr
%zone3219 = bitcast i8* %tzone3218 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3219)
; malloc closure structure
%clsptr3220 = call i8* @llvm_zone_malloc(%mzone* %zone3219, i64 24)
%closure3221 = bitcast i8* %clsptr3220 to { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*

; malloc environment structure
%envptr3222 = call i8* @llvm_zone_malloc(%mzone* %zone3219, i64 8)
%environment3223 = bitcast i8* %envptr3222 to {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***}*

; malloc closure address table
%addytable3224 = call %clsvar* @new_address_table()
%var3225 = bitcast [40 x i8]* @gsxtmmath160 to i8*
%var3226 = bitcast [47 x i8]* @gsxtmmath47 to i8*
%addytable3227 = call %clsvar* @add_address_table(%mzone* %zone3219, i8* %var3225, i32 0, i8* %var3226, i32 3, %clsvar* %addytable3224)
%address-table3228 = bitcast %clsvar* %addytable3227 to i8*

; insert table, function and environment into closure struct
%closure.table3231 = getelementptr { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure3221, i32 0, i32 0
store i8* %address-table3228, i8** %closure.table3231
%closure.env3232 = getelementptr { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure3221, i32 0, i32 1
store i8* %envptr3222, i8** %closure.env3232
%closure.func3233 = getelementptr { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure3221, i32 0, i32 2
store void (i8*, i8*, i64*, i64, i64)* @mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ__3183, void (i8*, i8*, i64*, i64, i64)** %closure.func3233
%closure_size3234 = call i64 @llvm_zone_mark_size(%mzone* %zone3219)
call void @llvm_zone_ptr_set_size(i8* %clsptr3220, i64 %closure_size3234)
%wrapper_ptr3235 = call i8* @llvm_zone_malloc(%mzone* %zone3219, i64 8)
%closure_wrapper3236 = bitcast i8* %wrapper_ptr3235 to { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**
store { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure3221, { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure_wrapper3236

; let value assignment
%mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure_wrapper3236, { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure_wrapper3236
store { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ, { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*** %mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ
%tmp_envptr3230 = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***}* %environment3223, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*** %mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**** %tmp_envptr3230


%val3239 = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*** %mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %val3239
}


@mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** @mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ(i64* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64*, i64, i64)*,  void (i8*, i8*, i64*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_native(i64* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64*, i64, i64)*,  void (i8*, i8*, i64*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3240 = bitcast [93 x i8]* @gsxtmmath161 to i8*
call i32 (i8*, ...) @printf(i8* %var3240)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i64*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3241 = bitcast [93 x i8]* @gsxtmmath161 to i8*
call i32 (i8*, ...) @printf(i8* %var3241)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3242 = bitcast [93 x i8]* @gsxtmmath161 to i8*
call i32 (i8*, ...) @printf(i8* %var3242)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64*, i64, i64)*,  void (i8*, i8*, i64*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64*, i64, i64}*
%arg_p_0 = getelementptr {i64*, i64, i64}, {i64*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64*, i64** %arg_p_0
%arg_p_1 = getelementptr {i64*, i64, i64}, {i64*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {i64*, i64, i64}, {i64*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mprint_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64*, i64, i64)*,  void (i8*, i8*, i64*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath162 = hidden constant [51 x i8] c"bad matrix multiplication [%lld,%lld]*[%lld,%lld]
\00"
@gsxtmmath163 = hidden constant [73 x i8] c"mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd\00"
@gsxtmmath164 = hidden constant [77 x i8] c"{i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}**\00"
define dllexport fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd__3243(i8* %_impz,i8* %_impenv, float* %m1, i64 %r1, i64 %c1, float* %m2, i64 %r2, i64 %c2, float* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3244 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}***}*
%mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpdPtr_ = getelementptr {{i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}***}, {{i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}***}* %impenv, i32 0, i32 0
%mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpdPtr = load {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}***, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}**** %mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpdPtr_

; setup arguments
%m1Ptr = alloca float*
store float* %m1, float** %m1Ptr
%r1Ptr = alloca i64
store i64 %r1, i64* %r1Ptr
%c1Ptr = alloca i64
store i64 %c1, i64* %c1Ptr
%m2Ptr = alloca float*
store float* %m2, float** %m2Ptr
%r2Ptr = alloca i64
store i64 %r2, i64* %r2Ptr
%c2Ptr = alloca i64
store i64 %c2, i64* %c2Ptr
%resultPtr = alloca float*
store float* %result, float** %resultPtr


%val3246 = load i64, i64* %c1Ptr
%val3247 = load i64, i64* %r2Ptr
%cmp3248 = icmp eq i64 %val3246, %val3247
br i1 %cmp3248, label %then3245, label %else3245

then3245:
%tzone3249 = load i8*, i8** %_impzPtr
%zone3250 = bitcast i8* %tzone3249 to %mzone*

; let assign value to symbol r
%rPtr = alloca i64
%tzone3251 = load i8*, i8** %_impzPtr
%zone3252 = bitcast i8* %tzone3251 to %mzone*

; let assign value to symbol c
%cPtr = alloca i64
%tzone3253 = load i8*, i8** %_impzPtr
%zone3254 = bitcast i8* %tzone3253 to %mzone*

; let assign value to symbol k
%kPtr = alloca i64

; let value assignment
%r = select i1 true, i64 0, i64 0
store i64 %r, i64* %rPtr


; let value assignment
%c = select i1 true, i64 0, i64 0
store i64 %c, i64* %cPtr


; let value assignment
%k = select i1 true, i64 0, i64 0
store i64 %k, i64* %kPtr

; setup loop
%val3257 = load i64, i64* %r1Ptr
store i64 0, i64* %rPtr
%val3312 = load i64, i64* %rPtr
%num3313 = add i64 %val3257, %val3312
%comp3314 = icmp ult i64 %val3257, 1
br i1 %comp3314, label %after3255, label %loop3255

loop3255:
; setup loop
%val3260 = load i64, i64* %c2Ptr
store i64 0, i64* %cPtr
%val3308 = load i64, i64* %cPtr
%num3309 = add i64 %val3260, %val3308
%comp3310 = icmp ult i64 %val3260, 1
br i1 %comp3310, label %after3258, label %loop3258

loop3258:
%val3261 = load i64, i64* %cPtr
%val3262 = load i64, i64* %rPtr
%val3263 = load i64, i64* %c2Ptr
%val3264 = mul i64 %val3262, %val3263
%val3265 = add i64 %val3261, %val3264
%val3266 = load float*, float** %resultPtr
; set pointer
%val3267 = getelementptr float, float* %val3266, i64 %val3265
store float 0x0, float* %val3267
; setup loop
%val3270 = load i64, i64* %c1Ptr
store i64 0, i64* %kPtr
%val3304 = load i64, i64* %kPtr
%num3305 = add i64 %val3270, %val3304
%comp3306 = icmp ult i64 %val3270, 1
br i1 %comp3306, label %after3268, label %loop3268

loop3268:
%val3271 = load i64, i64* %cPtr
%val3272 = load i64, i64* %rPtr
%val3273 = load i64, i64* %c2Ptr
%val3274 = mul i64 %val3272, %val3273
%val3275 = add i64 %val3271, %val3274
%val3276 = load float*, float** %resultPtr
%val3277 = load i64, i64* %cPtr
%val3278 = load i64, i64* %rPtr
%val3279 = load i64, i64* %c2Ptr
%val3280 = mul i64 %val3278, %val3279
%val3281 = add i64 %val3277, %val3280
%val3282 = load float*, float** %resultPtr
; pointer ref
%val3283 = getelementptr float, float* %val3282, i64 %val3281
%val3284 = load float, float* %val3283
%val3285 = load i64, i64* %kPtr
%val3286 = load i64, i64* %rPtr
%val3287 = load i64, i64* %c1Ptr
%val3288 = mul i64 %val3286, %val3287
%val3289 = add i64 %val3285, %val3288
%val3290 = load float*, float** %m1Ptr
; pointer ref
%val3291 = getelementptr float, float* %val3290, i64 %val3289
%val3292 = load float, float* %val3291
%val3293 = load i64, i64* %kPtr
%val3294 = load i64, i64* %c2Ptr
%val3295 = mul i64 %val3293, %val3294
%val3296 = load i64, i64* %cPtr
%val3297 = add i64 %val3295, %val3296
%val3298 = load float*, float** %m2Ptr
; pointer ref
%val3299 = getelementptr float, float* %val3298, i64 %val3297
%val3300 = load float, float* %val3299
%val3301 = fmul float %val3292, %val3300
%val3302 = fadd float %val3284, %val3301
; set pointer
%val3303 = getelementptr float, float* %val3276, i64 %val3275
store float %val3302, float* %val3303
%loop_cnt3268 = load i64, i64* %kPtr
%next3268 = add i64 %loop_cnt3268, 1
store i64 %next3268, i64* %kPtr
%cmp3268 = icmp ult i64 %next3268, %num3305
br i1 %cmp3268, label %loop3268, label %after3268

after3268:
%loop_cnt3258 = load i64, i64* %cPtr
%next3258 = add i64 %loop_cnt3258, 1
store i64 %next3258, i64* %cPtr
%cmp3258 = icmp ult i64 %next3258, %num3309
br i1 %cmp3258, label %loop3258, label %after3258

after3258:
%loop_cnt3255 = load i64, i64* %rPtr
%next3255 = add i64 %loop_cnt3255, 1
store i64 %next3255, i64* %rPtr
%cmp3255 = icmp ult i64 %next3255, %num3313
br i1 %cmp3255, label %loop3255, label %after3255

after3255:
%val3316 = load float*, float** %resultPtr
ret float* %val3316

else3245:
%var3317 = bitcast [51 x i8]* @gsxtmmath162 to i8*
%val3318 = load i64, i64* %r1Ptr
%val3319 = load i64, i64* %c1Ptr
%val3320 = load i64, i64* %r2Ptr
%val3321 = load i64, i64* %c2Ptr

%val3322 = call i32 (i8*, ...) @printf(i8* %var3317, i64 %val3318, i64 %val3319, i64 %val3320, i64 %val3321)
%null3323 = bitcast i8* null to i8*
%val3324 = bitcast i8* %null3323 to float*
ret float* %val3324
}
@gsxtmmath165 = hidden constant [126 x i8] c"mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}** @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3344 = load i8*, i8** %_impzPtr
%zone3345 = bitcast i8* %tzone3344 to %mzone*

; let assign value to symbol mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd
%dat_mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd = call i8* @llvm_zone_malloc(%mzone* %zone3345, i64 8)
%mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpdPtr = bitcast i8* %dat_mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd to { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}***
%tzone3325 = load i8*, i8** %_impzPtr
%zone3326 = bitcast i8* %tzone3325 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3326)
; malloc closure structure
%clsptr3327 = call i8* @llvm_zone_malloc(%mzone* %zone3326, i64 24)
%closure3328 = bitcast i8* %clsptr3327 to { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}*

; malloc environment structure
%envptr3329 = call i8* @llvm_zone_malloc(%mzone* %zone3326, i64 8)
%environment3330 = bitcast i8* %envptr3329 to {{i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}***}*

; malloc closure address table
%addytable3331 = call %clsvar* @new_address_table()
%var3332 = bitcast [73 x i8]* @gsxtmmath163 to i8*
%var3333 = bitcast [77 x i8]* @gsxtmmath164 to i8*
%addytable3334 = call %clsvar* @add_address_table(%mzone* %zone3326, i8* %var3332, i32 0, i8* %var3333, i32 3, %clsvar* %addytable3331)
%address-table3335 = bitcast %clsvar* %addytable3334 to i8*

; insert table, function and environment into closure struct
%closure.table3338 = getelementptr { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}, { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}* %closure3328, i32 0, i32 0
store i8* %address-table3335, i8** %closure.table3338
%closure.env3339 = getelementptr { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}, { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}* %closure3328, i32 0, i32 1
store i8* %envptr3329, i8** %closure.env3339
%closure.func3340 = getelementptr { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}, { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}* %closure3328, i32 0, i32 2
store float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd__3243, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)** %closure.func3340
%closure_size3341 = call i64 @llvm_zone_mark_size(%mzone* %zone3326)
call void @llvm_zone_ptr_set_size(i8* %clsptr3327, i64 %closure_size3341)
%wrapper_ptr3342 = call i8* @llvm_zone_malloc(%mzone* %zone3326, i64 8)
%closure_wrapper3343 = bitcast i8* %wrapper_ptr3342 to { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}**
store { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}* %closure3328, { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}** %closure_wrapper3343

; let value assignment
%mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd = select i1 true, { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}** %closure_wrapper3343, { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}** %closure_wrapper3343
store { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}** %mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd, { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}*** %mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpdPtr

; add data to environment
; don't need to alloc for env var mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd
%tmp_envptr3337 = getelementptr {{i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}***}, {{i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}***}* %environment3330, i32 0, i32 0
store {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}*** %mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpdPtr, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}**** %tmp_envptr3337


%val3346 = load {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}**, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}*** %mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpdPtr
ret {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}** %val3346
}


@mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}** @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd(float* %arg_0,i64 %arg_1,i64 %arg_2,float* %arg_3,i64 %arg_4,i64 %arg_5,float* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}**
%closure = load {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}*, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*,  float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2, float* %arg_3, i64 %arg_4, i64 %arg_5, float* %arg_6)
ret float* %result
}


define dllexport ccc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd_native(float* %arg_0,i64 %arg_1,i64 %arg_2,float* %arg_3,i64 %arg_4,i64 %arg_5,float* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}**
%closure = load {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}*, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*,  float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2, float* %arg_3, i64 %arg_4, i64 %arg_5, float* %arg_6)
ret float* %result
}


define dllexport ccc i8*  @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3347 = bitcast [126 x i8]* @gsxtmmath165 to i8*
call i32 (i8*, ...) @printf(i8* %var3347)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3348 = bitcast [126 x i8]* @gsxtmmath165 to i8*
call i32 (i8*, ...) @printf(i8* %var3348)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3349 = bitcast [126 x i8]* @gsxtmmath165 to i8*
call i32 (i8*, ...) @printf(i8* %var3349)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var3350 = bitcast [126 x i8]* @gsxtmmath165 to i8*
call i32 (i8*, ...) @printf(i8* %var3350)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var3351 = bitcast [126 x i8]* @gsxtmmath165 to i8*
call i32 (i8*, ...) @printf(i8* %var3351)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i64  @i64value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var3352 = bitcast [126 x i8]* @gsxtmmath165 to i8*
call i32 (i8*, ...) @printf(i8* %var3352)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i64  @i64value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var3353 = bitcast [126 x i8]* @gsxtmmath165 to i8*
call i32 (i8*, ...) @printf(i8* %var3353)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}**
%closure = load {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}*, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*,  float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2, float* %arg_3, i64 %arg_4, i64 %arg_5, float* %arg_6)
%tmpres = bitcast float* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64, i64, float*, i64, i64, float*}*
%arg_p_0 = getelementptr {float*, i64, i64, float*, i64, i64, float*}, {float*, i64, i64, float*, i64, i64, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64, i64, float*, i64, i64, float*}, {float*, i64, i64, float*, i64, i64, float*}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {float*, i64, i64, float*, i64, i64, float*}, {float*, i64, i64, float*, i64, i64, float*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {float*, i64, i64, float*, i64, i64, float*}, {float*, i64, i64, float*, i64, i64, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {float*, i64, i64, float*, i64, i64, float*}, {float*, i64, i64, float*, i64, i64, float*}* %fstruct, i32 0, i32 4
%arg_4 = load i64, i64* %arg_p_4
%arg_p_5 = getelementptr {float*, i64, i64, float*, i64, i64, float*}, {float*, i64, i64, float*, i64, i64, float*}* %fstruct, i32 0, i32 5
%arg_5 = load i64, i64* %arg_p_5
%arg_p_6 = getelementptr {float*, i64, i64, float*, i64, i64, float*}, {float*, i64, i64, float*, i64, i64, float*}* %fstruct, i32 0, i32 6
%arg_6 = load float*, float** %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}**
%closure = load {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}*, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)*,  float* (i8*, i8*, float*, i64, i64, float*, i64, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2, float* %arg_3, i64 %arg_4, i64 %arg_5, float* %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath166 = hidden constant [79 x i8] c"mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ\00"
@gsxtmmath167 = hidden constant [81 x i8] c"{i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}**\00"
define dllexport fastcc double* @mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ__3354(i8* %_impz,i8* %_impenv, double* %m1, i64 %r1, i64 %c1, double* %m2, i64 %r2, i64 %c2, double* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3355 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}***}*
%mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQPtr_ = getelementptr {{i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}***}, {{i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}***}* %impenv, i32 0, i32 0
%mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQPtr = load {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}***, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}**** %mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQPtr_

; setup arguments
%m1Ptr = alloca double*
store double* %m1, double** %m1Ptr
%r1Ptr = alloca i64
store i64 %r1, i64* %r1Ptr
%c1Ptr = alloca i64
store i64 %c1, i64* %c1Ptr
%m2Ptr = alloca double*
store double* %m2, double** %m2Ptr
%r2Ptr = alloca i64
store i64 %r2, i64* %r2Ptr
%c2Ptr = alloca i64
store i64 %c2, i64* %c2Ptr
%resultPtr = alloca double*
store double* %result, double** %resultPtr


%val3357 = load i64, i64* %c1Ptr
%val3358 = load i64, i64* %r2Ptr
%cmp3359 = icmp eq i64 %val3357, %val3358
br i1 %cmp3359, label %then3356, label %else3356

then3356:
%tzone3360 = load i8*, i8** %_impzPtr
%zone3361 = bitcast i8* %tzone3360 to %mzone*

; let assign value to symbol r
%rPtr = alloca i64
%tzone3362 = load i8*, i8** %_impzPtr
%zone3363 = bitcast i8* %tzone3362 to %mzone*

; let assign value to symbol c
%cPtr = alloca i64
%tzone3364 = load i8*, i8** %_impzPtr
%zone3365 = bitcast i8* %tzone3364 to %mzone*

; let assign value to symbol k
%kPtr = alloca i64

; let value assignment
%r = select i1 true, i64 0, i64 0
store i64 %r, i64* %rPtr


; let value assignment
%c = select i1 true, i64 0, i64 0
store i64 %c, i64* %cPtr


; let value assignment
%k = select i1 true, i64 0, i64 0
store i64 %k, i64* %kPtr

; setup loop
%val3368 = load i64, i64* %r1Ptr
store i64 0, i64* %rPtr
%val3423 = load i64, i64* %rPtr
%num3424 = add i64 %val3368, %val3423
%comp3425 = icmp ult i64 %val3368, 1
br i1 %comp3425, label %after3366, label %loop3366

loop3366:
; setup loop
%val3371 = load i64, i64* %c2Ptr
store i64 0, i64* %cPtr
%val3419 = load i64, i64* %cPtr
%num3420 = add i64 %val3371, %val3419
%comp3421 = icmp ult i64 %val3371, 1
br i1 %comp3421, label %after3369, label %loop3369

loop3369:
%val3372 = load i64, i64* %cPtr
%val3373 = load i64, i64* %rPtr
%val3374 = load i64, i64* %c2Ptr
%val3375 = mul i64 %val3373, %val3374
%val3376 = add i64 %val3372, %val3375
%val3377 = load double*, double** %resultPtr
; set pointer
%val3378 = getelementptr double, double* %val3377, i64 %val3376
store double 0.00000000000000000000, double* %val3378
; setup loop
%val3381 = load i64, i64* %c1Ptr
store i64 0, i64* %kPtr
%val3415 = load i64, i64* %kPtr
%num3416 = add i64 %val3381, %val3415
%comp3417 = icmp ult i64 %val3381, 1
br i1 %comp3417, label %after3379, label %loop3379

loop3379:
%val3382 = load i64, i64* %cPtr
%val3383 = load i64, i64* %rPtr
%val3384 = load i64, i64* %c2Ptr
%val3385 = mul i64 %val3383, %val3384
%val3386 = add i64 %val3382, %val3385
%val3387 = load double*, double** %resultPtr
%val3388 = load i64, i64* %cPtr
%val3389 = load i64, i64* %rPtr
%val3390 = load i64, i64* %c2Ptr
%val3391 = mul i64 %val3389, %val3390
%val3392 = add i64 %val3388, %val3391
%val3393 = load double*, double** %resultPtr
; pointer ref
%val3394 = getelementptr double, double* %val3393, i64 %val3392
%val3395 = load double, double* %val3394
%val3396 = load i64, i64* %kPtr
%val3397 = load i64, i64* %rPtr
%val3398 = load i64, i64* %c1Ptr
%val3399 = mul i64 %val3397, %val3398
%val3400 = add i64 %val3396, %val3399
%val3401 = load double*, double** %m1Ptr
; pointer ref
%val3402 = getelementptr double, double* %val3401, i64 %val3400
%val3403 = load double, double* %val3402
%val3404 = load i64, i64* %kPtr
%val3405 = load i64, i64* %c2Ptr
%val3406 = mul i64 %val3404, %val3405
%val3407 = load i64, i64* %cPtr
%val3408 = add i64 %val3406, %val3407
%val3409 = load double*, double** %m2Ptr
; pointer ref
%val3410 = getelementptr double, double* %val3409, i64 %val3408
%val3411 = load double, double* %val3410
%val3412 = fmul double %val3403, %val3411
%val3413 = fadd double %val3395, %val3412
; set pointer
%val3414 = getelementptr double, double* %val3387, i64 %val3386
store double %val3413, double* %val3414
%loop_cnt3379 = load i64, i64* %kPtr
%next3379 = add i64 %loop_cnt3379, 1
store i64 %next3379, i64* %kPtr
%cmp3379 = icmp ult i64 %next3379, %num3416
br i1 %cmp3379, label %loop3379, label %after3379

after3379:
%loop_cnt3369 = load i64, i64* %cPtr
%next3369 = add i64 %loop_cnt3369, 1
store i64 %next3369, i64* %cPtr
%cmp3369 = icmp ult i64 %next3369, %num3420
br i1 %cmp3369, label %loop3369, label %after3369

after3369:
%loop_cnt3366 = load i64, i64* %rPtr
%next3366 = add i64 %loop_cnt3366, 1
store i64 %next3366, i64* %rPtr
%cmp3366 = icmp ult i64 %next3366, %num3424
br i1 %cmp3366, label %loop3366, label %after3366

after3366:
%val3427 = load double*, double** %resultPtr
ret double* %val3427

else3356:
%var3428 = bitcast [51 x i8]* @gsxtmmath162 to i8*
%val3429 = load i64, i64* %r1Ptr
%val3430 = load i64, i64* %c1Ptr
%val3431 = load i64, i64* %r2Ptr
%val3432 = load i64, i64* %c2Ptr

%val3433 = call i32 (i8*, ...) @printf(i8* %var3428, i64 %val3429, i64 %val3430, i64 %val3431, i64 %val3432)
%null3434 = bitcast i8* null to i8*
%val3435 = bitcast i8* %null3434 to double*
ret double* %val3435
}
@gsxtmmath168 = hidden constant [132 x i8] c"mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}** @mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3455 = load i8*, i8** %_impzPtr
%zone3456 = bitcast i8* %tzone3455 to %mzone*

; let assign value to symbol mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ
%dat_mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3456, i64 8)
%mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQPtr = bitcast i8* %dat_mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ to { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}***
%tzone3436 = load i8*, i8** %_impzPtr
%zone3437 = bitcast i8* %tzone3436 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3437)
; malloc closure structure
%clsptr3438 = call i8* @llvm_zone_malloc(%mzone* %zone3437, i64 24)
%closure3439 = bitcast i8* %clsptr3438 to { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}*

; malloc environment structure
%envptr3440 = call i8* @llvm_zone_malloc(%mzone* %zone3437, i64 8)
%environment3441 = bitcast i8* %envptr3440 to {{i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}***}*

; malloc closure address table
%addytable3442 = call %clsvar* @new_address_table()
%var3443 = bitcast [79 x i8]* @gsxtmmath166 to i8*
%var3444 = bitcast [81 x i8]* @gsxtmmath167 to i8*
%addytable3445 = call %clsvar* @add_address_table(%mzone* %zone3437, i8* %var3443, i32 0, i8* %var3444, i32 3, %clsvar* %addytable3442)
%address-table3446 = bitcast %clsvar* %addytable3445 to i8*

; insert table, function and environment into closure struct
%closure.table3449 = getelementptr { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}, { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}* %closure3439, i32 0, i32 0
store i8* %address-table3446, i8** %closure.table3449
%closure.env3450 = getelementptr { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}, { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}* %closure3439, i32 0, i32 1
store i8* %envptr3440, i8** %closure.env3450
%closure.func3451 = getelementptr { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}, { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}* %closure3439, i32 0, i32 2
store double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)* @mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ__3354, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)** %closure.func3451
%closure_size3452 = call i64 @llvm_zone_mark_size(%mzone* %zone3437)
call void @llvm_zone_ptr_set_size(i8* %clsptr3438, i64 %closure_size3452)
%wrapper_ptr3453 = call i8* @llvm_zone_malloc(%mzone* %zone3437, i64 8)
%closure_wrapper3454 = bitcast i8* %wrapper_ptr3453 to { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}**
store { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}* %closure3439, { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}** %closure_wrapper3454

; let value assignment
%mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ = select i1 true, { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}** %closure_wrapper3454, { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}** %closure_wrapper3454
store { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}** %mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ, { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}*** %mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQPtr

; add data to environment
; don't need to alloc for env var mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ
%tmp_envptr3448 = getelementptr {{i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}***}, {{i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}***}* %environment3441, i32 0, i32 0
store {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}*** %mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQPtr, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}**** %tmp_envptr3448


%val3457 = load {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}**, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}*** %mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQPtr
ret {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}** %val3457
}


@mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}** @mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double* @mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ(double* %arg_0,i64 %arg_1,i64 %arg_2,double* %arg_3,i64 %arg_4,i64 %arg_5,double* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}**
%closure = load {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}*, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*,  double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double* %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2, double* %arg_3, i64 %arg_4, i64 %arg_5, double* %arg_6)
ret double* %result
}


define dllexport ccc double* @mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ_native(double* %arg_0,i64 %arg_1,i64 %arg_2,double* %arg_3,i64 %arg_4,i64 %arg_5,double* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}**
%closure = load {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}*, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*,  double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double* %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2, double* %arg_3, i64 %arg_4, i64 %arg_5, double* %arg_6)
ret double* %result
}


define dllexport ccc i8*  @mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3458 = bitcast [132 x i8]* @gsxtmmath168 to i8*
call i32 (i8*, ...) @printf(i8* %var3458)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3459 = bitcast [132 x i8]* @gsxtmmath168 to i8*
call i32 (i8*, ...) @printf(i8* %var3459)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3460 = bitcast [132 x i8]* @gsxtmmath168 to i8*
call i32 (i8*, ...) @printf(i8* %var3460)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var3461 = bitcast [132 x i8]* @gsxtmmath168 to i8*
call i32 (i8*, ...) @printf(i8* %var3461)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to double*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var3462 = bitcast [132 x i8]* @gsxtmmath168 to i8*
call i32 (i8*, ...) @printf(i8* %var3462)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i64  @i64value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var3463 = bitcast [132 x i8]* @gsxtmmath168 to i8*
call i32 (i8*, ...) @printf(i8* %var3463)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i64  @i64value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var3464 = bitcast [132 x i8]* @gsxtmmath168 to i8*
call i32 (i8*, ...) @printf(i8* %var3464)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to double*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}**
%closure = load {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}*, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*,  double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double* %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2, double* %arg_3, i64 %arg_4, i64 %arg_5, double* %arg_6)
%tmpres = bitcast double* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, i64, i64, double*, i64, i64, double*}*
%arg_p_0 = getelementptr {double*, i64, i64, double*, i64, i64, double*}, {double*, i64, i64, double*, i64, i64, double*}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, i64, i64, double*, i64, i64, double*}, {double*, i64, i64, double*, i64, i64, double*}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {double*, i64, i64, double*, i64, i64, double*}, {double*, i64, i64, double*, i64, i64, double*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {double*, i64, i64, double*, i64, i64, double*}, {double*, i64, i64, double*, i64, i64, double*}* %fstruct, i32 0, i32 3
%arg_3 = load double*, double** %arg_p_3
%arg_p_4 = getelementptr {double*, i64, i64, double*, i64, i64, double*}, {double*, i64, i64, double*, i64, i64, double*}* %fstruct, i32 0, i32 4
%arg_4 = load i64, i64* %arg_p_4
%arg_p_5 = getelementptr {double*, i64, i64, double*, i64, i64, double*}, {double*, i64, i64, double*, i64, i64, double*}* %fstruct, i32 0, i32 5
%arg_5 = load i64, i64* %arg_p_5
%arg_p_6 = getelementptr {double*, i64, i64, double*, i64, i64, double*}, {double*, i64, i64, double*, i64, i64, double*}* %fstruct, i32 0, i32 6
%arg_6 = load double*, double** %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSosaTY0LGk2NCxkb3VibGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}**
%closure = load {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}*, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)*,  double* (i8*, i8*, double*, i64, i64, double*, i64, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double* %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2, double* %arg_3, i64 %arg_4, i64 %arg_5, double* %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath169 = hidden constant [63 x i8] c"mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ\00"
@gsxtmmath170 = hidden constant [69 x i8] c"{i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}**\00"
define dllexport fastcc i32* @mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ__3465(i8* %_impz,i8* %_impenv, i32* %m1, i64 %r1, i64 %c1, i32* %m2, i64 %r2, i64 %c2, i32* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3466 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}***}*
%mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQPtr_ = getelementptr {{i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}***}, {{i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}***}* %impenv, i32 0, i32 0
%mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQPtr = load {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}***, {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}**** %mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQPtr_

; setup arguments
%m1Ptr = alloca i32*
store i32* %m1, i32** %m1Ptr
%r1Ptr = alloca i64
store i64 %r1, i64* %r1Ptr
%c1Ptr = alloca i64
store i64 %c1, i64* %c1Ptr
%m2Ptr = alloca i32*
store i32* %m2, i32** %m2Ptr
%r2Ptr = alloca i64
store i64 %r2, i64* %r2Ptr
%c2Ptr = alloca i64
store i64 %c2, i64* %c2Ptr
%resultPtr = alloca i32*
store i32* %result, i32** %resultPtr


%val3468 = load i64, i64* %c1Ptr
%val3469 = load i64, i64* %r2Ptr
%cmp3470 = icmp eq i64 %val3468, %val3469
br i1 %cmp3470, label %then3467, label %else3467

then3467:
%tzone3471 = load i8*, i8** %_impzPtr
%zone3472 = bitcast i8* %tzone3471 to %mzone*

; let assign value to symbol r
%rPtr = alloca i64
%tzone3473 = load i8*, i8** %_impzPtr
%zone3474 = bitcast i8* %tzone3473 to %mzone*

; let assign value to symbol c
%cPtr = alloca i64
%tzone3475 = load i8*, i8** %_impzPtr
%zone3476 = bitcast i8* %tzone3475 to %mzone*

; let assign value to symbol k
%kPtr = alloca i64

; let value assignment
%r = select i1 true, i64 0, i64 0
store i64 %r, i64* %rPtr


; let value assignment
%c = select i1 true, i64 0, i64 0
store i64 %c, i64* %cPtr


; let value assignment
%k = select i1 true, i64 0, i64 0
store i64 %k, i64* %kPtr

; setup loop
%val3479 = load i64, i64* %r1Ptr
store i64 0, i64* %rPtr
%val3534 = load i64, i64* %rPtr
%num3535 = add i64 %val3479, %val3534
%comp3536 = icmp ult i64 %val3479, 1
br i1 %comp3536, label %after3477, label %loop3477

loop3477:
; setup loop
%val3482 = load i64, i64* %c2Ptr
store i64 0, i64* %cPtr
%val3530 = load i64, i64* %cPtr
%num3531 = add i64 %val3482, %val3530
%comp3532 = icmp ult i64 %val3482, 1
br i1 %comp3532, label %after3480, label %loop3480

loop3480:
%val3483 = load i64, i64* %cPtr
%val3484 = load i64, i64* %rPtr
%val3485 = load i64, i64* %c2Ptr
%val3486 = mul i64 %val3484, %val3485
%val3487 = add i64 %val3483, %val3486
%val3488 = load i32*, i32** %resultPtr
; set pointer
%val3489 = getelementptr i32, i32* %val3488, i64 %val3487
store i32 0, i32* %val3489
; setup loop
%val3492 = load i64, i64* %c1Ptr
store i64 0, i64* %kPtr
%val3526 = load i64, i64* %kPtr
%num3527 = add i64 %val3492, %val3526
%comp3528 = icmp ult i64 %val3492, 1
br i1 %comp3528, label %after3490, label %loop3490

loop3490:
%val3493 = load i64, i64* %cPtr
%val3494 = load i64, i64* %rPtr
%val3495 = load i64, i64* %c2Ptr
%val3496 = mul i64 %val3494, %val3495
%val3497 = add i64 %val3493, %val3496
%val3498 = load i32*, i32** %resultPtr
%val3499 = load i64, i64* %cPtr
%val3500 = load i64, i64* %rPtr
%val3501 = load i64, i64* %c2Ptr
%val3502 = mul i64 %val3500, %val3501
%val3503 = add i64 %val3499, %val3502
%val3504 = load i32*, i32** %resultPtr
; pointer ref
%val3505 = getelementptr i32, i32* %val3504, i64 %val3503
%val3506 = load i32, i32* %val3505
%val3507 = load i64, i64* %kPtr
%val3508 = load i64, i64* %rPtr
%val3509 = load i64, i64* %c1Ptr
%val3510 = mul i64 %val3508, %val3509
%val3511 = add i64 %val3507, %val3510
%val3512 = load i32*, i32** %m1Ptr
; pointer ref
%val3513 = getelementptr i32, i32* %val3512, i64 %val3511
%val3514 = load i32, i32* %val3513
%val3515 = load i64, i64* %kPtr
%val3516 = load i64, i64* %c2Ptr
%val3517 = mul i64 %val3515, %val3516
%val3518 = load i64, i64* %cPtr
%val3519 = add i64 %val3517, %val3518
%val3520 = load i32*, i32** %m2Ptr
; pointer ref
%val3521 = getelementptr i32, i32* %val3520, i64 %val3519
%val3522 = load i32, i32* %val3521
%val3523 = mul i32 %val3514, %val3522
%val3524 = add i32 %val3506, %val3523
; set pointer
%val3525 = getelementptr i32, i32* %val3498, i64 %val3497
store i32 %val3524, i32* %val3525
%loop_cnt3490 = load i64, i64* %kPtr
%next3490 = add i64 %loop_cnt3490, 1
store i64 %next3490, i64* %kPtr
%cmp3490 = icmp ult i64 %next3490, %num3527
br i1 %cmp3490, label %loop3490, label %after3490

after3490:
%loop_cnt3480 = load i64, i64* %cPtr
%next3480 = add i64 %loop_cnt3480, 1
store i64 %next3480, i64* %cPtr
%cmp3480 = icmp ult i64 %next3480, %num3531
br i1 %cmp3480, label %loop3480, label %after3480

after3480:
%loop_cnt3477 = load i64, i64* %rPtr
%next3477 = add i64 %loop_cnt3477, 1
store i64 %next3477, i64* %rPtr
%cmp3477 = icmp ult i64 %next3477, %num3535
br i1 %cmp3477, label %loop3477, label %after3477

after3477:
%val3538 = load i32*, i32** %resultPtr
ret i32* %val3538

else3467:
%var3539 = bitcast [51 x i8]* @gsxtmmath162 to i8*
%val3540 = load i64, i64* %r1Ptr
%val3541 = load i64, i64* %c1Ptr
%val3542 = load i64, i64* %r2Ptr
%val3543 = load i64, i64* %c2Ptr

%val3544 = call i32 (i8*, ...) @printf(i8* %var3539, i64 %val3540, i64 %val3541, i64 %val3542, i64 %val3543)
%null3545 = bitcast i8* null to i8*
%val3546 = bitcast i8* %null3545 to i32*
ret i32* %val3546
}
@gsxtmmath171 = hidden constant [116 x i8] c"mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}** @mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3566 = load i8*, i8** %_impzPtr
%zone3567 = bitcast i8* %tzone3566 to %mzone*

; let assign value to symbol mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ
%dat_mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3567, i64 8)
%mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQPtr = bitcast i8* %dat_mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ to { i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}***
%tzone3547 = load i8*, i8** %_impzPtr
%zone3548 = bitcast i8* %tzone3547 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3548)
; malloc closure structure
%clsptr3549 = call i8* @llvm_zone_malloc(%mzone* %zone3548, i64 24)
%closure3550 = bitcast i8* %clsptr3549 to { i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}*

; malloc environment structure
%envptr3551 = call i8* @llvm_zone_malloc(%mzone* %zone3548, i64 8)
%environment3552 = bitcast i8* %envptr3551 to {{i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}***}*

; malloc closure address table
%addytable3553 = call %clsvar* @new_address_table()
%var3554 = bitcast [63 x i8]* @gsxtmmath169 to i8*
%var3555 = bitcast [69 x i8]* @gsxtmmath170 to i8*
%addytable3556 = call %clsvar* @add_address_table(%mzone* %zone3548, i8* %var3554, i32 0, i8* %var3555, i32 3, %clsvar* %addytable3553)
%address-table3557 = bitcast %clsvar* %addytable3556 to i8*

; insert table, function and environment into closure struct
%closure.table3560 = getelementptr { i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}, { i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}* %closure3550, i32 0, i32 0
store i8* %address-table3557, i8** %closure.table3560
%closure.env3561 = getelementptr { i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}, { i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}* %closure3550, i32 0, i32 1
store i8* %envptr3551, i8** %closure.env3561
%closure.func3562 = getelementptr { i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}, { i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}* %closure3550, i32 0, i32 2
store i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)* @mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ__3465, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)** %closure.func3562
%closure_size3563 = call i64 @llvm_zone_mark_size(%mzone* %zone3548)
call void @llvm_zone_ptr_set_size(i8* %clsptr3549, i64 %closure_size3563)
%wrapper_ptr3564 = call i8* @llvm_zone_malloc(%mzone* %zone3548, i64 8)
%closure_wrapper3565 = bitcast i8* %wrapper_ptr3564 to { i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}**
store { i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}* %closure3550, { i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}** %closure_wrapper3565

; let value assignment
%mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ = select i1 true, { i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}** %closure_wrapper3565, { i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}** %closure_wrapper3565
store { i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}** %mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ, { i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}*** %mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQPtr

; add data to environment
; don't need to alloc for env var mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ
%tmp_envptr3559 = getelementptr {{i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}***}, {{i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}***}* %environment3552, i32 0, i32 0
store {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}*** %mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQPtr, {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}**** %tmp_envptr3559


%val3568 = load {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}**, {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}*** %mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQPtr
ret {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}** %val3568
}


@mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}** @mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32* @mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ(i32* %arg_0,i64 %arg_1,i64 %arg_2,i32* %arg_3,i64 %arg_4,i64 %arg_5,i32* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}**
%closure = load {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}*, {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}, {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}, {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}* %closure, i32 0, i32 1
%ff = load  i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*,  i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2, i32* %arg_3, i64 %arg_4, i64 %arg_5, i32* %arg_6)
ret i32* %result
}


define dllexport ccc i32* @mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ_native(i32* %arg_0,i64 %arg_1,i64 %arg_2,i32* %arg_3,i64 %arg_4,i64 %arg_5,i32* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}**
%closure = load {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}*, {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}, {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}, {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}* %closure, i32 0, i32 1
%ff = load  i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*,  i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2, i32* %arg_3, i64 %arg_4, i64 %arg_5, i32* %arg_6)
ret i32* %result
}


define dllexport ccc i8*  @mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3569 = bitcast [116 x i8]* @gsxtmmath171 to i8*
call i32 (i8*, ...) @printf(i8* %var3569)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i32*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3570 = bitcast [116 x i8]* @gsxtmmath171 to i8*
call i32 (i8*, ...) @printf(i8* %var3570)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3571 = bitcast [116 x i8]* @gsxtmmath171 to i8*
call i32 (i8*, ...) @printf(i8* %var3571)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var3572 = bitcast [116 x i8]* @gsxtmmath171 to i8*
call i32 (i8*, ...) @printf(i8* %var3572)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to i32*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var3573 = bitcast [116 x i8]* @gsxtmmath171 to i8*
call i32 (i8*, ...) @printf(i8* %var3573)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i64  @i64value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var3574 = bitcast [116 x i8]* @gsxtmmath171 to i8*
call i32 (i8*, ...) @printf(i8* %var3574)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i64  @i64value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var3575 = bitcast [116 x i8]* @gsxtmmath171 to i8*
call i32 (i8*, ...) @printf(i8* %var3575)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to i32*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}**
%closure = load {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}*, {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}, {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}, {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}* %closure, i32 0, i32 1
%ff = load  i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*,  i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2, i32* %arg_3, i64 %arg_4, i64 %arg_5, i32* %arg_6)
%tmpres = bitcast i32* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32*, i64, i64, i32*, i64, i64, i32*}*
%arg_p_0 = getelementptr {i32*, i64, i64, i32*, i64, i64, i32*}, {i32*, i64, i64, i32*, i64, i64, i32*}* %fstruct, i32 0, i32 0
%arg_0 = load i32*, i32** %arg_p_0
%arg_p_1 = getelementptr {i32*, i64, i64, i32*, i64, i64, i32*}, {i32*, i64, i64, i32*, i64, i64, i32*}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {i32*, i64, i64, i32*, i64, i64, i32*}, {i32*, i64, i64, i32*, i64, i64, i32*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {i32*, i64, i64, i32*, i64, i64, i32*}, {i32*, i64, i64, i32*, i64, i64, i32*}* %fstruct, i32 0, i32 3
%arg_3 = load i32*, i32** %arg_p_3
%arg_p_4 = getelementptr {i32*, i64, i64, i32*, i64, i64, i32*}, {i32*, i64, i64, i32*, i64, i64, i32*}* %fstruct, i32 0, i32 4
%arg_4 = load i64, i64* %arg_p_4
%arg_p_5 = getelementptr {i32*, i64, i64, i32*, i64, i64, i32*}, {i32*, i64, i64, i32*, i64, i64, i32*}* %fstruct, i32 0, i32 5
%arg_5 = load i64, i64* %arg_p_5
%arg_p_6 = getelementptr {i32*, i64, i64, i32*, i64, i64, i32*}, {i32*, i64, i64, i32*, i64, i64, i32*}* %fstruct, i32 0, i32 6
%arg_6 = load i32*, i32** %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2kzMiosaTMyKixpNjQsaTY0LGkzMiosaTY0LGk2NCxpMzIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}**
%closure = load {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}*, {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}, {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}, {i8*, i8*, i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*}* %closure, i32 0, i32 1
%ff = load  i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)*,  i32* (i8*, i8*, i32*, i64, i64, i32*, i64, i64, i32*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2, i32* %arg_3, i64 %arg_4, i64 %arg_5, i32* %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath172 = hidden constant [63 x i8] c"mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ\00"
@gsxtmmath173 = hidden constant [69 x i8] c"{i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}**\00"
define dllexport fastcc i64* @mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ__3576(i8* %_impz,i8* %_impenv, i64* %m1, i64 %r1, i64 %c1, i64* %m2, i64 %r2, i64 %c2, i64* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3577 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}***}*
%mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQPtr_ = getelementptr {{i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}***}, {{i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}***}* %impenv, i32 0, i32 0
%mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQPtr = load {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}***, {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}**** %mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQPtr_

; setup arguments
%m1Ptr = alloca i64*
store i64* %m1, i64** %m1Ptr
%r1Ptr = alloca i64
store i64 %r1, i64* %r1Ptr
%c1Ptr = alloca i64
store i64 %c1, i64* %c1Ptr
%m2Ptr = alloca i64*
store i64* %m2, i64** %m2Ptr
%r2Ptr = alloca i64
store i64 %r2, i64* %r2Ptr
%c2Ptr = alloca i64
store i64 %c2, i64* %c2Ptr
%resultPtr = alloca i64*
store i64* %result, i64** %resultPtr


%val3579 = load i64, i64* %c1Ptr
%val3580 = load i64, i64* %r2Ptr
%cmp3581 = icmp eq i64 %val3579, %val3580
br i1 %cmp3581, label %then3578, label %else3578

then3578:
%tzone3582 = load i8*, i8** %_impzPtr
%zone3583 = bitcast i8* %tzone3582 to %mzone*

; let assign value to symbol r
%rPtr = alloca i64
%tzone3584 = load i8*, i8** %_impzPtr
%zone3585 = bitcast i8* %tzone3584 to %mzone*

; let assign value to symbol c
%cPtr = alloca i64
%tzone3586 = load i8*, i8** %_impzPtr
%zone3587 = bitcast i8* %tzone3586 to %mzone*

; let assign value to symbol k
%kPtr = alloca i64

; let value assignment
%r = select i1 true, i64 0, i64 0
store i64 %r, i64* %rPtr


; let value assignment
%c = select i1 true, i64 0, i64 0
store i64 %c, i64* %cPtr


; let value assignment
%k = select i1 true, i64 0, i64 0
store i64 %k, i64* %kPtr

; setup loop
%val3590 = load i64, i64* %r1Ptr
store i64 0, i64* %rPtr
%val3645 = load i64, i64* %rPtr
%num3646 = add i64 %val3590, %val3645
%comp3647 = icmp ult i64 %val3590, 1
br i1 %comp3647, label %after3588, label %loop3588

loop3588:
; setup loop
%val3593 = load i64, i64* %c2Ptr
store i64 0, i64* %cPtr
%val3641 = load i64, i64* %cPtr
%num3642 = add i64 %val3593, %val3641
%comp3643 = icmp ult i64 %val3593, 1
br i1 %comp3643, label %after3591, label %loop3591

loop3591:
%val3594 = load i64, i64* %cPtr
%val3595 = load i64, i64* %rPtr
%val3596 = load i64, i64* %c2Ptr
%val3597 = mul i64 %val3595, %val3596
%val3598 = add i64 %val3594, %val3597
%val3599 = load i64*, i64** %resultPtr
; set pointer
%val3600 = getelementptr i64, i64* %val3599, i64 %val3598
store i64 0, i64* %val3600
; setup loop
%val3603 = load i64, i64* %c1Ptr
store i64 0, i64* %kPtr
%val3637 = load i64, i64* %kPtr
%num3638 = add i64 %val3603, %val3637
%comp3639 = icmp ult i64 %val3603, 1
br i1 %comp3639, label %after3601, label %loop3601

loop3601:
%val3604 = load i64, i64* %cPtr
%val3605 = load i64, i64* %rPtr
%val3606 = load i64, i64* %c2Ptr
%val3607 = mul i64 %val3605, %val3606
%val3608 = add i64 %val3604, %val3607
%val3609 = load i64*, i64** %resultPtr
%val3610 = load i64, i64* %cPtr
%val3611 = load i64, i64* %rPtr
%val3612 = load i64, i64* %c2Ptr
%val3613 = mul i64 %val3611, %val3612
%val3614 = add i64 %val3610, %val3613
%val3615 = load i64*, i64** %resultPtr
; pointer ref
%val3616 = getelementptr i64, i64* %val3615, i64 %val3614
%val3617 = load i64, i64* %val3616
%val3618 = load i64, i64* %kPtr
%val3619 = load i64, i64* %rPtr
%val3620 = load i64, i64* %c1Ptr
%val3621 = mul i64 %val3619, %val3620
%val3622 = add i64 %val3618, %val3621
%val3623 = load i64*, i64** %m1Ptr
; pointer ref
%val3624 = getelementptr i64, i64* %val3623, i64 %val3622
%val3625 = load i64, i64* %val3624
%val3626 = load i64, i64* %kPtr
%val3627 = load i64, i64* %c2Ptr
%val3628 = mul i64 %val3626, %val3627
%val3629 = load i64, i64* %cPtr
%val3630 = add i64 %val3628, %val3629
%val3631 = load i64*, i64** %m2Ptr
; pointer ref
%val3632 = getelementptr i64, i64* %val3631, i64 %val3630
%val3633 = load i64, i64* %val3632
%val3634 = mul i64 %val3625, %val3633
%val3635 = add i64 %val3617, %val3634
; set pointer
%val3636 = getelementptr i64, i64* %val3609, i64 %val3608
store i64 %val3635, i64* %val3636
%loop_cnt3601 = load i64, i64* %kPtr
%next3601 = add i64 %loop_cnt3601, 1
store i64 %next3601, i64* %kPtr
%cmp3601 = icmp ult i64 %next3601, %num3638
br i1 %cmp3601, label %loop3601, label %after3601

after3601:
%loop_cnt3591 = load i64, i64* %cPtr
%next3591 = add i64 %loop_cnt3591, 1
store i64 %next3591, i64* %cPtr
%cmp3591 = icmp ult i64 %next3591, %num3642
br i1 %cmp3591, label %loop3591, label %after3591

after3591:
%loop_cnt3588 = load i64, i64* %rPtr
%next3588 = add i64 %loop_cnt3588, 1
store i64 %next3588, i64* %rPtr
%cmp3588 = icmp ult i64 %next3588, %num3646
br i1 %cmp3588, label %loop3588, label %after3588

after3588:
%val3649 = load i64*, i64** %resultPtr
ret i64* %val3649

else3578:
%var3650 = bitcast [51 x i8]* @gsxtmmath162 to i8*
%val3651 = load i64, i64* %r1Ptr
%val3652 = load i64, i64* %c1Ptr
%val3653 = load i64, i64* %r2Ptr
%val3654 = load i64, i64* %c2Ptr

%val3655 = call i32 (i8*, ...) @printf(i8* %var3650, i64 %val3651, i64 %val3652, i64 %val3653, i64 %val3654)
%null3656 = bitcast i8* null to i8*
%val3657 = bitcast i8* %null3656 to i64*
ret i64* %val3657
}
@gsxtmmath174 = hidden constant [116 x i8] c"mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}** @mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3677 = load i8*, i8** %_impzPtr
%zone3678 = bitcast i8* %tzone3677 to %mzone*

; let assign value to symbol mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ
%dat_mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3678, i64 8)
%mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQPtr = bitcast i8* %dat_mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ to { i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}***
%tzone3658 = load i8*, i8** %_impzPtr
%zone3659 = bitcast i8* %tzone3658 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3659)
; malloc closure structure
%clsptr3660 = call i8* @llvm_zone_malloc(%mzone* %zone3659, i64 24)
%closure3661 = bitcast i8* %clsptr3660 to { i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}*

; malloc environment structure
%envptr3662 = call i8* @llvm_zone_malloc(%mzone* %zone3659, i64 8)
%environment3663 = bitcast i8* %envptr3662 to {{i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}***}*

; malloc closure address table
%addytable3664 = call %clsvar* @new_address_table()
%var3665 = bitcast [63 x i8]* @gsxtmmath172 to i8*
%var3666 = bitcast [69 x i8]* @gsxtmmath173 to i8*
%addytable3667 = call %clsvar* @add_address_table(%mzone* %zone3659, i8* %var3665, i32 0, i8* %var3666, i32 3, %clsvar* %addytable3664)
%address-table3668 = bitcast %clsvar* %addytable3667 to i8*

; insert table, function and environment into closure struct
%closure.table3671 = getelementptr { i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}, { i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}* %closure3661, i32 0, i32 0
store i8* %address-table3668, i8** %closure.table3671
%closure.env3672 = getelementptr { i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}, { i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}* %closure3661, i32 0, i32 1
store i8* %envptr3662, i8** %closure.env3672
%closure.func3673 = getelementptr { i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}, { i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}* %closure3661, i32 0, i32 2
store i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)* @mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ__3576, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)** %closure.func3673
%closure_size3674 = call i64 @llvm_zone_mark_size(%mzone* %zone3659)
call void @llvm_zone_ptr_set_size(i8* %clsptr3660, i64 %closure_size3674)
%wrapper_ptr3675 = call i8* @llvm_zone_malloc(%mzone* %zone3659, i64 8)
%closure_wrapper3676 = bitcast i8* %wrapper_ptr3675 to { i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}**
store { i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}* %closure3661, { i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}** %closure_wrapper3676

; let value assignment
%mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ = select i1 true, { i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}** %closure_wrapper3676, { i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}** %closure_wrapper3676
store { i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}** %mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ, { i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}*** %mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQPtr

; add data to environment
; don't need to alloc for env var mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ
%tmp_envptr3670 = getelementptr {{i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}***}, {{i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}***}* %environment3663, i32 0, i32 0
store {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}*** %mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQPtr, {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}**** %tmp_envptr3670


%val3679 = load {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}**, {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}*** %mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQPtr
ret {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}** %val3679
}


@mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}** @mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64* @mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ(i64* %arg_0,i64 %arg_1,i64 %arg_2,i64* %arg_3,i64 %arg_4,i64 %arg_5,i64* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}**
%closure = load {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}*, {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}, {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}, {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}* %closure, i32 0, i32 1
%ff = load  i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*,  i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64* %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1, i64 %arg_2, i64* %arg_3, i64 %arg_4, i64 %arg_5, i64* %arg_6)
ret i64* %result
}


define dllexport ccc i64* @mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ_native(i64* %arg_0,i64 %arg_1,i64 %arg_2,i64* %arg_3,i64 %arg_4,i64 %arg_5,i64* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}**
%closure = load {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}*, {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}, {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}, {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}* %closure, i32 0, i32 1
%ff = load  i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*,  i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64* %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1, i64 %arg_2, i64* %arg_3, i64 %arg_4, i64 %arg_5, i64* %arg_6)
ret i64* %result
}


define dllexport ccc i8*  @mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3680 = bitcast [116 x i8]* @gsxtmmath174 to i8*
call i32 (i8*, ...) @printf(i8* %var3680)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i64*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3681 = bitcast [116 x i8]* @gsxtmmath174 to i8*
call i32 (i8*, ...) @printf(i8* %var3681)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3682 = bitcast [116 x i8]* @gsxtmmath174 to i8*
call i32 (i8*, ...) @printf(i8* %var3682)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var3683 = bitcast [116 x i8]* @gsxtmmath174 to i8*
call i32 (i8*, ...) @printf(i8* %var3683)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to i64*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var3684 = bitcast [116 x i8]* @gsxtmmath174 to i8*
call i32 (i8*, ...) @printf(i8* %var3684)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i64  @i64value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var3685 = bitcast [116 x i8]* @gsxtmmath174 to i8*
call i32 (i8*, ...) @printf(i8* %var3685)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i64  @i64value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var3686 = bitcast [116 x i8]* @gsxtmmath174 to i8*
call i32 (i8*, ...) @printf(i8* %var3686)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to i64*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}**
%closure = load {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}*, {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}, {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}, {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}* %closure, i32 0, i32 1
%ff = load  i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*,  i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64* %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1, i64 %arg_2, i64* %arg_3, i64 %arg_4, i64 %arg_5, i64* %arg_6)
%tmpres = bitcast i64* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64*, i64, i64, i64*, i64, i64, i64*}*
%arg_p_0 = getelementptr {i64*, i64, i64, i64*, i64, i64, i64*}, {i64*, i64, i64, i64*, i64, i64, i64*}* %fstruct, i32 0, i32 0
%arg_0 = load i64*, i64** %arg_p_0
%arg_p_1 = getelementptr {i64*, i64, i64, i64*, i64, i64, i64*}, {i64*, i64, i64, i64*, i64, i64, i64*}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {i64*, i64, i64, i64*, i64, i64, i64*}, {i64*, i64, i64, i64*, i64, i64, i64*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {i64*, i64, i64, i64*, i64, i64, i64*}, {i64*, i64, i64, i64*, i64, i64, i64*}* %fstruct, i32 0, i32 3
%arg_3 = load i64*, i64** %arg_p_3
%arg_p_4 = getelementptr {i64*, i64, i64, i64*, i64, i64, i64*}, {i64*, i64, i64, i64*, i64, i64, i64*}* %fstruct, i32 0, i32 4
%arg_4 = load i64, i64* %arg_p_4
%arg_p_5 = getelementptr {i64*, i64, i64, i64*, i64, i64, i64*}, {i64*, i64, i64, i64*, i64, i64, i64*}* %fstruct, i32 0, i32 5
%arg_5 = load i64, i64* %arg_p_5
%arg_p_6 = getelementptr {i64*, i64, i64, i64*, i64, i64, i64*}, {i64*, i64, i64, i64*, i64, i64, i64*}* %fstruct, i32 0, i32 6
%arg_6 = load i64*, i64** %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2k2NCosaTY0KixpNjQsaTY0LGk2NCosaTY0LGk2NCxpNjQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}**
%closure = load {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}*, {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}, {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}, {i8*, i8*, i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*}* %closure, i32 0, i32 1
%ff = load  i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)*,  i64* (i8*, i8*, i64*, i64, i64, i64*, i64, i64, i64*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64* %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1, i64 %arg_2, i64* %arg_3, i64 %arg_4, i64 %arg_5, i64* %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath175 = hidden constant [52 x i8] c"mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0\00"
@gsxtmmath176 = hidden constant [57 x i8] c"{i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}**\00"
define dllexport fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0__3687(i8* %_impz,i8* %_impenv, float* %m1, float* %m2, float* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3688 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}***}*
%mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr_ = getelementptr {{i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}***}, {{i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr = load {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}***, {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}**** %mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr_

; setup arguments
%m1Ptr = alloca float*
store float* %m1, float** %m1Ptr
%m2Ptr = alloca float*
store float* %m2, float** %m2Ptr
%resultPtr = alloca float*
store float* %result, float** %resultPtr


%tzone3692 = load i8*, i8** %_impzPtr
%zone3693 = bitcast i8* %tzone3692 to %mzone*

; let assign value to symbol row1
%row1Ptr = alloca <4 x float>*
%tzone3697 = load i8*, i8** %_impzPtr
%zone3698 = bitcast i8* %tzone3697 to %mzone*

; let assign value to symbol row2
%row2Ptr = alloca <4 x float>*
%tzone3702 = load i8*, i8** %_impzPtr
%zone3703 = bitcast i8* %tzone3702 to %mzone*

; let assign value to symbol row3
%row3Ptr = alloca <4 x float>*
%tzone3707 = load i8*, i8** %_impzPtr
%zone3708 = bitcast i8* %tzone3707 to %mzone*

; let assign value to symbol row4
%row4Ptr = alloca <4 x float>*
%tzone3711 = load i8*, i8** %_impzPtr
%zone3712 = bitcast i8* %tzone3711 to %mzone*

; let assign value to symbol out
%outPtr = alloca <4 x float>*
%tzone3714 = load i8*, i8** %_impzPtr
%zone3715 = bitcast i8* %tzone3714 to %mzone*

; let assign value to symbol tmp
%tmpPtr = alloca <4 x float>*
%tzone3716 = load i8*, i8** %_impzPtr
%zone3717 = bitcast i8* %tzone3716 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val3689 = load float*, float** %m2Ptr
; pointer ref
%val3690 = getelementptr float, float* %val3689, i64 0
%val3691 = bitcast float* %val3690 to <4 x float>*

; let value assignment
%row1 = select i1 true, <4 x float>* %val3691, <4 x float>* %val3691
store <4 x float>* %row1, <4 x float>** %row1Ptr

%val3694 = load float*, float** %m2Ptr
; pointer ref
%val3695 = getelementptr float, float* %val3694, i64 4
%val3696 = bitcast float* %val3695 to <4 x float>*

; let value assignment
%row2 = select i1 true, <4 x float>* %val3696, <4 x float>* %val3696
store <4 x float>* %row2, <4 x float>** %row2Ptr

%val3699 = load float*, float** %m2Ptr
; pointer ref
%val3700 = getelementptr float, float* %val3699, i64 8
%val3701 = bitcast float* %val3700 to <4 x float>*

; let value assignment
%row3 = select i1 true, <4 x float>* %val3701, <4 x float>* %val3701
store <4 x float>* %row3, <4 x float>** %row3Ptr

%val3704 = load float*, float** %m2Ptr
; pointer ref
%val3705 = getelementptr float, float* %val3704, i64 12
%val3706 = bitcast float* %val3705 to <4 x float>*

; let value assignment
%row4 = select i1 true, <4 x float>* %val3706, <4 x float>* %val3706
store <4 x float>* %row4, <4 x float>** %row4Ptr

%val3709 = load float*, float** %resultPtr
%val3710 = bitcast float* %val3709 to <4 x float>*

; let value assignment
%out = select i1 true, <4 x float>* %val3710, <4 x float>* %val3710
store <4 x float>* %out, <4 x float>** %outPtr

%null3713 = bitcast i8* null to <4 x float>*

; let value assignment
%tmp = select i1 true, <4 x float>* %null3713, <4 x float>* %null3713
store <4 x float>* %tmp, <4 x float>** %tmpPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
store i64 0, i64* %iPtr
%val3774 = load i64, i64* %iPtr
%num3775 = add i64 4, %val3774
%comp3776 = icmp ult i64 4, 1
br i1 %comp3776, label %after3718, label %loop3718

loop3718:
; do set!
%val3719 = load i64, i64* %iPtr
%val3720 = mul i64 4, %val3719
%val3721 = load float*, float** %m1Ptr
; pointer ref
%val3722 = getelementptr float, float* %val3721, i64 %val3720
%val3723 = bitcast float* %val3722 to <4 x float>*
store <4 x float>* %val3723, <4 x float>** %tmpPtr
%tzone3729 = load i8*, i8** %_impzPtr
%zone3730 = bitcast i8* %tzone3729 to %mzone*

; let assign value to symbol a
%aPtr = alloca <4 x float>
%tzone3736 = load i8*, i8** %_impzPtr
%zone3737 = bitcast i8* %tzone3736 to %mzone*

; let assign value to symbol b
%bPtr = alloca <4 x float>
%tzone3743 = load i8*, i8** %_impzPtr
%zone3744 = bitcast i8* %tzone3743 to %mzone*

; let assign value to symbol c
%cPtr = alloca <4 x float>
%tzone3750 = load i8*, i8** %_impzPtr
%zone3751 = bitcast i8* %tzone3750 to %mzone*

; let assign value to symbol d
%dPtr = alloca <4 x float>
; shuffle vector
%val3725 = load <4 x float>*, <4 x float>** %tmpPtr
%null3726 = bitcast i8* null to i8*
%val3727 = load <4 x float>, <4 x float>* %val3725
%vect3728 = shufflevector <4 x float> %val3727, <4 x float> undef, <4 x i32> <i32 0, i32 0, i32 0, i32 0>
; let value assignment
%a = select i1 true, <4 x float> %vect3728, <4 x float> %vect3728
store <4 x float> %a, <4 x float>* %aPtr

; shuffle vector
%val3732 = load <4 x float>*, <4 x float>** %tmpPtr
%null3733 = bitcast i8* null to i8*
%val3734 = load <4 x float>, <4 x float>* %val3732
%vect3735 = shufflevector <4 x float> %val3734, <4 x float> undef, <4 x i32> <i32 1, i32 1, i32 1, i32 1>
; let value assignment
%b = select i1 true, <4 x float> %vect3735, <4 x float> %vect3735
store <4 x float> %b, <4 x float>* %bPtr

; shuffle vector
%val3739 = load <4 x float>*, <4 x float>** %tmpPtr
%null3740 = bitcast i8* null to i8*
%val3741 = load <4 x float>, <4 x float>* %val3739
%vect3742 = shufflevector <4 x float> %val3741, <4 x float> undef, <4 x i32> <i32 2, i32 2, i32 2, i32 2>
; let value assignment
%c = select i1 true, <4 x float> %vect3742, <4 x float> %vect3742
store <4 x float> %c, <4 x float>* %cPtr

; shuffle vector
%val3746 = load <4 x float>*, <4 x float>** %tmpPtr
%null3747 = bitcast i8* null to i8*
%val3748 = load <4 x float>, <4 x float>* %val3746
%vect3749 = shufflevector <4 x float> %val3748, <4 x float> undef, <4 x i32> <i32 3, i32 3, i32 3, i32 3>
; let value assignment
%d = select i1 true, <4 x float> %vect3749, <4 x float> %vect3749
store <4 x float> %d, <4 x float>* %dPtr

%val3752 = load i64, i64* %iPtr
%val3753 = load <4 x float>*, <4 x float>** %outPtr
%val3754 = load <4 x float>, <4 x float>* %aPtr
%val3755 = load <4 x float>*, <4 x float>** %row1Ptr
%val3756 = load <4 x float>, <4 x float>* %val3755
%val3757 = fmul <4 x float> %val3754, %val3756
%val3758 = load <4 x float>, <4 x float>* %bPtr
%val3759 = load <4 x float>*, <4 x float>** %row2Ptr
%val3760 = load <4 x float>, <4 x float>* %val3759
%val3761 = fmul <4 x float> %val3758, %val3760
%val3762 = fadd <4 x float> %val3757, %val3761
%val3763 = load <4 x float>, <4 x float>* %cPtr
%val3764 = load <4 x float>*, <4 x float>** %row3Ptr
%val3765 = load <4 x float>, <4 x float>* %val3764
%val3766 = fmul <4 x float> %val3763, %val3765
%val3767 = load <4 x float>, <4 x float>* %dPtr
%val3768 = load <4 x float>*, <4 x float>** %row4Ptr
%val3769 = load <4 x float>, <4 x float>* %val3768
%val3770 = fmul <4 x float> %val3767, %val3769
%val3771 = fadd <4 x float> %val3766, %val3770
%val3772 = fadd <4 x float> %val3762, %val3771
; set pointer
%val3773 = getelementptr <4 x float>, <4 x float>* %val3753, i64 %val3752
store <4 x float> %val3772, <4 x float>* %val3773
%loop_cnt3718 = load i64, i64* %iPtr
%next3718 = add i64 %loop_cnt3718, 1
store i64 %next3718, i64* %iPtr
%cmp3718 = icmp ult i64 %next3718, %num3775
br i1 %cmp3718, label %loop3718, label %after3718

after3718:
%val3778 = load float*, float** %resultPtr
ret float* %val3778
}
@gsxtmmath177 = hidden constant [105 x i8] c"mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}** @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3798 = load i8*, i8** %_impzPtr
%zone3799 = bitcast i8* %tzone3798 to %mzone*

; let assign value to symbol mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0
%dat_mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone3799, i64 8)
%mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr = bitcast i8* %dat_mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 to { i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}***
%tzone3779 = load i8*, i8** %_impzPtr
%zone3780 = bitcast i8* %tzone3779 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3780)
; malloc closure structure
%clsptr3781 = call i8* @llvm_zone_malloc(%mzone* %zone3780, i64 24)
%closure3782 = bitcast i8* %clsptr3781 to { i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}*

; malloc environment structure
%envptr3783 = call i8* @llvm_zone_malloc(%mzone* %zone3780, i64 8)
%environment3784 = bitcast i8* %envptr3783 to {{i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}***}*

; malloc closure address table
%addytable3785 = call %clsvar* @new_address_table()
%var3786 = bitcast [52 x i8]* @gsxtmmath175 to i8*
%var3787 = bitcast [57 x i8]* @gsxtmmath176 to i8*
%addytable3788 = call %clsvar* @add_address_table(%mzone* %zone3780, i8* %var3786, i32 0, i8* %var3787, i32 3, %clsvar* %addytable3785)
%address-table3789 = bitcast %clsvar* %addytable3788 to i8*

; insert table, function and environment into closure struct
%closure.table3792 = getelementptr { i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}, { i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}* %closure3782, i32 0, i32 0
store i8* %address-table3789, i8** %closure.table3792
%closure.env3793 = getelementptr { i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}, { i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}* %closure3782, i32 0, i32 1
store i8* %envptr3783, i8** %closure.env3793
%closure.func3794 = getelementptr { i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}, { i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}* %closure3782, i32 0, i32 2
store float* (i8*, i8*, float*, float*, float*)* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0__3687, float* (i8*, i8*, float*, float*, float*)** %closure.func3794
%closure_size3795 = call i64 @llvm_zone_mark_size(%mzone* %zone3780)
call void @llvm_zone_ptr_set_size(i8* %clsptr3781, i64 %closure_size3795)
%wrapper_ptr3796 = call i8* @llvm_zone_malloc(%mzone* %zone3780, i64 8)
%closure_wrapper3797 = bitcast i8* %wrapper_ptr3796 to { i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}**
store { i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}* %closure3782, { i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}** %closure_wrapper3797

; let value assignment
%mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 = select i1 true, { i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}** %closure_wrapper3797, { i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}** %closure_wrapper3797
store { i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}** %mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0, { i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}*** %mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr

; add data to environment
; don't need to alloc for env var mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0
%tmp_envptr3791 = getelementptr {{i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}***}, {{i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}***}* %environment3784, i32 0, i32 0
store {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}*** %mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr, {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}**** %tmp_envptr3791


%val3800 = load {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}**, {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}*** %mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr
ret {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}** %val3800
}


@mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}** @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %arg_0,float* %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  float* (i8*, i8*, float*, float*, float*)*,  float* (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
ret float* %result
}


define dllexport ccc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_native(float* %arg_0,float* %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  float* (i8*, i8*, float*, float*, float*)*,  float* (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
ret float* %result
}


define dllexport ccc i8*  @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3801 = bitcast [105 x i8]* @gsxtmmath177 to i8*
call i32 (i8*, ...) @printf(i8* %var3801)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3802 = bitcast [105 x i8]* @gsxtmmath177 to i8*
call i32 (i8*, ...) @printf(i8* %var3802)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3803 = bitcast [105 x i8]* @gsxtmmath177 to i8*
call i32 (i8*, ...) @printf(i8* %var3803)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  float* (i8*, i8*, float*, float*, float*)*,  float* (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
%tmpres = bitcast float* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, float*}*
%arg_p_0 = getelementptr {float*, float*, float*}, {float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, float*}, {float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, float*}, {float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  float* (i8*, i8*, float*, float*, float*)*,  float* (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath178 = hidden constant [54 x i8] c"mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd\00"
@gsxtmmath179 = hidden constant [59 x i8] c"{i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}**\00"
define dllexport fastcc float* @mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd__3804(i8* %_impz,i8* %_impenv, float* %m1, i64 %nrows, i64 %ncols, float* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3805 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}***}*
%mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpdPtr_ = getelementptr {{i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}***}, {{i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}***}* %impenv, i32 0, i32 0
%mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpdPtr = load {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}***, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}**** %mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpdPtr_

; setup arguments
%m1Ptr = alloca float*
store float* %m1, float** %m1Ptr
%nrowsPtr = alloca i64
store i64 %nrows, i64* %nrowsPtr
%ncolsPtr = alloca i64
store i64 %ncols, i64* %ncolsPtr
%resultPtr = alloca float*
store float* %result, float** %resultPtr


%tzone3806 = load i8*, i8** %_impzPtr
%zone3807 = bitcast i8* %tzone3806 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%tzone3808 = load i8*, i8** %_impzPtr
%zone3809 = bitcast i8* %tzone3808 to %mzone*

; let assign value to symbol j
%jPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr


; let value assignment
%j = select i1 true, i64 0, i64 0
store i64 %j, i64* %jPtr

; setup loop
%val3812 = load i64, i64* %nrowsPtr
store i64 0, i64* %iPtr
%val3835 = load i64, i64* %iPtr
%num3836 = add i64 %val3812, %val3835
%comp3837 = icmp ult i64 %val3812, 1
br i1 %comp3837, label %after3810, label %loop3810

loop3810:
; setup loop
%val3815 = load i64, i64* %ncolsPtr
store i64 0, i64* %jPtr
%val3831 = load i64, i64* %jPtr
%num3832 = add i64 %val3815, %val3831
%comp3833 = icmp ult i64 %val3815, 1
br i1 %comp3833, label %after3813, label %loop3813

loop3813:
%val3816 = load i64, i64* %jPtr
%val3817 = load i64, i64* %ncolsPtr
%val3818 = mul i64 %val3816, %val3817
%val3819 = load i64, i64* %iPtr
%val3820 = add i64 %val3818, %val3819
%val3821 = load float*, float** %resultPtr
%val3822 = load i64, i64* %iPtr
%val3823 = load i64, i64* %ncolsPtr
%val3824 = mul i64 %val3822, %val3823
%val3825 = load i64, i64* %jPtr
%val3826 = add i64 %val3824, %val3825
%val3827 = load float*, float** %m1Ptr
; pointer ref
%val3828 = getelementptr float, float* %val3827, i64 %val3826
%val3829 = load float, float* %val3828
; set pointer
%val3830 = getelementptr float, float* %val3821, i64 %val3820
store float %val3829, float* %val3830
%loop_cnt3813 = load i64, i64* %jPtr
%next3813 = add i64 %loop_cnt3813, 1
store i64 %next3813, i64* %jPtr
%cmp3813 = icmp ult i64 %next3813, %num3832
br i1 %cmp3813, label %loop3813, label %after3813

after3813:
%loop_cnt3810 = load i64, i64* %iPtr
%next3810 = add i64 %loop_cnt3810, 1
store i64 %next3810, i64* %iPtr
%cmp3810 = icmp ult i64 %next3810, %num3836
br i1 %cmp3810, label %loop3810, label %after3810

after3810:
%val3839 = load float*, float** %resultPtr
ret float* %val3839
}
@gsxtmmath180 = hidden constant [107 x i8] c"mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}** @mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3859 = load i8*, i8** %_impzPtr
%zone3860 = bitcast i8* %tzone3859 to %mzone*

; let assign value to symbol mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd
%dat_mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd = call i8* @llvm_zone_malloc(%mzone* %zone3860, i64 8)
%mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpdPtr = bitcast i8* %dat_mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd to { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}***
%tzone3840 = load i8*, i8** %_impzPtr
%zone3841 = bitcast i8* %tzone3840 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3841)
; malloc closure structure
%clsptr3842 = call i8* @llvm_zone_malloc(%mzone* %zone3841, i64 24)
%closure3843 = bitcast i8* %clsptr3842 to { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}*

; malloc environment structure
%envptr3844 = call i8* @llvm_zone_malloc(%mzone* %zone3841, i64 8)
%environment3845 = bitcast i8* %envptr3844 to {{i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}***}*

; malloc closure address table
%addytable3846 = call %clsvar* @new_address_table()
%var3847 = bitcast [54 x i8]* @gsxtmmath178 to i8*
%var3848 = bitcast [59 x i8]* @gsxtmmath179 to i8*
%addytable3849 = call %clsvar* @add_address_table(%mzone* %zone3841, i8* %var3847, i32 0, i8* %var3848, i32 3, %clsvar* %addytable3846)
%address-table3850 = bitcast %clsvar* %addytable3849 to i8*

; insert table, function and environment into closure struct
%closure.table3853 = getelementptr { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}, { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}* %closure3843, i32 0, i32 0
store i8* %address-table3850, i8** %closure.table3853
%closure.env3854 = getelementptr { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}, { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}* %closure3843, i32 0, i32 1
store i8* %envptr3844, i8** %closure.env3854
%closure.func3855 = getelementptr { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}, { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}* %closure3843, i32 0, i32 2
store float* (i8*, i8*, float*, i64, i64, float*)* @mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd__3804, float* (i8*, i8*, float*, i64, i64, float*)** %closure.func3855
%closure_size3856 = call i64 @llvm_zone_mark_size(%mzone* %zone3841)
call void @llvm_zone_ptr_set_size(i8* %clsptr3842, i64 %closure_size3856)
%wrapper_ptr3857 = call i8* @llvm_zone_malloc(%mzone* %zone3841, i64 8)
%closure_wrapper3858 = bitcast i8* %wrapper_ptr3857 to { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}**
store { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}* %closure3843, { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}** %closure_wrapper3858

; let value assignment
%mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd = select i1 true, { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}** %closure_wrapper3858, { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}** %closure_wrapper3858
store { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}** %mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd, { i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}*** %mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpdPtr

; add data to environment
; don't need to alloc for env var mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd
%tmp_envptr3852 = getelementptr {{i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}***}, {{i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}***}* %environment3845, i32 0, i32 0
store {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}*** %mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpdPtr, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}**** %tmp_envptr3852


%val3861 = load {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}**, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}*** %mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpdPtr
ret {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}** %val3861
}


@mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}** @mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float* @mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd(float* %arg_0,i64 %arg_1,i64 %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}**
%closure = load {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}*, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  float* (i8*, i8*, float*, i64, i64, float*)*,  float* (i8*, i8*, float*, i64, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2, float* %arg_3)
ret float* %result
}


define dllexport ccc float* @mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd_native(float* %arg_0,i64 %arg_1,i64 %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}**
%closure = load {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}*, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  float* (i8*, i8*, float*, i64, i64, float*)*,  float* (i8*, i8*, float*, i64, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2, float* %arg_3)
ret float* %result
}


define dllexport ccc i8*  @mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3862 = bitcast [107 x i8]* @gsxtmmath180 to i8*
call i32 (i8*, ...) @printf(i8* %var3862)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3863 = bitcast [107 x i8]* @gsxtmmath180 to i8*
call i32 (i8*, ...) @printf(i8* %var3863)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3864 = bitcast [107 x i8]* @gsxtmmath180 to i8*
call i32 (i8*, ...) @printf(i8* %var3864)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var3865 = bitcast [107 x i8]* @gsxtmmath180 to i8*
call i32 (i8*, ...) @printf(i8* %var3865)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}**
%closure = load {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}*, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  float* (i8*, i8*, float*, i64, i64, float*)*,  float* (i8*, i8*, float*, i64, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2, float* %arg_3)
%tmpres = bitcast float* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64, i64, float*}*
%arg_p_0 = getelementptr {float*, i64, i64, float*}, {float*, i64, i64, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64, i64, float*}, {float*, i64, i64, float*}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {float*, i64, i64, float*}, {float*, i64, i64, float*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {float*, i64, i64, float*}, {float*, i64, i64, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}**
%closure = load {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}*, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, i64, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  float* (i8*, i8*, float*, i64, i64, float*)*,  float* (i8*, i8*, float*, i64, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2, float* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath181 = hidden constant [62 x i8] c"mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd\00"
@gsxtmmath182 = hidden constant [62 x i8] c"{i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}**\00"
define dllexport fastcc double* @mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd__3866(i8* %_impz,i8* %_impenv, double* %m1, i64 %nrows, i64 %ncols, double* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3867 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}***}*
%mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpdPtr_ = getelementptr {{i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}***}, {{i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}***}* %impenv, i32 0, i32 0
%mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpdPtr = load {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}***, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}**** %mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpdPtr_

; setup arguments
%m1Ptr = alloca double*
store double* %m1, double** %m1Ptr
%nrowsPtr = alloca i64
store i64 %nrows, i64* %nrowsPtr
%ncolsPtr = alloca i64
store i64 %ncols, i64* %ncolsPtr
%resultPtr = alloca double*
store double* %result, double** %resultPtr


%tzone3868 = load i8*, i8** %_impzPtr
%zone3869 = bitcast i8* %tzone3868 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%tzone3870 = load i8*, i8** %_impzPtr
%zone3871 = bitcast i8* %tzone3870 to %mzone*

; let assign value to symbol j
%jPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr


; let value assignment
%j = select i1 true, i64 0, i64 0
store i64 %j, i64* %jPtr

; setup loop
%val3874 = load i64, i64* %nrowsPtr
store i64 0, i64* %iPtr
%val3897 = load i64, i64* %iPtr
%num3898 = add i64 %val3874, %val3897
%comp3899 = icmp ult i64 %val3874, 1
br i1 %comp3899, label %after3872, label %loop3872

loop3872:
; setup loop
%val3877 = load i64, i64* %ncolsPtr
store i64 0, i64* %jPtr
%val3893 = load i64, i64* %jPtr
%num3894 = add i64 %val3877, %val3893
%comp3895 = icmp ult i64 %val3877, 1
br i1 %comp3895, label %after3875, label %loop3875

loop3875:
%val3878 = load i64, i64* %jPtr
%val3879 = load i64, i64* %ncolsPtr
%val3880 = mul i64 %val3878, %val3879
%val3881 = load i64, i64* %iPtr
%val3882 = add i64 %val3880, %val3881
%val3883 = load double*, double** %resultPtr
%val3884 = load i64, i64* %iPtr
%val3885 = load i64, i64* %ncolsPtr
%val3886 = mul i64 %val3884, %val3885
%val3887 = load i64, i64* %jPtr
%val3888 = add i64 %val3886, %val3887
%val3889 = load double*, double** %m1Ptr
; pointer ref
%val3890 = getelementptr double, double* %val3889, i64 %val3888
%val3891 = load double, double* %val3890
; set pointer
%val3892 = getelementptr double, double* %val3883, i64 %val3882
store double %val3891, double* %val3892
%loop_cnt3875 = load i64, i64* %jPtr
%next3875 = add i64 %loop_cnt3875, 1
store i64 %next3875, i64* %jPtr
%cmp3875 = icmp ult i64 %next3875, %num3894
br i1 %cmp3875, label %loop3875, label %after3875

after3875:
%loop_cnt3872 = load i64, i64* %iPtr
%next3872 = add i64 %loop_cnt3872, 1
store i64 %next3872, i64* %iPtr
%cmp3872 = icmp ult i64 %next3872, %num3898
br i1 %cmp3872, label %loop3872, label %after3872

after3872:
%val3901 = load double*, double** %resultPtr
ret double* %val3901
}
@gsxtmmath183 = hidden constant [115 x i8] c"mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}** @mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3921 = load i8*, i8** %_impzPtr
%zone3922 = bitcast i8* %tzone3921 to %mzone*

; let assign value to symbol mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd
%dat_mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd = call i8* @llvm_zone_malloc(%mzone* %zone3922, i64 8)
%mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpdPtr = bitcast i8* %dat_mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd to { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}***
%tzone3902 = load i8*, i8** %_impzPtr
%zone3903 = bitcast i8* %tzone3902 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3903)
; malloc closure structure
%clsptr3904 = call i8* @llvm_zone_malloc(%mzone* %zone3903, i64 24)
%closure3905 = bitcast i8* %clsptr3904 to { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}*

; malloc environment structure
%envptr3906 = call i8* @llvm_zone_malloc(%mzone* %zone3903, i64 8)
%environment3907 = bitcast i8* %envptr3906 to {{i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}***}*

; malloc closure address table
%addytable3908 = call %clsvar* @new_address_table()
%var3909 = bitcast [62 x i8]* @gsxtmmath181 to i8*
%var3910 = bitcast [62 x i8]* @gsxtmmath182 to i8*
%addytable3911 = call %clsvar* @add_address_table(%mzone* %zone3903, i8* %var3909, i32 0, i8* %var3910, i32 3, %clsvar* %addytable3908)
%address-table3912 = bitcast %clsvar* %addytable3911 to i8*

; insert table, function and environment into closure struct
%closure.table3915 = getelementptr { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}, { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}* %closure3905, i32 0, i32 0
store i8* %address-table3912, i8** %closure.table3915
%closure.env3916 = getelementptr { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}, { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}* %closure3905, i32 0, i32 1
store i8* %envptr3906, i8** %closure.env3916
%closure.func3917 = getelementptr { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}, { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}* %closure3905, i32 0, i32 2
store double* (i8*, i8*, double*, i64, i64, double*)* @mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd__3866, double* (i8*, i8*, double*, i64, i64, double*)** %closure.func3917
%closure_size3918 = call i64 @llvm_zone_mark_size(%mzone* %zone3903)
call void @llvm_zone_ptr_set_size(i8* %clsptr3904, i64 %closure_size3918)
%wrapper_ptr3919 = call i8* @llvm_zone_malloc(%mzone* %zone3903, i64 8)
%closure_wrapper3920 = bitcast i8* %wrapper_ptr3919 to { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}**
store { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}* %closure3905, { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}** %closure_wrapper3920

; let value assignment
%mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd = select i1 true, { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}** %closure_wrapper3920, { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}** %closure_wrapper3920
store { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}** %mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd, { i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}*** %mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpdPtr

; add data to environment
; don't need to alloc for env var mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd
%tmp_envptr3914 = getelementptr {{i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}***}, {{i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}***}* %environment3907, i32 0, i32 0
store {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}*** %mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpdPtr, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}**** %tmp_envptr3914


%val3923 = load {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}**, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}*** %mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpdPtr
ret {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}** %val3923
}


@mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}** @mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double* @mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd(double* %arg_0,i64 %arg_1,i64 %arg_2,double* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}**
%closure = load {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}*, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  double* (i8*, i8*, double*, i64, i64, double*)*,  double* (i8*, i8*, double*, i64, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double* %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2, double* %arg_3)
ret double* %result
}


define dllexport ccc double* @mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_native(double* %arg_0,i64 %arg_1,i64 %arg_2,double* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}**
%closure = load {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}*, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  double* (i8*, i8*, double*, i64, i64, double*)*,  double* (i8*, i8*, double*, i64, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double* %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2, double* %arg_3)
ret double* %result
}


define dllexport ccc i8*  @mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3924 = bitcast [115 x i8]* @gsxtmmath183 to i8*
call i32 (i8*, ...) @printf(i8* %var3924)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3925 = bitcast [115 x i8]* @gsxtmmath183 to i8*
call i32 (i8*, ...) @printf(i8* %var3925)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3926 = bitcast [115 x i8]* @gsxtmmath183 to i8*
call i32 (i8*, ...) @printf(i8* %var3926)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var3927 = bitcast [115 x i8]* @gsxtmmath183 to i8*
call i32 (i8*, ...) @printf(i8* %var3927)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to double*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}**
%closure = load {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}*, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  double* (i8*, i8*, double*, i64, i64, double*)*,  double* (i8*, i8*, double*, i64, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double* %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2, double* %arg_3)
%tmpres = bitcast double* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, i64, i64, double*}*
%arg_p_0 = getelementptr {double*, i64, i64, double*}, {double*, i64, i64, double*}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, i64, i64, double*}, {double*, i64, i64, double*}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {double*, i64, i64, double*}, {double*, i64, i64, double*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {double*, i64, i64, double*}, {double*, i64, i64, double*}* %fstruct, i32 0, i32 3
%arg_3 = load double*, double** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mtranspose_adhoc_W2RvdWJsZSosZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}**
%closure = load {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}*, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, i64, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  double* (i8*, i8*, double*, i64, i64, double*)*,  double* (i8*, i8*, double*, i64, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double* %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2, double* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath184 = hidden constant [44 x i8] c"mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd\00"
define dllexport fastcc float @mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd__3928(i8* %_impz,i8* %_impenv, float* %m1, i64 %nrows) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3929 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}*
%mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 0
%mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr = load {i8*, i8*, float (i8*, i8*, float*, i64)*}***, {i8*, i8*, float (i8*, i8*, float*, i64)*}**** %mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr_

; setup arguments
%m1Ptr = alloca float*
store float* %m1, float** %m1Ptr
%nrowsPtr = alloca i64
store i64 %nrows, i64* %nrowsPtr


%val3931 = load i64, i64* %nrowsPtr
%cmp3932 = icmp eq i64 %val3931, 1
br i1 %cmp3932, label %then3930, label %else3930

then3930:
%val3933 = load float*, float** %m1Ptr
; pointer ref
%val3934 = getelementptr float, float* %val3933, i64 0
%val3935 = load float, float* %val3934
ret float %val3935

else3930:
%tzone3936 = load i8*, i8** %_impzPtr
%zone3937 = bitcast i8* %tzone3936 to %mzone*

; let assign value to symbol det
%detPtr = alloca float
%tzone3938 = load i8*, i8** %_impzPtr
%zone3939 = bitcast i8* %tzone3938 to %mzone*

; let assign value to symbol s
%sPtr = alloca float
%tzone3940 = load i8*, i8** %_impzPtr
%zone3941 = bitcast i8* %tzone3940 to %mzone*

; let assign value to symbol c
%cPtr = alloca i64
%tzone3942 = load i8*, i8** %_impzPtr
%zone3943 = bitcast i8* %tzone3942 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%tzone3944 = load i8*, i8** %_impzPtr
%zone3945 = bitcast i8* %tzone3944 to %mzone*

; let assign value to symbol j
%jPtr = alloca i64
%tzone3946 = load i8*, i8** %_impzPtr
%zone3947 = bitcast i8* %tzone3946 to %mzone*

; let assign value to symbol m
%mPtr = alloca i64
%tzone3948 = load i8*, i8** %_impzPtr
%zone3949 = bitcast i8* %tzone3948 to %mzone*

; let assign value to symbol n
%nPtr = alloca i64
%tzone3954 = load i8*, i8** %_impzPtr
%zone3955 = bitcast i8* %tzone3954 to %mzone*

; let assign value to symbol mb
%mbPtr = alloca float*

; let value assignment
%det = select i1 true, float 0x0, float 0x0
store float %det, float* %detPtr


; let value assignment
%s = select i1 true, float 0x3ff0000000000000, float 0x3ff0000000000000
store float %s, float* %sPtr


; let value assignment
%c = select i1 true, i64 0, i64 0
store i64 %c, i64* %cPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr


; let value assignment
%j = select i1 true, i64 0, i64 0
store i64 %j, i64* %jPtr


; let value assignment
%m = select i1 true, i64 0, i64 0
store i64 %m, i64* %mPtr


; let value assignment
%n = select i1 true, i64 0, i64 0
store i64 %n, i64* %nPtr

%val3950 = load i64, i64* %nrowsPtr
%val3951 = load i64, i64* %nrowsPtr
%val3952 = mul i64 %val3950, %val3951
%dat3953 = alloca float, i64 %val3952, align 16

; let value assignment
%mb = select i1 true, float* %dat3953, float* %dat3953
store float* %mb, float** %mbPtr

; promote local stack var allocations
%tzone4051 = load i8*, i8** %_impzPtr
%zone4052 = bitcast i8* %tzone4051 to %mzone*
%ifptr3972 = alloca i64
%ifptr4003 = alloca i64
%ifptr3973 = alloca i1
%ifptr3976 = alloca i1
; setup loop
%val3958 = load i64, i64* %nrowsPtr
store i64 0, i64* %cPtr
%val4046 = load i64, i64* %cPtr
%num4047 = add i64 %val3958, %val4046
%comp4048 = icmp ult i64 %val3958, 1
br i1 %comp4048, label %after3956, label %loop3956

loop3956:
; do set!
store i64 0, i64* %mPtr
; do set!
store i64 0, i64* %nPtr
; setup loop
%val3961 = load i64, i64* %nrowsPtr
store i64 0, i64* %iPtr
%val4018 = load i64, i64* %iPtr
%num4019 = add i64 %val3961, %val4018
%comp4020 = icmp ult i64 %val3961, 1
br i1 %comp4020, label %after3959, label %loop3959

loop3959:
; setup loop
%val3964 = load i64, i64* %nrowsPtr
store i64 0, i64* %jPtr
%val4014 = load i64, i64* %jPtr
%num4015 = add i64 %val3964, %val4014
%comp4016 = icmp ult i64 %val3964, 1
br i1 %comp4016, label %after3962, label %loop3962

loop3962:
%val3965 = load i64, i64* %iPtr
%val3966 = load i64, i64* %nrowsPtr
%val3967 = mul i64 %val3965, %val3966
%val3968 = load i64, i64* %jPtr
%val3969 = add i64 %val3967, %val3968
%val3970 = load float*, float** %mbPtr
; set pointer
%val3971 = getelementptr float, float* %val3970, i64 %val3969
store float 0x0, float* %val3971
%val3974 = load i64, i64* %iPtr
%cmp3975 = icmp ne i64 %val3974, 0
br i1 %cmp3975, label %then3973, label %else3973

then3973:
%val3977 = load i64, i64* %jPtr
%val3978 = load i64, i64* %cPtr
%cmp3979 = icmp ne i64 %val3977, %val3978
br i1 %cmp3979, label %then3976, label %else3976

then3976:
%val3980 = load i64, i64* %jPtr
%val3981 = load i64, i64* %cPtr
%cmp3982 = icmp ne i64 %val3980, %val3981
store i1 %cmp3982, i1* %ifptr3976
br label %ifcont3976

else3976:
%res3983 = call ccc i1 @impc_false()
store i1 %res3983, i1* %ifptr3976
br label %ifcont3976

ifcont3976:
%ifres3984 = load i1, i1* %ifptr3976

store i1 %ifres3984, i1* %ifptr3973
br label %ifcont3973

else3973:
%res3985 = call ccc i1 @impc_false()
store i1 %res3985, i1* %ifptr3973
br label %ifcont3973

ifcont3973:
%ifres3986 = load i1, i1* %ifptr3973

br i1 %ifres3986, label %then3972, label %else3972

then3972:
%val3987 = load i64, i64* %mPtr
%val3988 = load i64, i64* %nrowsPtr
%val3989 = sub i64 %val3988, 1
%val3990 = mul i64 %val3987, %val3989
%val3991 = load i64, i64* %nPtr
%val3992 = add i64 %val3990, %val3991
%val3993 = load float*, float** %mbPtr
%val3994 = load i64, i64* %iPtr
%val3995 = load i64, i64* %nrowsPtr
%val3996 = mul i64 %val3994, %val3995
%val3997 = load i64, i64* %jPtr
%val3998 = add i64 %val3996, %val3997
%val3999 = load float*, float** %m1Ptr
; pointer ref
%val4000 = getelementptr float, float* %val3999, i64 %val3998
%val4001 = load float, float* %val4000
; set pointer
%val4002 = getelementptr float, float* %val3993, i64 %val3992
store float %val4001, float* %val4002
%val4004 = load i64, i64* %nPtr
%val4005 = load i64, i64* %nrowsPtr
%val4006 = sub i64 %val4005, 2
%cmp4007 = icmp slt i64 %val4004, %val4006
br i1 %cmp4007, label %then4003, label %else4003

then4003:
; do set!
%val4008 = load i64, i64* %nPtr
%val4009 = add i64 %val4008, 1
store i64 %val4009, i64* %nPtr
store i64 %val4009, i64* %ifptr4003
br label %ifcont4003

else4003:
; do set!
store i64 0, i64* %nPtr
; do set!
%val4010 = load i64, i64* %mPtr
%val4011 = add i64 %val4010, 1
store i64 %val4011, i64* %mPtr
store i64 %val4011, i64* %ifptr4003
br label %ifcont4003

ifcont4003:
%ifres4012 = load i64, i64* %ifptr4003

store i64 %ifres4012, i64* %ifptr3972
br label %ifcont3972

else3972:
store i64 1, i64* %ifptr3972
br label %ifcont3972

ifcont3972:
%ifres4013 = load i64, i64* %ifptr3972

%loop_cnt3962 = load i64, i64* %jPtr
%next3962 = add i64 %loop_cnt3962, 1
store i64 %next3962, i64* %jPtr
%cmp3962 = icmp ult i64 %next3962, %num4015
br i1 %cmp3962, label %loop3962, label %after3962

after3962:
%loop_cnt3959 = load i64, i64* %iPtr
%next3959 = add i64 %loop_cnt3959, 1
store i64 %next3959, i64* %iPtr
%cmp3959 = icmp ult i64 %next3959, %num4019
br i1 %cmp3959, label %loop3959, label %after3959

after3959:
; do set!
%val4022 = load float, float* %detPtr
%val4023 = load float, float* %sPtr
%val4024 = load i64, i64* %cPtr
%val4025 = load float*, float** %m1Ptr
; pointer ref
%val4026 = getelementptr float, float* %val4025, i64 %val4024
%val4027 = load float, float* %val4026
%val4028 = load float*, float** %mbPtr
%val4029 = load i64, i64* %nrowsPtr
%val4030 = sub i64 %val4029, 1

; apply closure 
%vval4031 = load {i8*, i8*, float (i8*, i8*, float*, i64)*}**, {i8*, i8*, float (i8*, i8*, float*, i64)*}*** %mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr
%val4032 = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*,{i8*, i8*, float (i8*, i8*, float*, i64)*}** %vval4031
%fPtr4033 = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %val4032, i32 0, i32 2
%ePtr4034 = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %val4032, i32 0, i32 1
%f4035 = load float (i8*, i8*, float*, i64)*, float (i8*, i8*, float*, i64)** %fPtr4033
%e4036 = load i8*, i8** %ePtr4034
%tzone4037 = load i8*, i8** %_impzPtr
%zone4038 = bitcast i8* %tzone4037 to %mzone*
%z4039 = bitcast %mzone* %zone4038 to i8*
%result4040 = tail call fastcc float %f4035(i8* %z4039, i8* %e4036, float* %val4028, i64 %val4030)
%val4041 = fmul float %val4027, %result4040
%val4042 = fmul float %val4023, %val4041
%val4043 = fadd float %val4022, %val4042
store float %val4043, float* %detPtr
; do set!
%val4044 = load float, float* %sPtr
%val4045 = fmul float 0xbff0000000000000, %val4044
store float %val4045, float* %sPtr
%loop_cnt3956 = load i64, i64* %cPtr
%next3956 = add i64 %loop_cnt3956, 1
store i64 %next3956, i64* %cPtr
%cmp3956 = icmp ult i64 %next3956, %num4047
br i1 %cmp3956, label %loop3956, label %after3956

after3956:
%val4050 = load float, float* %detPtr
ret float %val4050
}
@gsxtmmath185 = hidden constant [97 x i8] c"mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, float*, i64)*}** @mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4072 = load i8*, i8** %_impzPtr
%zone4073 = bitcast i8* %tzone4072 to %mzone*

; let assign value to symbol mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd
%dat_mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone4073, i64 8)
%mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr = bitcast i8* %dat_mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd to { i8*, i8*, float (i8*, i8*, float*, i64)*}***
%tzone4053 = load i8*, i8** %_impzPtr
%zone4054 = bitcast i8* %tzone4053 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4054)
; malloc closure structure
%clsptr4055 = call i8* @llvm_zone_malloc(%mzone* %zone4054, i64 24)
%closure4056 = bitcast i8* %clsptr4055 to { i8*, i8*, float (i8*, i8*, float*, i64)*}*

; malloc environment structure
%envptr4057 = call i8* @llvm_zone_malloc(%mzone* %zone4054, i64 8)
%environment4058 = bitcast i8* %envptr4057 to {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}*

; malloc closure address table
%addytable4059 = call %clsvar* @new_address_table()
%var4060 = bitcast [44 x i8]* @gsxtmmath184 to i8*
%var4061 = bitcast [45 x i8]* @gsxtmmath7 to i8*
%addytable4062 = call %clsvar* @add_address_table(%mzone* %zone4054, i8* %var4060, i32 0, i8* %var4061, i32 3, %clsvar* %addytable4059)
%address-table4063 = bitcast %clsvar* %addytable4062 to i8*

; insert table, function and environment into closure struct
%closure.table4066 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure4056, i32 0, i32 0
store i8* %address-table4063, i8** %closure.table4066
%closure.env4067 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure4056, i32 0, i32 1
store i8* %envptr4057, i8** %closure.env4067
%closure.func4068 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure4056, i32 0, i32 2
store float (i8*, i8*, float*, i64)* @mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd__3928, float (i8*, i8*, float*, i64)** %closure.func4068
%closure_size4069 = call i64 @llvm_zone_mark_size(%mzone* %zone4054)
call void @llvm_zone_ptr_set_size(i8* %clsptr4055, i64 %closure_size4069)
%wrapper_ptr4070 = call i8* @llvm_zone_malloc(%mzone* %zone4054, i64 8)
%closure_wrapper4071 = bitcast i8* %wrapper_ptr4070 to { i8*, i8*, float (i8*, i8*, float*, i64)*}**
store { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure4056, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper4071

; let value assignment
%mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd = select i1 true, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper4071, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper4071
store { i8*, i8*, float (i8*, i8*, float*, i64)*}** %mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd, { i8*, i8*, float (i8*, i8*, float*, i64)*}*** %mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr

; add data to environment
; don't need to alloc for env var mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd
%tmp_envptr4065 = getelementptr {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}* %environment4058, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, float*, i64)*}*** %mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr, {i8*, i8*, float (i8*, i8*, float*, i64)*}**** %tmp_envptr4065


%val4074 = load {i8*, i8*, float (i8*, i8*, float*, i64)*}**, {i8*, i8*, float (i8*, i8*, float*, i64)*}*** %mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr
ret {i8*, i8*, float (i8*, i8*, float*, i64)*}** %val4074
}


@mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, float*, i64)*}** @mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret float %result
}


define dllexport ccc float @mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_native(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret float %result
}


define dllexport ccc i8*  @mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4075 = bitcast [97 x i8]* @gsxtmmath185 to i8*
call i32 (i8*, ...) @printf(i8* %var4075)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4076 = bitcast [97 x i8]* @gsxtmmath185 to i8*
call i32 (i8*, ...) @printf(i8* %var4076)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64}*
%arg_p_0 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath186 = hidden constant [47 x i8] c"mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0\00"
define dllexport fastcc double @mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0__4077(i8* %_impz,i8* %_impenv, double* %m1, i64 %nrows) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4078 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}*
%mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}* %impenv, i32 0, i32 0
%mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr = load {i8*, i8*, double (i8*, i8*, double*, i64)*}***, {i8*, i8*, double (i8*, i8*, double*, i64)*}**** %mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr_

; setup arguments
%m1Ptr = alloca double*
store double* %m1, double** %m1Ptr
%nrowsPtr = alloca i64
store i64 %nrows, i64* %nrowsPtr


%val4080 = load i64, i64* %nrowsPtr
%cmp4081 = icmp eq i64 %val4080, 1
br i1 %cmp4081, label %then4079, label %else4079

then4079:
%val4082 = load double*, double** %m1Ptr
; pointer ref
%val4083 = getelementptr double, double* %val4082, i64 0
%val4084 = load double, double* %val4083
ret double %val4084

else4079:
%tzone4085 = load i8*, i8** %_impzPtr
%zone4086 = bitcast i8* %tzone4085 to %mzone*

; let assign value to symbol det
%detPtr = alloca double
%tzone4087 = load i8*, i8** %_impzPtr
%zone4088 = bitcast i8* %tzone4087 to %mzone*

; let assign value to symbol s
%sPtr = alloca double
%tzone4089 = load i8*, i8** %_impzPtr
%zone4090 = bitcast i8* %tzone4089 to %mzone*

; let assign value to symbol c
%cPtr = alloca i64
%tzone4091 = load i8*, i8** %_impzPtr
%zone4092 = bitcast i8* %tzone4091 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%tzone4093 = load i8*, i8** %_impzPtr
%zone4094 = bitcast i8* %tzone4093 to %mzone*

; let assign value to symbol j
%jPtr = alloca i64
%tzone4095 = load i8*, i8** %_impzPtr
%zone4096 = bitcast i8* %tzone4095 to %mzone*

; let assign value to symbol m
%mPtr = alloca i64
%tzone4097 = load i8*, i8** %_impzPtr
%zone4098 = bitcast i8* %tzone4097 to %mzone*

; let assign value to symbol n
%nPtr = alloca i64
%tzone4103 = load i8*, i8** %_impzPtr
%zone4104 = bitcast i8* %tzone4103 to %mzone*

; let assign value to symbol mb
%mbPtr = alloca double*

; let value assignment
%det = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %det, double* %detPtr


; let value assignment
%s = select i1 true, double 1.0000000000000000000, double 1.0000000000000000000
store double %s, double* %sPtr


; let value assignment
%c = select i1 true, i64 0, i64 0
store i64 %c, i64* %cPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr


; let value assignment
%j = select i1 true, i64 0, i64 0
store i64 %j, i64* %jPtr


; let value assignment
%m = select i1 true, i64 0, i64 0
store i64 %m, i64* %mPtr


; let value assignment
%n = select i1 true, i64 0, i64 0
store i64 %n, i64* %nPtr

%val4099 = load i64, i64* %nrowsPtr
%val4100 = load i64, i64* %nrowsPtr
%val4101 = mul i64 %val4099, %val4100
%dat4102 = alloca double, i64 %val4101, align 16

; let value assignment
%mb = select i1 true, double* %dat4102, double* %dat4102
store double* %mb, double** %mbPtr

; promote local stack var allocations
%tzone4200 = load i8*, i8** %_impzPtr
%zone4201 = bitcast i8* %tzone4200 to %mzone*
%ifptr4121 = alloca i64
%ifptr4152 = alloca i64
%ifptr4122 = alloca i1
%ifptr4125 = alloca i1
; setup loop
%val4107 = load i64, i64* %nrowsPtr
store i64 0, i64* %cPtr
%val4195 = load i64, i64* %cPtr
%num4196 = add i64 %val4107, %val4195
%comp4197 = icmp ult i64 %val4107, 1
br i1 %comp4197, label %after4105, label %loop4105

loop4105:
; do set!
store i64 0, i64* %mPtr
; do set!
store i64 0, i64* %nPtr
; setup loop
%val4110 = load i64, i64* %nrowsPtr
store i64 0, i64* %iPtr
%val4167 = load i64, i64* %iPtr
%num4168 = add i64 %val4110, %val4167
%comp4169 = icmp ult i64 %val4110, 1
br i1 %comp4169, label %after4108, label %loop4108

loop4108:
; setup loop
%val4113 = load i64, i64* %nrowsPtr
store i64 0, i64* %jPtr
%val4163 = load i64, i64* %jPtr
%num4164 = add i64 %val4113, %val4163
%comp4165 = icmp ult i64 %val4113, 1
br i1 %comp4165, label %after4111, label %loop4111

loop4111:
%val4114 = load i64, i64* %iPtr
%val4115 = load i64, i64* %nrowsPtr
%val4116 = mul i64 %val4114, %val4115
%val4117 = load i64, i64* %jPtr
%val4118 = add i64 %val4116, %val4117
%val4119 = load double*, double** %mbPtr
; set pointer
%val4120 = getelementptr double, double* %val4119, i64 %val4118
store double 0.00000000000000000000, double* %val4120
%val4123 = load i64, i64* %iPtr
%cmp4124 = icmp ne i64 %val4123, 0
br i1 %cmp4124, label %then4122, label %else4122

then4122:
%val4126 = load i64, i64* %jPtr
%val4127 = load i64, i64* %cPtr
%cmp4128 = icmp ne i64 %val4126, %val4127
br i1 %cmp4128, label %then4125, label %else4125

then4125:
%val4129 = load i64, i64* %jPtr
%val4130 = load i64, i64* %cPtr
%cmp4131 = icmp ne i64 %val4129, %val4130
store i1 %cmp4131, i1* %ifptr4125
br label %ifcont4125

else4125:
%res4132 = call ccc i1 @impc_false()
store i1 %res4132, i1* %ifptr4125
br label %ifcont4125

ifcont4125:
%ifres4133 = load i1, i1* %ifptr4125

store i1 %ifres4133, i1* %ifptr4122
br label %ifcont4122

else4122:
%res4134 = call ccc i1 @impc_false()
store i1 %res4134, i1* %ifptr4122
br label %ifcont4122

ifcont4122:
%ifres4135 = load i1, i1* %ifptr4122

br i1 %ifres4135, label %then4121, label %else4121

then4121:
%val4136 = load i64, i64* %mPtr
%val4137 = load i64, i64* %nrowsPtr
%val4138 = sub i64 %val4137, 1
%val4139 = mul i64 %val4136, %val4138
%val4140 = load i64, i64* %nPtr
%val4141 = add i64 %val4139, %val4140
%val4142 = load double*, double** %mbPtr
%val4143 = load i64, i64* %iPtr
%val4144 = load i64, i64* %nrowsPtr
%val4145 = mul i64 %val4143, %val4144
%val4146 = load i64, i64* %jPtr
%val4147 = add i64 %val4145, %val4146
%val4148 = load double*, double** %m1Ptr
; pointer ref
%val4149 = getelementptr double, double* %val4148, i64 %val4147
%val4150 = load double, double* %val4149
; set pointer
%val4151 = getelementptr double, double* %val4142, i64 %val4141
store double %val4150, double* %val4151
%val4153 = load i64, i64* %nPtr
%val4154 = load i64, i64* %nrowsPtr
%val4155 = sub i64 %val4154, 2
%cmp4156 = icmp slt i64 %val4153, %val4155
br i1 %cmp4156, label %then4152, label %else4152

then4152:
; do set!
%val4157 = load i64, i64* %nPtr
%val4158 = add i64 %val4157, 1
store i64 %val4158, i64* %nPtr
store i64 %val4158, i64* %ifptr4152
br label %ifcont4152

else4152:
; do set!
store i64 0, i64* %nPtr
; do set!
%val4159 = load i64, i64* %mPtr
%val4160 = add i64 %val4159, 1
store i64 %val4160, i64* %mPtr
store i64 %val4160, i64* %ifptr4152
br label %ifcont4152

ifcont4152:
%ifres4161 = load i64, i64* %ifptr4152

store i64 %ifres4161, i64* %ifptr4121
br label %ifcont4121

else4121:
store i64 1, i64* %ifptr4121
br label %ifcont4121

ifcont4121:
%ifres4162 = load i64, i64* %ifptr4121

%loop_cnt4111 = load i64, i64* %jPtr
%next4111 = add i64 %loop_cnt4111, 1
store i64 %next4111, i64* %jPtr
%cmp4111 = icmp ult i64 %next4111, %num4164
br i1 %cmp4111, label %loop4111, label %after4111

after4111:
%loop_cnt4108 = load i64, i64* %iPtr
%next4108 = add i64 %loop_cnt4108, 1
store i64 %next4108, i64* %iPtr
%cmp4108 = icmp ult i64 %next4108, %num4168
br i1 %cmp4108, label %loop4108, label %after4108

after4108:
; do set!
%val4171 = load double, double* %detPtr
%val4172 = load double, double* %sPtr
%val4173 = load i64, i64* %cPtr
%val4174 = load double*, double** %m1Ptr
; pointer ref
%val4175 = getelementptr double, double* %val4174, i64 %val4173
%val4176 = load double, double* %val4175
%val4177 = load double*, double** %mbPtr
%val4178 = load i64, i64* %nrowsPtr
%val4179 = sub i64 %val4178, 1

; apply closure 
%vval4180 = load {i8*, i8*, double (i8*, i8*, double*, i64)*}**, {i8*, i8*, double (i8*, i8*, double*, i64)*}*** %mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr
%val4181 = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*,{i8*, i8*, double (i8*, i8*, double*, i64)*}** %vval4180
%fPtr4182 = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %val4181, i32 0, i32 2
%ePtr4183 = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %val4181, i32 0, i32 1
%f4184 = load double (i8*, i8*, double*, i64)*, double (i8*, i8*, double*, i64)** %fPtr4182
%e4185 = load i8*, i8** %ePtr4183
%tzone4186 = load i8*, i8** %_impzPtr
%zone4187 = bitcast i8* %tzone4186 to %mzone*
%z4188 = bitcast %mzone* %zone4187 to i8*
%result4189 = tail call fastcc double %f4184(i8* %z4188, i8* %e4185, double* %val4177, i64 %val4179)
%val4190 = fmul double %val4176, %result4189
%val4191 = fmul double %val4172, %val4190
%val4192 = fadd double %val4171, %val4191
store double %val4192, double* %detPtr
; do set!
%val4193 = load double, double* %sPtr
%val4194 = fmul double -1.0000000000000000000, %val4193
store double %val4194, double* %sPtr
%loop_cnt4105 = load i64, i64* %cPtr
%next4105 = add i64 %loop_cnt4105, 1
store i64 %next4105, i64* %cPtr
%cmp4105 = icmp ult i64 %next4105, %num4196
br i1 %cmp4105, label %loop4105, label %after4105

after4105:
%val4199 = load double, double* %detPtr
ret double %val4199
}
@gsxtmmath187 = hidden constant [100 x i8] c"mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, double*, i64)*}** @mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4221 = load i8*, i8** %_impzPtr
%zone4222 = bitcast i8* %tzone4221 to %mzone*

; let assign value to symbol mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0
%dat_mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone4222, i64 8)
%mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr = bitcast i8* %dat_mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 to { i8*, i8*, double (i8*, i8*, double*, i64)*}***
%tzone4202 = load i8*, i8** %_impzPtr
%zone4203 = bitcast i8* %tzone4202 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4203)
; malloc closure structure
%clsptr4204 = call i8* @llvm_zone_malloc(%mzone* %zone4203, i64 24)
%closure4205 = bitcast i8* %clsptr4204 to { i8*, i8*, double (i8*, i8*, double*, i64)*}*

; malloc environment structure
%envptr4206 = call i8* @llvm_zone_malloc(%mzone* %zone4203, i64 8)
%environment4207 = bitcast i8* %envptr4206 to {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}*

; malloc closure address table
%addytable4208 = call %clsvar* @new_address_table()
%var4209 = bitcast [47 x i8]* @gsxtmmath186 to i8*
%var4210 = bitcast [47 x i8]* @gsxtmmath10 to i8*
%addytable4211 = call %clsvar* @add_address_table(%mzone* %zone4203, i8* %var4209, i32 0, i8* %var4210, i32 3, %clsvar* %addytable4208)
%address-table4212 = bitcast %clsvar* %addytable4211 to i8*

; insert table, function and environment into closure struct
%closure.table4215 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure4205, i32 0, i32 0
store i8* %address-table4212, i8** %closure.table4215
%closure.env4216 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure4205, i32 0, i32 1
store i8* %envptr4206, i8** %closure.env4216
%closure.func4217 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure4205, i32 0, i32 2
store double (i8*, i8*, double*, i64)* @mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0__4077, double (i8*, i8*, double*, i64)** %closure.func4217
%closure_size4218 = call i64 @llvm_zone_mark_size(%mzone* %zone4203)
call void @llvm_zone_ptr_set_size(i8* %clsptr4204, i64 %closure_size4218)
%wrapper_ptr4219 = call i8* @llvm_zone_malloc(%mzone* %zone4203, i64 8)
%closure_wrapper4220 = bitcast i8* %wrapper_ptr4219 to { i8*, i8*, double (i8*, i8*, double*, i64)*}**
store { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure4205, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper4220

; let value assignment
%mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 = select i1 true, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper4220, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper4220
store { i8*, i8*, double (i8*, i8*, double*, i64)*}** %mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0, { i8*, i8*, double (i8*, i8*, double*, i64)*}*** %mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0
%tmp_envptr4214 = getelementptr {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}* %environment4207, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, double*, i64)*}*** %mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr, {i8*, i8*, double (i8*, i8*, double*, i64)*}**** %tmp_envptr4214


%val4223 = load {i8*, i8*, double (i8*, i8*, double*, i64)*}**, {i8*, i8*, double (i8*, i8*, double*, i64)*}*** %mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr
ret {i8*, i8*, double (i8*, i8*, double*, i64)*}** %val4223
}


@mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, double*, i64)*}** @mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret double %result
}


define dllexport ccc double @mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_native(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret double %result
}


define dllexport ccc i8*  @mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4224 = bitcast [100 x i8]* @gsxtmmath187 to i8*
call i32 (i8*, ...) @printf(i8* %var4224)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4225 = bitcast [100 x i8]* @gsxtmmath187 to i8*
call i32 (i8*, ...) @printf(i8* %var4225)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, i64}*
%arg_p_0 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath188 = hidden constant [48 x i8] c"minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd\00"
define dllexport fastcc void @minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd__4226(i8* %_impz,i8* %_impenv, float* %m1, i64 %nrows, float* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4227 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***}*
%minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***}* %impenv, i32 0, i32 0
%minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpdPtr = load {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**** %minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpdPtr_

; setup arguments
%m1Ptr = alloca float*
store float* %m1, float** %m1Ptr
%nrowsPtr = alloca i64
store i64 %nrows, i64* %nrowsPtr
%resultPtr = alloca float*
store float* %result, float** %resultPtr


%tzone4232 = load i8*, i8** %_impzPtr
%zone4233 = bitcast i8* %tzone4232 to %mzone*

; let assign value to symbol m2
%m2Ptr = alloca float*
%tzone4238 = load i8*, i8** %_impzPtr
%zone4239 = bitcast i8* %tzone4238 to %mzone*

; let assign value to symbol fac
%facPtr = alloca float*
%tzone4240 = load i8*, i8** %_impzPtr
%zone4241 = bitcast i8* %tzone4240 to %mzone*

; let assign value to symbol d
%dPtr = alloca float
%tzone4242 = load i8*, i8** %_impzPtr
%zone4243 = bitcast i8* %tzone4242 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%tzone4244 = load i8*, i8** %_impzPtr
%zone4245 = bitcast i8* %tzone4244 to %mzone*

; let assign value to symbol j
%jPtr = alloca i64
%tzone4246 = load i8*, i8** %_impzPtr
%zone4247 = bitcast i8* %tzone4246 to %mzone*

; let assign value to symbol m
%mPtr = alloca i64
%tzone4248 = load i8*, i8** %_impzPtr
%zone4249 = bitcast i8* %tzone4248 to %mzone*

; let assign value to symbol n
%nPtr = alloca i64
%tzone4250 = load i8*, i8** %_impzPtr
%zone4251 = bitcast i8* %tzone4250 to %mzone*

; let assign value to symbol q
%qPtr = alloca i64
%tzone4252 = load i8*, i8** %_impzPtr
%zone4253 = bitcast i8* %tzone4252 to %mzone*

; let assign value to symbol p
%pPtr = alloca i64
%val4228 = load i64, i64* %nrowsPtr
%val4229 = load i64, i64* %nrowsPtr
%val4230 = mul i64 %val4228, %val4229
%dat4231 = alloca float, i64 %val4230, align 16

; let value assignment
%m2 = select i1 true, float* %dat4231, float* %dat4231
store float* %m2, float** %m2Ptr

%val4234 = load i64, i64* %nrowsPtr
%val4235 = load i64, i64* %nrowsPtr
%val4236 = mul i64 %val4234, %val4235
%dat4237 = alloca float, i64 %val4236, align 16

; let value assignment
%fac = select i1 true, float* %dat4237, float* %dat4237
store float* %fac, float** %facPtr


; let value assignment
%d = select i1 true, float 0x0, float 0x0
store float %d, float* %dPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr


; let value assignment
%j = select i1 true, i64 0, i64 0
store i64 %j, i64* %jPtr


; let value assignment
%m = select i1 true, i64 0, i64 0
store i64 %m, i64* %mPtr


; let value assignment
%n = select i1 true, i64 0, i64 0
store i64 %n, i64* %nPtr


; let value assignment
%q = select i1 true, i64 0, i64 0
store i64 %q, i64* %qPtr


; let value assignment
%p = select i1 true, i64 0, i64 0
store i64 %p, i64* %pPtr

; promote local stack var allocations
%tzone4413 = load i8*, i8** %_impzPtr
%zone4414 = bitcast i8* %tzone4413 to %mzone*
%ifptr4273 = alloca i64
%ifptr4305 = alloca i64
%ifptr4274 = alloca i1
%ifptr4278 = alloca i1
; setup loop
%val4256 = load i64, i64* %nrowsPtr
store i64 0, i64* %qPtr
%val4345 = load i64, i64* %qPtr
%num4346 = add i64 %val4256, %val4345
%comp4347 = icmp ult i64 %val4256, 1
br i1 %comp4347, label %after4254, label %loop4254

loop4254:
; setup loop
%val4259 = load i64, i64* %nrowsPtr
store i64 0, i64* %pPtr
%val4341 = load i64, i64* %pPtr
%num4342 = add i64 %val4259, %val4341
%comp4343 = icmp ult i64 %val4259, 1
br i1 %comp4343, label %after4257, label %loop4257

loop4257:
; do set!
store i64 0, i64* %mPtr
; do set!
store i64 0, i64* %nPtr
; setup loop
%val4262 = load i64, i64* %nrowsPtr
store i64 0, i64* %iPtr
%val4320 = load i64, i64* %iPtr
%num4321 = add i64 %val4262, %val4320
%comp4322 = icmp ult i64 %val4262, 1
br i1 %comp4322, label %after4260, label %loop4260

loop4260:
; setup loop
%val4265 = load i64, i64* %nrowsPtr
store i64 0, i64* %jPtr
%val4316 = load i64, i64* %jPtr
%num4317 = add i64 %val4265, %val4316
%comp4318 = icmp ult i64 %val4265, 1
br i1 %comp4318, label %after4263, label %loop4263

loop4263:
%val4266 = load i64, i64* %iPtr
%val4267 = load i64, i64* %nrowsPtr
%val4268 = mul i64 %val4266, %val4267
%val4269 = load i64, i64* %jPtr
%val4270 = add i64 %val4268, %val4269
%val4271 = load float*, float** %m2Ptr
; set pointer
%val4272 = getelementptr float, float* %val4271, i64 %val4270
store float 0x0, float* %val4272
%val4275 = load i64, i64* %iPtr
%val4276 = load i64, i64* %qPtr
%cmp4277 = icmp ne i64 %val4275, %val4276
br i1 %cmp4277, label %then4274, label %else4274

then4274:
%val4279 = load i64, i64* %jPtr
%val4280 = load i64, i64* %pPtr
%cmp4281 = icmp ne i64 %val4279, %val4280
br i1 %cmp4281, label %then4278, label %else4278

then4278:
%val4282 = load i64, i64* %jPtr
%val4283 = load i64, i64* %pPtr
%cmp4284 = icmp ne i64 %val4282, %val4283
store i1 %cmp4284, i1* %ifptr4278
br label %ifcont4278

else4278:
%res4285 = call ccc i1 @impc_false()
store i1 %res4285, i1* %ifptr4278
br label %ifcont4278

ifcont4278:
%ifres4286 = load i1, i1* %ifptr4278

store i1 %ifres4286, i1* %ifptr4274
br label %ifcont4274

else4274:
%res4287 = call ccc i1 @impc_false()
store i1 %res4287, i1* %ifptr4274
br label %ifcont4274

ifcont4274:
%ifres4288 = load i1, i1* %ifptr4274

br i1 %ifres4288, label %then4273, label %else4273

then4273:
%val4289 = load i64, i64* %mPtr
%val4290 = load i64, i64* %nrowsPtr
%val4291 = sub i64 %val4290, 1
%val4292 = mul i64 %val4289, %val4291
%val4293 = load i64, i64* %nPtr
%val4294 = add i64 %val4292, %val4293
%val4295 = load float*, float** %m2Ptr
%val4296 = load i64, i64* %iPtr
%val4297 = load i64, i64* %nrowsPtr
%val4298 = mul i64 %val4296, %val4297
%val4299 = load i64, i64* %jPtr
%val4300 = add i64 %val4298, %val4299
%val4301 = load float*, float** %m1Ptr
; pointer ref
%val4302 = getelementptr float, float* %val4301, i64 %val4300
%val4303 = load float, float* %val4302
; set pointer
%val4304 = getelementptr float, float* %val4295, i64 %val4294
store float %val4303, float* %val4304
%val4306 = load i64, i64* %nPtr
%val4307 = load i64, i64* %nrowsPtr
%val4308 = sub i64 %val4307, 2
%cmp4309 = icmp slt i64 %val4306, %val4308
br i1 %cmp4309, label %then4305, label %else4305

then4305:
; do set!
%val4310 = load i64, i64* %nPtr
%val4311 = add i64 %val4310, 1
store i64 %val4311, i64* %nPtr
store i64 %val4311, i64* %ifptr4305
br label %ifcont4305

else4305:
; do set!
store i64 0, i64* %nPtr
; do set!
%val4312 = load i64, i64* %mPtr
%val4313 = add i64 %val4312, 1
store i64 %val4313, i64* %mPtr
store i64 %val4313, i64* %ifptr4305
br label %ifcont4305

ifcont4305:
%ifres4314 = load i64, i64* %ifptr4305

store i64 %ifres4314, i64* %ifptr4273
br label %ifcont4273

else4273:
store i64 1, i64* %ifptr4273
br label %ifcont4273

ifcont4273:
%ifres4315 = load i64, i64* %ifptr4273

%loop_cnt4263 = load i64, i64* %jPtr
%next4263 = add i64 %loop_cnt4263, 1
store i64 %next4263, i64* %jPtr
%cmp4263 = icmp ult i64 %next4263, %num4317
br i1 %cmp4263, label %loop4263, label %after4263

after4263:
%loop_cnt4260 = load i64, i64* %iPtr
%next4260 = add i64 %loop_cnt4260, 1
store i64 %next4260, i64* %iPtr
%cmp4260 = icmp ult i64 %next4260, %num4321
br i1 %cmp4260, label %loop4260, label %after4260

after4260:
%val4324 = load i64, i64* %qPtr
%val4325 = load i64, i64* %nrowsPtr
%val4326 = mul i64 %val4324, %val4325
%val4327 = load i64, i64* %pPtr
%val4328 = add i64 %val4326, %val4327
%val4329 = load float*, float** %facPtr
%val4330 = load i64, i64* %qPtr
%val4331 = load i64, i64* %pPtr
%val4332 = add i64 %val4330, %val4331
%res4333 = call ccc float @i64tof(i64 %val4332)
%val4334 = call float @llvm.pow.f32(float 0xbff0000000000000, float %res4333)
%val4335 = load float*, float** %m2Ptr
%val4336 = load i64, i64* %nrowsPtr
%val4337 = sub i64 %val4336, 1
%res4338 = call fastcc float @mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd(float* %val4335, i64 %val4337)
%val4339 = fmul float %val4334, %res4338
; set pointer
%val4340 = getelementptr float, float* %val4329, i64 %val4328
store float %val4339, float* %val4340
%loop_cnt4257 = load i64, i64* %pPtr
%next4257 = add i64 %loop_cnt4257, 1
store i64 %next4257, i64* %pPtr
%cmp4257 = icmp ult i64 %next4257, %num4342
br i1 %cmp4257, label %loop4257, label %after4257

after4257:
%loop_cnt4254 = load i64, i64* %qPtr
%next4254 = add i64 %loop_cnt4254, 1
store i64 %next4254, i64* %qPtr
%cmp4254 = icmp ult i64 %next4254, %num4346
br i1 %cmp4254, label %loop4254, label %after4254

after4254:
; setup loop
%val4351 = load i64, i64* %nrowsPtr
store i64 0, i64* %iPtr
%val4374 = load i64, i64* %iPtr
%num4375 = add i64 %val4351, %val4374
%comp4376 = icmp ult i64 %val4351, 1
br i1 %comp4376, label %after4349, label %loop4349

loop4349:
; setup loop
%val4354 = load i64, i64* %nrowsPtr
store i64 0, i64* %jPtr
%val4370 = load i64, i64* %jPtr
%num4371 = add i64 %val4354, %val4370
%comp4372 = icmp ult i64 %val4354, 1
br i1 %comp4372, label %after4352, label %loop4352

loop4352:
%val4355 = load i64, i64* %iPtr
%val4356 = load i64, i64* %nrowsPtr
%val4357 = mul i64 %val4355, %val4356
%val4358 = load i64, i64* %jPtr
%val4359 = add i64 %val4357, %val4358
%val4360 = load float*, float** %m2Ptr
%val4361 = load i64, i64* %jPtr
%val4362 = load i64, i64* %nrowsPtr
%val4363 = mul i64 %val4361, %val4362
%val4364 = load i64, i64* %iPtr
%val4365 = add i64 %val4363, %val4364
%val4366 = load float*, float** %facPtr
; pointer ref
%val4367 = getelementptr float, float* %val4366, i64 %val4365
%val4368 = load float, float* %val4367
; set pointer
%val4369 = getelementptr float, float* %val4360, i64 %val4359
store float %val4368, float* %val4369
%loop_cnt4352 = load i64, i64* %jPtr
%next4352 = add i64 %loop_cnt4352, 1
store i64 %next4352, i64* %jPtr
%cmp4352 = icmp ult i64 %next4352, %num4371
br i1 %cmp4352, label %loop4352, label %after4352

after4352:
%loop_cnt4349 = load i64, i64* %iPtr
%next4349 = add i64 %loop_cnt4349, 1
store i64 %next4349, i64* %iPtr
%cmp4349 = icmp ult i64 %next4349, %num4375
br i1 %cmp4349, label %loop4349, label %after4349

after4349:
; do set!
%val4378 = load float*, float** %m1Ptr
%val4379 = load i64, i64* %nrowsPtr
%res4380 = call fastcc float @mdeterminant_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd(float* %val4378, i64 %val4379)
store float %res4380, float* %dPtr
; setup loop
%val4383 = load i64, i64* %nrowsPtr
store i64 0, i64* %iPtr
%val4408 = load i64, i64* %iPtr
%num4409 = add i64 %val4383, %val4408
%comp4410 = icmp ult i64 %val4383, 1
br i1 %comp4410, label %after4381, label %loop4381

loop4381:
; setup loop
%val4386 = load i64, i64* %nrowsPtr
store i64 0, i64* %jPtr
%val4404 = load i64, i64* %jPtr
%num4405 = add i64 %val4386, %val4404
%comp4406 = icmp ult i64 %val4386, 1
br i1 %comp4406, label %after4384, label %loop4384

loop4384:
%val4387 = load i64, i64* %iPtr
%val4388 = load i64, i64* %nrowsPtr
%val4389 = mul i64 %val4387, %val4388
%val4390 = load i64, i64* %jPtr
%val4391 = add i64 %val4389, %val4390
%val4392 = load float*, float** %resultPtr
%val4393 = load i64, i64* %iPtr
%val4394 = load i64, i64* %nrowsPtr
%val4395 = mul i64 %val4393, %val4394
%val4396 = load i64, i64* %jPtr
%val4397 = add i64 %val4395, %val4396
%val4398 = load float*, float** %m2Ptr
; pointer ref
%val4399 = getelementptr float, float* %val4398, i64 %val4397
%val4400 = load float, float* %val4399
%val4401 = load float, float* %dPtr
%val4402 = fdiv float %val4400, %val4401
; set pointer
%val4403 = getelementptr float, float* %val4392, i64 %val4391
store float %val4402, float* %val4403
%loop_cnt4384 = load i64, i64* %jPtr
%next4384 = add i64 %loop_cnt4384, 1
store i64 %next4384, i64* %jPtr
%cmp4384 = icmp ult i64 %next4384, %num4405
br i1 %cmp4384, label %loop4384, label %after4384

after4384:
%loop_cnt4381 = load i64, i64* %iPtr
%next4381 = add i64 %loop_cnt4381, 1
store i64 %next4381, i64* %iPtr
%cmp4381 = icmp ult i64 %next4381, %num4409
br i1 %cmp4381, label %loop4381, label %after4381

after4381:
ret void
}
@gsxtmmath189 = hidden constant [101 x i8] c"minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** @minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4434 = load i8*, i8** %_impzPtr
%zone4435 = bitcast i8* %tzone4434 to %mzone*

; let assign value to symbol minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd
%dat_minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd = call i8* @llvm_zone_malloc(%mzone* %zone4435, i64 8)
%minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpdPtr = bitcast i8* %dat_minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd to { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***
%tzone4415 = load i8*, i8** %_impzPtr
%zone4416 = bitcast i8* %tzone4415 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4416)
; malloc closure structure
%clsptr4417 = call i8* @llvm_zone_malloc(%mzone* %zone4416, i64 24)
%closure4418 = bitcast i8* %clsptr4417 to { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*

; malloc environment structure
%envptr4419 = call i8* @llvm_zone_malloc(%mzone* %zone4416, i64 8)
%environment4420 = bitcast i8* %envptr4419 to {{i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***}*

; malloc closure address table
%addytable4421 = call %clsvar* @new_address_table()
%var4422 = bitcast [48 x i8]* @gsxtmmath188 to i8*
%var4423 = bitcast [52 x i8]* @gsxtmmath79 to i8*
%addytable4424 = call %clsvar* @add_address_table(%mzone* %zone4416, i8* %var4422, i32 0, i8* %var4423, i32 3, %clsvar* %addytable4421)
%address-table4425 = bitcast %clsvar* %addytable4424 to i8*

; insert table, function and environment into closure struct
%closure.table4428 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure4418, i32 0, i32 0
store i8* %address-table4425, i8** %closure.table4428
%closure.env4429 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure4418, i32 0, i32 1
store i8* %envptr4419, i8** %closure.env4429
%closure.func4430 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure4418, i32 0, i32 2
store void (i8*, i8*, float*, i64, float*)* @minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd__4226, void (i8*, i8*, float*, i64, float*)** %closure.func4430
%closure_size4431 = call i64 @llvm_zone_mark_size(%mzone* %zone4416)
call void @llvm_zone_ptr_set_size(i8* %clsptr4417, i64 %closure_size4431)
%wrapper_ptr4432 = call i8* @llvm_zone_malloc(%mzone* %zone4416, i64 8)
%closure_wrapper4433 = bitcast i8* %wrapper_ptr4432 to { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure4418, { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure_wrapper4433

; let value assignment
%minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd = select i1 true, { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure_wrapper4433, { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure_wrapper4433
store { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd, { i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*** %minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpdPtr

; add data to environment
; don't need to alloc for env var minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd
%tmp_envptr4427 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64, float*)*}***}* %environment4420, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*** %minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpdPtr, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**** %tmp_envptr4427


%val4436 = load {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*** %minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpdPtr
ret {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %val4436
}


@minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** @minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd(float* %arg_0,i64 %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, float*)*,  void (i8*, i8*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, float* %arg_2)
ret void
}


define dllexport ccc void @minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_native(float* %arg_0,i64 %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, float*)*,  void (i8*, i8*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, float* %arg_2)
ret void
}


define dllexport ccc i8*  @minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4437 = bitcast [101 x i8]* @gsxtmmath189 to i8*
call i32 (i8*, ...) @printf(i8* %var4437)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4438 = bitcast [101 x i8]* @gsxtmmath189 to i8*
call i32 (i8*, ...) @printf(i8* %var4438)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4439 = bitcast [101 x i8]* @gsxtmmath189 to i8*
call i32 (i8*, ...) @printf(i8* %var4439)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, float*)*,  void (i8*, i8*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, float* %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64, float*}*
%arg_p_0 = getelementptr {float*, i64, float*}, {float*, i64, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64, float*}, {float*, i64, float*}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {float*, i64, float*}, {float*, i64, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, float*)*,  void (i8*, i8*, float*, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, float* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath190 = hidden constant [51 x i8] c"minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0\00"
define dllexport fastcc void @minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0__4440(i8* %_impz,i8* %_impenv, double* %m1, i64 %nrows, double* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4441 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***}*
%minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***}* %impenv, i32 0, i32 0
%minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0Ptr = load {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**** %minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0Ptr_

; setup arguments
%m1Ptr = alloca double*
store double* %m1, double** %m1Ptr
%nrowsPtr = alloca i64
store i64 %nrows, i64* %nrowsPtr
%resultPtr = alloca double*
store double* %result, double** %resultPtr


%tzone4446 = load i8*, i8** %_impzPtr
%zone4447 = bitcast i8* %tzone4446 to %mzone*

; let assign value to symbol m2
%m2Ptr = alloca double*
%tzone4452 = load i8*, i8** %_impzPtr
%zone4453 = bitcast i8* %tzone4452 to %mzone*

; let assign value to symbol fac
%facPtr = alloca double*
%tzone4454 = load i8*, i8** %_impzPtr
%zone4455 = bitcast i8* %tzone4454 to %mzone*

; let assign value to symbol d
%dPtr = alloca double
%tzone4456 = load i8*, i8** %_impzPtr
%zone4457 = bitcast i8* %tzone4456 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%tzone4458 = load i8*, i8** %_impzPtr
%zone4459 = bitcast i8* %tzone4458 to %mzone*

; let assign value to symbol j
%jPtr = alloca i64
%tzone4460 = load i8*, i8** %_impzPtr
%zone4461 = bitcast i8* %tzone4460 to %mzone*

; let assign value to symbol m
%mPtr = alloca i64
%tzone4462 = load i8*, i8** %_impzPtr
%zone4463 = bitcast i8* %tzone4462 to %mzone*

; let assign value to symbol n
%nPtr = alloca i64
%tzone4464 = load i8*, i8** %_impzPtr
%zone4465 = bitcast i8* %tzone4464 to %mzone*

; let assign value to symbol q
%qPtr = alloca i64
%tzone4466 = load i8*, i8** %_impzPtr
%zone4467 = bitcast i8* %tzone4466 to %mzone*

; let assign value to symbol p
%pPtr = alloca i64
%val4442 = load i64, i64* %nrowsPtr
%val4443 = load i64, i64* %nrowsPtr
%val4444 = mul i64 %val4442, %val4443
%dat4445 = alloca double, i64 %val4444, align 16

; let value assignment
%m2 = select i1 true, double* %dat4445, double* %dat4445
store double* %m2, double** %m2Ptr

%val4448 = load i64, i64* %nrowsPtr
%val4449 = load i64, i64* %nrowsPtr
%val4450 = mul i64 %val4448, %val4449
%dat4451 = alloca double, i64 %val4450, align 16

; let value assignment
%fac = select i1 true, double* %dat4451, double* %dat4451
store double* %fac, double** %facPtr


; let value assignment
%d = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %d, double* %dPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr


; let value assignment
%j = select i1 true, i64 0, i64 0
store i64 %j, i64* %jPtr


; let value assignment
%m = select i1 true, i64 0, i64 0
store i64 %m, i64* %mPtr


; let value assignment
%n = select i1 true, i64 0, i64 0
store i64 %n, i64* %nPtr


; let value assignment
%q = select i1 true, i64 0, i64 0
store i64 %q, i64* %qPtr


; let value assignment
%p = select i1 true, i64 0, i64 0
store i64 %p, i64* %pPtr

; promote local stack var allocations
%tzone4627 = load i8*, i8** %_impzPtr
%zone4628 = bitcast i8* %tzone4627 to %mzone*
%ifptr4487 = alloca i64
%ifptr4519 = alloca i64
%ifptr4488 = alloca i1
%ifptr4492 = alloca i1
; setup loop
%val4470 = load i64, i64* %nrowsPtr
store i64 0, i64* %qPtr
%val4559 = load i64, i64* %qPtr
%num4560 = add i64 %val4470, %val4559
%comp4561 = icmp ult i64 %val4470, 1
br i1 %comp4561, label %after4468, label %loop4468

loop4468:
; setup loop
%val4473 = load i64, i64* %nrowsPtr
store i64 0, i64* %pPtr
%val4555 = load i64, i64* %pPtr
%num4556 = add i64 %val4473, %val4555
%comp4557 = icmp ult i64 %val4473, 1
br i1 %comp4557, label %after4471, label %loop4471

loop4471:
; do set!
store i64 0, i64* %mPtr
; do set!
store i64 0, i64* %nPtr
; setup loop
%val4476 = load i64, i64* %nrowsPtr
store i64 0, i64* %iPtr
%val4534 = load i64, i64* %iPtr
%num4535 = add i64 %val4476, %val4534
%comp4536 = icmp ult i64 %val4476, 1
br i1 %comp4536, label %after4474, label %loop4474

loop4474:
; setup loop
%val4479 = load i64, i64* %nrowsPtr
store i64 0, i64* %jPtr
%val4530 = load i64, i64* %jPtr
%num4531 = add i64 %val4479, %val4530
%comp4532 = icmp ult i64 %val4479, 1
br i1 %comp4532, label %after4477, label %loop4477

loop4477:
%val4480 = load i64, i64* %iPtr
%val4481 = load i64, i64* %nrowsPtr
%val4482 = mul i64 %val4480, %val4481
%val4483 = load i64, i64* %jPtr
%val4484 = add i64 %val4482, %val4483
%val4485 = load double*, double** %m2Ptr
; set pointer
%val4486 = getelementptr double, double* %val4485, i64 %val4484
store double 0.00000000000000000000, double* %val4486
%val4489 = load i64, i64* %iPtr
%val4490 = load i64, i64* %qPtr
%cmp4491 = icmp ne i64 %val4489, %val4490
br i1 %cmp4491, label %then4488, label %else4488

then4488:
%val4493 = load i64, i64* %jPtr
%val4494 = load i64, i64* %pPtr
%cmp4495 = icmp ne i64 %val4493, %val4494
br i1 %cmp4495, label %then4492, label %else4492

then4492:
%val4496 = load i64, i64* %jPtr
%val4497 = load i64, i64* %pPtr
%cmp4498 = icmp ne i64 %val4496, %val4497
store i1 %cmp4498, i1* %ifptr4492
br label %ifcont4492

else4492:
%res4499 = call ccc i1 @impc_false()
store i1 %res4499, i1* %ifptr4492
br label %ifcont4492

ifcont4492:
%ifres4500 = load i1, i1* %ifptr4492

store i1 %ifres4500, i1* %ifptr4488
br label %ifcont4488

else4488:
%res4501 = call ccc i1 @impc_false()
store i1 %res4501, i1* %ifptr4488
br label %ifcont4488

ifcont4488:
%ifres4502 = load i1, i1* %ifptr4488

br i1 %ifres4502, label %then4487, label %else4487

then4487:
%val4503 = load i64, i64* %mPtr
%val4504 = load i64, i64* %nrowsPtr
%val4505 = sub i64 %val4504, 1
%val4506 = mul i64 %val4503, %val4505
%val4507 = load i64, i64* %nPtr
%val4508 = add i64 %val4506, %val4507
%val4509 = load double*, double** %m2Ptr
%val4510 = load i64, i64* %iPtr
%val4511 = load i64, i64* %nrowsPtr
%val4512 = mul i64 %val4510, %val4511
%val4513 = load i64, i64* %jPtr
%val4514 = add i64 %val4512, %val4513
%val4515 = load double*, double** %m1Ptr
; pointer ref
%val4516 = getelementptr double, double* %val4515, i64 %val4514
%val4517 = load double, double* %val4516
; set pointer
%val4518 = getelementptr double, double* %val4509, i64 %val4508
store double %val4517, double* %val4518
%val4520 = load i64, i64* %nPtr
%val4521 = load i64, i64* %nrowsPtr
%val4522 = sub i64 %val4521, 2
%cmp4523 = icmp slt i64 %val4520, %val4522
br i1 %cmp4523, label %then4519, label %else4519

then4519:
; do set!
%val4524 = load i64, i64* %nPtr
%val4525 = add i64 %val4524, 1
store i64 %val4525, i64* %nPtr
store i64 %val4525, i64* %ifptr4519
br label %ifcont4519

else4519:
; do set!
store i64 0, i64* %nPtr
; do set!
%val4526 = load i64, i64* %mPtr
%val4527 = add i64 %val4526, 1
store i64 %val4527, i64* %mPtr
store i64 %val4527, i64* %ifptr4519
br label %ifcont4519

ifcont4519:
%ifres4528 = load i64, i64* %ifptr4519

store i64 %ifres4528, i64* %ifptr4487
br label %ifcont4487

else4487:
store i64 1, i64* %ifptr4487
br label %ifcont4487

ifcont4487:
%ifres4529 = load i64, i64* %ifptr4487

%loop_cnt4477 = load i64, i64* %jPtr
%next4477 = add i64 %loop_cnt4477, 1
store i64 %next4477, i64* %jPtr
%cmp4477 = icmp ult i64 %next4477, %num4531
br i1 %cmp4477, label %loop4477, label %after4477

after4477:
%loop_cnt4474 = load i64, i64* %iPtr
%next4474 = add i64 %loop_cnt4474, 1
store i64 %next4474, i64* %iPtr
%cmp4474 = icmp ult i64 %next4474, %num4535
br i1 %cmp4474, label %loop4474, label %after4474

after4474:
%val4538 = load i64, i64* %qPtr
%val4539 = load i64, i64* %nrowsPtr
%val4540 = mul i64 %val4538, %val4539
%val4541 = load i64, i64* %pPtr
%val4542 = add i64 %val4540, %val4541
%val4543 = load double*, double** %facPtr
%val4544 = load i64, i64* %qPtr
%val4545 = load i64, i64* %pPtr
%val4546 = add i64 %val4544, %val4545
%res4547 = call ccc double @i64tod(i64 %val4546)
%val4548 = call double @llvm.pow.f64(double -1.0000000000000000000, double %res4547)
%val4549 = load double*, double** %m2Ptr
%val4550 = load i64, i64* %nrowsPtr
%val4551 = sub i64 %val4550, 1
%res4552 = call fastcc double @mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0(double* %val4549, i64 %val4551)
%val4553 = fmul double %val4548, %res4552
; set pointer
%val4554 = getelementptr double, double* %val4543, i64 %val4542
store double %val4553, double* %val4554
%loop_cnt4471 = load i64, i64* %pPtr
%next4471 = add i64 %loop_cnt4471, 1
store i64 %next4471, i64* %pPtr
%cmp4471 = icmp ult i64 %next4471, %num4556
br i1 %cmp4471, label %loop4471, label %after4471

after4471:
%loop_cnt4468 = load i64, i64* %qPtr
%next4468 = add i64 %loop_cnt4468, 1
store i64 %next4468, i64* %qPtr
%cmp4468 = icmp ult i64 %next4468, %num4560
br i1 %cmp4468, label %loop4468, label %after4468

after4468:
; setup loop
%val4565 = load i64, i64* %nrowsPtr
store i64 0, i64* %iPtr
%val4588 = load i64, i64* %iPtr
%num4589 = add i64 %val4565, %val4588
%comp4590 = icmp ult i64 %val4565, 1
br i1 %comp4590, label %after4563, label %loop4563

loop4563:
; setup loop
%val4568 = load i64, i64* %nrowsPtr
store i64 0, i64* %jPtr
%val4584 = load i64, i64* %jPtr
%num4585 = add i64 %val4568, %val4584
%comp4586 = icmp ult i64 %val4568, 1
br i1 %comp4586, label %after4566, label %loop4566

loop4566:
%val4569 = load i64, i64* %iPtr
%val4570 = load i64, i64* %nrowsPtr
%val4571 = mul i64 %val4569, %val4570
%val4572 = load i64, i64* %jPtr
%val4573 = add i64 %val4571, %val4572
%val4574 = load double*, double** %m2Ptr
%val4575 = load i64, i64* %jPtr
%val4576 = load i64, i64* %nrowsPtr
%val4577 = mul i64 %val4575, %val4576
%val4578 = load i64, i64* %iPtr
%val4579 = add i64 %val4577, %val4578
%val4580 = load double*, double** %facPtr
; pointer ref
%val4581 = getelementptr double, double* %val4580, i64 %val4579
%val4582 = load double, double* %val4581
; set pointer
%val4583 = getelementptr double, double* %val4574, i64 %val4573
store double %val4582, double* %val4583
%loop_cnt4566 = load i64, i64* %jPtr
%next4566 = add i64 %loop_cnt4566, 1
store i64 %next4566, i64* %jPtr
%cmp4566 = icmp ult i64 %next4566, %num4585
br i1 %cmp4566, label %loop4566, label %after4566

after4566:
%loop_cnt4563 = load i64, i64* %iPtr
%next4563 = add i64 %loop_cnt4563, 1
store i64 %next4563, i64* %iPtr
%cmp4563 = icmp ult i64 %next4563, %num4589
br i1 %cmp4563, label %loop4563, label %after4563

after4563:
; do set!
%val4592 = load double*, double** %m1Ptr
%val4593 = load i64, i64* %nrowsPtr
%res4594 = call fastcc double @mdeterminant_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0(double* %val4592, i64 %val4593)
store double %res4594, double* %dPtr
; setup loop
%val4597 = load i64, i64* %nrowsPtr
store i64 0, i64* %iPtr
%val4622 = load i64, i64* %iPtr
%num4623 = add i64 %val4597, %val4622
%comp4624 = icmp ult i64 %val4597, 1
br i1 %comp4624, label %after4595, label %loop4595

loop4595:
; setup loop
%val4600 = load i64, i64* %nrowsPtr
store i64 0, i64* %jPtr
%val4618 = load i64, i64* %jPtr
%num4619 = add i64 %val4600, %val4618
%comp4620 = icmp ult i64 %val4600, 1
br i1 %comp4620, label %after4598, label %loop4598

loop4598:
%val4601 = load i64, i64* %iPtr
%val4602 = load i64, i64* %nrowsPtr
%val4603 = mul i64 %val4601, %val4602
%val4604 = load i64, i64* %jPtr
%val4605 = add i64 %val4603, %val4604
%val4606 = load double*, double** %resultPtr
%val4607 = load i64, i64* %iPtr
%val4608 = load i64, i64* %nrowsPtr
%val4609 = mul i64 %val4607, %val4608
%val4610 = load i64, i64* %jPtr
%val4611 = add i64 %val4609, %val4610
%val4612 = load double*, double** %m2Ptr
; pointer ref
%val4613 = getelementptr double, double* %val4612, i64 %val4611
%val4614 = load double, double* %val4613
%val4615 = load double, double* %dPtr
%val4616 = fdiv double %val4614, %val4615
; set pointer
%val4617 = getelementptr double, double* %val4606, i64 %val4605
store double %val4616, double* %val4617
%loop_cnt4598 = load i64, i64* %jPtr
%next4598 = add i64 %loop_cnt4598, 1
store i64 %next4598, i64* %jPtr
%cmp4598 = icmp ult i64 %next4598, %num4619
br i1 %cmp4598, label %loop4598, label %after4598

after4598:
%loop_cnt4595 = load i64, i64* %iPtr
%next4595 = add i64 %loop_cnt4595, 1
store i64 %next4595, i64* %iPtr
%cmp4595 = icmp ult i64 %next4595, %num4623
br i1 %cmp4595, label %loop4595, label %after4595

after4595:
ret void
}
@gsxtmmath191 = hidden constant [104 x i8] c"minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** @minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4648 = load i8*, i8** %_impzPtr
%zone4649 = bitcast i8* %tzone4648 to %mzone*

; let assign value to symbol minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0
%dat_minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0 = call i8* @llvm_zone_malloc(%mzone* %zone4649, i64 8)
%minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0Ptr = bitcast i8* %dat_minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0 to { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***
%tzone4629 = load i8*, i8** %_impzPtr
%zone4630 = bitcast i8* %tzone4629 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4630)
; malloc closure structure
%clsptr4631 = call i8* @llvm_zone_malloc(%mzone* %zone4630, i64 24)
%closure4632 = bitcast i8* %clsptr4631 to { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*

; malloc environment structure
%envptr4633 = call i8* @llvm_zone_malloc(%mzone* %zone4630, i64 8)
%environment4634 = bitcast i8* %envptr4633 to {{i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***}*

; malloc closure address table
%addytable4635 = call %clsvar* @new_address_table()
%var4636 = bitcast [51 x i8]* @gsxtmmath190 to i8*
%var4637 = bitcast [54 x i8]* @gsxtmmath76 to i8*
%addytable4638 = call %clsvar* @add_address_table(%mzone* %zone4630, i8* %var4636, i32 0, i8* %var4637, i32 3, %clsvar* %addytable4635)
%address-table4639 = bitcast %clsvar* %addytable4638 to i8*

; insert table, function and environment into closure struct
%closure.table4642 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure4632, i32 0, i32 0
store i8* %address-table4639, i8** %closure.table4642
%closure.env4643 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure4632, i32 0, i32 1
store i8* %envptr4633, i8** %closure.env4643
%closure.func4644 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure4632, i32 0, i32 2
store void (i8*, i8*, double*, i64, double*)* @minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0__4440, void (i8*, i8*, double*, i64, double*)** %closure.func4644
%closure_size4645 = call i64 @llvm_zone_mark_size(%mzone* %zone4630)
call void @llvm_zone_ptr_set_size(i8* %clsptr4631, i64 %closure_size4645)
%wrapper_ptr4646 = call i8* @llvm_zone_malloc(%mzone* %zone4630, i64 8)
%closure_wrapper4647 = bitcast i8* %wrapper_ptr4646 to { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**
store { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure4632, { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure_wrapper4647

; let value assignment
%minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure_wrapper4647, { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure_wrapper4647
store { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0, { i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*** %minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0Ptr

; add data to environment
; don't need to alloc for env var minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0
%tmp_envptr4641 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64, double*)*}***}* %environment4634, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*** %minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0Ptr, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**** %tmp_envptr4641


%val4650 = load {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*** %minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0Ptr
ret {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %val4650
}


@minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var = dllexport global [1 x i8*] [ i8* null ]

@minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** @minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0(double* %arg_0,i64 %arg_1,double* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, double*)*,  void (i8*, i8*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, double* %arg_2)
ret void
}


define dllexport ccc void @minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_native(double* %arg_0,i64 %arg_1,double* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, double*)*,  void (i8*, i8*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, double* %arg_2)
ret void
}


define dllexport ccc i8*  @minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4651 = bitcast [104 x i8]* @gsxtmmath191 to i8*
call i32 (i8*, ...) @printf(i8* %var4651)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4652 = bitcast [104 x i8]* @gsxtmmath191 to i8*
call i32 (i8*, ...) @printf(i8* %var4652)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4653 = bitcast [104 x i8]* @gsxtmmath191 to i8*
call i32 (i8*, ...) @printf(i8* %var4653)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to double*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, double*)*,  void (i8*, i8*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, double* %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, i64, double*}*
%arg_p_0 = getelementptr {double*, i64, double*}, {double*, i64, double*}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, i64, double*}, {double*, i64, double*}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {double*, i64, double*}, {double*, i64, double*}* %fstruct, i32 0, i32 2
%arg_2 = load double*, double** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @minverse_adhoc_W3ZvaWQsZG91YmxlKixpNjQsZG91YmxlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, double*)*,  void (i8*, i8*, double*, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, double* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath192 = hidden constant [51 x i8] c"mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ\00"
@gsxtmmath193 = hidden constant [57 x i8] c"{i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}**\00"
define dllexport fastcc void @mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ__4654(i8* %_impz,i8* %_impenv, float* %src, i64 %row, i64 %col, float* %dest) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4655 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}***}*
%mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}***}* %impenv, i32 0, i32 0
%mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQPtr = load {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}**** %mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQPtr_

; setup arguments
%srcPtr = alloca float*
store float* %src, float** %srcPtr
%rowPtr = alloca i64
store i64 %row, i64* %rowPtr
%colPtr = alloca i64
store i64 %col, i64* %colPtr
%destPtr = alloca float*
store float* %dest, float** %destPtr


%val4656 = load float*, float** %destPtr
%val4657 = bitcast float* %val4656 to i8*
%val4658 = load float*, float** %srcPtr
%val4659 = bitcast float* %val4658 to i8*
%val4660 = load i64, i64* %rowPtr
%val4661 = load i64, i64* %colPtr
%val4662 = mul i64 %val4660, %val4661
%val4663 = mul i64 %val4662, 4
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val4657, i8* %val4659, i64 %val4663, i32 1, i1 0)
ret void
}
@gsxtmmath194 = hidden constant [104 x i8] c"mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}** @mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4685 = load i8*, i8** %_impzPtr
%zone4686 = bitcast i8* %tzone4685 to %mzone*

; let assign value to symbol mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ
%dat_mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone4686, i64 8)
%mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQPtr = bitcast i8* %dat_mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ to { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}***
%tzone4666 = load i8*, i8** %_impzPtr
%zone4667 = bitcast i8* %tzone4666 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4667)
; malloc closure structure
%clsptr4668 = call i8* @llvm_zone_malloc(%mzone* %zone4667, i64 24)
%closure4669 = bitcast i8* %clsptr4668 to { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}*

; malloc environment structure
%envptr4670 = call i8* @llvm_zone_malloc(%mzone* %zone4667, i64 8)
%environment4671 = bitcast i8* %envptr4670 to {{i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}***}*

; malloc closure address table
%addytable4672 = call %clsvar* @new_address_table()
%var4673 = bitcast [51 x i8]* @gsxtmmath192 to i8*
%var4674 = bitcast [57 x i8]* @gsxtmmath193 to i8*
%addytable4675 = call %clsvar* @add_address_table(%mzone* %zone4667, i8* %var4673, i32 0, i8* %var4674, i32 3, %clsvar* %addytable4672)
%address-table4676 = bitcast %clsvar* %addytable4675 to i8*

; insert table, function and environment into closure struct
%closure.table4679 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}* %closure4669, i32 0, i32 0
store i8* %address-table4676, i8** %closure.table4679
%closure.env4680 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}* %closure4669, i32 0, i32 1
store i8* %envptr4670, i8** %closure.env4680
%closure.func4681 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}, { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}* %closure4669, i32 0, i32 2
store void (i8*, i8*, float*, i64, i64, float*)* @mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ__4654, void (i8*, i8*, float*, i64, i64, float*)** %closure.func4681
%closure_size4682 = call i64 @llvm_zone_mark_size(%mzone* %zone4667)
call void @llvm_zone_ptr_set_size(i8* %clsptr4668, i64 %closure_size4682)
%wrapper_ptr4683 = call i8* @llvm_zone_malloc(%mzone* %zone4667, i64 8)
%closure_wrapper4684 = bitcast i8* %wrapper_ptr4683 to { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}* %closure4669, { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}** %closure_wrapper4684

; let value assignment
%mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}** %closure_wrapper4684, { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}** %closure_wrapper4684
store { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}** %mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ, { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}*** %mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQPtr

; add data to environment
; don't need to alloc for env var mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ
%tmp_envptr4678 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}***}* %environment4671, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}*** %mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQPtr, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}**** %tmp_envptr4678


%val4687 = load {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}*** %mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQPtr
ret {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}** %val4687
}


@mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}** @mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ(float* %arg_0,i64 %arg_1,i64 %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, i64, float*)*,  void (i8*, i8*, float*, i64, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2, float* %arg_3)
ret void
}


define dllexport ccc void @mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ_native(float* %arg_0,i64 %arg_1,i64 %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, i64, float*)*,  void (i8*, i8*, float*, i64, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2, float* %arg_3)
ret void
}


define dllexport ccc i8*  @mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4688 = bitcast [104 x i8]* @gsxtmmath194 to i8*
call i32 (i8*, ...) @printf(i8* %var4688)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4689 = bitcast [104 x i8]* @gsxtmmath194 to i8*
call i32 (i8*, ...) @printf(i8* %var4689)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4690 = bitcast [104 x i8]* @gsxtmmath194 to i8*
call i32 (i8*, ...) @printf(i8* %var4690)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var4691 = bitcast [104 x i8]* @gsxtmmath194 to i8*
call i32 (i8*, ...) @printf(i8* %var4691)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, i64, float*)*,  void (i8*, i8*, float*, i64, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2, float* %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64, i64, float*}*
%arg_p_0 = getelementptr {float*, i64, i64, float*}, {float*, i64, i64, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64, i64, float*}, {float*, i64, i64, float*}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {float*, i64, i64, float*}, {float*, i64, i64, float*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {float*, i64, i64, float*}, {float*, i64, i64, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, i64, float*)*,  void (i8*, i8*, float*, i64, i64, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2, float* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath195 = hidden constant [53 x i8] c"mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd\00"
@gsxtmmath196 = hidden constant [59 x i8] c"{i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}**\00"
define dllexport fastcc void @mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd__4692(i8* %_impz,i8* %_impenv, double* %src, i64 %row, i64 %col, double* %dest) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4693 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}***}*
%mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}***}* %impenv, i32 0, i32 0
%mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpdPtr = load {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}***, {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}**** %mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpdPtr_

; setup arguments
%srcPtr = alloca double*
store double* %src, double** %srcPtr
%rowPtr = alloca i64
store i64 %row, i64* %rowPtr
%colPtr = alloca i64
store i64 %col, i64* %colPtr
%destPtr = alloca double*
store double* %dest, double** %destPtr


%val4694 = load double*, double** %destPtr
%val4695 = bitcast double* %val4694 to i8*
%val4696 = load double*, double** %srcPtr
%val4697 = bitcast double* %val4696 to i8*
%val4698 = load i64, i64* %rowPtr
%val4699 = load i64, i64* %colPtr
%val4700 = mul i64 %val4698, %val4699
%val4701 = mul i64 %val4700, 8
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val4695, i8* %val4697, i64 %val4701, i32 1, i1 0)
ret void
}
@gsxtmmath197 = hidden constant [106 x i8] c"mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}** @mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4723 = load i8*, i8** %_impzPtr
%zone4724 = bitcast i8* %tzone4723 to %mzone*

; let assign value to symbol mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd
%dat_mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd = call i8* @llvm_zone_malloc(%mzone* %zone4724, i64 8)
%mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpdPtr = bitcast i8* %dat_mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd to { i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}***
%tzone4704 = load i8*, i8** %_impzPtr
%zone4705 = bitcast i8* %tzone4704 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4705)
; malloc closure structure
%clsptr4706 = call i8* @llvm_zone_malloc(%mzone* %zone4705, i64 24)
%closure4707 = bitcast i8* %clsptr4706 to { i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}*

; malloc environment structure
%envptr4708 = call i8* @llvm_zone_malloc(%mzone* %zone4705, i64 8)
%environment4709 = bitcast i8* %envptr4708 to {{i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}***}*

; malloc closure address table
%addytable4710 = call %clsvar* @new_address_table()
%var4711 = bitcast [53 x i8]* @gsxtmmath195 to i8*
%var4712 = bitcast [59 x i8]* @gsxtmmath196 to i8*
%addytable4713 = call %clsvar* @add_address_table(%mzone* %zone4705, i8* %var4711, i32 0, i8* %var4712, i32 3, %clsvar* %addytable4710)
%address-table4714 = bitcast %clsvar* %addytable4713 to i8*

; insert table, function and environment into closure struct
%closure.table4717 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}* %closure4707, i32 0, i32 0
store i8* %address-table4714, i8** %closure.table4717
%closure.env4718 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}* %closure4707, i32 0, i32 1
store i8* %envptr4708, i8** %closure.env4718
%closure.func4719 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}, { i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}* %closure4707, i32 0, i32 2
store void (i8*, i8*, double*, i64, i64, double*)* @mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd__4692, void (i8*, i8*, double*, i64, i64, double*)** %closure.func4719
%closure_size4720 = call i64 @llvm_zone_mark_size(%mzone* %zone4705)
call void @llvm_zone_ptr_set_size(i8* %clsptr4706, i64 %closure_size4720)
%wrapper_ptr4721 = call i8* @llvm_zone_malloc(%mzone* %zone4705, i64 8)
%closure_wrapper4722 = bitcast i8* %wrapper_ptr4721 to { i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}**
store { i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}* %closure4707, { i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}** %closure_wrapper4722

; let value assignment
%mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd = select i1 true, { i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}** %closure_wrapper4722, { i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}** %closure_wrapper4722
store { i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}** %mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd, { i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}*** %mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpdPtr

; add data to environment
; don't need to alloc for env var mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd
%tmp_envptr4716 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}***}* %environment4709, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}*** %mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpdPtr, {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}**** %tmp_envptr4716


%val4725 = load {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}**, {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}*** %mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpdPtr
ret {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}** %val4725
}


@mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}** @mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd(double* %arg_0,i64 %arg_1,i64 %arg_2,double* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, i64, double*)*,  void (i8*, i8*, double*, i64, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2, double* %arg_3)
ret void
}


define dllexport ccc void @mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_native(double* %arg_0,i64 %arg_1,i64 %arg_2,double* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, i64, double*)*,  void (i8*, i8*, double*, i64, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2, double* %arg_3)
ret void
}


define dllexport ccc i8*  @mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4726 = bitcast [106 x i8]* @gsxtmmath197 to i8*
call i32 (i8*, ...) @printf(i8* %var4726)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4727 = bitcast [106 x i8]* @gsxtmmath197 to i8*
call i32 (i8*, ...) @printf(i8* %var4727)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4728 = bitcast [106 x i8]* @gsxtmmath197 to i8*
call i32 (i8*, ...) @printf(i8* %var4728)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var4729 = bitcast [106 x i8]* @gsxtmmath197 to i8*
call i32 (i8*, ...) @printf(i8* %var4729)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to double*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, i64, double*)*,  void (i8*, i8*, double*, i64, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2, double* %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, i64, i64, double*}*
%arg_p_0 = getelementptr {double*, i64, i64, double*}, {double*, i64, i64, double*}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, i64, i64, double*}, {double*, i64, i64, double*}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {double*, i64, i64, double*}, {double*, i64, i64, double*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {double*, i64, i64, double*}, {double*, i64, i64, double*}* %fstruct, i32 0, i32 3
%arg_3 = load double*, double** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mcopy_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0LGRvdWJsZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64, double*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, i64, double*)*,  void (i8*, i8*, double*, i64, i64, double*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2, double* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath198 = hidden constant [54 x i8] c"varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ\00"
@gsxtmmath199 = hidden constant [56 x i8] c"{i8*, i8*, float* (i8*, i8*, float*, float, float*)*}**\00"
define dllexport fastcc float* @varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ__4730(i8* %_impz,i8* %_impenv, float* %axis, float %theta, float* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4731 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float* (i8*, i8*, float*, float, float*)*}***}*
%varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, float* (i8*, i8*, float*, float, float*)*}***}, {{i8*, i8*, float* (i8*, i8*, float*, float, float*)*}***}* %impenv, i32 0, i32 0
%varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQPtr = load {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}***, {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}**** %varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQPtr_

; setup arguments
%axisPtr = alloca float*
store float* %axis, float** %axisPtr
%thetaPtr = alloca float
store float %theta, float* %thetaPtr
%resultPtr = alloca float*
store float* %result, float** %resultPtr


%tzone4735 = load i8*, i8** %_impzPtr
%zone4736 = bitcast i8* %tzone4735 to %mzone*

; let assign value to symbol x
%xPtr = alloca float
%tzone4740 = load i8*, i8** %_impzPtr
%zone4741 = bitcast i8* %tzone4740 to %mzone*

; let assign value to symbol y
%yPtr = alloca float
%tzone4745 = load i8*, i8** %_impzPtr
%zone4746 = bitcast i8* %tzone4745 to %mzone*

; let assign value to symbol z
%zPtr = alloca float
%tzone4749 = load i8*, i8** %_impzPtr
%zone4750 = bitcast i8* %tzone4749 to %mzone*

; let assign value to symbol cost
%costPtr = alloca float
%tzone4753 = load i8*, i8** %_impzPtr
%zone4754 = bitcast i8* %tzone4753 to %mzone*

; let assign value to symbol sint
%sintPtr = alloca float
%tzone4757 = load i8*, i8** %_impzPtr
%zone4758 = bitcast i8* %tzone4757 to %mzone*

; let assign value to symbol mcost
%mcostPtr = alloca float
%val4732 = load float*, float** %axisPtr
; pointer ref
%val4733 = getelementptr float, float* %val4732, i64 0
%val4734 = load float, float* %val4733

; let value assignment
%x = select i1 true, float %val4734, float %val4734
store float %x, float* %xPtr

%val4737 = load float*, float** %axisPtr
; pointer ref
%val4738 = getelementptr float, float* %val4737, i64 1
%val4739 = load float, float* %val4738

; let value assignment
%y = select i1 true, float %val4739, float %val4739
store float %y, float* %yPtr

%val4742 = load float*, float** %axisPtr
; pointer ref
%val4743 = getelementptr float, float* %val4742, i64 2
%val4744 = load float, float* %val4743

; let value assignment
%z = select i1 true, float %val4744, float %val4744
store float %z, float* %zPtr

%val4747 = load float, float* %thetaPtr
%val4748 = call float @llvm.cos.f32(float %val4747)

; let value assignment
%cost = select i1 true, float %val4748, float %val4748
store float %cost, float* %costPtr

%val4751 = load float, float* %thetaPtr
%val4752 = call float @llvm.sin.f32(float %val4751)

; let value assignment
%sint = select i1 true, float %val4752, float %val4752
store float %sint, float* %sintPtr

%val4755 = load float, float* %costPtr
%val4756 = fsub float 0x3ff0000000000000, %val4755

; let value assignment
%mcost = select i1 true, float %val4756, float %val4756
store float %mcost, float* %mcostPtr

%val4759 = load float*, float** %resultPtr
%val4760 = load float, float* %costPtr
%val4761 = load float, float* %xPtr
%val4762 = load float, float* %xPtr
%val4763 = fmul float %val4761, %val4762
%val4764 = load float, float* %mcostPtr
%val4765 = fmul float %val4763, %val4764
%val4766 = fadd float %val4760, %val4765
; set pointer
%val4767 = getelementptr float, float* %val4759, i64 0
store float %val4766, float* %val4767
%val4768 = load float*, float** %resultPtr
%val4769 = load float, float* %yPtr
%val4770 = load float, float* %xPtr
%val4771 = fmul float %val4769, %val4770
%val4772 = load float, float* %mcostPtr
%val4773 = fmul float %val4771, %val4772
%val4774 = load float, float* %zPtr
%val4775 = load float, float* %sintPtr
%val4776 = fmul float %val4774, %val4775
%val4777 = fadd float %val4773, %val4776
; set pointer
%val4778 = getelementptr float, float* %val4768, i64 1
store float %val4777, float* %val4778
%val4779 = load float*, float** %resultPtr
%val4780 = load float, float* %zPtr
%val4781 = load float, float* %xPtr
%val4782 = fmul float %val4780, %val4781
%val4783 = load float, float* %mcostPtr
%val4784 = fmul float %val4782, %val4783
%val4785 = load float, float* %yPtr
%val4786 = load float, float* %sintPtr
%val4787 = fmul float %val4785, %val4786
%val4788 = fsub float %val4784, %val4787
; set pointer
%val4789 = getelementptr float, float* %val4779, i64 2
store float %val4788, float* %val4789
%val4790 = load float*, float** %resultPtr
; set pointer
%val4791 = getelementptr float, float* %val4790, i64 3
store float 0x0, float* %val4791
%val4792 = load float*, float** %resultPtr
%val4793 = load float, float* %xPtr
%val4794 = load float, float* %yPtr
%val4795 = fmul float %val4793, %val4794
%val4796 = load float, float* %mcostPtr
%val4797 = fmul float %val4795, %val4796
%val4798 = load float, float* %zPtr
%val4799 = load float, float* %sintPtr
%val4800 = fmul float %val4798, %val4799
%val4801 = fsub float %val4797, %val4800
; set pointer
%val4802 = getelementptr float, float* %val4792, i64 4
store float %val4801, float* %val4802
%val4803 = load float*, float** %resultPtr
%val4804 = load float, float* %costPtr
%val4805 = load float, float* %yPtr
%val4806 = load float, float* %yPtr
%val4807 = fmul float %val4805, %val4806
%val4808 = load float, float* %mcostPtr
%val4809 = fmul float %val4807, %val4808
%val4810 = fadd float %val4804, %val4809
; set pointer
%val4811 = getelementptr float, float* %val4803, i64 5
store float %val4810, float* %val4811
%val4812 = load float*, float** %resultPtr
%val4813 = load float, float* %zPtr
%val4814 = load float, float* %yPtr
%val4815 = fmul float %val4813, %val4814
%val4816 = load float, float* %mcostPtr
%val4817 = fmul float %val4815, %val4816
%val4818 = load float, float* %xPtr
%val4819 = load float, float* %sintPtr
%val4820 = fmul float %val4818, %val4819
%val4821 = fadd float %val4817, %val4820
; set pointer
%val4822 = getelementptr float, float* %val4812, i64 6
store float %val4821, float* %val4822
%val4823 = load float*, float** %resultPtr
; set pointer
%val4824 = getelementptr float, float* %val4823, i64 7
store float 0x0, float* %val4824
%val4825 = load float*, float** %resultPtr
%val4826 = load float, float* %xPtr
%val4827 = load float, float* %zPtr
%val4828 = fmul float %val4826, %val4827
%val4829 = load float, float* %mcostPtr
%val4830 = fmul float %val4828, %val4829
%val4831 = load float, float* %yPtr
%val4832 = load float, float* %sintPtr
%val4833 = fmul float %val4831, %val4832
%val4834 = fadd float %val4830, %val4833
; set pointer
%val4835 = getelementptr float, float* %val4825, i64 8
store float %val4834, float* %val4835
%val4836 = load float*, float** %resultPtr
%val4837 = load float, float* %yPtr
%val4838 = load float, float* %zPtr
%val4839 = fmul float %val4837, %val4838
%val4840 = load float, float* %mcostPtr
%val4841 = fmul float %val4839, %val4840
%val4842 = load float, float* %xPtr
%val4843 = load float, float* %sintPtr
%val4844 = fmul float %val4842, %val4843
%val4845 = fsub float %val4841, %val4844
; set pointer
%val4846 = getelementptr float, float* %val4836, i64 9
store float %val4845, float* %val4846
%val4847 = load float*, float** %resultPtr
%val4848 = load float, float* %costPtr
%val4849 = load float, float* %zPtr
%val4850 = load float, float* %zPtr
%val4851 = fmul float %val4849, %val4850
%val4852 = load float, float* %mcostPtr
%val4853 = fmul float %val4851, %val4852
%val4854 = fadd float %val4848, %val4853
; set pointer
%val4855 = getelementptr float, float* %val4847, i64 10
store float %val4854, float* %val4855
%val4856 = load float*, float** %resultPtr
; set pointer
%val4857 = getelementptr float, float* %val4856, i64 11
store float 0x0, float* %val4857
%val4858 = load float*, float** %resultPtr
; set pointer
%val4859 = getelementptr float, float* %val4858, i64 12
store float 0x0, float* %val4859
%val4860 = load float*, float** %resultPtr
; set pointer
%val4861 = getelementptr float, float* %val4860, i64 13
store float 0x0, float* %val4861
%val4862 = load float*, float** %resultPtr
; set pointer
%val4863 = getelementptr float, float* %val4862, i64 14
store float 0x0, float* %val4863
%val4864 = load float*, float** %resultPtr
; set pointer
%val4865 = getelementptr float, float* %val4864, i64 15
store float 0x3ff0000000000000, float* %val4865
%val4866 = load float*, float** %resultPtr
ret float* %val4866
}
@gsxtmmath200 = hidden constant [107 x i8] c"varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}** @varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4886 = load i8*, i8** %_impzPtr
%zone4887 = bitcast i8* %tzone4886 to %mzone*

; let assign value to symbol varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ
%dat_varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone4887, i64 8)
%varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQPtr = bitcast i8* %dat_varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ to { i8*, i8*, float* (i8*, i8*, float*, float, float*)*}***
%tzone4867 = load i8*, i8** %_impzPtr
%zone4868 = bitcast i8* %tzone4867 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4868)
; malloc closure structure
%clsptr4869 = call i8* @llvm_zone_malloc(%mzone* %zone4868, i64 24)
%closure4870 = bitcast i8* %clsptr4869 to { i8*, i8*, float* (i8*, i8*, float*, float, float*)*}*

; malloc environment structure
%envptr4871 = call i8* @llvm_zone_malloc(%mzone* %zone4868, i64 8)
%environment4872 = bitcast i8* %envptr4871 to {{i8*, i8*, float* (i8*, i8*, float*, float, float*)*}***}*

; malloc closure address table
%addytable4873 = call %clsvar* @new_address_table()
%var4874 = bitcast [54 x i8]* @gsxtmmath198 to i8*
%var4875 = bitcast [56 x i8]* @gsxtmmath199 to i8*
%addytable4876 = call %clsvar* @add_address_table(%mzone* %zone4868, i8* %var4874, i32 0, i8* %var4875, i32 3, %clsvar* %addytable4873)
%address-table4877 = bitcast %clsvar* %addytable4876 to i8*

; insert table, function and environment into closure struct
%closure.table4880 = getelementptr { i8*, i8*, float* (i8*, i8*, float*, float, float*)*}, { i8*, i8*, float* (i8*, i8*, float*, float, float*)*}* %closure4870, i32 0, i32 0
store i8* %address-table4877, i8** %closure.table4880
%closure.env4881 = getelementptr { i8*, i8*, float* (i8*, i8*, float*, float, float*)*}, { i8*, i8*, float* (i8*, i8*, float*, float, float*)*}* %closure4870, i32 0, i32 1
store i8* %envptr4871, i8** %closure.env4881
%closure.func4882 = getelementptr { i8*, i8*, float* (i8*, i8*, float*, float, float*)*}, { i8*, i8*, float* (i8*, i8*, float*, float, float*)*}* %closure4870, i32 0, i32 2
store float* (i8*, i8*, float*, float, float*)* @varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ__4730, float* (i8*, i8*, float*, float, float*)** %closure.func4882
%closure_size4883 = call i64 @llvm_zone_mark_size(%mzone* %zone4868)
call void @llvm_zone_ptr_set_size(i8* %clsptr4869, i64 %closure_size4883)
%wrapper_ptr4884 = call i8* @llvm_zone_malloc(%mzone* %zone4868, i64 8)
%closure_wrapper4885 = bitcast i8* %wrapper_ptr4884 to { i8*, i8*, float* (i8*, i8*, float*, float, float*)*}**
store { i8*, i8*, float* (i8*, i8*, float*, float, float*)*}* %closure4870, { i8*, i8*, float* (i8*, i8*, float*, float, float*)*}** %closure_wrapper4885

; let value assignment
%varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ = select i1 true, { i8*, i8*, float* (i8*, i8*, float*, float, float*)*}** %closure_wrapper4885, { i8*, i8*, float* (i8*, i8*, float*, float, float*)*}** %closure_wrapper4885
store { i8*, i8*, float* (i8*, i8*, float*, float, float*)*}** %varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ, { i8*, i8*, float* (i8*, i8*, float*, float, float*)*}*** %varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQPtr

; add data to environment
; don't need to alloc for env var varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ
%tmp_envptr4879 = getelementptr {{i8*, i8*, float* (i8*, i8*, float*, float, float*)*}***}, {{i8*, i8*, float* (i8*, i8*, float*, float, float*)*}***}* %environment4872, i32 0, i32 0
store {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}*** %varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQPtr, {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}**** %tmp_envptr4879


%val4888 = load {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}**, {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}*** %varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQPtr
ret {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}** %val4888
}


@varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}** @varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float* @varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ(float* %arg_0,float %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}**
%closure = load {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}*, {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}* %closure, i32 0, i32 1
%ff = load  float* (i8*, i8*, float*, float, float*)*,  float* (i8*, i8*, float*, float, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float* %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float* %arg_2)
ret float* %result
}


define dllexport ccc float* @varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ_native(float* %arg_0,float %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}**
%closure = load {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}*, {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}* %closure, i32 0, i32 1
%ff = load  float* (i8*, i8*, float*, float, float*)*,  float* (i8*, i8*, float*, float, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float* %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float* %arg_2)
ret float* %result
}


define dllexport ccc i8*  @varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4889 = bitcast [107 x i8]* @gsxtmmath200 to i8*
call i32 (i8*, ...) @printf(i8* %var4889)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4890 = bitcast [107 x i8]* @gsxtmmath200 to i8*
call i32 (i8*, ...) @printf(i8* %var4890)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4891 = bitcast [107 x i8]* @gsxtmmath200 to i8*
call i32 (i8*, ...) @printf(i8* %var4891)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}**
%closure = load {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}*, {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}* %closure, i32 0, i32 1
%ff = load  float* (i8*, i8*, float*, float, float*)*,  float* (i8*, i8*, float*, float, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float* %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float* %arg_2)
%tmpres = bitcast float* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float, float*}*
%arg_p_0 = getelementptr {float*, float, float*}, {float*, float, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float, float*}, {float*, float, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float*, float, float*}, {float*, float, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @varotate_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}**
%closure = load {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}*, {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}, {i8*, i8*, float* (i8*, i8*, float*, float, float*)*}* %closure, i32 0, i32 1
%ff = load  float* (i8*, i8*, float*, float, float*)*,  float* (i8*, i8*, float*, float, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float* %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath201 = hidden constant [59 x i8] c"varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0\00"
@gsxtmmath202 = hidden constant [60 x i8] c"{i8*, i8*, double* (i8*, i8*, double*, double, double*)*}**\00"
define dllexport fastcc double* @varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0__4892(i8* %_impz,i8* %_impenv, double* %axis, double %theta, double* %result) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4893 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double* (i8*, i8*, double*, double, double*)*}***}*
%varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0Ptr_ = getelementptr {{i8*, i8*, double* (i8*, i8*, double*, double, double*)*}***}, {{i8*, i8*, double* (i8*, i8*, double*, double, double*)*}***}* %impenv, i32 0, i32 0
%varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0Ptr = load {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}***, {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}**** %varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0Ptr_

; setup arguments
%axisPtr = alloca double*
store double* %axis, double** %axisPtr
%thetaPtr = alloca double
store double %theta, double* %thetaPtr
%resultPtr = alloca double*
store double* %result, double** %resultPtr


%tzone4897 = load i8*, i8** %_impzPtr
%zone4898 = bitcast i8* %tzone4897 to %mzone*

; let assign value to symbol x
%xPtr = alloca double
%tzone4902 = load i8*, i8** %_impzPtr
%zone4903 = bitcast i8* %tzone4902 to %mzone*

; let assign value to symbol y
%yPtr = alloca double
%tzone4907 = load i8*, i8** %_impzPtr
%zone4908 = bitcast i8* %tzone4907 to %mzone*

; let assign value to symbol z
%zPtr = alloca double
%tzone4911 = load i8*, i8** %_impzPtr
%zone4912 = bitcast i8* %tzone4911 to %mzone*

; let assign value to symbol cost
%costPtr = alloca double
%tzone4915 = load i8*, i8** %_impzPtr
%zone4916 = bitcast i8* %tzone4915 to %mzone*

; let assign value to symbol sint
%sintPtr = alloca double
%tzone4919 = load i8*, i8** %_impzPtr
%zone4920 = bitcast i8* %tzone4919 to %mzone*

; let assign value to symbol mcost
%mcostPtr = alloca double
%val4894 = load double*, double** %axisPtr
; pointer ref
%val4895 = getelementptr double, double* %val4894, i64 0
%val4896 = load double, double* %val4895

; let value assignment
%x = select i1 true, double %val4896, double %val4896
store double %x, double* %xPtr

%val4899 = load double*, double** %axisPtr
; pointer ref
%val4900 = getelementptr double, double* %val4899, i64 1
%val4901 = load double, double* %val4900

; let value assignment
%y = select i1 true, double %val4901, double %val4901
store double %y, double* %yPtr

%val4904 = load double*, double** %axisPtr
; pointer ref
%val4905 = getelementptr double, double* %val4904, i64 2
%val4906 = load double, double* %val4905

; let value assignment
%z = select i1 true, double %val4906, double %val4906
store double %z, double* %zPtr

%val4909 = load double, double* %thetaPtr
%val4910 = call double @llvm.cos.f64(double %val4909)

; let value assignment
%cost = select i1 true, double %val4910, double %val4910
store double %cost, double* %costPtr

%val4913 = load double, double* %thetaPtr
%val4914 = call double @llvm.sin.f64(double %val4913)

; let value assignment
%sint = select i1 true, double %val4914, double %val4914
store double %sint, double* %sintPtr

%val4917 = load double, double* %costPtr
%val4918 = fsub double 1.0000000000000000000, %val4917

; let value assignment
%mcost = select i1 true, double %val4918, double %val4918
store double %mcost, double* %mcostPtr

%val4921 = load double*, double** %resultPtr
%val4922 = load double, double* %costPtr
%val4923 = load double, double* %xPtr
%val4924 = load double, double* %xPtr
%val4925 = fmul double %val4923, %val4924
%val4926 = load double, double* %mcostPtr
%val4927 = fmul double %val4925, %val4926
%val4928 = fadd double %val4922, %val4927
; set pointer
%val4929 = getelementptr double, double* %val4921, i64 0
store double %val4928, double* %val4929
%val4930 = load double*, double** %resultPtr
%val4931 = load double, double* %yPtr
%val4932 = load double, double* %xPtr
%val4933 = fmul double %val4931, %val4932
%val4934 = load double, double* %mcostPtr
%val4935 = fmul double %val4933, %val4934
%val4936 = load double, double* %zPtr
%val4937 = load double, double* %sintPtr
%val4938 = fmul double %val4936, %val4937
%val4939 = fadd double %val4935, %val4938
; set pointer
%val4940 = getelementptr double, double* %val4930, i64 1
store double %val4939, double* %val4940
%val4941 = load double*, double** %resultPtr
%val4942 = load double, double* %zPtr
%val4943 = load double, double* %xPtr
%val4944 = fmul double %val4942, %val4943
%val4945 = load double, double* %mcostPtr
%val4946 = fmul double %val4944, %val4945
%val4947 = load double, double* %yPtr
%val4948 = load double, double* %sintPtr
%val4949 = fmul double %val4947, %val4948
%val4950 = fsub double %val4946, %val4949
; set pointer
%val4951 = getelementptr double, double* %val4941, i64 2
store double %val4950, double* %val4951
%val4952 = load double*, double** %resultPtr
; set pointer
%val4953 = getelementptr double, double* %val4952, i64 3
store double 0.00000000000000000000, double* %val4953
%val4954 = load double*, double** %resultPtr
%val4955 = load double, double* %xPtr
%val4956 = load double, double* %yPtr
%val4957 = fmul double %val4955, %val4956
%val4958 = load double, double* %mcostPtr
%val4959 = fmul double %val4957, %val4958
%val4960 = load double, double* %zPtr
%val4961 = load double, double* %sintPtr
%val4962 = fmul double %val4960, %val4961
%val4963 = fsub double %val4959, %val4962
; set pointer
%val4964 = getelementptr double, double* %val4954, i64 4
store double %val4963, double* %val4964
%val4965 = load double*, double** %resultPtr
%val4966 = load double, double* %costPtr
%val4967 = load double, double* %yPtr
%val4968 = load double, double* %yPtr
%val4969 = fmul double %val4967, %val4968
%val4970 = load double, double* %mcostPtr
%val4971 = fmul double %val4969, %val4970
%val4972 = fadd double %val4966, %val4971
; set pointer
%val4973 = getelementptr double, double* %val4965, i64 5
store double %val4972, double* %val4973
%val4974 = load double*, double** %resultPtr
%val4975 = load double, double* %zPtr
%val4976 = load double, double* %yPtr
%val4977 = fmul double %val4975, %val4976
%val4978 = load double, double* %mcostPtr
%val4979 = fmul double %val4977, %val4978
%val4980 = load double, double* %xPtr
%val4981 = load double, double* %sintPtr
%val4982 = fmul double %val4980, %val4981
%val4983 = fadd double %val4979, %val4982
; set pointer
%val4984 = getelementptr double, double* %val4974, i64 6
store double %val4983, double* %val4984
%val4985 = load double*, double** %resultPtr
; set pointer
%val4986 = getelementptr double, double* %val4985, i64 7
store double 0.00000000000000000000, double* %val4986
%val4987 = load double*, double** %resultPtr
%val4988 = load double, double* %xPtr
%val4989 = load double, double* %zPtr
%val4990 = fmul double %val4988, %val4989
%val4991 = load double, double* %mcostPtr
%val4992 = fmul double %val4990, %val4991
%val4993 = load double, double* %yPtr
%val4994 = load double, double* %sintPtr
%val4995 = fmul double %val4993, %val4994
%val4996 = fadd double %val4992, %val4995
; set pointer
%val4997 = getelementptr double, double* %val4987, i64 8
store double %val4996, double* %val4997
%val4998 = load double*, double** %resultPtr
%val4999 = load double, double* %yPtr
%val5000 = load double, double* %zPtr
%val5001 = fmul double %val4999, %val5000
%val5002 = load double, double* %mcostPtr
%val5003 = fmul double %val5001, %val5002
%val5004 = load double, double* %xPtr
%val5005 = load double, double* %sintPtr
%val5006 = fmul double %val5004, %val5005
%val5007 = fsub double %val5003, %val5006
; set pointer
%val5008 = getelementptr double, double* %val4998, i64 9
store double %val5007, double* %val5008
%val5009 = load double*, double** %resultPtr
%val5010 = load double, double* %costPtr
%val5011 = load double, double* %zPtr
%val5012 = load double, double* %zPtr
%val5013 = fmul double %val5011, %val5012
%val5014 = load double, double* %mcostPtr
%val5015 = fmul double %val5013, %val5014
%val5016 = fadd double %val5010, %val5015
; set pointer
%val5017 = getelementptr double, double* %val5009, i64 10
store double %val5016, double* %val5017
%val5018 = load double*, double** %resultPtr
; set pointer
%val5019 = getelementptr double, double* %val5018, i64 11
store double 0.00000000000000000000, double* %val5019
%val5020 = load double*, double** %resultPtr
; set pointer
%val5021 = getelementptr double, double* %val5020, i64 12
store double 0.00000000000000000000, double* %val5021
%val5022 = load double*, double** %resultPtr
; set pointer
%val5023 = getelementptr double, double* %val5022, i64 13
store double 0.00000000000000000000, double* %val5023
%val5024 = load double*, double** %resultPtr
; set pointer
%val5025 = getelementptr double, double* %val5024, i64 14
store double 0.00000000000000000000, double* %val5025
%val5026 = load double*, double** %resultPtr
; set pointer
%val5027 = getelementptr double, double* %val5026, i64 15
store double 1.0000000000000000000, double* %val5027
%val5028 = load double*, double** %resultPtr
ret double* %val5028
}
@gsxtmmath203 = hidden constant [112 x i8] c"varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}** @varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5048 = load i8*, i8** %_impzPtr
%zone5049 = bitcast i8* %tzone5048 to %mzone*

; let assign value to symbol varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0
%dat_varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0 = call i8* @llvm_zone_malloc(%mzone* %zone5049, i64 8)
%varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0Ptr = bitcast i8* %dat_varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0 to { i8*, i8*, double* (i8*, i8*, double*, double, double*)*}***
%tzone5029 = load i8*, i8** %_impzPtr
%zone5030 = bitcast i8* %tzone5029 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5030)
; malloc closure structure
%clsptr5031 = call i8* @llvm_zone_malloc(%mzone* %zone5030, i64 24)
%closure5032 = bitcast i8* %clsptr5031 to { i8*, i8*, double* (i8*, i8*, double*, double, double*)*}*

; malloc environment structure
%envptr5033 = call i8* @llvm_zone_malloc(%mzone* %zone5030, i64 8)
%environment5034 = bitcast i8* %envptr5033 to {{i8*, i8*, double* (i8*, i8*, double*, double, double*)*}***}*

; malloc closure address table
%addytable5035 = call %clsvar* @new_address_table()
%var5036 = bitcast [59 x i8]* @gsxtmmath201 to i8*
%var5037 = bitcast [60 x i8]* @gsxtmmath202 to i8*
%addytable5038 = call %clsvar* @add_address_table(%mzone* %zone5030, i8* %var5036, i32 0, i8* %var5037, i32 3, %clsvar* %addytable5035)
%address-table5039 = bitcast %clsvar* %addytable5038 to i8*

; insert table, function and environment into closure struct
%closure.table5042 = getelementptr { i8*, i8*, double* (i8*, i8*, double*, double, double*)*}, { i8*, i8*, double* (i8*, i8*, double*, double, double*)*}* %closure5032, i32 0, i32 0
store i8* %address-table5039, i8** %closure.table5042
%closure.env5043 = getelementptr { i8*, i8*, double* (i8*, i8*, double*, double, double*)*}, { i8*, i8*, double* (i8*, i8*, double*, double, double*)*}* %closure5032, i32 0, i32 1
store i8* %envptr5033, i8** %closure.env5043
%closure.func5044 = getelementptr { i8*, i8*, double* (i8*, i8*, double*, double, double*)*}, { i8*, i8*, double* (i8*, i8*, double*, double, double*)*}* %closure5032, i32 0, i32 2
store double* (i8*, i8*, double*, double, double*)* @varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0__4892, double* (i8*, i8*, double*, double, double*)** %closure.func5044
%closure_size5045 = call i64 @llvm_zone_mark_size(%mzone* %zone5030)
call void @llvm_zone_ptr_set_size(i8* %clsptr5031, i64 %closure_size5045)
%wrapper_ptr5046 = call i8* @llvm_zone_malloc(%mzone* %zone5030, i64 8)
%closure_wrapper5047 = bitcast i8* %wrapper_ptr5046 to { i8*, i8*, double* (i8*, i8*, double*, double, double*)*}**
store { i8*, i8*, double* (i8*, i8*, double*, double, double*)*}* %closure5032, { i8*, i8*, double* (i8*, i8*, double*, double, double*)*}** %closure_wrapper5047

; let value assignment
%varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0 = select i1 true, { i8*, i8*, double* (i8*, i8*, double*, double, double*)*}** %closure_wrapper5047, { i8*, i8*, double* (i8*, i8*, double*, double, double*)*}** %closure_wrapper5047
store { i8*, i8*, double* (i8*, i8*, double*, double, double*)*}** %varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0, { i8*, i8*, double* (i8*, i8*, double*, double, double*)*}*** %varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0Ptr

; add data to environment
; don't need to alloc for env var varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0
%tmp_envptr5041 = getelementptr {{i8*, i8*, double* (i8*, i8*, double*, double, double*)*}***}, {{i8*, i8*, double* (i8*, i8*, double*, double, double*)*}***}* %environment5034, i32 0, i32 0
store {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}*** %varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0Ptr, {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}**** %tmp_envptr5041


%val5050 = load {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}**, {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}*** %varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0Ptr
ret {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}** %val5050
}


@varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0_var = dllexport global [1 x i8*] [ i8* null ]

@varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}** @varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double* @varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0(double* %arg_0,double %arg_1,double* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}**
%closure = load {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}*, {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}* %closure, i32 0, i32 1
%ff = load  double* (i8*, i8*, double*, double, double*)*,  double* (i8*, i8*, double*, double, double*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double* %ff(i8* %_impz, i8* %ee, double* %arg_0, double %arg_1, double* %arg_2)
ret double* %result
}


define dllexport ccc double* @varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0_native(double* %arg_0,double %arg_1,double* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}**
%closure = load {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}*, {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}* %closure, i32 0, i32 1
%ff = load  double* (i8*, i8*, double*, double, double*)*,  double* (i8*, i8*, double*, double, double*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double* %ff(i8* %_impz, i8* %ee, double* %arg_0, double %arg_1, double* %arg_2)
ret double* %result
}


define dllexport ccc i8*  @varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5051 = bitcast [112 x i8]* @gsxtmmath203 to i8*
call i32 (i8*, ...) @printf(i8* %var5051)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5052 = bitcast [112 x i8]* @gsxtmmath203 to i8*
call i32 (i8*, ...) @printf(i8* %var5052)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5053 = bitcast [112 x i8]* @gsxtmmath203 to i8*
call i32 (i8*, ...) @printf(i8* %var5053)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to double*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}**
%closure = load {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}*, {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}* %closure, i32 0, i32 1
%ff = load  double* (i8*, i8*, double*, double, double*)*,  double* (i8*, i8*, double*, double, double*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double* %ff(i8* %_impz, i8* %ee, double* %arg_0, double %arg_1, double* %arg_2)
%tmpres = bitcast double* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, double, double*}*
%arg_p_0 = getelementptr {double*, double, double*}, {double*, double, double*}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, double, double*}, {double*, double, double*}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
%arg_p_2 = getelementptr {double*, double, double*}, {double*, double, double*}* %fstruct, i32 0, i32 2
%arg_2 = load double*, double** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @varotate_adhoc_W2RvdWJsZSosZG91YmxlKixkb3VibGUsZG91YmxlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}**
%closure = load {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}*, {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}, {i8*, i8*, double* (i8*, i8*, double*, double, double*)*}* %closure, i32 0, i32 1
%ff = load  double* (i8*, i8*, double*, double, double*)*,  double* (i8*, i8*, double*, double, double*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double* %ff(i8* %_impz, i8* %ee, double* %arg_0, double %arg_1, double* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath204 = hidden constant [48 x i8] c"vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ\00"
@gsxtmmath205 = hidden constant [6 x i8] c"right\00"
@gsxtmmath206 = hidden constant [5 x i8] c"left\00"
@gsxtmmath207 = hidden constant [4 x i8] c"buf\00"
@gsxtmmath208 = hidden constant [8 x i8] c"double*\00"
@gsxtmmath209 = hidden constant [6 x i8] c"index\00"
@gsxtmmath210 = hidden constant [6 x i8] c"pivot\00"
@gsxtmmath211 = hidden constant [7 x i8] c"double\00"
@gsxtmmath212 = hidden constant [6 x i8] c"_swap\00"
@gsxtmmath213 = hidden constant [43 x i8] c"{i8*, i8*, double (i8*, i8*, i64, i64)*}**\00"
@gsxtmmath214 = hidden constant [4 x i8] c"tmp\00"
define dllexport fastcc double @vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ__5055(i8* %_impz,i8* %_impenv, i64 %x, i64 %y) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5063 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}*
%vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}* %impenv, i32 0, i32 0
%vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**** %vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr_
%rightPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}* %impenv, i32 0, i32 1
%rightPtr = load i64*, i64** %rightPtr_
%leftPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}* %impenv, i32 0, i32 2
%leftPtr = load i64*, i64** %leftPtr_
%bufPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}* %impenv, i32 0, i32 3
%bufPtr = load double**, double*** %bufPtr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}* %impenv, i32 0, i32 4
%iPtr = load i64*, i64** %iPtr_
%indexPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}* %impenv, i32 0, i32 5
%indexPtr = load i64*, i64** %indexPtr_
%pivotPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}* %impenv, i32 0, i32 6
%pivotPtr = load double*, double** %pivotPtr_
%_swapPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}* %impenv, i32 0, i32 7
%_swapPtr = load {i8*, i8*, double (i8*, i8*, i64, i64)*}***, {i8*, i8*, double (i8*, i8*, i64, i64)*}**** %_swapPtr_
%tmpPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}* %impenv, i32 0, i32 8
%tmpPtr = load double*, double** %tmpPtr_

; setup arguments
%xPtr = alloca i64
store i64 %x, i64* %xPtr
%yPtr = alloca i64
store i64 %y, i64* %yPtr


; do set!
%val5064 = load i64, i64* %xPtr
%val5065 = load double*, double** %bufPtr
; pointer ref
%val5066 = getelementptr double, double* %val5065, i64 %val5064
%val5067 = load double, double* %val5066
store double %val5067, double* %tmpPtr
%val5068 = load i64, i64* %xPtr
%val5069 = load double*, double** %bufPtr
%val5070 = load i64, i64* %yPtr
%val5071 = load double*, double** %bufPtr
; pointer ref
%val5072 = getelementptr double, double* %val5071, i64 %val5070
%val5073 = load double, double* %val5072
; set pointer
%val5074 = getelementptr double, double* %val5069, i64 %val5068
store double %val5073, double* %val5074
%val5075 = load i64, i64* %yPtr
%val5076 = load double*, double** %bufPtr
%val5077 = load double, double* %tmpPtr
; set pointer
%val5078 = getelementptr double, double* %val5076, i64 %val5075
store double %val5077, double* %val5078
ret double %val5077
}
define dllexport fastcc void @vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ__5054(i8* %_impz,i8* %_impenv, double* %buf, i64 %left, i64 %right) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5056 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***}*
%vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***}* %impenv, i32 0, i32 0
%vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**** %vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr_

; setup arguments
%dat_buf = alloca i8, i64 8, align 16
%bufPtr = bitcast i8* %dat_buf to double**
store double* %buf, double** %bufPtr
%dat_left = alloca i8, i64 8, align 16
%leftPtr = bitcast i8* %dat_left to i64*
store i64 %left, i64* %leftPtr
%dat_right = alloca i8, i64 8, align 16
%rightPtr = bitcast i8* %dat_right to i64*
store i64 %right, i64* %rightPtr


%val5058 = load i64, i64* %leftPtr
%val5059 = load i64, i64* %rightPtr
%cmp5060 = icmp slt i64 %val5058, %val5059
br i1 %cmp5060, label %then5057, label %else5057

then5057:
%tzone5061 = load i8*, i8** %_impzPtr
%zone5062 = bitcast i8* %tzone5061 to %mzone*

; let assign value to symbol tmp
%tmpPtr = alloca double
%tzone5138 = load i8*, i8** %_impzPtr
%zone5139 = bitcast i8* %tzone5138 to %mzone*

; let assign value to symbol _swap
%_swapPtr = alloca { i8*, i8*, double (i8*, i8*, i64, i64)*}**
%tzone5144 = load i8*, i8** %_impzPtr
%zone5145 = bitcast i8* %tzone5144 to %mzone*

; let assign value to symbol pivot
%pivotPtr = alloca double
%tzone5147 = load i8*, i8** %_impzPtr
%zone5148 = bitcast i8* %tzone5147 to %mzone*

; let assign value to symbol index
%indexPtr = alloca i64
%tzone5149 = load i8*, i8** %_impzPtr
%zone5150 = bitcast i8* %tzone5149 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%tmp = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %tmp, double* %tmpPtr

%tzone5079 = load i8*, i8** %_impzPtr
%zone5080 = bitcast i8* %tzone5079 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5080)
; malloc closure structure
%clsptr5081 = alloca i8, i64 24, align 16
%closure5082 = bitcast i8* %clsptr5081 to { i8*, i8*, double (i8*, i8*, i64, i64)*}*

; malloc environment structure
%envptr5083 = alloca i8, i64 72, align 16
%environment5084 = bitcast i8* %envptr5083 to {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}*

; malloc closure address table
%addytable5085 = call %clsvar* @new_address_table()
%var5086 = bitcast [48 x i8]* @gsxtmmath204 to i8*
%var5087 = bitcast [50 x i8]* @gsxtmmath60 to i8*
%addytable5088 = call %clsvar* @add_address_table(%mzone* %zone5080, i8* %var5086, i32 0, i8* %var5087, i32 2, %clsvar* %addytable5085)
%var5089 = bitcast [6 x i8]* @gsxtmmath205 to i8*
%var5090 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5091 = call %clsvar* @add_address_table(%mzone* %zone5080, i8* %var5089, i32 8, i8* %var5090, i32 2, %clsvar* %addytable5088)
%var5092 = bitcast [5 x i8]* @gsxtmmath206 to i8*
%var5093 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5094 = call %clsvar* @add_address_table(%mzone* %zone5080, i8* %var5092, i32 16, i8* %var5093, i32 2, %clsvar* %addytable5091)
%var5095 = bitcast [4 x i8]* @gsxtmmath207 to i8*
%var5096 = bitcast [8 x i8]* @gsxtmmath208 to i8*
%addytable5097 = call %clsvar* @add_address_table(%mzone* %zone5080, i8* %var5095, i32 24, i8* %var5096, i32 2, %clsvar* %addytable5094)
%var5098 = bitcast [2 x i8]* @gsxtmmath93 to i8*
%var5099 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5100 = call %clsvar* @add_address_table(%mzone* %zone5080, i8* %var5098, i32 32, i8* %var5099, i32 2, %clsvar* %addytable5097)
%var5101 = bitcast [6 x i8]* @gsxtmmath209 to i8*
%var5102 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5103 = call %clsvar* @add_address_table(%mzone* %zone5080, i8* %var5101, i32 40, i8* %var5102, i32 2, %clsvar* %addytable5100)
%var5104 = bitcast [6 x i8]* @gsxtmmath210 to i8*
%var5105 = bitcast [7 x i8]* @gsxtmmath211 to i8*
%addytable5106 = call %clsvar* @add_address_table(%mzone* %zone5080, i8* %var5104, i32 48, i8* %var5105, i32 2, %clsvar* %addytable5103)
%var5107 = bitcast [6 x i8]* @gsxtmmath212 to i8*
%var5108 = bitcast [43 x i8]* @gsxtmmath213 to i8*
%addytable5109 = call %clsvar* @add_address_table(%mzone* %zone5080, i8* %var5107, i32 56, i8* %var5108, i32 2, %clsvar* %addytable5106)
%var5110 = bitcast [4 x i8]* @gsxtmmath214 to i8*
%var5111 = bitcast [7 x i8]* @gsxtmmath211 to i8*
%addytable5112 = call %clsvar* @add_address_table(%mzone* %zone5080, i8* %var5110, i32 64, i8* %var5111, i32 2, %clsvar* %addytable5109)
%address-table5113 = bitcast %clsvar* %addytable5112 to i8*

; insert table, function and environment into closure struct
%closure.table5132 = getelementptr { i8*, i8*, double (i8*, i8*, i64, i64)*}, { i8*, i8*, double (i8*, i8*, i64, i64)*}* %closure5082, i32 0, i32 0
store i8* %address-table5113, i8** %closure.table5132
%closure.env5133 = getelementptr { i8*, i8*, double (i8*, i8*, i64, i64)*}, { i8*, i8*, double (i8*, i8*, i64, i64)*}* %closure5082, i32 0, i32 1
store i8* %envptr5083, i8** %closure.env5133
%closure.func5134 = getelementptr { i8*, i8*, double (i8*, i8*, i64, i64)*}, { i8*, i8*, double (i8*, i8*, i64, i64)*}* %closure5082, i32 0, i32 2
store double (i8*, i8*, i64, i64)* @vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ__5055, double (i8*, i8*, i64, i64)** %closure.func5134
%closure_size5135 = call i64 @llvm_zone_mark_size(%mzone* %zone5080)
call void @llvm_zone_ptr_set_size(i8* %clsptr5081, i64 %closure_size5135)
%wrapper_ptr5136 = alloca i8,  i32 8, align 16
%closure_wrapper5137 = bitcast i8* %wrapper_ptr5136 to { i8*, i8*, double (i8*, i8*, i64, i64)*}**
store { i8*, i8*, double (i8*, i8*, i64, i64)*}* %closure5082, { i8*, i8*, double (i8*, i8*, i64, i64)*}** %closure_wrapper5137

; let value assignment
%_swap = select i1 true, { i8*, i8*, double (i8*, i8*, i64, i64)*}** %closure_wrapper5137, { i8*, i8*, double (i8*, i8*, i64, i64)*}** %closure_wrapper5137
store { i8*, i8*, double (i8*, i8*, i64, i64)*}** %_swap, { i8*, i8*, double (i8*, i8*, i64, i64)*}*** %_swapPtr

%val5140 = load i64, i64* %rightPtr
%val5141 = load double*, double** %bufPtr
; pointer ref
%val5142 = getelementptr double, double* %val5141, i64 %val5140
%val5143 = load double, double* %val5142

; let value assignment
%pivot = select i1 true, double %val5143, double %val5143
store double %pivot, double* %pivotPtr

%val5146 = load i64, i64* %leftPtr

; let value assignment
%index = select i1 true, i64 %val5146, i64 %val5146
store i64 %index, i64* %indexPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; add data to environment
; don't need to alloc for env var vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ
%tmp_envptr5115 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}* %environment5084, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**** %tmp_envptr5115

; don't need to alloc for env var right
%tmp_envptr5117 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}* %environment5084, i32 0, i32 1
store i64* %rightPtr, i64** %tmp_envptr5117

; don't need to alloc for env var left
%tmp_envptr5119 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}* %environment5084, i32 0, i32 2
store i64* %leftPtr, i64** %tmp_envptr5119

; don't need to alloc for env var buf
%tmp_envptr5121 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}* %environment5084, i32 0, i32 3
store double** %bufPtr, double*** %tmp_envptr5121

; don't need to alloc for env var i
%tmp_envptr5123 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}* %environment5084, i32 0, i32 4
store i64* %iPtr, i64** %tmp_envptr5123

; don't need to alloc for env var index
%tmp_envptr5125 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}* %environment5084, i32 0, i32 5
store i64* %indexPtr, i64** %tmp_envptr5125

; don't need to alloc for env var pivot
%tmp_envptr5127 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}* %environment5084, i32 0, i32 6
store double* %pivotPtr, double** %tmp_envptr5127

; don't need to alloc for env var _swap
%tmp_envptr5129 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}* %environment5084, i32 0, i32 7
store {i8*, i8*, double (i8*, i8*, i64, i64)*}*** %_swapPtr, {i8*, i8*, double (i8*, i8*, i64, i64)*}**** %tmp_envptr5129

; don't need to alloc for env var tmp
%tmp_envptr5131 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***, i64*, i64*, double**, i64*, i64*, double*, {i8*, i8*, double (i8*, i8*, i64, i64)*}***, double*}* %environment5084, i32 0, i32 8
store double* %tmpPtr, double** %tmp_envptr5131


; promote local stack var allocations
%tzone5245 = load i8*, i8** %_impzPtr
%zone5246 = bitcast i8* %tzone5245 to %mzone*
%ifptr5156 = alloca i64
%ifptr5157 = alloca i1
%ifptr5170 = alloca i1
; setup loop
%val5153 = load i64, i64* %rightPtr
%val5154 = load i64, i64* %leftPtr
%val5155 = sub i64 %val5153, %val5154
%val5152 = load i64, i64* %leftPtr
store i64 %val5152, i64* %iPtr
%val5201 = load i64, i64* %iPtr
%num5202 = add i64 %val5155, %val5201
%comp5203 = icmp ult i64 %val5155, 1
br i1 %comp5203, label %after5151, label %loop5151

loop5151:
%val5158 = load i64, i64* %iPtr
%val5159 = load double*, double** %bufPtr
; pointer ref
%val5160 = getelementptr double, double* %val5159, i64 %val5158
%val5161 = load double, double* %val5160
%val5162 = load double, double* %pivotPtr
%cmp5163 = fcmp ult double %val5161, %val5162
br i1 %cmp5163, label %then5157, label %else5157

then5157:
%val5164 = load i64, i64* %iPtr
%val5165 = load double*, double** %bufPtr
; pointer ref
%val5166 = getelementptr double, double* %val5165, i64 %val5164
%val5167 = load double, double* %val5166
%val5168 = load double, double* %pivotPtr
%cmp5169 = fcmp ult double %val5167, %val5168
store i1 %cmp5169, i1* %ifptr5157
br label %ifcont5157

else5157:
%val5171 = load i64, i64* %iPtr
%val5172 = load double*, double** %bufPtr
; pointer ref
%val5173 = getelementptr double, double* %val5172, i64 %val5171
%val5174 = load double, double* %val5173
%val5175 = load double, double* %pivotPtr
%cmp5176 = fcmp ueq double %val5174, %val5175
br i1 %cmp5176, label %then5170, label %else5170

then5170:
%val5177 = load i64, i64* %iPtr
%val5178 = load double*, double** %bufPtr
; pointer ref
%val5179 = getelementptr double, double* %val5178, i64 %val5177
%val5180 = load double, double* %val5179
%val5181 = load double, double* %pivotPtr
%cmp5182 = fcmp ueq double %val5180, %val5181
store i1 %cmp5182, i1* %ifptr5170
br label %ifcont5170

else5170:
%res5183 = call ccc i1 @impc_false()
store i1 %res5183, i1* %ifptr5170
br label %ifcont5170

ifcont5170:
%ifres5184 = load i1, i1* %ifptr5170

store i1 %ifres5184, i1* %ifptr5157
br label %ifcont5157

ifcont5157:
%ifres5185 = load i1, i1* %ifptr5157

br i1 %ifres5185, label %then5156, label %else5156

then5156:
%val5186 = load i64, i64* %iPtr
%val5187 = load i64, i64* %indexPtr

; apply closure 
%vval5188 = load {i8*, i8*, double (i8*, i8*, i64, i64)*}**, {i8*, i8*, double (i8*, i8*, i64, i64)*}*** %_swapPtr
%val5189 = load {i8*, i8*, double (i8*, i8*, i64, i64)*}*,{i8*, i8*, double (i8*, i8*, i64, i64)*}** %vval5188
%fPtr5190 = getelementptr {i8*, i8*, double (i8*, i8*, i64, i64)*}, {i8*, i8*, double (i8*, i8*, i64, i64)*}* %val5189, i32 0, i32 2
%ePtr5191 = getelementptr {i8*, i8*, double (i8*, i8*, i64, i64)*}, {i8*, i8*, double (i8*, i8*, i64, i64)*}* %val5189, i32 0, i32 1
%f5192 = load double (i8*, i8*, i64, i64)*, double (i8*, i8*, i64, i64)** %fPtr5190
%e5193 = load i8*, i8** %ePtr5191
%tzone5194 = load i8*, i8** %_impzPtr
%zone5195 = bitcast i8* %tzone5194 to %mzone*
%z5196 = bitcast %mzone* %zone5195 to i8*
%result5197 = tail call fastcc double %f5192(i8* %z5196, i8* %e5193, i64 %val5186, i64 %val5187)
; do set!
%val5198 = load i64, i64* %indexPtr
%val5199 = add i64 %val5198, 1
store i64 %val5199, i64* %indexPtr
store i64 %val5199, i64* %ifptr5156
br label %ifcont5156

else5156:
br label %ifcont5156

ifcont5156:
%ifres5200 = load i64, i64* %ifptr5156

%loop_cnt5151 = load i64, i64* %iPtr
%next5151 = add i64 %loop_cnt5151, 1
store i64 %next5151, i64* %iPtr
%cmp5151 = icmp ult i64 %next5151, %num5202
br i1 %cmp5151, label %loop5151, label %after5151

after5151:
%val5205 = load i64, i64* %rightPtr
%val5206 = load i64, i64* %indexPtr

; apply closure 
%vval5207 = load {i8*, i8*, double (i8*, i8*, i64, i64)*}**, {i8*, i8*, double (i8*, i8*, i64, i64)*}*** %_swapPtr
%val5208 = load {i8*, i8*, double (i8*, i8*, i64, i64)*}*,{i8*, i8*, double (i8*, i8*, i64, i64)*}** %vval5207
%fPtr5209 = getelementptr {i8*, i8*, double (i8*, i8*, i64, i64)*}, {i8*, i8*, double (i8*, i8*, i64, i64)*}* %val5208, i32 0, i32 2
%ePtr5210 = getelementptr {i8*, i8*, double (i8*, i8*, i64, i64)*}, {i8*, i8*, double (i8*, i8*, i64, i64)*}* %val5208, i32 0, i32 1
%f5211 = load double (i8*, i8*, i64, i64)*, double (i8*, i8*, i64, i64)** %fPtr5209
%e5212 = load i8*, i8** %ePtr5210
%tzone5213 = load i8*, i8** %_impzPtr
%zone5214 = bitcast i8* %tzone5213 to %mzone*
%z5215 = bitcast %mzone* %zone5214 to i8*
%result5216 = tail call fastcc double %f5211(i8* %z5215, i8* %e5212, i64 %val5205, i64 %val5206)
%val5217 = load double*, double** %bufPtr
%val5218 = load i64, i64* %leftPtr
%val5219 = load i64, i64* %indexPtr
%val5220 = sub i64 %val5219, 1

; apply closure 
%vval5221 = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr
%val5222 = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*,{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %vval5221
%fPtr5223 = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %val5222, i32 0, i32 2
%ePtr5224 = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %val5222, i32 0, i32 1
%f5225 = load void (i8*, i8*, double*, i64, i64)*, void (i8*, i8*, double*, i64, i64)** %fPtr5223
%e5226 = load i8*, i8** %ePtr5224
%tzone5227 = load i8*, i8** %_impzPtr
%zone5228 = bitcast i8* %tzone5227 to %mzone*
%z5229 = bitcast %mzone* %zone5228 to i8*
tail call fastcc void %f5225(i8* %z5229, i8* %e5226, double* %val5217, i64 %val5218, i64 %val5220)
%val5231 = load double*, double** %bufPtr
%val5232 = load i64, i64* %indexPtr
%val5233 = add i64 %val5232, 1
%val5234 = load i64, i64* %rightPtr

; apply closure 
%vval5235 = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr
%val5236 = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*,{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %vval5235
%fPtr5237 = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %val5236, i32 0, i32 2
%ePtr5238 = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %val5236, i32 0, i32 1
%f5239 = load void (i8*, i8*, double*, i64, i64)*, void (i8*, i8*, double*, i64, i64)** %fPtr5237
%e5240 = load i8*, i8** %ePtr5238
%tzone5241 = load i8*, i8** %_impzPtr
%zone5242 = bitcast i8* %tzone5241 to %mzone*
%z5243 = bitcast %mzone* %zone5242 to i8*
tail call fastcc void %f5239(i8* %z5243, i8* %e5240, double* %val5231, i64 %val5233, i64 %val5234)
ret void

else5057:
ret void
}
@gsxtmmath215 = hidden constant [101 x i8] c"vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** @vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5267 = load i8*, i8** %_impzPtr
%zone5268 = bitcast i8* %tzone5267 to %mzone*

; let assign value to symbol vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ
%dat_vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone5268, i64 8)
%vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr = bitcast i8* %dat_vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ to { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***
%tzone5248 = load i8*, i8** %_impzPtr
%zone5249 = bitcast i8* %tzone5248 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5249)
; malloc closure structure
%clsptr5250 = call i8* @llvm_zone_malloc(%mzone* %zone5249, i64 24)
%closure5251 = bitcast i8* %clsptr5250 to { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*

; malloc environment structure
%envptr5252 = call i8* @llvm_zone_malloc(%mzone* %zone5249, i64 8)
%environment5253 = bitcast i8* %envptr5252 to {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***}*

; malloc closure address table
%addytable5254 = call %clsvar* @new_address_table()
%var5255 = bitcast [48 x i8]* @gsxtmmath204 to i8*
%var5256 = bitcast [50 x i8]* @gsxtmmath60 to i8*
%addytable5257 = call %clsvar* @add_address_table(%mzone* %zone5249, i8* %var5255, i32 0, i8* %var5256, i32 3, %clsvar* %addytable5254)
%address-table5258 = bitcast %clsvar* %addytable5257 to i8*

; insert table, function and environment into closure struct
%closure.table5261 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure5251, i32 0, i32 0
store i8* %address-table5258, i8** %closure.table5261
%closure.env5262 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure5251, i32 0, i32 1
store i8* %envptr5252, i8** %closure.env5262
%closure.func5263 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure5251, i32 0, i32 2
store void (i8*, i8*, double*, i64, i64)* @vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ__5054, void (i8*, i8*, double*, i64, i64)** %closure.func5263
%closure_size5264 = call i64 @llvm_zone_mark_size(%mzone* %zone5249)
call void @llvm_zone_ptr_set_size(i8* %clsptr5250, i64 %closure_size5264)
%wrapper_ptr5265 = call i8* @llvm_zone_malloc(%mzone* %zone5249, i64 8)
%closure_wrapper5266 = bitcast i8* %wrapper_ptr5265 to { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**
store { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure5251, { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure_wrapper5266

; let value assignment
%vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure_wrapper5266, { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure_wrapper5266
store { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ, { i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ
%tmp_envptr5260 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64, i64)*}***}* %environment5253, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**** %tmp_envptr5260


%val5269 = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %val5269
}


@vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** @vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ(double* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, i64)*,  void (i8*, i8*, double*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_native(double* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, i64)*,  void (i8*, i8*, double*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5270 = bitcast [101 x i8]* @gsxtmmath215 to i8*
call i32 (i8*, ...) @printf(i8* %var5270)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5271 = bitcast [101 x i8]* @gsxtmmath215 to i8*
call i32 (i8*, ...) @printf(i8* %var5271)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5272 = bitcast [101 x i8]* @gsxtmmath215 to i8*
call i32 (i8*, ...) @printf(i8* %var5272)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, i64)*,  void (i8*, i8*, double*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, i64, i64}*
%arg_p_0 = getelementptr {double*, i64, i64}, {double*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, i64, i64}, {double*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {double*, i64, i64}, {double*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64, i64)*,  void (i8*, i8*, double*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath216 = hidden constant [46 x i8] c"vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd\00"
@gsxtmmath217 = hidden constant [7 x i8] c"float*\00"
@gsxtmmath218 = hidden constant [6 x i8] c"float\00"
@gsxtmmath219 = hidden constant [42 x i8] c"{i8*, i8*, float (i8*, i8*, i64, i64)*}**\00"
define dllexport fastcc float @vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd__5274(i8* %_impz,i8* %_impenv, i64 %x, i64 %y) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5282 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}*
%vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}* %impenv, i32 0, i32 0
%vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**** %vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr_
%rightPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}* %impenv, i32 0, i32 1
%rightPtr = load i64*, i64** %rightPtr_
%leftPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}* %impenv, i32 0, i32 2
%leftPtr = load i64*, i64** %leftPtr_
%bufPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}* %impenv, i32 0, i32 3
%bufPtr = load float**, float*** %bufPtr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}* %impenv, i32 0, i32 4
%iPtr = load i64*, i64** %iPtr_
%indexPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}* %impenv, i32 0, i32 5
%indexPtr = load i64*, i64** %indexPtr_
%pivotPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}* %impenv, i32 0, i32 6
%pivotPtr = load float*, float** %pivotPtr_
%_swapPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}* %impenv, i32 0, i32 7
%_swapPtr = load {i8*, i8*, float (i8*, i8*, i64, i64)*}***, {i8*, i8*, float (i8*, i8*, i64, i64)*}**** %_swapPtr_
%tmpPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}* %impenv, i32 0, i32 8
%tmpPtr = load float*, float** %tmpPtr_

; setup arguments
%xPtr = alloca i64
store i64 %x, i64* %xPtr
%yPtr = alloca i64
store i64 %y, i64* %yPtr


; do set!
%val5283 = load i64, i64* %xPtr
%val5284 = load float*, float** %bufPtr
; pointer ref
%val5285 = getelementptr float, float* %val5284, i64 %val5283
%val5286 = load float, float* %val5285
store float %val5286, float* %tmpPtr
%val5287 = load i64, i64* %xPtr
%val5288 = load float*, float** %bufPtr
%val5289 = load i64, i64* %yPtr
%val5290 = load float*, float** %bufPtr
; pointer ref
%val5291 = getelementptr float, float* %val5290, i64 %val5289
%val5292 = load float, float* %val5291
; set pointer
%val5293 = getelementptr float, float* %val5288, i64 %val5287
store float %val5292, float* %val5293
%val5294 = load i64, i64* %yPtr
%val5295 = load float*, float** %bufPtr
%val5296 = load float, float* %tmpPtr
; set pointer
%val5297 = getelementptr float, float* %val5295, i64 %val5294
store float %val5296, float* %val5297
ret float %val5296
}
define dllexport fastcc void @vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd__5273(i8* %_impz,i8* %_impenv, float* %buf, i64 %left, i64 %right) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5275 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***}*
%vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***}* %impenv, i32 0, i32 0
%vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**** %vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr_

; setup arguments
%dat_buf = alloca i8, i64 8, align 16
%bufPtr = bitcast i8* %dat_buf to float**
store float* %buf, float** %bufPtr
%dat_left = alloca i8, i64 8, align 16
%leftPtr = bitcast i8* %dat_left to i64*
store i64 %left, i64* %leftPtr
%dat_right = alloca i8, i64 8, align 16
%rightPtr = bitcast i8* %dat_right to i64*
store i64 %right, i64* %rightPtr


%val5277 = load i64, i64* %leftPtr
%val5278 = load i64, i64* %rightPtr
%cmp5279 = icmp slt i64 %val5277, %val5278
br i1 %cmp5279, label %then5276, label %else5276

then5276:
%tzone5280 = load i8*, i8** %_impzPtr
%zone5281 = bitcast i8* %tzone5280 to %mzone*

; let assign value to symbol tmp
%tmpPtr = alloca float
%tzone5357 = load i8*, i8** %_impzPtr
%zone5358 = bitcast i8* %tzone5357 to %mzone*

; let assign value to symbol _swap
%_swapPtr = alloca { i8*, i8*, float (i8*, i8*, i64, i64)*}**
%tzone5363 = load i8*, i8** %_impzPtr
%zone5364 = bitcast i8* %tzone5363 to %mzone*

; let assign value to symbol pivot
%pivotPtr = alloca float
%tzone5366 = load i8*, i8** %_impzPtr
%zone5367 = bitcast i8* %tzone5366 to %mzone*

; let assign value to symbol index
%indexPtr = alloca i64
%tzone5368 = load i8*, i8** %_impzPtr
%zone5369 = bitcast i8* %tzone5368 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%tmp = select i1 true, float 0x0, float 0x0
store float %tmp, float* %tmpPtr

%tzone5298 = load i8*, i8** %_impzPtr
%zone5299 = bitcast i8* %tzone5298 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5299)
; malloc closure structure
%clsptr5300 = alloca i8, i64 24, align 16
%closure5301 = bitcast i8* %clsptr5300 to { i8*, i8*, float (i8*, i8*, i64, i64)*}*

; malloc environment structure
%envptr5302 = alloca i8, i64 72, align 16
%environment5303 = bitcast i8* %envptr5302 to {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}*

; malloc closure address table
%addytable5304 = call %clsvar* @new_address_table()
%var5305 = bitcast [46 x i8]* @gsxtmmath216 to i8*
%var5306 = bitcast [49 x i8]* @gsxtmmath54 to i8*
%addytable5307 = call %clsvar* @add_address_table(%mzone* %zone5299, i8* %var5305, i32 0, i8* %var5306, i32 2, %clsvar* %addytable5304)
%var5308 = bitcast [6 x i8]* @gsxtmmath205 to i8*
%var5309 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5310 = call %clsvar* @add_address_table(%mzone* %zone5299, i8* %var5308, i32 8, i8* %var5309, i32 2, %clsvar* %addytable5307)
%var5311 = bitcast [5 x i8]* @gsxtmmath206 to i8*
%var5312 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5313 = call %clsvar* @add_address_table(%mzone* %zone5299, i8* %var5311, i32 16, i8* %var5312, i32 2, %clsvar* %addytable5310)
%var5314 = bitcast [4 x i8]* @gsxtmmath207 to i8*
%var5315 = bitcast [7 x i8]* @gsxtmmath217 to i8*
%addytable5316 = call %clsvar* @add_address_table(%mzone* %zone5299, i8* %var5314, i32 24, i8* %var5315, i32 2, %clsvar* %addytable5313)
%var5317 = bitcast [2 x i8]* @gsxtmmath93 to i8*
%var5318 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5319 = call %clsvar* @add_address_table(%mzone* %zone5299, i8* %var5317, i32 32, i8* %var5318, i32 2, %clsvar* %addytable5316)
%var5320 = bitcast [6 x i8]* @gsxtmmath209 to i8*
%var5321 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5322 = call %clsvar* @add_address_table(%mzone* %zone5299, i8* %var5320, i32 40, i8* %var5321, i32 2, %clsvar* %addytable5319)
%var5323 = bitcast [6 x i8]* @gsxtmmath210 to i8*
%var5324 = bitcast [6 x i8]* @gsxtmmath218 to i8*
%addytable5325 = call %clsvar* @add_address_table(%mzone* %zone5299, i8* %var5323, i32 48, i8* %var5324, i32 2, %clsvar* %addytable5322)
%var5326 = bitcast [6 x i8]* @gsxtmmath212 to i8*
%var5327 = bitcast [42 x i8]* @gsxtmmath219 to i8*
%addytable5328 = call %clsvar* @add_address_table(%mzone* %zone5299, i8* %var5326, i32 56, i8* %var5327, i32 2, %clsvar* %addytable5325)
%var5329 = bitcast [4 x i8]* @gsxtmmath214 to i8*
%var5330 = bitcast [6 x i8]* @gsxtmmath218 to i8*
%addytable5331 = call %clsvar* @add_address_table(%mzone* %zone5299, i8* %var5329, i32 64, i8* %var5330, i32 2, %clsvar* %addytable5328)
%address-table5332 = bitcast %clsvar* %addytable5331 to i8*

; insert table, function and environment into closure struct
%closure.table5351 = getelementptr { i8*, i8*, float (i8*, i8*, i64, i64)*}, { i8*, i8*, float (i8*, i8*, i64, i64)*}* %closure5301, i32 0, i32 0
store i8* %address-table5332, i8** %closure.table5351
%closure.env5352 = getelementptr { i8*, i8*, float (i8*, i8*, i64, i64)*}, { i8*, i8*, float (i8*, i8*, i64, i64)*}* %closure5301, i32 0, i32 1
store i8* %envptr5302, i8** %closure.env5352
%closure.func5353 = getelementptr { i8*, i8*, float (i8*, i8*, i64, i64)*}, { i8*, i8*, float (i8*, i8*, i64, i64)*}* %closure5301, i32 0, i32 2
store float (i8*, i8*, i64, i64)* @vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd__5274, float (i8*, i8*, i64, i64)** %closure.func5353
%closure_size5354 = call i64 @llvm_zone_mark_size(%mzone* %zone5299)
call void @llvm_zone_ptr_set_size(i8* %clsptr5300, i64 %closure_size5354)
%wrapper_ptr5355 = alloca i8,  i32 8, align 16
%closure_wrapper5356 = bitcast i8* %wrapper_ptr5355 to { i8*, i8*, float (i8*, i8*, i64, i64)*}**
store { i8*, i8*, float (i8*, i8*, i64, i64)*}* %closure5301, { i8*, i8*, float (i8*, i8*, i64, i64)*}** %closure_wrapper5356

; let value assignment
%_swap = select i1 true, { i8*, i8*, float (i8*, i8*, i64, i64)*}** %closure_wrapper5356, { i8*, i8*, float (i8*, i8*, i64, i64)*}** %closure_wrapper5356
store { i8*, i8*, float (i8*, i8*, i64, i64)*}** %_swap, { i8*, i8*, float (i8*, i8*, i64, i64)*}*** %_swapPtr

%val5359 = load i64, i64* %rightPtr
%val5360 = load float*, float** %bufPtr
; pointer ref
%val5361 = getelementptr float, float* %val5360, i64 %val5359
%val5362 = load float, float* %val5361

; let value assignment
%pivot = select i1 true, float %val5362, float %val5362
store float %pivot, float* %pivotPtr

%val5365 = load i64, i64* %leftPtr

; let value assignment
%index = select i1 true, i64 %val5365, i64 %val5365
store i64 %index, i64* %indexPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; add data to environment
; don't need to alloc for env var vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd
%tmp_envptr5334 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}* %environment5303, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**** %tmp_envptr5334

; don't need to alloc for env var right
%tmp_envptr5336 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}* %environment5303, i32 0, i32 1
store i64* %rightPtr, i64** %tmp_envptr5336

; don't need to alloc for env var left
%tmp_envptr5338 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}* %environment5303, i32 0, i32 2
store i64* %leftPtr, i64** %tmp_envptr5338

; don't need to alloc for env var buf
%tmp_envptr5340 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}* %environment5303, i32 0, i32 3
store float** %bufPtr, float*** %tmp_envptr5340

; don't need to alloc for env var i
%tmp_envptr5342 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}* %environment5303, i32 0, i32 4
store i64* %iPtr, i64** %tmp_envptr5342

; don't need to alloc for env var index
%tmp_envptr5344 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}* %environment5303, i32 0, i32 5
store i64* %indexPtr, i64** %tmp_envptr5344

; don't need to alloc for env var pivot
%tmp_envptr5346 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}* %environment5303, i32 0, i32 6
store float* %pivotPtr, float** %tmp_envptr5346

; don't need to alloc for env var _swap
%tmp_envptr5348 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}* %environment5303, i32 0, i32 7
store {i8*, i8*, float (i8*, i8*, i64, i64)*}*** %_swapPtr, {i8*, i8*, float (i8*, i8*, i64, i64)*}**** %tmp_envptr5348

; don't need to alloc for env var tmp
%tmp_envptr5350 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***, i64*, i64*, float**, i64*, i64*, float*, {i8*, i8*, float (i8*, i8*, i64, i64)*}***, float*}* %environment5303, i32 0, i32 8
store float* %tmpPtr, float** %tmp_envptr5350


; promote local stack var allocations
%tzone5464 = load i8*, i8** %_impzPtr
%zone5465 = bitcast i8* %tzone5464 to %mzone*
%ifptr5375 = alloca i64
%ifptr5376 = alloca i1
%ifptr5389 = alloca i1
; setup loop
%val5372 = load i64, i64* %rightPtr
%val5373 = load i64, i64* %leftPtr
%val5374 = sub i64 %val5372, %val5373
%val5371 = load i64, i64* %leftPtr
store i64 %val5371, i64* %iPtr
%val5420 = load i64, i64* %iPtr
%num5421 = add i64 %val5374, %val5420
%comp5422 = icmp ult i64 %val5374, 1
br i1 %comp5422, label %after5370, label %loop5370

loop5370:
%val5377 = load i64, i64* %iPtr
%val5378 = load float*, float** %bufPtr
; pointer ref
%val5379 = getelementptr float, float* %val5378, i64 %val5377
%val5380 = load float, float* %val5379
%val5381 = load float, float* %pivotPtr
%cmp5382 = fcmp ult float %val5380, %val5381
br i1 %cmp5382, label %then5376, label %else5376

then5376:
%val5383 = load i64, i64* %iPtr
%val5384 = load float*, float** %bufPtr
; pointer ref
%val5385 = getelementptr float, float* %val5384, i64 %val5383
%val5386 = load float, float* %val5385
%val5387 = load float, float* %pivotPtr
%cmp5388 = fcmp ult float %val5386, %val5387
store i1 %cmp5388, i1* %ifptr5376
br label %ifcont5376

else5376:
%val5390 = load i64, i64* %iPtr
%val5391 = load float*, float** %bufPtr
; pointer ref
%val5392 = getelementptr float, float* %val5391, i64 %val5390
%val5393 = load float, float* %val5392
%val5394 = load float, float* %pivotPtr
%cmp5395 = fcmp ueq float %val5393, %val5394
br i1 %cmp5395, label %then5389, label %else5389

then5389:
%val5396 = load i64, i64* %iPtr
%val5397 = load float*, float** %bufPtr
; pointer ref
%val5398 = getelementptr float, float* %val5397, i64 %val5396
%val5399 = load float, float* %val5398
%val5400 = load float, float* %pivotPtr
%cmp5401 = fcmp ueq float %val5399, %val5400
store i1 %cmp5401, i1* %ifptr5389
br label %ifcont5389

else5389:
%res5402 = call ccc i1 @impc_false()
store i1 %res5402, i1* %ifptr5389
br label %ifcont5389

ifcont5389:
%ifres5403 = load i1, i1* %ifptr5389

store i1 %ifres5403, i1* %ifptr5376
br label %ifcont5376

ifcont5376:
%ifres5404 = load i1, i1* %ifptr5376

br i1 %ifres5404, label %then5375, label %else5375

then5375:
%val5405 = load i64, i64* %iPtr
%val5406 = load i64, i64* %indexPtr

; apply closure 
%vval5407 = load {i8*, i8*, float (i8*, i8*, i64, i64)*}**, {i8*, i8*, float (i8*, i8*, i64, i64)*}*** %_swapPtr
%val5408 = load {i8*, i8*, float (i8*, i8*, i64, i64)*}*,{i8*, i8*, float (i8*, i8*, i64, i64)*}** %vval5407
%fPtr5409 = getelementptr {i8*, i8*, float (i8*, i8*, i64, i64)*}, {i8*, i8*, float (i8*, i8*, i64, i64)*}* %val5408, i32 0, i32 2
%ePtr5410 = getelementptr {i8*, i8*, float (i8*, i8*, i64, i64)*}, {i8*, i8*, float (i8*, i8*, i64, i64)*}* %val5408, i32 0, i32 1
%f5411 = load float (i8*, i8*, i64, i64)*, float (i8*, i8*, i64, i64)** %fPtr5409
%e5412 = load i8*, i8** %ePtr5410
%tzone5413 = load i8*, i8** %_impzPtr
%zone5414 = bitcast i8* %tzone5413 to %mzone*
%z5415 = bitcast %mzone* %zone5414 to i8*
%result5416 = tail call fastcc float %f5411(i8* %z5415, i8* %e5412, i64 %val5405, i64 %val5406)
; do set!
%val5417 = load i64, i64* %indexPtr
%val5418 = add i64 %val5417, 1
store i64 %val5418, i64* %indexPtr
store i64 %val5418, i64* %ifptr5375
br label %ifcont5375

else5375:
br label %ifcont5375

ifcont5375:
%ifres5419 = load i64, i64* %ifptr5375

%loop_cnt5370 = load i64, i64* %iPtr
%next5370 = add i64 %loop_cnt5370, 1
store i64 %next5370, i64* %iPtr
%cmp5370 = icmp ult i64 %next5370, %num5421
br i1 %cmp5370, label %loop5370, label %after5370

after5370:
%val5424 = load i64, i64* %rightPtr
%val5425 = load i64, i64* %indexPtr

; apply closure 
%vval5426 = load {i8*, i8*, float (i8*, i8*, i64, i64)*}**, {i8*, i8*, float (i8*, i8*, i64, i64)*}*** %_swapPtr
%val5427 = load {i8*, i8*, float (i8*, i8*, i64, i64)*}*,{i8*, i8*, float (i8*, i8*, i64, i64)*}** %vval5426
%fPtr5428 = getelementptr {i8*, i8*, float (i8*, i8*, i64, i64)*}, {i8*, i8*, float (i8*, i8*, i64, i64)*}* %val5427, i32 0, i32 2
%ePtr5429 = getelementptr {i8*, i8*, float (i8*, i8*, i64, i64)*}, {i8*, i8*, float (i8*, i8*, i64, i64)*}* %val5427, i32 0, i32 1
%f5430 = load float (i8*, i8*, i64, i64)*, float (i8*, i8*, i64, i64)** %fPtr5428
%e5431 = load i8*, i8** %ePtr5429
%tzone5432 = load i8*, i8** %_impzPtr
%zone5433 = bitcast i8* %tzone5432 to %mzone*
%z5434 = bitcast %mzone* %zone5433 to i8*
%result5435 = tail call fastcc float %f5430(i8* %z5434, i8* %e5431, i64 %val5424, i64 %val5425)
%val5436 = load float*, float** %bufPtr
%val5437 = load i64, i64* %leftPtr
%val5438 = load i64, i64* %indexPtr
%val5439 = sub i64 %val5438, 1

; apply closure 
%vval5440 = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr
%val5441 = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*,{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %vval5440
%fPtr5442 = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %val5441, i32 0, i32 2
%ePtr5443 = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %val5441, i32 0, i32 1
%f5444 = load void (i8*, i8*, float*, i64, i64)*, void (i8*, i8*, float*, i64, i64)** %fPtr5442
%e5445 = load i8*, i8** %ePtr5443
%tzone5446 = load i8*, i8** %_impzPtr
%zone5447 = bitcast i8* %tzone5446 to %mzone*
%z5448 = bitcast %mzone* %zone5447 to i8*
tail call fastcc void %f5444(i8* %z5448, i8* %e5445, float* %val5436, i64 %val5437, i64 %val5439)
%val5450 = load float*, float** %bufPtr
%val5451 = load i64, i64* %indexPtr
%val5452 = add i64 %val5451, 1
%val5453 = load i64, i64* %rightPtr

; apply closure 
%vval5454 = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr
%val5455 = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*,{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %vval5454
%fPtr5456 = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %val5455, i32 0, i32 2
%ePtr5457 = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %val5455, i32 0, i32 1
%f5458 = load void (i8*, i8*, float*, i64, i64)*, void (i8*, i8*, float*, i64, i64)** %fPtr5456
%e5459 = load i8*, i8** %ePtr5457
%tzone5460 = load i8*, i8** %_impzPtr
%zone5461 = bitcast i8* %tzone5460 to %mzone*
%z5462 = bitcast %mzone* %zone5461 to i8*
tail call fastcc void %f5458(i8* %z5462, i8* %e5459, float* %val5450, i64 %val5452, i64 %val5453)
ret void

else5276:
ret void
}
@gsxtmmath220 = hidden constant [99 x i8] c"vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** @vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5486 = load i8*, i8** %_impzPtr
%zone5487 = bitcast i8* %tzone5486 to %mzone*

; let assign value to symbol vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd
%dat_vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone5487, i64 8)
%vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr = bitcast i8* %dat_vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd to { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***
%tzone5467 = load i8*, i8** %_impzPtr
%zone5468 = bitcast i8* %tzone5467 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5468)
; malloc closure structure
%clsptr5469 = call i8* @llvm_zone_malloc(%mzone* %zone5468, i64 24)
%closure5470 = bitcast i8* %clsptr5469 to { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*

; malloc environment structure
%envptr5471 = call i8* @llvm_zone_malloc(%mzone* %zone5468, i64 8)
%environment5472 = bitcast i8* %envptr5471 to {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***}*

; malloc closure address table
%addytable5473 = call %clsvar* @new_address_table()
%var5474 = bitcast [46 x i8]* @gsxtmmath216 to i8*
%var5475 = bitcast [49 x i8]* @gsxtmmath54 to i8*
%addytable5476 = call %clsvar* @add_address_table(%mzone* %zone5468, i8* %var5474, i32 0, i8* %var5475, i32 3, %clsvar* %addytable5473)
%address-table5477 = bitcast %clsvar* %addytable5476 to i8*

; insert table, function and environment into closure struct
%closure.table5480 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure5470, i32 0, i32 0
store i8* %address-table5477, i8** %closure.table5480
%closure.env5481 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure5470, i32 0, i32 1
store i8* %envptr5471, i8** %closure.env5481
%closure.func5482 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure5470, i32 0, i32 2
store void (i8*, i8*, float*, i64, i64)* @vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd__5273, void (i8*, i8*, float*, i64, i64)** %closure.func5482
%closure_size5483 = call i64 @llvm_zone_mark_size(%mzone* %zone5468)
call void @llvm_zone_ptr_set_size(i8* %clsptr5469, i64 %closure_size5483)
%wrapper_ptr5484 = call i8* @llvm_zone_malloc(%mzone* %zone5468, i64 8)
%closure_wrapper5485 = bitcast i8* %wrapper_ptr5484 to { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**
store { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure5470, { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure_wrapper5485

; let value assignment
%vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd = select i1 true, { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure_wrapper5485, { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure_wrapper5485
store { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd, { i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr

; add data to environment
; don't need to alloc for env var vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd
%tmp_envptr5479 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64)*}***}* %environment5472, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**** %tmp_envptr5479


%val5488 = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRdPtr
ret {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %val5488
}


@vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** @vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd(float* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, i64)*,  void (i8*, i8*, float*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_native(float* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, i64)*,  void (i8*, i8*, float*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5489 = bitcast [99 x i8]* @gsxtmmath220 to i8*
call i32 (i8*, ...) @printf(i8* %var5489)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5490 = bitcast [99 x i8]* @gsxtmmath220 to i8*
call i32 (i8*, ...) @printf(i8* %var5490)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5491 = bitcast [99 x i8]* @gsxtmmath220 to i8*
call i32 (i8*, ...) @printf(i8* %var5491)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, i64)*,  void (i8*, i8*, float*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64, i64}*
%arg_p_0 = getelementptr {float*, i64, i64}, {float*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64, i64}, {float*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {float*, i64, i64}, {float*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, i64)*,  void (i8*, i8*, float*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath221 = hidden constant [44 x i8] c"vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ\00"
@gsxtmmath222 = hidden constant [5 x i8] c"i64*\00"
@gsxtmmath223 = hidden constant [40 x i8] c"{i8*, i8*, i64 (i8*, i8*, i64, i64)*}**\00"
define dllexport fastcc i64 @vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ__5493(i8* %_impz,i8* %_impenv, i64 %x, i64 %y) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5501 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}*
%vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}* %impenv, i32 0, i32 0
%vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**** %vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr_
%rightPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}* %impenv, i32 0, i32 1
%rightPtr = load i64*, i64** %rightPtr_
%leftPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}* %impenv, i32 0, i32 2
%leftPtr = load i64*, i64** %leftPtr_
%bufPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}* %impenv, i32 0, i32 3
%bufPtr = load i64**, i64*** %bufPtr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}* %impenv, i32 0, i32 4
%iPtr = load i64*, i64** %iPtr_
%indexPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}* %impenv, i32 0, i32 5
%indexPtr = load i64*, i64** %indexPtr_
%pivotPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}* %impenv, i32 0, i32 6
%pivotPtr = load i64*, i64** %pivotPtr_
%_swapPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}* %impenv, i32 0, i32 7
%_swapPtr = load {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}**** %_swapPtr_
%tmpPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}* %impenv, i32 0, i32 8
%tmpPtr = load i64*, i64** %tmpPtr_

; setup arguments
%xPtr = alloca i64
store i64 %x, i64* %xPtr
%yPtr = alloca i64
store i64 %y, i64* %yPtr


; do set!
%val5502 = load i64, i64* %xPtr
%val5503 = load i64*, i64** %bufPtr
; pointer ref
%val5504 = getelementptr i64, i64* %val5503, i64 %val5502
%val5505 = load i64, i64* %val5504
store i64 %val5505, i64* %tmpPtr
%val5506 = load i64, i64* %xPtr
%val5507 = load i64*, i64** %bufPtr
%val5508 = load i64, i64* %yPtr
%val5509 = load i64*, i64** %bufPtr
; pointer ref
%val5510 = getelementptr i64, i64* %val5509, i64 %val5508
%val5511 = load i64, i64* %val5510
; set pointer
%val5512 = getelementptr i64, i64* %val5507, i64 %val5506
store i64 %val5511, i64* %val5512
%val5513 = load i64, i64* %yPtr
%val5514 = load i64*, i64** %bufPtr
%val5515 = load i64, i64* %tmpPtr
; set pointer
%val5516 = getelementptr i64, i64* %val5514, i64 %val5513
store i64 %val5515, i64* %val5516
ret i64 %val5515
}
define dllexport fastcc void @vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ__5492(i8* %_impz,i8* %_impenv, i64* %buf, i64 %left, i64 %right) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5494 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***}*
%vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***}* %impenv, i32 0, i32 0
%vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**** %vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr_

; setup arguments
%dat_buf = alloca i8, i64 8, align 16
%bufPtr = bitcast i8* %dat_buf to i64**
store i64* %buf, i64** %bufPtr
%dat_left = alloca i8, i64 8, align 16
%leftPtr = bitcast i8* %dat_left to i64*
store i64 %left, i64* %leftPtr
%dat_right = alloca i8, i64 8, align 16
%rightPtr = bitcast i8* %dat_right to i64*
store i64 %right, i64* %rightPtr


%val5496 = load i64, i64* %leftPtr
%val5497 = load i64, i64* %rightPtr
%cmp5498 = icmp slt i64 %val5496, %val5497
br i1 %cmp5498, label %then5495, label %else5495

then5495:
%tzone5499 = load i8*, i8** %_impzPtr
%zone5500 = bitcast i8* %tzone5499 to %mzone*

; let assign value to symbol tmp
%tmpPtr = alloca i64
%tzone5576 = load i8*, i8** %_impzPtr
%zone5577 = bitcast i8* %tzone5576 to %mzone*

; let assign value to symbol _swap
%_swapPtr = alloca { i8*, i8*, i64 (i8*, i8*, i64, i64)*}**
%tzone5582 = load i8*, i8** %_impzPtr
%zone5583 = bitcast i8* %tzone5582 to %mzone*

; let assign value to symbol pivot
%pivotPtr = alloca i64
%tzone5585 = load i8*, i8** %_impzPtr
%zone5586 = bitcast i8* %tzone5585 to %mzone*

; let assign value to symbol index
%indexPtr = alloca i64
%tzone5587 = load i8*, i8** %_impzPtr
%zone5588 = bitcast i8* %tzone5587 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%tmp = select i1 true, i64 0, i64 0
store i64 %tmp, i64* %tmpPtr

%tzone5517 = load i8*, i8** %_impzPtr
%zone5518 = bitcast i8* %tzone5517 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5518)
; malloc closure structure
%clsptr5519 = alloca i8, i64 24, align 16
%closure5520 = bitcast i8* %clsptr5519 to { i8*, i8*, i64 (i8*, i8*, i64, i64)*}*

; malloc environment structure
%envptr5521 = alloca i8, i64 72, align 16
%environment5522 = bitcast i8* %envptr5521 to {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}*

; malloc closure address table
%addytable5523 = call %clsvar* @new_address_table()
%var5524 = bitcast [44 x i8]* @gsxtmmath221 to i8*
%var5525 = bitcast [47 x i8]* @gsxtmmath47 to i8*
%addytable5526 = call %clsvar* @add_address_table(%mzone* %zone5518, i8* %var5524, i32 0, i8* %var5525, i32 2, %clsvar* %addytable5523)
%var5527 = bitcast [6 x i8]* @gsxtmmath205 to i8*
%var5528 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5529 = call %clsvar* @add_address_table(%mzone* %zone5518, i8* %var5527, i32 8, i8* %var5528, i32 2, %clsvar* %addytable5526)
%var5530 = bitcast [5 x i8]* @gsxtmmath206 to i8*
%var5531 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5532 = call %clsvar* @add_address_table(%mzone* %zone5518, i8* %var5530, i32 16, i8* %var5531, i32 2, %clsvar* %addytable5529)
%var5533 = bitcast [4 x i8]* @gsxtmmath207 to i8*
%var5534 = bitcast [5 x i8]* @gsxtmmath222 to i8*
%addytable5535 = call %clsvar* @add_address_table(%mzone* %zone5518, i8* %var5533, i32 24, i8* %var5534, i32 2, %clsvar* %addytable5532)
%var5536 = bitcast [2 x i8]* @gsxtmmath93 to i8*
%var5537 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5538 = call %clsvar* @add_address_table(%mzone* %zone5518, i8* %var5536, i32 32, i8* %var5537, i32 2, %clsvar* %addytable5535)
%var5539 = bitcast [6 x i8]* @gsxtmmath209 to i8*
%var5540 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5541 = call %clsvar* @add_address_table(%mzone* %zone5518, i8* %var5539, i32 40, i8* %var5540, i32 2, %clsvar* %addytable5538)
%var5542 = bitcast [6 x i8]* @gsxtmmath210 to i8*
%var5543 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5544 = call %clsvar* @add_address_table(%mzone* %zone5518, i8* %var5542, i32 48, i8* %var5543, i32 2, %clsvar* %addytable5541)
%var5545 = bitcast [6 x i8]* @gsxtmmath212 to i8*
%var5546 = bitcast [40 x i8]* @gsxtmmath223 to i8*
%addytable5547 = call %clsvar* @add_address_table(%mzone* %zone5518, i8* %var5545, i32 56, i8* %var5546, i32 2, %clsvar* %addytable5544)
%var5548 = bitcast [4 x i8]* @gsxtmmath214 to i8*
%var5549 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5550 = call %clsvar* @add_address_table(%mzone* %zone5518, i8* %var5548, i32 64, i8* %var5549, i32 2, %clsvar* %addytable5547)
%address-table5551 = bitcast %clsvar* %addytable5550 to i8*

; insert table, function and environment into closure struct
%closure.table5570 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64, i64)*}, { i8*, i8*, i64 (i8*, i8*, i64, i64)*}* %closure5520, i32 0, i32 0
store i8* %address-table5551, i8** %closure.table5570
%closure.env5571 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64, i64)*}, { i8*, i8*, i64 (i8*, i8*, i64, i64)*}* %closure5520, i32 0, i32 1
store i8* %envptr5521, i8** %closure.env5571
%closure.func5572 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64, i64)*}, { i8*, i8*, i64 (i8*, i8*, i64, i64)*}* %closure5520, i32 0, i32 2
store i64 (i8*, i8*, i64, i64)* @vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ__5493, i64 (i8*, i8*, i64, i64)** %closure.func5572
%closure_size5573 = call i64 @llvm_zone_mark_size(%mzone* %zone5518)
call void @llvm_zone_ptr_set_size(i8* %clsptr5519, i64 %closure_size5573)
%wrapper_ptr5574 = alloca i8,  i32 8, align 16
%closure_wrapper5575 = bitcast i8* %wrapper_ptr5574 to { i8*, i8*, i64 (i8*, i8*, i64, i64)*}**
store { i8*, i8*, i64 (i8*, i8*, i64, i64)*}* %closure5520, { i8*, i8*, i64 (i8*, i8*, i64, i64)*}** %closure_wrapper5575

; let value assignment
%_swap = select i1 true, { i8*, i8*, i64 (i8*, i8*, i64, i64)*}** %closure_wrapper5575, { i8*, i8*, i64 (i8*, i8*, i64, i64)*}** %closure_wrapper5575
store { i8*, i8*, i64 (i8*, i8*, i64, i64)*}** %_swap, { i8*, i8*, i64 (i8*, i8*, i64, i64)*}*** %_swapPtr

%val5578 = load i64, i64* %rightPtr
%val5579 = load i64*, i64** %bufPtr
; pointer ref
%val5580 = getelementptr i64, i64* %val5579, i64 %val5578
%val5581 = load i64, i64* %val5580

; let value assignment
%pivot = select i1 true, i64 %val5581, i64 %val5581
store i64 %pivot, i64* %pivotPtr

%val5584 = load i64, i64* %leftPtr

; let value assignment
%index = select i1 true, i64 %val5584, i64 %val5584
store i64 %index, i64* %indexPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; add data to environment
; don't need to alloc for env var vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ
%tmp_envptr5553 = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}* %environment5522, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**** %tmp_envptr5553

; don't need to alloc for env var right
%tmp_envptr5555 = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}* %environment5522, i32 0, i32 1
store i64* %rightPtr, i64** %tmp_envptr5555

; don't need to alloc for env var left
%tmp_envptr5557 = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}* %environment5522, i32 0, i32 2
store i64* %leftPtr, i64** %tmp_envptr5557

; don't need to alloc for env var buf
%tmp_envptr5559 = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}* %environment5522, i32 0, i32 3
store i64** %bufPtr, i64*** %tmp_envptr5559

; don't need to alloc for env var i
%tmp_envptr5561 = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}* %environment5522, i32 0, i32 4
store i64* %iPtr, i64** %tmp_envptr5561

; don't need to alloc for env var index
%tmp_envptr5563 = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}* %environment5522, i32 0, i32 5
store i64* %indexPtr, i64** %tmp_envptr5563

; don't need to alloc for env var pivot
%tmp_envptr5565 = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}* %environment5522, i32 0, i32 6
store i64* %pivotPtr, i64** %tmp_envptr5565

; don't need to alloc for env var _swap
%tmp_envptr5567 = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}* %environment5522, i32 0, i32 7
store {i8*, i8*, i64 (i8*, i8*, i64, i64)*}*** %_swapPtr, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}**** %tmp_envptr5567

; don't need to alloc for env var tmp
%tmp_envptr5569 = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***, i64*, i64*, i64**, i64*, i64*, i64*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, i64*}* %environment5522, i32 0, i32 8
store i64* %tmpPtr, i64** %tmp_envptr5569


; promote local stack var allocations
%tzone5683 = load i8*, i8** %_impzPtr
%zone5684 = bitcast i8* %tzone5683 to %mzone*
%ifptr5594 = alloca i64
%ifptr5595 = alloca i1
%ifptr5608 = alloca i1
; setup loop
%val5591 = load i64, i64* %rightPtr
%val5592 = load i64, i64* %leftPtr
%val5593 = sub i64 %val5591, %val5592
%val5590 = load i64, i64* %leftPtr
store i64 %val5590, i64* %iPtr
%val5639 = load i64, i64* %iPtr
%num5640 = add i64 %val5593, %val5639
%comp5641 = icmp ult i64 %val5593, 1
br i1 %comp5641, label %after5589, label %loop5589

loop5589:
%val5596 = load i64, i64* %iPtr
%val5597 = load i64*, i64** %bufPtr
; pointer ref
%val5598 = getelementptr i64, i64* %val5597, i64 %val5596
%val5599 = load i64, i64* %val5598
%val5600 = load i64, i64* %pivotPtr
%cmp5601 = icmp slt i64 %val5599, %val5600
br i1 %cmp5601, label %then5595, label %else5595

then5595:
%val5602 = load i64, i64* %iPtr
%val5603 = load i64*, i64** %bufPtr
; pointer ref
%val5604 = getelementptr i64, i64* %val5603, i64 %val5602
%val5605 = load i64, i64* %val5604
%val5606 = load i64, i64* %pivotPtr
%cmp5607 = icmp slt i64 %val5605, %val5606
store i1 %cmp5607, i1* %ifptr5595
br label %ifcont5595

else5595:
%val5609 = load i64, i64* %iPtr
%val5610 = load i64*, i64** %bufPtr
; pointer ref
%val5611 = getelementptr i64, i64* %val5610, i64 %val5609
%val5612 = load i64, i64* %val5611
%val5613 = load i64, i64* %pivotPtr
%cmp5614 = icmp eq i64 %val5612, %val5613
br i1 %cmp5614, label %then5608, label %else5608

then5608:
%val5615 = load i64, i64* %iPtr
%val5616 = load i64*, i64** %bufPtr
; pointer ref
%val5617 = getelementptr i64, i64* %val5616, i64 %val5615
%val5618 = load i64, i64* %val5617
%val5619 = load i64, i64* %pivotPtr
%cmp5620 = icmp eq i64 %val5618, %val5619
store i1 %cmp5620, i1* %ifptr5608
br label %ifcont5608

else5608:
%res5621 = call ccc i1 @impc_false()
store i1 %res5621, i1* %ifptr5608
br label %ifcont5608

ifcont5608:
%ifres5622 = load i1, i1* %ifptr5608

store i1 %ifres5622, i1* %ifptr5595
br label %ifcont5595

ifcont5595:
%ifres5623 = load i1, i1* %ifptr5595

br i1 %ifres5623, label %then5594, label %else5594

then5594:
%val5624 = load i64, i64* %iPtr
%val5625 = load i64, i64* %indexPtr

; apply closure 
%vval5626 = load {i8*, i8*, i64 (i8*, i8*, i64, i64)*}**, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}*** %_swapPtr
%val5627 = load {i8*, i8*, i64 (i8*, i8*, i64, i64)*}*,{i8*, i8*, i64 (i8*, i8*, i64, i64)*}** %vval5626
%fPtr5628 = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}* %val5627, i32 0, i32 2
%ePtr5629 = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}* %val5627, i32 0, i32 1
%f5630 = load i64 (i8*, i8*, i64, i64)*, i64 (i8*, i8*, i64, i64)** %fPtr5628
%e5631 = load i8*, i8** %ePtr5629
%tzone5632 = load i8*, i8** %_impzPtr
%zone5633 = bitcast i8* %tzone5632 to %mzone*
%z5634 = bitcast %mzone* %zone5633 to i8*
%result5635 = tail call fastcc i64 %f5630(i8* %z5634, i8* %e5631, i64 %val5624, i64 %val5625)
; do set!
%val5636 = load i64, i64* %indexPtr
%val5637 = add i64 %val5636, 1
store i64 %val5637, i64* %indexPtr
store i64 %val5637, i64* %ifptr5594
br label %ifcont5594

else5594:
br label %ifcont5594

ifcont5594:
%ifres5638 = load i64, i64* %ifptr5594

%loop_cnt5589 = load i64, i64* %iPtr
%next5589 = add i64 %loop_cnt5589, 1
store i64 %next5589, i64* %iPtr
%cmp5589 = icmp ult i64 %next5589, %num5640
br i1 %cmp5589, label %loop5589, label %after5589

after5589:
%val5643 = load i64, i64* %rightPtr
%val5644 = load i64, i64* %indexPtr

; apply closure 
%vval5645 = load {i8*, i8*, i64 (i8*, i8*, i64, i64)*}**, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}*** %_swapPtr
%val5646 = load {i8*, i8*, i64 (i8*, i8*, i64, i64)*}*,{i8*, i8*, i64 (i8*, i8*, i64, i64)*}** %vval5645
%fPtr5647 = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}* %val5646, i32 0, i32 2
%ePtr5648 = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}* %val5646, i32 0, i32 1
%f5649 = load i64 (i8*, i8*, i64, i64)*, i64 (i8*, i8*, i64, i64)** %fPtr5647
%e5650 = load i8*, i8** %ePtr5648
%tzone5651 = load i8*, i8** %_impzPtr
%zone5652 = bitcast i8* %tzone5651 to %mzone*
%z5653 = bitcast %mzone* %zone5652 to i8*
%result5654 = tail call fastcc i64 %f5649(i8* %z5653, i8* %e5650, i64 %val5643, i64 %val5644)
%val5655 = load i64*, i64** %bufPtr
%val5656 = load i64, i64* %leftPtr
%val5657 = load i64, i64* %indexPtr
%val5658 = sub i64 %val5657, 1

; apply closure 
%vval5659 = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr
%val5660 = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*,{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %vval5659
%fPtr5661 = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %val5660, i32 0, i32 2
%ePtr5662 = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %val5660, i32 0, i32 1
%f5663 = load void (i8*, i8*, i64*, i64, i64)*, void (i8*, i8*, i64*, i64, i64)** %fPtr5661
%e5664 = load i8*, i8** %ePtr5662
%tzone5665 = load i8*, i8** %_impzPtr
%zone5666 = bitcast i8* %tzone5665 to %mzone*
%z5667 = bitcast %mzone* %zone5666 to i8*
tail call fastcc void %f5663(i8* %z5667, i8* %e5664, i64* %val5655, i64 %val5656, i64 %val5658)
%val5669 = load i64*, i64** %bufPtr
%val5670 = load i64, i64* %indexPtr
%val5671 = add i64 %val5670, 1
%val5672 = load i64, i64* %rightPtr

; apply closure 
%vval5673 = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr
%val5674 = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*,{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %vval5673
%fPtr5675 = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %val5674, i32 0, i32 2
%ePtr5676 = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %val5674, i32 0, i32 1
%f5677 = load void (i8*, i8*, i64*, i64, i64)*, void (i8*, i8*, i64*, i64, i64)** %fPtr5675
%e5678 = load i8*, i8** %ePtr5676
%tzone5679 = load i8*, i8** %_impzPtr
%zone5680 = bitcast i8* %tzone5679 to %mzone*
%z5681 = bitcast %mzone* %zone5680 to i8*
tail call fastcc void %f5677(i8* %z5681, i8* %e5678, i64* %val5669, i64 %val5671, i64 %val5672)
ret void

else5495:
ret void
}
@gsxtmmath224 = hidden constant [97 x i8] c"vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** @vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5705 = load i8*, i8** %_impzPtr
%zone5706 = bitcast i8* %tzone5705 to %mzone*

; let assign value to symbol vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ
%dat_vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone5706, i64 8)
%vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr = bitcast i8* %dat_vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ to { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***
%tzone5686 = load i8*, i8** %_impzPtr
%zone5687 = bitcast i8* %tzone5686 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5687)
; malloc closure structure
%clsptr5688 = call i8* @llvm_zone_malloc(%mzone* %zone5687, i64 24)
%closure5689 = bitcast i8* %clsptr5688 to { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*

; malloc environment structure
%envptr5690 = call i8* @llvm_zone_malloc(%mzone* %zone5687, i64 8)
%environment5691 = bitcast i8* %envptr5690 to {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***}*

; malloc closure address table
%addytable5692 = call %clsvar* @new_address_table()
%var5693 = bitcast [44 x i8]* @gsxtmmath221 to i8*
%var5694 = bitcast [47 x i8]* @gsxtmmath47 to i8*
%addytable5695 = call %clsvar* @add_address_table(%mzone* %zone5687, i8* %var5693, i32 0, i8* %var5694, i32 3, %clsvar* %addytable5692)
%address-table5696 = bitcast %clsvar* %addytable5695 to i8*

; insert table, function and environment into closure struct
%closure.table5699 = getelementptr { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure5689, i32 0, i32 0
store i8* %address-table5696, i8** %closure.table5699
%closure.env5700 = getelementptr { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure5689, i32 0, i32 1
store i8* %envptr5690, i8** %closure.env5700
%closure.func5701 = getelementptr { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure5689, i32 0, i32 2
store void (i8*, i8*, i64*, i64, i64)* @vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ__5492, void (i8*, i8*, i64*, i64, i64)** %closure.func5701
%closure_size5702 = call i64 @llvm_zone_mark_size(%mzone* %zone5687)
call void @llvm_zone_ptr_set_size(i8* %clsptr5688, i64 %closure_size5702)
%wrapper_ptr5703 = call i8* @llvm_zone_malloc(%mzone* %zone5687, i64 8)
%closure_wrapper5704 = bitcast i8* %wrapper_ptr5703 to { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**
store { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure5689, { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure_wrapper5704

; let value assignment
%vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure_wrapper5704, { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure_wrapper5704
store { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ, { i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ
%tmp_envptr5698 = getelementptr {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}***}* %environment5691, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**** %tmp_envptr5698


%val5707 = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %val5707
}


@vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** @vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ(i64* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64*, i64, i64)*,  void (i8*, i8*, i64*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_native(i64* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64*, i64, i64)*,  void (i8*, i8*, i64*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5708 = bitcast [97 x i8]* @gsxtmmath224 to i8*
call i32 (i8*, ...) @printf(i8* %var5708)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i64*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5709 = bitcast [97 x i8]* @gsxtmmath224 to i8*
call i32 (i8*, ...) @printf(i8* %var5709)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5710 = bitcast [97 x i8]* @gsxtmmath224 to i8*
call i32 (i8*, ...) @printf(i8* %var5710)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64*, i64, i64)*,  void (i8*, i8*, i64*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64*, i64, i64}*
%arg_p_0 = getelementptr {i64*, i64, i64}, {i64*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64*, i64** %arg_p_0
%arg_p_1 = getelementptr {i64*, i64, i64}, {i64*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {i64*, i64, i64}, {i64*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i64*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64*, i64, i64)*,  void (i8*, i8*, i64*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath225 = hidden constant [44 x i8] c"vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ\00"
@gsxtmmath226 = hidden constant [5 x i8] c"i32*\00"
@gsxtmmath227 = hidden constant [4 x i8] c"i32\00"
@gsxtmmath228 = hidden constant [40 x i8] c"{i8*, i8*, i32 (i8*, i8*, i64, i64)*}**\00"
define dllexport fastcc i32 @vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ__5712(i8* %_impz,i8* %_impenv, i64 %x, i64 %y) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5720 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}*
%vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}* %impenv, i32 0, i32 0
%vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**** %vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr_
%rightPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}* %impenv, i32 0, i32 1
%rightPtr = load i64*, i64** %rightPtr_
%leftPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}* %impenv, i32 0, i32 2
%leftPtr = load i64*, i64** %leftPtr_
%bufPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}* %impenv, i32 0, i32 3
%bufPtr = load i32**, i32*** %bufPtr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}* %impenv, i32 0, i32 4
%iPtr = load i64*, i64** %iPtr_
%indexPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}* %impenv, i32 0, i32 5
%indexPtr = load i64*, i64** %indexPtr_
%pivotPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}* %impenv, i32 0, i32 6
%pivotPtr = load i32*, i32** %pivotPtr_
%_swapPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}* %impenv, i32 0, i32 7
%_swapPtr = load {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}**** %_swapPtr_
%tmpPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}* %impenv, i32 0, i32 8
%tmpPtr = load i32*, i32** %tmpPtr_

; setup arguments
%xPtr = alloca i64
store i64 %x, i64* %xPtr
%yPtr = alloca i64
store i64 %y, i64* %yPtr


; do set!
%val5721 = load i64, i64* %xPtr
%val5722 = load i32*, i32** %bufPtr
; pointer ref
%val5723 = getelementptr i32, i32* %val5722, i64 %val5721
%val5724 = load i32, i32* %val5723
store i32 %val5724, i32* %tmpPtr
%val5725 = load i64, i64* %xPtr
%val5726 = load i32*, i32** %bufPtr
%val5727 = load i64, i64* %yPtr
%val5728 = load i32*, i32** %bufPtr
; pointer ref
%val5729 = getelementptr i32, i32* %val5728, i64 %val5727
%val5730 = load i32, i32* %val5729
; set pointer
%val5731 = getelementptr i32, i32* %val5726, i64 %val5725
store i32 %val5730, i32* %val5731
%val5732 = load i64, i64* %yPtr
%val5733 = load i32*, i32** %bufPtr
%val5734 = load i32, i32* %tmpPtr
; set pointer
%val5735 = getelementptr i32, i32* %val5733, i64 %val5732
store i32 %val5734, i32* %val5735
ret i32 %val5734
}
define dllexport fastcc void @vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ__5711(i8* %_impz,i8* %_impenv, i32* %buf, i64 %left, i64 %right) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5713 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***}*
%vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***}* %impenv, i32 0, i32 0
%vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**** %vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr_

; setup arguments
%dat_buf = alloca i8, i64 8, align 16
%bufPtr = bitcast i8* %dat_buf to i32**
store i32* %buf, i32** %bufPtr
%dat_left = alloca i8, i64 8, align 16
%leftPtr = bitcast i8* %dat_left to i64*
store i64 %left, i64* %leftPtr
%dat_right = alloca i8, i64 8, align 16
%rightPtr = bitcast i8* %dat_right to i64*
store i64 %right, i64* %rightPtr


%val5715 = load i64, i64* %leftPtr
%val5716 = load i64, i64* %rightPtr
%cmp5717 = icmp slt i64 %val5715, %val5716
br i1 %cmp5717, label %then5714, label %else5714

then5714:
%tzone5718 = load i8*, i8** %_impzPtr
%zone5719 = bitcast i8* %tzone5718 to %mzone*

; let assign value to symbol tmp
%tmpPtr = alloca i32
%tzone5795 = load i8*, i8** %_impzPtr
%zone5796 = bitcast i8* %tzone5795 to %mzone*

; let assign value to symbol _swap
%_swapPtr = alloca { i8*, i8*, i32 (i8*, i8*, i64, i64)*}**
%tzone5801 = load i8*, i8** %_impzPtr
%zone5802 = bitcast i8* %tzone5801 to %mzone*

; let assign value to symbol pivot
%pivotPtr = alloca i32
%tzone5804 = load i8*, i8** %_impzPtr
%zone5805 = bitcast i8* %tzone5804 to %mzone*

; let assign value to symbol index
%indexPtr = alloca i64
%tzone5806 = load i8*, i8** %_impzPtr
%zone5807 = bitcast i8* %tzone5806 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%tmp = select i1 true, i32 0, i32 0
store i32 %tmp, i32* %tmpPtr

%tzone5736 = load i8*, i8** %_impzPtr
%zone5737 = bitcast i8* %tzone5736 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5737)
; malloc closure structure
%clsptr5738 = alloca i8, i64 24, align 16
%closure5739 = bitcast i8* %clsptr5738 to { i8*, i8*, i32 (i8*, i8*, i64, i64)*}*

; malloc environment structure
%envptr5740 = alloca i8, i64 72, align 16
%environment5741 = bitcast i8* %envptr5740 to {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}*

; malloc closure address table
%addytable5742 = call %clsvar* @new_address_table()
%var5743 = bitcast [44 x i8]* @gsxtmmath225 to i8*
%var5744 = bitcast [47 x i8]* @gsxtmmath40 to i8*
%addytable5745 = call %clsvar* @add_address_table(%mzone* %zone5737, i8* %var5743, i32 0, i8* %var5744, i32 2, %clsvar* %addytable5742)
%var5746 = bitcast [6 x i8]* @gsxtmmath205 to i8*
%var5747 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5748 = call %clsvar* @add_address_table(%mzone* %zone5737, i8* %var5746, i32 8, i8* %var5747, i32 2, %clsvar* %addytable5745)
%var5749 = bitcast [5 x i8]* @gsxtmmath206 to i8*
%var5750 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5751 = call %clsvar* @add_address_table(%mzone* %zone5737, i8* %var5749, i32 16, i8* %var5750, i32 2, %clsvar* %addytable5748)
%var5752 = bitcast [4 x i8]* @gsxtmmath207 to i8*
%var5753 = bitcast [5 x i8]* @gsxtmmath226 to i8*
%addytable5754 = call %clsvar* @add_address_table(%mzone* %zone5737, i8* %var5752, i32 24, i8* %var5753, i32 2, %clsvar* %addytable5751)
%var5755 = bitcast [2 x i8]* @gsxtmmath93 to i8*
%var5756 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5757 = call %clsvar* @add_address_table(%mzone* %zone5737, i8* %var5755, i32 32, i8* %var5756, i32 2, %clsvar* %addytable5754)
%var5758 = bitcast [6 x i8]* @gsxtmmath209 to i8*
%var5759 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5760 = call %clsvar* @add_address_table(%mzone* %zone5737, i8* %var5758, i32 40, i8* %var5759, i32 2, %clsvar* %addytable5757)
%var5761 = bitcast [6 x i8]* @gsxtmmath210 to i8*
%var5762 = bitcast [4 x i8]* @gsxtmmath227 to i8*
%addytable5763 = call %clsvar* @add_address_table(%mzone* %zone5737, i8* %var5761, i32 48, i8* %var5762, i32 2, %clsvar* %addytable5760)
%var5764 = bitcast [6 x i8]* @gsxtmmath212 to i8*
%var5765 = bitcast [40 x i8]* @gsxtmmath228 to i8*
%addytable5766 = call %clsvar* @add_address_table(%mzone* %zone5737, i8* %var5764, i32 56, i8* %var5765, i32 2, %clsvar* %addytable5763)
%var5767 = bitcast [4 x i8]* @gsxtmmath214 to i8*
%var5768 = bitcast [4 x i8]* @gsxtmmath227 to i8*
%addytable5769 = call %clsvar* @add_address_table(%mzone* %zone5737, i8* %var5767, i32 64, i8* %var5768, i32 2, %clsvar* %addytable5766)
%address-table5770 = bitcast %clsvar* %addytable5769 to i8*

; insert table, function and environment into closure struct
%closure.table5789 = getelementptr { i8*, i8*, i32 (i8*, i8*, i64, i64)*}, { i8*, i8*, i32 (i8*, i8*, i64, i64)*}* %closure5739, i32 0, i32 0
store i8* %address-table5770, i8** %closure.table5789
%closure.env5790 = getelementptr { i8*, i8*, i32 (i8*, i8*, i64, i64)*}, { i8*, i8*, i32 (i8*, i8*, i64, i64)*}* %closure5739, i32 0, i32 1
store i8* %envptr5740, i8** %closure.env5790
%closure.func5791 = getelementptr { i8*, i8*, i32 (i8*, i8*, i64, i64)*}, { i8*, i8*, i32 (i8*, i8*, i64, i64)*}* %closure5739, i32 0, i32 2
store i32 (i8*, i8*, i64, i64)* @vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ__5712, i32 (i8*, i8*, i64, i64)** %closure.func5791
%closure_size5792 = call i64 @llvm_zone_mark_size(%mzone* %zone5737)
call void @llvm_zone_ptr_set_size(i8* %clsptr5738, i64 %closure_size5792)
%wrapper_ptr5793 = alloca i8,  i32 8, align 16
%closure_wrapper5794 = bitcast i8* %wrapper_ptr5793 to { i8*, i8*, i32 (i8*, i8*, i64, i64)*}**
store { i8*, i8*, i32 (i8*, i8*, i64, i64)*}* %closure5739, { i8*, i8*, i32 (i8*, i8*, i64, i64)*}** %closure_wrapper5794

; let value assignment
%_swap = select i1 true, { i8*, i8*, i32 (i8*, i8*, i64, i64)*}** %closure_wrapper5794, { i8*, i8*, i32 (i8*, i8*, i64, i64)*}** %closure_wrapper5794
store { i8*, i8*, i32 (i8*, i8*, i64, i64)*}** %_swap, { i8*, i8*, i32 (i8*, i8*, i64, i64)*}*** %_swapPtr

%val5797 = load i64, i64* %rightPtr
%val5798 = load i32*, i32** %bufPtr
; pointer ref
%val5799 = getelementptr i32, i32* %val5798, i64 %val5797
%val5800 = load i32, i32* %val5799

; let value assignment
%pivot = select i1 true, i32 %val5800, i32 %val5800
store i32 %pivot, i32* %pivotPtr

%val5803 = load i64, i64* %leftPtr

; let value assignment
%index = select i1 true, i64 %val5803, i64 %val5803
store i64 %index, i64* %indexPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; add data to environment
; don't need to alloc for env var vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ
%tmp_envptr5772 = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}* %environment5741, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**** %tmp_envptr5772

; don't need to alloc for env var right
%tmp_envptr5774 = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}* %environment5741, i32 0, i32 1
store i64* %rightPtr, i64** %tmp_envptr5774

; don't need to alloc for env var left
%tmp_envptr5776 = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}* %environment5741, i32 0, i32 2
store i64* %leftPtr, i64** %tmp_envptr5776

; don't need to alloc for env var buf
%tmp_envptr5778 = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}* %environment5741, i32 0, i32 3
store i32** %bufPtr, i32*** %tmp_envptr5778

; don't need to alloc for env var i
%tmp_envptr5780 = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}* %environment5741, i32 0, i32 4
store i64* %iPtr, i64** %tmp_envptr5780

; don't need to alloc for env var index
%tmp_envptr5782 = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}* %environment5741, i32 0, i32 5
store i64* %indexPtr, i64** %tmp_envptr5782

; don't need to alloc for env var pivot
%tmp_envptr5784 = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}* %environment5741, i32 0, i32 6
store i32* %pivotPtr, i32** %tmp_envptr5784

; don't need to alloc for env var _swap
%tmp_envptr5786 = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}* %environment5741, i32 0, i32 7
store {i8*, i8*, i32 (i8*, i8*, i64, i64)*}*** %_swapPtr, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}**** %tmp_envptr5786

; don't need to alloc for env var tmp
%tmp_envptr5788 = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***, i64*, i64*, i32**, i64*, i64*, i32*, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}***, i32*}* %environment5741, i32 0, i32 8
store i32* %tmpPtr, i32** %tmp_envptr5788


; promote local stack var allocations
%tzone5902 = load i8*, i8** %_impzPtr
%zone5903 = bitcast i8* %tzone5902 to %mzone*
%ifptr5813 = alloca i64
%ifptr5814 = alloca i1
%ifptr5827 = alloca i1
; setup loop
%val5810 = load i64, i64* %rightPtr
%val5811 = load i64, i64* %leftPtr
%val5812 = sub i64 %val5810, %val5811
%val5809 = load i64, i64* %leftPtr
store i64 %val5809, i64* %iPtr
%val5858 = load i64, i64* %iPtr
%num5859 = add i64 %val5812, %val5858
%comp5860 = icmp ult i64 %val5812, 1
br i1 %comp5860, label %after5808, label %loop5808

loop5808:
%val5815 = load i64, i64* %iPtr
%val5816 = load i32*, i32** %bufPtr
; pointer ref
%val5817 = getelementptr i32, i32* %val5816, i64 %val5815
%val5818 = load i32, i32* %val5817
%val5819 = load i32, i32* %pivotPtr
%cmp5820 = icmp slt i32 %val5818, %val5819
br i1 %cmp5820, label %then5814, label %else5814

then5814:
%val5821 = load i64, i64* %iPtr
%val5822 = load i32*, i32** %bufPtr
; pointer ref
%val5823 = getelementptr i32, i32* %val5822, i64 %val5821
%val5824 = load i32, i32* %val5823
%val5825 = load i32, i32* %pivotPtr
%cmp5826 = icmp slt i32 %val5824, %val5825
store i1 %cmp5826, i1* %ifptr5814
br label %ifcont5814

else5814:
%val5828 = load i64, i64* %iPtr
%val5829 = load i32*, i32** %bufPtr
; pointer ref
%val5830 = getelementptr i32, i32* %val5829, i64 %val5828
%val5831 = load i32, i32* %val5830
%val5832 = load i32, i32* %pivotPtr
%cmp5833 = icmp eq i32 %val5831, %val5832
br i1 %cmp5833, label %then5827, label %else5827

then5827:
%val5834 = load i64, i64* %iPtr
%val5835 = load i32*, i32** %bufPtr
; pointer ref
%val5836 = getelementptr i32, i32* %val5835, i64 %val5834
%val5837 = load i32, i32* %val5836
%val5838 = load i32, i32* %pivotPtr
%cmp5839 = icmp eq i32 %val5837, %val5838
store i1 %cmp5839, i1* %ifptr5827
br label %ifcont5827

else5827:
%res5840 = call ccc i1 @impc_false()
store i1 %res5840, i1* %ifptr5827
br label %ifcont5827

ifcont5827:
%ifres5841 = load i1, i1* %ifptr5827

store i1 %ifres5841, i1* %ifptr5814
br label %ifcont5814

ifcont5814:
%ifres5842 = load i1, i1* %ifptr5814

br i1 %ifres5842, label %then5813, label %else5813

then5813:
%val5843 = load i64, i64* %iPtr
%val5844 = load i64, i64* %indexPtr

; apply closure 
%vval5845 = load {i8*, i8*, i32 (i8*, i8*, i64, i64)*}**, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}*** %_swapPtr
%val5846 = load {i8*, i8*, i32 (i8*, i8*, i64, i64)*}*,{i8*, i8*, i32 (i8*, i8*, i64, i64)*}** %vval5845
%fPtr5847 = getelementptr {i8*, i8*, i32 (i8*, i8*, i64, i64)*}, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}* %val5846, i32 0, i32 2
%ePtr5848 = getelementptr {i8*, i8*, i32 (i8*, i8*, i64, i64)*}, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}* %val5846, i32 0, i32 1
%f5849 = load i32 (i8*, i8*, i64, i64)*, i32 (i8*, i8*, i64, i64)** %fPtr5847
%e5850 = load i8*, i8** %ePtr5848
%tzone5851 = load i8*, i8** %_impzPtr
%zone5852 = bitcast i8* %tzone5851 to %mzone*
%z5853 = bitcast %mzone* %zone5852 to i8*
%result5854 = tail call fastcc i32 %f5849(i8* %z5853, i8* %e5850, i64 %val5843, i64 %val5844)
; do set!
%val5855 = load i64, i64* %indexPtr
%val5856 = add i64 %val5855, 1
store i64 %val5856, i64* %indexPtr
store i64 %val5856, i64* %ifptr5813
br label %ifcont5813

else5813:
br label %ifcont5813

ifcont5813:
%ifres5857 = load i64, i64* %ifptr5813

%loop_cnt5808 = load i64, i64* %iPtr
%next5808 = add i64 %loop_cnt5808, 1
store i64 %next5808, i64* %iPtr
%cmp5808 = icmp ult i64 %next5808, %num5859
br i1 %cmp5808, label %loop5808, label %after5808

after5808:
%val5862 = load i64, i64* %rightPtr
%val5863 = load i64, i64* %indexPtr

; apply closure 
%vval5864 = load {i8*, i8*, i32 (i8*, i8*, i64, i64)*}**, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}*** %_swapPtr
%val5865 = load {i8*, i8*, i32 (i8*, i8*, i64, i64)*}*,{i8*, i8*, i32 (i8*, i8*, i64, i64)*}** %vval5864
%fPtr5866 = getelementptr {i8*, i8*, i32 (i8*, i8*, i64, i64)*}, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}* %val5865, i32 0, i32 2
%ePtr5867 = getelementptr {i8*, i8*, i32 (i8*, i8*, i64, i64)*}, {i8*, i8*, i32 (i8*, i8*, i64, i64)*}* %val5865, i32 0, i32 1
%f5868 = load i32 (i8*, i8*, i64, i64)*, i32 (i8*, i8*, i64, i64)** %fPtr5866
%e5869 = load i8*, i8** %ePtr5867
%tzone5870 = load i8*, i8** %_impzPtr
%zone5871 = bitcast i8* %tzone5870 to %mzone*
%z5872 = bitcast %mzone* %zone5871 to i8*
%result5873 = tail call fastcc i32 %f5868(i8* %z5872, i8* %e5869, i64 %val5862, i64 %val5863)
%val5874 = load i32*, i32** %bufPtr
%val5875 = load i64, i64* %leftPtr
%val5876 = load i64, i64* %indexPtr
%val5877 = sub i64 %val5876, 1

; apply closure 
%vval5878 = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr
%val5879 = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*,{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %vval5878
%fPtr5880 = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %val5879, i32 0, i32 2
%ePtr5881 = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %val5879, i32 0, i32 1
%f5882 = load void (i8*, i8*, i32*, i64, i64)*, void (i8*, i8*, i32*, i64, i64)** %fPtr5880
%e5883 = load i8*, i8** %ePtr5881
%tzone5884 = load i8*, i8** %_impzPtr
%zone5885 = bitcast i8* %tzone5884 to %mzone*
%z5886 = bitcast %mzone* %zone5885 to i8*
tail call fastcc void %f5882(i8* %z5886, i8* %e5883, i32* %val5874, i64 %val5875, i64 %val5877)
%val5888 = load i32*, i32** %bufPtr
%val5889 = load i64, i64* %indexPtr
%val5890 = add i64 %val5889, 1
%val5891 = load i64, i64* %rightPtr

; apply closure 
%vval5892 = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr
%val5893 = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*,{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %vval5892
%fPtr5894 = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %val5893, i32 0, i32 2
%ePtr5895 = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %val5893, i32 0, i32 1
%f5896 = load void (i8*, i8*, i32*, i64, i64)*, void (i8*, i8*, i32*, i64, i64)** %fPtr5894
%e5897 = load i8*, i8** %ePtr5895
%tzone5898 = load i8*, i8** %_impzPtr
%zone5899 = bitcast i8* %tzone5898 to %mzone*
%z5900 = bitcast %mzone* %zone5899 to i8*
tail call fastcc void %f5896(i8* %z5900, i8* %e5897, i32* %val5888, i64 %val5890, i64 %val5891)
ret void

else5714:
ret void
}
@gsxtmmath229 = hidden constant [97 x i8] c"vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** @vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5924 = load i8*, i8** %_impzPtr
%zone5925 = bitcast i8* %tzone5924 to %mzone*

; let assign value to symbol vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ
%dat_vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone5925, i64 8)
%vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr = bitcast i8* %dat_vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ to { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***
%tzone5905 = load i8*, i8** %_impzPtr
%zone5906 = bitcast i8* %tzone5905 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5906)
; malloc closure structure
%clsptr5907 = call i8* @llvm_zone_malloc(%mzone* %zone5906, i64 24)
%closure5908 = bitcast i8* %clsptr5907 to { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*

; malloc environment structure
%envptr5909 = call i8* @llvm_zone_malloc(%mzone* %zone5906, i64 8)
%environment5910 = bitcast i8* %envptr5909 to {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***}*

; malloc closure address table
%addytable5911 = call %clsvar* @new_address_table()
%var5912 = bitcast [44 x i8]* @gsxtmmath225 to i8*
%var5913 = bitcast [47 x i8]* @gsxtmmath40 to i8*
%addytable5914 = call %clsvar* @add_address_table(%mzone* %zone5906, i8* %var5912, i32 0, i8* %var5913, i32 3, %clsvar* %addytable5911)
%address-table5915 = bitcast %clsvar* %addytable5914 to i8*

; insert table, function and environment into closure struct
%closure.table5918 = getelementptr { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure5908, i32 0, i32 0
store i8* %address-table5915, i8** %closure.table5918
%closure.env5919 = getelementptr { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure5908, i32 0, i32 1
store i8* %envptr5909, i8** %closure.env5919
%closure.func5920 = getelementptr { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure5908, i32 0, i32 2
store void (i8*, i8*, i32*, i64, i64)* @vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ__5711, void (i8*, i8*, i32*, i64, i64)** %closure.func5920
%closure_size5921 = call i64 @llvm_zone_mark_size(%mzone* %zone5906)
call void @llvm_zone_ptr_set_size(i8* %clsptr5907, i64 %closure_size5921)
%wrapper_ptr5922 = call i8* @llvm_zone_malloc(%mzone* %zone5906, i64 8)
%closure_wrapper5923 = bitcast i8* %wrapper_ptr5922 to { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**
store { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure5908, { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure_wrapper5923

; let value assignment
%vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure_wrapper5923, { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure_wrapper5923
store { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ, { i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ
%tmp_envptr5917 = getelementptr {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}***}* %environment5910, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**** %tmp_envptr5917


%val5926 = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %val5926
}


@vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** @vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ(i32* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32*, i64, i64)*,  void (i8*, i8*, i32*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_native(i32* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32*, i64, i64)*,  void (i8*, i8*, i32*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5927 = bitcast [97 x i8]* @gsxtmmath229 to i8*
call i32 (i8*, ...) @printf(i8* %var5927)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i32*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5928 = bitcast [97 x i8]* @gsxtmmath229 to i8*
call i32 (i8*, ...) @printf(i8* %var5928)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5929 = bitcast [97 x i8]* @gsxtmmath229 to i8*
call i32 (i8*, ...) @printf(i8* %var5929)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32*, i64, i64)*,  void (i8*, i8*, i32*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32*, i64, i64}*
%arg_p_0 = getelementptr {i32*, i64, i64}, {i32*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i32*, i32** %arg_p_0
%arg_p_1 = getelementptr {i32*, i64, i64}, {i32*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {i32*, i64, i64}, {i32*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32*, i64, i64)*,  void (i8*, i8*, i32*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath230 = hidden constant [44 x i8] c"vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ\00"
@gsxtmmath231 = hidden constant [47 x i8] c"{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}**\00"
@gsxtmmath232 = hidden constant [5 x i8] c"i16*\00"
@gsxtmmath233 = hidden constant [4 x i8] c"i16\00"
@gsxtmmath234 = hidden constant [40 x i8] c"{i8*, i8*, i16 (i8*, i8*, i64, i64)*}**\00"
define dllexport fastcc i16 @vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ__5931(i8* %_impz,i8* %_impenv, i64 %x, i64 %y) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5939 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}*
%vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}, {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}* %impenv, i32 0, i32 0
%vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}**** %vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQPtr_
%rightPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}, {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}* %impenv, i32 0, i32 1
%rightPtr = load i64*, i64** %rightPtr_
%leftPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}, {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}* %impenv, i32 0, i32 2
%leftPtr = load i64*, i64** %leftPtr_
%bufPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}, {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}* %impenv, i32 0, i32 3
%bufPtr = load i16**, i16*** %bufPtr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}, {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}* %impenv, i32 0, i32 4
%iPtr = load i64*, i64** %iPtr_
%indexPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}, {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}* %impenv, i32 0, i32 5
%indexPtr = load i64*, i64** %indexPtr_
%pivotPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}, {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}* %impenv, i32 0, i32 6
%pivotPtr = load i16*, i16** %pivotPtr_
%_swapPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}, {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}* %impenv, i32 0, i32 7
%_swapPtr = load {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}**** %_swapPtr_
%tmpPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}, {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}* %impenv, i32 0, i32 8
%tmpPtr = load i16*, i16** %tmpPtr_

; setup arguments
%xPtr = alloca i64
store i64 %x, i64* %xPtr
%yPtr = alloca i64
store i64 %y, i64* %yPtr


; do set!
%val5940 = load i64, i64* %xPtr
%val5941 = load i16*, i16** %bufPtr
; pointer ref
%val5942 = getelementptr i16, i16* %val5941, i64 %val5940
%val5943 = load i16, i16* %val5942
store i16 %val5943, i16* %tmpPtr
%val5944 = load i64, i64* %xPtr
%val5945 = load i16*, i16** %bufPtr
%val5946 = load i64, i64* %yPtr
%val5947 = load i16*, i16** %bufPtr
; pointer ref
%val5948 = getelementptr i16, i16* %val5947, i64 %val5946
%val5949 = load i16, i16* %val5948
; set pointer
%val5950 = getelementptr i16, i16* %val5945, i64 %val5944
store i16 %val5949, i16* %val5950
%val5951 = load i64, i64* %yPtr
%val5952 = load i16*, i16** %bufPtr
%val5953 = load i16, i16* %tmpPtr
; set pointer
%val5954 = getelementptr i16, i16* %val5952, i64 %val5951
store i16 %val5953, i16* %val5954
ret i16 %val5953
}
define dllexport fastcc void @vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ__5930(i8* %_impz,i8* %_impenv, i16* %buf, i64 %left, i64 %right) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5932 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***}*
%vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***}* %impenv, i32 0, i32 0
%vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}**** %vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQPtr_

; setup arguments
%dat_buf = alloca i8, i64 8, align 16
%bufPtr = bitcast i8* %dat_buf to i16**
store i16* %buf, i16** %bufPtr
%dat_left = alloca i8, i64 8, align 16
%leftPtr = bitcast i8* %dat_left to i64*
store i64 %left, i64* %leftPtr
%dat_right = alloca i8, i64 8, align 16
%rightPtr = bitcast i8* %dat_right to i64*
store i64 %right, i64* %rightPtr


%val5934 = load i64, i64* %leftPtr
%val5935 = load i64, i64* %rightPtr
%cmp5936 = icmp slt i64 %val5934, %val5935
br i1 %cmp5936, label %then5933, label %else5933

then5933:
%tzone5937 = load i8*, i8** %_impzPtr
%zone5938 = bitcast i8* %tzone5937 to %mzone*

; let assign value to symbol tmp
%tmpPtr = alloca i16
%tzone6014 = load i8*, i8** %_impzPtr
%zone6015 = bitcast i8* %tzone6014 to %mzone*

; let assign value to symbol _swap
%_swapPtr = alloca { i8*, i8*, i16 (i8*, i8*, i64, i64)*}**
%tzone6020 = load i8*, i8** %_impzPtr
%zone6021 = bitcast i8* %tzone6020 to %mzone*

; let assign value to symbol pivot
%pivotPtr = alloca i16
%tzone6023 = load i8*, i8** %_impzPtr
%zone6024 = bitcast i8* %tzone6023 to %mzone*

; let assign value to symbol index
%indexPtr = alloca i64
%tzone6025 = load i8*, i8** %_impzPtr
%zone6026 = bitcast i8* %tzone6025 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%tmp = select i1 true, i16 0, i16 0
store i16 %tmp, i16* %tmpPtr

%tzone5955 = load i8*, i8** %_impzPtr
%zone5956 = bitcast i8* %tzone5955 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5956)
; malloc closure structure
%clsptr5957 = alloca i8, i64 24, align 16
%closure5958 = bitcast i8* %clsptr5957 to { i8*, i8*, i16 (i8*, i8*, i64, i64)*}*

; malloc environment structure
%envptr5959 = alloca i8, i64 72, align 16
%environment5960 = bitcast i8* %envptr5959 to {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}*

; malloc closure address table
%addytable5961 = call %clsvar* @new_address_table()
%var5962 = bitcast [44 x i8]* @gsxtmmath230 to i8*
%var5963 = bitcast [47 x i8]* @gsxtmmath231 to i8*
%addytable5964 = call %clsvar* @add_address_table(%mzone* %zone5956, i8* %var5962, i32 0, i8* %var5963, i32 2, %clsvar* %addytable5961)
%var5965 = bitcast [6 x i8]* @gsxtmmath205 to i8*
%var5966 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5967 = call %clsvar* @add_address_table(%mzone* %zone5956, i8* %var5965, i32 8, i8* %var5966, i32 2, %clsvar* %addytable5964)
%var5968 = bitcast [5 x i8]* @gsxtmmath206 to i8*
%var5969 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5970 = call %clsvar* @add_address_table(%mzone* %zone5956, i8* %var5968, i32 16, i8* %var5969, i32 2, %clsvar* %addytable5967)
%var5971 = bitcast [4 x i8]* @gsxtmmath207 to i8*
%var5972 = bitcast [5 x i8]* @gsxtmmath232 to i8*
%addytable5973 = call %clsvar* @add_address_table(%mzone* %zone5956, i8* %var5971, i32 24, i8* %var5972, i32 2, %clsvar* %addytable5970)
%var5974 = bitcast [2 x i8]* @gsxtmmath93 to i8*
%var5975 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5976 = call %clsvar* @add_address_table(%mzone* %zone5956, i8* %var5974, i32 32, i8* %var5975, i32 2, %clsvar* %addytable5973)
%var5977 = bitcast [6 x i8]* @gsxtmmath209 to i8*
%var5978 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable5979 = call %clsvar* @add_address_table(%mzone* %zone5956, i8* %var5977, i32 40, i8* %var5978, i32 2, %clsvar* %addytable5976)
%var5980 = bitcast [6 x i8]* @gsxtmmath210 to i8*
%var5981 = bitcast [4 x i8]* @gsxtmmath233 to i8*
%addytable5982 = call %clsvar* @add_address_table(%mzone* %zone5956, i8* %var5980, i32 48, i8* %var5981, i32 2, %clsvar* %addytable5979)
%var5983 = bitcast [6 x i8]* @gsxtmmath212 to i8*
%var5984 = bitcast [40 x i8]* @gsxtmmath234 to i8*
%addytable5985 = call %clsvar* @add_address_table(%mzone* %zone5956, i8* %var5983, i32 56, i8* %var5984, i32 2, %clsvar* %addytable5982)
%var5986 = bitcast [4 x i8]* @gsxtmmath214 to i8*
%var5987 = bitcast [4 x i8]* @gsxtmmath233 to i8*
%addytable5988 = call %clsvar* @add_address_table(%mzone* %zone5956, i8* %var5986, i32 64, i8* %var5987, i32 2, %clsvar* %addytable5985)
%address-table5989 = bitcast %clsvar* %addytable5988 to i8*

; insert table, function and environment into closure struct
%closure.table6008 = getelementptr { i8*, i8*, i16 (i8*, i8*, i64, i64)*}, { i8*, i8*, i16 (i8*, i8*, i64, i64)*}* %closure5958, i32 0, i32 0
store i8* %address-table5989, i8** %closure.table6008
%closure.env6009 = getelementptr { i8*, i8*, i16 (i8*, i8*, i64, i64)*}, { i8*, i8*, i16 (i8*, i8*, i64, i64)*}* %closure5958, i32 0, i32 1
store i8* %envptr5959, i8** %closure.env6009
%closure.func6010 = getelementptr { i8*, i8*, i16 (i8*, i8*, i64, i64)*}, { i8*, i8*, i16 (i8*, i8*, i64, i64)*}* %closure5958, i32 0, i32 2
store i16 (i8*, i8*, i64, i64)* @vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ__5931, i16 (i8*, i8*, i64, i64)** %closure.func6010
%closure_size6011 = call i64 @llvm_zone_mark_size(%mzone* %zone5956)
call void @llvm_zone_ptr_set_size(i8* %clsptr5957, i64 %closure_size6011)
%wrapper_ptr6012 = alloca i8,  i32 8, align 16
%closure_wrapper6013 = bitcast i8* %wrapper_ptr6012 to { i8*, i8*, i16 (i8*, i8*, i64, i64)*}**
store { i8*, i8*, i16 (i8*, i8*, i64, i64)*}* %closure5958, { i8*, i8*, i16 (i8*, i8*, i64, i64)*}** %closure_wrapper6013

; let value assignment
%_swap = select i1 true, { i8*, i8*, i16 (i8*, i8*, i64, i64)*}** %closure_wrapper6013, { i8*, i8*, i16 (i8*, i8*, i64, i64)*}** %closure_wrapper6013
store { i8*, i8*, i16 (i8*, i8*, i64, i64)*}** %_swap, { i8*, i8*, i16 (i8*, i8*, i64, i64)*}*** %_swapPtr

%val6016 = load i64, i64* %rightPtr
%val6017 = load i16*, i16** %bufPtr
; pointer ref
%val6018 = getelementptr i16, i16* %val6017, i64 %val6016
%val6019 = load i16, i16* %val6018

; let value assignment
%pivot = select i1 true, i16 %val6019, i16 %val6019
store i16 %pivot, i16* %pivotPtr

%val6022 = load i64, i64* %leftPtr

; let value assignment
%index = select i1 true, i64 %val6022, i64 %val6022
store i64 %index, i64* %indexPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; add data to environment
; don't need to alloc for env var vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ
%tmp_envptr5991 = getelementptr {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}, {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}* %environment5960, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQPtr, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}**** %tmp_envptr5991

; don't need to alloc for env var right
%tmp_envptr5993 = getelementptr {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}, {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}* %environment5960, i32 0, i32 1
store i64* %rightPtr, i64** %tmp_envptr5993

; don't need to alloc for env var left
%tmp_envptr5995 = getelementptr {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}, {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}* %environment5960, i32 0, i32 2
store i64* %leftPtr, i64** %tmp_envptr5995

; don't need to alloc for env var buf
%tmp_envptr5997 = getelementptr {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}, {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}* %environment5960, i32 0, i32 3
store i16** %bufPtr, i16*** %tmp_envptr5997

; don't need to alloc for env var i
%tmp_envptr5999 = getelementptr {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}, {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}* %environment5960, i32 0, i32 4
store i64* %iPtr, i64** %tmp_envptr5999

; don't need to alloc for env var index
%tmp_envptr6001 = getelementptr {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}, {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}* %environment5960, i32 0, i32 5
store i64* %indexPtr, i64** %tmp_envptr6001

; don't need to alloc for env var pivot
%tmp_envptr6003 = getelementptr {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}, {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}* %environment5960, i32 0, i32 6
store i16* %pivotPtr, i16** %tmp_envptr6003

; don't need to alloc for env var _swap
%tmp_envptr6005 = getelementptr {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}, {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}* %environment5960, i32 0, i32 7
store {i8*, i8*, i16 (i8*, i8*, i64, i64)*}*** %_swapPtr, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}**** %tmp_envptr6005

; don't need to alloc for env var tmp
%tmp_envptr6007 = getelementptr {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}, {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***, i64*, i64*, i16**, i64*, i64*, i16*, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}***, i16*}* %environment5960, i32 0, i32 8
store i16* %tmpPtr, i16** %tmp_envptr6007


; promote local stack var allocations
%tzone6121 = load i8*, i8** %_impzPtr
%zone6122 = bitcast i8* %tzone6121 to %mzone*
%ifptr6032 = alloca i64
%ifptr6033 = alloca i1
%ifptr6046 = alloca i1
; setup loop
%val6029 = load i64, i64* %rightPtr
%val6030 = load i64, i64* %leftPtr
%val6031 = sub i64 %val6029, %val6030
%val6028 = load i64, i64* %leftPtr
store i64 %val6028, i64* %iPtr
%val6077 = load i64, i64* %iPtr
%num6078 = add i64 %val6031, %val6077
%comp6079 = icmp ult i64 %val6031, 1
br i1 %comp6079, label %after6027, label %loop6027

loop6027:
%val6034 = load i64, i64* %iPtr
%val6035 = load i16*, i16** %bufPtr
; pointer ref
%val6036 = getelementptr i16, i16* %val6035, i64 %val6034
%val6037 = load i16, i16* %val6036
%val6038 = load i16, i16* %pivotPtr
%cmp6039 = icmp slt i16 %val6037, %val6038
br i1 %cmp6039, label %then6033, label %else6033

then6033:
%val6040 = load i64, i64* %iPtr
%val6041 = load i16*, i16** %bufPtr
; pointer ref
%val6042 = getelementptr i16, i16* %val6041, i64 %val6040
%val6043 = load i16, i16* %val6042
%val6044 = load i16, i16* %pivotPtr
%cmp6045 = icmp slt i16 %val6043, %val6044
store i1 %cmp6045, i1* %ifptr6033
br label %ifcont6033

else6033:
%val6047 = load i64, i64* %iPtr
%val6048 = load i16*, i16** %bufPtr
; pointer ref
%val6049 = getelementptr i16, i16* %val6048, i64 %val6047
%val6050 = load i16, i16* %val6049
%val6051 = load i16, i16* %pivotPtr
%cmp6052 = icmp eq i16 %val6050, %val6051
br i1 %cmp6052, label %then6046, label %else6046

then6046:
%val6053 = load i64, i64* %iPtr
%val6054 = load i16*, i16** %bufPtr
; pointer ref
%val6055 = getelementptr i16, i16* %val6054, i64 %val6053
%val6056 = load i16, i16* %val6055
%val6057 = load i16, i16* %pivotPtr
%cmp6058 = icmp eq i16 %val6056, %val6057
store i1 %cmp6058, i1* %ifptr6046
br label %ifcont6046

else6046:
%res6059 = call ccc i1 @impc_false()
store i1 %res6059, i1* %ifptr6046
br label %ifcont6046

ifcont6046:
%ifres6060 = load i1, i1* %ifptr6046

store i1 %ifres6060, i1* %ifptr6033
br label %ifcont6033

ifcont6033:
%ifres6061 = load i1, i1* %ifptr6033

br i1 %ifres6061, label %then6032, label %else6032

then6032:
%val6062 = load i64, i64* %iPtr
%val6063 = load i64, i64* %indexPtr

; apply closure 
%vval6064 = load {i8*, i8*, i16 (i8*, i8*, i64, i64)*}**, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}*** %_swapPtr
%val6065 = load {i8*, i8*, i16 (i8*, i8*, i64, i64)*}*,{i8*, i8*, i16 (i8*, i8*, i64, i64)*}** %vval6064
%fPtr6066 = getelementptr {i8*, i8*, i16 (i8*, i8*, i64, i64)*}, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}* %val6065, i32 0, i32 2
%ePtr6067 = getelementptr {i8*, i8*, i16 (i8*, i8*, i64, i64)*}, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}* %val6065, i32 0, i32 1
%f6068 = load i16 (i8*, i8*, i64, i64)*, i16 (i8*, i8*, i64, i64)** %fPtr6066
%e6069 = load i8*, i8** %ePtr6067
%tzone6070 = load i8*, i8** %_impzPtr
%zone6071 = bitcast i8* %tzone6070 to %mzone*
%z6072 = bitcast %mzone* %zone6071 to i8*
%result6073 = tail call fastcc i16 %f6068(i8* %z6072, i8* %e6069, i64 %val6062, i64 %val6063)
; do set!
%val6074 = load i64, i64* %indexPtr
%val6075 = add i64 %val6074, 1
store i64 %val6075, i64* %indexPtr
store i64 %val6075, i64* %ifptr6032
br label %ifcont6032

else6032:
br label %ifcont6032

ifcont6032:
%ifres6076 = load i64, i64* %ifptr6032

%loop_cnt6027 = load i64, i64* %iPtr
%next6027 = add i64 %loop_cnt6027, 1
store i64 %next6027, i64* %iPtr
%cmp6027 = icmp ult i64 %next6027, %num6078
br i1 %cmp6027, label %loop6027, label %after6027

after6027:
%val6081 = load i64, i64* %rightPtr
%val6082 = load i64, i64* %indexPtr

; apply closure 
%vval6083 = load {i8*, i8*, i16 (i8*, i8*, i64, i64)*}**, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}*** %_swapPtr
%val6084 = load {i8*, i8*, i16 (i8*, i8*, i64, i64)*}*,{i8*, i8*, i16 (i8*, i8*, i64, i64)*}** %vval6083
%fPtr6085 = getelementptr {i8*, i8*, i16 (i8*, i8*, i64, i64)*}, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}* %val6084, i32 0, i32 2
%ePtr6086 = getelementptr {i8*, i8*, i16 (i8*, i8*, i64, i64)*}, {i8*, i8*, i16 (i8*, i8*, i64, i64)*}* %val6084, i32 0, i32 1
%f6087 = load i16 (i8*, i8*, i64, i64)*, i16 (i8*, i8*, i64, i64)** %fPtr6085
%e6088 = load i8*, i8** %ePtr6086
%tzone6089 = load i8*, i8** %_impzPtr
%zone6090 = bitcast i8* %tzone6089 to %mzone*
%z6091 = bitcast %mzone* %zone6090 to i8*
%result6092 = tail call fastcc i16 %f6087(i8* %z6091, i8* %e6088, i64 %val6081, i64 %val6082)
%val6093 = load i16*, i16** %bufPtr
%val6094 = load i64, i64* %leftPtr
%val6095 = load i64, i64* %indexPtr
%val6096 = sub i64 %val6095, 1

; apply closure 
%vval6097 = load {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQPtr
%val6098 = load {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}*,{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}** %vval6097
%fPtr6099 = getelementptr {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}* %val6098, i32 0, i32 2
%ePtr6100 = getelementptr {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}* %val6098, i32 0, i32 1
%f6101 = load void (i8*, i8*, i16*, i64, i64)*, void (i8*, i8*, i16*, i64, i64)** %fPtr6099
%e6102 = load i8*, i8** %ePtr6100
%tzone6103 = load i8*, i8** %_impzPtr
%zone6104 = bitcast i8* %tzone6103 to %mzone*
%z6105 = bitcast %mzone* %zone6104 to i8*
tail call fastcc void %f6101(i8* %z6105, i8* %e6102, i16* %val6093, i64 %val6094, i64 %val6096)
%val6107 = load i16*, i16** %bufPtr
%val6108 = load i64, i64* %indexPtr
%val6109 = add i64 %val6108, 1
%val6110 = load i64, i64* %rightPtr

; apply closure 
%vval6111 = load {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQPtr
%val6112 = load {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}*,{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}** %vval6111
%fPtr6113 = getelementptr {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}* %val6112, i32 0, i32 2
%ePtr6114 = getelementptr {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}* %val6112, i32 0, i32 1
%f6115 = load void (i8*, i8*, i16*, i64, i64)*, void (i8*, i8*, i16*, i64, i64)** %fPtr6113
%e6116 = load i8*, i8** %ePtr6114
%tzone6117 = load i8*, i8** %_impzPtr
%zone6118 = bitcast i8* %tzone6117 to %mzone*
%z6119 = bitcast %mzone* %zone6118 to i8*
tail call fastcc void %f6115(i8* %z6119, i8* %e6116, i16* %val6107, i64 %val6109, i64 %val6110)
ret void

else5933:
ret void
}
@gsxtmmath235 = hidden constant [97 x i8] c"vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}** @vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6143 = load i8*, i8** %_impzPtr
%zone6144 = bitcast i8* %tzone6143 to %mzone*

; let assign value to symbol vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ
%dat_vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone6144, i64 8)
%vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQPtr = bitcast i8* %dat_vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ to { i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***
%tzone6124 = load i8*, i8** %_impzPtr
%zone6125 = bitcast i8* %tzone6124 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6125)
; malloc closure structure
%clsptr6126 = call i8* @llvm_zone_malloc(%mzone* %zone6125, i64 24)
%closure6127 = bitcast i8* %clsptr6126 to { i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}*

; malloc environment structure
%envptr6128 = call i8* @llvm_zone_malloc(%mzone* %zone6125, i64 8)
%environment6129 = bitcast i8* %envptr6128 to {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***}*

; malloc closure address table
%addytable6130 = call %clsvar* @new_address_table()
%var6131 = bitcast [44 x i8]* @gsxtmmath230 to i8*
%var6132 = bitcast [47 x i8]* @gsxtmmath231 to i8*
%addytable6133 = call %clsvar* @add_address_table(%mzone* %zone6125, i8* %var6131, i32 0, i8* %var6132, i32 3, %clsvar* %addytable6130)
%address-table6134 = bitcast %clsvar* %addytable6133 to i8*

; insert table, function and environment into closure struct
%closure.table6137 = getelementptr { i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}* %closure6127, i32 0, i32 0
store i8* %address-table6134, i8** %closure.table6137
%closure.env6138 = getelementptr { i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}* %closure6127, i32 0, i32 1
store i8* %envptr6128, i8** %closure.env6138
%closure.func6139 = getelementptr { i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}* %closure6127, i32 0, i32 2
store void (i8*, i8*, i16*, i64, i64)* @vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ__5930, void (i8*, i8*, i16*, i64, i64)** %closure.func6139
%closure_size6140 = call i64 @llvm_zone_mark_size(%mzone* %zone6125)
call void @llvm_zone_ptr_set_size(i8* %clsptr6126, i64 %closure_size6140)
%wrapper_ptr6141 = call i8* @llvm_zone_malloc(%mzone* %zone6125, i64 8)
%closure_wrapper6142 = bitcast i8* %wrapper_ptr6141 to { i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}**
store { i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}* %closure6127, { i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}** %closure_wrapper6142

; let value assignment
%vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}** %closure_wrapper6142, { i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}** %closure_wrapper6142
store { i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}** %vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ, { i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ
%tmp_envptr6136 = getelementptr {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}***}* %environment6129, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQPtr, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}**** %tmp_envptr6136


%val6145 = load {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}** %val6145
}


@vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}** @vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ(i16* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i16*, i64, i64)*,  void (i8*, i8*, i16*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i16* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ_native(i16* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i16*, i64, i64)*,  void (i8*, i8*, i16*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i16* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6146 = bitcast [97 x i8]* @gsxtmmath235 to i8*
call i32 (i8*, ...) @printf(i8* %var6146)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i16*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6147 = bitcast [97 x i8]* @gsxtmmath235 to i8*
call i32 (i8*, ...) @printf(i8* %var6147)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var6148 = bitcast [97 x i8]* @gsxtmmath235 to i8*
call i32 (i8*, ...) @printf(i8* %var6148)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i16*, i64, i64)*,  void (i8*, i8*, i16*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i16* %arg_0, i64 %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i16*, i64, i64}*
%arg_p_0 = getelementptr {i16*, i64, i64}, {i16*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i16*, i16** %arg_p_0
%arg_p_1 = getelementptr {i16*, i64, i64}, {i16*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {i16*, i64, i64}, {i16*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i16*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i16*, i64, i64)*,  void (i8*, i8*, i16*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i16* %arg_0, i64 %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath236 = hidden constant [42 x i8] c"vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd\00"
@gsxtmmath237 = hidden constant [46 x i8] c"{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}**\00"
@gsxtmmath238 = hidden constant [4 x i8] c"i8*\00"
@gsxtmmath239 = hidden constant [3 x i8] c"i8\00"
@gsxtmmath240 = hidden constant [39 x i8] c"{i8*, i8*, i8 (i8*, i8*, i64, i64)*}**\00"
define dllexport fastcc i8 @vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd__6150(i8* %_impz,i8* %_impenv, i64 %x, i64 %y) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6158 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}*
%vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}, {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}* %impenv, i32 0, i32 0
%vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRdPtr = load {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}**** %vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRdPtr_
%rightPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}, {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}* %impenv, i32 0, i32 1
%rightPtr = load i64*, i64** %rightPtr_
%leftPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}, {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}* %impenv, i32 0, i32 2
%leftPtr = load i64*, i64** %leftPtr_
%bufPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}, {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}* %impenv, i32 0, i32 3
%bufPtr = load i8**, i8*** %bufPtr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}, {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}* %impenv, i32 0, i32 4
%iPtr = load i64*, i64** %iPtr_
%indexPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}, {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}* %impenv, i32 0, i32 5
%indexPtr = load i64*, i64** %indexPtr_
%pivotPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}, {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}* %impenv, i32 0, i32 6
%pivotPtr = load i8*, i8** %pivotPtr_
%_swapPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}, {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}* %impenv, i32 0, i32 7
%_swapPtr = load {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}**** %_swapPtr_
%tmpPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}, {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}* %impenv, i32 0, i32 8
%tmpPtr = load i8*, i8** %tmpPtr_

; setup arguments
%xPtr = alloca i64
store i64 %x, i64* %xPtr
%yPtr = alloca i64
store i64 %y, i64* %yPtr


; do set!
%val6159 = load i64, i64* %xPtr
%val6160 = load i8*, i8** %bufPtr
; pointer ref
%val6161 = getelementptr i8, i8* %val6160, i64 %val6159
%val6162 = load i8, i8* %val6161
store i8 %val6162, i8* %tmpPtr
%val6163 = load i64, i64* %xPtr
%val6164 = load i8*, i8** %bufPtr
%val6165 = load i64, i64* %yPtr
%val6166 = load i8*, i8** %bufPtr
; pointer ref
%val6167 = getelementptr i8, i8* %val6166, i64 %val6165
%val6168 = load i8, i8* %val6167
; set pointer
%val6169 = getelementptr i8, i8* %val6164, i64 %val6163
store i8 %val6168, i8* %val6169
%val6170 = load i64, i64* %yPtr
%val6171 = load i8*, i8** %bufPtr
%val6172 = load i8, i8* %tmpPtr
; set pointer
%val6173 = getelementptr i8, i8* %val6171, i64 %val6170
store i8 %val6172, i8* %val6173
ret i8 %val6172
}
define dllexport fastcc void @vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd__6149(i8* %_impz,i8* %_impenv, i8* %buf, i64 %left, i64 %right) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6151 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***}*
%vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***}* %impenv, i32 0, i32 0
%vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRdPtr = load {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}**** %vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRdPtr_

; setup arguments
%dat_buf = alloca i8, i64 8, align 16
%bufPtr = bitcast i8* %dat_buf to i8**
store i8* %buf, i8** %bufPtr
%dat_left = alloca i8, i64 8, align 16
%leftPtr = bitcast i8* %dat_left to i64*
store i64 %left, i64* %leftPtr
%dat_right = alloca i8, i64 8, align 16
%rightPtr = bitcast i8* %dat_right to i64*
store i64 %right, i64* %rightPtr


%val6153 = load i64, i64* %leftPtr
%val6154 = load i64, i64* %rightPtr
%cmp6155 = icmp slt i64 %val6153, %val6154
br i1 %cmp6155, label %then6152, label %else6152

then6152:
%tzone6156 = load i8*, i8** %_impzPtr
%zone6157 = bitcast i8* %tzone6156 to %mzone*

; let assign value to symbol tmp
%tmpPtr = alloca i8
%tzone6233 = load i8*, i8** %_impzPtr
%zone6234 = bitcast i8* %tzone6233 to %mzone*

; let assign value to symbol _swap
%_swapPtr = alloca { i8*, i8*, i8 (i8*, i8*, i64, i64)*}**
%tzone6239 = load i8*, i8** %_impzPtr
%zone6240 = bitcast i8* %tzone6239 to %mzone*

; let assign value to symbol pivot
%pivotPtr = alloca i8
%tzone6242 = load i8*, i8** %_impzPtr
%zone6243 = bitcast i8* %tzone6242 to %mzone*

; let assign value to symbol index
%indexPtr = alloca i64
%tzone6244 = load i8*, i8** %_impzPtr
%zone6245 = bitcast i8* %tzone6244 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%tmp = select i1 true, i8 0, i8 0
store i8 %tmp, i8* %tmpPtr

%tzone6174 = load i8*, i8** %_impzPtr
%zone6175 = bitcast i8* %tzone6174 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6175)
; malloc closure structure
%clsptr6176 = alloca i8, i64 24, align 16
%closure6177 = bitcast i8* %clsptr6176 to { i8*, i8*, i8 (i8*, i8*, i64, i64)*}*

; malloc environment structure
%envptr6178 = alloca i8, i64 72, align 16
%environment6179 = bitcast i8* %envptr6178 to {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}*

; malloc closure address table
%addytable6180 = call %clsvar* @new_address_table()
%var6181 = bitcast [42 x i8]* @gsxtmmath236 to i8*
%var6182 = bitcast [46 x i8]* @gsxtmmath237 to i8*
%addytable6183 = call %clsvar* @add_address_table(%mzone* %zone6175, i8* %var6181, i32 0, i8* %var6182, i32 2, %clsvar* %addytable6180)
%var6184 = bitcast [6 x i8]* @gsxtmmath205 to i8*
%var6185 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable6186 = call %clsvar* @add_address_table(%mzone* %zone6175, i8* %var6184, i32 8, i8* %var6185, i32 2, %clsvar* %addytable6183)
%var6187 = bitcast [5 x i8]* @gsxtmmath206 to i8*
%var6188 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable6189 = call %clsvar* @add_address_table(%mzone* %zone6175, i8* %var6187, i32 16, i8* %var6188, i32 2, %clsvar* %addytable6186)
%var6190 = bitcast [4 x i8]* @gsxtmmath207 to i8*
%var6191 = bitcast [4 x i8]* @gsxtmmath238 to i8*
%addytable6192 = call %clsvar* @add_address_table(%mzone* %zone6175, i8* %var6190, i32 24, i8* %var6191, i32 2, %clsvar* %addytable6189)
%var6193 = bitcast [2 x i8]* @gsxtmmath93 to i8*
%var6194 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable6195 = call %clsvar* @add_address_table(%mzone* %zone6175, i8* %var6193, i32 32, i8* %var6194, i32 2, %clsvar* %addytable6192)
%var6196 = bitcast [6 x i8]* @gsxtmmath209 to i8*
%var6197 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable6198 = call %clsvar* @add_address_table(%mzone* %zone6175, i8* %var6196, i32 40, i8* %var6197, i32 2, %clsvar* %addytable6195)
%var6199 = bitcast [6 x i8]* @gsxtmmath210 to i8*
%var6200 = bitcast [3 x i8]* @gsxtmmath239 to i8*
%addytable6201 = call %clsvar* @add_address_table(%mzone* %zone6175, i8* %var6199, i32 48, i8* %var6200, i32 2, %clsvar* %addytable6198)
%var6202 = bitcast [6 x i8]* @gsxtmmath212 to i8*
%var6203 = bitcast [39 x i8]* @gsxtmmath240 to i8*
%addytable6204 = call %clsvar* @add_address_table(%mzone* %zone6175, i8* %var6202, i32 56, i8* %var6203, i32 2, %clsvar* %addytable6201)
%var6205 = bitcast [4 x i8]* @gsxtmmath214 to i8*
%var6206 = bitcast [3 x i8]* @gsxtmmath239 to i8*
%addytable6207 = call %clsvar* @add_address_table(%mzone* %zone6175, i8* %var6205, i32 64, i8* %var6206, i32 2, %clsvar* %addytable6204)
%address-table6208 = bitcast %clsvar* %addytable6207 to i8*

; insert table, function and environment into closure struct
%closure.table6227 = getelementptr { i8*, i8*, i8 (i8*, i8*, i64, i64)*}, { i8*, i8*, i8 (i8*, i8*, i64, i64)*}* %closure6177, i32 0, i32 0
store i8* %address-table6208, i8** %closure.table6227
%closure.env6228 = getelementptr { i8*, i8*, i8 (i8*, i8*, i64, i64)*}, { i8*, i8*, i8 (i8*, i8*, i64, i64)*}* %closure6177, i32 0, i32 1
store i8* %envptr6178, i8** %closure.env6228
%closure.func6229 = getelementptr { i8*, i8*, i8 (i8*, i8*, i64, i64)*}, { i8*, i8*, i8 (i8*, i8*, i64, i64)*}* %closure6177, i32 0, i32 2
store i8 (i8*, i8*, i64, i64)* @vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd__6150, i8 (i8*, i8*, i64, i64)** %closure.func6229
%closure_size6230 = call i64 @llvm_zone_mark_size(%mzone* %zone6175)
call void @llvm_zone_ptr_set_size(i8* %clsptr6176, i64 %closure_size6230)
%wrapper_ptr6231 = alloca i8,  i32 8, align 16
%closure_wrapper6232 = bitcast i8* %wrapper_ptr6231 to { i8*, i8*, i8 (i8*, i8*, i64, i64)*}**
store { i8*, i8*, i8 (i8*, i8*, i64, i64)*}* %closure6177, { i8*, i8*, i8 (i8*, i8*, i64, i64)*}** %closure_wrapper6232

; let value assignment
%_swap = select i1 true, { i8*, i8*, i8 (i8*, i8*, i64, i64)*}** %closure_wrapper6232, { i8*, i8*, i8 (i8*, i8*, i64, i64)*}** %closure_wrapper6232
store { i8*, i8*, i8 (i8*, i8*, i64, i64)*}** %_swap, { i8*, i8*, i8 (i8*, i8*, i64, i64)*}*** %_swapPtr

%val6235 = load i64, i64* %rightPtr
%val6236 = load i8*, i8** %bufPtr
; pointer ref
%val6237 = getelementptr i8, i8* %val6236, i64 %val6235
%val6238 = load i8, i8* %val6237

; let value assignment
%pivot = select i1 true, i8 %val6238, i8 %val6238
store i8 %pivot, i8* %pivotPtr

%val6241 = load i64, i64* %leftPtr

; let value assignment
%index = select i1 true, i64 %val6241, i64 %val6241
store i64 %index, i64* %indexPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; add data to environment
; don't need to alloc for env var vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd
%tmp_envptr6210 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}, {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}* %environment6179, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRdPtr, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}**** %tmp_envptr6210

; don't need to alloc for env var right
%tmp_envptr6212 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}, {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}* %environment6179, i32 0, i32 1
store i64* %rightPtr, i64** %tmp_envptr6212

; don't need to alloc for env var left
%tmp_envptr6214 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}, {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}* %environment6179, i32 0, i32 2
store i64* %leftPtr, i64** %tmp_envptr6214

; don't need to alloc for env var buf
%tmp_envptr6216 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}, {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}* %environment6179, i32 0, i32 3
store i8** %bufPtr, i8*** %tmp_envptr6216

; don't need to alloc for env var i
%tmp_envptr6218 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}, {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}* %environment6179, i32 0, i32 4
store i64* %iPtr, i64** %tmp_envptr6218

; don't need to alloc for env var index
%tmp_envptr6220 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}, {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}* %environment6179, i32 0, i32 5
store i64* %indexPtr, i64** %tmp_envptr6220

; don't need to alloc for env var pivot
%tmp_envptr6222 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}, {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}* %environment6179, i32 0, i32 6
store i8* %pivotPtr, i8** %tmp_envptr6222

; don't need to alloc for env var _swap
%tmp_envptr6224 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}, {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}* %environment6179, i32 0, i32 7
store {i8*, i8*, i8 (i8*, i8*, i64, i64)*}*** %_swapPtr, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}**** %tmp_envptr6224

; don't need to alloc for env var tmp
%tmp_envptr6226 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}, {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***, i64*, i64*, i8**, i64*, i64*, i8*, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}***, i8*}* %environment6179, i32 0, i32 8
store i8* %tmpPtr, i8** %tmp_envptr6226


; promote local stack var allocations
%tzone6340 = load i8*, i8** %_impzPtr
%zone6341 = bitcast i8* %tzone6340 to %mzone*
%ifptr6251 = alloca i64
%ifptr6252 = alloca i1
%ifptr6265 = alloca i1
; setup loop
%val6248 = load i64, i64* %rightPtr
%val6249 = load i64, i64* %leftPtr
%val6250 = sub i64 %val6248, %val6249
%val6247 = load i64, i64* %leftPtr
store i64 %val6247, i64* %iPtr
%val6296 = load i64, i64* %iPtr
%num6297 = add i64 %val6250, %val6296
%comp6298 = icmp ult i64 %val6250, 1
br i1 %comp6298, label %after6246, label %loop6246

loop6246:
%val6253 = load i64, i64* %iPtr
%val6254 = load i8*, i8** %bufPtr
; pointer ref
%val6255 = getelementptr i8, i8* %val6254, i64 %val6253
%val6256 = load i8, i8* %val6255
%val6257 = load i8, i8* %pivotPtr
%cmp6258 = icmp slt i8 %val6256, %val6257
br i1 %cmp6258, label %then6252, label %else6252

then6252:
%val6259 = load i64, i64* %iPtr
%val6260 = load i8*, i8** %bufPtr
; pointer ref
%val6261 = getelementptr i8, i8* %val6260, i64 %val6259
%val6262 = load i8, i8* %val6261
%val6263 = load i8, i8* %pivotPtr
%cmp6264 = icmp slt i8 %val6262, %val6263
store i1 %cmp6264, i1* %ifptr6252
br label %ifcont6252

else6252:
%val6266 = load i64, i64* %iPtr
%val6267 = load i8*, i8** %bufPtr
; pointer ref
%val6268 = getelementptr i8, i8* %val6267, i64 %val6266
%val6269 = load i8, i8* %val6268
%val6270 = load i8, i8* %pivotPtr
%cmp6271 = icmp eq i8 %val6269, %val6270
br i1 %cmp6271, label %then6265, label %else6265

then6265:
%val6272 = load i64, i64* %iPtr
%val6273 = load i8*, i8** %bufPtr
; pointer ref
%val6274 = getelementptr i8, i8* %val6273, i64 %val6272
%val6275 = load i8, i8* %val6274
%val6276 = load i8, i8* %pivotPtr
%cmp6277 = icmp eq i8 %val6275, %val6276
store i1 %cmp6277, i1* %ifptr6265
br label %ifcont6265

else6265:
%res6278 = call ccc i1 @impc_false()
store i1 %res6278, i1* %ifptr6265
br label %ifcont6265

ifcont6265:
%ifres6279 = load i1, i1* %ifptr6265

store i1 %ifres6279, i1* %ifptr6252
br label %ifcont6252

ifcont6252:
%ifres6280 = load i1, i1* %ifptr6252

br i1 %ifres6280, label %then6251, label %else6251

then6251:
%val6281 = load i64, i64* %iPtr
%val6282 = load i64, i64* %indexPtr

; apply closure 
%vval6283 = load {i8*, i8*, i8 (i8*, i8*, i64, i64)*}**, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}*** %_swapPtr
%val6284 = load {i8*, i8*, i8 (i8*, i8*, i64, i64)*}*,{i8*, i8*, i8 (i8*, i8*, i64, i64)*}** %vval6283
%fPtr6285 = getelementptr {i8*, i8*, i8 (i8*, i8*, i64, i64)*}, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}* %val6284, i32 0, i32 2
%ePtr6286 = getelementptr {i8*, i8*, i8 (i8*, i8*, i64, i64)*}, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}* %val6284, i32 0, i32 1
%f6287 = load i8 (i8*, i8*, i64, i64)*, i8 (i8*, i8*, i64, i64)** %fPtr6285
%e6288 = load i8*, i8** %ePtr6286
%tzone6289 = load i8*, i8** %_impzPtr
%zone6290 = bitcast i8* %tzone6289 to %mzone*
%z6291 = bitcast %mzone* %zone6290 to i8*
%result6292 = tail call fastcc i8 %f6287(i8* %z6291, i8* %e6288, i64 %val6281, i64 %val6282)
; do set!
%val6293 = load i64, i64* %indexPtr
%val6294 = add i64 %val6293, 1
store i64 %val6294, i64* %indexPtr
store i64 %val6294, i64* %ifptr6251
br label %ifcont6251

else6251:
br label %ifcont6251

ifcont6251:
%ifres6295 = load i64, i64* %ifptr6251

%loop_cnt6246 = load i64, i64* %iPtr
%next6246 = add i64 %loop_cnt6246, 1
store i64 %next6246, i64* %iPtr
%cmp6246 = icmp ult i64 %next6246, %num6297
br i1 %cmp6246, label %loop6246, label %after6246

after6246:
%val6300 = load i64, i64* %rightPtr
%val6301 = load i64, i64* %indexPtr

; apply closure 
%vval6302 = load {i8*, i8*, i8 (i8*, i8*, i64, i64)*}**, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}*** %_swapPtr
%val6303 = load {i8*, i8*, i8 (i8*, i8*, i64, i64)*}*,{i8*, i8*, i8 (i8*, i8*, i64, i64)*}** %vval6302
%fPtr6304 = getelementptr {i8*, i8*, i8 (i8*, i8*, i64, i64)*}, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}* %val6303, i32 0, i32 2
%ePtr6305 = getelementptr {i8*, i8*, i8 (i8*, i8*, i64, i64)*}, {i8*, i8*, i8 (i8*, i8*, i64, i64)*}* %val6303, i32 0, i32 1
%f6306 = load i8 (i8*, i8*, i64, i64)*, i8 (i8*, i8*, i64, i64)** %fPtr6304
%e6307 = load i8*, i8** %ePtr6305
%tzone6308 = load i8*, i8** %_impzPtr
%zone6309 = bitcast i8* %tzone6308 to %mzone*
%z6310 = bitcast %mzone* %zone6309 to i8*
%result6311 = tail call fastcc i8 %f6306(i8* %z6310, i8* %e6307, i64 %val6300, i64 %val6301)
%val6312 = load i8*, i8** %bufPtr
%val6313 = load i64, i64* %leftPtr
%val6314 = load i64, i64* %indexPtr
%val6315 = sub i64 %val6314, 1

; apply closure 
%vval6316 = load {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRdPtr
%val6317 = load {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}*,{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}** %vval6316
%fPtr6318 = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}* %val6317, i32 0, i32 2
%ePtr6319 = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}* %val6317, i32 0, i32 1
%f6320 = load void (i8*, i8*, i8*, i64, i64)*, void (i8*, i8*, i8*, i64, i64)** %fPtr6318
%e6321 = load i8*, i8** %ePtr6319
%tzone6322 = load i8*, i8** %_impzPtr
%zone6323 = bitcast i8* %tzone6322 to %mzone*
%z6324 = bitcast %mzone* %zone6323 to i8*
tail call fastcc void %f6320(i8* %z6324, i8* %e6321, i8* %val6312, i64 %val6313, i64 %val6315)
%val6326 = load i8*, i8** %bufPtr
%val6327 = load i64, i64* %indexPtr
%val6328 = add i64 %val6327, 1
%val6329 = load i64, i64* %rightPtr

; apply closure 
%vval6330 = load {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRdPtr
%val6331 = load {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}*,{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}** %vval6330
%fPtr6332 = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}* %val6331, i32 0, i32 2
%ePtr6333 = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}* %val6331, i32 0, i32 1
%f6334 = load void (i8*, i8*, i8*, i64, i64)*, void (i8*, i8*, i8*, i64, i64)** %fPtr6332
%e6335 = load i8*, i8** %ePtr6333
%tzone6336 = load i8*, i8** %_impzPtr
%zone6337 = bitcast i8* %tzone6336 to %mzone*
%z6338 = bitcast %mzone* %zone6337 to i8*
tail call fastcc void %f6334(i8* %z6338, i8* %e6335, i8* %val6326, i64 %val6328, i64 %val6329)
ret void

else6152:
ret void
}
@gsxtmmath241 = hidden constant [95 x i8] c"vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}** @vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6362 = load i8*, i8** %_impzPtr
%zone6363 = bitcast i8* %tzone6362 to %mzone*

; let assign value to symbol vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd
%dat_vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone6363, i64 8)
%vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRdPtr = bitcast i8* %dat_vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd to { i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***
%tzone6343 = load i8*, i8** %_impzPtr
%zone6344 = bitcast i8* %tzone6343 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6344)
; malloc closure structure
%clsptr6345 = call i8* @llvm_zone_malloc(%mzone* %zone6344, i64 24)
%closure6346 = bitcast i8* %clsptr6345 to { i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}*

; malloc environment structure
%envptr6347 = call i8* @llvm_zone_malloc(%mzone* %zone6344, i64 8)
%environment6348 = bitcast i8* %envptr6347 to {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***}*

; malloc closure address table
%addytable6349 = call %clsvar* @new_address_table()
%var6350 = bitcast [42 x i8]* @gsxtmmath236 to i8*
%var6351 = bitcast [46 x i8]* @gsxtmmath237 to i8*
%addytable6352 = call %clsvar* @add_address_table(%mzone* %zone6344, i8* %var6350, i32 0, i8* %var6351, i32 3, %clsvar* %addytable6349)
%address-table6353 = bitcast %clsvar* %addytable6352 to i8*

; insert table, function and environment into closure struct
%closure.table6356 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}* %closure6346, i32 0, i32 0
store i8* %address-table6353, i8** %closure.table6356
%closure.env6357 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}* %closure6346, i32 0, i32 1
store i8* %envptr6347, i8** %closure.env6357
%closure.func6358 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}* %closure6346, i32 0, i32 2
store void (i8*, i8*, i8*, i64, i64)* @vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd__6149, void (i8*, i8*, i8*, i64, i64)** %closure.func6358
%closure_size6359 = call i64 @llvm_zone_mark_size(%mzone* %zone6344)
call void @llvm_zone_ptr_set_size(i8* %clsptr6345, i64 %closure_size6359)
%wrapper_ptr6360 = call i8* @llvm_zone_malloc(%mzone* %zone6344, i64 8)
%closure_wrapper6361 = bitcast i8* %wrapper_ptr6360 to { i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}**
store { i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}* %closure6346, { i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}** %closure_wrapper6361

; let value assignment
%vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd = select i1 true, { i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}** %closure_wrapper6361, { i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}** %closure_wrapper6361
store { i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}** %vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd, { i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRdPtr

; add data to environment
; don't need to alloc for env var vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd
%tmp_envptr6355 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}***}* %environment6348, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRdPtr, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}**** %tmp_envptr6355


%val6364 = load {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}**, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}*** %vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRdPtr
ret {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}** %val6364
}


@vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}** @vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd(i8* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i64, i64)*,  void (i8*, i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd_native(i8* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i64, i64)*,  void (i8*, i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i64 %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6365 = bitcast [95 x i8]* @gsxtmmath241 to i8*
call i32 (i8*, ...) @printf(i8* %var6365)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6366 = bitcast [95 x i8]* @gsxtmmath241 to i8*
call i32 (i8*, ...) @printf(i8* %var6366)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var6367 = bitcast [95 x i8]* @gsxtmmath241 to i8*
call i32 (i8*, ...) @printf(i8* %var6367)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i64, i64)*,  void (i8*, i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i64 %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i64, i64}*
%arg_p_0 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i64, i64)*,  void (i8*, i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i64 %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath242 = hidden constant [41 x i8] c"vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd\00"
@gsxtmmath243 = hidden constant [48 x i8] c"{i8*, i8*, double* (i8*, i8*, double*, i64)*}**\00"
define dllexport fastcc double* @vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd__6368(i8* %_impz,i8* %_impenv, double* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6369 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double* (i8*, i8*, double*, i64)*}***}*
%vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRdPtr_ = getelementptr {{i8*, i8*, double* (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, double* (i8*, i8*, double*, i64)*}***}* %impenv, i32 0, i32 0
%vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRdPtr = load {i8*, i8*, double* (i8*, i8*, double*, i64)*}***, {i8*, i8*, double* (i8*, i8*, double*, i64)*}**** %vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRdPtr_

; setup arguments
%bufPtr = alloca double*
store double* %buf, double** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%val6370 = load double*, double** %bufPtr
%val6371 = load i64, i64* %lenPtr
%val6372 = sub i64 %val6371, 1
call fastcc void @vquicksort_adhoc_W3ZvaWQsZG91YmxlKixpNjQsaTY0XQ(double* %val6370, i64 0, i64 %val6372)
%val6374 = load double*, double** %bufPtr
ret double* %val6374
}
@gsxtmmath244 = hidden constant [94 x i8] c"vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double* (i8*, i8*, double*, i64)*}** @vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6394 = load i8*, i8** %_impzPtr
%zone6395 = bitcast i8* %tzone6394 to %mzone*

; let assign value to symbol vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd
%dat_vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone6395, i64 8)
%vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRdPtr = bitcast i8* %dat_vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd to { i8*, i8*, double* (i8*, i8*, double*, i64)*}***
%tzone6375 = load i8*, i8** %_impzPtr
%zone6376 = bitcast i8* %tzone6375 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6376)
; malloc closure structure
%clsptr6377 = call i8* @llvm_zone_malloc(%mzone* %zone6376, i64 24)
%closure6378 = bitcast i8* %clsptr6377 to { i8*, i8*, double* (i8*, i8*, double*, i64)*}*

; malloc environment structure
%envptr6379 = call i8* @llvm_zone_malloc(%mzone* %zone6376, i64 8)
%environment6380 = bitcast i8* %envptr6379 to {{i8*, i8*, double* (i8*, i8*, double*, i64)*}***}*

; malloc closure address table
%addytable6381 = call %clsvar* @new_address_table()
%var6382 = bitcast [41 x i8]* @gsxtmmath242 to i8*
%var6383 = bitcast [48 x i8]* @gsxtmmath243 to i8*
%addytable6384 = call %clsvar* @add_address_table(%mzone* %zone6376, i8* %var6382, i32 0, i8* %var6383, i32 3, %clsvar* %addytable6381)
%address-table6385 = bitcast %clsvar* %addytable6384 to i8*

; insert table, function and environment into closure struct
%closure.table6388 = getelementptr { i8*, i8*, double* (i8*, i8*, double*, i64)*}, { i8*, i8*, double* (i8*, i8*, double*, i64)*}* %closure6378, i32 0, i32 0
store i8* %address-table6385, i8** %closure.table6388
%closure.env6389 = getelementptr { i8*, i8*, double* (i8*, i8*, double*, i64)*}, { i8*, i8*, double* (i8*, i8*, double*, i64)*}* %closure6378, i32 0, i32 1
store i8* %envptr6379, i8** %closure.env6389
%closure.func6390 = getelementptr { i8*, i8*, double* (i8*, i8*, double*, i64)*}, { i8*, i8*, double* (i8*, i8*, double*, i64)*}* %closure6378, i32 0, i32 2
store double* (i8*, i8*, double*, i64)* @vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd__6368, double* (i8*, i8*, double*, i64)** %closure.func6390
%closure_size6391 = call i64 @llvm_zone_mark_size(%mzone* %zone6376)
call void @llvm_zone_ptr_set_size(i8* %clsptr6377, i64 %closure_size6391)
%wrapper_ptr6392 = call i8* @llvm_zone_malloc(%mzone* %zone6376, i64 8)
%closure_wrapper6393 = bitcast i8* %wrapper_ptr6392 to { i8*, i8*, double* (i8*, i8*, double*, i64)*}**
store { i8*, i8*, double* (i8*, i8*, double*, i64)*}* %closure6378, { i8*, i8*, double* (i8*, i8*, double*, i64)*}** %closure_wrapper6393

; let value assignment
%vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd = select i1 true, { i8*, i8*, double* (i8*, i8*, double*, i64)*}** %closure_wrapper6393, { i8*, i8*, double* (i8*, i8*, double*, i64)*}** %closure_wrapper6393
store { i8*, i8*, double* (i8*, i8*, double*, i64)*}** %vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd, { i8*, i8*, double* (i8*, i8*, double*, i64)*}*** %vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRdPtr

; add data to environment
; don't need to alloc for env var vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd
%tmp_envptr6387 = getelementptr {{i8*, i8*, double* (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, double* (i8*, i8*, double*, i64)*}***}* %environment6380, i32 0, i32 0
store {i8*, i8*, double* (i8*, i8*, double*, i64)*}*** %vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRdPtr, {i8*, i8*, double* (i8*, i8*, double*, i64)*}**** %tmp_envptr6387


%val6396 = load {i8*, i8*, double* (i8*, i8*, double*, i64)*}**, {i8*, i8*, double* (i8*, i8*, double*, i64)*}*** %vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRdPtr
ret {i8*, i8*, double* (i8*, i8*, double*, i64)*}** %val6396
}


@vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double* (i8*, i8*, double*, i64)*}** @vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double* (i8*, i8*, double*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double* @vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double* (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double* (i8*, i8*, double*, i64)*}*, {i8*, i8*, double* (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64)*}, {i8*, i8*, double* (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64)*}, {i8*, i8*, double* (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double* (i8*, i8*, double*, i64)*,  double* (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double* %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret double* %result
}


define dllexport ccc double* @vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd_native(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double* (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double* (i8*, i8*, double*, i64)*}*, {i8*, i8*, double* (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64)*}, {i8*, i8*, double* (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64)*}, {i8*, i8*, double* (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double* (i8*, i8*, double*, i64)*,  double* (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double* %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret double* %result
}


define dllexport ccc i8*  @vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6397 = bitcast [94 x i8]* @gsxtmmath244 to i8*
call i32 (i8*, ...) @printf(i8* %var6397)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6398 = bitcast [94 x i8]* @gsxtmmath244 to i8*
call i32 (i8*, ...) @printf(i8* %var6398)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double* (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double* (i8*, i8*, double*, i64)*}*, {i8*, i8*, double* (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64)*}, {i8*, i8*, double* (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64)*}, {i8*, i8*, double* (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double* (i8*, i8*, double*, i64)*,  double* (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double* %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%tmpres = bitcast double* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, i64}*
%arg_p_0 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double* (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double* (i8*, i8*, double*, i64)*}*, {i8*, i8*, double* (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64)*}, {i8*, i8*, double* (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double* (i8*, i8*, double*, i64)*}, {i8*, i8*, double* (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double* (i8*, i8*, double*, i64)*,  double* (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double* %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath245 = hidden constant [39 x i8] c"vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ\00"
@gsxtmmath246 = hidden constant [46 x i8] c"{i8*, i8*, float* (i8*, i8*, float*, i64)*}**\00"
define dllexport fastcc float* @vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ__6399(i8* %_impz,i8* %_impenv, float* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6400 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float* (i8*, i8*, float*, i64)*}***}*
%vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQPtr_ = getelementptr {{i8*, i8*, float* (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, float* (i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 0
%vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQPtr = load {i8*, i8*, float* (i8*, i8*, float*, i64)*}***, {i8*, i8*, float* (i8*, i8*, float*, i64)*}**** %vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQPtr_

; setup arguments
%bufPtr = alloca float*
store float* %buf, float** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%val6401 = load float*, float** %bufPtr
%val6402 = load i64, i64* %lenPtr
%val6403 = sub i64 %val6402, 1
call fastcc void @vquicksort_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd(float* %val6401, i64 0, i64 %val6403)
%val6405 = load float*, float** %bufPtr
ret float* %val6405
}
@gsxtmmath247 = hidden constant [92 x i8] c"vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float* (i8*, i8*, float*, i64)*}** @vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6425 = load i8*, i8** %_impzPtr
%zone6426 = bitcast i8* %tzone6425 to %mzone*

; let assign value to symbol vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ
%dat_vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone6426, i64 8)
%vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQPtr = bitcast i8* %dat_vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ to { i8*, i8*, float* (i8*, i8*, float*, i64)*}***
%tzone6406 = load i8*, i8** %_impzPtr
%zone6407 = bitcast i8* %tzone6406 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6407)
; malloc closure structure
%clsptr6408 = call i8* @llvm_zone_malloc(%mzone* %zone6407, i64 24)
%closure6409 = bitcast i8* %clsptr6408 to { i8*, i8*, float* (i8*, i8*, float*, i64)*}*

; malloc environment structure
%envptr6410 = call i8* @llvm_zone_malloc(%mzone* %zone6407, i64 8)
%environment6411 = bitcast i8* %envptr6410 to {{i8*, i8*, float* (i8*, i8*, float*, i64)*}***}*

; malloc closure address table
%addytable6412 = call %clsvar* @new_address_table()
%var6413 = bitcast [39 x i8]* @gsxtmmath245 to i8*
%var6414 = bitcast [46 x i8]* @gsxtmmath246 to i8*
%addytable6415 = call %clsvar* @add_address_table(%mzone* %zone6407, i8* %var6413, i32 0, i8* %var6414, i32 3, %clsvar* %addytable6412)
%address-table6416 = bitcast %clsvar* %addytable6415 to i8*

; insert table, function and environment into closure struct
%closure.table6419 = getelementptr { i8*, i8*, float* (i8*, i8*, float*, i64)*}, { i8*, i8*, float* (i8*, i8*, float*, i64)*}* %closure6409, i32 0, i32 0
store i8* %address-table6416, i8** %closure.table6419
%closure.env6420 = getelementptr { i8*, i8*, float* (i8*, i8*, float*, i64)*}, { i8*, i8*, float* (i8*, i8*, float*, i64)*}* %closure6409, i32 0, i32 1
store i8* %envptr6410, i8** %closure.env6420
%closure.func6421 = getelementptr { i8*, i8*, float* (i8*, i8*, float*, i64)*}, { i8*, i8*, float* (i8*, i8*, float*, i64)*}* %closure6409, i32 0, i32 2
store float* (i8*, i8*, float*, i64)* @vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ__6399, float* (i8*, i8*, float*, i64)** %closure.func6421
%closure_size6422 = call i64 @llvm_zone_mark_size(%mzone* %zone6407)
call void @llvm_zone_ptr_set_size(i8* %clsptr6408, i64 %closure_size6422)
%wrapper_ptr6423 = call i8* @llvm_zone_malloc(%mzone* %zone6407, i64 8)
%closure_wrapper6424 = bitcast i8* %wrapper_ptr6423 to { i8*, i8*, float* (i8*, i8*, float*, i64)*}**
store { i8*, i8*, float* (i8*, i8*, float*, i64)*}* %closure6409, { i8*, i8*, float* (i8*, i8*, float*, i64)*}** %closure_wrapper6424

; let value assignment
%vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ = select i1 true, { i8*, i8*, float* (i8*, i8*, float*, i64)*}** %closure_wrapper6424, { i8*, i8*, float* (i8*, i8*, float*, i64)*}** %closure_wrapper6424
store { i8*, i8*, float* (i8*, i8*, float*, i64)*}** %vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ, { i8*, i8*, float* (i8*, i8*, float*, i64)*}*** %vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQPtr

; add data to environment
; don't need to alloc for env var vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ
%tmp_envptr6418 = getelementptr {{i8*, i8*, float* (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, float* (i8*, i8*, float*, i64)*}***}* %environment6411, i32 0, i32 0
store {i8*, i8*, float* (i8*, i8*, float*, i64)*}*** %vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQPtr, {i8*, i8*, float* (i8*, i8*, float*, i64)*}**** %tmp_envptr6418


%val6427 = load {i8*, i8*, float* (i8*, i8*, float*, i64)*}**, {i8*, i8*, float* (i8*, i8*, float*, i64)*}*** %vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQPtr
ret {i8*, i8*, float* (i8*, i8*, float*, i64)*}** %val6427
}


@vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float* (i8*, i8*, float*, i64)*}** @vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float* (i8*, i8*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float* @vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float* (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float* (i8*, i8*, float*, i64)*}*, {i8*, i8*, float* (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64)*}, {i8*, i8*, float* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64)*}, {i8*, i8*, float* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float* (i8*, i8*, float*, i64)*,  float* (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret float* %result
}


define dllexport ccc float* @vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ_native(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float* (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float* (i8*, i8*, float*, i64)*}*, {i8*, i8*, float* (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64)*}, {i8*, i8*, float* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64)*}, {i8*, i8*, float* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float* (i8*, i8*, float*, i64)*,  float* (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret float* %result
}


define dllexport ccc i8*  @vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6428 = bitcast [92 x i8]* @gsxtmmath247 to i8*
call i32 (i8*, ...) @printf(i8* %var6428)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6429 = bitcast [92 x i8]* @gsxtmmath247 to i8*
call i32 (i8*, ...) @printf(i8* %var6429)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float* (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float* (i8*, i8*, float*, i64)*}*, {i8*, i8*, float* (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64)*}, {i8*, i8*, float* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64)*}, {i8*, i8*, float* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float* (i8*, i8*, float*, i64)*,  float* (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%tmpres = bitcast float* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64}*
%arg_p_0 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float* (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float* (i8*, i8*, float*, i64)*}*, {i8*, i8*, float* (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64)*}, {i8*, i8*, float* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float* (i8*, i8*, float*, i64)*}, {i8*, i8*, float* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float* (i8*, i8*, float*, i64)*,  float* (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath248 = hidden constant [33 x i8] c"vsort_adhoc_W2k2NCosaTY0KixpNjRd\00"
@gsxtmmath249 = hidden constant [42 x i8] c"{i8*, i8*, i64* (i8*, i8*, i64*, i64)*}**\00"
define dllexport fastcc i64* @vsort_adhoc_W2k2NCosaTY0KixpNjRd__6430(i8* %_impz,i8* %_impenv, i64* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6431 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64* (i8*, i8*, i64*, i64)*}***}*
%vsort_adhoc_W2k2NCosaTY0KixpNjRdPtr_ = getelementptr {{i8*, i8*, i64* (i8*, i8*, i64*, i64)*}***}, {{i8*, i8*, i64* (i8*, i8*, i64*, i64)*}***}* %impenv, i32 0, i32 0
%vsort_adhoc_W2k2NCosaTY0KixpNjRdPtr = load {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}***, {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}**** %vsort_adhoc_W2k2NCosaTY0KixpNjRdPtr_

; setup arguments
%bufPtr = alloca i64*
store i64* %buf, i64** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%val6432 = load i64*, i64** %bufPtr
%val6433 = load i64, i64* %lenPtr
%val6434 = sub i64 %val6433, 1
call fastcc void @vquicksort_adhoc_W3ZvaWQsaTY0KixpNjQsaTY0XQ(i64* %val6432, i64 0, i64 %val6434)
%val6436 = load i64*, i64** %bufPtr
ret i64* %val6436
}
@gsxtmmath250 = hidden constant [86 x i8] c"vsort_adhoc_W2k2NCosaTY0KixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}** @vsort_adhoc_W2k2NCosaTY0KixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6456 = load i8*, i8** %_impzPtr
%zone6457 = bitcast i8* %tzone6456 to %mzone*

; let assign value to symbol vsort_adhoc_W2k2NCosaTY0KixpNjRd
%dat_vsort_adhoc_W2k2NCosaTY0KixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone6457, i64 8)
%vsort_adhoc_W2k2NCosaTY0KixpNjRdPtr = bitcast i8* %dat_vsort_adhoc_W2k2NCosaTY0KixpNjRd to { i8*, i8*, i64* (i8*, i8*, i64*, i64)*}***
%tzone6437 = load i8*, i8** %_impzPtr
%zone6438 = bitcast i8* %tzone6437 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6438)
; malloc closure structure
%clsptr6439 = call i8* @llvm_zone_malloc(%mzone* %zone6438, i64 24)
%closure6440 = bitcast i8* %clsptr6439 to { i8*, i8*, i64* (i8*, i8*, i64*, i64)*}*

; malloc environment structure
%envptr6441 = call i8* @llvm_zone_malloc(%mzone* %zone6438, i64 8)
%environment6442 = bitcast i8* %envptr6441 to {{i8*, i8*, i64* (i8*, i8*, i64*, i64)*}***}*

; malloc closure address table
%addytable6443 = call %clsvar* @new_address_table()
%var6444 = bitcast [33 x i8]* @gsxtmmath248 to i8*
%var6445 = bitcast [42 x i8]* @gsxtmmath249 to i8*
%addytable6446 = call %clsvar* @add_address_table(%mzone* %zone6438, i8* %var6444, i32 0, i8* %var6445, i32 3, %clsvar* %addytable6443)
%address-table6447 = bitcast %clsvar* %addytable6446 to i8*

; insert table, function and environment into closure struct
%closure.table6450 = getelementptr { i8*, i8*, i64* (i8*, i8*, i64*, i64)*}, { i8*, i8*, i64* (i8*, i8*, i64*, i64)*}* %closure6440, i32 0, i32 0
store i8* %address-table6447, i8** %closure.table6450
%closure.env6451 = getelementptr { i8*, i8*, i64* (i8*, i8*, i64*, i64)*}, { i8*, i8*, i64* (i8*, i8*, i64*, i64)*}* %closure6440, i32 0, i32 1
store i8* %envptr6441, i8** %closure.env6451
%closure.func6452 = getelementptr { i8*, i8*, i64* (i8*, i8*, i64*, i64)*}, { i8*, i8*, i64* (i8*, i8*, i64*, i64)*}* %closure6440, i32 0, i32 2
store i64* (i8*, i8*, i64*, i64)* @vsort_adhoc_W2k2NCosaTY0KixpNjRd__6430, i64* (i8*, i8*, i64*, i64)** %closure.func6452
%closure_size6453 = call i64 @llvm_zone_mark_size(%mzone* %zone6438)
call void @llvm_zone_ptr_set_size(i8* %clsptr6439, i64 %closure_size6453)
%wrapper_ptr6454 = call i8* @llvm_zone_malloc(%mzone* %zone6438, i64 8)
%closure_wrapper6455 = bitcast i8* %wrapper_ptr6454 to { i8*, i8*, i64* (i8*, i8*, i64*, i64)*}**
store { i8*, i8*, i64* (i8*, i8*, i64*, i64)*}* %closure6440, { i8*, i8*, i64* (i8*, i8*, i64*, i64)*}** %closure_wrapper6455

; let value assignment
%vsort_adhoc_W2k2NCosaTY0KixpNjRd = select i1 true, { i8*, i8*, i64* (i8*, i8*, i64*, i64)*}** %closure_wrapper6455, { i8*, i8*, i64* (i8*, i8*, i64*, i64)*}** %closure_wrapper6455
store { i8*, i8*, i64* (i8*, i8*, i64*, i64)*}** %vsort_adhoc_W2k2NCosaTY0KixpNjRd, { i8*, i8*, i64* (i8*, i8*, i64*, i64)*}*** %vsort_adhoc_W2k2NCosaTY0KixpNjRdPtr

; add data to environment
; don't need to alloc for env var vsort_adhoc_W2k2NCosaTY0KixpNjRd
%tmp_envptr6449 = getelementptr {{i8*, i8*, i64* (i8*, i8*, i64*, i64)*}***}, {{i8*, i8*, i64* (i8*, i8*, i64*, i64)*}***}* %environment6442, i32 0, i32 0
store {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}*** %vsort_adhoc_W2k2NCosaTY0KixpNjRdPtr, {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}**** %tmp_envptr6449


%val6458 = load {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}**, {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}*** %vsort_adhoc_W2k2NCosaTY0KixpNjRdPtr
ret {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}** %val6458
}


@vsort_adhoc_W2k2NCosaTY0KixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@vsort_adhoc_W2k2NCosaTY0KixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vsort_adhoc_W2k2NCosaTY0KixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2k2NCosaTY0KixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}** @vsort_adhoc_W2k2NCosaTY0KixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vsort_adhoc_W2k2NCosaTY0KixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vsort_adhoc_W2k2NCosaTY0KixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2k2NCosaTY0KixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64* @vsort_adhoc_W2k2NCosaTY0KixpNjRd(i64* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2k2NCosaTY0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}*, {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  i64* (i8*, i8*, i64*, i64)*,  i64* (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64* %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
ret i64* %result
}


define dllexport ccc i64* @vsort_adhoc_W2k2NCosaTY0KixpNjRd_native(i64* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2k2NCosaTY0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}*, {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  i64* (i8*, i8*, i64*, i64)*,  i64* (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64* %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
ret i64* %result
}


define dllexport ccc i8*  @vsort_adhoc_W2k2NCosaTY0KixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6459 = bitcast [86 x i8]* @gsxtmmath250 to i8*
call i32 (i8*, ...) @printf(i8* %var6459)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i64*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6460 = bitcast [86 x i8]* @gsxtmmath250 to i8*
call i32 (i8*, ...) @printf(i8* %var6460)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2k2NCosaTY0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}*, {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  i64* (i8*, i8*, i64*, i64)*,  i64* (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64* %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
%tmpres = bitcast i64* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @vsort_adhoc_W2k2NCosaTY0KixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64*, i64}*
%arg_p_0 = getelementptr {i64*, i64}, {i64*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64*, i64** %arg_p_0
%arg_p_1 = getelementptr {i64*, i64}, {i64*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2k2NCosaTY0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}**
%closure = load {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}*, {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}, {i8*, i8*, i64* (i8*, i8*, i64*, i64)*}* %closure, i32 0, i32 1
%ff = load  i64* (i8*, i8*, i64*, i64)*,  i64* (i8*, i8*, i64*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64* %ff(i8* %_impz, i8* %ee, i64* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath251 = hidden constant [33 x i8] c"vsort_adhoc_W2kzMiosaTMyKixpNjRd\00"
@gsxtmmath252 = hidden constant [42 x i8] c"{i8*, i8*, i32* (i8*, i8*, i32*, i64)*}**\00"
define dllexport fastcc i32* @vsort_adhoc_W2kzMiosaTMyKixpNjRd__6461(i8* %_impz,i8* %_impenv, i32* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6462 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32* (i8*, i8*, i32*, i64)*}***}*
%vsort_adhoc_W2kzMiosaTMyKixpNjRdPtr_ = getelementptr {{i8*, i8*, i32* (i8*, i8*, i32*, i64)*}***}, {{i8*, i8*, i32* (i8*, i8*, i32*, i64)*}***}* %impenv, i32 0, i32 0
%vsort_adhoc_W2kzMiosaTMyKixpNjRdPtr = load {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}***, {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}**** %vsort_adhoc_W2kzMiosaTMyKixpNjRdPtr_

; setup arguments
%bufPtr = alloca i32*
store i32* %buf, i32** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%val6463 = load i32*, i32** %bufPtr
%val6464 = load i64, i64* %lenPtr
%val6465 = sub i64 %val6464, 1
call fastcc void @vquicksort_adhoc_W3ZvaWQsaTMyKixpNjQsaTY0XQ(i32* %val6463, i64 0, i64 %val6465)
%val6467 = load i32*, i32** %bufPtr
ret i32* %val6467
}
@gsxtmmath253 = hidden constant [86 x i8] c"vsort_adhoc_W2kzMiosaTMyKixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}** @vsort_adhoc_W2kzMiosaTMyKixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6487 = load i8*, i8** %_impzPtr
%zone6488 = bitcast i8* %tzone6487 to %mzone*

; let assign value to symbol vsort_adhoc_W2kzMiosaTMyKixpNjRd
%dat_vsort_adhoc_W2kzMiosaTMyKixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone6488, i64 8)
%vsort_adhoc_W2kzMiosaTMyKixpNjRdPtr = bitcast i8* %dat_vsort_adhoc_W2kzMiosaTMyKixpNjRd to { i8*, i8*, i32* (i8*, i8*, i32*, i64)*}***
%tzone6468 = load i8*, i8** %_impzPtr
%zone6469 = bitcast i8* %tzone6468 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6469)
; malloc closure structure
%clsptr6470 = call i8* @llvm_zone_malloc(%mzone* %zone6469, i64 24)
%closure6471 = bitcast i8* %clsptr6470 to { i8*, i8*, i32* (i8*, i8*, i32*, i64)*}*

; malloc environment structure
%envptr6472 = call i8* @llvm_zone_malloc(%mzone* %zone6469, i64 8)
%environment6473 = bitcast i8* %envptr6472 to {{i8*, i8*, i32* (i8*, i8*, i32*, i64)*}***}*

; malloc closure address table
%addytable6474 = call %clsvar* @new_address_table()
%var6475 = bitcast [33 x i8]* @gsxtmmath251 to i8*
%var6476 = bitcast [42 x i8]* @gsxtmmath252 to i8*
%addytable6477 = call %clsvar* @add_address_table(%mzone* %zone6469, i8* %var6475, i32 0, i8* %var6476, i32 3, %clsvar* %addytable6474)
%address-table6478 = bitcast %clsvar* %addytable6477 to i8*

; insert table, function and environment into closure struct
%closure.table6481 = getelementptr { i8*, i8*, i32* (i8*, i8*, i32*, i64)*}, { i8*, i8*, i32* (i8*, i8*, i32*, i64)*}* %closure6471, i32 0, i32 0
store i8* %address-table6478, i8** %closure.table6481
%closure.env6482 = getelementptr { i8*, i8*, i32* (i8*, i8*, i32*, i64)*}, { i8*, i8*, i32* (i8*, i8*, i32*, i64)*}* %closure6471, i32 0, i32 1
store i8* %envptr6472, i8** %closure.env6482
%closure.func6483 = getelementptr { i8*, i8*, i32* (i8*, i8*, i32*, i64)*}, { i8*, i8*, i32* (i8*, i8*, i32*, i64)*}* %closure6471, i32 0, i32 2
store i32* (i8*, i8*, i32*, i64)* @vsort_adhoc_W2kzMiosaTMyKixpNjRd__6461, i32* (i8*, i8*, i32*, i64)** %closure.func6483
%closure_size6484 = call i64 @llvm_zone_mark_size(%mzone* %zone6469)
call void @llvm_zone_ptr_set_size(i8* %clsptr6470, i64 %closure_size6484)
%wrapper_ptr6485 = call i8* @llvm_zone_malloc(%mzone* %zone6469, i64 8)
%closure_wrapper6486 = bitcast i8* %wrapper_ptr6485 to { i8*, i8*, i32* (i8*, i8*, i32*, i64)*}**
store { i8*, i8*, i32* (i8*, i8*, i32*, i64)*}* %closure6471, { i8*, i8*, i32* (i8*, i8*, i32*, i64)*}** %closure_wrapper6486

; let value assignment
%vsort_adhoc_W2kzMiosaTMyKixpNjRd = select i1 true, { i8*, i8*, i32* (i8*, i8*, i32*, i64)*}** %closure_wrapper6486, { i8*, i8*, i32* (i8*, i8*, i32*, i64)*}** %closure_wrapper6486
store { i8*, i8*, i32* (i8*, i8*, i32*, i64)*}** %vsort_adhoc_W2kzMiosaTMyKixpNjRd, { i8*, i8*, i32* (i8*, i8*, i32*, i64)*}*** %vsort_adhoc_W2kzMiosaTMyKixpNjRdPtr

; add data to environment
; don't need to alloc for env var vsort_adhoc_W2kzMiosaTMyKixpNjRd
%tmp_envptr6480 = getelementptr {{i8*, i8*, i32* (i8*, i8*, i32*, i64)*}***}, {{i8*, i8*, i32* (i8*, i8*, i32*, i64)*}***}* %environment6473, i32 0, i32 0
store {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}*** %vsort_adhoc_W2kzMiosaTMyKixpNjRdPtr, {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}**** %tmp_envptr6480


%val6489 = load {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}**, {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}*** %vsort_adhoc_W2kzMiosaTMyKixpNjRdPtr
ret {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}** %val6489
}


@vsort_adhoc_W2kzMiosaTMyKixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@vsort_adhoc_W2kzMiosaTMyKixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vsort_adhoc_W2kzMiosaTMyKixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2kzMiosaTMyKixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}** @vsort_adhoc_W2kzMiosaTMyKixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vsort_adhoc_W2kzMiosaTMyKixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vsort_adhoc_W2kzMiosaTMyKixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2kzMiosaTMyKixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32* @vsort_adhoc_W2kzMiosaTMyKixpNjRd(i32* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2kzMiosaTMyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}*, {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  i32* (i8*, i8*, i32*, i64)*,  i32* (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
ret i32* %result
}


define dllexport ccc i32* @vsort_adhoc_W2kzMiosaTMyKixpNjRd_native(i32* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2kzMiosaTMyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}*, {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  i32* (i8*, i8*, i32*, i64)*,  i32* (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
ret i32* %result
}


define dllexport ccc i8*  @vsort_adhoc_W2kzMiosaTMyKixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6490 = bitcast [86 x i8]* @gsxtmmath253 to i8*
call i32 (i8*, ...) @printf(i8* %var6490)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i32*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6491 = bitcast [86 x i8]* @gsxtmmath253 to i8*
call i32 (i8*, ...) @printf(i8* %var6491)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2kzMiosaTMyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}*, {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  i32* (i8*, i8*, i32*, i64)*,  i32* (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
%tmpres = bitcast i32* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @vsort_adhoc_W2kzMiosaTMyKixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32*, i64}*
%arg_p_0 = getelementptr {i32*, i64}, {i32*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i32*, i32** %arg_p_0
%arg_p_1 = getelementptr {i32*, i64}, {i32*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2kzMiosaTMyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}*, {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}, {i8*, i8*, i32* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  i32* (i8*, i8*, i32*, i64)*,  i32* (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath254 = hidden constant [33 x i8] c"vsort_adhoc_W2kxNiosaTE2KixpNjRd\00"
@gsxtmmath255 = hidden constant [42 x i8] c"{i8*, i8*, i16* (i8*, i8*, i16*, i64)*}**\00"
define dllexport fastcc i16* @vsort_adhoc_W2kxNiosaTE2KixpNjRd__6492(i8* %_impz,i8* %_impenv, i16* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6493 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i16* (i8*, i8*, i16*, i64)*}***}*
%vsort_adhoc_W2kxNiosaTE2KixpNjRdPtr_ = getelementptr {{i8*, i8*, i16* (i8*, i8*, i16*, i64)*}***}, {{i8*, i8*, i16* (i8*, i8*, i16*, i64)*}***}* %impenv, i32 0, i32 0
%vsort_adhoc_W2kxNiosaTE2KixpNjRdPtr = load {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}***, {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}**** %vsort_adhoc_W2kxNiosaTE2KixpNjRdPtr_

; setup arguments
%bufPtr = alloca i16*
store i16* %buf, i16** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%val6494 = load i16*, i16** %bufPtr
%val6495 = load i64, i64* %lenPtr
%val6496 = sub i64 %val6495, 1
call fastcc void @vquicksort_adhoc_W3ZvaWQsaTE2KixpNjQsaTY0XQ(i16* %val6494, i64 0, i64 %val6496)
%val6498 = load i16*, i16** %bufPtr
ret i16* %val6498
}
@gsxtmmath256 = hidden constant [86 x i8] c"vsort_adhoc_W2kxNiosaTE2KixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}** @vsort_adhoc_W2kxNiosaTE2KixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6518 = load i8*, i8** %_impzPtr
%zone6519 = bitcast i8* %tzone6518 to %mzone*

; let assign value to symbol vsort_adhoc_W2kxNiosaTE2KixpNjRd
%dat_vsort_adhoc_W2kxNiosaTE2KixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone6519, i64 8)
%vsort_adhoc_W2kxNiosaTE2KixpNjRdPtr = bitcast i8* %dat_vsort_adhoc_W2kxNiosaTE2KixpNjRd to { i8*, i8*, i16* (i8*, i8*, i16*, i64)*}***
%tzone6499 = load i8*, i8** %_impzPtr
%zone6500 = bitcast i8* %tzone6499 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6500)
; malloc closure structure
%clsptr6501 = call i8* @llvm_zone_malloc(%mzone* %zone6500, i64 24)
%closure6502 = bitcast i8* %clsptr6501 to { i8*, i8*, i16* (i8*, i8*, i16*, i64)*}*

; malloc environment structure
%envptr6503 = call i8* @llvm_zone_malloc(%mzone* %zone6500, i64 8)
%environment6504 = bitcast i8* %envptr6503 to {{i8*, i8*, i16* (i8*, i8*, i16*, i64)*}***}*

; malloc closure address table
%addytable6505 = call %clsvar* @new_address_table()
%var6506 = bitcast [33 x i8]* @gsxtmmath254 to i8*
%var6507 = bitcast [42 x i8]* @gsxtmmath255 to i8*
%addytable6508 = call %clsvar* @add_address_table(%mzone* %zone6500, i8* %var6506, i32 0, i8* %var6507, i32 3, %clsvar* %addytable6505)
%address-table6509 = bitcast %clsvar* %addytable6508 to i8*

; insert table, function and environment into closure struct
%closure.table6512 = getelementptr { i8*, i8*, i16* (i8*, i8*, i16*, i64)*}, { i8*, i8*, i16* (i8*, i8*, i16*, i64)*}* %closure6502, i32 0, i32 0
store i8* %address-table6509, i8** %closure.table6512
%closure.env6513 = getelementptr { i8*, i8*, i16* (i8*, i8*, i16*, i64)*}, { i8*, i8*, i16* (i8*, i8*, i16*, i64)*}* %closure6502, i32 0, i32 1
store i8* %envptr6503, i8** %closure.env6513
%closure.func6514 = getelementptr { i8*, i8*, i16* (i8*, i8*, i16*, i64)*}, { i8*, i8*, i16* (i8*, i8*, i16*, i64)*}* %closure6502, i32 0, i32 2
store i16* (i8*, i8*, i16*, i64)* @vsort_adhoc_W2kxNiosaTE2KixpNjRd__6492, i16* (i8*, i8*, i16*, i64)** %closure.func6514
%closure_size6515 = call i64 @llvm_zone_mark_size(%mzone* %zone6500)
call void @llvm_zone_ptr_set_size(i8* %clsptr6501, i64 %closure_size6515)
%wrapper_ptr6516 = call i8* @llvm_zone_malloc(%mzone* %zone6500, i64 8)
%closure_wrapper6517 = bitcast i8* %wrapper_ptr6516 to { i8*, i8*, i16* (i8*, i8*, i16*, i64)*}**
store { i8*, i8*, i16* (i8*, i8*, i16*, i64)*}* %closure6502, { i8*, i8*, i16* (i8*, i8*, i16*, i64)*}** %closure_wrapper6517

; let value assignment
%vsort_adhoc_W2kxNiosaTE2KixpNjRd = select i1 true, { i8*, i8*, i16* (i8*, i8*, i16*, i64)*}** %closure_wrapper6517, { i8*, i8*, i16* (i8*, i8*, i16*, i64)*}** %closure_wrapper6517
store { i8*, i8*, i16* (i8*, i8*, i16*, i64)*}** %vsort_adhoc_W2kxNiosaTE2KixpNjRd, { i8*, i8*, i16* (i8*, i8*, i16*, i64)*}*** %vsort_adhoc_W2kxNiosaTE2KixpNjRdPtr

; add data to environment
; don't need to alloc for env var vsort_adhoc_W2kxNiosaTE2KixpNjRd
%tmp_envptr6511 = getelementptr {{i8*, i8*, i16* (i8*, i8*, i16*, i64)*}***}, {{i8*, i8*, i16* (i8*, i8*, i16*, i64)*}***}* %environment6504, i32 0, i32 0
store {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}*** %vsort_adhoc_W2kxNiosaTE2KixpNjRdPtr, {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}**** %tmp_envptr6511


%val6520 = load {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}**, {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}*** %vsort_adhoc_W2kxNiosaTE2KixpNjRdPtr
ret {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}** %val6520
}


@vsort_adhoc_W2kxNiosaTE2KixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@vsort_adhoc_W2kxNiosaTE2KixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vsort_adhoc_W2kxNiosaTE2KixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2kxNiosaTE2KixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}** @vsort_adhoc_W2kxNiosaTE2KixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vsort_adhoc_W2kxNiosaTE2KixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vsort_adhoc_W2kxNiosaTE2KixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2kxNiosaTE2KixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i16* @vsort_adhoc_W2kxNiosaTE2KixpNjRd(i16* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2kxNiosaTE2KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}**
%closure = load {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}*, {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}, {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}, {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}* %closure, i32 0, i32 1
%ff = load  i16* (i8*, i8*, i16*, i64)*,  i16* (i8*, i8*, i16*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i16* %ff(i8* %_impz, i8* %ee, i16* %arg_0, i64 %arg_1)
ret i16* %result
}


define dllexport ccc i16* @vsort_adhoc_W2kxNiosaTE2KixpNjRd_native(i16* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2kxNiosaTE2KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}**
%closure = load {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}*, {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}, {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}, {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}* %closure, i32 0, i32 1
%ff = load  i16* (i8*, i8*, i16*, i64)*,  i16* (i8*, i8*, i16*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i16* %ff(i8* %_impz, i8* %ee, i16* %arg_0, i64 %arg_1)
ret i16* %result
}


define dllexport ccc i8*  @vsort_adhoc_W2kxNiosaTE2KixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6521 = bitcast [86 x i8]* @gsxtmmath256 to i8*
call i32 (i8*, ...) @printf(i8* %var6521)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i16*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6522 = bitcast [86 x i8]* @gsxtmmath256 to i8*
call i32 (i8*, ...) @printf(i8* %var6522)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2kxNiosaTE2KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}**
%closure = load {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}*, {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}, {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}, {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}* %closure, i32 0, i32 1
%ff = load  i16* (i8*, i8*, i16*, i64)*,  i16* (i8*, i8*, i16*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i16* %ff(i8* %_impz, i8* %ee, i16* %arg_0, i64 %arg_1)
%tmpres = bitcast i16* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @vsort_adhoc_W2kxNiosaTE2KixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i16*, i64}*
%arg_p_0 = getelementptr {i16*, i64}, {i16*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i16*, i16** %arg_p_0
%arg_p_1 = getelementptr {i16*, i64}, {i16*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2kxNiosaTE2KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}**
%closure = load {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}*, {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}, {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}, {i8*, i8*, i16* (i8*, i8*, i16*, i64)*}* %closure, i32 0, i32 1
%ff = load  i16* (i8*, i8*, i16*, i64)*,  i16* (i8*, i8*, i16*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i16* %ff(i8* %_impz, i8* %ee, i16* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath257 = hidden constant [31 x i8] c"vsort_adhoc_W2k4KixpOCosaTY0XQ\00"
@gsxtmmath258 = hidden constant [40 x i8] c"{i8*, i8*, i8* (i8*, i8*, i8*, i64)*}**\00"
define dllexport fastcc i8* @vsort_adhoc_W2k4KixpOCosaTY0XQ__6523(i8* %_impz,i8* %_impenv, i8* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6524 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, i8*, i64)*}***}*
%vsort_adhoc_W2k4KixpOCosaTY0XQPtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i8*, i64)*}***}, {{i8*, i8*, i8* (i8*, i8*, i8*, i64)*}***}* %impenv, i32 0, i32 0
%vsort_adhoc_W2k4KixpOCosaTY0XQPtr = load {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}***, {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}**** %vsort_adhoc_W2k4KixpOCosaTY0XQPtr_

; setup arguments
%bufPtr = alloca i8*
store i8* %buf, i8** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%val6525 = load i8*, i8** %bufPtr
%val6526 = load i64, i64* %lenPtr
%val6527 = sub i64 %val6526, 1
call fastcc void @vquicksort_adhoc_W3ZvaWQsaTgqLGk2NCxpNjRd(i8* %val6525, i64 0, i64 %val6527)
%val6529 = load i8*, i8** %bufPtr
ret i8* %val6529
}
@gsxtmmath259 = hidden constant [84 x i8] c"vsort_adhoc_W2k4KixpOCosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}** @vsort_adhoc_W2k4KixpOCosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6549 = load i8*, i8** %_impzPtr
%zone6550 = bitcast i8* %tzone6549 to %mzone*

; let assign value to symbol vsort_adhoc_W2k4KixpOCosaTY0XQ
%dat_vsort_adhoc_W2k4KixpOCosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone6550, i64 8)
%vsort_adhoc_W2k4KixpOCosaTY0XQPtr = bitcast i8* %dat_vsort_adhoc_W2k4KixpOCosaTY0XQ to { i8*, i8*, i8* (i8*, i8*, i8*, i64)*}***
%tzone6530 = load i8*, i8** %_impzPtr
%zone6531 = bitcast i8* %tzone6530 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6531)
; malloc closure structure
%clsptr6532 = call i8* @llvm_zone_malloc(%mzone* %zone6531, i64 24)
%closure6533 = bitcast i8* %clsptr6532 to { i8*, i8*, i8* (i8*, i8*, i8*, i64)*}*

; malloc environment structure
%envptr6534 = call i8* @llvm_zone_malloc(%mzone* %zone6531, i64 8)
%environment6535 = bitcast i8* %envptr6534 to {{i8*, i8*, i8* (i8*, i8*, i8*, i64)*}***}*

; malloc closure address table
%addytable6536 = call %clsvar* @new_address_table()
%var6537 = bitcast [31 x i8]* @gsxtmmath257 to i8*
%var6538 = bitcast [40 x i8]* @gsxtmmath258 to i8*
%addytable6539 = call %clsvar* @add_address_table(%mzone* %zone6531, i8* %var6537, i32 0, i8* %var6538, i32 3, %clsvar* %addytable6536)
%address-table6540 = bitcast %clsvar* %addytable6539 to i8*

; insert table, function and environment into closure struct
%closure.table6543 = getelementptr { i8*, i8*, i8* (i8*, i8*, i8*, i64)*}, { i8*, i8*, i8* (i8*, i8*, i8*, i64)*}* %closure6533, i32 0, i32 0
store i8* %address-table6540, i8** %closure.table6543
%closure.env6544 = getelementptr { i8*, i8*, i8* (i8*, i8*, i8*, i64)*}, { i8*, i8*, i8* (i8*, i8*, i8*, i64)*}* %closure6533, i32 0, i32 1
store i8* %envptr6534, i8** %closure.env6544
%closure.func6545 = getelementptr { i8*, i8*, i8* (i8*, i8*, i8*, i64)*}, { i8*, i8*, i8* (i8*, i8*, i8*, i64)*}* %closure6533, i32 0, i32 2
store i8* (i8*, i8*, i8*, i64)* @vsort_adhoc_W2k4KixpOCosaTY0XQ__6523, i8* (i8*, i8*, i8*, i64)** %closure.func6545
%closure_size6546 = call i64 @llvm_zone_mark_size(%mzone* %zone6531)
call void @llvm_zone_ptr_set_size(i8* %clsptr6532, i64 %closure_size6546)
%wrapper_ptr6547 = call i8* @llvm_zone_malloc(%mzone* %zone6531, i64 8)
%closure_wrapper6548 = bitcast i8* %wrapper_ptr6547 to { i8*, i8*, i8* (i8*, i8*, i8*, i64)*}**
store { i8*, i8*, i8* (i8*, i8*, i8*, i64)*}* %closure6533, { i8*, i8*, i8* (i8*, i8*, i8*, i64)*}** %closure_wrapper6548

; let value assignment
%vsort_adhoc_W2k4KixpOCosaTY0XQ = select i1 true, { i8*, i8*, i8* (i8*, i8*, i8*, i64)*}** %closure_wrapper6548, { i8*, i8*, i8* (i8*, i8*, i8*, i64)*}** %closure_wrapper6548
store { i8*, i8*, i8* (i8*, i8*, i8*, i64)*}** %vsort_adhoc_W2k4KixpOCosaTY0XQ, { i8*, i8*, i8* (i8*, i8*, i8*, i64)*}*** %vsort_adhoc_W2k4KixpOCosaTY0XQPtr

; add data to environment
; don't need to alloc for env var vsort_adhoc_W2k4KixpOCosaTY0XQ
%tmp_envptr6542 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i8*, i64)*}***}, {{i8*, i8*, i8* (i8*, i8*, i8*, i64)*}***}* %environment6535, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}*** %vsort_adhoc_W2k4KixpOCosaTY0XQPtr, {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}**** %tmp_envptr6542


%val6551 = load {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}**, {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}*** %vsort_adhoc_W2k4KixpOCosaTY0XQPtr
ret {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}** %val6551
}


@vsort_adhoc_W2k4KixpOCosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@vsort_adhoc_W2k4KixpOCosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vsort_adhoc_W2k4KixpOCosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2k4KixpOCosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}** @vsort_adhoc_W2k4KixpOCosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vsort_adhoc_W2k4KixpOCosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vsort_adhoc_W2k4KixpOCosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2k4KixpOCosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @vsort_adhoc_W2k4KixpOCosaTY0XQ(i8* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2k4KixpOCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}*, {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i8*, i64)*,  i8* (i8*, i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i64 %arg_1)
ret i8* %result
}


define dllexport ccc i8* @vsort_adhoc_W2k4KixpOCosaTY0XQ_native(i8* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2k4KixpOCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}*, {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i8*, i64)*,  i8* (i8*, i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i64 %arg_1)
ret i8* %result
}


define dllexport ccc i8*  @vsort_adhoc_W2k4KixpOCosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6552 = bitcast [84 x i8]* @gsxtmmath259 to i8*
call i32 (i8*, ...) @printf(i8* %var6552)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6553 = bitcast [84 x i8]* @gsxtmmath259 to i8*
call i32 (i8*, ...) @printf(i8* %var6553)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2k4KixpOCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}*, {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i8*, i64)*,  i8* (i8*, i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i64 %arg_1)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @vsort_adhoc_W2k4KixpOCosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i64}*
%arg_p_0 = getelementptr {i8*, i64}, {i8*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i64}, {i8*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsort_adhoc_W2k4KixpOCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}*, {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i8*, i64)*,  i8* (i8*, i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath260 = hidden constant [39 x i8] c"vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd\00"
define dllexport fastcc float @vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd__6554(i8* %_impz,i8* %_impenv, float* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6555 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}*
%vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 0
%vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr = load {i8*, i8*, float (i8*, i8*, float*, i64)*}***, {i8*, i8*, float (i8*, i8*, float*, i64)*}**** %vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr_

; setup arguments
%bufPtr = alloca float*
store float* %buf, float** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone6559 = load i8*, i8** %_impzPtr
%zone6560 = bitcast i8* %tzone6559 to %mzone*

; let assign value to symbol h
%hPtr = alloca float*
%tzone6566 = load i8*, i8** %_impzPtr
%zone6567 = bitcast i8* %tzone6566 to %mzone*

; let assign value to symbol idx
%idxPtr = alloca i64
%val6556 = load float*, float** %bufPtr
%val6557 = load i64, i64* %lenPtr
%res6558 = call fastcc float* @vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ(float* %val6556, i64 %val6557)

; let value assignment
%h = select i1 true, float* %res6558, float* %res6558
store float* %h, float** %hPtr

%val6561 = load i64, i64* %lenPtr
%res6562 = call ccc double @i64tod(i64 %val6561)
%val6563 = fdiv double %res6562, 2.0000000000000000000
%val6564 = call double @llvm.ceil.f64(double %val6563)
%res6565 = call ccc i64 @dtoi64(double %val6564)

; let value assignment
%idx = select i1 true, i64 %res6565, i64 %res6565
store i64 %idx, i64* %idxPtr

; promote local stack var allocations
%tzone6591 = load i8*, i8** %_impzPtr
%zone6592 = bitcast i8* %tzone6591 to %mzone*
%ifptr6569 = alloca i1
%val6570 = load i64, i64* %lenPtr
%val6571 = and i64 %val6570, 1
%cmp6572 = icmp eq i64 %val6571, 0
br i1 %cmp6572, label %then6569, label %else6569

then6569:
%val6573 = trunc i64 1 to i1
store i1 %val6573, i1* %ifptr6569
br label %ifcont6569

else6569:
%val6574 = trunc i64 0 to i1
store i1 %val6574, i1* %ifptr6569
br label %ifcont6569

ifcont6569:
%ifres6575 = load i1, i1* %ifptr6569

br i1 %ifres6575, label %then6568, label %else6568

then6568:
%val6576 = load i64, i64* %idxPtr
%val6577 = load float*, float** %hPtr
; pointer ref
%val6578 = getelementptr float, float* %val6577, i64 %val6576
%val6579 = load float, float* %val6578
%val6580 = load i64, i64* %idxPtr
%val6581 = sub i64 %val6580, 1
%val6582 = load float*, float** %hPtr
; pointer ref
%val6583 = getelementptr float, float* %val6582, i64 %val6581
%val6584 = load float, float* %val6583
%val6585 = fadd float %val6579, %val6584
%val6586 = fdiv float %val6585, 0x4000000000000000
ret float %val6586

else6568:
%val6587 = load i64, i64* %idxPtr
%val6588 = load float*, float** %hPtr
; pointer ref
%val6589 = getelementptr float, float* %val6588, i64 %val6587
%val6590 = load float, float* %val6589
ret float %val6590
}
@gsxtmmath261 = hidden constant [92 x i8] c"vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, float*, i64)*}** @vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6612 = load i8*, i8** %_impzPtr
%zone6613 = bitcast i8* %tzone6612 to %mzone*

; let assign value to symbol vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd
%dat_vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone6613, i64 8)
%vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr = bitcast i8* %dat_vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd to { i8*, i8*, float (i8*, i8*, float*, i64)*}***
%tzone6593 = load i8*, i8** %_impzPtr
%zone6594 = bitcast i8* %tzone6593 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6594)
; malloc closure structure
%clsptr6595 = call i8* @llvm_zone_malloc(%mzone* %zone6594, i64 24)
%closure6596 = bitcast i8* %clsptr6595 to { i8*, i8*, float (i8*, i8*, float*, i64)*}*

; malloc environment structure
%envptr6597 = call i8* @llvm_zone_malloc(%mzone* %zone6594, i64 8)
%environment6598 = bitcast i8* %envptr6597 to {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}*

; malloc closure address table
%addytable6599 = call %clsvar* @new_address_table()
%var6600 = bitcast [39 x i8]* @gsxtmmath260 to i8*
%var6601 = bitcast [45 x i8]* @gsxtmmath7 to i8*
%addytable6602 = call %clsvar* @add_address_table(%mzone* %zone6594, i8* %var6600, i32 0, i8* %var6601, i32 3, %clsvar* %addytable6599)
%address-table6603 = bitcast %clsvar* %addytable6602 to i8*

; insert table, function and environment into closure struct
%closure.table6606 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure6596, i32 0, i32 0
store i8* %address-table6603, i8** %closure.table6606
%closure.env6607 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure6596, i32 0, i32 1
store i8* %envptr6597, i8** %closure.env6607
%closure.func6608 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure6596, i32 0, i32 2
store float (i8*, i8*, float*, i64)* @vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd__6554, float (i8*, i8*, float*, i64)** %closure.func6608
%closure_size6609 = call i64 @llvm_zone_mark_size(%mzone* %zone6594)
call void @llvm_zone_ptr_set_size(i8* %clsptr6595, i64 %closure_size6609)
%wrapper_ptr6610 = call i8* @llvm_zone_malloc(%mzone* %zone6594, i64 8)
%closure_wrapper6611 = bitcast i8* %wrapper_ptr6610 to { i8*, i8*, float (i8*, i8*, float*, i64)*}**
store { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure6596, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper6611

; let value assignment
%vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd = select i1 true, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper6611, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper6611
store { i8*, i8*, float (i8*, i8*, float*, i64)*}** %vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd, { i8*, i8*, float (i8*, i8*, float*, i64)*}*** %vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr

; add data to environment
; don't need to alloc for env var vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd
%tmp_envptr6605 = getelementptr {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}* %environment6598, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, float*, i64)*}*** %vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr, {i8*, i8*, float (i8*, i8*, float*, i64)*}**** %tmp_envptr6605


%val6614 = load {i8*, i8*, float (i8*, i8*, float*, i64)*}**, {i8*, i8*, float (i8*, i8*, float*, i64)*}*** %vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr
ret {i8*, i8*, float (i8*, i8*, float*, i64)*}** %val6614
}


@vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, float*, i64)*}** @vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret float %result
}


define dllexport ccc float @vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_native(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret float %result
}


define dllexport ccc i8*  @vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6615 = bitcast [92 x i8]* @gsxtmmath261 to i8*
call i32 (i8*, ...) @printf(i8* %var6615)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6616 = bitcast [92 x i8]* @gsxtmmath261 to i8*
call i32 (i8*, ...) @printf(i8* %var6616)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64}*
%arg_p_0 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmedian_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath262 = hidden constant [42 x i8] c"vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0\00"
define dllexport fastcc double @vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0__6617(i8* %_impz,i8* %_impenv, double* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6618 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}*
%vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}* %impenv, i32 0, i32 0
%vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr = load {i8*, i8*, double (i8*, i8*, double*, i64)*}***, {i8*, i8*, double (i8*, i8*, double*, i64)*}**** %vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr_

; setup arguments
%bufPtr = alloca double*
store double* %buf, double** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone6622 = load i8*, i8** %_impzPtr
%zone6623 = bitcast i8* %tzone6622 to %mzone*

; let assign value to symbol h
%hPtr = alloca double*
%tzone6629 = load i8*, i8** %_impzPtr
%zone6630 = bitcast i8* %tzone6629 to %mzone*

; let assign value to symbol idx
%idxPtr = alloca i64
%val6619 = load double*, double** %bufPtr
%val6620 = load i64, i64* %lenPtr
%res6621 = call fastcc double* @vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd(double* %val6619, i64 %val6620)

; let value assignment
%h = select i1 true, double* %res6621, double* %res6621
store double* %h, double** %hPtr

%val6624 = load i64, i64* %lenPtr
%res6625 = call ccc double @i64tod(i64 %val6624)
%val6626 = fdiv double %res6625, 2.0000000000000000000
%val6627 = call double @llvm.ceil.f64(double %val6626)
%res6628 = call ccc i64 @dtoi64(double %val6627)

; let value assignment
%idx = select i1 true, i64 %res6628, i64 %res6628
store i64 %idx, i64* %idxPtr

; promote local stack var allocations
%tzone6654 = load i8*, i8** %_impzPtr
%zone6655 = bitcast i8* %tzone6654 to %mzone*
%ifptr6632 = alloca i1
%val6633 = load i64, i64* %lenPtr
%val6634 = and i64 %val6633, 1
%cmp6635 = icmp eq i64 %val6634, 0
br i1 %cmp6635, label %then6632, label %else6632

then6632:
%val6636 = trunc i64 1 to i1
store i1 %val6636, i1* %ifptr6632
br label %ifcont6632

else6632:
%val6637 = trunc i64 0 to i1
store i1 %val6637, i1* %ifptr6632
br label %ifcont6632

ifcont6632:
%ifres6638 = load i1, i1* %ifptr6632

br i1 %ifres6638, label %then6631, label %else6631

then6631:
%val6639 = load i64, i64* %idxPtr
%val6640 = load double*, double** %hPtr
; pointer ref
%val6641 = getelementptr double, double* %val6640, i64 %val6639
%val6642 = load double, double* %val6641
%val6643 = load i64, i64* %idxPtr
%val6644 = sub i64 %val6643, 1
%val6645 = load double*, double** %hPtr
; pointer ref
%val6646 = getelementptr double, double* %val6645, i64 %val6644
%val6647 = load double, double* %val6646
%val6648 = fadd double %val6642, %val6647
%val6649 = fdiv double %val6648, 2.0000000000000000000
ret double %val6649

else6631:
%val6650 = load i64, i64* %idxPtr
%val6651 = load double*, double** %hPtr
; pointer ref
%val6652 = getelementptr double, double* %val6651, i64 %val6650
%val6653 = load double, double* %val6652
ret double %val6653
}
@gsxtmmath263 = hidden constant [95 x i8] c"vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, double*, i64)*}** @vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6675 = load i8*, i8** %_impzPtr
%zone6676 = bitcast i8* %tzone6675 to %mzone*

; let assign value to symbol vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0
%dat_vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone6676, i64 8)
%vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr = bitcast i8* %dat_vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 to { i8*, i8*, double (i8*, i8*, double*, i64)*}***
%tzone6656 = load i8*, i8** %_impzPtr
%zone6657 = bitcast i8* %tzone6656 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6657)
; malloc closure structure
%clsptr6658 = call i8* @llvm_zone_malloc(%mzone* %zone6657, i64 24)
%closure6659 = bitcast i8* %clsptr6658 to { i8*, i8*, double (i8*, i8*, double*, i64)*}*

; malloc environment structure
%envptr6660 = call i8* @llvm_zone_malloc(%mzone* %zone6657, i64 8)
%environment6661 = bitcast i8* %envptr6660 to {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}*

; malloc closure address table
%addytable6662 = call %clsvar* @new_address_table()
%var6663 = bitcast [42 x i8]* @gsxtmmath262 to i8*
%var6664 = bitcast [47 x i8]* @gsxtmmath10 to i8*
%addytable6665 = call %clsvar* @add_address_table(%mzone* %zone6657, i8* %var6663, i32 0, i8* %var6664, i32 3, %clsvar* %addytable6662)
%address-table6666 = bitcast %clsvar* %addytable6665 to i8*

; insert table, function and environment into closure struct
%closure.table6669 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure6659, i32 0, i32 0
store i8* %address-table6666, i8** %closure.table6669
%closure.env6670 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure6659, i32 0, i32 1
store i8* %envptr6660, i8** %closure.env6670
%closure.func6671 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure6659, i32 0, i32 2
store double (i8*, i8*, double*, i64)* @vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0__6617, double (i8*, i8*, double*, i64)** %closure.func6671
%closure_size6672 = call i64 @llvm_zone_mark_size(%mzone* %zone6657)
call void @llvm_zone_ptr_set_size(i8* %clsptr6658, i64 %closure_size6672)
%wrapper_ptr6673 = call i8* @llvm_zone_malloc(%mzone* %zone6657, i64 8)
%closure_wrapper6674 = bitcast i8* %wrapper_ptr6673 to { i8*, i8*, double (i8*, i8*, double*, i64)*}**
store { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure6659, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper6674

; let value assignment
%vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 = select i1 true, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper6674, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper6674
store { i8*, i8*, double (i8*, i8*, double*, i64)*}** %vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0, { i8*, i8*, double (i8*, i8*, double*, i64)*}*** %vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0
%tmp_envptr6668 = getelementptr {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}* %environment6661, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, double*, i64)*}*** %vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr, {i8*, i8*, double (i8*, i8*, double*, i64)*}**** %tmp_envptr6668


%val6677 = load {i8*, i8*, double (i8*, i8*, double*, i64)*}**, {i8*, i8*, double (i8*, i8*, double*, i64)*}*** %vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr
ret {i8*, i8*, double (i8*, i8*, double*, i64)*}** %val6677
}


@vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, double*, i64)*}** @vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret double %result
}


define dllexport ccc double @vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_native(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret double %result
}


define dllexport ccc i8*  @vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6678 = bitcast [95 x i8]* @gsxtmmath263 to i8*
call i32 (i8*, ...) @printf(i8* %var6678)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6679 = bitcast [95 x i8]* @gsxtmmath263 to i8*
call i32 (i8*, ...) @printf(i8* %var6679)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, i64}*
%arg_p_0 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmedian_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath264 = hidden constant [37 x i8] c"vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd\00"
define dllexport fastcc float @vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd__6680(i8* %_impz,i8* %_impenv, float* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6681 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}*
%vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 0
%vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr = load {i8*, i8*, float (i8*, i8*, float*, i64)*}***, {i8*, i8*, float (i8*, i8*, float*, i64)*}**** %vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr_

; setup arguments
%bufPtr = alloca float*
store float* %buf, float** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone6685 = load i8*, i8** %_impzPtr
%zone6686 = bitcast i8* %tzone6685 to %mzone*

; let assign value to symbol h
%hPtr = alloca float*
%tzone6688 = load i8*, i8** %_impzPtr
%zone6689 = bitcast i8* %tzone6688 to %mzone*

; let assign value to symbol p
%pPtr = alloca float
%tzone6690 = load i8*, i8** %_impzPtr
%zone6691 = bitcast i8* %tzone6690 to %mzone*

; let assign value to symbol l
%lPtr = alloca i64
%tzone6692 = load i8*, i8** %_impzPtr
%zone6693 = bitcast i8* %tzone6692 to %mzone*

; let assign value to symbol largest
%largestPtr = alloca i64
%tzone6694 = load i8*, i8** %_impzPtr
%zone6695 = bitcast i8* %tzone6694 to %mzone*

; let assign value to symbol j
%jPtr = alloca float
%tzone6696 = load i8*, i8** %_impzPtr
%zone6697 = bitcast i8* %tzone6696 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val6682 = load float*, float** %bufPtr
%val6683 = load i64, i64* %lenPtr
%res6684 = call fastcc float* @vsort_adhoc_W2Zsb2F0KixmbG9hdCosaTY0XQ(float* %val6682, i64 %val6683)

; let value assignment
%h = select i1 true, float* %res6684, float* %res6684
store float* %h, float** %hPtr

%val6687 = load float, float* @NaNf

; let value assignment
%p = select i1 true, float %val6687, float %val6687
store float %p, float* %pPtr


; let value assignment
%l = select i1 true, i64 0, i64 0
store i64 %l, i64* %lPtr


; let value assignment
%largest = select i1 true, i64 0, i64 0
store i64 %largest, i64* %largestPtr


; let value assignment
%j = select i1 true, float 0x0, float 0x0
store float %j, float* %jPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; promote local stack var allocations
%tzone6727 = load i8*, i8** %_impzPtr
%zone6728 = bitcast i8* %tzone6727 to %mzone*
%ifptr6715 = alloca float
%ifptr6701 = alloca i64
; setup loop
%val6700 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val6722 = load i64, i64* %iPtr
%num6723 = add i64 %val6700, %val6722
%comp6724 = icmp ult i64 %val6700, 1
br i1 %comp6724, label %after6698, label %loop6698

loop6698:
%val6702 = load float, float* %pPtr
%val6703 = load i64, i64* %iPtr
%val6704 = load float*, float** %bufPtr
; pointer ref
%val6705 = getelementptr float, float* %val6704, i64 %val6703
%val6706 = load float, float* %val6705
%cmp6707 = fcmp ueq float %val6702, %val6706
br i1 %cmp6707, label %then6701, label %else6701

then6701:
; do set!
%val6708 = load i64, i64* %lPtr
%val6709 = add i64 %val6708, 1
store i64 %val6709, i64* %lPtr
store i64 %val6709, i64* %ifptr6701
br label %ifcont6701

else6701:
; do set!
store i64 0, i64* %lPtr
store i64 0, i64* %ifptr6701
br label %ifcont6701

ifcont6701:
%ifres6710 = load i64, i64* %ifptr6701

; do set!
%val6711 = load i64, i64* %iPtr
%val6712 = load float*, float** %bufPtr
; pointer ref
%val6713 = getelementptr float, float* %val6712, i64 %val6711
%val6714 = load float, float* %val6713
store float %val6714, float* %pPtr
%val6716 = load i64, i64* %lPtr
%val6717 = load i64, i64* %largestPtr
%cmp6718 = icmp sgt i64 %val6716, %val6717
br i1 %cmp6718, label %then6715, label %else6715

then6715:
; do set!
%val6719 = load i64, i64* %lPtr
store i64 %val6719, i64* %largestPtr
; do set!
%val6720 = load float, float* %pPtr
store float %val6720, float* %jPtr
store float %val6720, float* %ifptr6715
br label %ifcont6715

else6715:
br label %ifcont6715

ifcont6715:
%ifres6721 = load float, float* %ifptr6715

%loop_cnt6698 = load i64, i64* %iPtr
%next6698 = add i64 %loop_cnt6698, 1
store i64 %next6698, i64* %iPtr
%cmp6698 = icmp ult i64 %next6698, %num6723
br i1 %cmp6698, label %loop6698, label %after6698

after6698:
%val6726 = load float, float* %jPtr
ret float %val6726
}
@gsxtmmath265 = hidden constant [90 x i8] c"vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, float*, i64)*}** @vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6748 = load i8*, i8** %_impzPtr
%zone6749 = bitcast i8* %tzone6748 to %mzone*

; let assign value to symbol vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd
%dat_vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone6749, i64 8)
%vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr = bitcast i8* %dat_vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd to { i8*, i8*, float (i8*, i8*, float*, i64)*}***
%tzone6729 = load i8*, i8** %_impzPtr
%zone6730 = bitcast i8* %tzone6729 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6730)
; malloc closure structure
%clsptr6731 = call i8* @llvm_zone_malloc(%mzone* %zone6730, i64 24)
%closure6732 = bitcast i8* %clsptr6731 to { i8*, i8*, float (i8*, i8*, float*, i64)*}*

; malloc environment structure
%envptr6733 = call i8* @llvm_zone_malloc(%mzone* %zone6730, i64 8)
%environment6734 = bitcast i8* %envptr6733 to {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}*

; malloc closure address table
%addytable6735 = call %clsvar* @new_address_table()
%var6736 = bitcast [37 x i8]* @gsxtmmath264 to i8*
%var6737 = bitcast [45 x i8]* @gsxtmmath7 to i8*
%addytable6738 = call %clsvar* @add_address_table(%mzone* %zone6730, i8* %var6736, i32 0, i8* %var6737, i32 3, %clsvar* %addytable6735)
%address-table6739 = bitcast %clsvar* %addytable6738 to i8*

; insert table, function and environment into closure struct
%closure.table6742 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure6732, i32 0, i32 0
store i8* %address-table6739, i8** %closure.table6742
%closure.env6743 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure6732, i32 0, i32 1
store i8* %envptr6733, i8** %closure.env6743
%closure.func6744 = getelementptr { i8*, i8*, float (i8*, i8*, float*, i64)*}, { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure6732, i32 0, i32 2
store float (i8*, i8*, float*, i64)* @vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd__6680, float (i8*, i8*, float*, i64)** %closure.func6744
%closure_size6745 = call i64 @llvm_zone_mark_size(%mzone* %zone6730)
call void @llvm_zone_ptr_set_size(i8* %clsptr6731, i64 %closure_size6745)
%wrapper_ptr6746 = call i8* @llvm_zone_malloc(%mzone* %zone6730, i64 8)
%closure_wrapper6747 = bitcast i8* %wrapper_ptr6746 to { i8*, i8*, float (i8*, i8*, float*, i64)*}**
store { i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure6732, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper6747

; let value assignment
%vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd = select i1 true, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper6747, { i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_wrapper6747
store { i8*, i8*, float (i8*, i8*, float*, i64)*}** %vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd, { i8*, i8*, float (i8*, i8*, float*, i64)*}*** %vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr

; add data to environment
; don't need to alloc for env var vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd
%tmp_envptr6741 = getelementptr {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, float*, i64)*}***}* %environment6734, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, float*, i64)*}*** %vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr, {i8*, i8*, float (i8*, i8*, float*, i64)*}**** %tmp_envptr6741


%val6750 = load {i8*, i8*, float (i8*, i8*, float*, i64)*}**, {i8*, i8*, float (i8*, i8*, float*, i64)*}*** %vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRdPtr
ret {i8*, i8*, float (i8*, i8*, float*, i64)*}** %val6750
}


@vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, float*, i64)*}** @vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret float %result
}


define dllexport ccc float @vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_native(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret float %result
}


define dllexport ccc i8*  @vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6751 = bitcast [90 x i8]* @gsxtmmath265 to i8*
call i32 (i8*, ...) @printf(i8* %var6751)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6752 = bitcast [90 x i8]* @gsxtmmath265 to i8*
call i32 (i8*, ...) @printf(i8* %var6752)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64}*
%arg_p_0 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmode_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float*, i64)*}*, {i8*, i8*, float (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float*, i64)*}, {i8*, i8*, float (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float*, i64)*,  float (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath266 = hidden constant [40 x i8] c"vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0\00"
define dllexport fastcc double @vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0__6753(i8* %_impz,i8* %_impenv, double* %buf, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6754 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}*
%vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}* %impenv, i32 0, i32 0
%vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr = load {i8*, i8*, double (i8*, i8*, double*, i64)*}***, {i8*, i8*, double (i8*, i8*, double*, i64)*}**** %vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr_

; setup arguments
%bufPtr = alloca double*
store double* %buf, double** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone6758 = load i8*, i8** %_impzPtr
%zone6759 = bitcast i8* %tzone6758 to %mzone*

; let assign value to symbol h
%hPtr = alloca double*
%tzone6761 = load i8*, i8** %_impzPtr
%zone6762 = bitcast i8* %tzone6761 to %mzone*

; let assign value to symbol p
%pPtr = alloca double
%tzone6763 = load i8*, i8** %_impzPtr
%zone6764 = bitcast i8* %tzone6763 to %mzone*

; let assign value to symbol l
%lPtr = alloca i64
%tzone6765 = load i8*, i8** %_impzPtr
%zone6766 = bitcast i8* %tzone6765 to %mzone*

; let assign value to symbol largest
%largestPtr = alloca i64
%tzone6767 = load i8*, i8** %_impzPtr
%zone6768 = bitcast i8* %tzone6767 to %mzone*

; let assign value to symbol j
%jPtr = alloca double
%tzone6769 = load i8*, i8** %_impzPtr
%zone6770 = bitcast i8* %tzone6769 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val6755 = load double*, double** %bufPtr
%val6756 = load i64, i64* %lenPtr
%res6757 = call fastcc double* @vsort_adhoc_W2RvdWJsZSosZG91YmxlKixpNjRd(double* %val6755, i64 %val6756)

; let value assignment
%h = select i1 true, double* %res6757, double* %res6757
store double* %h, double** %hPtr

%val6760 = load double, double* @NaN

; let value assignment
%p = select i1 true, double %val6760, double %val6760
store double %p, double* %pPtr


; let value assignment
%l = select i1 true, i64 0, i64 0
store i64 %l, i64* %lPtr


; let value assignment
%largest = select i1 true, i64 0, i64 0
store i64 %largest, i64* %largestPtr


; let value assignment
%j = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %j, double* %jPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; promote local stack var allocations
%tzone6800 = load i8*, i8** %_impzPtr
%zone6801 = bitcast i8* %tzone6800 to %mzone*
%ifptr6788 = alloca double
%ifptr6774 = alloca i64
; setup loop
%val6773 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val6795 = load i64, i64* %iPtr
%num6796 = add i64 %val6773, %val6795
%comp6797 = icmp ult i64 %val6773, 1
br i1 %comp6797, label %after6771, label %loop6771

loop6771:
%val6775 = load double, double* %pPtr
%val6776 = load i64, i64* %iPtr
%val6777 = load double*, double** %bufPtr
; pointer ref
%val6778 = getelementptr double, double* %val6777, i64 %val6776
%val6779 = load double, double* %val6778
%cmp6780 = fcmp ueq double %val6775, %val6779
br i1 %cmp6780, label %then6774, label %else6774

then6774:
; do set!
%val6781 = load i64, i64* %lPtr
%val6782 = add i64 %val6781, 1
store i64 %val6782, i64* %lPtr
store i64 %val6782, i64* %ifptr6774
br label %ifcont6774

else6774:
; do set!
store i64 0, i64* %lPtr
store i64 0, i64* %ifptr6774
br label %ifcont6774

ifcont6774:
%ifres6783 = load i64, i64* %ifptr6774

; do set!
%val6784 = load i64, i64* %iPtr
%val6785 = load double*, double** %bufPtr
; pointer ref
%val6786 = getelementptr double, double* %val6785, i64 %val6784
%val6787 = load double, double* %val6786
store double %val6787, double* %pPtr
%val6789 = load i64, i64* %lPtr
%val6790 = load i64, i64* %largestPtr
%cmp6791 = icmp sgt i64 %val6789, %val6790
br i1 %cmp6791, label %then6788, label %else6788

then6788:
; do set!
%val6792 = load i64, i64* %lPtr
store i64 %val6792, i64* %largestPtr
; do set!
%val6793 = load double, double* %pPtr
store double %val6793, double* %jPtr
store double %val6793, double* %ifptr6788
br label %ifcont6788

else6788:
br label %ifcont6788

ifcont6788:
%ifres6794 = load double, double* %ifptr6788

%loop_cnt6771 = load i64, i64* %iPtr
%next6771 = add i64 %loop_cnt6771, 1
store i64 %next6771, i64* %iPtr
%cmp6771 = icmp ult i64 %next6771, %num6796
br i1 %cmp6771, label %loop6771, label %after6771

after6771:
%val6799 = load double, double* %jPtr
ret double %val6799
}
@gsxtmmath267 = hidden constant [93 x i8] c"vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, double*, i64)*}** @vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6821 = load i8*, i8** %_impzPtr
%zone6822 = bitcast i8* %tzone6821 to %mzone*

; let assign value to symbol vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0
%dat_vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone6822, i64 8)
%vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr = bitcast i8* %dat_vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 to { i8*, i8*, double (i8*, i8*, double*, i64)*}***
%tzone6802 = load i8*, i8** %_impzPtr
%zone6803 = bitcast i8* %tzone6802 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6803)
; malloc closure structure
%clsptr6804 = call i8* @llvm_zone_malloc(%mzone* %zone6803, i64 24)
%closure6805 = bitcast i8* %clsptr6804 to { i8*, i8*, double (i8*, i8*, double*, i64)*}*

; malloc environment structure
%envptr6806 = call i8* @llvm_zone_malloc(%mzone* %zone6803, i64 8)
%environment6807 = bitcast i8* %envptr6806 to {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}*

; malloc closure address table
%addytable6808 = call %clsvar* @new_address_table()
%var6809 = bitcast [40 x i8]* @gsxtmmath266 to i8*
%var6810 = bitcast [47 x i8]* @gsxtmmath10 to i8*
%addytable6811 = call %clsvar* @add_address_table(%mzone* %zone6803, i8* %var6809, i32 0, i8* %var6810, i32 3, %clsvar* %addytable6808)
%address-table6812 = bitcast %clsvar* %addytable6811 to i8*

; insert table, function and environment into closure struct
%closure.table6815 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure6805, i32 0, i32 0
store i8* %address-table6812, i8** %closure.table6815
%closure.env6816 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure6805, i32 0, i32 1
store i8* %envptr6806, i8** %closure.env6816
%closure.func6817 = getelementptr { i8*, i8*, double (i8*, i8*, double*, i64)*}, { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure6805, i32 0, i32 2
store double (i8*, i8*, double*, i64)* @vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0__6753, double (i8*, i8*, double*, i64)** %closure.func6817
%closure_size6818 = call i64 @llvm_zone_mark_size(%mzone* %zone6803)
call void @llvm_zone_ptr_set_size(i8* %clsptr6804, i64 %closure_size6818)
%wrapper_ptr6819 = call i8* @llvm_zone_malloc(%mzone* %zone6803, i64 8)
%closure_wrapper6820 = bitcast i8* %wrapper_ptr6819 to { i8*, i8*, double (i8*, i8*, double*, i64)*}**
store { i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure6805, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper6820

; let value assignment
%vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0 = select i1 true, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper6820, { i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_wrapper6820
store { i8*, i8*, double (i8*, i8*, double*, i64)*}** %vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0, { i8*, i8*, double (i8*, i8*, double*, i64)*}*** %vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0
%tmp_envptr6814 = getelementptr {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, double (i8*, i8*, double*, i64)*}***}* %environment6807, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, double*, i64)*}*** %vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr, {i8*, i8*, double (i8*, i8*, double*, i64)*}**** %tmp_envptr6814


%val6823 = load {i8*, i8*, double (i8*, i8*, double*, i64)*}**, {i8*, i8*, double (i8*, i8*, double*, i64)*}*** %vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0Ptr
ret {i8*, i8*, double (i8*, i8*, double*, i64)*}** %val6823
}


@vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, double*, i64)*}** @vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret double %result
}


define dllexport ccc double @vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_native(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret double %result
}


define dllexport ccc i8*  @vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6824 = bitcast [93 x i8]* @gsxtmmath267 to i8*
call i32 (i8*, ...) @printf(i8* %var6824)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6825 = bitcast [93 x i8]* @gsxtmmath267 to i8*
call i32 (i8*, ...) @printf(i8* %var6825)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, i64}*
%arg_p_0 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vmode_adhoc_W2RvdWJsZSxkb3VibGUqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double*, i64)*}*, {i8*, i8*, double (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double*, i64)*}, {i8*, i8*, double (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double*, i64)*,  double (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath268 = hidden constant [62 x i8] c"vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0\00"
@gsxtmmath269 = hidden constant [65 x i8] c"{i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}**\00"
define dllexport fastcc void @vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0__6826(i8* %_impz,i8* %_impenv, float* %buf, i64 %n, i64 %stride, float* %c, float* %r) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6827 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}***}*
%vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}***}* %impenv, i32 0, i32 0
%vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0Ptr = load {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}**** %vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0Ptr_

; setup arguments
%bufPtr = alloca float*
store float* %buf, float** %bufPtr
%nPtr = alloca i64
store i64 %n, i64* %nPtr
%stridePtr = alloca i64
store i64 %stride, i64* %stridePtr
%cPtr = alloca float*
store float* %c, float** %cPtr
%rPtr = alloca float*
store float* %r, float** %rPtr


%tzone6829 = load i8*, i8** %_impzPtr
%zone6830 = bitcast i8* %tzone6829 to %mzone*

; let assign value to symbol centre
%centrePtr = alloca float*
%tzone6832 = load i8*, i8** %_impzPtr
%zone6833 = bitcast i8* %tzone6832 to %mzone*

; let assign value to symbol radius
%radiusPtr = alloca float
%tzone6835 = load i8*, i8** %_impzPtr
%zone6836 = bitcast i8* %tzone6835 to %mzone*

; let assign value to symbol pos
%posPtr = alloca float*
%tzone6838 = load i8*, i8** %_impzPtr
%zone6839 = bitcast i8* %tzone6838 to %mzone*

; let assign value to symbol diff
%diffPtr = alloca float*
%tzone6841 = load i8*, i8** %_impzPtr
%zone6842 = bitcast i8* %tzone6841 to %mzone*

; let assign value to symbol tmp
%tmpPtr = alloca float*
%tzone6843 = load i8*, i8** %_impzPtr
%zone6844 = bitcast i8* %tzone6843 to %mzone*

; let assign value to symbol len
%lenPtr = alloca float
%tzone6845 = load i8*, i8** %_impzPtr
%zone6846 = bitcast i8* %tzone6845 to %mzone*

; let assign value to symbol alpha
%alphaPtr = alloca float
%tzone6847 = load i8*, i8** %_impzPtr
%zone6848 = bitcast i8* %tzone6847 to %mzone*

; let assign value to symbol alphasq
%alphasqPtr = alloca float
%tzone6849 = load i8*, i8** %_impzPtr
%zone6850 = bitcast i8* %tzone6849 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%tzone6851 = load i8*, i8** %_impzPtr
%zone6852 = bitcast i8* %tzone6851 to %mzone*

; let assign value to symbol j
%jPtr = alloca i64
%val6828 = load float*, float** %bufPtr

; let value assignment
%centre = select i1 true, float* %val6828, float* %val6828
store float* %centre, float** %centrePtr

%val6831 = fptrunc double 0.00010000000000000000479 to float

; let value assignment
%radius = select i1 true, float %val6831, float %val6831
store float %radius, float* %radiusPtr

%null6834 = bitcast i8* null to float*

; let value assignment
%pos = select i1 true, float* %null6834, float* %null6834
store float* %pos, float** %posPtr

%dat6837 = alloca float, i64 3, align 16

; let value assignment
%diff = select i1 true, float* %dat6837, float* %dat6837
store float* %diff, float** %diffPtr

%dat6840 = alloca float, i64 3, align 16

; let value assignment
%tmp = select i1 true, float* %dat6840, float* %dat6840
store float* %tmp, float** %tmpPtr


; let value assignment
%len = select i1 true, float 0x0, float 0x0
store float %len, float* %lenPtr


; let value assignment
%alpha = select i1 true, float 0x0, float 0x0
store float %alpha, float* %alphaPtr


; let value assignment
%alphasq = select i1 true, float 0x0, float 0x0
store float %alphasq, float* %alphasqPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr


; let value assignment
%j = select i1 true, i64 0, i64 0
store i64 %j, i64* %jPtr

; setup loop
store i64 0, i64* %iPtr
%val6907 = load i64, i64* %iPtr
%num6908 = add i64 2, %val6907
%comp6909 = icmp ult i64 2, 1
br i1 %comp6909, label %after6853, label %loop6853

loop6853:
; setup loop
%val6856 = load i64, i64* %nPtr
store i64 0, i64* %jPtr
%val6903 = load i64, i64* %jPtr
%num6904 = add i64 %val6856, %val6903
%comp6905 = icmp ult i64 %val6856, 1
br i1 %comp6905, label %after6854, label %loop6854

loop6854:
; do set!
%val6857 = load i64, i64* %stridePtr
%val6858 = load i64, i64* %jPtr
%val6859 = mul i64 %val6857, %val6858
%val6860 = load float*, float** %bufPtr
; pointer ref
%val6861 = getelementptr float, float* %val6860, i64 %val6859
store float* %val6861, float** %posPtr
%val6862 = load float*, float** %posPtr
%val6863 = load float*, float** %centrePtr
%val6864 = load float*, float** %diffPtr
call fastcc void @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ(float* %val6862, float* %val6863, i64 3, float* %val6864)
; do set!
%val6866 = load float*, float** %diffPtr
%res6867 = call fastcc float @vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd(float* %val6866, i64 3)
store float %res6867, float* %lenPtr
%val6869 = load float, float* %lenPtr
%val6870 = load float, float* %radiusPtr
%cmp6871 = fcmp ugt float %val6869, %val6870
br i1 %cmp6871, label %then6868, label %else6868

then6868:
; do set!
%val6872 = load float, float* %lenPtr
%val6873 = load float, float* %radiusPtr
%val6874 = fdiv float %val6872, %val6873
store float %val6874, float* %alphaPtr
; do set!
%val6875 = load float, float* %alphaPtr
%val6876 = load float, float* %alphaPtr
%val6877 = fmul float %val6875, %val6876
store float %val6877, float* %alphasqPtr
; do set!
%val6878 = fptrunc double 0.50000000000000000000 to float
%val6879 = load float, float* %alphaPtr
%val6880 = load float, float* %alphaPtr
%val6881 = fdiv float 0x3ff0000000000000, %val6880
%val6882 = fadd float %val6879, %val6881
%val6883 = fmul float %val6878, %val6882
%val6884 = load float, float* %radiusPtr
%val6885 = fmul float %val6883, %val6884
store float %val6885, float* %radiusPtr
%val6886 = load float*, float** %centrePtr
%val6887 = load float, float* %alphasqPtr
%val6888 = fdiv float 0x3ff0000000000000, %val6887
%val6889 = fadd float 0x3ff0000000000000, %val6888
%val6890 = fmul float 0x3fe0000000000000, %val6889
%val6891 = load float*, float** %centrePtr
call fastcc void @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd(float* %val6886, float %val6890, i64 3, float* %val6891)
%val6893 = load float*, float** %posPtr
%val6894 = load float, float* %alphasqPtr
%val6895 = fdiv float 0x3ff0000000000000, %val6894
%val6896 = fsub float 0x3ff0000000000000, %val6895
%val6897 = load float*, float** %tmpPtr
call fastcc void @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd(float* %val6893, float %val6896, i64 3, float* %val6897)
%val6899 = load float*, float** %centrePtr
%val6900 = load float*, float** %tmpPtr
%val6901 = load float*, float** %centrePtr
call fastcc void @vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ(float* %val6899, float* %val6900, i64 3, float* %val6901)
br label %ifcont6868

else6868:
br label %ifcont6868

ifcont6868:
%loop_cnt6854 = load i64, i64* %jPtr
%next6854 = add i64 %loop_cnt6854, 1
store i64 %next6854, i64* %jPtr
%cmp6854 = icmp ult i64 %next6854, %num6904
br i1 %cmp6854, label %loop6854, label %after6854

after6854:
%loop_cnt6853 = load i64, i64* %iPtr
%next6853 = add i64 %loop_cnt6853, 1
store i64 %next6853, i64* %iPtr
%cmp6853 = icmp ult i64 %next6853, %num6908
br i1 %cmp6853, label %loop6853, label %after6853

after6853:
; setup loop
%val6913 = load i64, i64* %nPtr
store i64 0, i64* %jPtr
%val6947 = load i64, i64* %jPtr
%num6948 = add i64 %val6913, %val6947
%comp6949 = icmp ult i64 %val6913, 1
br i1 %comp6949, label %after6911, label %loop6911

loop6911:
; do set!
%val6914 = load i64, i64* %stridePtr
%val6915 = load i64, i64* %jPtr
%val6916 = mul i64 %val6914, %val6915
%val6917 = load float*, float** %bufPtr
; pointer ref
%val6918 = getelementptr float, float* %val6917, i64 %val6916
store float* %val6918, float** %posPtr
%val6919 = load float*, float** %posPtr
%val6920 = load float*, float** %centrePtr
%val6921 = load float*, float** %diffPtr
call fastcc void @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ(float* %val6919, float* %val6920, i64 3, float* %val6921)
; do set!
%val6923 = load float*, float** %diffPtr
%res6924 = call fastcc float @vmag_adhoc_W2Zsb2F0LGZsb2F0KixpNjRd(float* %val6923, i64 3)
store float %res6924, float* %lenPtr
%val6926 = load float, float* %lenPtr
%val6927 = load float, float* %radiusPtr
%cmp6928 = fcmp ugt float %val6926, %val6927
br i1 %cmp6928, label %then6925, label %else6925

then6925:
; do set!
%val6929 = load float, float* %radiusPtr
%val6930 = load float, float* %lenPtr
%val6931 = fadd float %val6929, %val6930
%val6932 = fdiv float %val6931, 0x4000000000000000
store float %val6932, float* %radiusPtr
%val6933 = load float*, float** %diffPtr
%val6934 = load float, float* %lenPtr
%val6935 = load float*, float** %diffPtr
call fastcc void @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd(float* %val6933, float %val6934, i64 3, float* %val6935)
%val6937 = load float*, float** %diffPtr
%val6938 = load float, float* %lenPtr
%val6939 = load float, float* %radiusPtr
%val6940 = fsub float %val6938, %val6939
%val6941 = load float*, float** %diffPtr
call fastcc void @vsdiv_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd(float* %val6937, float %val6940, i64 3, float* %val6941)
%val6943 = load float*, float** %centrePtr
%val6944 = load float*, float** %diffPtr
%val6945 = load float*, float** %centrePtr
call fastcc void @vvsum_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ(float* %val6943, float* %val6944, i64 3, float* %val6945)
br label %ifcont6925

else6925:
br label %ifcont6925

ifcont6925:
%loop_cnt6911 = load i64, i64* %jPtr
%next6911 = add i64 %loop_cnt6911, 1
store i64 %next6911, i64* %jPtr
%cmp6911 = icmp ult i64 %next6911, %num6948
br i1 %cmp6911, label %loop6911, label %after6911

after6911:
%val6951 = load float*, float** %centrePtr
%val6952 = load float*, float** %cPtr
call fastcc void @vcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd(float* %val6951, i64 3, float* %val6952)
%val6954 = load float*, float** %rPtr
%val6955 = load float, float* %radiusPtr
; set pointer
%val6956 = getelementptr float, float* %val6954, i64 0
store float %val6955, float* %val6956
ret void
}
@gsxtmmath270 = hidden constant [115 x i8] c"vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}** @vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6977 = load i8*, i8** %_impzPtr
%zone6978 = bitcast i8* %tzone6977 to %mzone*

; let assign value to symbol vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0
%dat_vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone6978, i64 8)
%vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0Ptr = bitcast i8* %dat_vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0 to { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}***
%tzone6958 = load i8*, i8** %_impzPtr
%zone6959 = bitcast i8* %tzone6958 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6959)
; malloc closure structure
%clsptr6960 = call i8* @llvm_zone_malloc(%mzone* %zone6959, i64 24)
%closure6961 = bitcast i8* %clsptr6960 to { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}*

; malloc environment structure
%envptr6962 = call i8* @llvm_zone_malloc(%mzone* %zone6959, i64 8)
%environment6963 = bitcast i8* %envptr6962 to {{i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}***}*

; malloc closure address table
%addytable6964 = call %clsvar* @new_address_table()
%var6965 = bitcast [62 x i8]* @gsxtmmath268 to i8*
%var6966 = bitcast [65 x i8]* @gsxtmmath269 to i8*
%addytable6967 = call %clsvar* @add_address_table(%mzone* %zone6959, i8* %var6965, i32 0, i8* %var6966, i32 3, %clsvar* %addytable6964)
%address-table6968 = bitcast %clsvar* %addytable6967 to i8*

; insert table, function and environment into closure struct
%closure.table6971 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}* %closure6961, i32 0, i32 0
store i8* %address-table6968, i8** %closure.table6971
%closure.env6972 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}* %closure6961, i32 0, i32 1
store i8* %envptr6962, i8** %closure.env6972
%closure.func6973 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}* %closure6961, i32 0, i32 2
store void (i8*, i8*, float*, i64, i64, float*, float*)* @vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0__6826, void (i8*, i8*, float*, i64, i64, float*, float*)** %closure.func6973
%closure_size6974 = call i64 @llvm_zone_mark_size(%mzone* %zone6959)
call void @llvm_zone_ptr_set_size(i8* %clsptr6960, i64 %closure_size6974)
%wrapper_ptr6975 = call i8* @llvm_zone_malloc(%mzone* %zone6959, i64 8)
%closure_wrapper6976 = bitcast i8* %wrapper_ptr6975 to { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}* %closure6961, { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}** %closure_wrapper6976

; let value assignment
%vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}** %closure_wrapper6976, { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}** %closure_wrapper6976
store { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}** %vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0, { i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}*** %vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0Ptr

; add data to environment
; don't need to alloc for env var vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0
%tmp_envptr6970 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}***}* %environment6963, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}*** %vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0Ptr, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}**** %tmp_envptr6970


%val6979 = load {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}*** %vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}** %val6979
}


@vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}** @vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0(float* %arg_0,i64 %arg_1,i64 %arg_2,float* %arg_3,float* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, i64, float*, float*)*,  void (i8*, i8*, float*, i64, i64, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2, float* %arg_3, float* %arg_4)
ret void
}


define dllexport ccc void @vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0_native(float* %arg_0,i64 %arg_1,i64 %arg_2,float* %arg_3,float* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, i64, float*, float*)*,  void (i8*, i8*, float*, i64, i64, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2, float* %arg_3, float* %arg_4)
ret void
}


define dllexport ccc i8*  @vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6980 = bitcast [115 x i8]* @gsxtmmath270 to i8*
call i32 (i8*, ...) @printf(i8* %var6980)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6981 = bitcast [115 x i8]* @gsxtmmath270 to i8*
call i32 (i8*, ...) @printf(i8* %var6981)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var6982 = bitcast [115 x i8]* @gsxtmmath270 to i8*
call i32 (i8*, ...) @printf(i8* %var6982)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var6983 = bitcast [115 x i8]* @gsxtmmath270 to i8*
call i32 (i8*, ...) @printf(i8* %var6983)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var6984 = bitcast [115 x i8]* @gsxtmmath270 to i8*
call i32 (i8*, ...) @printf(i8* %var6984)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, i64, float*, float*)*,  void (i8*, i8*, float*, i64, i64, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2, float* %arg_3, float* %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64, i64, float*, float*}*
%arg_p_0 = getelementptr {float*, i64, i64, float*, float*}, {float*, i64, i64, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64, i64, float*, float*}, {float*, i64, i64, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {float*, i64, i64, float*, float*}, {float*, i64, i64, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {float*, i64, i64, float*, float*}, {float*, i64, i64, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {float*, i64, i64, float*, float*}, {float*, i64, i64, float*, float*}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @vsphere_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, i64, i64, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64, i64, float*, float*)*,  void (i8*, i8*, float*, i64, i64, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2, float* %arg_3, float* %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%Complexd = type {double,double}
@gsxtmmath271 = hidden constant [50 x i8] c"Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ\00"
@gsxtmmath272 = hidden constant [53 x i8] c"{i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**\00"
define dllexport fastcc %Complexd* @Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ__6985(i8* %_impz,i8* %_impenv, double %arg_0, double %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6986 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***}*
%Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQPtr_ = getelementptr {{i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***}, {{i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***}* %impenv, i32 0, i32 0
%Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQPtr = load {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**** %Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQPtr_

; setup arguments
%arg_0Ptr = alloca double
store double %arg_0, double* %arg_0Ptr
%arg_1Ptr = alloca double
store double %arg_1, double* %arg_1Ptr


%tzone6991 = load i8*, i8** %_impzPtr
%zone6992 = bitcast i8* %tzone6991 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Complexd*
%tzone6987 = load i8*, i8** %_impzPtr
%zone6988 = bitcast i8* %tzone6987 to %mzone*
%dat6989 = call i8* @llvm_zone_malloc(%mzone* %zone6988, i64 16)
call i8* @memset(i8* %dat6989, i32 0, i64 16)
%val6990 = bitcast i8* %dat6989 to %Complexd*

; let value assignment
%obj = select i1 true, %Complexd* %val6990, %Complexd* %val6990
store %Complexd* %obj, %Complexd** %objPtr

%val6993 = load %Complexd*, %Complexd** %objPtr
%val6994 = load double, double* %arg_0Ptr
; set tuple
%val6995 = getelementptr %Complexd, %Complexd* %val6993, i64 0, i32 0
store double %val6994, double* %val6995
%val6996 = load %Complexd*, %Complexd** %objPtr
%val6997 = load double, double* %arg_1Ptr
; set tuple
%val6998 = getelementptr %Complexd, %Complexd* %val6996, i64 0, i32 1
store double %val6997, double* %val6998
%val6999 = load %Complexd*, %Complexd** %objPtr
ret %Complexd* %val6999
}
@gsxtmmath273 = hidden constant [103 x i8] c"Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** @Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7019 = load i8*, i8** %_impzPtr
%zone7020 = bitcast i8* %tzone7019 to %mzone*

; let assign value to symbol Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ
%dat_Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ = call i8* @llvm_zone_malloc(%mzone* %zone7020, i64 8)
%Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQPtr = bitcast i8* %dat_Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ to { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***
%tzone7000 = load i8*, i8** %_impzPtr
%zone7001 = bitcast i8* %tzone7000 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7001)
; malloc closure structure
%clsptr7002 = call i8* @llvm_zone_malloc(%mzone* %zone7001, i64 24)
%closure7003 = bitcast i8* %clsptr7002 to { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*

; malloc environment structure
%envptr7004 = call i8* @llvm_zone_malloc(%mzone* %zone7001, i64 8)
%environment7005 = bitcast i8* %envptr7004 to {{i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***}*

; malloc closure address table
%addytable7006 = call %clsvar* @new_address_table()
%var7007 = bitcast [50 x i8]* @gsxtmmath271 to i8*
%var7008 = bitcast [53 x i8]* @gsxtmmath272 to i8*
%addytable7009 = call %clsvar* @add_address_table(%mzone* %zone7001, i8* %var7007, i32 0, i8* %var7008, i32 3, %clsvar* %addytable7006)
%address-table7010 = bitcast %clsvar* %addytable7009 to i8*

; insert table, function and environment into closure struct
%closure.table7013 = getelementptr { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure7003, i32 0, i32 0
store i8* %address-table7010, i8** %closure.table7013
%closure.env7014 = getelementptr { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure7003, i32 0, i32 1
store i8* %envptr7004, i8** %closure.env7014
%closure.func7015 = getelementptr { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure7003, i32 0, i32 2
store %Complexd* (i8*, i8*, double, double)* @Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ__6985, %Complexd* (i8*, i8*, double, double)** %closure.func7015
%closure_size7016 = call i64 @llvm_zone_mark_size(%mzone* %zone7001)
call void @llvm_zone_ptr_set_size(i8* %clsptr7002, i64 %closure_size7016)
%wrapper_ptr7017 = call i8* @llvm_zone_malloc(%mzone* %zone7001, i64 8)
%closure_wrapper7018 = bitcast i8* %wrapper_ptr7017 to { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**
store { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure7003, { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure_wrapper7018

; let value assignment
%Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ = select i1 true, { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure_wrapper7018, { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure_wrapper7018
store { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ, { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*** %Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQPtr

; add data to environment
; don't need to alloc for env var Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ
%tmp_envptr7012 = getelementptr {{i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***}, {{i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***}* %environment7005, i32 0, i32 0
store {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*** %Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQPtr, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**** %tmp_envptr7012


%val7021 = load {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*** %Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQPtr
ret {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %val7021
}


@Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** @Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd* @Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ(double %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd* (i8*, i8*, double, double)*,  %Complexd* (i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd* %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1)
ret %Complexd* %result
}


define dllexport ccc %Complexd* @Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_native(double %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd* (i8*, i8*, double, double)*,  %Complexd* (i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd* %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1)
ret %Complexd* %result
}


define dllexport ccc i8*  @Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7022 = bitcast [103 x i8]* @gsxtmmath273 to i8*
call i32 (i8*, ...) @printf(i8* %var7022)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc double @r64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var7023 = bitcast [103 x i8]* @gsxtmmath273 to i8*
call i32 (i8*, ...) @printf(i8* %var7023)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd* (i8*, i8*, double, double)*,  %Complexd* (i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd* %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1)
%tmpres = bitcast %Complexd* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double, double}*
%arg_p_0 = getelementptr {double, double}, {double, double}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
%arg_p_1 = getelementptr {double, double}, {double, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexd_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd* (i8*, i8*, double, double)*,  %Complexd* (i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd* %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath274 = hidden constant [52 x i8] c"Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ\00"
define dllexport fastcc %Complexd* @Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ__7024(i8* %_impz,i8* %_impenv, double %arg_0, double %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7025 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***}*
%Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQPtr_ = getelementptr {{i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***}, {{i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***}* %impenv, i32 0, i32 0
%Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQPtr = load {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**** %Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQPtr_

; setup arguments
%arg_0Ptr = alloca double
store double %arg_0, double* %arg_0Ptr
%arg_1Ptr = alloca double
store double %arg_1, double* %arg_1Ptr


%tzone7030 = load i8*, i8** %_impzPtr
%zone7031 = bitcast i8* %tzone7030 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Complexd*
%tzone7026 = load i8*, i8** %_impzPtr
%zone7027 = bitcast i8* %tzone7026 to %mzone*
%dat7028 = call i8* @llvm_zone_malloc(%mzone* %zone7027, i64 16)
call i8* @memset(i8* %dat7028, i32 0, i64 16)
%val7029 = bitcast i8* %dat7028 to %Complexd*

; let value assignment
%obj = select i1 true, %Complexd* %val7029, %Complexd* %val7029
store %Complexd* %obj, %Complexd** %objPtr

%val7032 = load %Complexd*, %Complexd** %objPtr
%val7033 = load double, double* %arg_0Ptr
; set tuple
%val7034 = getelementptr %Complexd, %Complexd* %val7032, i64 0, i32 0
store double %val7033, double* %val7034
%val7035 = load %Complexd*, %Complexd** %objPtr
%val7036 = load double, double* %arg_1Ptr
; set tuple
%val7037 = getelementptr %Complexd, %Complexd* %val7035, i64 0, i32 1
store double %val7036, double* %val7037
%val7038 = load %Complexd*, %Complexd** %objPtr
ret %Complexd* %val7038
}
@gsxtmmath275 = hidden constant [105 x i8] c"Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** @Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7058 = load i8*, i8** %_impzPtr
%zone7059 = bitcast i8* %tzone7058 to %mzone*

; let assign value to symbol Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ
%dat_Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ = call i8* @llvm_zone_malloc(%mzone* %zone7059, i64 8)
%Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQPtr = bitcast i8* %dat_Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ to { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***
%tzone7039 = load i8*, i8** %_impzPtr
%zone7040 = bitcast i8* %tzone7039 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7040)
; malloc closure structure
%clsptr7041 = call i8* @llvm_zone_malloc(%mzone* %zone7040, i64 24)
%closure7042 = bitcast i8* %clsptr7041 to { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*

; malloc environment structure
%envptr7043 = call i8* @llvm_zone_malloc(%mzone* %zone7040, i64 8)
%environment7044 = bitcast i8* %envptr7043 to {{i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***}*

; malloc closure address table
%addytable7045 = call %clsvar* @new_address_table()
%var7046 = bitcast [52 x i8]* @gsxtmmath274 to i8*
%var7047 = bitcast [53 x i8]* @gsxtmmath272 to i8*
%addytable7048 = call %clsvar* @add_address_table(%mzone* %zone7040, i8* %var7046, i32 0, i8* %var7047, i32 3, %clsvar* %addytable7045)
%address-table7049 = bitcast %clsvar* %addytable7048 to i8*

; insert table, function and environment into closure struct
%closure.table7052 = getelementptr { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure7042, i32 0, i32 0
store i8* %address-table7049, i8** %closure.table7052
%closure.env7053 = getelementptr { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure7042, i32 0, i32 1
store i8* %envptr7043, i8** %closure.env7053
%closure.func7054 = getelementptr { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure7042, i32 0, i32 2
store %Complexd* (i8*, i8*, double, double)* @Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ__7024, %Complexd* (i8*, i8*, double, double)** %closure.func7054
%closure_size7055 = call i64 @llvm_zone_mark_size(%mzone* %zone7040)
call void @llvm_zone_ptr_set_size(i8* %clsptr7041, i64 %closure_size7055)
%wrapper_ptr7056 = call i8* @llvm_zone_malloc(%mzone* %zone7040, i64 8)
%closure_wrapper7057 = bitcast i8* %wrapper_ptr7056 to { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**
store { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure7042, { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure_wrapper7057

; let value assignment
%Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ = select i1 true, { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure_wrapper7057, { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure_wrapper7057
store { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ, { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*** %Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQPtr

; add data to environment
; don't need to alloc for env var Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ
%tmp_envptr7051 = getelementptr {{i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***}, {{i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***}* %environment7044, i32 0, i32 0
store {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*** %Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQPtr, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**** %tmp_envptr7051


%val7060 = load {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*** %Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQPtr
ret {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %val7060
}


@Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** @Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd* @Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ(double %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd* (i8*, i8*, double, double)*,  %Complexd* (i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd* %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1)
ret %Complexd* %result
}


define dllexport ccc %Complexd* @Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_native(double %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd* (i8*, i8*, double, double)*,  %Complexd* (i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd* %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1)
ret %Complexd* %result
}


define dllexport ccc i8*  @Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7061 = bitcast [105 x i8]* @gsxtmmath275 to i8*
call i32 (i8*, ...) @printf(i8* %var7061)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc double @r64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var7062 = bitcast [105 x i8]* @gsxtmmath275 to i8*
call i32 (i8*, ...) @printf(i8* %var7062)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd* (i8*, i8*, double, double)*,  %Complexd* (i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd* %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1)
%tmpres = bitcast %Complexd* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double, double}*
%arg_p_0 = getelementptr {double, double}, {double, double}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
%arg_p_1 = getelementptr {double, double}, {double, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexd_z_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd* (i8*, i8*, double, double)*,  %Complexd* (i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd* %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath276 = hidden constant [52 x i8] c"Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ\00"
define dllexport fastcc %Complexd* @Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ__7063(i8* %_impz,i8* %_impenv, double %arg_0, double %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7064 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***}*
%Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQPtr_ = getelementptr {{i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***}, {{i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***}* %impenv, i32 0, i32 0
%Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQPtr = load {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**** %Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQPtr_

; setup arguments
%arg_0Ptr = alloca double
store double %arg_0, double* %arg_0Ptr
%arg_1Ptr = alloca double
store double %arg_1, double* %arg_1Ptr


%tzone7067 = load i8*, i8** %_impzPtr
%zone7068 = bitcast i8* %tzone7067 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Complexd*
%dat7065 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat7065, i32 0, i64 16)
%val7066 = bitcast i8* %dat7065 to %Complexd*

; let value assignment
%obj = select i1 true, %Complexd* %val7066, %Complexd* %val7066
store %Complexd* %obj, %Complexd** %objPtr

%val7069 = load %Complexd*, %Complexd** %objPtr
%val7070 = load double, double* %arg_0Ptr
; set tuple
%val7071 = getelementptr %Complexd, %Complexd* %val7069, i64 0, i32 0
store double %val7070, double* %val7071
%val7072 = load %Complexd*, %Complexd** %objPtr
%val7073 = load double, double* %arg_1Ptr
; set tuple
%val7074 = getelementptr %Complexd, %Complexd* %val7072, i64 0, i32 1
store double %val7073, double* %val7074
%val7075 = load %Complexd*, %Complexd** %objPtr
ret %Complexd* %val7075
}
@gsxtmmath277 = hidden constant [105 x i8] c"Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** @Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7095 = load i8*, i8** %_impzPtr
%zone7096 = bitcast i8* %tzone7095 to %mzone*

; let assign value to symbol Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ
%dat_Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ = call i8* @llvm_zone_malloc(%mzone* %zone7096, i64 8)
%Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQPtr = bitcast i8* %dat_Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ to { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***
%tzone7076 = load i8*, i8** %_impzPtr
%zone7077 = bitcast i8* %tzone7076 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7077)
; malloc closure structure
%clsptr7078 = call i8* @llvm_zone_malloc(%mzone* %zone7077, i64 24)
%closure7079 = bitcast i8* %clsptr7078 to { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*

; malloc environment structure
%envptr7080 = call i8* @llvm_zone_malloc(%mzone* %zone7077, i64 8)
%environment7081 = bitcast i8* %envptr7080 to {{i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***}*

; malloc closure address table
%addytable7082 = call %clsvar* @new_address_table()
%var7083 = bitcast [52 x i8]* @gsxtmmath276 to i8*
%var7084 = bitcast [53 x i8]* @gsxtmmath272 to i8*
%addytable7085 = call %clsvar* @add_address_table(%mzone* %zone7077, i8* %var7083, i32 0, i8* %var7084, i32 3, %clsvar* %addytable7082)
%address-table7086 = bitcast %clsvar* %addytable7085 to i8*

; insert table, function and environment into closure struct
%closure.table7089 = getelementptr { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure7079, i32 0, i32 0
store i8* %address-table7086, i8** %closure.table7089
%closure.env7090 = getelementptr { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure7079, i32 0, i32 1
store i8* %envptr7080, i8** %closure.env7090
%closure.func7091 = getelementptr { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure7079, i32 0, i32 2
store %Complexd* (i8*, i8*, double, double)* @Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ__7063, %Complexd* (i8*, i8*, double, double)** %closure.func7091
%closure_size7092 = call i64 @llvm_zone_mark_size(%mzone* %zone7077)
call void @llvm_zone_ptr_set_size(i8* %clsptr7078, i64 %closure_size7092)
%wrapper_ptr7093 = call i8* @llvm_zone_malloc(%mzone* %zone7077, i64 8)
%closure_wrapper7094 = bitcast i8* %wrapper_ptr7093 to { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**
store { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure7079, { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure_wrapper7094

; let value assignment
%Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ = select i1 true, { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure_wrapper7094, { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure_wrapper7094
store { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ, { i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*** %Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQPtr

; add data to environment
; don't need to alloc for env var Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ
%tmp_envptr7088 = getelementptr {{i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***}, {{i8*, i8*, %Complexd* (i8*, i8*, double, double)*}***}* %environment7081, i32 0, i32 0
store {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*** %Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQPtr, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**** %tmp_envptr7088


%val7097 = load {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*** %Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQPtr
ret {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %val7097
}


@Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** @Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd* @Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ(double %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd* (i8*, i8*, double, double)*,  %Complexd* (i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd* %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1)
ret %Complexd* %result
}


define dllexport ccc %Complexd* @Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_native(double %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd* (i8*, i8*, double, double)*,  %Complexd* (i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd* %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1)
ret %Complexd* %result
}


define dllexport ccc i8*  @Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7098 = bitcast [105 x i8]* @gsxtmmath277 to i8*
call i32 (i8*, ...) @printf(i8* %var7098)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc double @r64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var7099 = bitcast [105 x i8]* @gsxtmmath277 to i8*
call i32 (i8*, ...) @printf(i8* %var7099)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd* (i8*, i8*, double, double)*,  %Complexd* (i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd* %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1)
%tmpres = bitcast %Complexd* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double, double}*
%arg_p_0 = getelementptr {double, double}, {double, double}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
%arg_p_1 = getelementptr {double, double}, {double, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexd_h_adhoc_W0NvbXBsZXhkKixkb3VibGUsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}*, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd* (i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd* (i8*, i8*, double, double)*,  %Complexd* (i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd* %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath278 = hidden constant [52 x i8] c"Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd\00"
@gsxtmmath279 = hidden constant [52 x i8] c"{i8*, i8*, %Complexd (i8*, i8*, double, double)*}**\00"
define dllexport fastcc %Complexd @Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd__7100(i8* %_impz,i8* %_impenv, double %arg_0, double %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7101 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd (i8*, i8*, double, double)*}***}*
%Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVdPtr_ = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, double, double)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, double, double)*}***}* %impenv, i32 0, i32 0
%Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVdPtr = load {i8*, i8*, %Complexd (i8*, i8*, double, double)*}***, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}**** %Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVdPtr_

; setup arguments
%arg_0Ptr = alloca double
store double %arg_0, double* %arg_0Ptr
%arg_1Ptr = alloca double
store double %arg_1, double* %arg_1Ptr


%tzone7103 = load i8*, i8** %_impzPtr
%zone7104 = bitcast i8* %tzone7103 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Complexd*
%dat7102 = alloca %Complexd, align 16

; let value assignment
%obj = select i1 true, %Complexd* %dat7102, %Complexd* %dat7102
store %Complexd* %obj, %Complexd** %objPtr

%val7105 = load %Complexd*, %Complexd** %objPtr
%val7106 = load double, double* %arg_0Ptr
; set tuple
%val7107 = getelementptr %Complexd, %Complexd* %val7105, i64 0, i32 0
store double %val7106, double* %val7107
%val7108 = load %Complexd*, %Complexd** %objPtr
%val7109 = load double, double* %arg_1Ptr
; set tuple
%val7110 = getelementptr %Complexd, %Complexd* %val7108, i64 0, i32 1
store double %val7109, double* %val7110
%val7111 = load %Complexd*, %Complexd** %objPtr
; pointer ref
%val7112 = getelementptr %Complexd, %Complexd* %val7111, i64 0
%val7113 = load %Complexd, %Complexd* %val7112
ret %Complexd %val7113
}
@gsxtmmath280 = hidden constant [105 x i8] c"Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexd (i8*, i8*, double, double)*}** @Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7133 = load i8*, i8** %_impzPtr
%zone7134 = bitcast i8* %tzone7133 to %mzone*

; let assign value to symbol Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd
%dat_Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd = call i8* @llvm_zone_malloc(%mzone* %zone7134, i64 8)
%Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVdPtr = bitcast i8* %dat_Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd to { i8*, i8*, %Complexd (i8*, i8*, double, double)*}***
%tzone7114 = load i8*, i8** %_impzPtr
%zone7115 = bitcast i8* %tzone7114 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7115)
; malloc closure structure
%clsptr7116 = call i8* @llvm_zone_malloc(%mzone* %zone7115, i64 24)
%closure7117 = bitcast i8* %clsptr7116 to { i8*, i8*, %Complexd (i8*, i8*, double, double)*}*

; malloc environment structure
%envptr7118 = call i8* @llvm_zone_malloc(%mzone* %zone7115, i64 8)
%environment7119 = bitcast i8* %envptr7118 to {{i8*, i8*, %Complexd (i8*, i8*, double, double)*}***}*

; malloc closure address table
%addytable7120 = call %clsvar* @new_address_table()
%var7121 = bitcast [52 x i8]* @gsxtmmath278 to i8*
%var7122 = bitcast [52 x i8]* @gsxtmmath279 to i8*
%addytable7123 = call %clsvar* @add_address_table(%mzone* %zone7115, i8* %var7121, i32 0, i8* %var7122, i32 3, %clsvar* %addytable7120)
%address-table7124 = bitcast %clsvar* %addytable7123 to i8*

; insert table, function and environment into closure struct
%closure.table7127 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, double, double)*}, { i8*, i8*, %Complexd (i8*, i8*, double, double)*}* %closure7117, i32 0, i32 0
store i8* %address-table7124, i8** %closure.table7127
%closure.env7128 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, double, double)*}, { i8*, i8*, %Complexd (i8*, i8*, double, double)*}* %closure7117, i32 0, i32 1
store i8* %envptr7118, i8** %closure.env7128
%closure.func7129 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, double, double)*}, { i8*, i8*, %Complexd (i8*, i8*, double, double)*}* %closure7117, i32 0, i32 2
store %Complexd (i8*, i8*, double, double)* @Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd__7100, %Complexd (i8*, i8*, double, double)** %closure.func7129
%closure_size7130 = call i64 @llvm_zone_mark_size(%mzone* %zone7115)
call void @llvm_zone_ptr_set_size(i8* %clsptr7116, i64 %closure_size7130)
%wrapper_ptr7131 = call i8* @llvm_zone_malloc(%mzone* %zone7115, i64 8)
%closure_wrapper7132 = bitcast i8* %wrapper_ptr7131 to { i8*, i8*, %Complexd (i8*, i8*, double, double)*}**
store { i8*, i8*, %Complexd (i8*, i8*, double, double)*}* %closure7117, { i8*, i8*, %Complexd (i8*, i8*, double, double)*}** %closure_wrapper7132

; let value assignment
%Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd = select i1 true, { i8*, i8*, %Complexd (i8*, i8*, double, double)*}** %closure_wrapper7132, { i8*, i8*, %Complexd (i8*, i8*, double, double)*}** %closure_wrapper7132
store { i8*, i8*, %Complexd (i8*, i8*, double, double)*}** %Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd, { i8*, i8*, %Complexd (i8*, i8*, double, double)*}*** %Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVdPtr

; add data to environment
; don't need to alloc for env var Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd
%tmp_envptr7126 = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, double, double)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, double, double)*}***}* %environment7119, i32 0, i32 0
store {i8*, i8*, %Complexd (i8*, i8*, double, double)*}*** %Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVdPtr, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}**** %tmp_envptr7126


%val7135 = load {i8*, i8*, %Complexd (i8*, i8*, double, double)*}**, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}*** %Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVdPtr
ret {i8*, i8*, %Complexd (i8*, i8*, double, double)*}** %val7135
}


@Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_var = dllexport global [1 x i8*] [ i8* null ]

@Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd (i8*, i8*, double, double)*}** @Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd (i8*, i8*, double, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd @Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd(double %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, double, double)*}*, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, double, double)*,  %Complexd (i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1)
ret %Complexd %result
}


define dllexport ccc %Complexd @Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_native(double %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, double, double)*}*, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, double, double)*,  %Complexd (i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1)
ret %Complexd %result
}


define dllexport ccc void @Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double, double}*
%arg_p_0 = getelementptr {double, double}, {double, double}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
%arg_p_1 = getelementptr {double, double}, {double, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexd_val_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, double, double)*}*, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, double, double)*,  %Complexd (i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath281 = hidden constant [41 x i8] c"hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd\00"
@gsxtmmath282 = hidden constant [49 x i8] c"{i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}**\00"
define dllexport fastcc %Complexd* @hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd__7138(i8* %_impz,i8* %_impenv, %Complexd* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7139 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}***}*
%hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpdPtr_ = getelementptr {{i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}***}, {{i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpdPtr = load {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}***, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}**** %hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpdPtr_

; setup arguments
%xPtr = alloca %Complexd*
store %Complexd* %x, %Complexd** %xPtr


%tzone7142 = load i8*, i8** %_impzPtr
%zone7143 = bitcast i8* %tzone7142 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Complexd*
%dat7140 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat7140, i32 0, i64 16)
%val7141 = bitcast i8* %dat7140 to %Complexd*

; let value assignment
%obj = select i1 true, %Complexd* %val7141, %Complexd* %val7141
store %Complexd* %obj, %Complexd** %objPtr

%val7144 = load %Complexd*, %Complexd** %objPtr
%val7145 = load %Complexd*, %Complexd** %xPtr
; tuple ref
%val7146 = getelementptr %Complexd, %Complexd* %val7145, i64 0, i32 0
%val7147 = load double, double* %val7146
; set tuple
%val7148 = getelementptr %Complexd, %Complexd* %val7144, i64 0, i32 0
store double %val7147, double* %val7148
%val7149 = load %Complexd*, %Complexd** %objPtr
%val7150 = load %Complexd*, %Complexd** %xPtr
; tuple ref
%val7151 = getelementptr %Complexd, %Complexd* %val7150, i64 0, i32 1
%val7152 = load double, double* %val7151
; set tuple
%val7153 = getelementptr %Complexd, %Complexd* %val7149, i64 0, i32 1
store double %val7152, double* %val7153
%val7154 = load %Complexd*, %Complexd** %objPtr
ret %Complexd* %val7154
}
@gsxtmmath283 = hidden constant [94 x i8] c"hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}** @hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7174 = load i8*, i8** %_impzPtr
%zone7175 = bitcast i8* %tzone7174 to %mzone*

; let assign value to symbol hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd
%dat_hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd = call i8* @llvm_zone_malloc(%mzone* %zone7175, i64 8)
%hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpdPtr = bitcast i8* %dat_hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd to { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}***
%tzone7155 = load i8*, i8** %_impzPtr
%zone7156 = bitcast i8* %tzone7155 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7156)
; malloc closure structure
%clsptr7157 = call i8* @llvm_zone_malloc(%mzone* %zone7156, i64 24)
%closure7158 = bitcast i8* %clsptr7157 to { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}*

; malloc environment structure
%envptr7159 = call i8* @llvm_zone_malloc(%mzone* %zone7156, i64 8)
%environment7160 = bitcast i8* %envptr7159 to {{i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}***}*

; malloc closure address table
%addytable7161 = call %clsvar* @new_address_table()
%var7162 = bitcast [41 x i8]* @gsxtmmath281 to i8*
%var7163 = bitcast [49 x i8]* @gsxtmmath282 to i8*
%addytable7164 = call %clsvar* @add_address_table(%mzone* %zone7156, i8* %var7162, i32 0, i8* %var7163, i32 3, %clsvar* %addytable7161)
%address-table7165 = bitcast %clsvar* %addytable7164 to i8*

; insert table, function and environment into closure struct
%closure.table7168 = getelementptr { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}, { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}* %closure7158, i32 0, i32 0
store i8* %address-table7165, i8** %closure.table7168
%closure.env7169 = getelementptr { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}, { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}* %closure7158, i32 0, i32 1
store i8* %envptr7159, i8** %closure.env7169
%closure.func7170 = getelementptr { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}, { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}* %closure7158, i32 0, i32 2
store %Complexd* (i8*, i8*, %Complexd*)* @hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd__7138, %Complexd* (i8*, i8*, %Complexd*)** %closure.func7170
%closure_size7171 = call i64 @llvm_zone_mark_size(%mzone* %zone7156)
call void @llvm_zone_ptr_set_size(i8* %clsptr7157, i64 %closure_size7171)
%wrapper_ptr7172 = call i8* @llvm_zone_malloc(%mzone* %zone7156, i64 8)
%closure_wrapper7173 = bitcast i8* %wrapper_ptr7172 to { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}**
store { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}* %closure7158, { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}** %closure_wrapper7173

; let value assignment
%hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd = select i1 true, { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}** %closure_wrapper7173, { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}** %closure_wrapper7173
store { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}** %hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd, { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}*** %hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpdPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd
%tmp_envptr7167 = getelementptr {{i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}***}, {{i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}***}* %environment7160, i32 0, i32 0
store {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}*** %hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpdPtr, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}**** %tmp_envptr7167


%val7176 = load {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}**, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}*** %hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpdPtr
ret {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}** %val7176
}


@hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}** @hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd* @hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd(%Complexd* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}**
%closure = load {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}*, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 1
%ff = load  %Complexd* (i8*, i8*, %Complexd*)*,  %Complexd* (i8*, i8*, %Complexd*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd* %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0)
ret %Complexd* %result
}


define dllexport ccc %Complexd* @hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd_native(%Complexd* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}**
%closure = load {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}*, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 1
%ff = load  %Complexd* (i8*, i8*, %Complexd*)*,  %Complexd* (i8*, i8*, %Complexd*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd* %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0)
ret %Complexd* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7177 = bitcast [94 x i8]* @gsxtmmath283 to i8*
call i32 (i8*, ...) @printf(i8* %var7177)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexd*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}**
%closure = load {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}*, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 1
%ff = load  %Complexd* (i8*, i8*, %Complexd*)*,  %Complexd* (i8*, i8*, %Complexd*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd* %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0)
%tmpres = bitcast %Complexd* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd*}*
%arg_p_0 = getelementptr {%Complexd*}, {%Complexd*}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd*, %Complexd** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}**
%closure = load {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}*, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 1
%ff = load  %Complexd* (i8*, i8*, %Complexd*)*,  %Complexd* (i8*, i8*, %Complexd*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd* %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath284 = hidden constant [35 x i8] c"hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ\00"
@gsxtmmath285 = hidden constant [43 x i8] c"{i8*, i8*, void (i8*, i8*, %Complexd*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ__7178(i8* %_impz,i8* %_impenv, %Complexd* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7179 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexd*)*}***}*
%hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQPtr = load {i8*, i8*, void (i8*, i8*, %Complexd*)*}***, {i8*, i8*, void (i8*, i8*, %Complexd*)*}**** %hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQPtr_

; setup arguments
%xPtr = alloca %Complexd*
store %Complexd* %x, %Complexd** %xPtr


%val7180 = load %Complexd*, %Complexd** %xPtr
%val7181 = bitcast %Complexd* %val7180 to i8*
call ccc void @free(i8* %val7181)
ret void
}
@gsxtmmath286 = hidden constant [88 x i8] c"hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexd*)*}** @hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7203 = load i8*, i8** %_impzPtr
%zone7204 = bitcast i8* %tzone7203 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ
%dat_hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone7204, i64 8)
%hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ to { i8*, i8*, void (i8*, i8*, %Complexd*)*}***
%tzone7184 = load i8*, i8** %_impzPtr
%zone7185 = bitcast i8* %tzone7184 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7185)
; malloc closure structure
%clsptr7186 = call i8* @llvm_zone_malloc(%mzone* %zone7185, i64 24)
%closure7187 = bitcast i8* %clsptr7186 to { i8*, i8*, void (i8*, i8*, %Complexd*)*}*

; malloc environment structure
%envptr7188 = call i8* @llvm_zone_malloc(%mzone* %zone7185, i64 8)
%environment7189 = bitcast i8* %envptr7188 to {{i8*, i8*, void (i8*, i8*, %Complexd*)*}***}*

; malloc closure address table
%addytable7190 = call %clsvar* @new_address_table()
%var7191 = bitcast [35 x i8]* @gsxtmmath284 to i8*
%var7192 = bitcast [43 x i8]* @gsxtmmath285 to i8*
%addytable7193 = call %clsvar* @add_address_table(%mzone* %zone7185, i8* %var7191, i32 0, i8* %var7192, i32 3, %clsvar* %addytable7190)
%address-table7194 = bitcast %clsvar* %addytable7193 to i8*

; insert table, function and environment into closure struct
%closure.table7197 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*)*}, { i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure7187, i32 0, i32 0
store i8* %address-table7194, i8** %closure.table7197
%closure.env7198 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*)*}, { i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure7187, i32 0, i32 1
store i8* %envptr7188, i8** %closure.env7198
%closure.func7199 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*)*}, { i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure7187, i32 0, i32 2
store void (i8*, i8*, %Complexd*)* @hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ__7178, void (i8*, i8*, %Complexd*)** %closure.func7199
%closure_size7200 = call i64 @llvm_zone_mark_size(%mzone* %zone7185)
call void @llvm_zone_ptr_set_size(i8* %clsptr7186, i64 %closure_size7200)
%wrapper_ptr7201 = call i8* @llvm_zone_malloc(%mzone* %zone7185, i64 8)
%closure_wrapper7202 = bitcast i8* %wrapper_ptr7201 to { i8*, i8*, void (i8*, i8*, %Complexd*)*}**
store { i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure7187, { i8*, i8*, void (i8*, i8*, %Complexd*)*}** %closure_wrapper7202

; let value assignment
%hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexd*)*}** %closure_wrapper7202, { i8*, i8*, void (i8*, i8*, %Complexd*)*}** %closure_wrapper7202
store { i8*, i8*, void (i8*, i8*, %Complexd*)*}** %hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ, { i8*, i8*, void (i8*, i8*, %Complexd*)*}*** %hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ
%tmp_envptr7196 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*)*}***}* %environment7189, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexd*)*}*** %hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQPtr, {i8*, i8*, void (i8*, i8*, %Complexd*)*}**** %tmp_envptr7196


%val7205 = load {i8*, i8*, void (i8*, i8*, %Complexd*)*}**, {i8*, i8*, void (i8*, i8*, %Complexd*)*}*** %hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQPtr
ret {i8*, i8*, void (i8*, i8*, %Complexd*)*}** %val7205
}


@hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexd*)*}** @hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexd*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ(%Complexd* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*)*}, {i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*)*}, {i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*)*,  void (i8*, i8*, %Complexd*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_native(%Complexd* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*)*}, {i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*)*}, {i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*)*,  void (i8*, i8*, %Complexd*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7206 = bitcast [88 x i8]* @gsxtmmath286 to i8*
call i32 (i8*, ...) @printf(i8* %var7206)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexd*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*)*}, {i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*)*}, {i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*)*,  void (i8*, i8*, %Complexd*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd*}*
%arg_p_0 = getelementptr {%Complexd*}, {%Complexd*}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd*, %Complexd** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*)*}, {i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*)*}, {i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*)*,  void (i8*, i8*, %Complexd*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath287 = hidden constant [60 x i8] c"zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0\00"
@gsxtmmath288 = hidden constant [67 x i8] c"{i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %Complexd* @zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0__7207(i8* %_impz,i8* %_impenv, %Complexd* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7208 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0Ptr_ = getelementptr {{i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0Ptr = load {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}***, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0Ptr_

; setup arguments
%xPtr = alloca %Complexd*
store %Complexd* %x, %Complexd** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val7210 = load %mzone*, %mzone** %fromzPtr
%val7211 = load %Complexd*, %Complexd** %xPtr
%val7212 = bitcast %Complexd* %val7211 to i8*
%res7213 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val7210, i8* %val7212)
br i1 %res7213, label %then7209, label %else7209

then7209:
%val7214 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val7214)
%zone_ptr7215 = bitcast %mzone* %val7214 to i8*
store i8* %zone_ptr7215, i8** %_impzPtr
%tzone7221 = load i8*, i8** %_impzPtr
%zone7222 = bitcast i8* %tzone7221 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Complexd*
%tzone7217 = load i8*, i8** %_impzPtr
%zone7218 = bitcast i8* %tzone7217 to %mzone*
%dat7219 = call i8* @llvm_zone_malloc(%mzone* %zone7218, i64 16)
call i8* @memset(i8* %dat7219, i32 0, i64 16)
%val7220 = bitcast i8* %dat7219 to %Complexd*

; let value assignment
%obj = select i1 true, %Complexd* %val7220, %Complexd* %val7220
store %Complexd* %obj, %Complexd** %objPtr

%val7223 = load %Complexd*, %Complexd** %objPtr
%val7224 = load %Complexd*, %Complexd** %xPtr
; tuple ref
%val7225 = getelementptr %Complexd, %Complexd* %val7224, i64 0, i32 0
%val7226 = load double, double* %val7225
; set tuple
%val7227 = getelementptr %Complexd, %Complexd* %val7223, i64 0, i32 0
store double %val7226, double* %val7227
%val7228 = load %Complexd*, %Complexd** %objPtr
%val7229 = load %Complexd*, %Complexd** %xPtr
; tuple ref
%val7230 = getelementptr %Complexd, %Complexd* %val7229, i64 0, i32 1
%val7231 = load double, double* %val7230
; set tuple
%val7232 = getelementptr %Complexd, %Complexd* %val7228, i64 0, i32 1
store double %val7231, double* %val7232
%oldzone7233 = call %mzone* @llvm_pop_zone_stack()
%newzone7234 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr7235 = bitcast %mzone* %newzone7234 to i8*
store i8* %zone_ptr7235, i8** %_impzPtr
%val7236 = load %Complexd*, %Complexd** %objPtr
ret %Complexd* %val7236

else7209:
%val7237 = load %Complexd*, %Complexd** %xPtr
ret %Complexd* %val7237
}
@gsxtmmath289 = hidden constant [113 x i8] c"zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}** @zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7257 = load i8*, i8** %_impzPtr
%zone7258 = bitcast i8* %tzone7257 to %mzone*

; let assign value to symbol zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0
%dat_zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone7258, i64 8)
%zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0Ptr = bitcast i8* %dat_zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0 to { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}***
%tzone7238 = load i8*, i8** %_impzPtr
%zone7239 = bitcast i8* %tzone7238 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7239)
; malloc closure structure
%clsptr7240 = call i8* @llvm_zone_malloc(%mzone* %zone7239, i64 24)
%closure7241 = bitcast i8* %clsptr7240 to { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr7242 = call i8* @llvm_zone_malloc(%mzone* %zone7239, i64 8)
%environment7243 = bitcast i8* %envptr7242 to {{i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable7244 = call %clsvar* @new_address_table()
%var7245 = bitcast [60 x i8]* @gsxtmmath287 to i8*
%var7246 = bitcast [67 x i8]* @gsxtmmath288 to i8*
%addytable7247 = call %clsvar* @add_address_table(%mzone* %zone7239, i8* %var7245, i32 0, i8* %var7246, i32 3, %clsvar* %addytable7244)
%address-table7248 = bitcast %clsvar* %addytable7247 to i8*

; insert table, function and environment into closure struct
%closure.table7251 = getelementptr { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}, { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}* %closure7241, i32 0, i32 0
store i8* %address-table7248, i8** %closure.table7251
%closure.env7252 = getelementptr { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}, { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}* %closure7241, i32 0, i32 1
store i8* %envptr7242, i8** %closure.env7252
%closure.func7253 = getelementptr { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}, { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}* %closure7241, i32 0, i32 2
store %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)* @zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0__7207, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)** %closure.func7253
%closure_size7254 = call i64 @llvm_zone_mark_size(%mzone* %zone7239)
call void @llvm_zone_ptr_set_size(i8* %clsptr7240, i64 %closure_size7254)
%wrapper_ptr7255 = call i8* @llvm_zone_malloc(%mzone* %zone7239, i64 8)
%closure_wrapper7256 = bitcast i8* %wrapper_ptr7255 to { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}**
store { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}* %closure7241, { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}** %closure_wrapper7256

; let value assignment
%zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0 = select i1 true, { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}** %closure_wrapper7256, { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}** %closure_wrapper7256
store { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}** %zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0, { i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0Ptr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0
%tmp_envptr7250 = getelementptr {{i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}***}* %environment7243, i32 0, i32 0
store {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0Ptr, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}**** %tmp_envptr7250


%val7259 = load {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}**, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0Ptr
ret {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}** %val7259
}


@zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}** @zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd* @zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0(%Complexd* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}*, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*,  %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd* %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %Complexd* %result
}


define dllexport ccc %Complexd* @zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0_native(%Complexd* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}*, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*,  %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd* %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %Complexd* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7260 = bitcast [113 x i8]* @gsxtmmath289 to i8*
call i32 (i8*, ...) @printf(i8* %var7260)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexd*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var7261 = bitcast [113 x i8]* @gsxtmmath289 to i8*
call i32 (i8*, ...) @printf(i8* %var7261)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var7262 = bitcast [113 x i8]* @gsxtmmath289 to i8*
call i32 (i8*, ...) @printf(i8* %var7262)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}*, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*,  %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd* %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %Complexd* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%Complexd*, %mzone*, %mzone*}, {%Complexd*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd*, %Complexd** %arg_p_0
%arg_p_1 = getelementptr {%Complexd*, %mzone*, %mzone*}, {%Complexd*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%Complexd*, %mzone*, %mzone*}, {%Complexd*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0NvbXBsZXhkKixDb21wbGV4ZCosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}*, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}, {i8*, i8*, %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)*,  %Complexd* (i8*, i8*, %Complexd*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd* %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath290 = hidden constant [44 x i8] c"Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd\00"
define dllexport fastcc %Complexd @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd__7263(i8* %_impz,i8* %_impenv, double %re, double %im) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7264 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd (i8*, i8*, double, double)*}***}*
%Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVdPtr_ = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, double, double)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, double, double)*}***}* %impenv, i32 0, i32 0
%Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVdPtr = load {i8*, i8*, %Complexd (i8*, i8*, double, double)*}***, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}**** %Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVdPtr_

; setup arguments
%rePtr = alloca double
store double %re, double* %rePtr
%imPtr = alloca double
store double %im, double* %imPtr


%tzone7266 = load i8*, i8** %_impzPtr
%zone7267 = bitcast i8* %tzone7266 to %mzone*

; let assign value to symbol c
%cPtr = alloca %Complexd*
%dat7265 = alloca %Complexd, align 16

; let value assignment
%c = select i1 true, %Complexd* %dat7265, %Complexd* %dat7265
store %Complexd* %c, %Complexd** %cPtr

%val7268 = load %Complexd*, %Complexd** %cPtr
%val7269 = load double, double* %rePtr
; set tuple
%val7270 = getelementptr %Complexd, %Complexd* %val7268, i64 0, i32 0
store double %val7269, double* %val7270
%val7271 = load %Complexd*, %Complexd** %cPtr
%val7272 = load double, double* %imPtr
; set tuple
%val7273 = getelementptr %Complexd, %Complexd* %val7271, i64 0, i32 1
store double %val7272, double* %val7273
%val7274 = load %Complexd*, %Complexd** %cPtr
; pointer ref
%val7275 = getelementptr %Complexd, %Complexd* %val7274, i64 0
%val7276 = load %Complexd, %Complexd* %val7275
ret %Complexd %val7276
}
@gsxtmmath291 = hidden constant [97 x i8] c"Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexd (i8*, i8*, double, double)*}** @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7296 = load i8*, i8** %_impzPtr
%zone7297 = bitcast i8* %tzone7296 to %mzone*

; let assign value to symbol Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd
%dat_Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd = call i8* @llvm_zone_malloc(%mzone* %zone7297, i64 8)
%Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVdPtr = bitcast i8* %dat_Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd to { i8*, i8*, %Complexd (i8*, i8*, double, double)*}***
%tzone7277 = load i8*, i8** %_impzPtr
%zone7278 = bitcast i8* %tzone7277 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7278)
; malloc closure structure
%clsptr7279 = call i8* @llvm_zone_malloc(%mzone* %zone7278, i64 24)
%closure7280 = bitcast i8* %clsptr7279 to { i8*, i8*, %Complexd (i8*, i8*, double, double)*}*

; malloc environment structure
%envptr7281 = call i8* @llvm_zone_malloc(%mzone* %zone7278, i64 8)
%environment7282 = bitcast i8* %envptr7281 to {{i8*, i8*, %Complexd (i8*, i8*, double, double)*}***}*

; malloc closure address table
%addytable7283 = call %clsvar* @new_address_table()
%var7284 = bitcast [44 x i8]* @gsxtmmath290 to i8*
%var7285 = bitcast [52 x i8]* @gsxtmmath279 to i8*
%addytable7286 = call %clsvar* @add_address_table(%mzone* %zone7278, i8* %var7284, i32 0, i8* %var7285, i32 3, %clsvar* %addytable7283)
%address-table7287 = bitcast %clsvar* %addytable7286 to i8*

; insert table, function and environment into closure struct
%closure.table7290 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, double, double)*}, { i8*, i8*, %Complexd (i8*, i8*, double, double)*}* %closure7280, i32 0, i32 0
store i8* %address-table7287, i8** %closure.table7290
%closure.env7291 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, double, double)*}, { i8*, i8*, %Complexd (i8*, i8*, double, double)*}* %closure7280, i32 0, i32 1
store i8* %envptr7281, i8** %closure.env7291
%closure.func7292 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, double, double)*}, { i8*, i8*, %Complexd (i8*, i8*, double, double)*}* %closure7280, i32 0, i32 2
store %Complexd (i8*, i8*, double, double)* @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd__7263, %Complexd (i8*, i8*, double, double)** %closure.func7292
%closure_size7293 = call i64 @llvm_zone_mark_size(%mzone* %zone7278)
call void @llvm_zone_ptr_set_size(i8* %clsptr7279, i64 %closure_size7293)
%wrapper_ptr7294 = call i8* @llvm_zone_malloc(%mzone* %zone7278, i64 8)
%closure_wrapper7295 = bitcast i8* %wrapper_ptr7294 to { i8*, i8*, %Complexd (i8*, i8*, double, double)*}**
store { i8*, i8*, %Complexd (i8*, i8*, double, double)*}* %closure7280, { i8*, i8*, %Complexd (i8*, i8*, double, double)*}** %closure_wrapper7295

; let value assignment
%Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd = select i1 true, { i8*, i8*, %Complexd (i8*, i8*, double, double)*}** %closure_wrapper7295, { i8*, i8*, %Complexd (i8*, i8*, double, double)*}** %closure_wrapper7295
store { i8*, i8*, %Complexd (i8*, i8*, double, double)*}** %Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd, { i8*, i8*, %Complexd (i8*, i8*, double, double)*}*** %Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVdPtr

; add data to environment
; don't need to alloc for env var Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd
%tmp_envptr7289 = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, double, double)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, double, double)*}***}* %environment7282, i32 0, i32 0
store {i8*, i8*, %Complexd (i8*, i8*, double, double)*}*** %Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVdPtr, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}**** %tmp_envptr7289


%val7298 = load {i8*, i8*, %Complexd (i8*, i8*, double, double)*}**, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}*** %Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVdPtr
ret {i8*, i8*, %Complexd (i8*, i8*, double, double)*}** %val7298
}


@Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_var = dllexport global [1 x i8*] [ i8* null ]

@Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd (i8*, i8*, double, double)*}** @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd (i8*, i8*, double, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd(double %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, double, double)*}*, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, double, double)*,  %Complexd (i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1)
ret %Complexd %result
}


define dllexport ccc %Complexd @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_native(double %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, double, double)*}*, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, double, double)*,  %Complexd (i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1)
ret %Complexd %result
}


define dllexport ccc void @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double, double}*
%arg_p_0 = getelementptr {double, double}, {double, double}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
%arg_p_1 = getelementptr {double, double}, {double, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, double, double)*}*, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, double)*}, {i8*, i8*, %Complexd (i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, double, double)*,  %Complexd (i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath292 = hidden constant [11 x i8] c"%.2f%+.2fi\00"
@gsxtmmath293 = hidden constant [33 x i8] c"print_adhoc_W3ZvaWQsQ29tcGxleGRd\00"
@gsxtmmath294 = hidden constant [42 x i8] c"{i8*, i8*, void (i8*, i8*, %Complexd)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsQ29tcGxleGRd__7301(i8* %_impz,i8* %_impenv, %Complexd %c) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7302 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexd)*}***}*
%print_adhoc_W3ZvaWQsQ29tcGxleGRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsQ29tcGxleGRdPtr = load {i8*, i8*, void (i8*, i8*, %Complexd)*}***, {i8*, i8*, void (i8*, i8*, %Complexd)*}**** %print_adhoc_W3ZvaWQsQ29tcGxleGRdPtr_

; setup arguments
%cPtr = alloca %Complexd
store %Complexd %c, %Complexd* %cPtr


%var7303 = bitcast [11 x i8]* @gsxtmmath292 to i8*
%val7304 = load %Complexd, %Complexd* %cPtr
; tuple ref
%val7305 = extractvalue %Complexd %val7304, 0
%val7306 = load %Complexd, %Complexd* %cPtr
; tuple ref
%val7307 = extractvalue %Complexd %val7306, 1

%val7308 = call i32 (i8*, ...) @printf(i8* %var7303, double %val7305, double %val7307)
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexd)*}** @print_adhoc_W3ZvaWQsQ29tcGxleGRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7329 = load i8*, i8** %_impzPtr
%zone7330 = bitcast i8* %tzone7329 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsQ29tcGxleGRd
%dat_print_adhoc_W3ZvaWQsQ29tcGxleGRd = call i8* @llvm_zone_malloc(%mzone* %zone7330, i64 8)
%print_adhoc_W3ZvaWQsQ29tcGxleGRdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsQ29tcGxleGRd to { i8*, i8*, void (i8*, i8*, %Complexd)*}***
%tzone7310 = load i8*, i8** %_impzPtr
%zone7311 = bitcast i8* %tzone7310 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7311)
; malloc closure structure
%clsptr7312 = call i8* @llvm_zone_malloc(%mzone* %zone7311, i64 24)
%closure7313 = bitcast i8* %clsptr7312 to { i8*, i8*, void (i8*, i8*, %Complexd)*}*

; malloc environment structure
%envptr7314 = call i8* @llvm_zone_malloc(%mzone* %zone7311, i64 8)
%environment7315 = bitcast i8* %envptr7314 to {{i8*, i8*, void (i8*, i8*, %Complexd)*}***}*

; malloc closure address table
%addytable7316 = call %clsvar* @new_address_table()
%var7317 = bitcast [33 x i8]* @gsxtmmath293 to i8*
%var7318 = bitcast [42 x i8]* @gsxtmmath294 to i8*
%addytable7319 = call %clsvar* @add_address_table(%mzone* %zone7311, i8* %var7317, i32 0, i8* %var7318, i32 3, %clsvar* %addytable7316)
%address-table7320 = bitcast %clsvar* %addytable7319 to i8*

; insert table, function and environment into closure struct
%closure.table7323 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd)*}, { i8*, i8*, void (i8*, i8*, %Complexd)*}* %closure7313, i32 0, i32 0
store i8* %address-table7320, i8** %closure.table7323
%closure.env7324 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd)*}, { i8*, i8*, void (i8*, i8*, %Complexd)*}* %closure7313, i32 0, i32 1
store i8* %envptr7314, i8** %closure.env7324
%closure.func7325 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd)*}, { i8*, i8*, void (i8*, i8*, %Complexd)*}* %closure7313, i32 0, i32 2
store void (i8*, i8*, %Complexd)* @print_adhoc_W3ZvaWQsQ29tcGxleGRd__7301, void (i8*, i8*, %Complexd)** %closure.func7325
%closure_size7326 = call i64 @llvm_zone_mark_size(%mzone* %zone7311)
call void @llvm_zone_ptr_set_size(i8* %clsptr7312, i64 %closure_size7326)
%wrapper_ptr7327 = call i8* @llvm_zone_malloc(%mzone* %zone7311, i64 8)
%closure_wrapper7328 = bitcast i8* %wrapper_ptr7327 to { i8*, i8*, void (i8*, i8*, %Complexd)*}**
store { i8*, i8*, void (i8*, i8*, %Complexd)*}* %closure7313, { i8*, i8*, void (i8*, i8*, %Complexd)*}** %closure_wrapper7328

; let value assignment
%print_adhoc_W3ZvaWQsQ29tcGxleGRd = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexd)*}** %closure_wrapper7328, { i8*, i8*, void (i8*, i8*, %Complexd)*}** %closure_wrapper7328
store { i8*, i8*, void (i8*, i8*, %Complexd)*}** %print_adhoc_W3ZvaWQsQ29tcGxleGRd, { i8*, i8*, void (i8*, i8*, %Complexd)*}*** %print_adhoc_W3ZvaWQsQ29tcGxleGRdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsQ29tcGxleGRd
%tmp_envptr7322 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd)*}***}* %environment7315, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexd)*}*** %print_adhoc_W3ZvaWQsQ29tcGxleGRdPtr, {i8*, i8*, void (i8*, i8*, %Complexd)*}**** %tmp_envptr7322


%val7331 = load {i8*, i8*, void (i8*, i8*, %Complexd)*}**, {i8*, i8*, void (i8*, i8*, %Complexd)*}*** %print_adhoc_W3ZvaWQsQ29tcGxleGRdPtr
ret {i8*, i8*, void (i8*, i8*, %Complexd)*}** %val7331
}


@print_adhoc_W3ZvaWQsQ29tcGxleGRd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsQ29tcGxleGRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsQ29tcGxleGRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexd)*}** @print_adhoc_W3ZvaWQsQ29tcGxleGRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexd)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsQ29tcGxleGRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsQ29tcGxleGRd(%Complexd %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd)*}*, {i8*, i8*, void (i8*, i8*, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd)*}, {i8*, i8*, void (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd)*}, {i8*, i8*, void (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd)*,  void (i8*, i8*, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsQ29tcGxleGRd_native(%Complexd %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd)*}*, {i8*, i8*, void (i8*, i8*, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd)*}, {i8*, i8*, void (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd)*}, {i8*, i8*, void (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd)*,  void (i8*, i8*, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsQ29tcGxleGRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd}*
%arg_p_0 = getelementptr {%Complexd}, {%Complexd}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd, %Complexd* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd)*}*, {i8*, i8*, void (i8*, i8*, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd)*}, {i8*, i8*, void (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd)*}, {i8*, i8*, void (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd)*,  void (i8*, i8*, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath295 = hidden constant [15 x i8] c"<Complexd 0x0>\00"
@gsxtmmath296 = hidden constant [35 x i8] c"print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ__7332(i8* %_impz,i8* %_impenv, %Complexd* %c) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7333 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexd*)*}***}*
%print_adhoc_W3ZvaWQsQ29tcGxleGQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsQ29tcGxleGQqXQPtr = load {i8*, i8*, void (i8*, i8*, %Complexd*)*}***, {i8*, i8*, void (i8*, i8*, %Complexd*)*}**** %print_adhoc_W3ZvaWQsQ29tcGxleGQqXQPtr_

; setup arguments
%cPtr = alloca %Complexd*
store %Complexd* %c, %Complexd** %cPtr

; promote local stack var allocations
%tzone7349 = load i8*, i8** %_impzPtr
%zone7350 = bitcast i8* %tzone7349 to %mzone*
%ifptr7334 = alloca i32

%val7335 = load %Complexd*, %Complexd** %cPtr
%val7336 = icmp eq %Complexd* %val7335, null
br i1 %val7336, label %then7334, label %else7334

then7334:
%var7337 = bitcast [15 x i8]* @gsxtmmath295 to i8*

%val7338 = call i32 (i8*, ...) @printf(i8* %var7337)
store i32 %val7338, i32* %ifptr7334
br label %ifcont7334

else7334:
%var7339 = bitcast [11 x i8]* @gsxtmmath292 to i8*
%val7340 = load %Complexd*, %Complexd** %cPtr
; tuple ref
%val7341 = getelementptr %Complexd, %Complexd* %val7340, i64 0, i32 0
%val7342 = load double, double* %val7341
%val7343 = load %Complexd*, %Complexd** %cPtr
; tuple ref
%val7344 = getelementptr %Complexd, %Complexd* %val7343, i64 0, i32 1
%val7345 = load double, double* %val7344

%val7346 = call i32 (i8*, ...) @printf(i8* %var7339, double %val7342, double %val7345)
store i32 %val7346, i32* %ifptr7334
br label %ifcont7334

ifcont7334:
%ifres7347 = load i32, i32* %ifptr7334

ret void
}
@gsxtmmath297 = hidden constant [88 x i8] c"print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexd*)*}** @print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7370 = load i8*, i8** %_impzPtr
%zone7371 = bitcast i8* %tzone7370 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ
%dat_print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone7371, i64 8)
%print_adhoc_W3ZvaWQsQ29tcGxleGQqXQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ to { i8*, i8*, void (i8*, i8*, %Complexd*)*}***
%tzone7351 = load i8*, i8** %_impzPtr
%zone7352 = bitcast i8* %tzone7351 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7352)
; malloc closure structure
%clsptr7353 = call i8* @llvm_zone_malloc(%mzone* %zone7352, i64 24)
%closure7354 = bitcast i8* %clsptr7353 to { i8*, i8*, void (i8*, i8*, %Complexd*)*}*

; malloc environment structure
%envptr7355 = call i8* @llvm_zone_malloc(%mzone* %zone7352, i64 8)
%environment7356 = bitcast i8* %envptr7355 to {{i8*, i8*, void (i8*, i8*, %Complexd*)*}***}*

; malloc closure address table
%addytable7357 = call %clsvar* @new_address_table()
%var7358 = bitcast [35 x i8]* @gsxtmmath296 to i8*
%var7359 = bitcast [43 x i8]* @gsxtmmath285 to i8*
%addytable7360 = call %clsvar* @add_address_table(%mzone* %zone7352, i8* %var7358, i32 0, i8* %var7359, i32 3, %clsvar* %addytable7357)
%address-table7361 = bitcast %clsvar* %addytable7360 to i8*

; insert table, function and environment into closure struct
%closure.table7364 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*)*}, { i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure7354, i32 0, i32 0
store i8* %address-table7361, i8** %closure.table7364
%closure.env7365 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*)*}, { i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure7354, i32 0, i32 1
store i8* %envptr7355, i8** %closure.env7365
%closure.func7366 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*)*}, { i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure7354, i32 0, i32 2
store void (i8*, i8*, %Complexd*)* @print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ__7332, void (i8*, i8*, %Complexd*)** %closure.func7366
%closure_size7367 = call i64 @llvm_zone_mark_size(%mzone* %zone7352)
call void @llvm_zone_ptr_set_size(i8* %clsptr7353, i64 %closure_size7367)
%wrapper_ptr7368 = call i8* @llvm_zone_malloc(%mzone* %zone7352, i64 8)
%closure_wrapper7369 = bitcast i8* %wrapper_ptr7368 to { i8*, i8*, void (i8*, i8*, %Complexd*)*}**
store { i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure7354, { i8*, i8*, void (i8*, i8*, %Complexd*)*}** %closure_wrapper7369

; let value assignment
%print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexd*)*}** %closure_wrapper7369, { i8*, i8*, void (i8*, i8*, %Complexd*)*}** %closure_wrapper7369
store { i8*, i8*, void (i8*, i8*, %Complexd*)*}** %print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ, { i8*, i8*, void (i8*, i8*, %Complexd*)*}*** %print_adhoc_W3ZvaWQsQ29tcGxleGQqXQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ
%tmp_envptr7363 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*)*}***}* %environment7356, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexd*)*}*** %print_adhoc_W3ZvaWQsQ29tcGxleGQqXQPtr, {i8*, i8*, void (i8*, i8*, %Complexd*)*}**** %tmp_envptr7363


%val7372 = load {i8*, i8*, void (i8*, i8*, %Complexd*)*}**, {i8*, i8*, void (i8*, i8*, %Complexd*)*}*** %print_adhoc_W3ZvaWQsQ29tcGxleGQqXQPtr
ret {i8*, i8*, void (i8*, i8*, %Complexd*)*}** %val7372
}


@print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexd*)*}** @print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexd*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ(%Complexd* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*)*}, {i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*)*}, {i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*)*,  void (i8*, i8*, %Complexd*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_native(%Complexd* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*)*}, {i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*)*}, {i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*)*,  void (i8*, i8*, %Complexd*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7373 = bitcast [88 x i8]* @gsxtmmath297 to i8*
call i32 (i8*, ...) @printf(i8* %var7373)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexd*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*)*}, {i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*)*}, {i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*)*,  void (i8*, i8*, %Complexd*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd*}*
%arg_p_0 = getelementptr {%Complexd*}, {%Complexd*}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd*, %Complexd** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*)*}, {i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*)*}, {i8*, i8*, void (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*)*,  void (i8*, i8*, %Complexd*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath298 = hidden constant [40 x i8] c"toString_adhoc_W1N0cmluZyosQ29tcGxleGRd\00"
@gsxtmmath299 = hidden constant [46 x i8] c"{i8*, i8*, %String* (i8*, i8*, %Complexd)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosQ29tcGxleGRd__7374(i8* %_impz,i8* %_impenv, %Complexd %c) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7375 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %Complexd)*}***}*
%toString_adhoc_W1N0cmluZyosQ29tcGxleGRdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %Complexd)*}***}, {{i8*, i8*, %String* (i8*, i8*, %Complexd)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosQ29tcGxleGRdPtr = load {i8*, i8*, %String* (i8*, i8*, %Complexd)*}***, {i8*, i8*, %String* (i8*, i8*, %Complexd)*}**** %toString_adhoc_W1N0cmluZyosQ29tcGxleGRdPtr_

; setup arguments
%cPtr = alloca %Complexd
store %Complexd %c, %Complexd* %cPtr


%tzone7377 = load i8*, i8** %_impzPtr
%zone7378 = bitcast i8* %tzone7377 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat7376 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat7376, i8* %dat7376
store i8* %str, i8** %strPtr

%val7379 = load i8*, i8** %strPtr
%var7380 = bitcast [11 x i8]* @gsxtmmath292 to i8*
%val7381 = load %Complexd, %Complexd* %cPtr
; tuple ref
%val7382 = extractvalue %Complexd %val7381, 0
%val7383 = load %Complexd, %Complexd* %cPtr
; tuple ref
%val7384 = extractvalue %Complexd %val7383, 1

%val7385 = call i32 (i8*,i8*, ...) @sprintf(i8* %val7379, i8* %var7380, double %val7382, double %val7384)
%val7386 = load i8*, i8** %strPtr
%res7387 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val7386)
ret %String* %res7387
}
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %Complexd)*}** @toString_adhoc_W1N0cmluZyosQ29tcGxleGRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7407 = load i8*, i8** %_impzPtr
%zone7408 = bitcast i8* %tzone7407 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosQ29tcGxleGRd
%dat_toString_adhoc_W1N0cmluZyosQ29tcGxleGRd = call i8* @llvm_zone_malloc(%mzone* %zone7408, i64 8)
%toString_adhoc_W1N0cmluZyosQ29tcGxleGRdPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosQ29tcGxleGRd to { i8*, i8*, %String* (i8*, i8*, %Complexd)*}***
%tzone7388 = load i8*, i8** %_impzPtr
%zone7389 = bitcast i8* %tzone7388 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7389)
; malloc closure structure
%clsptr7390 = call i8* @llvm_zone_malloc(%mzone* %zone7389, i64 24)
%closure7391 = bitcast i8* %clsptr7390 to { i8*, i8*, %String* (i8*, i8*, %Complexd)*}*

; malloc environment structure
%envptr7392 = call i8* @llvm_zone_malloc(%mzone* %zone7389, i64 8)
%environment7393 = bitcast i8* %envptr7392 to {{i8*, i8*, %String* (i8*, i8*, %Complexd)*}***}*

; malloc closure address table
%addytable7394 = call %clsvar* @new_address_table()
%var7395 = bitcast [40 x i8]* @gsxtmmath298 to i8*
%var7396 = bitcast [46 x i8]* @gsxtmmath299 to i8*
%addytable7397 = call %clsvar* @add_address_table(%mzone* %zone7389, i8* %var7395, i32 0, i8* %var7396, i32 3, %clsvar* %addytable7394)
%address-table7398 = bitcast %clsvar* %addytable7397 to i8*

; insert table, function and environment into closure struct
%closure.table7401 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Complexd)*}, { i8*, i8*, %String* (i8*, i8*, %Complexd)*}* %closure7391, i32 0, i32 0
store i8* %address-table7398, i8** %closure.table7401
%closure.env7402 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Complexd)*}, { i8*, i8*, %String* (i8*, i8*, %Complexd)*}* %closure7391, i32 0, i32 1
store i8* %envptr7392, i8** %closure.env7402
%closure.func7403 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Complexd)*}, { i8*, i8*, %String* (i8*, i8*, %Complexd)*}* %closure7391, i32 0, i32 2
store %String* (i8*, i8*, %Complexd)* @toString_adhoc_W1N0cmluZyosQ29tcGxleGRd__7374, %String* (i8*, i8*, %Complexd)** %closure.func7403
%closure_size7404 = call i64 @llvm_zone_mark_size(%mzone* %zone7389)
call void @llvm_zone_ptr_set_size(i8* %clsptr7390, i64 %closure_size7404)
%wrapper_ptr7405 = call i8* @llvm_zone_malloc(%mzone* %zone7389, i64 8)
%closure_wrapper7406 = bitcast i8* %wrapper_ptr7405 to { i8*, i8*, %String* (i8*, i8*, %Complexd)*}**
store { i8*, i8*, %String* (i8*, i8*, %Complexd)*}* %closure7391, { i8*, i8*, %String* (i8*, i8*, %Complexd)*}** %closure_wrapper7406

; let value assignment
%toString_adhoc_W1N0cmluZyosQ29tcGxleGRd = select i1 true, { i8*, i8*, %String* (i8*, i8*, %Complexd)*}** %closure_wrapper7406, { i8*, i8*, %String* (i8*, i8*, %Complexd)*}** %closure_wrapper7406
store { i8*, i8*, %String* (i8*, i8*, %Complexd)*}** %toString_adhoc_W1N0cmluZyosQ29tcGxleGRd, { i8*, i8*, %String* (i8*, i8*, %Complexd)*}*** %toString_adhoc_W1N0cmluZyosQ29tcGxleGRdPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosQ29tcGxleGRd
%tmp_envptr7400 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %Complexd)*}***}, {{i8*, i8*, %String* (i8*, i8*, %Complexd)*}***}* %environment7393, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %Complexd)*}*** %toString_adhoc_W1N0cmluZyosQ29tcGxleGRdPtr, {i8*, i8*, %String* (i8*, i8*, %Complexd)*}**** %tmp_envptr7400


%val7409 = load {i8*, i8*, %String* (i8*, i8*, %Complexd)*}**, {i8*, i8*, %String* (i8*, i8*, %Complexd)*}*** %toString_adhoc_W1N0cmluZyosQ29tcGxleGRdPtr
ret {i8*, i8*, %String* (i8*, i8*, %Complexd)*}** %val7409
}


@toString_adhoc_W1N0cmluZyosQ29tcGxleGRd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosQ29tcGxleGRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosQ29tcGxleGRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %Complexd)*}** @toString_adhoc_W1N0cmluZyosQ29tcGxleGRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %Complexd)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosQ29tcGxleGRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosQ29tcGxleGRd(%Complexd %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Complexd)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Complexd)*}*, {i8*, i8*, %String* (i8*, i8*, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexd)*}, {i8*, i8*, %String* (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexd)*}, {i8*, i8*, %String* (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Complexd)*,  %String* (i8*, i8*, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Complexd %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosQ29tcGxleGRd_native(%Complexd %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Complexd)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Complexd)*}*, {i8*, i8*, %String* (i8*, i8*, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexd)*}, {i8*, i8*, %String* (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexd)*}, {i8*, i8*, %String* (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Complexd)*,  %String* (i8*, i8*, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Complexd %arg_0)
ret %String* %result
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosQ29tcGxleGRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd}*
%arg_p_0 = getelementptr {%Complexd}, {%Complexd}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd, %Complexd* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Complexd)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Complexd)*}*, {i8*, i8*, %String* (i8*, i8*, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexd)*}, {i8*, i8*, %String* (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexd)*}, {i8*, i8*, %String* (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Complexd)*,  %String* (i8*, i8*, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Complexd %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath300 = hidden constant [42 x i8] c"toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ\00"
@gsxtmmath301 = hidden constant [47 x i8] c"{i8*, i8*, %String* (i8*, i8*, %Complexd*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ__7410(i8* %_impz,i8* %_impenv, %Complexd* %c) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7411 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %Complexd*)*}***}*
%toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %Complexd*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %Complexd*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQPtr = load {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}***, {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}**** %toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQPtr_

; setup arguments
%cPtr = alloca %Complexd*
store %Complexd* %c, %Complexd** %cPtr


%tzone7413 = load i8*, i8** %_impzPtr
%zone7414 = bitcast i8* %tzone7413 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat7412 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat7412, i8* %dat7412
store i8* %str, i8** %strPtr

; promote local stack var allocations
%tzone7433 = load i8*, i8** %_impzPtr
%zone7434 = bitcast i8* %tzone7433 to %mzone*
%ifptr7415 = alloca i32
%val7416 = load %Complexd*, %Complexd** %cPtr
%val7417 = icmp eq %Complexd* %val7416, null
br i1 %val7417, label %then7415, label %else7415

then7415:
%val7418 = load i8*, i8** %strPtr
%var7419 = bitcast [15 x i8]* @gsxtmmath295 to i8*

%val7420 = call i32 (i8*,i8*, ...) @sprintf(i8* %val7418, i8* %var7419)
store i32 %val7420, i32* %ifptr7415
br label %ifcont7415

else7415:
%val7421 = load i8*, i8** %strPtr
%var7422 = bitcast [11 x i8]* @gsxtmmath292 to i8*
%val7423 = load %Complexd*, %Complexd** %cPtr
; tuple ref
%val7424 = getelementptr %Complexd, %Complexd* %val7423, i64 0, i32 0
%val7425 = load double, double* %val7424
%val7426 = load %Complexd*, %Complexd** %cPtr
; tuple ref
%val7427 = getelementptr %Complexd, %Complexd* %val7426, i64 0, i32 1
%val7428 = load double, double* %val7427

%val7429 = call i32 (i8*,i8*, ...) @sprintf(i8* %val7421, i8* %var7422, double %val7425, double %val7428)
store i32 %val7429, i32* %ifptr7415
br label %ifcont7415

ifcont7415:
%ifres7430 = load i32, i32* %ifptr7415

%val7431 = load i8*, i8** %strPtr
%res7432 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val7431)
ret %String* %res7432
}
@gsxtmmath302 = hidden constant [95 x i8] c"toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}** @toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7454 = load i8*, i8** %_impzPtr
%zone7455 = bitcast i8* %tzone7454 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ
%dat_toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone7455, i64 8)
%toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ to { i8*, i8*, %String* (i8*, i8*, %Complexd*)*}***
%tzone7435 = load i8*, i8** %_impzPtr
%zone7436 = bitcast i8* %tzone7435 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7436)
; malloc closure structure
%clsptr7437 = call i8* @llvm_zone_malloc(%mzone* %zone7436, i64 24)
%closure7438 = bitcast i8* %clsptr7437 to { i8*, i8*, %String* (i8*, i8*, %Complexd*)*}*

; malloc environment structure
%envptr7439 = call i8* @llvm_zone_malloc(%mzone* %zone7436, i64 8)
%environment7440 = bitcast i8* %envptr7439 to {{i8*, i8*, %String* (i8*, i8*, %Complexd*)*}***}*

; malloc closure address table
%addytable7441 = call %clsvar* @new_address_table()
%var7442 = bitcast [42 x i8]* @gsxtmmath300 to i8*
%var7443 = bitcast [47 x i8]* @gsxtmmath301 to i8*
%addytable7444 = call %clsvar* @add_address_table(%mzone* %zone7436, i8* %var7442, i32 0, i8* %var7443, i32 3, %clsvar* %addytable7441)
%address-table7445 = bitcast %clsvar* %addytable7444 to i8*

; insert table, function and environment into closure struct
%closure.table7448 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Complexd*)*}, { i8*, i8*, %String* (i8*, i8*, %Complexd*)*}* %closure7438, i32 0, i32 0
store i8* %address-table7445, i8** %closure.table7448
%closure.env7449 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Complexd*)*}, { i8*, i8*, %String* (i8*, i8*, %Complexd*)*}* %closure7438, i32 0, i32 1
store i8* %envptr7439, i8** %closure.env7449
%closure.func7450 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Complexd*)*}, { i8*, i8*, %String* (i8*, i8*, %Complexd*)*}* %closure7438, i32 0, i32 2
store %String* (i8*, i8*, %Complexd*)* @toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ__7410, %String* (i8*, i8*, %Complexd*)** %closure.func7450
%closure_size7451 = call i64 @llvm_zone_mark_size(%mzone* %zone7436)
call void @llvm_zone_ptr_set_size(i8* %clsptr7437, i64 %closure_size7451)
%wrapper_ptr7452 = call i8* @llvm_zone_malloc(%mzone* %zone7436, i64 8)
%closure_wrapper7453 = bitcast i8* %wrapper_ptr7452 to { i8*, i8*, %String* (i8*, i8*, %Complexd*)*}**
store { i8*, i8*, %String* (i8*, i8*, %Complexd*)*}* %closure7438, { i8*, i8*, %String* (i8*, i8*, %Complexd*)*}** %closure_wrapper7453

; let value assignment
%toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, %Complexd*)*}** %closure_wrapper7453, { i8*, i8*, %String* (i8*, i8*, %Complexd*)*}** %closure_wrapper7453
store { i8*, i8*, %String* (i8*, i8*, %Complexd*)*}** %toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ, { i8*, i8*, %String* (i8*, i8*, %Complexd*)*}*** %toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ
%tmp_envptr7447 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %Complexd*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %Complexd*)*}***}* %environment7440, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}*** %toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQPtr, {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}**** %tmp_envptr7447


%val7456 = load {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}**, {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}*** %toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}** %val7456
}


@toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}** @toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ(%Complexd* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}*, {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}, {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}, {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Complexd*)*,  %String* (i8*, i8*, %Complexd*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ_native(%Complexd* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}*, {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}, {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}, {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Complexd*)*,  %String* (i8*, i8*, %Complexd*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7457 = bitcast [95 x i8]* @gsxtmmath302 to i8*
call i32 (i8*, ...) @printf(i8* %var7457)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexd*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}*, {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}, {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}, {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Complexd*)*,  %String* (i8*, i8*, %Complexd*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd*}*
%arg_p_0 = getelementptr {%Complexd*}, {%Complexd*}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd*, %Complexd** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}*, {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}, {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}, {i8*, i8*, %String* (i8*, i8*, %Complexd*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Complexd*)*,  %String* (i8*, i8*, %Complexd*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath303 = hidden constant [58 x i8] c"xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ\00"
@gsxtmmath304 = hidden constant [58 x i8] c"{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**\00"
define dllexport fastcc %Complexd @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ__7458(i8* %_impz,i8* %_impenv, %Complexd %a, %Complexd %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7459 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}*
%xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr_ = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}* %impenv, i32 0, i32 0
%xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**** %xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr_

; setup arguments
%aPtr = alloca %Complexd
store %Complexd %a, %Complexd* %aPtr
%bPtr = alloca %Complexd
store %Complexd %b, %Complexd* %bPtr


%val7460 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7461 = extractvalue %Complexd %val7460, 0
%val7462 = load %Complexd, %Complexd* %bPtr
; tuple ref
%val7463 = extractvalue %Complexd %val7462, 0
%val7464 = fadd double %val7461, %val7463
%val7465 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7466 = extractvalue %Complexd %val7465, 1
%val7467 = load %Complexd, %Complexd* %bPtr
; tuple ref
%val7468 = extractvalue %Complexd %val7467, 1
%val7469 = fadd double %val7466, %val7468
%res7470 = call fastcc %Complexd @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd(double %val7464, double %val7469)
ret %Complexd %res7470
}
define dllexport ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7490 = load i8*, i8** %_impzPtr
%zone7491 = bitcast i8* %tzone7490 to %mzone*

; let assign value to symbol xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ
%dat_xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ = call i8* @llvm_zone_malloc(%mzone* %zone7491, i64 8)
%xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr = bitcast i8* %dat_xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***
%tzone7471 = load i8*, i8** %_impzPtr
%zone7472 = bitcast i8* %tzone7471 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7472)
; malloc closure structure
%clsptr7473 = call i8* @llvm_zone_malloc(%mzone* %zone7472, i64 24)
%closure7474 = bitcast i8* %clsptr7473 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*

; malloc environment structure
%envptr7475 = call i8* @llvm_zone_malloc(%mzone* %zone7472, i64 8)
%environment7476 = bitcast i8* %envptr7475 to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}*

; malloc closure address table
%addytable7477 = call %clsvar* @new_address_table()
%var7478 = bitcast [58 x i8]* @gsxtmmath303 to i8*
%var7479 = bitcast [58 x i8]* @gsxtmmath304 to i8*
%addytable7480 = call %clsvar* @add_address_table(%mzone* %zone7472, i8* %var7478, i32 0, i8* %var7479, i32 3, %clsvar* %addytable7477)
%address-table7481 = bitcast %clsvar* %addytable7480 to i8*

; insert table, function and environment into closure struct
%closure.table7484 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure7474, i32 0, i32 0
store i8* %address-table7481, i8** %closure.table7484
%closure.env7485 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure7474, i32 0, i32 1
store i8* %envptr7475, i8** %closure.env7485
%closure.func7486 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure7474, i32 0, i32 2
store %Complexd (i8*, i8*, %Complexd, %Complexd)* @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ__7458, %Complexd (i8*, i8*, %Complexd, %Complexd)** %closure.func7486
%closure_size7487 = call i64 @llvm_zone_mark_size(%mzone* %zone7472)
call void @llvm_zone_ptr_set_size(i8* %clsptr7473, i64 %closure_size7487)
%wrapper_ptr7488 = call i8* @llvm_zone_malloc(%mzone* %zone7472, i64 8)
%closure_wrapper7489 = bitcast i8* %wrapper_ptr7488 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure7474, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_wrapper7489

; let value assignment
%xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ = select i1 true, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_wrapper7489, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_wrapper7489
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*** %xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr

; add data to environment
; don't need to alloc for env var xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ
%tmp_envptr7483 = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}* %environment7476, i32 0, i32 0
store {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*** %xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**** %tmp_envptr7483


%val7492 = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*** %xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr
ret {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %val7492
}


@xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ(%Complexd %arg_0,%Complexd %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, %Complexd)*,  %Complexd (i8*, i8*, %Complexd, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, %Complexd %arg_1)
ret %Complexd %result
}


define dllexport ccc %Complexd @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_native(%Complexd %arg_0,%Complexd %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, %Complexd)*,  %Complexd (i8*, i8*, %Complexd, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, %Complexd %arg_1)
ret %Complexd %result
}


define dllexport ccc void @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd, %Complexd}*
%arg_p_0 = getelementptr {%Complexd, %Complexd}, {%Complexd, %Complexd}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd, %Complexd* %arg_p_0
%arg_p_1 = getelementptr {%Complexd, %Complexd}, {%Complexd, %Complexd}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexd, %Complexd* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, %Complexd)*,  %Complexd (i8*, i8*, %Complexd, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, %Complexd %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath305 = hidden constant [55 x i8] c"xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0\00"
@gsxtmmath306 = hidden constant [55 x i8] c"{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**\00"
define dllexport fastcc %Complexd @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0__7493(i8* %_impz,i8* %_impenv, %Complexd %a, double %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7494 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}*
%xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr_ = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}* %impenv, i32 0, i32 0
%xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**** %xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr_

; setup arguments
%aPtr = alloca %Complexd
store %Complexd %a, %Complexd* %aPtr
%bPtr = alloca double
store double %b, double* %bPtr


%val7495 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7496 = extractvalue %Complexd %val7495, 0
%val7497 = load double, double* %bPtr
%val7498 = fadd double %val7496, %val7497
%val7499 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7500 = extractvalue %Complexd %val7499, 1
%res7501 = call fastcc %Complexd @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd(double %val7498, double %val7500)
ret %Complexd %res7501
}
@gsxtmmath307 = hidden constant [108 x i8] c"xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7521 = load i8*, i8** %_impzPtr
%zone7522 = bitcast i8* %tzone7521 to %mzone*

; let assign value to symbol xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0
%dat_xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0 = call i8* @llvm_zone_malloc(%mzone* %zone7522, i64 8)
%xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr = bitcast i8* %dat_xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***
%tzone7502 = load i8*, i8** %_impzPtr
%zone7503 = bitcast i8* %tzone7502 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7503)
; malloc closure structure
%clsptr7504 = call i8* @llvm_zone_malloc(%mzone* %zone7503, i64 24)
%closure7505 = bitcast i8* %clsptr7504 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*

; malloc environment structure
%envptr7506 = call i8* @llvm_zone_malloc(%mzone* %zone7503, i64 8)
%environment7507 = bitcast i8* %envptr7506 to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}*

; malloc closure address table
%addytable7508 = call %clsvar* @new_address_table()
%var7509 = bitcast [55 x i8]* @gsxtmmath305 to i8*
%var7510 = bitcast [55 x i8]* @gsxtmmath306 to i8*
%addytable7511 = call %clsvar* @add_address_table(%mzone* %zone7503, i8* %var7509, i32 0, i8* %var7510, i32 3, %clsvar* %addytable7508)
%address-table7512 = bitcast %clsvar* %addytable7511 to i8*

; insert table, function and environment into closure struct
%closure.table7515 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure7505, i32 0, i32 0
store i8* %address-table7512, i8** %closure.table7515
%closure.env7516 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure7505, i32 0, i32 1
store i8* %envptr7506, i8** %closure.env7516
%closure.func7517 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure7505, i32 0, i32 2
store %Complexd (i8*, i8*, %Complexd, double)* @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0__7493, %Complexd (i8*, i8*, %Complexd, double)** %closure.func7517
%closure_size7518 = call i64 @llvm_zone_mark_size(%mzone* %zone7503)
call void @llvm_zone_ptr_set_size(i8* %clsptr7504, i64 %closure_size7518)
%wrapper_ptr7519 = call i8* @llvm_zone_malloc(%mzone* %zone7503, i64 8)
%closure_wrapper7520 = bitcast i8* %wrapper_ptr7519 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure7505, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_wrapper7520

; let value assignment
%xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0 = select i1 true, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_wrapper7520, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_wrapper7520
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*** %xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr

; add data to environment
; don't need to alloc for env var xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0
%tmp_envptr7514 = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}* %environment7507, i32 0, i32 0
store {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*** %xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**** %tmp_envptr7514


%val7523 = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*** %xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr
ret {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %val7523
}


@xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0(%Complexd %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, double)*,  %Complexd (i8*, i8*, %Complexd, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, double %arg_1)
ret %Complexd %result
}


define dllexport ccc %Complexd @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_native(%Complexd %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, double)*,  %Complexd (i8*, i8*, %Complexd, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, double %arg_1)
ret %Complexd %result
}


define dllexport ccc void @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd, double}*
%arg_p_0 = getelementptr {%Complexd, double}, {%Complexd, double}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd, %Complexd* %arg_p_0
%arg_p_1 = getelementptr {%Complexd, double}, {%Complexd, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, double)*,  %Complexd (i8*, i8*, %Complexd, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, double %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath308 = hidden constant [55 x i8] c"xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0\00"
@gsxtmmath309 = hidden constant [55 x i8] c"{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**\00"
define dllexport fastcc %Complexd @xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0__7525(i8* %_impz,i8* %_impenv, double %b, %Complexd %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7526 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}*
%xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr_ = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}* %impenv, i32 0, i32 0
%xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr = load {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**** %xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr_

; setup arguments
%bPtr = alloca double
store double %b, double* %bPtr
%aPtr = alloca %Complexd
store %Complexd %a, %Complexd* %aPtr


%val7527 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7528 = extractvalue %Complexd %val7527, 0
%val7529 = load double, double* %bPtr
%val7530 = fadd double %val7528, %val7529
%val7531 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7532 = extractvalue %Complexd %val7531, 1
%res7533 = call fastcc %Complexd @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd(double %val7530, double %val7532)
ret %Complexd %res7533
}
@gsxtmmath310 = hidden constant [108 x i8] c"xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** @xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7553 = load i8*, i8** %_impzPtr
%zone7554 = bitcast i8* %tzone7553 to %mzone*

; let assign value to symbol xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0
%dat_xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0 = call i8* @llvm_zone_malloc(%mzone* %zone7554, i64 8)
%xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr = bitcast i8* %dat_xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0 to { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***
%tzone7534 = load i8*, i8** %_impzPtr
%zone7535 = bitcast i8* %tzone7534 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7535)
; malloc closure structure
%clsptr7536 = call i8* @llvm_zone_malloc(%mzone* %zone7535, i64 24)
%closure7537 = bitcast i8* %clsptr7536 to { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*

; malloc environment structure
%envptr7538 = call i8* @llvm_zone_malloc(%mzone* %zone7535, i64 8)
%environment7539 = bitcast i8* %envptr7538 to {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}*

; malloc closure address table
%addytable7540 = call %clsvar* @new_address_table()
%var7541 = bitcast [55 x i8]* @gsxtmmath308 to i8*
%var7542 = bitcast [55 x i8]* @gsxtmmath309 to i8*
%addytable7543 = call %clsvar* @add_address_table(%mzone* %zone7535, i8* %var7541, i32 0, i8* %var7542, i32 3, %clsvar* %addytable7540)
%address-table7544 = bitcast %clsvar* %addytable7543 to i8*

; insert table, function and environment into closure struct
%closure.table7547 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure7537, i32 0, i32 0
store i8* %address-table7544, i8** %closure.table7547
%closure.env7548 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure7537, i32 0, i32 1
store i8* %envptr7538, i8** %closure.env7548
%closure.func7549 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure7537, i32 0, i32 2
store %Complexd (i8*, i8*, double, %Complexd)* @xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0__7525, %Complexd (i8*, i8*, double, %Complexd)** %closure.func7549
%closure_size7550 = call i64 @llvm_zone_mark_size(%mzone* %zone7535)
call void @llvm_zone_ptr_set_size(i8* %clsptr7536, i64 %closure_size7550)
%wrapper_ptr7551 = call i8* @llvm_zone_malloc(%mzone* %zone7535, i64 8)
%closure_wrapper7552 = bitcast i8* %wrapper_ptr7551 to { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**
store { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure7537, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_wrapper7552

; let value assignment
%xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0 = select i1 true, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_wrapper7552, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_wrapper7552
store { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*** %xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr

; add data to environment
; don't need to alloc for env var xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0
%tmp_envptr7546 = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}* %environment7539, i32 0, i32 0
store {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*** %xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**** %tmp_envptr7546


%val7555 = load {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*** %xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr
ret {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %val7555
}


@xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** @xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd @xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0(double %arg_0,%Complexd %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, double, %Complexd)*,  %Complexd (i8*, i8*, double, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, double %arg_0, %Complexd %arg_1)
ret %Complexd %result
}


define dllexport ccc %Complexd @xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_native(double %arg_0,%Complexd %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, double, %Complexd)*,  %Complexd (i8*, i8*, double, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, double %arg_0, %Complexd %arg_1)
ret %Complexd %result
}


define dllexport ccc void @xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double, %Complexd}*
%arg_p_0 = getelementptr {double, %Complexd}, {double, %Complexd}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
%arg_p_1 = getelementptr {double, %Complexd}, {double, %Complexd}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexd, %Complexd* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, double, %Complexd)*,  %Complexd (i8*, i8*, double, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, double %arg_0, %Complexd %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath311 = hidden constant [84 x i8] c"Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ\00"
@gsxtmmath312 = hidden constant [72 x i8] c"{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**\00"
define dllexport fastcc void @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ__7557(i8* %_impz,i8* %_impenv, %Complexd* %a, %Complexd* %b, %Complexd* %c, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7558 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}*
%Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}* %impenv, i32 0, i32 0
%Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**** %Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr_

; setup arguments
%aPtr = alloca %Complexd*
store %Complexd* %a, %Complexd** %aPtr
%bPtr = alloca %Complexd*
store %Complexd* %b, %Complexd** %bPtr
%cPtr = alloca %Complexd*
store %Complexd* %c, %Complexd** %cPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone7559 = load i8*, i8** %_impzPtr
%zone7560 = bitcast i8* %tzone7559 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val7563 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val7594 = load i64, i64* %iPtr
%num7595 = add i64 %val7563, %val7594
%comp7596 = icmp ult i64 %val7563, 1
br i1 %comp7596, label %after7561, label %loop7561

loop7561:
%val7564 = load i64, i64* %iPtr
%val7565 = load %Complexd*, %Complexd** %cPtr
; pointer ref
%val7566 = getelementptr %Complexd, %Complexd* %val7565, i64 %val7564
%val7567 = load i64, i64* %iPtr
%val7568 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val7569 = getelementptr %Complexd, %Complexd* %val7568, i64 %val7567
; tuple ref
%val7570 = getelementptr %Complexd, %Complexd* %val7569, i64 0, i32 0
%val7571 = load double, double* %val7570
%val7572 = load i64, i64* %iPtr
%val7573 = load %Complexd*, %Complexd** %bPtr
; pointer ref
%val7574 = getelementptr %Complexd, %Complexd* %val7573, i64 %val7572
; tuple ref
%val7575 = getelementptr %Complexd, %Complexd* %val7574, i64 0, i32 0
%val7576 = load double, double* %val7575
%val7577 = fadd double %val7571, %val7576
; set tuple
%val7578 = getelementptr %Complexd, %Complexd* %val7566, i64 0, i32 0
store double %val7577, double* %val7578
%val7579 = load i64, i64* %iPtr
%val7580 = load %Complexd*, %Complexd** %cPtr
; pointer ref
%val7581 = getelementptr %Complexd, %Complexd* %val7580, i64 %val7579
%val7582 = load i64, i64* %iPtr
%val7583 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val7584 = getelementptr %Complexd, %Complexd* %val7583, i64 %val7582
; tuple ref
%val7585 = getelementptr %Complexd, %Complexd* %val7584, i64 0, i32 1
%val7586 = load double, double* %val7585
%val7587 = load i64, i64* %iPtr
%val7588 = load %Complexd*, %Complexd** %bPtr
; pointer ref
%val7589 = getelementptr %Complexd, %Complexd* %val7588, i64 %val7587
; tuple ref
%val7590 = getelementptr %Complexd, %Complexd* %val7589, i64 0, i32 1
%val7591 = load double, double* %val7590
%val7592 = fadd double %val7586, %val7591
; set tuple
%val7593 = getelementptr %Complexd, %Complexd* %val7581, i64 0, i32 1
store double %val7592, double* %val7593
%loop_cnt7561 = load i64, i64* %iPtr
%next7561 = add i64 %loop_cnt7561, 1
store i64 %next7561, i64* %iPtr
%cmp7561 = icmp ult i64 %next7561, %num7595
br i1 %cmp7561, label %loop7561, label %after7561

after7561:
ret void
}
@gsxtmmath313 = hidden constant [137 x i8] c"Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7618 = load i8*, i8** %_impzPtr
%zone7619 = bitcast i8* %tzone7618 to %mzone*

; let assign value to symbol Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ
%dat_Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone7619, i64 8)
%Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr = bitcast i8* %dat_Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ to { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***
%tzone7599 = load i8*, i8** %_impzPtr
%zone7600 = bitcast i8* %tzone7599 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7600)
; malloc closure structure
%clsptr7601 = call i8* @llvm_zone_malloc(%mzone* %zone7600, i64 24)
%closure7602 = bitcast i8* %clsptr7601 to { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*

; malloc environment structure
%envptr7603 = call i8* @llvm_zone_malloc(%mzone* %zone7600, i64 8)
%environment7604 = bitcast i8* %envptr7603 to {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}*

; malloc closure address table
%addytable7605 = call %clsvar* @new_address_table()
%var7606 = bitcast [84 x i8]* @gsxtmmath311 to i8*
%var7607 = bitcast [72 x i8]* @gsxtmmath312 to i8*
%addytable7608 = call %clsvar* @add_address_table(%mzone* %zone7600, i8* %var7606, i32 0, i8* %var7607, i32 3, %clsvar* %addytable7605)
%address-table7609 = bitcast %clsvar* %addytable7608 to i8*

; insert table, function and environment into closure struct
%closure.table7612 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure7602, i32 0, i32 0
store i8* %address-table7609, i8** %closure.table7612
%closure.env7613 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure7602, i32 0, i32 1
store i8* %envptr7603, i8** %closure.env7613
%closure.func7614 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure7602, i32 0, i32 2
store void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)* @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ__7557, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)** %closure.func7614
%closure_size7615 = call i64 @llvm_zone_mark_size(%mzone* %zone7600)
call void @llvm_zone_ptr_set_size(i8* %clsptr7601, i64 %closure_size7615)
%wrapper_ptr7616 = call i8* @llvm_zone_malloc(%mzone* %zone7600, i64 8)
%closure_wrapper7617 = bitcast i8* %wrapper_ptr7616 to { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**
store { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure7602, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_wrapper7617

; let value assignment
%Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_wrapper7617, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_wrapper7617
store { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*** %Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr

; add data to environment
; don't need to alloc for env var Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ
%tmp_envptr7611 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}* %environment7604, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*** %Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**** %tmp_envptr7611


%val7620 = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*** %Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %val7620
}


@Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ(%Complexd* %arg_0,%Complexd* %arg_1,%Complexd* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, %Complexd* %arg_1, %Complexd* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc void @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_native(%Complexd* %arg_0,%Complexd* %arg_1,%Complexd* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, %Complexd* %arg_1, %Complexd* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc i8*  @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7621 = bitcast [137 x i8]* @gsxtmmath313 to i8*
call i32 (i8*, ...) @printf(i8* %var7621)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexd*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var7622 = bitcast [137 x i8]* @gsxtmmath313 to i8*
call i32 (i8*, ...) @printf(i8* %var7622)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Complexd*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var7623 = bitcast [137 x i8]* @gsxtmmath313 to i8*
call i32 (i8*, ...) @printf(i8* %var7623)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Complexd*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var7624 = bitcast [137 x i8]* @gsxtmmath313 to i8*
call i32 (i8*, ...) @printf(i8* %var7624)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, %Complexd* %arg_1, %Complexd* %arg_2, i64 %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd*, %Complexd*, %Complexd*, i64}*
%arg_p_0 = getelementptr {%Complexd*, %Complexd*, %Complexd*, i64}, {%Complexd*, %Complexd*, %Complexd*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd*, %Complexd** %arg_p_0
%arg_p_1 = getelementptr {%Complexd*, %Complexd*, %Complexd*, i64}, {%Complexd*, %Complexd*, %Complexd*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexd*, %Complexd** %arg_p_1
%arg_p_2 = getelementptr {%Complexd*, %Complexd*, %Complexd*, i64}, {%Complexd*, %Complexd*, %Complexd*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load %Complexd*, %Complexd** %arg_p_2
%arg_p_3 = getelementptr {%Complexd*, %Complexd*, %Complexd*, i64}, {%Complexd*, %Complexd*, %Complexd*, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, %Complexd* %arg_1, %Complexd* %arg_2, i64 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath314 = hidden constant [61 x i8] c"xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ\00"
define dllexport fastcc %Complexd @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ__7625(i8* %_impz,i8* %_impenv, %Complexd %a, %Complexd %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7626 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}*
%xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr_ = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}* %impenv, i32 0, i32 0
%xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**** %xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr_

; setup arguments
%aPtr = alloca %Complexd
store %Complexd %a, %Complexd* %aPtr
%bPtr = alloca %Complexd
store %Complexd %b, %Complexd* %bPtr


%val7627 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7628 = extractvalue %Complexd %val7627, 0
%val7629 = load %Complexd, %Complexd* %bPtr
; tuple ref
%val7630 = extractvalue %Complexd %val7629, 0
%val7631 = fsub double %val7628, %val7630
%val7632 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7633 = extractvalue %Complexd %val7632, 1
%val7634 = load %Complexd, %Complexd* %bPtr
; tuple ref
%val7635 = extractvalue %Complexd %val7634, 1
%val7636 = fsub double %val7633, %val7635
%res7637 = call fastcc %Complexd @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd(double %val7631, double %val7636)
ret %Complexd %res7637
}
define dllexport ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7657 = load i8*, i8** %_impzPtr
%zone7658 = bitcast i8* %tzone7657 to %mzone*

; let assign value to symbol xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ
%dat_xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ = call i8* @llvm_zone_malloc(%mzone* %zone7658, i64 8)
%xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr = bitcast i8* %dat_xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***
%tzone7638 = load i8*, i8** %_impzPtr
%zone7639 = bitcast i8* %tzone7638 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7639)
; malloc closure structure
%clsptr7640 = call i8* @llvm_zone_malloc(%mzone* %zone7639, i64 24)
%closure7641 = bitcast i8* %clsptr7640 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*

; malloc environment structure
%envptr7642 = call i8* @llvm_zone_malloc(%mzone* %zone7639, i64 8)
%environment7643 = bitcast i8* %envptr7642 to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}*

; malloc closure address table
%addytable7644 = call %clsvar* @new_address_table()
%var7645 = bitcast [61 x i8]* @gsxtmmath314 to i8*
%var7646 = bitcast [58 x i8]* @gsxtmmath304 to i8*
%addytable7647 = call %clsvar* @add_address_table(%mzone* %zone7639, i8* %var7645, i32 0, i8* %var7646, i32 3, %clsvar* %addytable7644)
%address-table7648 = bitcast %clsvar* %addytable7647 to i8*

; insert table, function and environment into closure struct
%closure.table7651 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure7641, i32 0, i32 0
store i8* %address-table7648, i8** %closure.table7651
%closure.env7652 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure7641, i32 0, i32 1
store i8* %envptr7642, i8** %closure.env7652
%closure.func7653 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure7641, i32 0, i32 2
store %Complexd (i8*, i8*, %Complexd, %Complexd)* @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ__7625, %Complexd (i8*, i8*, %Complexd, %Complexd)** %closure.func7653
%closure_size7654 = call i64 @llvm_zone_mark_size(%mzone* %zone7639)
call void @llvm_zone_ptr_set_size(i8* %clsptr7640, i64 %closure_size7654)
%wrapper_ptr7655 = call i8* @llvm_zone_malloc(%mzone* %zone7639, i64 8)
%closure_wrapper7656 = bitcast i8* %wrapper_ptr7655 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure7641, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_wrapper7656

; let value assignment
%xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ = select i1 true, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_wrapper7656, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_wrapper7656
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*** %xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr

; add data to environment
; don't need to alloc for env var xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ
%tmp_envptr7650 = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}* %environment7643, i32 0, i32 0
store {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*** %xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**** %tmp_envptr7650


%val7659 = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*** %xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr
ret {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %val7659
}


@xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ(%Complexd %arg_0,%Complexd %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, %Complexd)*,  %Complexd (i8*, i8*, %Complexd, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, %Complexd %arg_1)
ret %Complexd %result
}


define dllexport ccc %Complexd @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_native(%Complexd %arg_0,%Complexd %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, %Complexd)*,  %Complexd (i8*, i8*, %Complexd, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, %Complexd %arg_1)
ret %Complexd %result
}


define dllexport ccc void @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd, %Complexd}*
%arg_p_0 = getelementptr {%Complexd, %Complexd}, {%Complexd, %Complexd}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd, %Complexd* %arg_p_0
%arg_p_1 = getelementptr {%Complexd, %Complexd}, {%Complexd, %Complexd}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexd, %Complexd* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, %Complexd)*,  %Complexd (i8*, i8*, %Complexd, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, %Complexd %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath315 = hidden constant [58 x i8] c"xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0\00"
define dllexport fastcc %Complexd @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0__7660(i8* %_impz,i8* %_impenv, %Complexd %a, double %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7661 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}*
%xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr_ = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}* %impenv, i32 0, i32 0
%xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**** %xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr_

; setup arguments
%aPtr = alloca %Complexd
store %Complexd %a, %Complexd* %aPtr
%bPtr = alloca double
store double %b, double* %bPtr


%val7662 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7663 = extractvalue %Complexd %val7662, 0
%val7664 = load double, double* %bPtr
%val7665 = fsub double %val7663, %val7664
%val7666 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7667 = extractvalue %Complexd %val7666, 1
%res7668 = call fastcc %Complexd @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd(double %val7665, double %val7667)
ret %Complexd %res7668
}
@gsxtmmath316 = hidden constant [111 x i8] c"xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7688 = load i8*, i8** %_impzPtr
%zone7689 = bitcast i8* %tzone7688 to %mzone*

; let assign value to symbol xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0
%dat_xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0 = call i8* @llvm_zone_malloc(%mzone* %zone7689, i64 8)
%xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr = bitcast i8* %dat_xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***
%tzone7669 = load i8*, i8** %_impzPtr
%zone7670 = bitcast i8* %tzone7669 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7670)
; malloc closure structure
%clsptr7671 = call i8* @llvm_zone_malloc(%mzone* %zone7670, i64 24)
%closure7672 = bitcast i8* %clsptr7671 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*

; malloc environment structure
%envptr7673 = call i8* @llvm_zone_malloc(%mzone* %zone7670, i64 8)
%environment7674 = bitcast i8* %envptr7673 to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}*

; malloc closure address table
%addytable7675 = call %clsvar* @new_address_table()
%var7676 = bitcast [58 x i8]* @gsxtmmath315 to i8*
%var7677 = bitcast [55 x i8]* @gsxtmmath306 to i8*
%addytable7678 = call %clsvar* @add_address_table(%mzone* %zone7670, i8* %var7676, i32 0, i8* %var7677, i32 3, %clsvar* %addytable7675)
%address-table7679 = bitcast %clsvar* %addytable7678 to i8*

; insert table, function and environment into closure struct
%closure.table7682 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure7672, i32 0, i32 0
store i8* %address-table7679, i8** %closure.table7682
%closure.env7683 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure7672, i32 0, i32 1
store i8* %envptr7673, i8** %closure.env7683
%closure.func7684 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure7672, i32 0, i32 2
store %Complexd (i8*, i8*, %Complexd, double)* @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0__7660, %Complexd (i8*, i8*, %Complexd, double)** %closure.func7684
%closure_size7685 = call i64 @llvm_zone_mark_size(%mzone* %zone7670)
call void @llvm_zone_ptr_set_size(i8* %clsptr7671, i64 %closure_size7685)
%wrapper_ptr7686 = call i8* @llvm_zone_malloc(%mzone* %zone7670, i64 8)
%closure_wrapper7687 = bitcast i8* %wrapper_ptr7686 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure7672, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_wrapper7687

; let value assignment
%xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0 = select i1 true, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_wrapper7687, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_wrapper7687
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*** %xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr

; add data to environment
; don't need to alloc for env var xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0
%tmp_envptr7681 = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}* %environment7674, i32 0, i32 0
store {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*** %xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**** %tmp_envptr7681


%val7690 = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*** %xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr
ret {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %val7690
}


@xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0(%Complexd %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, double)*,  %Complexd (i8*, i8*, %Complexd, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, double %arg_1)
ret %Complexd %result
}


define dllexport ccc %Complexd @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_native(%Complexd %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, double)*,  %Complexd (i8*, i8*, %Complexd, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, double %arg_1)
ret %Complexd %result
}


define dllexport ccc void @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd, double}*
%arg_p_0 = getelementptr {%Complexd, double}, {%Complexd, double}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd, %Complexd* %arg_p_0
%arg_p_1 = getelementptr {%Complexd, double}, {%Complexd, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, double)*,  %Complexd (i8*, i8*, %Complexd, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, double %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath317 = hidden constant [58 x i8] c"xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0\00"
define dllexport fastcc %Complexd @xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0__7692(i8* %_impz,i8* %_impenv, double %b, %Complexd %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7693 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}*
%xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr_ = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}* %impenv, i32 0, i32 0
%xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr = load {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**** %xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr_

; setup arguments
%bPtr = alloca double
store double %b, double* %bPtr
%aPtr = alloca %Complexd
store %Complexd %a, %Complexd* %aPtr


%val7694 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7695 = extractvalue %Complexd %val7694, 0
%val7696 = load double, double* %bPtr
%val7697 = fsub double %val7695, %val7696
%val7698 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7699 = extractvalue %Complexd %val7698, 1
%res7700 = call fastcc %Complexd @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd(double %val7697, double %val7699)
ret %Complexd %res7700
}
@gsxtmmath318 = hidden constant [111 x i8] c"xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** @xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7720 = load i8*, i8** %_impzPtr
%zone7721 = bitcast i8* %tzone7720 to %mzone*

; let assign value to symbol xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0
%dat_xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0 = call i8* @llvm_zone_malloc(%mzone* %zone7721, i64 8)
%xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr = bitcast i8* %dat_xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0 to { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***
%tzone7701 = load i8*, i8** %_impzPtr
%zone7702 = bitcast i8* %tzone7701 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7702)
; malloc closure structure
%clsptr7703 = call i8* @llvm_zone_malloc(%mzone* %zone7702, i64 24)
%closure7704 = bitcast i8* %clsptr7703 to { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*

; malloc environment structure
%envptr7705 = call i8* @llvm_zone_malloc(%mzone* %zone7702, i64 8)
%environment7706 = bitcast i8* %envptr7705 to {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}*

; malloc closure address table
%addytable7707 = call %clsvar* @new_address_table()
%var7708 = bitcast [58 x i8]* @gsxtmmath317 to i8*
%var7709 = bitcast [55 x i8]* @gsxtmmath309 to i8*
%addytable7710 = call %clsvar* @add_address_table(%mzone* %zone7702, i8* %var7708, i32 0, i8* %var7709, i32 3, %clsvar* %addytable7707)
%address-table7711 = bitcast %clsvar* %addytable7710 to i8*

; insert table, function and environment into closure struct
%closure.table7714 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure7704, i32 0, i32 0
store i8* %address-table7711, i8** %closure.table7714
%closure.env7715 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure7704, i32 0, i32 1
store i8* %envptr7705, i8** %closure.env7715
%closure.func7716 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure7704, i32 0, i32 2
store %Complexd (i8*, i8*, double, %Complexd)* @xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0__7692, %Complexd (i8*, i8*, double, %Complexd)** %closure.func7716
%closure_size7717 = call i64 @llvm_zone_mark_size(%mzone* %zone7702)
call void @llvm_zone_ptr_set_size(i8* %clsptr7703, i64 %closure_size7717)
%wrapper_ptr7718 = call i8* @llvm_zone_malloc(%mzone* %zone7702, i64 8)
%closure_wrapper7719 = bitcast i8* %wrapper_ptr7718 to { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**
store { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure7704, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_wrapper7719

; let value assignment
%xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0 = select i1 true, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_wrapper7719, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_wrapper7719
store { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*** %xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr

; add data to environment
; don't need to alloc for env var xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0
%tmp_envptr7713 = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}* %environment7706, i32 0, i32 0
store {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*** %xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**** %tmp_envptr7713


%val7722 = load {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*** %xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr
ret {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %val7722
}


@xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** @xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd @xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0(double %arg_0,%Complexd %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, double, %Complexd)*,  %Complexd (i8*, i8*, double, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, double %arg_0, %Complexd %arg_1)
ret %Complexd %result
}


define dllexport ccc %Complexd @xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_native(double %arg_0,%Complexd %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, double, %Complexd)*,  %Complexd (i8*, i8*, double, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, double %arg_0, %Complexd %arg_1)
ret %Complexd %result
}


define dllexport ccc void @xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double, %Complexd}*
%arg_p_0 = getelementptr {double, %Complexd}, {double, %Complexd}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
%arg_p_1 = getelementptr {double, %Complexd}, {double, %Complexd}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexd, %Complexd* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, double, %Complexd)*,  %Complexd (i8*, i8*, double, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, double %arg_0, %Complexd %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath319 = hidden constant [87 x i8] c"Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ\00"
define dllexport fastcc void @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ__7724(i8* %_impz,i8* %_impenv, %Complexd* %a, %Complexd* %b, %Complexd* %c, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7725 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}*
%Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}* %impenv, i32 0, i32 0
%Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**** %Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr_

; setup arguments
%aPtr = alloca %Complexd*
store %Complexd* %a, %Complexd** %aPtr
%bPtr = alloca %Complexd*
store %Complexd* %b, %Complexd** %bPtr
%cPtr = alloca %Complexd*
store %Complexd* %c, %Complexd** %cPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone7726 = load i8*, i8** %_impzPtr
%zone7727 = bitcast i8* %tzone7726 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val7730 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val7761 = load i64, i64* %iPtr
%num7762 = add i64 %val7730, %val7761
%comp7763 = icmp ult i64 %val7730, 1
br i1 %comp7763, label %after7728, label %loop7728

loop7728:
%val7731 = load i64, i64* %iPtr
%val7732 = load %Complexd*, %Complexd** %cPtr
; pointer ref
%val7733 = getelementptr %Complexd, %Complexd* %val7732, i64 %val7731
%val7734 = load i64, i64* %iPtr
%val7735 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val7736 = getelementptr %Complexd, %Complexd* %val7735, i64 %val7734
; tuple ref
%val7737 = getelementptr %Complexd, %Complexd* %val7736, i64 0, i32 0
%val7738 = load double, double* %val7737
%val7739 = load i64, i64* %iPtr
%val7740 = load %Complexd*, %Complexd** %bPtr
; pointer ref
%val7741 = getelementptr %Complexd, %Complexd* %val7740, i64 %val7739
; tuple ref
%val7742 = getelementptr %Complexd, %Complexd* %val7741, i64 0, i32 0
%val7743 = load double, double* %val7742
%val7744 = fsub double %val7738, %val7743
; set tuple
%val7745 = getelementptr %Complexd, %Complexd* %val7733, i64 0, i32 0
store double %val7744, double* %val7745
%val7746 = load i64, i64* %iPtr
%val7747 = load %Complexd*, %Complexd** %cPtr
; pointer ref
%val7748 = getelementptr %Complexd, %Complexd* %val7747, i64 %val7746
%val7749 = load i64, i64* %iPtr
%val7750 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val7751 = getelementptr %Complexd, %Complexd* %val7750, i64 %val7749
; tuple ref
%val7752 = getelementptr %Complexd, %Complexd* %val7751, i64 0, i32 1
%val7753 = load double, double* %val7752
%val7754 = load i64, i64* %iPtr
%val7755 = load %Complexd*, %Complexd** %bPtr
; pointer ref
%val7756 = getelementptr %Complexd, %Complexd* %val7755, i64 %val7754
; tuple ref
%val7757 = getelementptr %Complexd, %Complexd* %val7756, i64 0, i32 1
%val7758 = load double, double* %val7757
%val7759 = fsub double %val7753, %val7758
; set tuple
%val7760 = getelementptr %Complexd, %Complexd* %val7748, i64 0, i32 1
store double %val7759, double* %val7760
%loop_cnt7728 = load i64, i64* %iPtr
%next7728 = add i64 %loop_cnt7728, 1
store i64 %next7728, i64* %iPtr
%cmp7728 = icmp ult i64 %next7728, %num7762
br i1 %cmp7728, label %loop7728, label %after7728

after7728:
ret void
}
@gsxtmmath320 = hidden constant [140 x i8] c"Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7785 = load i8*, i8** %_impzPtr
%zone7786 = bitcast i8* %tzone7785 to %mzone*

; let assign value to symbol Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ
%dat_Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone7786, i64 8)
%Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr = bitcast i8* %dat_Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ to { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***
%tzone7766 = load i8*, i8** %_impzPtr
%zone7767 = bitcast i8* %tzone7766 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7767)
; malloc closure structure
%clsptr7768 = call i8* @llvm_zone_malloc(%mzone* %zone7767, i64 24)
%closure7769 = bitcast i8* %clsptr7768 to { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*

; malloc environment structure
%envptr7770 = call i8* @llvm_zone_malloc(%mzone* %zone7767, i64 8)
%environment7771 = bitcast i8* %envptr7770 to {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}*

; malloc closure address table
%addytable7772 = call %clsvar* @new_address_table()
%var7773 = bitcast [87 x i8]* @gsxtmmath319 to i8*
%var7774 = bitcast [72 x i8]* @gsxtmmath312 to i8*
%addytable7775 = call %clsvar* @add_address_table(%mzone* %zone7767, i8* %var7773, i32 0, i8* %var7774, i32 3, %clsvar* %addytable7772)
%address-table7776 = bitcast %clsvar* %addytable7775 to i8*

; insert table, function and environment into closure struct
%closure.table7779 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure7769, i32 0, i32 0
store i8* %address-table7776, i8** %closure.table7779
%closure.env7780 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure7769, i32 0, i32 1
store i8* %envptr7770, i8** %closure.env7780
%closure.func7781 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure7769, i32 0, i32 2
store void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)* @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ__7724, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)** %closure.func7781
%closure_size7782 = call i64 @llvm_zone_mark_size(%mzone* %zone7767)
call void @llvm_zone_ptr_set_size(i8* %clsptr7768, i64 %closure_size7782)
%wrapper_ptr7783 = call i8* @llvm_zone_malloc(%mzone* %zone7767, i64 8)
%closure_wrapper7784 = bitcast i8* %wrapper_ptr7783 to { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**
store { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure7769, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_wrapper7784

; let value assignment
%Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_wrapper7784, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_wrapper7784
store { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*** %Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr

; add data to environment
; don't need to alloc for env var Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ
%tmp_envptr7778 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}* %environment7771, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*** %Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**** %tmp_envptr7778


%val7787 = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*** %Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %val7787
}


@Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ(%Complexd* %arg_0,%Complexd* %arg_1,%Complexd* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, %Complexd* %arg_1, %Complexd* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc void @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_native(%Complexd* %arg_0,%Complexd* %arg_1,%Complexd* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, %Complexd* %arg_1, %Complexd* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc i8*  @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7788 = bitcast [140 x i8]* @gsxtmmath320 to i8*
call i32 (i8*, ...) @printf(i8* %var7788)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexd*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var7789 = bitcast [140 x i8]* @gsxtmmath320 to i8*
call i32 (i8*, ...) @printf(i8* %var7789)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Complexd*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var7790 = bitcast [140 x i8]* @gsxtmmath320 to i8*
call i32 (i8*, ...) @printf(i8* %var7790)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Complexd*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var7791 = bitcast [140 x i8]* @gsxtmmath320 to i8*
call i32 (i8*, ...) @printf(i8* %var7791)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, %Complexd* %arg_1, %Complexd* %arg_2, i64 %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd*, %Complexd*, %Complexd*, i64}*
%arg_p_0 = getelementptr {%Complexd*, %Complexd*, %Complexd*, i64}, {%Complexd*, %Complexd*, %Complexd*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd*, %Complexd** %arg_p_0
%arg_p_1 = getelementptr {%Complexd*, %Complexd*, %Complexd*, i64}, {%Complexd*, %Complexd*, %Complexd*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexd*, %Complexd** %arg_p_1
%arg_p_2 = getelementptr {%Complexd*, %Complexd*, %Complexd*, i64}, {%Complexd*, %Complexd*, %Complexd*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load %Complexd*, %Complexd** %arg_p_2
%arg_p_3 = getelementptr {%Complexd*, %Complexd*, %Complexd*, i64}, {%Complexd*, %Complexd*, %Complexd*, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, %Complexd* %arg_1, %Complexd* %arg_2, i64 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath321 = hidden constant [64 x i8] c"xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ\00"
define dllexport fastcc %Complexd @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ__7792(i8* %_impz,i8* %_impenv, %Complexd %a, %Complexd %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7793 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}*
%xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr_ = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}* %impenv, i32 0, i32 0
%xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**** %xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr_

; setup arguments
%aPtr = alloca %Complexd
store %Complexd %a, %Complexd* %aPtr
%bPtr = alloca %Complexd
store %Complexd %b, %Complexd* %bPtr


%val7794 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7795 = extractvalue %Complexd %val7794, 0
%val7796 = load %Complexd, %Complexd* %bPtr
; tuple ref
%val7797 = extractvalue %Complexd %val7796, 0
%val7798 = fmul double %val7795, %val7797
%val7799 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7800 = extractvalue %Complexd %val7799, 1
%val7801 = load %Complexd, %Complexd* %bPtr
; tuple ref
%val7802 = extractvalue %Complexd %val7801, 1
%val7803 = fmul double %val7800, %val7802
%val7804 = fsub double %val7798, %val7803
%val7805 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7806 = extractvalue %Complexd %val7805, 0
%val7807 = load %Complexd, %Complexd* %bPtr
; tuple ref
%val7808 = extractvalue %Complexd %val7807, 1
%val7809 = fmul double %val7806, %val7808
%val7810 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7811 = extractvalue %Complexd %val7810, 1
%val7812 = load %Complexd, %Complexd* %bPtr
; tuple ref
%val7813 = extractvalue %Complexd %val7812, 0
%val7814 = fmul double %val7811, %val7813
%val7815 = fadd double %val7809, %val7814
%res7816 = call fastcc %Complexd @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd(double %val7804, double %val7815)
ret %Complexd %res7816
}
define dllexport ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7836 = load i8*, i8** %_impzPtr
%zone7837 = bitcast i8* %tzone7836 to %mzone*

; let assign value to symbol xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ
%dat_xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ = call i8* @llvm_zone_malloc(%mzone* %zone7837, i64 8)
%xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr = bitcast i8* %dat_xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***
%tzone7817 = load i8*, i8** %_impzPtr
%zone7818 = bitcast i8* %tzone7817 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7818)
; malloc closure structure
%clsptr7819 = call i8* @llvm_zone_malloc(%mzone* %zone7818, i64 24)
%closure7820 = bitcast i8* %clsptr7819 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*

; malloc environment structure
%envptr7821 = call i8* @llvm_zone_malloc(%mzone* %zone7818, i64 8)
%environment7822 = bitcast i8* %envptr7821 to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}*

; malloc closure address table
%addytable7823 = call %clsvar* @new_address_table()
%var7824 = bitcast [64 x i8]* @gsxtmmath321 to i8*
%var7825 = bitcast [58 x i8]* @gsxtmmath304 to i8*
%addytable7826 = call %clsvar* @add_address_table(%mzone* %zone7818, i8* %var7824, i32 0, i8* %var7825, i32 3, %clsvar* %addytable7823)
%address-table7827 = bitcast %clsvar* %addytable7826 to i8*

; insert table, function and environment into closure struct
%closure.table7830 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure7820, i32 0, i32 0
store i8* %address-table7827, i8** %closure.table7830
%closure.env7831 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure7820, i32 0, i32 1
store i8* %envptr7821, i8** %closure.env7831
%closure.func7832 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure7820, i32 0, i32 2
store %Complexd (i8*, i8*, %Complexd, %Complexd)* @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ__7792, %Complexd (i8*, i8*, %Complexd, %Complexd)** %closure.func7832
%closure_size7833 = call i64 @llvm_zone_mark_size(%mzone* %zone7818)
call void @llvm_zone_ptr_set_size(i8* %clsptr7819, i64 %closure_size7833)
%wrapper_ptr7834 = call i8* @llvm_zone_malloc(%mzone* %zone7818, i64 8)
%closure_wrapper7835 = bitcast i8* %wrapper_ptr7834 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure7820, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_wrapper7835

; let value assignment
%xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ = select i1 true, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_wrapper7835, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_wrapper7835
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*** %xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr

; add data to environment
; don't need to alloc for env var xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ
%tmp_envptr7829 = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}* %environment7822, i32 0, i32 0
store {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*** %xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**** %tmp_envptr7829


%val7838 = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*** %xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr
ret {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %val7838
}


@xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ(%Complexd %arg_0,%Complexd %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, %Complexd)*,  %Complexd (i8*, i8*, %Complexd, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, %Complexd %arg_1)
ret %Complexd %result
}


define dllexport ccc %Complexd @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_native(%Complexd %arg_0,%Complexd %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, %Complexd)*,  %Complexd (i8*, i8*, %Complexd, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, %Complexd %arg_1)
ret %Complexd %result
}


define dllexport ccc void @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd, %Complexd}*
%arg_p_0 = getelementptr {%Complexd, %Complexd}, {%Complexd, %Complexd}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd, %Complexd* %arg_p_0
%arg_p_1 = getelementptr {%Complexd, %Complexd}, {%Complexd, %Complexd}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexd, %Complexd* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, %Complexd)*,  %Complexd (i8*, i8*, %Complexd, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, %Complexd %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath322 = hidden constant [61 x i8] c"xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0\00"
define dllexport fastcc %Complexd @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0__7839(i8* %_impz,i8* %_impenv, %Complexd %a, double %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7840 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}*
%xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr_ = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}* %impenv, i32 0, i32 0
%xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**** %xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr_

; setup arguments
%aPtr = alloca %Complexd
store %Complexd %a, %Complexd* %aPtr
%bPtr = alloca double
store double %b, double* %bPtr


%val7841 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7842 = extractvalue %Complexd %val7841, 0
%val7843 = load double, double* %bPtr
%val7844 = fmul double %val7842, %val7843
%val7845 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7846 = extractvalue %Complexd %val7845, 1
%val7847 = fsub double %val7844, %val7846
%val7848 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7849 = extractvalue %Complexd %val7848, 0
%val7850 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7851 = extractvalue %Complexd %val7850, 1
%val7852 = load double, double* %bPtr
%val7853 = fmul double %val7851, %val7852
%val7854 = fadd double %val7849, %val7853
%res7855 = call fastcc %Complexd @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd(double %val7847, double %val7854)
ret %Complexd %res7855
}
@gsxtmmath323 = hidden constant [114 x i8] c"xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7875 = load i8*, i8** %_impzPtr
%zone7876 = bitcast i8* %tzone7875 to %mzone*

; let assign value to symbol xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0
%dat_xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0 = call i8* @llvm_zone_malloc(%mzone* %zone7876, i64 8)
%xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr = bitcast i8* %dat_xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***
%tzone7856 = load i8*, i8** %_impzPtr
%zone7857 = bitcast i8* %tzone7856 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7857)
; malloc closure structure
%clsptr7858 = call i8* @llvm_zone_malloc(%mzone* %zone7857, i64 24)
%closure7859 = bitcast i8* %clsptr7858 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*

; malloc environment structure
%envptr7860 = call i8* @llvm_zone_malloc(%mzone* %zone7857, i64 8)
%environment7861 = bitcast i8* %envptr7860 to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}*

; malloc closure address table
%addytable7862 = call %clsvar* @new_address_table()
%var7863 = bitcast [61 x i8]* @gsxtmmath322 to i8*
%var7864 = bitcast [55 x i8]* @gsxtmmath306 to i8*
%addytable7865 = call %clsvar* @add_address_table(%mzone* %zone7857, i8* %var7863, i32 0, i8* %var7864, i32 3, %clsvar* %addytable7862)
%address-table7866 = bitcast %clsvar* %addytable7865 to i8*

; insert table, function and environment into closure struct
%closure.table7869 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure7859, i32 0, i32 0
store i8* %address-table7866, i8** %closure.table7869
%closure.env7870 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure7859, i32 0, i32 1
store i8* %envptr7860, i8** %closure.env7870
%closure.func7871 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure7859, i32 0, i32 2
store %Complexd (i8*, i8*, %Complexd, double)* @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0__7839, %Complexd (i8*, i8*, %Complexd, double)** %closure.func7871
%closure_size7872 = call i64 @llvm_zone_mark_size(%mzone* %zone7857)
call void @llvm_zone_ptr_set_size(i8* %clsptr7858, i64 %closure_size7872)
%wrapper_ptr7873 = call i8* @llvm_zone_malloc(%mzone* %zone7857, i64 8)
%closure_wrapper7874 = bitcast i8* %wrapper_ptr7873 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure7859, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_wrapper7874

; let value assignment
%xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0 = select i1 true, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_wrapper7874, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_wrapper7874
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*** %xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr

; add data to environment
; don't need to alloc for env var xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0
%tmp_envptr7868 = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}* %environment7861, i32 0, i32 0
store {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*** %xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**** %tmp_envptr7868


%val7877 = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*** %xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr
ret {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %val7877
}


@xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0(%Complexd %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, double)*,  %Complexd (i8*, i8*, %Complexd, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, double %arg_1)
ret %Complexd %result
}


define dllexport ccc %Complexd @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_native(%Complexd %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, double)*,  %Complexd (i8*, i8*, %Complexd, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, double %arg_1)
ret %Complexd %result
}


define dllexport ccc void @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd, double}*
%arg_p_0 = getelementptr {%Complexd, double}, {%Complexd, double}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd, %Complexd* %arg_p_0
%arg_p_1 = getelementptr {%Complexd, double}, {%Complexd, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, double)*,  %Complexd (i8*, i8*, %Complexd, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, double %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath324 = hidden constant [61 x i8] c"xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0\00"
define dllexport fastcc %Complexd @xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0__7879(i8* %_impz,i8* %_impenv, double %b, %Complexd %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7880 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}*
%xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr_ = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}* %impenv, i32 0, i32 0
%xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr = load {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**** %xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr_

; setup arguments
%bPtr = alloca double
store double %b, double* %bPtr
%aPtr = alloca %Complexd
store %Complexd %a, %Complexd* %aPtr


%val7881 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7882 = extractvalue %Complexd %val7881, 0
%val7883 = load double, double* %bPtr
%val7884 = fmul double %val7882, %val7883
%val7885 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7886 = extractvalue %Complexd %val7885, 1
%val7887 = fsub double %val7884, %val7886
%val7888 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7889 = extractvalue %Complexd %val7888, 0
%val7890 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val7891 = extractvalue %Complexd %val7890, 1
%val7892 = load double, double* %bPtr
%val7893 = fmul double %val7891, %val7892
%val7894 = fadd double %val7889, %val7893
%res7895 = call fastcc %Complexd @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd(double %val7887, double %val7894)
ret %Complexd %res7895
}
@gsxtmmath325 = hidden constant [114 x i8] c"xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** @xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7915 = load i8*, i8** %_impzPtr
%zone7916 = bitcast i8* %tzone7915 to %mzone*

; let assign value to symbol xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0
%dat_xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0 = call i8* @llvm_zone_malloc(%mzone* %zone7916, i64 8)
%xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr = bitcast i8* %dat_xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0 to { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***
%tzone7896 = load i8*, i8** %_impzPtr
%zone7897 = bitcast i8* %tzone7896 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7897)
; malloc closure structure
%clsptr7898 = call i8* @llvm_zone_malloc(%mzone* %zone7897, i64 24)
%closure7899 = bitcast i8* %clsptr7898 to { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*

; malloc environment structure
%envptr7900 = call i8* @llvm_zone_malloc(%mzone* %zone7897, i64 8)
%environment7901 = bitcast i8* %envptr7900 to {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}*

; malloc closure address table
%addytable7902 = call %clsvar* @new_address_table()
%var7903 = bitcast [61 x i8]* @gsxtmmath324 to i8*
%var7904 = bitcast [55 x i8]* @gsxtmmath309 to i8*
%addytable7905 = call %clsvar* @add_address_table(%mzone* %zone7897, i8* %var7903, i32 0, i8* %var7904, i32 3, %clsvar* %addytable7902)
%address-table7906 = bitcast %clsvar* %addytable7905 to i8*

; insert table, function and environment into closure struct
%closure.table7909 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure7899, i32 0, i32 0
store i8* %address-table7906, i8** %closure.table7909
%closure.env7910 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure7899, i32 0, i32 1
store i8* %envptr7900, i8** %closure.env7910
%closure.func7911 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure7899, i32 0, i32 2
store %Complexd (i8*, i8*, double, %Complexd)* @xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0__7879, %Complexd (i8*, i8*, double, %Complexd)** %closure.func7911
%closure_size7912 = call i64 @llvm_zone_mark_size(%mzone* %zone7897)
call void @llvm_zone_ptr_set_size(i8* %clsptr7898, i64 %closure_size7912)
%wrapper_ptr7913 = call i8* @llvm_zone_malloc(%mzone* %zone7897, i64 8)
%closure_wrapper7914 = bitcast i8* %wrapper_ptr7913 to { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**
store { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure7899, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_wrapper7914

; let value assignment
%xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0 = select i1 true, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_wrapper7914, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_wrapper7914
store { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*** %xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr

; add data to environment
; don't need to alloc for env var xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0
%tmp_envptr7908 = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}* %environment7901, i32 0, i32 0
store {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*** %xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**** %tmp_envptr7908


%val7917 = load {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*** %xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr
ret {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %val7917
}


@xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** @xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd @xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0(double %arg_0,%Complexd %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, double, %Complexd)*,  %Complexd (i8*, i8*, double, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, double %arg_0, %Complexd %arg_1)
ret %Complexd %result
}


define dllexport ccc %Complexd @xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_native(double %arg_0,%Complexd %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, double, %Complexd)*,  %Complexd (i8*, i8*, double, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, double %arg_0, %Complexd %arg_1)
ret %Complexd %result
}


define dllexport ccc void @xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double, %Complexd}*
%arg_p_0 = getelementptr {double, %Complexd}, {double, %Complexd}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
%arg_p_1 = getelementptr {double, %Complexd}, {double, %Complexd}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexd, %Complexd* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, double, %Complexd)*,  %Complexd (i8*, i8*, double, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, double %arg_0, %Complexd %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath326 = hidden constant [90 x i8] c"Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ\00"
define dllexport fastcc void @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ__7919(i8* %_impz,i8* %_impenv, %Complexd* %a, %Complexd* %b, %Complexd* %c, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7920 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}*
%Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}* %impenv, i32 0, i32 0
%Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**** %Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr_

; setup arguments
%aPtr = alloca %Complexd*
store %Complexd* %a, %Complexd** %aPtr
%bPtr = alloca %Complexd*
store %Complexd* %b, %Complexd** %bPtr
%cPtr = alloca %Complexd*
store %Complexd* %c, %Complexd** %cPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone7921 = load i8*, i8** %_impzPtr
%zone7922 = bitcast i8* %tzone7921 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val7925 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val7980 = load i64, i64* %iPtr
%num7981 = add i64 %val7925, %val7980
%comp7982 = icmp ult i64 %val7925, 1
br i1 %comp7982, label %after7923, label %loop7923

loop7923:
%val7926 = load i64, i64* %iPtr
%val7927 = load %Complexd*, %Complexd** %cPtr
; pointer ref
%val7928 = getelementptr %Complexd, %Complexd* %val7927, i64 %val7926
%val7929 = load i64, i64* %iPtr
%val7930 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val7931 = getelementptr %Complexd, %Complexd* %val7930, i64 %val7929
; tuple ref
%val7932 = getelementptr %Complexd, %Complexd* %val7931, i64 0, i32 0
%val7933 = load double, double* %val7932
%val7934 = load i64, i64* %iPtr
%val7935 = load %Complexd*, %Complexd** %bPtr
; pointer ref
%val7936 = getelementptr %Complexd, %Complexd* %val7935, i64 %val7934
; tuple ref
%val7937 = getelementptr %Complexd, %Complexd* %val7936, i64 0, i32 0
%val7938 = load double, double* %val7937
%val7939 = fmul double %val7933, %val7938
%val7940 = load i64, i64* %iPtr
%val7941 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val7942 = getelementptr %Complexd, %Complexd* %val7941, i64 %val7940
; tuple ref
%val7943 = getelementptr %Complexd, %Complexd* %val7942, i64 0, i32 1
%val7944 = load double, double* %val7943
%val7945 = load i64, i64* %iPtr
%val7946 = load %Complexd*, %Complexd** %bPtr
; pointer ref
%val7947 = getelementptr %Complexd, %Complexd* %val7946, i64 %val7945
; tuple ref
%val7948 = getelementptr %Complexd, %Complexd* %val7947, i64 0, i32 1
%val7949 = load double, double* %val7948
%val7950 = fmul double %val7944, %val7949
%val7951 = fsub double %val7939, %val7950
; set tuple
%val7952 = getelementptr %Complexd, %Complexd* %val7928, i64 0, i32 0
store double %val7951, double* %val7952
%val7953 = load i64, i64* %iPtr
%val7954 = load %Complexd*, %Complexd** %cPtr
; pointer ref
%val7955 = getelementptr %Complexd, %Complexd* %val7954, i64 %val7953
%val7956 = load i64, i64* %iPtr
%val7957 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val7958 = getelementptr %Complexd, %Complexd* %val7957, i64 %val7956
; tuple ref
%val7959 = getelementptr %Complexd, %Complexd* %val7958, i64 0, i32 0
%val7960 = load double, double* %val7959
%val7961 = load i64, i64* %iPtr
%val7962 = load %Complexd*, %Complexd** %bPtr
; pointer ref
%val7963 = getelementptr %Complexd, %Complexd* %val7962, i64 %val7961
; tuple ref
%val7964 = getelementptr %Complexd, %Complexd* %val7963, i64 0, i32 1
%val7965 = load double, double* %val7964
%val7966 = fmul double %val7960, %val7965
%val7967 = load i64, i64* %iPtr
%val7968 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val7969 = getelementptr %Complexd, %Complexd* %val7968, i64 %val7967
; tuple ref
%val7970 = getelementptr %Complexd, %Complexd* %val7969, i64 0, i32 1
%val7971 = load double, double* %val7970
%val7972 = load i64, i64* %iPtr
%val7973 = load %Complexd*, %Complexd** %bPtr
; pointer ref
%val7974 = getelementptr %Complexd, %Complexd* %val7973, i64 %val7972
; tuple ref
%val7975 = getelementptr %Complexd, %Complexd* %val7974, i64 0, i32 0
%val7976 = load double, double* %val7975
%val7977 = fmul double %val7971, %val7976
%val7978 = fadd double %val7966, %val7977
; set tuple
%val7979 = getelementptr %Complexd, %Complexd* %val7955, i64 0, i32 1
store double %val7978, double* %val7979
%loop_cnt7923 = load i64, i64* %iPtr
%next7923 = add i64 %loop_cnt7923, 1
store i64 %next7923, i64* %iPtr
%cmp7923 = icmp ult i64 %next7923, %num7981
br i1 %cmp7923, label %loop7923, label %after7923

after7923:
ret void
}
@gsxtmmath327 = hidden constant [143 x i8] c"Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8004 = load i8*, i8** %_impzPtr
%zone8005 = bitcast i8* %tzone8004 to %mzone*

; let assign value to symbol Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ
%dat_Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone8005, i64 8)
%Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr = bitcast i8* %dat_Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ to { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***
%tzone7985 = load i8*, i8** %_impzPtr
%zone7986 = bitcast i8* %tzone7985 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7986)
; malloc closure structure
%clsptr7987 = call i8* @llvm_zone_malloc(%mzone* %zone7986, i64 24)
%closure7988 = bitcast i8* %clsptr7987 to { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*

; malloc environment structure
%envptr7989 = call i8* @llvm_zone_malloc(%mzone* %zone7986, i64 8)
%environment7990 = bitcast i8* %envptr7989 to {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}*

; malloc closure address table
%addytable7991 = call %clsvar* @new_address_table()
%var7992 = bitcast [90 x i8]* @gsxtmmath326 to i8*
%var7993 = bitcast [72 x i8]* @gsxtmmath312 to i8*
%addytable7994 = call %clsvar* @add_address_table(%mzone* %zone7986, i8* %var7992, i32 0, i8* %var7993, i32 3, %clsvar* %addytable7991)
%address-table7995 = bitcast %clsvar* %addytable7994 to i8*

; insert table, function and environment into closure struct
%closure.table7998 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure7988, i32 0, i32 0
store i8* %address-table7995, i8** %closure.table7998
%closure.env7999 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure7988, i32 0, i32 1
store i8* %envptr7989, i8** %closure.env7999
%closure.func8000 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure7988, i32 0, i32 2
store void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)* @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ__7919, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)** %closure.func8000
%closure_size8001 = call i64 @llvm_zone_mark_size(%mzone* %zone7986)
call void @llvm_zone_ptr_set_size(i8* %clsptr7987, i64 %closure_size8001)
%wrapper_ptr8002 = call i8* @llvm_zone_malloc(%mzone* %zone7986, i64 8)
%closure_wrapper8003 = bitcast i8* %wrapper_ptr8002 to { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**
store { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure7988, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_wrapper8003

; let value assignment
%Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_wrapper8003, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_wrapper8003
store { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*** %Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr

; add data to environment
; don't need to alloc for env var Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ
%tmp_envptr7997 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}* %environment7990, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*** %Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**** %tmp_envptr7997


%val8006 = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*** %Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %val8006
}


@Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ(%Complexd* %arg_0,%Complexd* %arg_1,%Complexd* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, %Complexd* %arg_1, %Complexd* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc void @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_native(%Complexd* %arg_0,%Complexd* %arg_1,%Complexd* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, %Complexd* %arg_1, %Complexd* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc i8*  @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8007 = bitcast [143 x i8]* @gsxtmmath327 to i8*
call i32 (i8*, ...) @printf(i8* %var8007)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexd*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var8008 = bitcast [143 x i8]* @gsxtmmath327 to i8*
call i32 (i8*, ...) @printf(i8* %var8008)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Complexd*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var8009 = bitcast [143 x i8]* @gsxtmmath327 to i8*
call i32 (i8*, ...) @printf(i8* %var8009)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Complexd*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var8010 = bitcast [143 x i8]* @gsxtmmath327 to i8*
call i32 (i8*, ...) @printf(i8* %var8010)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, %Complexd* %arg_1, %Complexd* %arg_2, i64 %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd*, %Complexd*, %Complexd*, i64}*
%arg_p_0 = getelementptr {%Complexd*, %Complexd*, %Complexd*, i64}, {%Complexd*, %Complexd*, %Complexd*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd*, %Complexd** %arg_p_0
%arg_p_1 = getelementptr {%Complexd*, %Complexd*, %Complexd*, i64}, {%Complexd*, %Complexd*, %Complexd*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexd*, %Complexd** %arg_p_1
%arg_p_2 = getelementptr {%Complexd*, %Complexd*, %Complexd*, i64}, {%Complexd*, %Complexd*, %Complexd*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load %Complexd*, %Complexd** %arg_p_2
%arg_p_3 = getelementptr {%Complexd*, %Complexd*, %Complexd*, i64}, {%Complexd*, %Complexd*, %Complexd*, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, %Complexd* %arg_1, %Complexd* %arg_2, i64 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath328 = hidden constant [58 x i8] c"xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ\00"
define dllexport fastcc %Complexd @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ__8011(i8* %_impz,i8* %_impenv, %Complexd %a, %Complexd %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8012 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}*
%xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr_ = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}* %impenv, i32 0, i32 0
%xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**** %xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr_

; setup arguments
%aPtr = alloca %Complexd
store %Complexd %a, %Complexd* %aPtr
%bPtr = alloca %Complexd
store %Complexd %b, %Complexd* %bPtr


%tzone8024 = load i8*, i8** %_impzPtr
%zone8025 = bitcast i8* %tzone8024 to %mzone*

; let assign value to symbol i
%iPtr = alloca double
%tzone8037 = load i8*, i8** %_impzPtr
%zone8038 = bitcast i8* %tzone8037 to %mzone*

; let assign value to symbol j
%jPtr = alloca double
%tzone8050 = load i8*, i8** %_impzPtr
%zone8051 = bitcast i8* %tzone8050 to %mzone*

; let assign value to symbol k
%kPtr = alloca double
%val8013 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8014 = extractvalue %Complexd %val8013, 0
%val8015 = load %Complexd, %Complexd* %bPtr
; tuple ref
%val8016 = extractvalue %Complexd %val8015, 0
%val8017 = fmul double %val8014, %val8016
%val8018 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8019 = extractvalue %Complexd %val8018, 1
%val8020 = load %Complexd, %Complexd* %bPtr
; tuple ref
%val8021 = extractvalue %Complexd %val8020, 1
%val8022 = fmul double %val8019, %val8021
%val8023 = fadd double %val8017, %val8022

; let value assignment
%i = select i1 true, double %val8023, double %val8023
store double %i, double* %iPtr

%val8026 = load %Complexd, %Complexd* %bPtr
; tuple ref
%val8027 = extractvalue %Complexd %val8026, 0
%val8028 = load %Complexd, %Complexd* %bPtr
; tuple ref
%val8029 = extractvalue %Complexd %val8028, 0
%val8030 = fmul double %val8027, %val8029
%val8031 = load %Complexd, %Complexd* %bPtr
; tuple ref
%val8032 = extractvalue %Complexd %val8031, 1
%val8033 = load %Complexd, %Complexd* %bPtr
; tuple ref
%val8034 = extractvalue %Complexd %val8033, 1
%val8035 = fmul double %val8032, %val8034
%val8036 = fadd double %val8030, %val8035

; let value assignment
%j = select i1 true, double %val8036, double %val8036
store double %j, double* %jPtr

%val8039 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8040 = extractvalue %Complexd %val8039, 1
%val8041 = load %Complexd, %Complexd* %bPtr
; tuple ref
%val8042 = extractvalue %Complexd %val8041, 0
%val8043 = fmul double %val8040, %val8042
%val8044 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8045 = extractvalue %Complexd %val8044, 0
%val8046 = load %Complexd, %Complexd* %bPtr
; tuple ref
%val8047 = extractvalue %Complexd %val8046, 1
%val8048 = fmul double %val8045, %val8047
%val8049 = fsub double %val8043, %val8048

; let value assignment
%k = select i1 true, double %val8049, double %val8049
store double %k, double* %kPtr

%val8052 = load double, double* %iPtr
%val8053 = load double, double* %jPtr
%val8054 = fdiv double %val8052, %val8053
%val8055 = load double, double* %kPtr
%val8056 = load double, double* %jPtr
%val8057 = fdiv double %val8055, %val8056
%res8058 = call fastcc %Complexd @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd(double %val8054, double %val8057)
ret %Complexd %res8058
}
define dllexport ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8078 = load i8*, i8** %_impzPtr
%zone8079 = bitcast i8* %tzone8078 to %mzone*

; let assign value to symbol xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ
%dat_xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ = call i8* @llvm_zone_malloc(%mzone* %zone8079, i64 8)
%xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr = bitcast i8* %dat_xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***
%tzone8059 = load i8*, i8** %_impzPtr
%zone8060 = bitcast i8* %tzone8059 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8060)
; malloc closure structure
%clsptr8061 = call i8* @llvm_zone_malloc(%mzone* %zone8060, i64 24)
%closure8062 = bitcast i8* %clsptr8061 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*

; malloc environment structure
%envptr8063 = call i8* @llvm_zone_malloc(%mzone* %zone8060, i64 8)
%environment8064 = bitcast i8* %envptr8063 to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}*

; malloc closure address table
%addytable8065 = call %clsvar* @new_address_table()
%var8066 = bitcast [58 x i8]* @gsxtmmath328 to i8*
%var8067 = bitcast [58 x i8]* @gsxtmmath304 to i8*
%addytable8068 = call %clsvar* @add_address_table(%mzone* %zone8060, i8* %var8066, i32 0, i8* %var8067, i32 3, %clsvar* %addytable8065)
%address-table8069 = bitcast %clsvar* %addytable8068 to i8*

; insert table, function and environment into closure struct
%closure.table8072 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure8062, i32 0, i32 0
store i8* %address-table8069, i8** %closure.table8072
%closure.env8073 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure8062, i32 0, i32 1
store i8* %envptr8063, i8** %closure.env8073
%closure.func8074 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure8062, i32 0, i32 2
store %Complexd (i8*, i8*, %Complexd, %Complexd)* @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ__8011, %Complexd (i8*, i8*, %Complexd, %Complexd)** %closure.func8074
%closure_size8075 = call i64 @llvm_zone_mark_size(%mzone* %zone8060)
call void @llvm_zone_ptr_set_size(i8* %clsptr8061, i64 %closure_size8075)
%wrapper_ptr8076 = call i8* @llvm_zone_malloc(%mzone* %zone8060, i64 8)
%closure_wrapper8077 = bitcast i8* %wrapper_ptr8076 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure8062, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_wrapper8077

; let value assignment
%xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ = select i1 true, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_wrapper8077, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_wrapper8077
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*** %xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr

; add data to environment
; don't need to alloc for env var xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ
%tmp_envptr8071 = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}***}* %environment8064, i32 0, i32 0
store {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*** %xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**** %tmp_envptr8071


%val8080 = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*** %xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQPtr
ret {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %val8080
}


@xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ(%Complexd %arg_0,%Complexd %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, %Complexd)*,  %Complexd (i8*, i8*, %Complexd, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, %Complexd %arg_1)
ret %Complexd %result
}


define dllexport ccc %Complexd @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_native(%Complexd %arg_0,%Complexd %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, %Complexd)*,  %Complexd (i8*, i8*, %Complexd, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, %Complexd %arg_1)
ret %Complexd %result
}


define dllexport ccc void @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd, %Complexd}*
%arg_p_0 = getelementptr {%Complexd, %Complexd}, {%Complexd, %Complexd}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd, %Complexd* %arg_p_0
%arg_p_1 = getelementptr {%Complexd, %Complexd}, {%Complexd, %Complexd}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexd, %Complexd* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, %Complexd)*,  %Complexd (i8*, i8*, %Complexd, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, %Complexd %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath329 = hidden constant [55 x i8] c"xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0\00"
define dllexport fastcc %Complexd @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0__8081(i8* %_impz,i8* %_impenv, %Complexd %a, double %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8082 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}*
%xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr_ = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}* %impenv, i32 0, i32 0
%xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**** %xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr_

; setup arguments
%aPtr = alloca %Complexd
store %Complexd %a, %Complexd* %aPtr
%bPtr = alloca double
store double %b, double* %bPtr


%tzone8090 = load i8*, i8** %_impzPtr
%zone8091 = bitcast i8* %tzone8090 to %mzone*

; let assign value to symbol i
%iPtr = alloca double
%tzone8095 = load i8*, i8** %_impzPtr
%zone8096 = bitcast i8* %tzone8095 to %mzone*

; let assign value to symbol j
%jPtr = alloca double
%tzone8104 = load i8*, i8** %_impzPtr
%zone8105 = bitcast i8* %tzone8104 to %mzone*

; let assign value to symbol k
%kPtr = alloca double
%val8083 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8084 = extractvalue %Complexd %val8083, 0
%val8085 = load double, double* %bPtr
%val8086 = fmul double %val8084, %val8085
%val8087 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8088 = extractvalue %Complexd %val8087, 1
%val8089 = fadd double %val8086, %val8088

; let value assignment
%i = select i1 true, double %val8089, double %val8089
store double %i, double* %iPtr

%val8092 = load double, double* %bPtr
%val8093 = load double, double* %bPtr
%val8094 = fmul double %val8092, %val8093

; let value assignment
%j = select i1 true, double %val8094, double %val8094
store double %j, double* %jPtr

%val8097 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8098 = extractvalue %Complexd %val8097, 1
%val8099 = load double, double* %bPtr
%val8100 = fmul double %val8098, %val8099
%val8101 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8102 = extractvalue %Complexd %val8101, 0
%val8103 = fsub double %val8100, %val8102

; let value assignment
%k = select i1 true, double %val8103, double %val8103
store double %k, double* %kPtr

%val8106 = load double, double* %iPtr
%val8107 = load double, double* %jPtr
%val8108 = fdiv double %val8106, %val8107
%val8109 = load double, double* %kPtr
%val8110 = load double, double* %jPtr
%val8111 = fdiv double %val8109, %val8110
%res8112 = call fastcc %Complexd @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd(double %val8108, double %val8111)
ret %Complexd %res8112
}
@gsxtmmath330 = hidden constant [108 x i8] c"xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8132 = load i8*, i8** %_impzPtr
%zone8133 = bitcast i8* %tzone8132 to %mzone*

; let assign value to symbol xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0
%dat_xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0 = call i8* @llvm_zone_malloc(%mzone* %zone8133, i64 8)
%xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr = bitcast i8* %dat_xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***
%tzone8113 = load i8*, i8** %_impzPtr
%zone8114 = bitcast i8* %tzone8113 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8114)
; malloc closure structure
%clsptr8115 = call i8* @llvm_zone_malloc(%mzone* %zone8114, i64 24)
%closure8116 = bitcast i8* %clsptr8115 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*

; malloc environment structure
%envptr8117 = call i8* @llvm_zone_malloc(%mzone* %zone8114, i64 8)
%environment8118 = bitcast i8* %envptr8117 to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}*

; malloc closure address table
%addytable8119 = call %clsvar* @new_address_table()
%var8120 = bitcast [55 x i8]* @gsxtmmath329 to i8*
%var8121 = bitcast [55 x i8]* @gsxtmmath306 to i8*
%addytable8122 = call %clsvar* @add_address_table(%mzone* %zone8114, i8* %var8120, i32 0, i8* %var8121, i32 3, %clsvar* %addytable8119)
%address-table8123 = bitcast %clsvar* %addytable8122 to i8*

; insert table, function and environment into closure struct
%closure.table8126 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure8116, i32 0, i32 0
store i8* %address-table8123, i8** %closure.table8126
%closure.env8127 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure8116, i32 0, i32 1
store i8* %envptr8117, i8** %closure.env8127
%closure.func8128 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure8116, i32 0, i32 2
store %Complexd (i8*, i8*, %Complexd, double)* @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0__8081, %Complexd (i8*, i8*, %Complexd, double)** %closure.func8128
%closure_size8129 = call i64 @llvm_zone_mark_size(%mzone* %zone8114)
call void @llvm_zone_ptr_set_size(i8* %clsptr8115, i64 %closure_size8129)
%wrapper_ptr8130 = call i8* @llvm_zone_malloc(%mzone* %zone8114, i64 8)
%closure_wrapper8131 = bitcast i8* %wrapper_ptr8130 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure8116, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_wrapper8131

; let value assignment
%xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0 = select i1 true, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_wrapper8131, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_wrapper8131
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0, { i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*** %xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr

; add data to environment
; don't need to alloc for env var xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0
%tmp_envptr8125 = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}***}* %environment8118, i32 0, i32 0
store {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*** %xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**** %tmp_envptr8125


%val8134 = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*** %xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0Ptr
ret {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %val8134
}


@xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0(%Complexd %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, double)*,  %Complexd (i8*, i8*, %Complexd, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, double %arg_1)
ret %Complexd %result
}


define dllexport ccc %Complexd @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_native(%Complexd %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, double)*,  %Complexd (i8*, i8*, %Complexd, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, double %arg_1)
ret %Complexd %result
}


define dllexport ccc void @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd, double}*
%arg_p_0 = getelementptr {%Complexd, double}, {%Complexd, double}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd, %Complexd* %arg_p_0
%arg_p_1 = getelementptr {%Complexd, double}, {%Complexd, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhkLENvbXBsZXhkLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd, double)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd, double)*,  %Complexd (i8*, i8*, %Complexd, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0, double %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath331 = hidden constant [55 x i8] c"xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0\00"
define dllexport fastcc %Complexd @xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0__8136(i8* %_impz,i8* %_impenv, double %b, %Complexd %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8137 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}*
%xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr_ = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}* %impenv, i32 0, i32 0
%xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr = load {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**** %xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr_

; setup arguments
%bPtr = alloca double
store double %b, double* %bPtr
%aPtr = alloca %Complexd
store %Complexd %a, %Complexd* %aPtr


%tzone8145 = load i8*, i8** %_impzPtr
%zone8146 = bitcast i8* %tzone8145 to %mzone*

; let assign value to symbol i
%iPtr = alloca double
%tzone8150 = load i8*, i8** %_impzPtr
%zone8151 = bitcast i8* %tzone8150 to %mzone*

; let assign value to symbol j
%jPtr = alloca double
%tzone8159 = load i8*, i8** %_impzPtr
%zone8160 = bitcast i8* %tzone8159 to %mzone*

; let assign value to symbol k
%kPtr = alloca double
%val8138 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8139 = extractvalue %Complexd %val8138, 0
%val8140 = load double, double* %bPtr
%val8141 = fmul double %val8139, %val8140
%val8142 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8143 = extractvalue %Complexd %val8142, 1
%val8144 = fadd double %val8141, %val8143

; let value assignment
%i = select i1 true, double %val8144, double %val8144
store double %i, double* %iPtr

%val8147 = load double, double* %bPtr
%val8148 = load double, double* %bPtr
%val8149 = fmul double %val8147, %val8148

; let value assignment
%j = select i1 true, double %val8149, double %val8149
store double %j, double* %jPtr

%val8152 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8153 = extractvalue %Complexd %val8152, 1
%val8154 = load double, double* %bPtr
%val8155 = fmul double %val8153, %val8154
%val8156 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8157 = extractvalue %Complexd %val8156, 0
%val8158 = fsub double %val8155, %val8157

; let value assignment
%k = select i1 true, double %val8158, double %val8158
store double %k, double* %kPtr

%val8161 = load double, double* %iPtr
%val8162 = load double, double* %jPtr
%val8163 = fdiv double %val8161, %val8162
%val8164 = load double, double* %kPtr
%val8165 = load double, double* %jPtr
%val8166 = fdiv double %val8164, %val8165
%res8167 = call fastcc %Complexd @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd(double %val8163, double %val8166)
ret %Complexd %res8167
}
@gsxtmmath332 = hidden constant [108 x i8] c"xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** @xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8187 = load i8*, i8** %_impzPtr
%zone8188 = bitcast i8* %tzone8187 to %mzone*

; let assign value to symbol xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0
%dat_xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0 = call i8* @llvm_zone_malloc(%mzone* %zone8188, i64 8)
%xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr = bitcast i8* %dat_xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0 to { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***
%tzone8168 = load i8*, i8** %_impzPtr
%zone8169 = bitcast i8* %tzone8168 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8169)
; malloc closure structure
%clsptr8170 = call i8* @llvm_zone_malloc(%mzone* %zone8169, i64 24)
%closure8171 = bitcast i8* %clsptr8170 to { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*

; malloc environment structure
%envptr8172 = call i8* @llvm_zone_malloc(%mzone* %zone8169, i64 8)
%environment8173 = bitcast i8* %envptr8172 to {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}*

; malloc closure address table
%addytable8174 = call %clsvar* @new_address_table()
%var8175 = bitcast [55 x i8]* @gsxtmmath331 to i8*
%var8176 = bitcast [55 x i8]* @gsxtmmath309 to i8*
%addytable8177 = call %clsvar* @add_address_table(%mzone* %zone8169, i8* %var8175, i32 0, i8* %var8176, i32 3, %clsvar* %addytable8174)
%address-table8178 = bitcast %clsvar* %addytable8177 to i8*

; insert table, function and environment into closure struct
%closure.table8181 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure8171, i32 0, i32 0
store i8* %address-table8178, i8** %closure.table8181
%closure.env8182 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure8171, i32 0, i32 1
store i8* %envptr8172, i8** %closure.env8182
%closure.func8183 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure8171, i32 0, i32 2
store %Complexd (i8*, i8*, double, %Complexd)* @xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0__8136, %Complexd (i8*, i8*, double, %Complexd)** %closure.func8183
%closure_size8184 = call i64 @llvm_zone_mark_size(%mzone* %zone8169)
call void @llvm_zone_ptr_set_size(i8* %clsptr8170, i64 %closure_size8184)
%wrapper_ptr8185 = call i8* @llvm_zone_malloc(%mzone* %zone8169, i64 8)
%closure_wrapper8186 = bitcast i8* %wrapper_ptr8185 to { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**
store { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure8171, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_wrapper8186

; let value assignment
%xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0 = select i1 true, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_wrapper8186, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_wrapper8186
store { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0, { i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*** %xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr

; add data to environment
; don't need to alloc for env var xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0
%tmp_envptr8180 = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}***}* %environment8173, i32 0, i32 0
store {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*** %xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**** %tmp_envptr8180


%val8189 = load {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*** %xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0Ptr
ret {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %val8189
}


@xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** @xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd @xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0(double %arg_0,%Complexd %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, double, %Complexd)*,  %Complexd (i8*, i8*, double, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, double %arg_0, %Complexd %arg_1)
ret %Complexd %result
}


define dllexport ccc %Complexd @xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_native(double %arg_0,%Complexd %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, double, %Complexd)*,  %Complexd (i8*, i8*, double, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, double %arg_0, %Complexd %arg_1)
ret %Complexd %result
}


define dllexport ccc void @xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double, %Complexd}*
%arg_p_0 = getelementptr {double, %Complexd}, {double, %Complexd}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
%arg_p_1 = getelementptr {double, %Complexd}, {double, %Complexd}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexd, %Complexd* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhkLGRvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, double, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, double, %Complexd)*,  %Complexd (i8*, i8*, double, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, double %arg_0, %Complexd %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath333 = hidden constant [84 x i8] c"Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ\00"
define dllexport fastcc void @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ__8191(i8* %_impz,i8* %_impenv, %Complexd* %a, %Complexd* %b, %Complexd* %c, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8192 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}*
%Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}* %impenv, i32 0, i32 0
%Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**** %Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr_

; setup arguments
%aPtr = alloca %Complexd*
store %Complexd* %a, %Complexd** %aPtr
%bPtr = alloca %Complexd*
store %Complexd* %b, %Complexd** %bPtr
%cPtr = alloca %Complexd*
store %Complexd* %c, %Complexd** %cPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone8193 = load i8*, i8** %_impzPtr
%zone8194 = bitcast i8* %tzone8193 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%tzone8195 = load i8*, i8** %_impzPtr
%zone8196 = bitcast i8* %tzone8195 to %mzone*

; let assign value to symbol j
%jPtr = alloca double
%tzone8197 = load i8*, i8** %_impzPtr
%zone8198 = bitcast i8* %tzone8197 to %mzone*

; let assign value to symbol k
%kPtr = alloca double
%tzone8199 = load i8*, i8** %_impzPtr
%zone8200 = bitcast i8* %tzone8199 to %mzone*

; let assign value to symbol l
%lPtr = alloca double

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr


; let value assignment
%j = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %j, double* %jPtr


; let value assignment
%k = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %k, double* %kPtr


; let value assignment
%l = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %l, double* %lPtr

; setup loop
%val8203 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val8287 = load i64, i64* %iPtr
%num8288 = add i64 %val8203, %val8287
%comp8289 = icmp ult i64 %val8203, 1
br i1 %comp8289, label %after8201, label %loop8201

loop8201:
; do set!
%val8204 = load i64, i64* %iPtr
%val8205 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val8206 = getelementptr %Complexd, %Complexd* %val8205, i64 %val8204
; tuple ref
%val8207 = getelementptr %Complexd, %Complexd* %val8206, i64 0, i32 0
%val8208 = load double, double* %val8207
%val8209 = load i64, i64* %iPtr
%val8210 = load %Complexd*, %Complexd** %bPtr
; pointer ref
%val8211 = getelementptr %Complexd, %Complexd* %val8210, i64 %val8209
; tuple ref
%val8212 = getelementptr %Complexd, %Complexd* %val8211, i64 0, i32 0
%val8213 = load double, double* %val8212
%val8214 = fmul double %val8208, %val8213
%val8215 = load i64, i64* %iPtr
%val8216 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val8217 = getelementptr %Complexd, %Complexd* %val8216, i64 %val8215
; tuple ref
%val8218 = getelementptr %Complexd, %Complexd* %val8217, i64 0, i32 1
%val8219 = load double, double* %val8218
%val8220 = load i64, i64* %iPtr
%val8221 = load %Complexd*, %Complexd** %bPtr
; pointer ref
%val8222 = getelementptr %Complexd, %Complexd* %val8221, i64 %val8220
; tuple ref
%val8223 = getelementptr %Complexd, %Complexd* %val8222, i64 0, i32 1
%val8224 = load double, double* %val8223
%val8225 = fmul double %val8219, %val8224
%val8226 = fadd double %val8214, %val8225
store double %val8226, double* %jPtr
; do set!
%val8227 = load i64, i64* %iPtr
%val8228 = load %Complexd*, %Complexd** %bPtr
; pointer ref
%val8229 = getelementptr %Complexd, %Complexd* %val8228, i64 %val8227
; tuple ref
%val8230 = getelementptr %Complexd, %Complexd* %val8229, i64 0, i32 0
%val8231 = load double, double* %val8230
%val8232 = load i64, i64* %iPtr
%val8233 = load %Complexd*, %Complexd** %bPtr
; pointer ref
%val8234 = getelementptr %Complexd, %Complexd* %val8233, i64 %val8232
; tuple ref
%val8235 = getelementptr %Complexd, %Complexd* %val8234, i64 0, i32 0
%val8236 = load double, double* %val8235
%val8237 = fmul double %val8231, %val8236
%val8238 = load i64, i64* %iPtr
%val8239 = load %Complexd*, %Complexd** %bPtr
; pointer ref
%val8240 = getelementptr %Complexd, %Complexd* %val8239, i64 %val8238
; tuple ref
%val8241 = getelementptr %Complexd, %Complexd* %val8240, i64 0, i32 1
%val8242 = load double, double* %val8241
%val8243 = load i64, i64* %iPtr
%val8244 = load %Complexd*, %Complexd** %bPtr
; pointer ref
%val8245 = getelementptr %Complexd, %Complexd* %val8244, i64 %val8243
; tuple ref
%val8246 = getelementptr %Complexd, %Complexd* %val8245, i64 0, i32 1
%val8247 = load double, double* %val8246
%val8248 = fmul double %val8242, %val8247
%val8249 = fadd double %val8237, %val8248
store double %val8249, double* %kPtr
; do set!
%val8250 = load i64, i64* %iPtr
%val8251 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val8252 = getelementptr %Complexd, %Complexd* %val8251, i64 %val8250
; tuple ref
%val8253 = getelementptr %Complexd, %Complexd* %val8252, i64 0, i32 1
%val8254 = load double, double* %val8253
%val8255 = load i64, i64* %iPtr
%val8256 = load %Complexd*, %Complexd** %bPtr
; pointer ref
%val8257 = getelementptr %Complexd, %Complexd* %val8256, i64 %val8255
; tuple ref
%val8258 = getelementptr %Complexd, %Complexd* %val8257, i64 0, i32 0
%val8259 = load double, double* %val8258
%val8260 = fmul double %val8254, %val8259
%val8261 = load i64, i64* %iPtr
%val8262 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val8263 = getelementptr %Complexd, %Complexd* %val8262, i64 %val8261
; tuple ref
%val8264 = getelementptr %Complexd, %Complexd* %val8263, i64 0, i32 0
%val8265 = load double, double* %val8264
%val8266 = load i64, i64* %iPtr
%val8267 = load %Complexd*, %Complexd** %bPtr
; pointer ref
%val8268 = getelementptr %Complexd, %Complexd* %val8267, i64 %val8266
; tuple ref
%val8269 = getelementptr %Complexd, %Complexd* %val8268, i64 0, i32 1
%val8270 = load double, double* %val8269
%val8271 = fmul double %val8265, %val8270
%val8272 = fsub double %val8260, %val8271
store double %val8272, double* %lPtr
%val8273 = load i64, i64* %iPtr
%val8274 = load %Complexd*, %Complexd** %cPtr
; pointer ref
%val8275 = getelementptr %Complexd, %Complexd* %val8274, i64 %val8273
%val8276 = load double, double* %jPtr
%val8277 = load double, double* %kPtr
%val8278 = fdiv double %val8276, %val8277
; set tuple
%val8279 = getelementptr %Complexd, %Complexd* %val8275, i64 0, i32 0
store double %val8278, double* %val8279
%val8280 = load i64, i64* %iPtr
%val8281 = load %Complexd*, %Complexd** %cPtr
; pointer ref
%val8282 = getelementptr %Complexd, %Complexd* %val8281, i64 %val8280
%val8283 = load double, double* %lPtr
%val8284 = load double, double* %kPtr
%val8285 = fdiv double %val8283, %val8284
; set tuple
%val8286 = getelementptr %Complexd, %Complexd* %val8282, i64 0, i32 1
store double %val8285, double* %val8286
%loop_cnt8201 = load i64, i64* %iPtr
%next8201 = add i64 %loop_cnt8201, 1
store i64 %next8201, i64* %iPtr
%cmp8201 = icmp ult i64 %next8201, %num8288
br i1 %cmp8201, label %loop8201, label %after8201

after8201:
ret void
}
@gsxtmmath334 = hidden constant [137 x i8] c"Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8311 = load i8*, i8** %_impzPtr
%zone8312 = bitcast i8* %tzone8311 to %mzone*

; let assign value to symbol Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ
%dat_Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone8312, i64 8)
%Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr = bitcast i8* %dat_Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ to { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***
%tzone8292 = load i8*, i8** %_impzPtr
%zone8293 = bitcast i8* %tzone8292 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8293)
; malloc closure structure
%clsptr8294 = call i8* @llvm_zone_malloc(%mzone* %zone8293, i64 24)
%closure8295 = bitcast i8* %clsptr8294 to { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*

; malloc environment structure
%envptr8296 = call i8* @llvm_zone_malloc(%mzone* %zone8293, i64 8)
%environment8297 = bitcast i8* %envptr8296 to {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}*

; malloc closure address table
%addytable8298 = call %clsvar* @new_address_table()
%var8299 = bitcast [84 x i8]* @gsxtmmath333 to i8*
%var8300 = bitcast [72 x i8]* @gsxtmmath312 to i8*
%addytable8301 = call %clsvar* @add_address_table(%mzone* %zone8293, i8* %var8299, i32 0, i8* %var8300, i32 3, %clsvar* %addytable8298)
%address-table8302 = bitcast %clsvar* %addytable8301 to i8*

; insert table, function and environment into closure struct
%closure.table8305 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure8295, i32 0, i32 0
store i8* %address-table8302, i8** %closure.table8305
%closure.env8306 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure8295, i32 0, i32 1
store i8* %envptr8296, i8** %closure.env8306
%closure.func8307 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure8295, i32 0, i32 2
store void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)* @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ__8191, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)** %closure.func8307
%closure_size8308 = call i64 @llvm_zone_mark_size(%mzone* %zone8293)
call void @llvm_zone_ptr_set_size(i8* %clsptr8294, i64 %closure_size8308)
%wrapper_ptr8309 = call i8* @llvm_zone_malloc(%mzone* %zone8293, i64 8)
%closure_wrapper8310 = bitcast i8* %wrapper_ptr8309 to { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**
store { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure8295, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_wrapper8310

; let value assignment
%Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_wrapper8310, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_wrapper8310
store { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ, { i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*** %Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr

; add data to environment
; don't need to alloc for env var Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ
%tmp_envptr8304 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}***}* %environment8297, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*** %Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**** %tmp_envptr8304


%val8313 = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*** %Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %val8313
}


@Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ(%Complexd* %arg_0,%Complexd* %arg_1,%Complexd* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, %Complexd* %arg_1, %Complexd* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc void @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_native(%Complexd* %arg_0,%Complexd* %arg_1,%Complexd* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, %Complexd* %arg_1, %Complexd* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc i8*  @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8314 = bitcast [137 x i8]* @gsxtmmath334 to i8*
call i32 (i8*, ...) @printf(i8* %var8314)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexd*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var8315 = bitcast [137 x i8]* @gsxtmmath334 to i8*
call i32 (i8*, ...) @printf(i8* %var8315)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Complexd*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var8316 = bitcast [137 x i8]* @gsxtmmath334 to i8*
call i32 (i8*, ...) @printf(i8* %var8316)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Complexd*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var8317 = bitcast [137 x i8]* @gsxtmmath334 to i8*
call i32 (i8*, ...) @printf(i8* %var8317)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, %Complexd* %arg_1, %Complexd* %arg_2, i64 %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd*, %Complexd*, %Complexd*, i64}*
%arg_p_0 = getelementptr {%Complexd*, %Complexd*, %Complexd*, i64}, {%Complexd*, %Complexd*, %Complexd*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd*, %Complexd** %arg_p_0
%arg_p_1 = getelementptr {%Complexd*, %Complexd*, %Complexd*, i64}, {%Complexd*, %Complexd*, %Complexd*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexd*, %Complexd** %arg_p_1
%arg_p_2 = getelementptr {%Complexd*, %Complexd*, %Complexd*, i64}, {%Complexd*, %Complexd*, %Complexd*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load %Complexd*, %Complexd** %arg_p_2
%arg_p_3 = getelementptr {%Complexd*, %Complexd*, %Complexd*, i64}, {%Complexd*, %Complexd*, %Complexd*, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGQqLENvbXBsZXhkKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, %Complexd*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, %Complexd* %arg_1, %Complexd* %arg_2, i64 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath335 = hidden constant [42 x i8] c"Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0\00"
@gsxtmmath336 = hidden constant [44 x i8] c"{i8*, i8*, double (i8*, i8*, %Complexd)*}**\00"
define dllexport fastcc double @Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0__8318(i8* %_impz,i8* %_impenv, %Complexd %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8319 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, %Complexd)*}***}*
%Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, %Complexd)*}***}, {{i8*, i8*, double (i8*, i8*, %Complexd)*}***}* %impenv, i32 0, i32 0
%Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0Ptr = load {i8*, i8*, double (i8*, i8*, %Complexd)*}***, {i8*, i8*, double (i8*, i8*, %Complexd)*}**** %Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0Ptr_

; setup arguments
%aPtr = alloca %Complexd
store %Complexd %a, %Complexd* %aPtr


%val8320 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8321 = extractvalue %Complexd %val8320, 0
%val8322 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8323 = extractvalue %Complexd %val8322, 0
%val8324 = fmul double %val8321, %val8323
%val8325 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8326 = extractvalue %Complexd %val8325, 1
%val8327 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8328 = extractvalue %Complexd %val8327, 1
%val8329 = fmul double %val8326, %val8328
%val8330 = fadd double %val8324, %val8329
%val8331 = call double @llvm.sqrt.f64(double %val8330)
ret double %val8331
}
define dllexport ccc {i8*, i8*, double (i8*, i8*, %Complexd)*}** @Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8351 = load i8*, i8** %_impzPtr
%zone8352 = bitcast i8* %tzone8351 to %mzone*

; let assign value to symbol Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0
%dat_Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0 = call i8* @llvm_zone_malloc(%mzone* %zone8352, i64 8)
%Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0Ptr = bitcast i8* %dat_Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0 to { i8*, i8*, double (i8*, i8*, %Complexd)*}***
%tzone8332 = load i8*, i8** %_impzPtr
%zone8333 = bitcast i8* %tzone8332 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8333)
; malloc closure structure
%clsptr8334 = call i8* @llvm_zone_malloc(%mzone* %zone8333, i64 24)
%closure8335 = bitcast i8* %clsptr8334 to { i8*, i8*, double (i8*, i8*, %Complexd)*}*

; malloc environment structure
%envptr8336 = call i8* @llvm_zone_malloc(%mzone* %zone8333, i64 8)
%environment8337 = bitcast i8* %envptr8336 to {{i8*, i8*, double (i8*, i8*, %Complexd)*}***}*

; malloc closure address table
%addytable8338 = call %clsvar* @new_address_table()
%var8339 = bitcast [42 x i8]* @gsxtmmath335 to i8*
%var8340 = bitcast [44 x i8]* @gsxtmmath336 to i8*
%addytable8341 = call %clsvar* @add_address_table(%mzone* %zone8333, i8* %var8339, i32 0, i8* %var8340, i32 3, %clsvar* %addytable8338)
%address-table8342 = bitcast %clsvar* %addytable8341 to i8*

; insert table, function and environment into closure struct
%closure.table8345 = getelementptr { i8*, i8*, double (i8*, i8*, %Complexd)*}, { i8*, i8*, double (i8*, i8*, %Complexd)*}* %closure8335, i32 0, i32 0
store i8* %address-table8342, i8** %closure.table8345
%closure.env8346 = getelementptr { i8*, i8*, double (i8*, i8*, %Complexd)*}, { i8*, i8*, double (i8*, i8*, %Complexd)*}* %closure8335, i32 0, i32 1
store i8* %envptr8336, i8** %closure.env8346
%closure.func8347 = getelementptr { i8*, i8*, double (i8*, i8*, %Complexd)*}, { i8*, i8*, double (i8*, i8*, %Complexd)*}* %closure8335, i32 0, i32 2
store double (i8*, i8*, %Complexd)* @Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0__8318, double (i8*, i8*, %Complexd)** %closure.func8347
%closure_size8348 = call i64 @llvm_zone_mark_size(%mzone* %zone8333)
call void @llvm_zone_ptr_set_size(i8* %clsptr8334, i64 %closure_size8348)
%wrapper_ptr8349 = call i8* @llvm_zone_malloc(%mzone* %zone8333, i64 8)
%closure_wrapper8350 = bitcast i8* %wrapper_ptr8349 to { i8*, i8*, double (i8*, i8*, %Complexd)*}**
store { i8*, i8*, double (i8*, i8*, %Complexd)*}* %closure8335, { i8*, i8*, double (i8*, i8*, %Complexd)*}** %closure_wrapper8350

; let value assignment
%Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0 = select i1 true, { i8*, i8*, double (i8*, i8*, %Complexd)*}** %closure_wrapper8350, { i8*, i8*, double (i8*, i8*, %Complexd)*}** %closure_wrapper8350
store { i8*, i8*, double (i8*, i8*, %Complexd)*}** %Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0, { i8*, i8*, double (i8*, i8*, %Complexd)*}*** %Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0Ptr

; add data to environment
; don't need to alloc for env var Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0
%tmp_envptr8344 = getelementptr {{i8*, i8*, double (i8*, i8*, %Complexd)*}***}, {{i8*, i8*, double (i8*, i8*, %Complexd)*}***}* %environment8337, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, %Complexd)*}*** %Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0Ptr, {i8*, i8*, double (i8*, i8*, %Complexd)*}**** %tmp_envptr8344


%val8353 = load {i8*, i8*, double (i8*, i8*, %Complexd)*}**, {i8*, i8*, double (i8*, i8*, %Complexd)*}*** %Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0Ptr
ret {i8*, i8*, double (i8*, i8*, %Complexd)*}** %val8353
}


@Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, %Complexd)*}** @Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, %Complexd)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0(%Complexd %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %Complexd)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %Complexd)*}*, {i8*, i8*, double (i8*, i8*, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %Complexd)*}, {i8*, i8*, double (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %Complexd)*}, {i8*, i8*, double (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %Complexd)*,  double (i8*, i8*, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %Complexd %arg_0)
ret double %result
}


define dllexport ccc double @Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_native(%Complexd %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %Complexd)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %Complexd)*}*, {i8*, i8*, double (i8*, i8*, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %Complexd)*}, {i8*, i8*, double (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %Complexd)*}, {i8*, i8*, double (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %Complexd)*,  double (i8*, i8*, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %Complexd %arg_0)
ret double %result
}


define dllexport ccc void @Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd}*
%arg_p_0 = getelementptr {%Complexd}, {%Complexd}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd, %Complexd* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_mag_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %Complexd)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %Complexd)*}*, {i8*, i8*, double (i8*, i8*, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %Complexd)*}, {i8*, i8*, double (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %Complexd)*}, {i8*, i8*, double (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %Complexd)*,  double (i8*, i8*, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %Complexd %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath337 = hidden constant [44 x i8] c"Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0\00"
define dllexport fastcc double @Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0__8354(i8* %_impz,i8* %_impenv, %Complexd %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8355 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, %Complexd)*}***}*
%Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, %Complexd)*}***}, {{i8*, i8*, double (i8*, i8*, %Complexd)*}***}* %impenv, i32 0, i32 0
%Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0Ptr = load {i8*, i8*, double (i8*, i8*, %Complexd)*}***, {i8*, i8*, double (i8*, i8*, %Complexd)*}**** %Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0Ptr_

; setup arguments
%aPtr = alloca %Complexd
store %Complexd %a, %Complexd* %aPtr


%val8356 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8357 = extractvalue %Complexd %val8356, 1
%val8358 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8359 = extractvalue %Complexd %val8358, 0
%res8360 = call ccc double @atan2(double %val8357, double %val8359)
ret double %res8360
}
define dllexport ccc {i8*, i8*, double (i8*, i8*, %Complexd)*}** @Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8380 = load i8*, i8** %_impzPtr
%zone8381 = bitcast i8* %tzone8380 to %mzone*

; let assign value to symbol Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0
%dat_Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0 = call i8* @llvm_zone_malloc(%mzone* %zone8381, i64 8)
%Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0Ptr = bitcast i8* %dat_Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0 to { i8*, i8*, double (i8*, i8*, %Complexd)*}***
%tzone8361 = load i8*, i8** %_impzPtr
%zone8362 = bitcast i8* %tzone8361 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8362)
; malloc closure structure
%clsptr8363 = call i8* @llvm_zone_malloc(%mzone* %zone8362, i64 24)
%closure8364 = bitcast i8* %clsptr8363 to { i8*, i8*, double (i8*, i8*, %Complexd)*}*

; malloc environment structure
%envptr8365 = call i8* @llvm_zone_malloc(%mzone* %zone8362, i64 8)
%environment8366 = bitcast i8* %envptr8365 to {{i8*, i8*, double (i8*, i8*, %Complexd)*}***}*

; malloc closure address table
%addytable8367 = call %clsvar* @new_address_table()
%var8368 = bitcast [44 x i8]* @gsxtmmath337 to i8*
%var8369 = bitcast [44 x i8]* @gsxtmmath336 to i8*
%addytable8370 = call %clsvar* @add_address_table(%mzone* %zone8362, i8* %var8368, i32 0, i8* %var8369, i32 3, %clsvar* %addytable8367)
%address-table8371 = bitcast %clsvar* %addytable8370 to i8*

; insert table, function and environment into closure struct
%closure.table8374 = getelementptr { i8*, i8*, double (i8*, i8*, %Complexd)*}, { i8*, i8*, double (i8*, i8*, %Complexd)*}* %closure8364, i32 0, i32 0
store i8* %address-table8371, i8** %closure.table8374
%closure.env8375 = getelementptr { i8*, i8*, double (i8*, i8*, %Complexd)*}, { i8*, i8*, double (i8*, i8*, %Complexd)*}* %closure8364, i32 0, i32 1
store i8* %envptr8365, i8** %closure.env8375
%closure.func8376 = getelementptr { i8*, i8*, double (i8*, i8*, %Complexd)*}, { i8*, i8*, double (i8*, i8*, %Complexd)*}* %closure8364, i32 0, i32 2
store double (i8*, i8*, %Complexd)* @Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0__8354, double (i8*, i8*, %Complexd)** %closure.func8376
%closure_size8377 = call i64 @llvm_zone_mark_size(%mzone* %zone8362)
call void @llvm_zone_ptr_set_size(i8* %clsptr8363, i64 %closure_size8377)
%wrapper_ptr8378 = call i8* @llvm_zone_malloc(%mzone* %zone8362, i64 8)
%closure_wrapper8379 = bitcast i8* %wrapper_ptr8378 to { i8*, i8*, double (i8*, i8*, %Complexd)*}**
store { i8*, i8*, double (i8*, i8*, %Complexd)*}* %closure8364, { i8*, i8*, double (i8*, i8*, %Complexd)*}** %closure_wrapper8379

; let value assignment
%Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0 = select i1 true, { i8*, i8*, double (i8*, i8*, %Complexd)*}** %closure_wrapper8379, { i8*, i8*, double (i8*, i8*, %Complexd)*}** %closure_wrapper8379
store { i8*, i8*, double (i8*, i8*, %Complexd)*}** %Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0, { i8*, i8*, double (i8*, i8*, %Complexd)*}*** %Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0Ptr

; add data to environment
; don't need to alloc for env var Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0
%tmp_envptr8373 = getelementptr {{i8*, i8*, double (i8*, i8*, %Complexd)*}***}, {{i8*, i8*, double (i8*, i8*, %Complexd)*}***}* %environment8366, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, %Complexd)*}*** %Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0Ptr, {i8*, i8*, double (i8*, i8*, %Complexd)*}**** %tmp_envptr8373


%val8382 = load {i8*, i8*, double (i8*, i8*, %Complexd)*}**, {i8*, i8*, double (i8*, i8*, %Complexd)*}*** %Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0Ptr
ret {i8*, i8*, double (i8*, i8*, %Complexd)*}** %val8382
}


@Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, %Complexd)*}** @Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, %Complexd)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0(%Complexd %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %Complexd)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %Complexd)*}*, {i8*, i8*, double (i8*, i8*, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %Complexd)*}, {i8*, i8*, double (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %Complexd)*}, {i8*, i8*, double (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %Complexd)*,  double (i8*, i8*, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %Complexd %arg_0)
ret double %result
}


define dllexport ccc double @Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_native(%Complexd %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %Complexd)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %Complexd)*}*, {i8*, i8*, double (i8*, i8*, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %Complexd)*}, {i8*, i8*, double (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %Complexd)*}, {i8*, i8*, double (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %Complexd)*,  double (i8*, i8*, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %Complexd %arg_0)
ret double %result
}


define dllexport ccc void @Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd}*
%arg_p_0 = getelementptr {%Complexd}, {%Complexd}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd, %Complexd* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_phase_adhoc_W2RvdWJsZSxDb21wbGV4ZF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %Complexd)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %Complexd)*}*, {i8*, i8*, double (i8*, i8*, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %Complexd)*}, {i8*, i8*, double (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %Complexd)*}, {i8*, i8*, double (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %Complexd)*,  double (i8*, i8*, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %Complexd %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath338 = hidden constant [46 x i8] c"Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ\00"
@gsxtmmath339 = hidden constant [47 x i8] c"{i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**\00"
define dllexport fastcc %Complexd @Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ__8383(i8* %_impz,i8* %_impenv, %Complexd %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8384 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***}*
%Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQPtr_ = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***}* %impenv, i32 0, i32 0
%Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQPtr = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**** %Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQPtr_

; setup arguments
%aPtr = alloca %Complexd
store %Complexd %a, %Complexd* %aPtr


%val8385 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8386 = extractvalue %Complexd %val8385, 0
%val8387 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8388 = extractvalue %Complexd %val8387, 0
%val8389 = fmul double -1.0000000000000000000, %val8388
%res8390 = call fastcc %Complexd @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd(double %val8386, double %val8389)
ret %Complexd %res8390
}
define dllexport ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** @Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8410 = load i8*, i8** %_impzPtr
%zone8411 = bitcast i8* %tzone8410 to %mzone*

; let assign value to symbol Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ
%dat_Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ = call i8* @llvm_zone_malloc(%mzone* %zone8411, i64 8)
%Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQPtr = bitcast i8* %dat_Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ to { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***
%tzone8391 = load i8*, i8** %_impzPtr
%zone8392 = bitcast i8* %tzone8391 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8392)
; malloc closure structure
%clsptr8393 = call i8* @llvm_zone_malloc(%mzone* %zone8392, i64 24)
%closure8394 = bitcast i8* %clsptr8393 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}*

; malloc environment structure
%envptr8395 = call i8* @llvm_zone_malloc(%mzone* %zone8392, i64 8)
%environment8396 = bitcast i8* %envptr8395 to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***}*

; malloc closure address table
%addytable8397 = call %clsvar* @new_address_table()
%var8398 = bitcast [46 x i8]* @gsxtmmath338 to i8*
%var8399 = bitcast [47 x i8]* @gsxtmmath339 to i8*
%addytable8400 = call %clsvar* @add_address_table(%mzone* %zone8392, i8* %var8398, i32 0, i8* %var8399, i32 3, %clsvar* %addytable8397)
%address-table8401 = bitcast %clsvar* %addytable8400 to i8*

; insert table, function and environment into closure struct
%closure.table8404 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure8394, i32 0, i32 0
store i8* %address-table8401, i8** %closure.table8404
%closure.env8405 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure8394, i32 0, i32 1
store i8* %envptr8395, i8** %closure.env8405
%closure.func8406 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure8394, i32 0, i32 2
store %Complexd (i8*, i8*, %Complexd)* @Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ__8383, %Complexd (i8*, i8*, %Complexd)** %closure.func8406
%closure_size8407 = call i64 @llvm_zone_mark_size(%mzone* %zone8392)
call void @llvm_zone_ptr_set_size(i8* %clsptr8393, i64 %closure_size8407)
%wrapper_ptr8408 = call i8* @llvm_zone_malloc(%mzone* %zone8392, i64 8)
%closure_wrapper8409 = bitcast i8* %wrapper_ptr8408 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure8394, { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %closure_wrapper8409

; let value assignment
%Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ = select i1 true, { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %closure_wrapper8409, { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %closure_wrapper8409
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ, { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}*** %Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQPtr

; add data to environment
; don't need to alloc for env var Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ
%tmp_envptr8403 = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***}* %environment8396, i32 0, i32 0
store {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}*** %Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQPtr, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**** %tmp_envptr8403


%val8412 = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}*** %Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQPtr
ret {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %val8412
}


@Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** @Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd @Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ(%Complexd %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd)*,  %Complexd (i8*, i8*, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0)
ret %Complexd %result
}


define dllexport ccc %Complexd @Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_native(%Complexd %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd)*,  %Complexd (i8*, i8*, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0)
ret %Complexd %result
}


define dllexport ccc void @Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd}*
%arg_p_0 = getelementptr {%Complexd}, {%Complexd}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd, %Complexd* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_conj_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd)*,  %Complexd (i8*, i8*, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath340 = hidden constant [45 x i8] c"cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ\00"
define dllexport fastcc %Complexd @cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ__8413(i8* %_impz,i8* %_impenv, %Complexd %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8414 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***}*
%cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQPtr_ = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***}* %impenv, i32 0, i32 0
%cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQPtr = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**** %cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQPtr_

; setup arguments
%aPtr = alloca %Complexd
store %Complexd %a, %Complexd* %aPtr


%val8415 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8416 = extractvalue %Complexd %val8415, 0
%val8417 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8418 = extractvalue %Complexd %val8417, 0
%val8419 = fmul double %val8416, %val8418
%val8420 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8421 = extractvalue %Complexd %val8420, 1
%val8422 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8423 = extractvalue %Complexd %val8422, 1
%val8424 = fmul double %val8421, %val8423
%val8425 = fadd double %val8419, %val8424
%val8426 = call double @llvm.sqrt.f64(double %val8425)
%val8427 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8428 = extractvalue %Complexd %val8427, 1
%val8429 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8430 = extractvalue %Complexd %val8429, 0
%res8431 = call ccc double @atan2(double %val8428, double %val8430)
%res8432 = call fastcc %Complexd @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd(double %val8426, double %res8431)
ret %Complexd %res8432
}
define dllexport ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** @cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8452 = load i8*, i8** %_impzPtr
%zone8453 = bitcast i8* %tzone8452 to %mzone*

; let assign value to symbol cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ
%dat_cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ = call i8* @llvm_zone_malloc(%mzone* %zone8453, i64 8)
%cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQPtr = bitcast i8* %dat_cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ to { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***
%tzone8433 = load i8*, i8** %_impzPtr
%zone8434 = bitcast i8* %tzone8433 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8434)
; malloc closure structure
%clsptr8435 = call i8* @llvm_zone_malloc(%mzone* %zone8434, i64 24)
%closure8436 = bitcast i8* %clsptr8435 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}*

; malloc environment structure
%envptr8437 = call i8* @llvm_zone_malloc(%mzone* %zone8434, i64 8)
%environment8438 = bitcast i8* %envptr8437 to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***}*

; malloc closure address table
%addytable8439 = call %clsvar* @new_address_table()
%var8440 = bitcast [45 x i8]* @gsxtmmath340 to i8*
%var8441 = bitcast [47 x i8]* @gsxtmmath339 to i8*
%addytable8442 = call %clsvar* @add_address_table(%mzone* %zone8434, i8* %var8440, i32 0, i8* %var8441, i32 3, %clsvar* %addytable8439)
%address-table8443 = bitcast %clsvar* %addytable8442 to i8*

; insert table, function and environment into closure struct
%closure.table8446 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure8436, i32 0, i32 0
store i8* %address-table8443, i8** %closure.table8446
%closure.env8447 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure8436, i32 0, i32 1
store i8* %envptr8437, i8** %closure.env8447
%closure.func8448 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure8436, i32 0, i32 2
store %Complexd (i8*, i8*, %Complexd)* @cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ__8413, %Complexd (i8*, i8*, %Complexd)** %closure.func8448
%closure_size8449 = call i64 @llvm_zone_mark_size(%mzone* %zone8434)
call void @llvm_zone_ptr_set_size(i8* %clsptr8435, i64 %closure_size8449)
%wrapper_ptr8450 = call i8* @llvm_zone_malloc(%mzone* %zone8434, i64 8)
%closure_wrapper8451 = bitcast i8* %wrapper_ptr8450 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure8436, { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %closure_wrapper8451

; let value assignment
%cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ = select i1 true, { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %closure_wrapper8451, { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %closure_wrapper8451
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ, { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}*** %cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQPtr

; add data to environment
; don't need to alloc for env var cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ
%tmp_envptr8445 = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***}* %environment8438, i32 0, i32 0
store {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}*** %cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQPtr, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**** %tmp_envptr8445


%val8454 = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}*** %cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQPtr
ret {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %val8454
}


@cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var = dllexport global [1 x i8*] [ i8* null ]

@cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** @cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd @cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ(%Complexd %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd)*,  %Complexd (i8*, i8*, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0)
ret %Complexd %result
}


define dllexport ccc %Complexd @cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_native(%Complexd %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd)*,  %Complexd (i8*, i8*, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0)
ret %Complexd %result
}


define dllexport ccc void @cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd}*
%arg_p_0 = getelementptr {%Complexd}, {%Complexd}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd, %Complexd* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd)*,  %Complexd (i8*, i8*, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath341 = hidden constant [46 x i8] c"cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0\00"
@gsxtmmath342 = hidden constant [48 x i8] c"{i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}**\00"
define dllexport fastcc void @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0__8455(i8* %_impz,i8* %_impenv, %Complexd* %a, i64 %n) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8456 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}***}*
%cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}***}* %impenv, i32 0, i32 0
%cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0Ptr = load {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}***, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}**** %cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0Ptr_

; setup arguments
%aPtr = alloca %Complexd*
store %Complexd* %a, %Complexd** %aPtr
%nPtr = alloca i64
store i64 %n, i64* %nPtr


%tzone8457 = load i8*, i8** %_impzPtr
%zone8458 = bitcast i8* %tzone8457 to %mzone*

; let assign value to symbol temp
%tempPtr = alloca double

; let value assignment
%temp = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %temp, double* %tempPtr

%tzone8460 = load i8*, i8** %_impzPtr
%zone8461 = bitcast i8* %tzone8460 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val8459 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val8459, i64 %val8459
store i64 %i, i64* %iPtr

; setup loop
%val8464 = load i64, i64* %nPtr
store i64 0, i64* %iPtr
%val8509 = load i64, i64* %iPtr
%num8510 = add i64 %val8464, %val8509
%comp8511 = icmp ult i64 %val8464, 1
br i1 %comp8511, label %after8462, label %loop8462

loop8462:
; do set!
%val8465 = load i64, i64* %iPtr
%val8466 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val8467 = getelementptr %Complexd, %Complexd* %val8466, i64 %val8465
%val8468 = load %Complexd, %Complexd* %val8467
; tuple ref
%val8469 = extractvalue %Complexd %val8468, 0
%val8470 = load i64, i64* %iPtr
%val8471 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val8472 = getelementptr %Complexd, %Complexd* %val8471, i64 %val8470
%val8473 = load %Complexd, %Complexd* %val8472
; tuple ref
%val8474 = extractvalue %Complexd %val8473, 0
%val8475 = fmul double %val8469, %val8474
%val8476 = load i64, i64* %iPtr
%val8477 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val8478 = getelementptr %Complexd, %Complexd* %val8477, i64 %val8476
%val8479 = load %Complexd, %Complexd* %val8478
; tuple ref
%val8480 = extractvalue %Complexd %val8479, 1
%val8481 = load i64, i64* %iPtr
%val8482 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val8483 = getelementptr %Complexd, %Complexd* %val8482, i64 %val8481
%val8484 = load %Complexd, %Complexd* %val8483
; tuple ref
%val8485 = extractvalue %Complexd %val8484, 1
%val8486 = fmul double %val8480, %val8485
%val8487 = fadd double %val8475, %val8486
%val8488 = call double @llvm.sqrt.f64(double %val8487)
store double %val8488, double* %tempPtr
%val8489 = load i64, i64* %iPtr
%val8490 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val8491 = getelementptr %Complexd, %Complexd* %val8490, i64 %val8489
%val8492 = load i64, i64* %iPtr
%val8493 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val8494 = getelementptr %Complexd, %Complexd* %val8493, i64 %val8492
%val8495 = load %Complexd, %Complexd* %val8494
; tuple ref
%val8496 = extractvalue %Complexd %val8495, 1
%val8497 = load i64, i64* %iPtr
%val8498 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val8499 = getelementptr %Complexd, %Complexd* %val8498, i64 %val8497
%val8500 = load %Complexd, %Complexd* %val8499
; tuple ref
%val8501 = extractvalue %Complexd %val8500, 0
%res8502 = call ccc double @atan2(double %val8496, double %val8501)
; set tuple
%val8503 = getelementptr %Complexd, %Complexd* %val8491, i64 0, i32 1
store double %res8502, double* %val8503
%val8504 = load i64, i64* %iPtr
%val8505 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val8506 = getelementptr %Complexd, %Complexd* %val8505, i64 %val8504
%val8507 = load double, double* %tempPtr
; set tuple
%val8508 = getelementptr %Complexd, %Complexd* %val8506, i64 0, i32 0
store double %val8507, double* %val8508
%loop_cnt8462 = load i64, i64* %iPtr
%next8462 = add i64 %loop_cnt8462, 1
store i64 %next8462, i64* %iPtr
%cmp8462 = icmp ult i64 %next8462, %num8510
br i1 %cmp8462, label %loop8462, label %after8462

after8462:
ret void
}
@gsxtmmath343 = hidden constant [99 x i8] c"cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8533 = load i8*, i8** %_impzPtr
%zone8534 = bitcast i8* %tzone8533 to %mzone*

; let assign value to symbol cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0
%dat_cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone8534, i64 8)
%cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0Ptr = bitcast i8* %dat_cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0 to { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}***
%tzone8514 = load i8*, i8** %_impzPtr
%zone8515 = bitcast i8* %tzone8514 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8515)
; malloc closure structure
%clsptr8516 = call i8* @llvm_zone_malloc(%mzone* %zone8515, i64 24)
%closure8517 = bitcast i8* %clsptr8516 to { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}*

; malloc environment structure
%envptr8518 = call i8* @llvm_zone_malloc(%mzone* %zone8515, i64 8)
%environment8519 = bitcast i8* %envptr8518 to {{i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}***}*

; malloc closure address table
%addytable8520 = call %clsvar* @new_address_table()
%var8521 = bitcast [46 x i8]* @gsxtmmath341 to i8*
%var8522 = bitcast [48 x i8]* @gsxtmmath342 to i8*
%addytable8523 = call %clsvar* @add_address_table(%mzone* %zone8515, i8* %var8521, i32 0, i8* %var8522, i32 3, %clsvar* %addytable8520)
%address-table8524 = bitcast %clsvar* %addytable8523 to i8*

; insert table, function and environment into closure struct
%closure.table8527 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure8517, i32 0, i32 0
store i8* %address-table8524, i8** %closure.table8527
%closure.env8528 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure8517, i32 0, i32 1
store i8* %envptr8518, i8** %closure.env8528
%closure.func8529 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure8517, i32 0, i32 2
store void (i8*, i8*, %Complexd*, i64)* @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0__8455, void (i8*, i8*, %Complexd*, i64)** %closure.func8529
%closure_size8530 = call i64 @llvm_zone_mark_size(%mzone* %zone8515)
call void @llvm_zone_ptr_set_size(i8* %clsptr8516, i64 %closure_size8530)
%wrapper_ptr8531 = call i8* @llvm_zone_malloc(%mzone* %zone8515, i64 8)
%closure_wrapper8532 = bitcast i8* %wrapper_ptr8531 to { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}**
store { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure8517, { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** %closure_wrapper8532

; let value assignment
%cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0 = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** %closure_wrapper8532, { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** %closure_wrapper8532
store { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** %cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0, { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}*** %cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0
%tmp_envptr8526 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}***}* %environment8519, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}*** %cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0Ptr, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}**** %tmp_envptr8526


%val8535 = load {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}**, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}*** %cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0Ptr
ret {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** %val8535
}


@cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0(%Complexd* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc void @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_native(%Complexd* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc i8*  @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8536 = bitcast [99 x i8]* @gsxtmmath343 to i8*
call i32 (i8*, ...) @printf(i8* %var8536)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexd*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var8537 = bitcast [99 x i8]* @gsxtmmath343 to i8*
call i32 (i8*, ...) @printf(i8* %var8537)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd*, i64}*
%arg_p_0 = getelementptr {%Complexd*, i64}, {%Complexd*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd*, %Complexd** %arg_p_0
%arg_p_1 = getelementptr {%Complexd*, i64}, {%Complexd*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath344 = hidden constant [45 x i8] c"pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ\00"
define dllexport fastcc %Complexd @pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ__8538(i8* %_impz,i8* %_impenv, %Complexd %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8539 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***}*
%pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQPtr_ = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***}* %impenv, i32 0, i32 0
%pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQPtr = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**** %pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQPtr_

; setup arguments
%aPtr = alloca %Complexd
store %Complexd %a, %Complexd* %aPtr


%val8540 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8541 = extractvalue %Complexd %val8540, 0
%val8542 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8543 = extractvalue %Complexd %val8542, 1
%val8544 = call double @llvm.cos.f64(double %val8543)
%val8545 = fmul double %val8541, %val8544
%val8546 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8547 = extractvalue %Complexd %val8546, 0
%val8548 = load %Complexd, %Complexd* %aPtr
; tuple ref
%val8549 = extractvalue %Complexd %val8548, 1
%val8550 = call double @llvm.sin.f64(double %val8549)
%val8551 = fmul double %val8547, %val8550
%res8552 = call fastcc %Complexd @Cpxd_adhoc_W0NvbXBsZXhkLGRvdWJsZSxkb3VibGVd(double %val8545, double %val8551)
ret %Complexd %res8552
}
define dllexport ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** @pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8572 = load i8*, i8** %_impzPtr
%zone8573 = bitcast i8* %tzone8572 to %mzone*

; let assign value to symbol pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ
%dat_pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ = call i8* @llvm_zone_malloc(%mzone* %zone8573, i64 8)
%pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQPtr = bitcast i8* %dat_pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ to { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***
%tzone8553 = load i8*, i8** %_impzPtr
%zone8554 = bitcast i8* %tzone8553 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8554)
; malloc closure structure
%clsptr8555 = call i8* @llvm_zone_malloc(%mzone* %zone8554, i64 24)
%closure8556 = bitcast i8* %clsptr8555 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}*

; malloc environment structure
%envptr8557 = call i8* @llvm_zone_malloc(%mzone* %zone8554, i64 8)
%environment8558 = bitcast i8* %envptr8557 to {{i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***}*

; malloc closure address table
%addytable8559 = call %clsvar* @new_address_table()
%var8560 = bitcast [45 x i8]* @gsxtmmath344 to i8*
%var8561 = bitcast [47 x i8]* @gsxtmmath339 to i8*
%addytable8562 = call %clsvar* @add_address_table(%mzone* %zone8554, i8* %var8560, i32 0, i8* %var8561, i32 3, %clsvar* %addytable8559)
%address-table8563 = bitcast %clsvar* %addytable8562 to i8*

; insert table, function and environment into closure struct
%closure.table8566 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure8556, i32 0, i32 0
store i8* %address-table8563, i8** %closure.table8566
%closure.env8567 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure8556, i32 0, i32 1
store i8* %envptr8557, i8** %closure.env8567
%closure.func8568 = getelementptr { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure8556, i32 0, i32 2
store %Complexd (i8*, i8*, %Complexd)* @pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ__8538, %Complexd (i8*, i8*, %Complexd)** %closure.func8568
%closure_size8569 = call i64 @llvm_zone_mark_size(%mzone* %zone8554)
call void @llvm_zone_ptr_set_size(i8* %clsptr8555, i64 %closure_size8569)
%wrapper_ptr8570 = call i8* @llvm_zone_malloc(%mzone* %zone8554, i64 8)
%closure_wrapper8571 = bitcast i8* %wrapper_ptr8570 to { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure8556, { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %closure_wrapper8571

; let value assignment
%pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ = select i1 true, { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %closure_wrapper8571, { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %closure_wrapper8571
store { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ, { i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}*** %pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQPtr

; add data to environment
; don't need to alloc for env var pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ
%tmp_envptr8565 = getelementptr {{i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***}, {{i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}***}* %environment8558, i32 0, i32 0
store {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}*** %pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQPtr, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**** %tmp_envptr8565


%val8574 = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}*** %pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQPtr
ret {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %val8574
}


@pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var = dllexport global [1 x i8*] [ i8* null ]

@pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** @pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexd @pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ(%Complexd %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd)*,  %Complexd (i8*, i8*, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0)
ret %Complexd %result
}


define dllexport ccc %Complexd @pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_native(%Complexd %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd)*,  %Complexd (i8*, i8*, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0)
ret %Complexd %result
}


define dllexport ccc void @pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd}*
%arg_p_0 = getelementptr {%Complexd}, {%Complexd}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd, %Complexd* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W0NvbXBsZXhkLENvbXBsZXhkXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}**
%closure = load {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}*, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}, {i8*, i8*, %Complexd (i8*, i8*, %Complexd)*}* %closure, i32 0, i32 1
%ff = load  %Complexd (i8*, i8*, %Complexd)*,  %Complexd (i8*, i8*, %Complexd)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexd %ff(i8* %_impz, i8* %ee, %Complexd %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath345 = hidden constant [46 x i8] c"pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0\00"
define dllexport fastcc void @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0__8575(i8* %_impz,i8* %_impenv, %Complexd* %a, i64 %n) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8576 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}***}*
%pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}***}* %impenv, i32 0, i32 0
%pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0Ptr = load {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}***, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}**** %pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0Ptr_

; setup arguments
%aPtr = alloca %Complexd*
store %Complexd* %a, %Complexd** %aPtr
%nPtr = alloca i64
store i64 %n, i64* %nPtr


%tzone8577 = load i8*, i8** %_impzPtr
%zone8578 = bitcast i8* %tzone8577 to %mzone*

; let assign value to symbol temp
%tempPtr = alloca double

; let value assignment
%temp = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %temp, double* %tempPtr

%tzone8580 = load i8*, i8** %_impzPtr
%zone8581 = bitcast i8* %tzone8580 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val8579 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val8579, i64 %val8579
store i64 %i, i64* %iPtr

; setup loop
%val8584 = load i64, i64* %nPtr
store i64 0, i64* %iPtr
%val8618 = load i64, i64* %iPtr
%num8619 = add i64 %val8584, %val8618
%comp8620 = icmp ult i64 %val8584, 1
br i1 %comp8620, label %after8582, label %loop8582

loop8582:
; do set!
%val8585 = load i64, i64* %iPtr
%val8586 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val8587 = getelementptr %Complexd, %Complexd* %val8586, i64 %val8585
%val8588 = load %Complexd, %Complexd* %val8587
; tuple ref
%val8589 = extractvalue %Complexd %val8588, 0
%val8590 = load i64, i64* %iPtr
%val8591 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val8592 = getelementptr %Complexd, %Complexd* %val8591, i64 %val8590
%val8593 = load %Complexd, %Complexd* %val8592
; tuple ref
%val8594 = extractvalue %Complexd %val8593, 1
%val8595 = call double @llvm.cos.f64(double %val8594)
%val8596 = fmul double %val8589, %val8595
store double %val8596, double* %tempPtr
%val8597 = load i64, i64* %iPtr
%val8598 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val8599 = getelementptr %Complexd, %Complexd* %val8598, i64 %val8597
%val8600 = load i64, i64* %iPtr
%val8601 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val8602 = getelementptr %Complexd, %Complexd* %val8601, i64 %val8600
%val8603 = load %Complexd, %Complexd* %val8602
; tuple ref
%val8604 = extractvalue %Complexd %val8603, 0
%val8605 = load i64, i64* %iPtr
%val8606 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val8607 = getelementptr %Complexd, %Complexd* %val8606, i64 %val8605
%val8608 = load %Complexd, %Complexd* %val8607
; tuple ref
%val8609 = extractvalue %Complexd %val8608, 1
%val8610 = call double @llvm.sin.f64(double %val8609)
%val8611 = fmul double %val8604, %val8610
; set tuple
%val8612 = getelementptr %Complexd, %Complexd* %val8599, i64 0, i32 1
store double %val8611, double* %val8612
%val8613 = load i64, i64* %iPtr
%val8614 = load %Complexd*, %Complexd** %aPtr
; pointer ref
%val8615 = getelementptr %Complexd, %Complexd* %val8614, i64 %val8613
%val8616 = load double, double* %tempPtr
; set tuple
%val8617 = getelementptr %Complexd, %Complexd* %val8615, i64 0, i32 0
store double %val8616, double* %val8617
%loop_cnt8582 = load i64, i64* %iPtr
%next8582 = add i64 %loop_cnt8582, 1
store i64 %next8582, i64* %iPtr
%cmp8582 = icmp ult i64 %next8582, %num8619
br i1 %cmp8582, label %loop8582, label %after8582

after8582:
ret void
}
@gsxtmmath346 = hidden constant [99 x i8] c"pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8642 = load i8*, i8** %_impzPtr
%zone8643 = bitcast i8* %tzone8642 to %mzone*

; let assign value to symbol pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0
%dat_pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone8643, i64 8)
%pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0Ptr = bitcast i8* %dat_pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0 to { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}***
%tzone8623 = load i8*, i8** %_impzPtr
%zone8624 = bitcast i8* %tzone8623 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8624)
; malloc closure structure
%clsptr8625 = call i8* @llvm_zone_malloc(%mzone* %zone8624, i64 24)
%closure8626 = bitcast i8* %clsptr8625 to { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}*

; malloc environment structure
%envptr8627 = call i8* @llvm_zone_malloc(%mzone* %zone8624, i64 8)
%environment8628 = bitcast i8* %envptr8627 to {{i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}***}*

; malloc closure address table
%addytable8629 = call %clsvar* @new_address_table()
%var8630 = bitcast [46 x i8]* @gsxtmmath345 to i8*
%var8631 = bitcast [48 x i8]* @gsxtmmath342 to i8*
%addytable8632 = call %clsvar* @add_address_table(%mzone* %zone8624, i8* %var8630, i32 0, i8* %var8631, i32 3, %clsvar* %addytable8629)
%address-table8633 = bitcast %clsvar* %addytable8632 to i8*

; insert table, function and environment into closure struct
%closure.table8636 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure8626, i32 0, i32 0
store i8* %address-table8633, i8** %closure.table8636
%closure.env8637 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure8626, i32 0, i32 1
store i8* %envptr8627, i8** %closure.env8637
%closure.func8638 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure8626, i32 0, i32 2
store void (i8*, i8*, %Complexd*, i64)* @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0__8575, void (i8*, i8*, %Complexd*, i64)** %closure.func8638
%closure_size8639 = call i64 @llvm_zone_mark_size(%mzone* %zone8624)
call void @llvm_zone_ptr_set_size(i8* %clsptr8625, i64 %closure_size8639)
%wrapper_ptr8640 = call i8* @llvm_zone_malloc(%mzone* %zone8624, i64 8)
%closure_wrapper8641 = bitcast i8* %wrapper_ptr8640 to { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}**
store { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure8626, { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** %closure_wrapper8641

; let value assignment
%pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0 = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** %closure_wrapper8641, { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** %closure_wrapper8641
store { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** %pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0, { i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}*** %pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0
%tmp_envptr8635 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}***}* %environment8628, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}*** %pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0Ptr, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}**** %tmp_envptr8635


%val8644 = load {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}**, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}*** %pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0Ptr
ret {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** %val8644
}


@pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0(%Complexd* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc void @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_native(%Complexd* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc i8*  @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8645 = bitcast [99 x i8]* @gsxtmmath346 to i8*
call i32 (i8*, ...) @printf(i8* %var8645)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexd*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var8646 = bitcast [99 x i8]* @gsxtmmath346 to i8*
call i32 (i8*, ...) @printf(i8* %var8646)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd*, i64}*
%arg_p_0 = getelementptr {%Complexd*, i64}, {%Complexd*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd*, %Complexd** %arg_p_0
%arg_p_1 = getelementptr {%Complexd*, i64}, {%Complexd*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, i64)*,  void (i8*, i8*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%Complexf = type {float,float}
@gsxtmmath347 = hidden constant [47 x i8] c"Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0\00"
@gsxtmmath348 = hidden constant [51 x i8] c"{i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**\00"
define dllexport fastcc %Complexf* @Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0__8647(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8648 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***}*
%Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0Ptr_ = getelementptr {{i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***}, {{i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***}* %impenv, i32 0, i32 0
%Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0Ptr = load {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**** %Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0Ptr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr


%tzone8653 = load i8*, i8** %_impzPtr
%zone8654 = bitcast i8* %tzone8653 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Complexf*
%tzone8649 = load i8*, i8** %_impzPtr
%zone8650 = bitcast i8* %tzone8649 to %mzone*
%dat8651 = call i8* @llvm_zone_malloc(%mzone* %zone8650, i64 8)
call i8* @memset(i8* %dat8651, i32 0, i64 8)
%val8652 = bitcast i8* %dat8651 to %Complexf*

; let value assignment
%obj = select i1 true, %Complexf* %val8652, %Complexf* %val8652
store %Complexf* %obj, %Complexf** %objPtr

%val8655 = load %Complexf*, %Complexf** %objPtr
%val8656 = load float, float* %arg_0Ptr
; set tuple
%val8657 = getelementptr %Complexf, %Complexf* %val8655, i64 0, i32 0
store float %val8656, float* %val8657
%val8658 = load %Complexf*, %Complexf** %objPtr
%val8659 = load float, float* %arg_1Ptr
; set tuple
%val8660 = getelementptr %Complexf, %Complexf* %val8658, i64 0, i32 1
store float %val8659, float* %val8660
%val8661 = load %Complexf*, %Complexf** %objPtr
ret %Complexf* %val8661
}
@gsxtmmath349 = hidden constant [100 x i8] c"Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** @Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8681 = load i8*, i8** %_impzPtr
%zone8682 = bitcast i8* %tzone8681 to %mzone*

; let assign value to symbol Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0
%dat_Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0 = call i8* @llvm_zone_malloc(%mzone* %zone8682, i64 8)
%Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0Ptr = bitcast i8* %dat_Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0 to { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***
%tzone8662 = load i8*, i8** %_impzPtr
%zone8663 = bitcast i8* %tzone8662 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8663)
; malloc closure structure
%clsptr8664 = call i8* @llvm_zone_malloc(%mzone* %zone8663, i64 24)
%closure8665 = bitcast i8* %clsptr8664 to { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*

; malloc environment structure
%envptr8666 = call i8* @llvm_zone_malloc(%mzone* %zone8663, i64 8)
%environment8667 = bitcast i8* %envptr8666 to {{i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***}*

; malloc closure address table
%addytable8668 = call %clsvar* @new_address_table()
%var8669 = bitcast [47 x i8]* @gsxtmmath347 to i8*
%var8670 = bitcast [51 x i8]* @gsxtmmath348 to i8*
%addytable8671 = call %clsvar* @add_address_table(%mzone* %zone8663, i8* %var8669, i32 0, i8* %var8670, i32 3, %clsvar* %addytable8668)
%address-table8672 = bitcast %clsvar* %addytable8671 to i8*

; insert table, function and environment into closure struct
%closure.table8675 = getelementptr { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure8665, i32 0, i32 0
store i8* %address-table8672, i8** %closure.table8675
%closure.env8676 = getelementptr { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure8665, i32 0, i32 1
store i8* %envptr8666, i8** %closure.env8676
%closure.func8677 = getelementptr { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure8665, i32 0, i32 2
store %Complexf* (i8*, i8*, float, float)* @Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0__8647, %Complexf* (i8*, i8*, float, float)** %closure.func8677
%closure_size8678 = call i64 @llvm_zone_mark_size(%mzone* %zone8663)
call void @llvm_zone_ptr_set_size(i8* %clsptr8664, i64 %closure_size8678)
%wrapper_ptr8679 = call i8* @llvm_zone_malloc(%mzone* %zone8663, i64 8)
%closure_wrapper8680 = bitcast i8* %wrapper_ptr8679 to { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**
store { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure8665, { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure_wrapper8680

; let value assignment
%Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0 = select i1 true, { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure_wrapper8680, { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure_wrapper8680
store { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0, { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*** %Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0Ptr

; add data to environment
; don't need to alloc for env var Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0
%tmp_envptr8674 = getelementptr {{i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***}, {{i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***}* %environment8667, i32 0, i32 0
store {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*** %Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0Ptr, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**** %tmp_envptr8674


%val8683 = load {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*** %Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0Ptr
ret {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %val8683
}


@Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var = dllexport global [1 x i8*] [ i8* null ]

@Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** @Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf* @Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf* (i8*, i8*, float, float)*,  %Complexf* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %Complexf* %result
}


define dllexport ccc %Complexf* @Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_native(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf* (i8*, i8*, float, float)*,  %Complexf* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %Complexf* %result
}


define dllexport ccc i8*  @Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8684 = bitcast [100 x i8]* @gsxtmmath349 to i8*
call i32 (i8*, ...) @printf(i8* %var8684)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var8685 = bitcast [100 x i8]* @gsxtmmath349 to i8*
call i32 (i8*, ...) @printf(i8* %var8685)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf* (i8*, i8*, float, float)*,  %Complexf* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%tmpres = bitcast %Complexf* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float}*
%arg_p_0 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexf_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf* (i8*, i8*, float, float)*,  %Complexf* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath350 = hidden constant [49 x i8] c"Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0\00"
define dllexport fastcc %Complexf* @Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0__8686(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8687 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***}*
%Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0Ptr_ = getelementptr {{i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***}, {{i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***}* %impenv, i32 0, i32 0
%Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0Ptr = load {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**** %Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0Ptr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr


%tzone8692 = load i8*, i8** %_impzPtr
%zone8693 = bitcast i8* %tzone8692 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Complexf*
%tzone8688 = load i8*, i8** %_impzPtr
%zone8689 = bitcast i8* %tzone8688 to %mzone*
%dat8690 = call i8* @llvm_zone_malloc(%mzone* %zone8689, i64 8)
call i8* @memset(i8* %dat8690, i32 0, i64 8)
%val8691 = bitcast i8* %dat8690 to %Complexf*

; let value assignment
%obj = select i1 true, %Complexf* %val8691, %Complexf* %val8691
store %Complexf* %obj, %Complexf** %objPtr

%val8694 = load %Complexf*, %Complexf** %objPtr
%val8695 = load float, float* %arg_0Ptr
; set tuple
%val8696 = getelementptr %Complexf, %Complexf* %val8694, i64 0, i32 0
store float %val8695, float* %val8696
%val8697 = load %Complexf*, %Complexf** %objPtr
%val8698 = load float, float* %arg_1Ptr
; set tuple
%val8699 = getelementptr %Complexf, %Complexf* %val8697, i64 0, i32 1
store float %val8698, float* %val8699
%val8700 = load %Complexf*, %Complexf** %objPtr
ret %Complexf* %val8700
}
@gsxtmmath351 = hidden constant [102 x i8] c"Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** @Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8720 = load i8*, i8** %_impzPtr
%zone8721 = bitcast i8* %tzone8720 to %mzone*

; let assign value to symbol Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0
%dat_Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0 = call i8* @llvm_zone_malloc(%mzone* %zone8721, i64 8)
%Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0Ptr = bitcast i8* %dat_Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0 to { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***
%tzone8701 = load i8*, i8** %_impzPtr
%zone8702 = bitcast i8* %tzone8701 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8702)
; malloc closure structure
%clsptr8703 = call i8* @llvm_zone_malloc(%mzone* %zone8702, i64 24)
%closure8704 = bitcast i8* %clsptr8703 to { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*

; malloc environment structure
%envptr8705 = call i8* @llvm_zone_malloc(%mzone* %zone8702, i64 8)
%environment8706 = bitcast i8* %envptr8705 to {{i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***}*

; malloc closure address table
%addytable8707 = call %clsvar* @new_address_table()
%var8708 = bitcast [49 x i8]* @gsxtmmath350 to i8*
%var8709 = bitcast [51 x i8]* @gsxtmmath348 to i8*
%addytable8710 = call %clsvar* @add_address_table(%mzone* %zone8702, i8* %var8708, i32 0, i8* %var8709, i32 3, %clsvar* %addytable8707)
%address-table8711 = bitcast %clsvar* %addytable8710 to i8*

; insert table, function and environment into closure struct
%closure.table8714 = getelementptr { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure8704, i32 0, i32 0
store i8* %address-table8711, i8** %closure.table8714
%closure.env8715 = getelementptr { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure8704, i32 0, i32 1
store i8* %envptr8705, i8** %closure.env8715
%closure.func8716 = getelementptr { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure8704, i32 0, i32 2
store %Complexf* (i8*, i8*, float, float)* @Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0__8686, %Complexf* (i8*, i8*, float, float)** %closure.func8716
%closure_size8717 = call i64 @llvm_zone_mark_size(%mzone* %zone8702)
call void @llvm_zone_ptr_set_size(i8* %clsptr8703, i64 %closure_size8717)
%wrapper_ptr8718 = call i8* @llvm_zone_malloc(%mzone* %zone8702, i64 8)
%closure_wrapper8719 = bitcast i8* %wrapper_ptr8718 to { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**
store { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure8704, { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure_wrapper8719

; let value assignment
%Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0 = select i1 true, { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure_wrapper8719, { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure_wrapper8719
store { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0, { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*** %Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0Ptr

; add data to environment
; don't need to alloc for env var Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0
%tmp_envptr8713 = getelementptr {{i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***}, {{i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***}* %environment8706, i32 0, i32 0
store {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*** %Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0Ptr, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**** %tmp_envptr8713


%val8722 = load {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*** %Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0Ptr
ret {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %val8722
}


@Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var = dllexport global [1 x i8*] [ i8* null ]

@Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** @Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf* @Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf* (i8*, i8*, float, float)*,  %Complexf* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %Complexf* %result
}


define dllexport ccc %Complexf* @Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_native(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf* (i8*, i8*, float, float)*,  %Complexf* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %Complexf* %result
}


define dllexport ccc i8*  @Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8723 = bitcast [102 x i8]* @gsxtmmath351 to i8*
call i32 (i8*, ...) @printf(i8* %var8723)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var8724 = bitcast [102 x i8]* @gsxtmmath351 to i8*
call i32 (i8*, ...) @printf(i8* %var8724)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf* (i8*, i8*, float, float)*,  %Complexf* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%tmpres = bitcast %Complexf* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float}*
%arg_p_0 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexf_z_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf* (i8*, i8*, float, float)*,  %Complexf* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath352 = hidden constant [49 x i8] c"Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0\00"
define dllexport fastcc %Complexf* @Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0__8725(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8726 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***}*
%Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0Ptr_ = getelementptr {{i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***}, {{i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***}* %impenv, i32 0, i32 0
%Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0Ptr = load {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**** %Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0Ptr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr


%tzone8729 = load i8*, i8** %_impzPtr
%zone8730 = bitcast i8* %tzone8729 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Complexf*
%dat8727 = call i8* @malloc(i64 8)
call i8* @memset(i8* %dat8727, i32 0, i64 8)
%val8728 = bitcast i8* %dat8727 to %Complexf*

; let value assignment
%obj = select i1 true, %Complexf* %val8728, %Complexf* %val8728
store %Complexf* %obj, %Complexf** %objPtr

%val8731 = load %Complexf*, %Complexf** %objPtr
%val8732 = load float, float* %arg_0Ptr
; set tuple
%val8733 = getelementptr %Complexf, %Complexf* %val8731, i64 0, i32 0
store float %val8732, float* %val8733
%val8734 = load %Complexf*, %Complexf** %objPtr
%val8735 = load float, float* %arg_1Ptr
; set tuple
%val8736 = getelementptr %Complexf, %Complexf* %val8734, i64 0, i32 1
store float %val8735, float* %val8736
%val8737 = load %Complexf*, %Complexf** %objPtr
ret %Complexf* %val8737
}
@gsxtmmath353 = hidden constant [102 x i8] c"Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** @Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8757 = load i8*, i8** %_impzPtr
%zone8758 = bitcast i8* %tzone8757 to %mzone*

; let assign value to symbol Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0
%dat_Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0 = call i8* @llvm_zone_malloc(%mzone* %zone8758, i64 8)
%Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0Ptr = bitcast i8* %dat_Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0 to { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***
%tzone8738 = load i8*, i8** %_impzPtr
%zone8739 = bitcast i8* %tzone8738 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8739)
; malloc closure structure
%clsptr8740 = call i8* @llvm_zone_malloc(%mzone* %zone8739, i64 24)
%closure8741 = bitcast i8* %clsptr8740 to { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*

; malloc environment structure
%envptr8742 = call i8* @llvm_zone_malloc(%mzone* %zone8739, i64 8)
%environment8743 = bitcast i8* %envptr8742 to {{i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***}*

; malloc closure address table
%addytable8744 = call %clsvar* @new_address_table()
%var8745 = bitcast [49 x i8]* @gsxtmmath352 to i8*
%var8746 = bitcast [51 x i8]* @gsxtmmath348 to i8*
%addytable8747 = call %clsvar* @add_address_table(%mzone* %zone8739, i8* %var8745, i32 0, i8* %var8746, i32 3, %clsvar* %addytable8744)
%address-table8748 = bitcast %clsvar* %addytable8747 to i8*

; insert table, function and environment into closure struct
%closure.table8751 = getelementptr { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure8741, i32 0, i32 0
store i8* %address-table8748, i8** %closure.table8751
%closure.env8752 = getelementptr { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure8741, i32 0, i32 1
store i8* %envptr8742, i8** %closure.env8752
%closure.func8753 = getelementptr { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure8741, i32 0, i32 2
store %Complexf* (i8*, i8*, float, float)* @Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0__8725, %Complexf* (i8*, i8*, float, float)** %closure.func8753
%closure_size8754 = call i64 @llvm_zone_mark_size(%mzone* %zone8739)
call void @llvm_zone_ptr_set_size(i8* %clsptr8740, i64 %closure_size8754)
%wrapper_ptr8755 = call i8* @llvm_zone_malloc(%mzone* %zone8739, i64 8)
%closure_wrapper8756 = bitcast i8* %wrapper_ptr8755 to { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**
store { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure8741, { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure_wrapper8756

; let value assignment
%Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0 = select i1 true, { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure_wrapper8756, { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure_wrapper8756
store { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0, { i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*** %Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0Ptr

; add data to environment
; don't need to alloc for env var Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0
%tmp_envptr8750 = getelementptr {{i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***}, {{i8*, i8*, %Complexf* (i8*, i8*, float, float)*}***}* %environment8743, i32 0, i32 0
store {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*** %Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0Ptr, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**** %tmp_envptr8750


%val8759 = load {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*** %Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0Ptr
ret {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %val8759
}


@Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var = dllexport global [1 x i8*] [ i8* null ]

@Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** @Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf* @Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf* (i8*, i8*, float, float)*,  %Complexf* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %Complexf* %result
}


define dllexport ccc %Complexf* @Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_native(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf* (i8*, i8*, float, float)*,  %Complexf* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %Complexf* %result
}


define dllexport ccc i8*  @Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8760 = bitcast [102 x i8]* @gsxtmmath353 to i8*
call i32 (i8*, ...) @printf(i8* %var8760)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var8761 = bitcast [102 x i8]* @gsxtmmath353 to i8*
call i32 (i8*, ...) @printf(i8* %var8761)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf* (i8*, i8*, float, float)*,  %Complexf* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%tmpres = bitcast %Complexf* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float}*
%arg_p_0 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexf_h_adhoc_W0NvbXBsZXhmKixmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}*, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf* (i8*, i8*, float, float)*,  %Complexf* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath354 = hidden constant [50 x i8] c"Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ\00"
@gsxtmmath355 = hidden constant [50 x i8] c"{i8*, i8*, %Complexf (i8*, i8*, float, float)*}**\00"
define dllexport fastcc %Complexf @Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ__8762(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8763 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf (i8*, i8*, float, float)*}***}*
%Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, float, float)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, float, float)*}***}* %impenv, i32 0, i32 0
%Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, %Complexf (i8*, i8*, float, float)*}***, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}**** %Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr


%tzone8765 = load i8*, i8** %_impzPtr
%zone8766 = bitcast i8* %tzone8765 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Complexf*
%dat8764 = alloca %Complexf, align 16

; let value assignment
%obj = select i1 true, %Complexf* %dat8764, %Complexf* %dat8764
store %Complexf* %obj, %Complexf** %objPtr

%val8767 = load %Complexf*, %Complexf** %objPtr
%val8768 = load float, float* %arg_0Ptr
; set tuple
%val8769 = getelementptr %Complexf, %Complexf* %val8767, i64 0, i32 0
store float %val8768, float* %val8769
%val8770 = load %Complexf*, %Complexf** %objPtr
%val8771 = load float, float* %arg_1Ptr
; set tuple
%val8772 = getelementptr %Complexf, %Complexf* %val8770, i64 0, i32 1
store float %val8771, float* %val8772
%val8773 = load %Complexf*, %Complexf** %objPtr
; pointer ref
%val8774 = getelementptr %Complexf, %Complexf* %val8773, i64 0
%val8775 = load %Complexf, %Complexf* %val8774
ret %Complexf %val8775
}
@gsxtmmath356 = hidden constant [103 x i8] c"Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexf (i8*, i8*, float, float)*}** @Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8795 = load i8*, i8** %_impzPtr
%zone8796 = bitcast i8* %tzone8795 to %mzone*

; let assign value to symbol Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ
%dat_Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone8796, i64 8)
%Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ to { i8*, i8*, %Complexf (i8*, i8*, float, float)*}***
%tzone8776 = load i8*, i8** %_impzPtr
%zone8777 = bitcast i8* %tzone8776 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8777)
; malloc closure structure
%clsptr8778 = call i8* @llvm_zone_malloc(%mzone* %zone8777, i64 24)
%closure8779 = bitcast i8* %clsptr8778 to { i8*, i8*, %Complexf (i8*, i8*, float, float)*}*

; malloc environment structure
%envptr8780 = call i8* @llvm_zone_malloc(%mzone* %zone8777, i64 8)
%environment8781 = bitcast i8* %envptr8780 to {{i8*, i8*, %Complexf (i8*, i8*, float, float)*}***}*

; malloc closure address table
%addytable8782 = call %clsvar* @new_address_table()
%var8783 = bitcast [50 x i8]* @gsxtmmath354 to i8*
%var8784 = bitcast [50 x i8]* @gsxtmmath355 to i8*
%addytable8785 = call %clsvar* @add_address_table(%mzone* %zone8777, i8* %var8783, i32 0, i8* %var8784, i32 3, %clsvar* %addytable8782)
%address-table8786 = bitcast %clsvar* %addytable8785 to i8*

; insert table, function and environment into closure struct
%closure.table8789 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, float, float)*}, { i8*, i8*, %Complexf (i8*, i8*, float, float)*}* %closure8779, i32 0, i32 0
store i8* %address-table8786, i8** %closure.table8789
%closure.env8790 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, float, float)*}, { i8*, i8*, %Complexf (i8*, i8*, float, float)*}* %closure8779, i32 0, i32 1
store i8* %envptr8780, i8** %closure.env8790
%closure.func8791 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, float, float)*}, { i8*, i8*, %Complexf (i8*, i8*, float, float)*}* %closure8779, i32 0, i32 2
store %Complexf (i8*, i8*, float, float)* @Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ__8762, %Complexf (i8*, i8*, float, float)** %closure.func8791
%closure_size8792 = call i64 @llvm_zone_mark_size(%mzone* %zone8777)
call void @llvm_zone_ptr_set_size(i8* %clsptr8778, i64 %closure_size8792)
%wrapper_ptr8793 = call i8* @llvm_zone_malloc(%mzone* %zone8777, i64 8)
%closure_wrapper8794 = bitcast i8* %wrapper_ptr8793 to { i8*, i8*, %Complexf (i8*, i8*, float, float)*}**
store { i8*, i8*, %Complexf (i8*, i8*, float, float)*}* %closure8779, { i8*, i8*, %Complexf (i8*, i8*, float, float)*}** %closure_wrapper8794

; let value assignment
%Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, %Complexf (i8*, i8*, float, float)*}** %closure_wrapper8794, { i8*, i8*, %Complexf (i8*, i8*, float, float)*}** %closure_wrapper8794
store { i8*, i8*, %Complexf (i8*, i8*, float, float)*}** %Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ, { i8*, i8*, %Complexf (i8*, i8*, float, float)*}*** %Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ
%tmp_envptr8788 = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, float, float)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, float, float)*}***}* %environment8781, i32 0, i32 0
store {i8*, i8*, %Complexf (i8*, i8*, float, float)*}*** %Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}**** %tmp_envptr8788


%val8797 = load {i8*, i8*, %Complexf (i8*, i8*, float, float)*}**, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}*** %Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, %Complexf (i8*, i8*, float, float)*}** %val8797
}


@Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf (i8*, i8*, float, float)*}** @Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf (i8*, i8*, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf @Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, float, float)*}*, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, float, float)*,  %Complexf (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %Complexf %result
}


define dllexport ccc %Complexf @Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_native(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, float, float)*}*, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, float, float)*,  %Complexf (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %Complexf %result
}


define dllexport ccc void @Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float}*
%arg_p_0 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complexf_val_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, float, float)*}*, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, float, float)*,  %Complexf (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath357 = hidden constant [41 x i8] c"hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd\00"
@gsxtmmath358 = hidden constant [49 x i8] c"{i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}**\00"
define dllexport fastcc %Complexf* @hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd__8800(i8* %_impz,i8* %_impenv, %Complexf* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8801 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}***}*
%hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZipdPtr_ = getelementptr {{i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}***}, {{i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZipdPtr = load {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}***, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}**** %hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZipdPtr_

; setup arguments
%xPtr = alloca %Complexf*
store %Complexf* %x, %Complexf** %xPtr


%tzone8804 = load i8*, i8** %_impzPtr
%zone8805 = bitcast i8* %tzone8804 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Complexf*
%dat8802 = call i8* @malloc(i64 8)
call i8* @memset(i8* %dat8802, i32 0, i64 8)
%val8803 = bitcast i8* %dat8802 to %Complexf*

; let value assignment
%obj = select i1 true, %Complexf* %val8803, %Complexf* %val8803
store %Complexf* %obj, %Complexf** %objPtr

%val8806 = load %Complexf*, %Complexf** %objPtr
%val8807 = load %Complexf*, %Complexf** %xPtr
; tuple ref
%val8808 = getelementptr %Complexf, %Complexf* %val8807, i64 0, i32 0
%val8809 = load float, float* %val8808
; set tuple
%val8810 = getelementptr %Complexf, %Complexf* %val8806, i64 0, i32 0
store float %val8809, float* %val8810
%val8811 = load %Complexf*, %Complexf** %objPtr
%val8812 = load %Complexf*, %Complexf** %xPtr
; tuple ref
%val8813 = getelementptr %Complexf, %Complexf* %val8812, i64 0, i32 1
%val8814 = load float, float* %val8813
; set tuple
%val8815 = getelementptr %Complexf, %Complexf* %val8811, i64 0, i32 1
store float %val8814, float* %val8815
%val8816 = load %Complexf*, %Complexf** %objPtr
ret %Complexf* %val8816
}
@gsxtmmath359 = hidden constant [94 x i8] c"hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}** @hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8836 = load i8*, i8** %_impzPtr
%zone8837 = bitcast i8* %tzone8836 to %mzone*

; let assign value to symbol hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd
%dat_hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd = call i8* @llvm_zone_malloc(%mzone* %zone8837, i64 8)
%hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZipdPtr = bitcast i8* %dat_hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd to { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}***
%tzone8817 = load i8*, i8** %_impzPtr
%zone8818 = bitcast i8* %tzone8817 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8818)
; malloc closure structure
%clsptr8819 = call i8* @llvm_zone_malloc(%mzone* %zone8818, i64 24)
%closure8820 = bitcast i8* %clsptr8819 to { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}*

; malloc environment structure
%envptr8821 = call i8* @llvm_zone_malloc(%mzone* %zone8818, i64 8)
%environment8822 = bitcast i8* %envptr8821 to {{i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}***}*

; malloc closure address table
%addytable8823 = call %clsvar* @new_address_table()
%var8824 = bitcast [41 x i8]* @gsxtmmath357 to i8*
%var8825 = bitcast [49 x i8]* @gsxtmmath358 to i8*
%addytable8826 = call %clsvar* @add_address_table(%mzone* %zone8818, i8* %var8824, i32 0, i8* %var8825, i32 3, %clsvar* %addytable8823)
%address-table8827 = bitcast %clsvar* %addytable8826 to i8*

; insert table, function and environment into closure struct
%closure.table8830 = getelementptr { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}, { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}* %closure8820, i32 0, i32 0
store i8* %address-table8827, i8** %closure.table8830
%closure.env8831 = getelementptr { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}, { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}* %closure8820, i32 0, i32 1
store i8* %envptr8821, i8** %closure.env8831
%closure.func8832 = getelementptr { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}, { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}* %closure8820, i32 0, i32 2
store %Complexf* (i8*, i8*, %Complexf*)* @hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd__8800, %Complexf* (i8*, i8*, %Complexf*)** %closure.func8832
%closure_size8833 = call i64 @llvm_zone_mark_size(%mzone* %zone8818)
call void @llvm_zone_ptr_set_size(i8* %clsptr8819, i64 %closure_size8833)
%wrapper_ptr8834 = call i8* @llvm_zone_malloc(%mzone* %zone8818, i64 8)
%closure_wrapper8835 = bitcast i8* %wrapper_ptr8834 to { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}**
store { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}* %closure8820, { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}** %closure_wrapper8835

; let value assignment
%hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd = select i1 true, { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}** %closure_wrapper8835, { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}** %closure_wrapper8835
store { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}** %hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd, { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}*** %hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZipdPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd
%tmp_envptr8829 = getelementptr {{i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}***}, {{i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}***}* %environment8822, i32 0, i32 0
store {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}*** %hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZipdPtr, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}**** %tmp_envptr8829


%val8838 = load {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}**, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}*** %hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZipdPtr
ret {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}** %val8838
}


@hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}** @hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf* @hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd(%Complexf* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}**
%closure = load {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}*, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 1
%ff = load  %Complexf* (i8*, i8*, %Complexf*)*,  %Complexf* (i8*, i8*, %Complexf*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf* %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0)
ret %Complexf* %result
}


define dllexport ccc %Complexf* @hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd_native(%Complexf* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}**
%closure = load {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}*, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 1
%ff = load  %Complexf* (i8*, i8*, %Complexf*)*,  %Complexf* (i8*, i8*, %Complexf*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf* %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0)
ret %Complexf* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8839 = bitcast [94 x i8]* @gsxtmmath359 to i8*
call i32 (i8*, ...) @printf(i8* %var8839)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexf*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}**
%closure = load {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}*, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 1
%ff = load  %Complexf* (i8*, i8*, %Complexf*)*,  %Complexf* (i8*, i8*, %Complexf*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf* %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0)
%tmpres = bitcast %Complexf* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf*}*
%arg_p_0 = getelementptr {%Complexf*}, {%Complexf*}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf*, %Complexf** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4Zipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}**
%closure = load {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}*, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 1
%ff = load  %Complexf* (i8*, i8*, %Complexf*)*,  %Complexf* (i8*, i8*, %Complexf*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf* %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath360 = hidden constant [35 x i8] c"hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ\00"
@gsxtmmath361 = hidden constant [43 x i8] c"{i8*, i8*, void (i8*, i8*, %Complexf*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ__8840(i8* %_impz,i8* %_impenv, %Complexf* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8841 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexf*)*}***}*
%hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQPtr = load {i8*, i8*, void (i8*, i8*, %Complexf*)*}***, {i8*, i8*, void (i8*, i8*, %Complexf*)*}**** %hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQPtr_

; setup arguments
%xPtr = alloca %Complexf*
store %Complexf* %x, %Complexf** %xPtr


%val8842 = load %Complexf*, %Complexf** %xPtr
%val8843 = bitcast %Complexf* %val8842 to i8*
call ccc void @free(i8* %val8843)
ret void
}
@gsxtmmath362 = hidden constant [88 x i8] c"hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexf*)*}** @hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8865 = load i8*, i8** %_impzPtr
%zone8866 = bitcast i8* %tzone8865 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ
%dat_hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ = call i8* @llvm_zone_malloc(%mzone* %zone8866, i64 8)
%hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ to { i8*, i8*, void (i8*, i8*, %Complexf*)*}***
%tzone8846 = load i8*, i8** %_impzPtr
%zone8847 = bitcast i8* %tzone8846 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8847)
; malloc closure structure
%clsptr8848 = call i8* @llvm_zone_malloc(%mzone* %zone8847, i64 24)
%closure8849 = bitcast i8* %clsptr8848 to { i8*, i8*, void (i8*, i8*, %Complexf*)*}*

; malloc environment structure
%envptr8850 = call i8* @llvm_zone_malloc(%mzone* %zone8847, i64 8)
%environment8851 = bitcast i8* %envptr8850 to {{i8*, i8*, void (i8*, i8*, %Complexf*)*}***}*

; malloc closure address table
%addytable8852 = call %clsvar* @new_address_table()
%var8853 = bitcast [35 x i8]* @gsxtmmath360 to i8*
%var8854 = bitcast [43 x i8]* @gsxtmmath361 to i8*
%addytable8855 = call %clsvar* @add_address_table(%mzone* %zone8847, i8* %var8853, i32 0, i8* %var8854, i32 3, %clsvar* %addytable8852)
%address-table8856 = bitcast %clsvar* %addytable8855 to i8*

; insert table, function and environment into closure struct
%closure.table8859 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*)*}, { i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure8849, i32 0, i32 0
store i8* %address-table8856, i8** %closure.table8859
%closure.env8860 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*)*}, { i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure8849, i32 0, i32 1
store i8* %envptr8850, i8** %closure.env8860
%closure.func8861 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*)*}, { i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure8849, i32 0, i32 2
store void (i8*, i8*, %Complexf*)* @hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ__8840, void (i8*, i8*, %Complexf*)** %closure.func8861
%closure_size8862 = call i64 @llvm_zone_mark_size(%mzone* %zone8847)
call void @llvm_zone_ptr_set_size(i8* %clsptr8848, i64 %closure_size8862)
%wrapper_ptr8863 = call i8* @llvm_zone_malloc(%mzone* %zone8847, i64 8)
%closure_wrapper8864 = bitcast i8* %wrapper_ptr8863 to { i8*, i8*, void (i8*, i8*, %Complexf*)*}**
store { i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure8849, { i8*, i8*, void (i8*, i8*, %Complexf*)*}** %closure_wrapper8864

; let value assignment
%hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexf*)*}** %closure_wrapper8864, { i8*, i8*, void (i8*, i8*, %Complexf*)*}** %closure_wrapper8864
store { i8*, i8*, void (i8*, i8*, %Complexf*)*}** %hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ, { i8*, i8*, void (i8*, i8*, %Complexf*)*}*** %hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ
%tmp_envptr8858 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*)*}***}* %environment8851, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexf*)*}*** %hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQPtr, {i8*, i8*, void (i8*, i8*, %Complexf*)*}**** %tmp_envptr8858


%val8867 = load {i8*, i8*, void (i8*, i8*, %Complexf*)*}**, {i8*, i8*, void (i8*, i8*, %Complexf*)*}*** %hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQPtr
ret {i8*, i8*, void (i8*, i8*, %Complexf*)*}** %val8867
}


@hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexf*)*}** @hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexf*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ(%Complexf* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*)*}, {i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*)*}, {i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*)*,  void (i8*, i8*, %Complexf*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_native(%Complexf* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*)*}, {i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*)*}, {i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*)*,  void (i8*, i8*, %Complexf*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8868 = bitcast [88 x i8]* @gsxtmmath362 to i8*
call i32 (i8*, ...) @printf(i8* %var8868)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexf*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*)*}, {i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*)*}, {i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*)*,  void (i8*, i8*, %Complexf*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf*}*
%arg_p_0 = getelementptr {%Complexf*}, {%Complexf*}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf*, %Complexf** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*)*}, {i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*)*}, {i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*)*,  void (i8*, i8*, %Complexf*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath363 = hidden constant [60 x i8] c"zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0\00"
@gsxtmmath364 = hidden constant [67 x i8] c"{i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %Complexf* @zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0__8869(i8* %_impz,i8* %_impenv, %Complexf* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8870 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0Ptr_ = getelementptr {{i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0Ptr = load {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}***, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0Ptr_

; setup arguments
%xPtr = alloca %Complexf*
store %Complexf* %x, %Complexf** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val8872 = load %mzone*, %mzone** %fromzPtr
%val8873 = load %Complexf*, %Complexf** %xPtr
%val8874 = bitcast %Complexf* %val8873 to i8*
%res8875 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val8872, i8* %val8874)
br i1 %res8875, label %then8871, label %else8871

then8871:
%val8876 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val8876)
%zone_ptr8877 = bitcast %mzone* %val8876 to i8*
store i8* %zone_ptr8877, i8** %_impzPtr
%tzone8883 = load i8*, i8** %_impzPtr
%zone8884 = bitcast i8* %tzone8883 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Complexf*
%tzone8879 = load i8*, i8** %_impzPtr
%zone8880 = bitcast i8* %tzone8879 to %mzone*
%dat8881 = call i8* @llvm_zone_malloc(%mzone* %zone8880, i64 8)
call i8* @memset(i8* %dat8881, i32 0, i64 8)
%val8882 = bitcast i8* %dat8881 to %Complexf*

; let value assignment
%obj = select i1 true, %Complexf* %val8882, %Complexf* %val8882
store %Complexf* %obj, %Complexf** %objPtr

%val8885 = load %Complexf*, %Complexf** %objPtr
%val8886 = load %Complexf*, %Complexf** %xPtr
; tuple ref
%val8887 = getelementptr %Complexf, %Complexf* %val8886, i64 0, i32 0
%val8888 = load float, float* %val8887
; set tuple
%val8889 = getelementptr %Complexf, %Complexf* %val8885, i64 0, i32 0
store float %val8888, float* %val8889
%val8890 = load %Complexf*, %Complexf** %objPtr
%val8891 = load %Complexf*, %Complexf** %xPtr
; tuple ref
%val8892 = getelementptr %Complexf, %Complexf* %val8891, i64 0, i32 1
%val8893 = load float, float* %val8892
; set tuple
%val8894 = getelementptr %Complexf, %Complexf* %val8890, i64 0, i32 1
store float %val8893, float* %val8894
%oldzone8895 = call %mzone* @llvm_pop_zone_stack()
%newzone8896 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr8897 = bitcast %mzone* %newzone8896 to i8*
store i8* %zone_ptr8897, i8** %_impzPtr
%val8898 = load %Complexf*, %Complexf** %objPtr
ret %Complexf* %val8898

else8871:
%val8899 = load %Complexf*, %Complexf** %xPtr
ret %Complexf* %val8899
}
@gsxtmmath365 = hidden constant [113 x i8] c"zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}** @zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8919 = load i8*, i8** %_impzPtr
%zone8920 = bitcast i8* %tzone8919 to %mzone*

; let assign value to symbol zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0
%dat_zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone8920, i64 8)
%zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0Ptr = bitcast i8* %dat_zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0 to { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}***
%tzone8900 = load i8*, i8** %_impzPtr
%zone8901 = bitcast i8* %tzone8900 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8901)
; malloc closure structure
%clsptr8902 = call i8* @llvm_zone_malloc(%mzone* %zone8901, i64 24)
%closure8903 = bitcast i8* %clsptr8902 to { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr8904 = call i8* @llvm_zone_malloc(%mzone* %zone8901, i64 8)
%environment8905 = bitcast i8* %envptr8904 to {{i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable8906 = call %clsvar* @new_address_table()
%var8907 = bitcast [60 x i8]* @gsxtmmath363 to i8*
%var8908 = bitcast [67 x i8]* @gsxtmmath364 to i8*
%addytable8909 = call %clsvar* @add_address_table(%mzone* %zone8901, i8* %var8907, i32 0, i8* %var8908, i32 3, %clsvar* %addytable8906)
%address-table8910 = bitcast %clsvar* %addytable8909 to i8*

; insert table, function and environment into closure struct
%closure.table8913 = getelementptr { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}, { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}* %closure8903, i32 0, i32 0
store i8* %address-table8910, i8** %closure.table8913
%closure.env8914 = getelementptr { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}, { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}* %closure8903, i32 0, i32 1
store i8* %envptr8904, i8** %closure.env8914
%closure.func8915 = getelementptr { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}, { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}* %closure8903, i32 0, i32 2
store %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)* @zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0__8869, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)** %closure.func8915
%closure_size8916 = call i64 @llvm_zone_mark_size(%mzone* %zone8901)
call void @llvm_zone_ptr_set_size(i8* %clsptr8902, i64 %closure_size8916)
%wrapper_ptr8917 = call i8* @llvm_zone_malloc(%mzone* %zone8901, i64 8)
%closure_wrapper8918 = bitcast i8* %wrapper_ptr8917 to { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}**
store { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}* %closure8903, { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}** %closure_wrapper8918

; let value assignment
%zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0 = select i1 true, { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}** %closure_wrapper8918, { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}** %closure_wrapper8918
store { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}** %zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0, { i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0Ptr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0
%tmp_envptr8912 = getelementptr {{i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}***}* %environment8905, i32 0, i32 0
store {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0Ptr, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}**** %tmp_envptr8912


%val8921 = load {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}**, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0Ptr
ret {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}** %val8921
}


@zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}** @zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf* @zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0(%Complexf* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}*, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*,  %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf* %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %Complexf* %result
}


define dllexport ccc %Complexf* @zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0_native(%Complexf* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}*, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*,  %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf* %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %Complexf* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8922 = bitcast [113 x i8]* @gsxtmmath365 to i8*
call i32 (i8*, ...) @printf(i8* %var8922)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexf*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var8923 = bitcast [113 x i8]* @gsxtmmath365 to i8*
call i32 (i8*, ...) @printf(i8* %var8923)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var8924 = bitcast [113 x i8]* @gsxtmmath365 to i8*
call i32 (i8*, ...) @printf(i8* %var8924)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}*, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*,  %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf* %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %Complexf* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%Complexf*, %mzone*, %mzone*}, {%Complexf*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf*, %Complexf** %arg_p_0
%arg_p_1 = getelementptr {%Complexf*, %mzone*, %mzone*}, {%Complexf*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%Complexf*, %mzone*, %mzone*}, {%Complexf*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0NvbXBsZXhmKixDb21wbGV4ZiosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}*, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}, {i8*, i8*, %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)*,  %Complexf* (i8*, i8*, %Complexf*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf* %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath366 = hidden constant [42 x i8] c"Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ\00"
define dllexport fastcc %Complexf @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ__8925(i8* %_impz,i8* %_impenv, float %re, float %im) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8926 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf (i8*, i8*, float, float)*}***}*
%Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, float, float)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, float, float)*}***}* %impenv, i32 0, i32 0
%Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, %Complexf (i8*, i8*, float, float)*}***, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}**** %Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%rePtr = alloca float
store float %re, float* %rePtr
%imPtr = alloca float
store float %im, float* %imPtr


%tzone8928 = load i8*, i8** %_impzPtr
%zone8929 = bitcast i8* %tzone8928 to %mzone*

; let assign value to symbol c
%cPtr = alloca %Complexf*
%dat8927 = alloca %Complexf, align 16

; let value assignment
%c = select i1 true, %Complexf* %dat8927, %Complexf* %dat8927
store %Complexf* %c, %Complexf** %cPtr

%val8930 = load %Complexf*, %Complexf** %cPtr
%val8931 = load float, float* %rePtr
; set tuple
%val8932 = getelementptr %Complexf, %Complexf* %val8930, i64 0, i32 0
store float %val8931, float* %val8932
%val8933 = load %Complexf*, %Complexf** %cPtr
%val8934 = load float, float* %imPtr
; set tuple
%val8935 = getelementptr %Complexf, %Complexf* %val8933, i64 0, i32 1
store float %val8934, float* %val8935
%val8936 = load %Complexf*, %Complexf** %cPtr
; pointer ref
%val8937 = getelementptr %Complexf, %Complexf* %val8936, i64 0
%val8938 = load %Complexf, %Complexf* %val8937
ret %Complexf %val8938
}
@gsxtmmath367 = hidden constant [95 x i8] c"Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexf (i8*, i8*, float, float)*}** @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8958 = load i8*, i8** %_impzPtr
%zone8959 = bitcast i8* %tzone8958 to %mzone*

; let assign value to symbol Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ
%dat_Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone8959, i64 8)
%Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ to { i8*, i8*, %Complexf (i8*, i8*, float, float)*}***
%tzone8939 = load i8*, i8** %_impzPtr
%zone8940 = bitcast i8* %tzone8939 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8940)
; malloc closure structure
%clsptr8941 = call i8* @llvm_zone_malloc(%mzone* %zone8940, i64 24)
%closure8942 = bitcast i8* %clsptr8941 to { i8*, i8*, %Complexf (i8*, i8*, float, float)*}*

; malloc environment structure
%envptr8943 = call i8* @llvm_zone_malloc(%mzone* %zone8940, i64 8)
%environment8944 = bitcast i8* %envptr8943 to {{i8*, i8*, %Complexf (i8*, i8*, float, float)*}***}*

; malloc closure address table
%addytable8945 = call %clsvar* @new_address_table()
%var8946 = bitcast [42 x i8]* @gsxtmmath366 to i8*
%var8947 = bitcast [50 x i8]* @gsxtmmath355 to i8*
%addytable8948 = call %clsvar* @add_address_table(%mzone* %zone8940, i8* %var8946, i32 0, i8* %var8947, i32 3, %clsvar* %addytable8945)
%address-table8949 = bitcast %clsvar* %addytable8948 to i8*

; insert table, function and environment into closure struct
%closure.table8952 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, float, float)*}, { i8*, i8*, %Complexf (i8*, i8*, float, float)*}* %closure8942, i32 0, i32 0
store i8* %address-table8949, i8** %closure.table8952
%closure.env8953 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, float, float)*}, { i8*, i8*, %Complexf (i8*, i8*, float, float)*}* %closure8942, i32 0, i32 1
store i8* %envptr8943, i8** %closure.env8953
%closure.func8954 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, float, float)*}, { i8*, i8*, %Complexf (i8*, i8*, float, float)*}* %closure8942, i32 0, i32 2
store %Complexf (i8*, i8*, float, float)* @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ__8925, %Complexf (i8*, i8*, float, float)** %closure.func8954
%closure_size8955 = call i64 @llvm_zone_mark_size(%mzone* %zone8940)
call void @llvm_zone_ptr_set_size(i8* %clsptr8941, i64 %closure_size8955)
%wrapper_ptr8956 = call i8* @llvm_zone_malloc(%mzone* %zone8940, i64 8)
%closure_wrapper8957 = bitcast i8* %wrapper_ptr8956 to { i8*, i8*, %Complexf (i8*, i8*, float, float)*}**
store { i8*, i8*, %Complexf (i8*, i8*, float, float)*}* %closure8942, { i8*, i8*, %Complexf (i8*, i8*, float, float)*}** %closure_wrapper8957

; let value assignment
%Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, %Complexf (i8*, i8*, float, float)*}** %closure_wrapper8957, { i8*, i8*, %Complexf (i8*, i8*, float, float)*}** %closure_wrapper8957
store { i8*, i8*, %Complexf (i8*, i8*, float, float)*}** %Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ, { i8*, i8*, %Complexf (i8*, i8*, float, float)*}*** %Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ
%tmp_envptr8951 = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, float, float)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, float, float)*}***}* %environment8944, i32 0, i32 0
store {i8*, i8*, %Complexf (i8*, i8*, float, float)*}*** %Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}**** %tmp_envptr8951


%val8960 = load {i8*, i8*, %Complexf (i8*, i8*, float, float)*}**, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}*** %Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, %Complexf (i8*, i8*, float, float)*}** %val8960
}


@Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf (i8*, i8*, float, float)*}** @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf (i8*, i8*, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, float, float)*}*, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, float, float)*,  %Complexf (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %Complexf %result
}


define dllexport ccc %Complexf @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_native(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, float, float)*}*, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, float, float)*,  %Complexf (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %Complexf %result
}


define dllexport ccc void @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float}*
%arg_p_0 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, float, float)*}*, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, float)*}, {i8*, i8*, %Complexf (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, float, float)*,  %Complexf (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath368 = hidden constant [33 x i8] c"print_adhoc_W3ZvaWQsQ29tcGxleGZd\00"
@gsxtmmath369 = hidden constant [42 x i8] c"{i8*, i8*, void (i8*, i8*, %Complexf)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsQ29tcGxleGZd__8963(i8* %_impz,i8* %_impenv, %Complexf %c) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8964 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexf)*}***}*
%print_adhoc_W3ZvaWQsQ29tcGxleGZdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsQ29tcGxleGZdPtr = load {i8*, i8*, void (i8*, i8*, %Complexf)*}***, {i8*, i8*, void (i8*, i8*, %Complexf)*}**** %print_adhoc_W3ZvaWQsQ29tcGxleGZdPtr_

; setup arguments
%cPtr = alloca %Complexf
store %Complexf %c, %Complexf* %cPtr


%var8965 = bitcast [11 x i8]* @gsxtmmath292 to i8*
%val8966 = load %Complexf, %Complexf* %cPtr
; tuple ref
%val8967 = extractvalue %Complexf %val8966, 0
%res8968 = call ccc double @ftod(float %val8967)
%val8969 = load %Complexf, %Complexf* %cPtr
; tuple ref
%val8970 = extractvalue %Complexf %val8969, 1
%res8971 = call ccc double @ftod(float %val8970)

%val8972 = call i32 (i8*, ...) @printf(i8* %var8965, double %res8968, double %res8971)
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexf)*}** @print_adhoc_W3ZvaWQsQ29tcGxleGZd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8993 = load i8*, i8** %_impzPtr
%zone8994 = bitcast i8* %tzone8993 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsQ29tcGxleGZd
%dat_print_adhoc_W3ZvaWQsQ29tcGxleGZd = call i8* @llvm_zone_malloc(%mzone* %zone8994, i64 8)
%print_adhoc_W3ZvaWQsQ29tcGxleGZdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsQ29tcGxleGZd to { i8*, i8*, void (i8*, i8*, %Complexf)*}***
%tzone8974 = load i8*, i8** %_impzPtr
%zone8975 = bitcast i8* %tzone8974 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8975)
; malloc closure structure
%clsptr8976 = call i8* @llvm_zone_malloc(%mzone* %zone8975, i64 24)
%closure8977 = bitcast i8* %clsptr8976 to { i8*, i8*, void (i8*, i8*, %Complexf)*}*

; malloc environment structure
%envptr8978 = call i8* @llvm_zone_malloc(%mzone* %zone8975, i64 8)
%environment8979 = bitcast i8* %envptr8978 to {{i8*, i8*, void (i8*, i8*, %Complexf)*}***}*

; malloc closure address table
%addytable8980 = call %clsvar* @new_address_table()
%var8981 = bitcast [33 x i8]* @gsxtmmath368 to i8*
%var8982 = bitcast [42 x i8]* @gsxtmmath369 to i8*
%addytable8983 = call %clsvar* @add_address_table(%mzone* %zone8975, i8* %var8981, i32 0, i8* %var8982, i32 3, %clsvar* %addytable8980)
%address-table8984 = bitcast %clsvar* %addytable8983 to i8*

; insert table, function and environment into closure struct
%closure.table8987 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf)*}, { i8*, i8*, void (i8*, i8*, %Complexf)*}* %closure8977, i32 0, i32 0
store i8* %address-table8984, i8** %closure.table8987
%closure.env8988 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf)*}, { i8*, i8*, void (i8*, i8*, %Complexf)*}* %closure8977, i32 0, i32 1
store i8* %envptr8978, i8** %closure.env8988
%closure.func8989 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf)*}, { i8*, i8*, void (i8*, i8*, %Complexf)*}* %closure8977, i32 0, i32 2
store void (i8*, i8*, %Complexf)* @print_adhoc_W3ZvaWQsQ29tcGxleGZd__8963, void (i8*, i8*, %Complexf)** %closure.func8989
%closure_size8990 = call i64 @llvm_zone_mark_size(%mzone* %zone8975)
call void @llvm_zone_ptr_set_size(i8* %clsptr8976, i64 %closure_size8990)
%wrapper_ptr8991 = call i8* @llvm_zone_malloc(%mzone* %zone8975, i64 8)
%closure_wrapper8992 = bitcast i8* %wrapper_ptr8991 to { i8*, i8*, void (i8*, i8*, %Complexf)*}**
store { i8*, i8*, void (i8*, i8*, %Complexf)*}* %closure8977, { i8*, i8*, void (i8*, i8*, %Complexf)*}** %closure_wrapper8992

; let value assignment
%print_adhoc_W3ZvaWQsQ29tcGxleGZd = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexf)*}** %closure_wrapper8992, { i8*, i8*, void (i8*, i8*, %Complexf)*}** %closure_wrapper8992
store { i8*, i8*, void (i8*, i8*, %Complexf)*}** %print_adhoc_W3ZvaWQsQ29tcGxleGZd, { i8*, i8*, void (i8*, i8*, %Complexf)*}*** %print_adhoc_W3ZvaWQsQ29tcGxleGZdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsQ29tcGxleGZd
%tmp_envptr8986 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf)*}***}* %environment8979, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexf)*}*** %print_adhoc_W3ZvaWQsQ29tcGxleGZdPtr, {i8*, i8*, void (i8*, i8*, %Complexf)*}**** %tmp_envptr8986


%val8995 = load {i8*, i8*, void (i8*, i8*, %Complexf)*}**, {i8*, i8*, void (i8*, i8*, %Complexf)*}*** %print_adhoc_W3ZvaWQsQ29tcGxleGZdPtr
ret {i8*, i8*, void (i8*, i8*, %Complexf)*}** %val8995
}


@print_adhoc_W3ZvaWQsQ29tcGxleGZd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsQ29tcGxleGZd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsQ29tcGxleGZd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGZd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexf)*}** @print_adhoc_W3ZvaWQsQ29tcGxleGZd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexf)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGZd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsQ29tcGxleGZd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGZd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsQ29tcGxleGZd(%Complexf %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGZd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf)*}*, {i8*, i8*, void (i8*, i8*, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf)*}, {i8*, i8*, void (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf)*}, {i8*, i8*, void (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf)*,  void (i8*, i8*, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsQ29tcGxleGZd_native(%Complexf %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGZd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf)*}*, {i8*, i8*, void (i8*, i8*, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf)*}, {i8*, i8*, void (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf)*}, {i8*, i8*, void (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf)*,  void (i8*, i8*, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsQ29tcGxleGZd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf}*
%arg_p_0 = getelementptr {%Complexf}, {%Complexf}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf, %Complexf* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGZd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf)*}*, {i8*, i8*, void (i8*, i8*, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf)*}, {i8*, i8*, void (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf)*}, {i8*, i8*, void (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf)*,  void (i8*, i8*, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath370 = hidden constant [15 x i8] c"<Complexf 0x0>\00"
@gsxtmmath371 = hidden constant [35 x i8] c"print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ__8996(i8* %_impz,i8* %_impenv, %Complexf* %c) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8997 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexf*)*}***}*
%print_adhoc_W3ZvaWQsQ29tcGxleGYqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsQ29tcGxleGYqXQPtr = load {i8*, i8*, void (i8*, i8*, %Complexf*)*}***, {i8*, i8*, void (i8*, i8*, %Complexf*)*}**** %print_adhoc_W3ZvaWQsQ29tcGxleGYqXQPtr_

; setup arguments
%cPtr = alloca %Complexf*
store %Complexf* %c, %Complexf** %cPtr

; promote local stack var allocations
%tzone9015 = load i8*, i8** %_impzPtr
%zone9016 = bitcast i8* %tzone9015 to %mzone*
%ifptr8998 = alloca i32

%val8999 = load %Complexf*, %Complexf** %cPtr
%val9000 = icmp eq %Complexf* %val8999, null
br i1 %val9000, label %then8998, label %else8998

then8998:
%var9001 = bitcast [15 x i8]* @gsxtmmath370 to i8*

%val9002 = call i32 (i8*, ...) @printf(i8* %var9001)
store i32 %val9002, i32* %ifptr8998
br label %ifcont8998

else8998:
%var9003 = bitcast [11 x i8]* @gsxtmmath292 to i8*
%val9004 = load %Complexf*, %Complexf** %cPtr
; tuple ref
%val9005 = getelementptr %Complexf, %Complexf* %val9004, i64 0, i32 0
%val9006 = load float, float* %val9005
%res9007 = call ccc double @ftod(float %val9006)
%val9008 = load %Complexf*, %Complexf** %cPtr
; tuple ref
%val9009 = getelementptr %Complexf, %Complexf* %val9008, i64 0, i32 1
%val9010 = load float, float* %val9009
%res9011 = call ccc double @ftod(float %val9010)

%val9012 = call i32 (i8*, ...) @printf(i8* %var9003, double %res9007, double %res9011)
store i32 %val9012, i32* %ifptr8998
br label %ifcont8998

ifcont8998:
%ifres9013 = load i32, i32* %ifptr8998

ret void
}
@gsxtmmath372 = hidden constant [88 x i8] c"print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexf*)*}** @print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9036 = load i8*, i8** %_impzPtr
%zone9037 = bitcast i8* %tzone9036 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ
%dat_print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ = call i8* @llvm_zone_malloc(%mzone* %zone9037, i64 8)
%print_adhoc_W3ZvaWQsQ29tcGxleGYqXQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ to { i8*, i8*, void (i8*, i8*, %Complexf*)*}***
%tzone9017 = load i8*, i8** %_impzPtr
%zone9018 = bitcast i8* %tzone9017 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9018)
; malloc closure structure
%clsptr9019 = call i8* @llvm_zone_malloc(%mzone* %zone9018, i64 24)
%closure9020 = bitcast i8* %clsptr9019 to { i8*, i8*, void (i8*, i8*, %Complexf*)*}*

; malloc environment structure
%envptr9021 = call i8* @llvm_zone_malloc(%mzone* %zone9018, i64 8)
%environment9022 = bitcast i8* %envptr9021 to {{i8*, i8*, void (i8*, i8*, %Complexf*)*}***}*

; malloc closure address table
%addytable9023 = call %clsvar* @new_address_table()
%var9024 = bitcast [35 x i8]* @gsxtmmath371 to i8*
%var9025 = bitcast [43 x i8]* @gsxtmmath361 to i8*
%addytable9026 = call %clsvar* @add_address_table(%mzone* %zone9018, i8* %var9024, i32 0, i8* %var9025, i32 3, %clsvar* %addytable9023)
%address-table9027 = bitcast %clsvar* %addytable9026 to i8*

; insert table, function and environment into closure struct
%closure.table9030 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*)*}, { i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure9020, i32 0, i32 0
store i8* %address-table9027, i8** %closure.table9030
%closure.env9031 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*)*}, { i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure9020, i32 0, i32 1
store i8* %envptr9021, i8** %closure.env9031
%closure.func9032 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*)*}, { i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure9020, i32 0, i32 2
store void (i8*, i8*, %Complexf*)* @print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ__8996, void (i8*, i8*, %Complexf*)** %closure.func9032
%closure_size9033 = call i64 @llvm_zone_mark_size(%mzone* %zone9018)
call void @llvm_zone_ptr_set_size(i8* %clsptr9019, i64 %closure_size9033)
%wrapper_ptr9034 = call i8* @llvm_zone_malloc(%mzone* %zone9018, i64 8)
%closure_wrapper9035 = bitcast i8* %wrapper_ptr9034 to { i8*, i8*, void (i8*, i8*, %Complexf*)*}**
store { i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure9020, { i8*, i8*, void (i8*, i8*, %Complexf*)*}** %closure_wrapper9035

; let value assignment
%print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexf*)*}** %closure_wrapper9035, { i8*, i8*, void (i8*, i8*, %Complexf*)*}** %closure_wrapper9035
store { i8*, i8*, void (i8*, i8*, %Complexf*)*}** %print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ, { i8*, i8*, void (i8*, i8*, %Complexf*)*}*** %print_adhoc_W3ZvaWQsQ29tcGxleGYqXQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ
%tmp_envptr9029 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*)*}***}* %environment9022, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexf*)*}*** %print_adhoc_W3ZvaWQsQ29tcGxleGYqXQPtr, {i8*, i8*, void (i8*, i8*, %Complexf*)*}**** %tmp_envptr9029


%val9038 = load {i8*, i8*, void (i8*, i8*, %Complexf*)*}**, {i8*, i8*, void (i8*, i8*, %Complexf*)*}*** %print_adhoc_W3ZvaWQsQ29tcGxleGYqXQPtr
ret {i8*, i8*, void (i8*, i8*, %Complexf*)*}** %val9038
}


@print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexf*)*}** @print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexf*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ(%Complexf* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*)*}, {i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*)*}, {i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*)*,  void (i8*, i8*, %Complexf*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_native(%Complexf* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*)*}, {i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*)*}, {i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*)*,  void (i8*, i8*, %Complexf*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var9039 = bitcast [88 x i8]* @gsxtmmath372 to i8*
call i32 (i8*, ...) @printf(i8* %var9039)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexf*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*)*}, {i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*)*}, {i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*)*,  void (i8*, i8*, %Complexf*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf*}*
%arg_p_0 = getelementptr {%Complexf*}, {%Complexf*}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf*, %Complexf** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQ29tcGxleGYqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*)*}, {i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*)*}, {i8*, i8*, void (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*)*,  void (i8*, i8*, %Complexf*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath373 = hidden constant [40 x i8] c"toString_adhoc_W1N0cmluZyosQ29tcGxleGZd\00"
@gsxtmmath374 = hidden constant [46 x i8] c"{i8*, i8*, %String* (i8*, i8*, %Complexf)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosQ29tcGxleGZd__9040(i8* %_impz,i8* %_impenv, %Complexf %c) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9041 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %Complexf)*}***}*
%toString_adhoc_W1N0cmluZyosQ29tcGxleGZdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %Complexf)*}***}, {{i8*, i8*, %String* (i8*, i8*, %Complexf)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosQ29tcGxleGZdPtr = load {i8*, i8*, %String* (i8*, i8*, %Complexf)*}***, {i8*, i8*, %String* (i8*, i8*, %Complexf)*}**** %toString_adhoc_W1N0cmluZyosQ29tcGxleGZdPtr_

; setup arguments
%cPtr = alloca %Complexf
store %Complexf %c, %Complexf* %cPtr


%tzone9043 = load i8*, i8** %_impzPtr
%zone9044 = bitcast i8* %tzone9043 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat9042 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat9042, i8* %dat9042
store i8* %str, i8** %strPtr

%val9045 = load i8*, i8** %strPtr
%var9046 = bitcast [11 x i8]* @gsxtmmath292 to i8*
%val9047 = load %Complexf, %Complexf* %cPtr
; tuple ref
%val9048 = extractvalue %Complexf %val9047, 0
%res9049 = call ccc double @ftod(float %val9048)
%val9050 = load %Complexf, %Complexf* %cPtr
; tuple ref
%val9051 = extractvalue %Complexf %val9050, 1
%res9052 = call ccc double @ftod(float %val9051)

%val9053 = call i32 (i8*,i8*, ...) @sprintf(i8* %val9045, i8* %var9046, double %res9049, double %res9052)
%val9054 = load i8*, i8** %strPtr
%res9055 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val9054)
ret %String* %res9055
}
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %Complexf)*}** @toString_adhoc_W1N0cmluZyosQ29tcGxleGZd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9075 = load i8*, i8** %_impzPtr
%zone9076 = bitcast i8* %tzone9075 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosQ29tcGxleGZd
%dat_toString_adhoc_W1N0cmluZyosQ29tcGxleGZd = call i8* @llvm_zone_malloc(%mzone* %zone9076, i64 8)
%toString_adhoc_W1N0cmluZyosQ29tcGxleGZdPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosQ29tcGxleGZd to { i8*, i8*, %String* (i8*, i8*, %Complexf)*}***
%tzone9056 = load i8*, i8** %_impzPtr
%zone9057 = bitcast i8* %tzone9056 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9057)
; malloc closure structure
%clsptr9058 = call i8* @llvm_zone_malloc(%mzone* %zone9057, i64 24)
%closure9059 = bitcast i8* %clsptr9058 to { i8*, i8*, %String* (i8*, i8*, %Complexf)*}*

; malloc environment structure
%envptr9060 = call i8* @llvm_zone_malloc(%mzone* %zone9057, i64 8)
%environment9061 = bitcast i8* %envptr9060 to {{i8*, i8*, %String* (i8*, i8*, %Complexf)*}***}*

; malloc closure address table
%addytable9062 = call %clsvar* @new_address_table()
%var9063 = bitcast [40 x i8]* @gsxtmmath373 to i8*
%var9064 = bitcast [46 x i8]* @gsxtmmath374 to i8*
%addytable9065 = call %clsvar* @add_address_table(%mzone* %zone9057, i8* %var9063, i32 0, i8* %var9064, i32 3, %clsvar* %addytable9062)
%address-table9066 = bitcast %clsvar* %addytable9065 to i8*

; insert table, function and environment into closure struct
%closure.table9069 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Complexf)*}, { i8*, i8*, %String* (i8*, i8*, %Complexf)*}* %closure9059, i32 0, i32 0
store i8* %address-table9066, i8** %closure.table9069
%closure.env9070 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Complexf)*}, { i8*, i8*, %String* (i8*, i8*, %Complexf)*}* %closure9059, i32 0, i32 1
store i8* %envptr9060, i8** %closure.env9070
%closure.func9071 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Complexf)*}, { i8*, i8*, %String* (i8*, i8*, %Complexf)*}* %closure9059, i32 0, i32 2
store %String* (i8*, i8*, %Complexf)* @toString_adhoc_W1N0cmluZyosQ29tcGxleGZd__9040, %String* (i8*, i8*, %Complexf)** %closure.func9071
%closure_size9072 = call i64 @llvm_zone_mark_size(%mzone* %zone9057)
call void @llvm_zone_ptr_set_size(i8* %clsptr9058, i64 %closure_size9072)
%wrapper_ptr9073 = call i8* @llvm_zone_malloc(%mzone* %zone9057, i64 8)
%closure_wrapper9074 = bitcast i8* %wrapper_ptr9073 to { i8*, i8*, %String* (i8*, i8*, %Complexf)*}**
store { i8*, i8*, %String* (i8*, i8*, %Complexf)*}* %closure9059, { i8*, i8*, %String* (i8*, i8*, %Complexf)*}** %closure_wrapper9074

; let value assignment
%toString_adhoc_W1N0cmluZyosQ29tcGxleGZd = select i1 true, { i8*, i8*, %String* (i8*, i8*, %Complexf)*}** %closure_wrapper9074, { i8*, i8*, %String* (i8*, i8*, %Complexf)*}** %closure_wrapper9074
store { i8*, i8*, %String* (i8*, i8*, %Complexf)*}** %toString_adhoc_W1N0cmluZyosQ29tcGxleGZd, { i8*, i8*, %String* (i8*, i8*, %Complexf)*}*** %toString_adhoc_W1N0cmluZyosQ29tcGxleGZdPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosQ29tcGxleGZd
%tmp_envptr9068 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %Complexf)*}***}, {{i8*, i8*, %String* (i8*, i8*, %Complexf)*}***}* %environment9061, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %Complexf)*}*** %toString_adhoc_W1N0cmluZyosQ29tcGxleGZdPtr, {i8*, i8*, %String* (i8*, i8*, %Complexf)*}**** %tmp_envptr9068


%val9077 = load {i8*, i8*, %String* (i8*, i8*, %Complexf)*}**, {i8*, i8*, %String* (i8*, i8*, %Complexf)*}*** %toString_adhoc_W1N0cmluZyosQ29tcGxleGZdPtr
ret {i8*, i8*, %String* (i8*, i8*, %Complexf)*}** %val9077
}


@toString_adhoc_W1N0cmluZyosQ29tcGxleGZd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosQ29tcGxleGZd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosQ29tcGxleGZd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGZd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %Complexf)*}** @toString_adhoc_W1N0cmluZyosQ29tcGxleGZd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %Complexf)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGZd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosQ29tcGxleGZd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGZd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosQ29tcGxleGZd(%Complexf %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGZd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Complexf)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Complexf)*}*, {i8*, i8*, %String* (i8*, i8*, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexf)*}, {i8*, i8*, %String* (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexf)*}, {i8*, i8*, %String* (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Complexf)*,  %String* (i8*, i8*, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Complexf %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosQ29tcGxleGZd_native(%Complexf %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGZd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Complexf)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Complexf)*}*, {i8*, i8*, %String* (i8*, i8*, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexf)*}, {i8*, i8*, %String* (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexf)*}, {i8*, i8*, %String* (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Complexf)*,  %String* (i8*, i8*, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Complexf %arg_0)
ret %String* %result
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosQ29tcGxleGZd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf}*
%arg_p_0 = getelementptr {%Complexf}, {%Complexf}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf, %Complexf* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGZd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Complexf)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Complexf)*}*, {i8*, i8*, %String* (i8*, i8*, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexf)*}, {i8*, i8*, %String* (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexf)*}, {i8*, i8*, %String* (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Complexf)*,  %String* (i8*, i8*, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Complexf %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath375 = hidden constant [42 x i8] c"toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ\00"
@gsxtmmath376 = hidden constant [47 x i8] c"{i8*, i8*, %String* (i8*, i8*, %Complexf*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ__9078(i8* %_impz,i8* %_impenv, %Complexf* %c) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9079 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %Complexf*)*}***}*
%toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %Complexf*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %Complexf*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQPtr = load {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}***, {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}**** %toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQPtr_

; setup arguments
%cPtr = alloca %Complexf*
store %Complexf* %c, %Complexf** %cPtr


%tzone9081 = load i8*, i8** %_impzPtr
%zone9082 = bitcast i8* %tzone9081 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat9080 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat9080, i8* %dat9080
store i8* %str, i8** %strPtr

; promote local stack var allocations
%tzone9103 = load i8*, i8** %_impzPtr
%zone9104 = bitcast i8* %tzone9103 to %mzone*
%ifptr9083 = alloca i32
%val9084 = load %Complexf*, %Complexf** %cPtr
%val9085 = icmp eq %Complexf* %val9084, null
br i1 %val9085, label %then9083, label %else9083

then9083:
%val9086 = load i8*, i8** %strPtr
%var9087 = bitcast [15 x i8]* @gsxtmmath370 to i8*

%val9088 = call i32 (i8*,i8*, ...) @sprintf(i8* %val9086, i8* %var9087)
store i32 %val9088, i32* %ifptr9083
br label %ifcont9083

else9083:
%val9089 = load i8*, i8** %strPtr
%var9090 = bitcast [11 x i8]* @gsxtmmath292 to i8*
%val9091 = load %Complexf*, %Complexf** %cPtr
; tuple ref
%val9092 = getelementptr %Complexf, %Complexf* %val9091, i64 0, i32 0
%val9093 = load float, float* %val9092
%res9094 = call ccc double @ftod(float %val9093)
%val9095 = load %Complexf*, %Complexf** %cPtr
; tuple ref
%val9096 = getelementptr %Complexf, %Complexf* %val9095, i64 0, i32 1
%val9097 = load float, float* %val9096
%res9098 = call ccc double @ftod(float %val9097)

%val9099 = call i32 (i8*,i8*, ...) @sprintf(i8* %val9089, i8* %var9090, double %res9094, double %res9098)
store i32 %val9099, i32* %ifptr9083
br label %ifcont9083

ifcont9083:
%ifres9100 = load i32, i32* %ifptr9083

%val9101 = load i8*, i8** %strPtr
%res9102 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val9101)
ret %String* %res9102
}
@gsxtmmath377 = hidden constant [95 x i8] c"toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}** @toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9124 = load i8*, i8** %_impzPtr
%zone9125 = bitcast i8* %tzone9124 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ
%dat_toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ = call i8* @llvm_zone_malloc(%mzone* %zone9125, i64 8)
%toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ to { i8*, i8*, %String* (i8*, i8*, %Complexf*)*}***
%tzone9105 = load i8*, i8** %_impzPtr
%zone9106 = bitcast i8* %tzone9105 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9106)
; malloc closure structure
%clsptr9107 = call i8* @llvm_zone_malloc(%mzone* %zone9106, i64 24)
%closure9108 = bitcast i8* %clsptr9107 to { i8*, i8*, %String* (i8*, i8*, %Complexf*)*}*

; malloc environment structure
%envptr9109 = call i8* @llvm_zone_malloc(%mzone* %zone9106, i64 8)
%environment9110 = bitcast i8* %envptr9109 to {{i8*, i8*, %String* (i8*, i8*, %Complexf*)*}***}*

; malloc closure address table
%addytable9111 = call %clsvar* @new_address_table()
%var9112 = bitcast [42 x i8]* @gsxtmmath375 to i8*
%var9113 = bitcast [47 x i8]* @gsxtmmath376 to i8*
%addytable9114 = call %clsvar* @add_address_table(%mzone* %zone9106, i8* %var9112, i32 0, i8* %var9113, i32 3, %clsvar* %addytable9111)
%address-table9115 = bitcast %clsvar* %addytable9114 to i8*

; insert table, function and environment into closure struct
%closure.table9118 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Complexf*)*}, { i8*, i8*, %String* (i8*, i8*, %Complexf*)*}* %closure9108, i32 0, i32 0
store i8* %address-table9115, i8** %closure.table9118
%closure.env9119 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Complexf*)*}, { i8*, i8*, %String* (i8*, i8*, %Complexf*)*}* %closure9108, i32 0, i32 1
store i8* %envptr9109, i8** %closure.env9119
%closure.func9120 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Complexf*)*}, { i8*, i8*, %String* (i8*, i8*, %Complexf*)*}* %closure9108, i32 0, i32 2
store %String* (i8*, i8*, %Complexf*)* @toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ__9078, %String* (i8*, i8*, %Complexf*)** %closure.func9120
%closure_size9121 = call i64 @llvm_zone_mark_size(%mzone* %zone9106)
call void @llvm_zone_ptr_set_size(i8* %clsptr9107, i64 %closure_size9121)
%wrapper_ptr9122 = call i8* @llvm_zone_malloc(%mzone* %zone9106, i64 8)
%closure_wrapper9123 = bitcast i8* %wrapper_ptr9122 to { i8*, i8*, %String* (i8*, i8*, %Complexf*)*}**
store { i8*, i8*, %String* (i8*, i8*, %Complexf*)*}* %closure9108, { i8*, i8*, %String* (i8*, i8*, %Complexf*)*}** %closure_wrapper9123

; let value assignment
%toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, %Complexf*)*}** %closure_wrapper9123, { i8*, i8*, %String* (i8*, i8*, %Complexf*)*}** %closure_wrapper9123
store { i8*, i8*, %String* (i8*, i8*, %Complexf*)*}** %toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ, { i8*, i8*, %String* (i8*, i8*, %Complexf*)*}*** %toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ
%tmp_envptr9117 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %Complexf*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %Complexf*)*}***}* %environment9110, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}*** %toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQPtr, {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}**** %tmp_envptr9117


%val9126 = load {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}**, {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}*** %toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}** %val9126
}


@toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}** @toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ(%Complexf* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}*, {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}, {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}, {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Complexf*)*,  %String* (i8*, i8*, %Complexf*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ_native(%Complexf* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}*, {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}, {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}, {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Complexf*)*,  %String* (i8*, i8*, %Complexf*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var9127 = bitcast [95 x i8]* @gsxtmmath377 to i8*
call i32 (i8*, ...) @printf(i8* %var9127)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexf*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}*, {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}, {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}, {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Complexf*)*,  %String* (i8*, i8*, %Complexf*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf*}*
%arg_p_0 = getelementptr {%Complexf*}, {%Complexf*}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf*, %Complexf** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQ29tcGxleGYqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}*, {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}, {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}, {i8*, i8*, %String* (i8*, i8*, %Complexf*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Complexf*)*,  %String* (i8*, i8*, %Complexf*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath378 = hidden constant [58 x i8] c"xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ\00"
@gsxtmmath379 = hidden constant [58 x i8] c"{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**\00"
define dllexport fastcc %Complexf @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ__9128(i8* %_impz,i8* %_impenv, %Complexf %a, %Complexf %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9129 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}*
%xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr_ = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}* %impenv, i32 0, i32 0
%xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**** %xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr_

; setup arguments
%aPtr = alloca %Complexf
store %Complexf %a, %Complexf* %aPtr
%bPtr = alloca %Complexf
store %Complexf %b, %Complexf* %bPtr


%val9130 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9131 = extractvalue %Complexf %val9130, 0
%val9132 = load %Complexf, %Complexf* %bPtr
; tuple ref
%val9133 = extractvalue %Complexf %val9132, 0
%val9134 = fadd float %val9131, %val9133
%val9135 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9136 = extractvalue %Complexf %val9135, 1
%val9137 = load %Complexf, %Complexf* %bPtr
; tuple ref
%val9138 = extractvalue %Complexf %val9137, 1
%val9139 = fadd float %val9136, %val9138
%res9140 = call fastcc %Complexf @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ(float %val9134, float %val9139)
ret %Complexf %res9140
}
define dllexport ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9160 = load i8*, i8** %_impzPtr
%zone9161 = bitcast i8* %tzone9160 to %mzone*

; let assign value to symbol xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ
%dat_xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ = call i8* @llvm_zone_malloc(%mzone* %zone9161, i64 8)
%xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr = bitcast i8* %dat_xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***
%tzone9141 = load i8*, i8** %_impzPtr
%zone9142 = bitcast i8* %tzone9141 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9142)
; malloc closure structure
%clsptr9143 = call i8* @llvm_zone_malloc(%mzone* %zone9142, i64 24)
%closure9144 = bitcast i8* %clsptr9143 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*

; malloc environment structure
%envptr9145 = call i8* @llvm_zone_malloc(%mzone* %zone9142, i64 8)
%environment9146 = bitcast i8* %envptr9145 to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}*

; malloc closure address table
%addytable9147 = call %clsvar* @new_address_table()
%var9148 = bitcast [58 x i8]* @gsxtmmath378 to i8*
%var9149 = bitcast [58 x i8]* @gsxtmmath379 to i8*
%addytable9150 = call %clsvar* @add_address_table(%mzone* %zone9142, i8* %var9148, i32 0, i8* %var9149, i32 3, %clsvar* %addytable9147)
%address-table9151 = bitcast %clsvar* %addytable9150 to i8*

; insert table, function and environment into closure struct
%closure.table9154 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure9144, i32 0, i32 0
store i8* %address-table9151, i8** %closure.table9154
%closure.env9155 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure9144, i32 0, i32 1
store i8* %envptr9145, i8** %closure.env9155
%closure.func9156 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure9144, i32 0, i32 2
store %Complexf (i8*, i8*, %Complexf, %Complexf)* @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ__9128, %Complexf (i8*, i8*, %Complexf, %Complexf)** %closure.func9156
%closure_size9157 = call i64 @llvm_zone_mark_size(%mzone* %zone9142)
call void @llvm_zone_ptr_set_size(i8* %clsptr9143, i64 %closure_size9157)
%wrapper_ptr9158 = call i8* @llvm_zone_malloc(%mzone* %zone9142, i64 8)
%closure_wrapper9159 = bitcast i8* %wrapper_ptr9158 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure9144, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_wrapper9159

; let value assignment
%xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ = select i1 true, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_wrapper9159, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_wrapper9159
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*** %xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr

; add data to environment
; don't need to alloc for env var xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ
%tmp_envptr9153 = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}* %environment9146, i32 0, i32 0
store {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*** %xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**** %tmp_envptr9153


%val9162 = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*** %xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr
ret {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %val9162
}


@xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ(%Complexf %arg_0,%Complexf %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, %Complexf)*,  %Complexf (i8*, i8*, %Complexf, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, %Complexf %arg_1)
ret %Complexf %result
}


define dllexport ccc %Complexf @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_native(%Complexf %arg_0,%Complexf %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, %Complexf)*,  %Complexf (i8*, i8*, %Complexf, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, %Complexf %arg_1)
ret %Complexf %result
}


define dllexport ccc void @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf, %Complexf}*
%arg_p_0 = getelementptr {%Complexf, %Complexf}, {%Complexf, %Complexf}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf, %Complexf* %arg_p_0
%arg_p_1 = getelementptr {%Complexf, %Complexf}, {%Complexf, %Complexf}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexf, %Complexf* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, %Complexf)*,  %Complexf (i8*, i8*, %Complexf, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, %Complexf %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath380 = hidden constant [54 x i8] c"xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ\00"
@gsxtmmath381 = hidden constant [54 x i8] c"{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**\00"
define dllexport fastcc %Complexf @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ__9163(i8* %_impz,i8* %_impenv, %Complexf %a, float %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9164 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}*
%xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}* %impenv, i32 0, i32 0
%xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**** %xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr_

; setup arguments
%aPtr = alloca %Complexf
store %Complexf %a, %Complexf* %aPtr
%bPtr = alloca float
store float %b, float* %bPtr


%val9165 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9166 = extractvalue %Complexf %val9165, 0
%val9167 = load float, float* %bPtr
%val9168 = fadd float %val9166, %val9167
%val9169 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9170 = extractvalue %Complexf %val9169, 1
%res9171 = call fastcc %Complexf @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ(float %val9168, float %val9170)
ret %Complexf %res9171
}
@gsxtmmath382 = hidden constant [107 x i8] c"xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9191 = load i8*, i8** %_impzPtr
%zone9192 = bitcast i8* %tzone9191 to %mzone*

; let assign value to symbol xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ
%dat_xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone9192, i64 8)
%xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr = bitcast i8* %dat_xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***
%tzone9172 = load i8*, i8** %_impzPtr
%zone9173 = bitcast i8* %tzone9172 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9173)
; malloc closure structure
%clsptr9174 = call i8* @llvm_zone_malloc(%mzone* %zone9173, i64 24)
%closure9175 = bitcast i8* %clsptr9174 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*

; malloc environment structure
%envptr9176 = call i8* @llvm_zone_malloc(%mzone* %zone9173, i64 8)
%environment9177 = bitcast i8* %envptr9176 to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}*

; malloc closure address table
%addytable9178 = call %clsvar* @new_address_table()
%var9179 = bitcast [54 x i8]* @gsxtmmath380 to i8*
%var9180 = bitcast [54 x i8]* @gsxtmmath381 to i8*
%addytable9181 = call %clsvar* @add_address_table(%mzone* %zone9173, i8* %var9179, i32 0, i8* %var9180, i32 3, %clsvar* %addytable9178)
%address-table9182 = bitcast %clsvar* %addytable9181 to i8*

; insert table, function and environment into closure struct
%closure.table9185 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure9175, i32 0, i32 0
store i8* %address-table9182, i8** %closure.table9185
%closure.env9186 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure9175, i32 0, i32 1
store i8* %envptr9176, i8** %closure.env9186
%closure.func9187 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure9175, i32 0, i32 2
store %Complexf (i8*, i8*, %Complexf, float)* @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ__9163, %Complexf (i8*, i8*, %Complexf, float)** %closure.func9187
%closure_size9188 = call i64 @llvm_zone_mark_size(%mzone* %zone9173)
call void @llvm_zone_ptr_set_size(i8* %clsptr9174, i64 %closure_size9188)
%wrapper_ptr9189 = call i8* @llvm_zone_malloc(%mzone* %zone9173, i64 8)
%closure_wrapper9190 = bitcast i8* %wrapper_ptr9189 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure9175, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_wrapper9190

; let value assignment
%xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ = select i1 true, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_wrapper9190, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_wrapper9190
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*** %xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ
%tmp_envptr9184 = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}* %environment9177, i32 0, i32 0
store {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*** %xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**** %tmp_envptr9184


%val9193 = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*** %xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr
ret {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %val9193
}


@xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ(%Complexf %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, float)*,  %Complexf (i8*, i8*, %Complexf, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, float %arg_1)
ret %Complexf %result
}


define dllexport ccc %Complexf @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_native(%Complexf %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, float)*,  %Complexf (i8*, i8*, %Complexf, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, float %arg_1)
ret %Complexf %result
}


define dllexport ccc void @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf, float}*
%arg_p_0 = getelementptr {%Complexf, float}, {%Complexf, float}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf, %Complexf* %arg_p_0
%arg_p_1 = getelementptr {%Complexf, float}, {%Complexf, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, float)*,  %Complexf (i8*, i8*, %Complexf, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath383 = hidden constant [54 x i8] c"xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ\00"
@gsxtmmath384 = hidden constant [54 x i8] c"{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**\00"
define dllexport fastcc %Complexf @xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ__9195(i8* %_impz,i8* %_impenv, float %b, %Complexf %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9196 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}*
%xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr_ = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}* %impenv, i32 0, i32 0
%xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr = load {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**** %xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr_

; setup arguments
%bPtr = alloca float
store float %b, float* %bPtr
%aPtr = alloca %Complexf
store %Complexf %a, %Complexf* %aPtr


%val9197 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9198 = extractvalue %Complexf %val9197, 0
%val9199 = load float, float* %bPtr
%val9200 = fadd float %val9198, %val9199
%val9201 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9202 = extractvalue %Complexf %val9201, 1
%res9203 = call fastcc %Complexf @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ(float %val9200, float %val9202)
ret %Complexf %res9203
}
@gsxtmmath385 = hidden constant [107 x i8] c"xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** @xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9223 = load i8*, i8** %_impzPtr
%zone9224 = bitcast i8* %tzone9223 to %mzone*

; let assign value to symbol xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ
%dat_xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ = call i8* @llvm_zone_malloc(%mzone* %zone9224, i64 8)
%xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr = bitcast i8* %dat_xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ to { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***
%tzone9204 = load i8*, i8** %_impzPtr
%zone9205 = bitcast i8* %tzone9204 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9205)
; malloc closure structure
%clsptr9206 = call i8* @llvm_zone_malloc(%mzone* %zone9205, i64 24)
%closure9207 = bitcast i8* %clsptr9206 to { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*

; malloc environment structure
%envptr9208 = call i8* @llvm_zone_malloc(%mzone* %zone9205, i64 8)
%environment9209 = bitcast i8* %envptr9208 to {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}*

; malloc closure address table
%addytable9210 = call %clsvar* @new_address_table()
%var9211 = bitcast [54 x i8]* @gsxtmmath383 to i8*
%var9212 = bitcast [54 x i8]* @gsxtmmath384 to i8*
%addytable9213 = call %clsvar* @add_address_table(%mzone* %zone9205, i8* %var9211, i32 0, i8* %var9212, i32 3, %clsvar* %addytable9210)
%address-table9214 = bitcast %clsvar* %addytable9213 to i8*

; insert table, function and environment into closure struct
%closure.table9217 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure9207, i32 0, i32 0
store i8* %address-table9214, i8** %closure.table9217
%closure.env9218 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure9207, i32 0, i32 1
store i8* %envptr9208, i8** %closure.env9218
%closure.func9219 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure9207, i32 0, i32 2
store %Complexf (i8*, i8*, float, %Complexf)* @xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ__9195, %Complexf (i8*, i8*, float, %Complexf)** %closure.func9219
%closure_size9220 = call i64 @llvm_zone_mark_size(%mzone* %zone9205)
call void @llvm_zone_ptr_set_size(i8* %clsptr9206, i64 %closure_size9220)
%wrapper_ptr9221 = call i8* @llvm_zone_malloc(%mzone* %zone9205, i64 8)
%closure_wrapper9222 = bitcast i8* %wrapper_ptr9221 to { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**
store { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure9207, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_wrapper9222

; let value assignment
%xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ = select i1 true, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_wrapper9222, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_wrapper9222
store { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*** %xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr

; add data to environment
; don't need to alloc for env var xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ
%tmp_envptr9216 = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}* %environment9209, i32 0, i32 0
store {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*** %xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**** %tmp_envptr9216


%val9225 = load {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*** %xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr
ret {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %val9225
}


@xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** @xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf @xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ(float %arg_0,%Complexf %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, float, %Complexf)*,  %Complexf (i8*, i8*, float, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, float %arg_0, %Complexf %arg_1)
ret %Complexf %result
}


define dllexport ccc %Complexf @xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_native(float %arg_0,%Complexf %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, float, %Complexf)*,  %Complexf (i8*, i8*, float, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, float %arg_0, %Complexf %arg_1)
ret %Complexf %result
}


define dllexport ccc void @xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, %Complexf}*
%arg_p_0 = getelementptr {float, %Complexf}, {float, %Complexf}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, %Complexf}, {float, %Complexf}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexf, %Complexf* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, float, %Complexf)*,  %Complexf (i8*, i8*, float, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, float %arg_0, %Complexf %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath386 = hidden constant [84 x i8] c"Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ\00"
@gsxtmmath387 = hidden constant [72 x i8] c"{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**\00"
define dllexport fastcc void @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ__9227(i8* %_impz,i8* %_impenv, %Complexf* %a, %Complexf* %b, %Complexf* %c, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9228 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}*
%Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}* %impenv, i32 0, i32 0
%Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**** %Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr_

; setup arguments
%aPtr = alloca %Complexf*
store %Complexf* %a, %Complexf** %aPtr
%bPtr = alloca %Complexf*
store %Complexf* %b, %Complexf** %bPtr
%cPtr = alloca %Complexf*
store %Complexf* %c, %Complexf** %cPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr

; promote local stack var allocations
%tzone9313 = load i8*, i8** %_impzPtr
%zone9314 = bitcast i8* %tzone9313 to %mzone*
%ifptr9230 = alloca i1

%val9231 = load i64, i64* %lenPtr
%val9232 = and i64 %val9231, 1
%cmp9233 = icmp eq i64 %val9232, 0
br i1 %cmp9233, label %then9230, label %else9230

then9230:
%val9234 = trunc i64 1 to i1
store i1 %val9234, i1* %ifptr9230
br label %ifcont9230

else9230:
%val9235 = trunc i64 0 to i1
store i1 %val9235, i1* %ifptr9230
br label %ifcont9230

ifcont9230:
%ifres9236 = load i1, i1* %ifptr9230

br i1 %ifres9236, label %then9229, label %else9229

then9229:
%tzone9239 = load i8*, i8** %_impzPtr
%zone9240 = bitcast i8* %tzone9239 to %mzone*

; let assign value to symbol aa
%aaPtr = alloca <4 x float>*
%tzone9243 = load i8*, i8** %_impzPtr
%zone9244 = bitcast i8* %tzone9243 to %mzone*

; let assign value to symbol bb
%bbPtr = alloca <4 x float>*
%tzone9247 = load i8*, i8** %_impzPtr
%zone9248 = bitcast i8* %tzone9247 to %mzone*

; let assign value to symbol cc
%ccPtr = alloca <4 x float>*
%tzone9249 = load i8*, i8** %_impzPtr
%zone9250 = bitcast i8* %tzone9249 to %mzone*

; let assign value to symbol k
%kPtr = alloca i64
%val9237 = load %Complexf*, %Complexf** %aPtr
%val9238 = bitcast %Complexf* %val9237 to <4 x float>*

; let value assignment
%aa = select i1 true, <4 x float>* %val9238, <4 x float>* %val9238
store <4 x float>* %aa, <4 x float>** %aaPtr

%val9241 = load %Complexf*, %Complexf** %bPtr
%val9242 = bitcast %Complexf* %val9241 to <4 x float>*

; let value assignment
%bb = select i1 true, <4 x float>* %val9242, <4 x float>* %val9242
store <4 x float>* %bb, <4 x float>** %bbPtr

%val9245 = load %Complexf*, %Complexf** %cPtr
%val9246 = bitcast %Complexf* %val9245 to <4 x float>*

; let value assignment
%cc = select i1 true, <4 x float>* %val9246, <4 x float>* %val9246
store <4 x float>* %cc, <4 x float>** %ccPtr


; let value assignment
%k = select i1 true, i64 0, i64 0
store i64 %k, i64* %kPtr

; setup loop
%val9254 = load i64, i64* %lenPtr
%val9255 = sdiv i64 %val9254, 2
store i64 0, i64* %kPtr
%val9269 = load i64, i64* %kPtr
%num9270 = add i64 %val9255, %val9269
%comp9271 = icmp ult i64 %val9255, 1
br i1 %comp9271, label %after9251, label %loop9251

loop9251:
%val9256 = load i64, i64* %kPtr
%val9257 = load <4 x float>*, <4 x float>** %ccPtr
%val9258 = load i64, i64* %kPtr
%val9259 = load <4 x float>*, <4 x float>** %aaPtr
; pointer ref
%val9260 = getelementptr <4 x float>, <4 x float>* %val9259, i64 %val9258
%val9261 = load i64, i64* %kPtr
%val9262 = load <4 x float>*, <4 x float>** %bbPtr
; pointer ref
%val9263 = getelementptr <4 x float>, <4 x float>* %val9262, i64 %val9261
%val9264 = load <4 x float>, <4 x float>* %val9260
%val9265 = load <4 x float>, <4 x float>* %val9263
%val9266 = fadd <4 x float> %val9264, %val9265
; set pointer
%val9267 = getelementptr <4 x float>, <4 x float>* %val9257, i64 %val9256
store <4 x float> %val9266, <4 x float>* %val9267
%loop_cnt9251 = load i64, i64* %kPtr
%next9251 = add i64 %loop_cnt9251, 1
store i64 %next9251, i64* %kPtr
%cmp9251 = icmp ult i64 %next9251, %num9270
br i1 %cmp9251, label %loop9251, label %after9251

after9251:
ret void

else9229:
%tzone9273 = load i8*, i8** %_impzPtr
%zone9274 = bitcast i8* %tzone9273 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val9277 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val9308 = load i64, i64* %iPtr
%num9309 = add i64 %val9277, %val9308
%comp9310 = icmp ult i64 %val9277, 1
br i1 %comp9310, label %after9275, label %loop9275

loop9275:
%val9278 = load i64, i64* %iPtr
%val9279 = load %Complexf*, %Complexf** %cPtr
; pointer ref
%val9280 = getelementptr %Complexf, %Complexf* %val9279, i64 %val9278
%val9281 = load i64, i64* %iPtr
%val9282 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val9283 = getelementptr %Complexf, %Complexf* %val9282, i64 %val9281
; tuple ref
%val9284 = getelementptr %Complexf, %Complexf* %val9283, i64 0, i32 0
%val9285 = load float, float* %val9284
%val9286 = load i64, i64* %iPtr
%val9287 = load %Complexf*, %Complexf** %bPtr
; pointer ref
%val9288 = getelementptr %Complexf, %Complexf* %val9287, i64 %val9286
; tuple ref
%val9289 = getelementptr %Complexf, %Complexf* %val9288, i64 0, i32 0
%val9290 = load float, float* %val9289
%val9291 = fadd float %val9285, %val9290
; set tuple
%val9292 = getelementptr %Complexf, %Complexf* %val9280, i64 0, i32 0
store float %val9291, float* %val9292
%val9293 = load i64, i64* %iPtr
%val9294 = load %Complexf*, %Complexf** %cPtr
; pointer ref
%val9295 = getelementptr %Complexf, %Complexf* %val9294, i64 %val9293
%val9296 = load i64, i64* %iPtr
%val9297 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val9298 = getelementptr %Complexf, %Complexf* %val9297, i64 %val9296
; tuple ref
%val9299 = getelementptr %Complexf, %Complexf* %val9298, i64 0, i32 1
%val9300 = load float, float* %val9299
%val9301 = load i64, i64* %iPtr
%val9302 = load %Complexf*, %Complexf** %bPtr
; pointer ref
%val9303 = getelementptr %Complexf, %Complexf* %val9302, i64 %val9301
; tuple ref
%val9304 = getelementptr %Complexf, %Complexf* %val9303, i64 0, i32 1
%val9305 = load float, float* %val9304
%val9306 = fadd float %val9300, %val9305
; set tuple
%val9307 = getelementptr %Complexf, %Complexf* %val9295, i64 0, i32 1
store float %val9306, float* %val9307
%loop_cnt9275 = load i64, i64* %iPtr
%next9275 = add i64 %loop_cnt9275, 1
store i64 %next9275, i64* %iPtr
%cmp9275 = icmp ult i64 %next9275, %num9309
br i1 %cmp9275, label %loop9275, label %after9275

after9275:
ret void
}
@gsxtmmath388 = hidden constant [137 x i8] c"Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9334 = load i8*, i8** %_impzPtr
%zone9335 = bitcast i8* %tzone9334 to %mzone*

; let assign value to symbol Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ
%dat_Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone9335, i64 8)
%Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr = bitcast i8* %dat_Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ to { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***
%tzone9315 = load i8*, i8** %_impzPtr
%zone9316 = bitcast i8* %tzone9315 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9316)
; malloc closure structure
%clsptr9317 = call i8* @llvm_zone_malloc(%mzone* %zone9316, i64 24)
%closure9318 = bitcast i8* %clsptr9317 to { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*

; malloc environment structure
%envptr9319 = call i8* @llvm_zone_malloc(%mzone* %zone9316, i64 8)
%environment9320 = bitcast i8* %envptr9319 to {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}*

; malloc closure address table
%addytable9321 = call %clsvar* @new_address_table()
%var9322 = bitcast [84 x i8]* @gsxtmmath386 to i8*
%var9323 = bitcast [72 x i8]* @gsxtmmath387 to i8*
%addytable9324 = call %clsvar* @add_address_table(%mzone* %zone9316, i8* %var9322, i32 0, i8* %var9323, i32 3, %clsvar* %addytable9321)
%address-table9325 = bitcast %clsvar* %addytable9324 to i8*

; insert table, function and environment into closure struct
%closure.table9328 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure9318, i32 0, i32 0
store i8* %address-table9325, i8** %closure.table9328
%closure.env9329 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure9318, i32 0, i32 1
store i8* %envptr9319, i8** %closure.env9329
%closure.func9330 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure9318, i32 0, i32 2
store void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)* @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ__9227, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)** %closure.func9330
%closure_size9331 = call i64 @llvm_zone_mark_size(%mzone* %zone9316)
call void @llvm_zone_ptr_set_size(i8* %clsptr9317, i64 %closure_size9331)
%wrapper_ptr9332 = call i8* @llvm_zone_malloc(%mzone* %zone9316, i64 8)
%closure_wrapper9333 = bitcast i8* %wrapper_ptr9332 to { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**
store { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure9318, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_wrapper9333

; let value assignment
%Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_wrapper9333, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_wrapper9333
store { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*** %Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr

; add data to environment
; don't need to alloc for env var Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ
%tmp_envptr9327 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}* %environment9320, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*** %Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**** %tmp_envptr9327


%val9336 = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*** %Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %val9336
}


@Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ(%Complexf* %arg_0,%Complexf* %arg_1,%Complexf* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, %Complexf* %arg_1, %Complexf* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc void @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_native(%Complexf* %arg_0,%Complexf* %arg_1,%Complexf* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, %Complexf* %arg_1, %Complexf* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc i8*  @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var9337 = bitcast [137 x i8]* @gsxtmmath388 to i8*
call i32 (i8*, ...) @printf(i8* %var9337)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexf*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var9338 = bitcast [137 x i8]* @gsxtmmath388 to i8*
call i32 (i8*, ...) @printf(i8* %var9338)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Complexf*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var9339 = bitcast [137 x i8]* @gsxtmmath388 to i8*
call i32 (i8*, ...) @printf(i8* %var9339)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Complexf*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var9340 = bitcast [137 x i8]* @gsxtmmath388 to i8*
call i32 (i8*, ...) @printf(i8* %var9340)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, %Complexf* %arg_1, %Complexf* %arg_2, i64 %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf*, %Complexf*, %Complexf*, i64}*
%arg_p_0 = getelementptr {%Complexf*, %Complexf*, %Complexf*, i64}, {%Complexf*, %Complexf*, %Complexf*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf*, %Complexf** %arg_p_0
%arg_p_1 = getelementptr {%Complexf*, %Complexf*, %Complexf*, i64}, {%Complexf*, %Complexf*, %Complexf*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexf*, %Complexf** %arg_p_1
%arg_p_2 = getelementptr {%Complexf*, %Complexf*, %Complexf*, i64}, {%Complexf*, %Complexf*, %Complexf*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load %Complexf*, %Complexf** %arg_p_2
%arg_p_3 = getelementptr {%Complexf*, %Complexf*, %Complexf*, i64}, {%Complexf*, %Complexf*, %Complexf*, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_addition_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, %Complexf* %arg_1, %Complexf* %arg_2, i64 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath389 = hidden constant [61 x i8] c"xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ\00"
define dllexport fastcc %Complexf @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ__9341(i8* %_impz,i8* %_impenv, %Complexf %a, %Complexf %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9342 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}*
%xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr_ = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}* %impenv, i32 0, i32 0
%xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**** %xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr_

; setup arguments
%aPtr = alloca %Complexf
store %Complexf %a, %Complexf* %aPtr
%bPtr = alloca %Complexf
store %Complexf %b, %Complexf* %bPtr


%val9343 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9344 = extractvalue %Complexf %val9343, 0
%val9345 = load %Complexf, %Complexf* %bPtr
; tuple ref
%val9346 = extractvalue %Complexf %val9345, 0
%val9347 = fsub float %val9344, %val9346
%val9348 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9349 = extractvalue %Complexf %val9348, 1
%val9350 = load %Complexf, %Complexf* %bPtr
; tuple ref
%val9351 = extractvalue %Complexf %val9350, 1
%val9352 = fsub float %val9349, %val9351
%res9353 = call fastcc %Complexf @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ(float %val9347, float %val9352)
ret %Complexf %res9353
}
define dllexport ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9373 = load i8*, i8** %_impzPtr
%zone9374 = bitcast i8* %tzone9373 to %mzone*

; let assign value to symbol xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ
%dat_xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ = call i8* @llvm_zone_malloc(%mzone* %zone9374, i64 8)
%xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr = bitcast i8* %dat_xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***
%tzone9354 = load i8*, i8** %_impzPtr
%zone9355 = bitcast i8* %tzone9354 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9355)
; malloc closure structure
%clsptr9356 = call i8* @llvm_zone_malloc(%mzone* %zone9355, i64 24)
%closure9357 = bitcast i8* %clsptr9356 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*

; malloc environment structure
%envptr9358 = call i8* @llvm_zone_malloc(%mzone* %zone9355, i64 8)
%environment9359 = bitcast i8* %envptr9358 to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}*

; malloc closure address table
%addytable9360 = call %clsvar* @new_address_table()
%var9361 = bitcast [61 x i8]* @gsxtmmath389 to i8*
%var9362 = bitcast [58 x i8]* @gsxtmmath379 to i8*
%addytable9363 = call %clsvar* @add_address_table(%mzone* %zone9355, i8* %var9361, i32 0, i8* %var9362, i32 3, %clsvar* %addytable9360)
%address-table9364 = bitcast %clsvar* %addytable9363 to i8*

; insert table, function and environment into closure struct
%closure.table9367 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure9357, i32 0, i32 0
store i8* %address-table9364, i8** %closure.table9367
%closure.env9368 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure9357, i32 0, i32 1
store i8* %envptr9358, i8** %closure.env9368
%closure.func9369 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure9357, i32 0, i32 2
store %Complexf (i8*, i8*, %Complexf, %Complexf)* @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ__9341, %Complexf (i8*, i8*, %Complexf, %Complexf)** %closure.func9369
%closure_size9370 = call i64 @llvm_zone_mark_size(%mzone* %zone9355)
call void @llvm_zone_ptr_set_size(i8* %clsptr9356, i64 %closure_size9370)
%wrapper_ptr9371 = call i8* @llvm_zone_malloc(%mzone* %zone9355, i64 8)
%closure_wrapper9372 = bitcast i8* %wrapper_ptr9371 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure9357, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_wrapper9372

; let value assignment
%xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ = select i1 true, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_wrapper9372, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_wrapper9372
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*** %xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr

; add data to environment
; don't need to alloc for env var xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ
%tmp_envptr9366 = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}* %environment9359, i32 0, i32 0
store {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*** %xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**** %tmp_envptr9366


%val9375 = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*** %xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr
ret {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %val9375
}


@xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ(%Complexf %arg_0,%Complexf %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, %Complexf)*,  %Complexf (i8*, i8*, %Complexf, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, %Complexf %arg_1)
ret %Complexf %result
}


define dllexport ccc %Complexf @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_native(%Complexf %arg_0,%Complexf %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, %Complexf)*,  %Complexf (i8*, i8*, %Complexf, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, %Complexf %arg_1)
ret %Complexf %result
}


define dllexport ccc void @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf, %Complexf}*
%arg_p_0 = getelementptr {%Complexf, %Complexf}, {%Complexf, %Complexf}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf, %Complexf* %arg_p_0
%arg_p_1 = getelementptr {%Complexf, %Complexf}, {%Complexf, %Complexf}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexf, %Complexf* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, %Complexf)*,  %Complexf (i8*, i8*, %Complexf, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, %Complexf %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath390 = hidden constant [57 x i8] c"xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ\00"
define dllexport fastcc %Complexf @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ__9376(i8* %_impz,i8* %_impenv, %Complexf %a, float %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9377 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}*
%xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}* %impenv, i32 0, i32 0
%xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**** %xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr_

; setup arguments
%aPtr = alloca %Complexf
store %Complexf %a, %Complexf* %aPtr
%bPtr = alloca float
store float %b, float* %bPtr


%val9378 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9379 = extractvalue %Complexf %val9378, 0
%val9380 = load float, float* %bPtr
%val9381 = fsub float %val9379, %val9380
%val9382 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9383 = extractvalue %Complexf %val9382, 1
%res9384 = call fastcc %Complexf @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ(float %val9381, float %val9383)
ret %Complexf %res9384
}
@gsxtmmath391 = hidden constant [110 x i8] c"xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9404 = load i8*, i8** %_impzPtr
%zone9405 = bitcast i8* %tzone9404 to %mzone*

; let assign value to symbol xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ
%dat_xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone9405, i64 8)
%xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr = bitcast i8* %dat_xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***
%tzone9385 = load i8*, i8** %_impzPtr
%zone9386 = bitcast i8* %tzone9385 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9386)
; malloc closure structure
%clsptr9387 = call i8* @llvm_zone_malloc(%mzone* %zone9386, i64 24)
%closure9388 = bitcast i8* %clsptr9387 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*

; malloc environment structure
%envptr9389 = call i8* @llvm_zone_malloc(%mzone* %zone9386, i64 8)
%environment9390 = bitcast i8* %envptr9389 to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}*

; malloc closure address table
%addytable9391 = call %clsvar* @new_address_table()
%var9392 = bitcast [57 x i8]* @gsxtmmath390 to i8*
%var9393 = bitcast [54 x i8]* @gsxtmmath381 to i8*
%addytable9394 = call %clsvar* @add_address_table(%mzone* %zone9386, i8* %var9392, i32 0, i8* %var9393, i32 3, %clsvar* %addytable9391)
%address-table9395 = bitcast %clsvar* %addytable9394 to i8*

; insert table, function and environment into closure struct
%closure.table9398 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure9388, i32 0, i32 0
store i8* %address-table9395, i8** %closure.table9398
%closure.env9399 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure9388, i32 0, i32 1
store i8* %envptr9389, i8** %closure.env9399
%closure.func9400 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure9388, i32 0, i32 2
store %Complexf (i8*, i8*, %Complexf, float)* @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ__9376, %Complexf (i8*, i8*, %Complexf, float)** %closure.func9400
%closure_size9401 = call i64 @llvm_zone_mark_size(%mzone* %zone9386)
call void @llvm_zone_ptr_set_size(i8* %clsptr9387, i64 %closure_size9401)
%wrapper_ptr9402 = call i8* @llvm_zone_malloc(%mzone* %zone9386, i64 8)
%closure_wrapper9403 = bitcast i8* %wrapper_ptr9402 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure9388, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_wrapper9403

; let value assignment
%xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ = select i1 true, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_wrapper9403, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_wrapper9403
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*** %xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ
%tmp_envptr9397 = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}* %environment9390, i32 0, i32 0
store {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*** %xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**** %tmp_envptr9397


%val9406 = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*** %xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr
ret {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %val9406
}


@xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ(%Complexf %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, float)*,  %Complexf (i8*, i8*, %Complexf, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, float %arg_1)
ret %Complexf %result
}


define dllexport ccc %Complexf @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_native(%Complexf %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, float)*,  %Complexf (i8*, i8*, %Complexf, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, float %arg_1)
ret %Complexf %result
}


define dllexport ccc void @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf, float}*
%arg_p_0 = getelementptr {%Complexf, float}, {%Complexf, float}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf, %Complexf* %arg_p_0
%arg_p_1 = getelementptr {%Complexf, float}, {%Complexf, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, float)*,  %Complexf (i8*, i8*, %Complexf, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath392 = hidden constant [57 x i8] c"xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ\00"
define dllexport fastcc %Complexf @xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ__9408(i8* %_impz,i8* %_impenv, float %b, %Complexf %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9409 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}*
%xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr_ = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}* %impenv, i32 0, i32 0
%xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr = load {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**** %xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr_

; setup arguments
%bPtr = alloca float
store float %b, float* %bPtr
%aPtr = alloca %Complexf
store %Complexf %a, %Complexf* %aPtr


%val9410 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9411 = extractvalue %Complexf %val9410, 0
%val9412 = load float, float* %bPtr
%val9413 = fsub float %val9411, %val9412
%val9414 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9415 = extractvalue %Complexf %val9414, 1
%res9416 = call fastcc %Complexf @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ(float %val9413, float %val9415)
ret %Complexf %res9416
}
@gsxtmmath393 = hidden constant [110 x i8] c"xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** @xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9436 = load i8*, i8** %_impzPtr
%zone9437 = bitcast i8* %tzone9436 to %mzone*

; let assign value to symbol xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ
%dat_xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ = call i8* @llvm_zone_malloc(%mzone* %zone9437, i64 8)
%xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr = bitcast i8* %dat_xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ to { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***
%tzone9417 = load i8*, i8** %_impzPtr
%zone9418 = bitcast i8* %tzone9417 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9418)
; malloc closure structure
%clsptr9419 = call i8* @llvm_zone_malloc(%mzone* %zone9418, i64 24)
%closure9420 = bitcast i8* %clsptr9419 to { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*

; malloc environment structure
%envptr9421 = call i8* @llvm_zone_malloc(%mzone* %zone9418, i64 8)
%environment9422 = bitcast i8* %envptr9421 to {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}*

; malloc closure address table
%addytable9423 = call %clsvar* @new_address_table()
%var9424 = bitcast [57 x i8]* @gsxtmmath392 to i8*
%var9425 = bitcast [54 x i8]* @gsxtmmath384 to i8*
%addytable9426 = call %clsvar* @add_address_table(%mzone* %zone9418, i8* %var9424, i32 0, i8* %var9425, i32 3, %clsvar* %addytable9423)
%address-table9427 = bitcast %clsvar* %addytable9426 to i8*

; insert table, function and environment into closure struct
%closure.table9430 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure9420, i32 0, i32 0
store i8* %address-table9427, i8** %closure.table9430
%closure.env9431 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure9420, i32 0, i32 1
store i8* %envptr9421, i8** %closure.env9431
%closure.func9432 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure9420, i32 0, i32 2
store %Complexf (i8*, i8*, float, %Complexf)* @xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ__9408, %Complexf (i8*, i8*, float, %Complexf)** %closure.func9432
%closure_size9433 = call i64 @llvm_zone_mark_size(%mzone* %zone9418)
call void @llvm_zone_ptr_set_size(i8* %clsptr9419, i64 %closure_size9433)
%wrapper_ptr9434 = call i8* @llvm_zone_malloc(%mzone* %zone9418, i64 8)
%closure_wrapper9435 = bitcast i8* %wrapper_ptr9434 to { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**
store { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure9420, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_wrapper9435

; let value assignment
%xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ = select i1 true, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_wrapper9435, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_wrapper9435
store { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*** %xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr

; add data to environment
; don't need to alloc for env var xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ
%tmp_envptr9429 = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}* %environment9422, i32 0, i32 0
store {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*** %xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**** %tmp_envptr9429


%val9438 = load {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*** %xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr
ret {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %val9438
}


@xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** @xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf @xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ(float %arg_0,%Complexf %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, float, %Complexf)*,  %Complexf (i8*, i8*, float, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, float %arg_0, %Complexf %arg_1)
ret %Complexf %result
}


define dllexport ccc %Complexf @xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_native(float %arg_0,%Complexf %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, float, %Complexf)*,  %Complexf (i8*, i8*, float, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, float %arg_0, %Complexf %arg_1)
ret %Complexf %result
}


define dllexport ccc void @xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, %Complexf}*
%arg_p_0 = getelementptr {float, %Complexf}, {float, %Complexf}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, %Complexf}, {float, %Complexf}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexf, %Complexf* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, float, %Complexf)*,  %Complexf (i8*, i8*, float, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, float %arg_0, %Complexf %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath394 = hidden constant [87 x i8] c"Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ\00"
define dllexport fastcc void @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ__9440(i8* %_impz,i8* %_impenv, %Complexf* %a, %Complexf* %b, %Complexf* %c, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9441 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}*
%Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}* %impenv, i32 0, i32 0
%Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**** %Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr_

; setup arguments
%aPtr = alloca %Complexf*
store %Complexf* %a, %Complexf** %aPtr
%bPtr = alloca %Complexf*
store %Complexf* %b, %Complexf** %bPtr
%cPtr = alloca %Complexf*
store %Complexf* %c, %Complexf** %cPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr

; promote local stack var allocations
%tzone9526 = load i8*, i8** %_impzPtr
%zone9527 = bitcast i8* %tzone9526 to %mzone*
%ifptr9443 = alloca i1

%val9444 = load i64, i64* %lenPtr
%val9445 = and i64 %val9444, 1
%cmp9446 = icmp eq i64 %val9445, 0
br i1 %cmp9446, label %then9443, label %else9443

then9443:
%val9447 = trunc i64 1 to i1
store i1 %val9447, i1* %ifptr9443
br label %ifcont9443

else9443:
%val9448 = trunc i64 0 to i1
store i1 %val9448, i1* %ifptr9443
br label %ifcont9443

ifcont9443:
%ifres9449 = load i1, i1* %ifptr9443

br i1 %ifres9449, label %then9442, label %else9442

then9442:
%tzone9452 = load i8*, i8** %_impzPtr
%zone9453 = bitcast i8* %tzone9452 to %mzone*

; let assign value to symbol aa
%aaPtr = alloca <4 x float>*
%tzone9456 = load i8*, i8** %_impzPtr
%zone9457 = bitcast i8* %tzone9456 to %mzone*

; let assign value to symbol bb
%bbPtr = alloca <4 x float>*
%tzone9460 = load i8*, i8** %_impzPtr
%zone9461 = bitcast i8* %tzone9460 to %mzone*

; let assign value to symbol cc
%ccPtr = alloca <4 x float>*
%tzone9462 = load i8*, i8** %_impzPtr
%zone9463 = bitcast i8* %tzone9462 to %mzone*

; let assign value to symbol k
%kPtr = alloca i64
%val9450 = load %Complexf*, %Complexf** %aPtr
%val9451 = bitcast %Complexf* %val9450 to <4 x float>*

; let value assignment
%aa = select i1 true, <4 x float>* %val9451, <4 x float>* %val9451
store <4 x float>* %aa, <4 x float>** %aaPtr

%val9454 = load %Complexf*, %Complexf** %bPtr
%val9455 = bitcast %Complexf* %val9454 to <4 x float>*

; let value assignment
%bb = select i1 true, <4 x float>* %val9455, <4 x float>* %val9455
store <4 x float>* %bb, <4 x float>** %bbPtr

%val9458 = load %Complexf*, %Complexf** %cPtr
%val9459 = bitcast %Complexf* %val9458 to <4 x float>*

; let value assignment
%cc = select i1 true, <4 x float>* %val9459, <4 x float>* %val9459
store <4 x float>* %cc, <4 x float>** %ccPtr


; let value assignment
%k = select i1 true, i64 0, i64 0
store i64 %k, i64* %kPtr

; setup loop
%val9467 = load i64, i64* %lenPtr
%val9468 = sdiv i64 %val9467, 2
store i64 0, i64* %kPtr
%val9482 = load i64, i64* %kPtr
%num9483 = add i64 %val9468, %val9482
%comp9484 = icmp ult i64 %val9468, 1
br i1 %comp9484, label %after9464, label %loop9464

loop9464:
%val9469 = load i64, i64* %kPtr
%val9470 = load <4 x float>*, <4 x float>** %ccPtr
%val9471 = load i64, i64* %kPtr
%val9472 = load <4 x float>*, <4 x float>** %aaPtr
; pointer ref
%val9473 = getelementptr <4 x float>, <4 x float>* %val9472, i64 %val9471
%val9474 = load i64, i64* %kPtr
%val9475 = load <4 x float>*, <4 x float>** %bbPtr
; pointer ref
%val9476 = getelementptr <4 x float>, <4 x float>* %val9475, i64 %val9474
%val9477 = load <4 x float>, <4 x float>* %val9473
%val9478 = load <4 x float>, <4 x float>* %val9476
%val9479 = fsub <4 x float> %val9477, %val9478
; set pointer
%val9480 = getelementptr <4 x float>, <4 x float>* %val9470, i64 %val9469
store <4 x float> %val9479, <4 x float>* %val9480
%loop_cnt9464 = load i64, i64* %kPtr
%next9464 = add i64 %loop_cnt9464, 1
store i64 %next9464, i64* %kPtr
%cmp9464 = icmp ult i64 %next9464, %num9483
br i1 %cmp9464, label %loop9464, label %after9464

after9464:
ret void

else9442:
%tzone9486 = load i8*, i8** %_impzPtr
%zone9487 = bitcast i8* %tzone9486 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val9490 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val9521 = load i64, i64* %iPtr
%num9522 = add i64 %val9490, %val9521
%comp9523 = icmp ult i64 %val9490, 1
br i1 %comp9523, label %after9488, label %loop9488

loop9488:
%val9491 = load i64, i64* %iPtr
%val9492 = load %Complexf*, %Complexf** %cPtr
; pointer ref
%val9493 = getelementptr %Complexf, %Complexf* %val9492, i64 %val9491
%val9494 = load i64, i64* %iPtr
%val9495 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val9496 = getelementptr %Complexf, %Complexf* %val9495, i64 %val9494
; tuple ref
%val9497 = getelementptr %Complexf, %Complexf* %val9496, i64 0, i32 0
%val9498 = load float, float* %val9497
%val9499 = load i64, i64* %iPtr
%val9500 = load %Complexf*, %Complexf** %bPtr
; pointer ref
%val9501 = getelementptr %Complexf, %Complexf* %val9500, i64 %val9499
; tuple ref
%val9502 = getelementptr %Complexf, %Complexf* %val9501, i64 0, i32 0
%val9503 = load float, float* %val9502
%val9504 = fsub float %val9498, %val9503
; set tuple
%val9505 = getelementptr %Complexf, %Complexf* %val9493, i64 0, i32 0
store float %val9504, float* %val9505
%val9506 = load i64, i64* %iPtr
%val9507 = load %Complexf*, %Complexf** %cPtr
; pointer ref
%val9508 = getelementptr %Complexf, %Complexf* %val9507, i64 %val9506
%val9509 = load i64, i64* %iPtr
%val9510 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val9511 = getelementptr %Complexf, %Complexf* %val9510, i64 %val9509
; tuple ref
%val9512 = getelementptr %Complexf, %Complexf* %val9511, i64 0, i32 1
%val9513 = load float, float* %val9512
%val9514 = load i64, i64* %iPtr
%val9515 = load %Complexf*, %Complexf** %bPtr
; pointer ref
%val9516 = getelementptr %Complexf, %Complexf* %val9515, i64 %val9514
; tuple ref
%val9517 = getelementptr %Complexf, %Complexf* %val9516, i64 0, i32 1
%val9518 = load float, float* %val9517
%val9519 = fsub float %val9513, %val9518
; set tuple
%val9520 = getelementptr %Complexf, %Complexf* %val9508, i64 0, i32 1
store float %val9519, float* %val9520
%loop_cnt9488 = load i64, i64* %iPtr
%next9488 = add i64 %loop_cnt9488, 1
store i64 %next9488, i64* %iPtr
%cmp9488 = icmp ult i64 %next9488, %num9522
br i1 %cmp9488, label %loop9488, label %after9488

after9488:
ret void
}
@gsxtmmath395 = hidden constant [140 x i8] c"Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9547 = load i8*, i8** %_impzPtr
%zone9548 = bitcast i8* %tzone9547 to %mzone*

; let assign value to symbol Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ
%dat_Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone9548, i64 8)
%Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr = bitcast i8* %dat_Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ to { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***
%tzone9528 = load i8*, i8** %_impzPtr
%zone9529 = bitcast i8* %tzone9528 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9529)
; malloc closure structure
%clsptr9530 = call i8* @llvm_zone_malloc(%mzone* %zone9529, i64 24)
%closure9531 = bitcast i8* %clsptr9530 to { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*

; malloc environment structure
%envptr9532 = call i8* @llvm_zone_malloc(%mzone* %zone9529, i64 8)
%environment9533 = bitcast i8* %envptr9532 to {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}*

; malloc closure address table
%addytable9534 = call %clsvar* @new_address_table()
%var9535 = bitcast [87 x i8]* @gsxtmmath394 to i8*
%var9536 = bitcast [72 x i8]* @gsxtmmath387 to i8*
%addytable9537 = call %clsvar* @add_address_table(%mzone* %zone9529, i8* %var9535, i32 0, i8* %var9536, i32 3, %clsvar* %addytable9534)
%address-table9538 = bitcast %clsvar* %addytable9537 to i8*

; insert table, function and environment into closure struct
%closure.table9541 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure9531, i32 0, i32 0
store i8* %address-table9538, i8** %closure.table9541
%closure.env9542 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure9531, i32 0, i32 1
store i8* %envptr9532, i8** %closure.env9542
%closure.func9543 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure9531, i32 0, i32 2
store void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)* @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ__9440, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)** %closure.func9543
%closure_size9544 = call i64 @llvm_zone_mark_size(%mzone* %zone9529)
call void @llvm_zone_ptr_set_size(i8* %clsptr9530, i64 %closure_size9544)
%wrapper_ptr9545 = call i8* @llvm_zone_malloc(%mzone* %zone9529, i64 8)
%closure_wrapper9546 = bitcast i8* %wrapper_ptr9545 to { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**
store { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure9531, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_wrapper9546

; let value assignment
%Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_wrapper9546, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_wrapper9546
store { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*** %Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr

; add data to environment
; don't need to alloc for env var Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ
%tmp_envptr9540 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}* %environment9533, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*** %Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**** %tmp_envptr9540


%val9549 = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*** %Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %val9549
}


@Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ(%Complexf* %arg_0,%Complexf* %arg_1,%Complexf* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, %Complexf* %arg_1, %Complexf* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc void @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_native(%Complexf* %arg_0,%Complexf* %arg_1,%Complexf* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, %Complexf* %arg_1, %Complexf* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc i8*  @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var9550 = bitcast [140 x i8]* @gsxtmmath395 to i8*
call i32 (i8*, ...) @printf(i8* %var9550)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexf*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var9551 = bitcast [140 x i8]* @gsxtmmath395 to i8*
call i32 (i8*, ...) @printf(i8* %var9551)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Complexf*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var9552 = bitcast [140 x i8]* @gsxtmmath395 to i8*
call i32 (i8*, ...) @printf(i8* %var9552)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Complexf*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var9553 = bitcast [140 x i8]* @gsxtmmath395 to i8*
call i32 (i8*, ...) @printf(i8* %var9553)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, %Complexf* %arg_1, %Complexf* %arg_2, i64 %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf*, %Complexf*, %Complexf*, i64}*
%arg_p_0 = getelementptr {%Complexf*, %Complexf*, %Complexf*, i64}, {%Complexf*, %Complexf*, %Complexf*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf*, %Complexf** %arg_p_0
%arg_p_1 = getelementptr {%Complexf*, %Complexf*, %Complexf*, i64}, {%Complexf*, %Complexf*, %Complexf*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexf*, %Complexf** %arg_p_1
%arg_p_2 = getelementptr {%Complexf*, %Complexf*, %Complexf*, i64}, {%Complexf*, %Complexf*, %Complexf*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load %Complexf*, %Complexf** %arg_p_2
%arg_p_3 = getelementptr {%Complexf*, %Complexf*, %Complexf*, i64}, {%Complexf*, %Complexf*, %Complexf*, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_subtraction_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, %Complexf* %arg_1, %Complexf* %arg_2, i64 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath396 = hidden constant [64 x i8] c"xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ\00"
define dllexport fastcc %Complexf @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ__9554(i8* %_impz,i8* %_impenv, %Complexf %a, %Complexf %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9555 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}*
%xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr_ = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}* %impenv, i32 0, i32 0
%xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**** %xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr_

; setup arguments
%aPtr = alloca %Complexf
store %Complexf %a, %Complexf* %aPtr
%bPtr = alloca %Complexf
store %Complexf %b, %Complexf* %bPtr


%val9556 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9557 = extractvalue %Complexf %val9556, 0
%val9558 = load %Complexf, %Complexf* %bPtr
; tuple ref
%val9559 = extractvalue %Complexf %val9558, 0
%val9560 = fmul float %val9557, %val9559
%val9561 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9562 = extractvalue %Complexf %val9561, 1
%val9563 = load %Complexf, %Complexf* %bPtr
; tuple ref
%val9564 = extractvalue %Complexf %val9563, 1
%val9565 = fmul float %val9562, %val9564
%val9566 = fsub float %val9560, %val9565
%val9567 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9568 = extractvalue %Complexf %val9567, 0
%val9569 = load %Complexf, %Complexf* %bPtr
; tuple ref
%val9570 = extractvalue %Complexf %val9569, 1
%val9571 = fmul float %val9568, %val9570
%val9572 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9573 = extractvalue %Complexf %val9572, 1
%val9574 = load %Complexf, %Complexf* %bPtr
; tuple ref
%val9575 = extractvalue %Complexf %val9574, 0
%val9576 = fmul float %val9573, %val9575
%val9577 = fadd float %val9571, %val9576
%res9578 = call fastcc %Complexf @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ(float %val9566, float %val9577)
ret %Complexf %res9578
}
define dllexport ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9598 = load i8*, i8** %_impzPtr
%zone9599 = bitcast i8* %tzone9598 to %mzone*

; let assign value to symbol xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ
%dat_xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ = call i8* @llvm_zone_malloc(%mzone* %zone9599, i64 8)
%xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr = bitcast i8* %dat_xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***
%tzone9579 = load i8*, i8** %_impzPtr
%zone9580 = bitcast i8* %tzone9579 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9580)
; malloc closure structure
%clsptr9581 = call i8* @llvm_zone_malloc(%mzone* %zone9580, i64 24)
%closure9582 = bitcast i8* %clsptr9581 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*

; malloc environment structure
%envptr9583 = call i8* @llvm_zone_malloc(%mzone* %zone9580, i64 8)
%environment9584 = bitcast i8* %envptr9583 to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}*

; malloc closure address table
%addytable9585 = call %clsvar* @new_address_table()
%var9586 = bitcast [64 x i8]* @gsxtmmath396 to i8*
%var9587 = bitcast [58 x i8]* @gsxtmmath379 to i8*
%addytable9588 = call %clsvar* @add_address_table(%mzone* %zone9580, i8* %var9586, i32 0, i8* %var9587, i32 3, %clsvar* %addytable9585)
%address-table9589 = bitcast %clsvar* %addytable9588 to i8*

; insert table, function and environment into closure struct
%closure.table9592 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure9582, i32 0, i32 0
store i8* %address-table9589, i8** %closure.table9592
%closure.env9593 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure9582, i32 0, i32 1
store i8* %envptr9583, i8** %closure.env9593
%closure.func9594 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure9582, i32 0, i32 2
store %Complexf (i8*, i8*, %Complexf, %Complexf)* @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ__9554, %Complexf (i8*, i8*, %Complexf, %Complexf)** %closure.func9594
%closure_size9595 = call i64 @llvm_zone_mark_size(%mzone* %zone9580)
call void @llvm_zone_ptr_set_size(i8* %clsptr9581, i64 %closure_size9595)
%wrapper_ptr9596 = call i8* @llvm_zone_malloc(%mzone* %zone9580, i64 8)
%closure_wrapper9597 = bitcast i8* %wrapper_ptr9596 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure9582, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_wrapper9597

; let value assignment
%xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ = select i1 true, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_wrapper9597, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_wrapper9597
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*** %xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr

; add data to environment
; don't need to alloc for env var xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ
%tmp_envptr9591 = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}* %environment9584, i32 0, i32 0
store {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*** %xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**** %tmp_envptr9591


%val9600 = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*** %xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr
ret {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %val9600
}


@xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ(%Complexf %arg_0,%Complexf %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, %Complexf)*,  %Complexf (i8*, i8*, %Complexf, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, %Complexf %arg_1)
ret %Complexf %result
}


define dllexport ccc %Complexf @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_native(%Complexf %arg_0,%Complexf %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, %Complexf)*,  %Complexf (i8*, i8*, %Complexf, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, %Complexf %arg_1)
ret %Complexf %result
}


define dllexport ccc void @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf, %Complexf}*
%arg_p_0 = getelementptr {%Complexf, %Complexf}, {%Complexf, %Complexf}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf, %Complexf* %arg_p_0
%arg_p_1 = getelementptr {%Complexf, %Complexf}, {%Complexf, %Complexf}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexf, %Complexf* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, %Complexf)*,  %Complexf (i8*, i8*, %Complexf, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, %Complexf %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath397 = hidden constant [60 x i8] c"xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ\00"
define dllexport fastcc %Complexf @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ__9601(i8* %_impz,i8* %_impenv, %Complexf %a, float %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9602 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}*
%xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}* %impenv, i32 0, i32 0
%xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**** %xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr_

; setup arguments
%aPtr = alloca %Complexf
store %Complexf %a, %Complexf* %aPtr
%bPtr = alloca float
store float %b, float* %bPtr


%val9603 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9604 = extractvalue %Complexf %val9603, 0
%val9605 = load float, float* %bPtr
%val9606 = fmul float %val9604, %val9605
%val9607 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9608 = extractvalue %Complexf %val9607, 1
%val9609 = fsub float %val9606, %val9608
%val9610 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9611 = extractvalue %Complexf %val9610, 0
%val9612 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9613 = extractvalue %Complexf %val9612, 1
%val9614 = load float, float* %bPtr
%val9615 = fmul float %val9613, %val9614
%val9616 = fadd float %val9611, %val9615
%res9617 = call fastcc %Complexf @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ(float %val9609, float %val9616)
ret %Complexf %res9617
}
@gsxtmmath398 = hidden constant [113 x i8] c"xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9637 = load i8*, i8** %_impzPtr
%zone9638 = bitcast i8* %tzone9637 to %mzone*

; let assign value to symbol xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ
%dat_xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone9638, i64 8)
%xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr = bitcast i8* %dat_xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***
%tzone9618 = load i8*, i8** %_impzPtr
%zone9619 = bitcast i8* %tzone9618 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9619)
; malloc closure structure
%clsptr9620 = call i8* @llvm_zone_malloc(%mzone* %zone9619, i64 24)
%closure9621 = bitcast i8* %clsptr9620 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*

; malloc environment structure
%envptr9622 = call i8* @llvm_zone_malloc(%mzone* %zone9619, i64 8)
%environment9623 = bitcast i8* %envptr9622 to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}*

; malloc closure address table
%addytable9624 = call %clsvar* @new_address_table()
%var9625 = bitcast [60 x i8]* @gsxtmmath397 to i8*
%var9626 = bitcast [54 x i8]* @gsxtmmath381 to i8*
%addytable9627 = call %clsvar* @add_address_table(%mzone* %zone9619, i8* %var9625, i32 0, i8* %var9626, i32 3, %clsvar* %addytable9624)
%address-table9628 = bitcast %clsvar* %addytable9627 to i8*

; insert table, function and environment into closure struct
%closure.table9631 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure9621, i32 0, i32 0
store i8* %address-table9628, i8** %closure.table9631
%closure.env9632 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure9621, i32 0, i32 1
store i8* %envptr9622, i8** %closure.env9632
%closure.func9633 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure9621, i32 0, i32 2
store %Complexf (i8*, i8*, %Complexf, float)* @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ__9601, %Complexf (i8*, i8*, %Complexf, float)** %closure.func9633
%closure_size9634 = call i64 @llvm_zone_mark_size(%mzone* %zone9619)
call void @llvm_zone_ptr_set_size(i8* %clsptr9620, i64 %closure_size9634)
%wrapper_ptr9635 = call i8* @llvm_zone_malloc(%mzone* %zone9619, i64 8)
%closure_wrapper9636 = bitcast i8* %wrapper_ptr9635 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure9621, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_wrapper9636

; let value assignment
%xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ = select i1 true, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_wrapper9636, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_wrapper9636
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*** %xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ
%tmp_envptr9630 = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}* %environment9623, i32 0, i32 0
store {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*** %xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**** %tmp_envptr9630


%val9639 = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*** %xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr
ret {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %val9639
}


@xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ(%Complexf %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, float)*,  %Complexf (i8*, i8*, %Complexf, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, float %arg_1)
ret %Complexf %result
}


define dllexport ccc %Complexf @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_native(%Complexf %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, float)*,  %Complexf (i8*, i8*, %Complexf, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, float %arg_1)
ret %Complexf %result
}


define dllexport ccc void @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf, float}*
%arg_p_0 = getelementptr {%Complexf, float}, {%Complexf, float}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf, %Complexf* %arg_p_0
%arg_p_1 = getelementptr {%Complexf, float}, {%Complexf, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, float)*,  %Complexf (i8*, i8*, %Complexf, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath399 = hidden constant [60 x i8] c"xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ\00"
define dllexport fastcc %Complexf @xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ__9641(i8* %_impz,i8* %_impenv, float %b, %Complexf %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9642 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}*
%xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr_ = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}* %impenv, i32 0, i32 0
%xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr = load {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**** %xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr_

; setup arguments
%bPtr = alloca float
store float %b, float* %bPtr
%aPtr = alloca %Complexf
store %Complexf %a, %Complexf* %aPtr


%val9643 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9644 = extractvalue %Complexf %val9643, 0
%val9645 = load float, float* %bPtr
%val9646 = fmul float %val9644, %val9645
%val9647 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9648 = extractvalue %Complexf %val9647, 1
%val9649 = fsub float %val9646, %val9648
%val9650 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9651 = extractvalue %Complexf %val9650, 0
%val9652 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9653 = extractvalue %Complexf %val9652, 1
%val9654 = load float, float* %bPtr
%val9655 = fmul float %val9653, %val9654
%val9656 = fadd float %val9651, %val9655
%res9657 = call fastcc %Complexf @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ(float %val9649, float %val9656)
ret %Complexf %res9657
}
@gsxtmmath400 = hidden constant [113 x i8] c"xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** @xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9677 = load i8*, i8** %_impzPtr
%zone9678 = bitcast i8* %tzone9677 to %mzone*

; let assign value to symbol xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ
%dat_xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ = call i8* @llvm_zone_malloc(%mzone* %zone9678, i64 8)
%xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr = bitcast i8* %dat_xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ to { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***
%tzone9658 = load i8*, i8** %_impzPtr
%zone9659 = bitcast i8* %tzone9658 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9659)
; malloc closure structure
%clsptr9660 = call i8* @llvm_zone_malloc(%mzone* %zone9659, i64 24)
%closure9661 = bitcast i8* %clsptr9660 to { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*

; malloc environment structure
%envptr9662 = call i8* @llvm_zone_malloc(%mzone* %zone9659, i64 8)
%environment9663 = bitcast i8* %envptr9662 to {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}*

; malloc closure address table
%addytable9664 = call %clsvar* @new_address_table()
%var9665 = bitcast [60 x i8]* @gsxtmmath399 to i8*
%var9666 = bitcast [54 x i8]* @gsxtmmath384 to i8*
%addytable9667 = call %clsvar* @add_address_table(%mzone* %zone9659, i8* %var9665, i32 0, i8* %var9666, i32 3, %clsvar* %addytable9664)
%address-table9668 = bitcast %clsvar* %addytable9667 to i8*

; insert table, function and environment into closure struct
%closure.table9671 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure9661, i32 0, i32 0
store i8* %address-table9668, i8** %closure.table9671
%closure.env9672 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure9661, i32 0, i32 1
store i8* %envptr9662, i8** %closure.env9672
%closure.func9673 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure9661, i32 0, i32 2
store %Complexf (i8*, i8*, float, %Complexf)* @xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ__9641, %Complexf (i8*, i8*, float, %Complexf)** %closure.func9673
%closure_size9674 = call i64 @llvm_zone_mark_size(%mzone* %zone9659)
call void @llvm_zone_ptr_set_size(i8* %clsptr9660, i64 %closure_size9674)
%wrapper_ptr9675 = call i8* @llvm_zone_malloc(%mzone* %zone9659, i64 8)
%closure_wrapper9676 = bitcast i8* %wrapper_ptr9675 to { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**
store { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure9661, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_wrapper9676

; let value assignment
%xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ = select i1 true, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_wrapper9676, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_wrapper9676
store { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*** %xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr

; add data to environment
; don't need to alloc for env var xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ
%tmp_envptr9670 = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}* %environment9663, i32 0, i32 0
store {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*** %xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**** %tmp_envptr9670


%val9679 = load {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*** %xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr
ret {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %val9679
}


@xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** @xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf @xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ(float %arg_0,%Complexf %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, float, %Complexf)*,  %Complexf (i8*, i8*, float, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, float %arg_0, %Complexf %arg_1)
ret %Complexf %result
}


define dllexport ccc %Complexf @xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_native(float %arg_0,%Complexf %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, float, %Complexf)*,  %Complexf (i8*, i8*, float, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, float %arg_0, %Complexf %arg_1)
ret %Complexf %result
}


define dllexport ccc void @xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, %Complexf}*
%arg_p_0 = getelementptr {float, %Complexf}, {float, %Complexf}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, %Complexf}, {float, %Complexf}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexf, %Complexf* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, float, %Complexf)*,  %Complexf (i8*, i8*, float, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, float %arg_0, %Complexf %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath401 = hidden constant [90 x i8] c"Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ\00"
@gsxtmmath402 = hidden constant [3 x i8] c"dd\00"
@gsxtmmath403 = hidden constant [13 x i8] c"<4 x float>*\00"
@gsxtmmath404 = hidden constant [16 x i8] c"_anon_lambda_11\00"
define dllexport fastcc void @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ__9681(i8* %_impz,i8* %_impenv, %Complexf* %a, %Complexf* %b, %Complexf* %c, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9704 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***, <4 x float>**, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}*
%Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***, <4 x float>**, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***, <4 x float>**, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}* %impenv, i32 0, i32 0
%Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**** %Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr_
%ddPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***, <4 x float>**, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***, <4 x float>**, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}* %impenv, i32 0, i32 1
%ddPtr = load <4 x float>**, <4 x float>*** %ddPtr_
%_anon_lambda_11Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***, <4 x float>**, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***, <4 x float>**, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_11Ptr = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**** %_anon_lambda_11Ptr_

; setup arguments
%aPtr = alloca %Complexf*
store %Complexf* %a, %Complexf** %aPtr
%bPtr = alloca %Complexf*
store %Complexf* %b, %Complexf** %bPtr
%cPtr = alloca %Complexf*
store %Complexf* %c, %Complexf** %cPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr

; promote local stack var allocations
%tzone9838 = load i8*, i8** %_impzPtr
%zone9839 = bitcast i8* %tzone9838 to %mzone*
%ifptr9706 = alloca i1

%val9707 = load i64, i64* %lenPtr
%val9708 = and i64 %val9707, 1
%cmp9709 = icmp eq i64 %val9708, 0
br i1 %cmp9709, label %then9706, label %else9706

then9706:
%val9710 = trunc i64 1 to i1
store i1 %val9710, i1* %ifptr9706
br label %ifcont9706

else9706:
%val9711 = trunc i64 0 to i1
store i1 %val9711, i1* %ifptr9706
br label %ifcont9706

ifcont9706:
%ifres9712 = load i1, i1* %ifptr9706

br i1 %ifres9712, label %then9705, label %else9705

then9705:
%tzone9713 = load i8*, i8** %_impzPtr
%zone9714 = bitcast i8* %tzone9713 to %mzone*

; let assign value to symbol j
%jPtr = alloca i64
%tzone9717 = load i8*, i8** %_impzPtr
%zone9718 = bitcast i8* %tzone9717 to %mzone*

; let assign value to symbol aa
%aaPtr = alloca <4 x float>*
%tzone9721 = load i8*, i8** %_impzPtr
%zone9722 = bitcast i8* %tzone9721 to %mzone*

; let assign value to symbol bb
%bbPtr = alloca <4 x float>*
%tzone9725 = load i8*, i8** %_impzPtr
%zone9726 = bitcast i8* %tzone9725 to %mzone*

; let assign value to symbol cc
%ccPtr = alloca <4 x float>*

; let value assignment
%j = select i1 true, i64 0, i64 0
store i64 %j, i64* %jPtr

%val9715 = load %Complexf*, %Complexf** %aPtr
%val9716 = bitcast %Complexf* %val9715 to <4 x float>*

; let value assignment
%aa = select i1 true, <4 x float>* %val9716, <4 x float>* %val9716
store <4 x float>* %aa, <4 x float>** %aaPtr

%val9719 = load %Complexf*, %Complexf** %bPtr
%val9720 = bitcast %Complexf* %val9719 to <4 x float>*

; let value assignment
%bb = select i1 true, <4 x float>* %val9720, <4 x float>* %val9720
store <4 x float>* %bb, <4 x float>** %bbPtr

%val9723 = load %Complexf*, %Complexf** %cPtr
%val9724 = bitcast %Complexf* %val9723 to <4 x float>*

; let value assignment
%cc = select i1 true, <4 x float>* %val9724, <4 x float>* %val9724
store <4 x float>* %cc, <4 x float>** %ccPtr

; setup loop
%val9730 = load i64, i64* %lenPtr
%val9731 = sdiv i64 %val9730, 2
store i64 0, i64* %jPtr
%val9769 = load i64, i64* %jPtr
%num9770 = add i64 %val9731, %val9769
%comp9771 = icmp ult i64 %val9731, 1
br i1 %comp9771, label %after9727, label %loop9727

loop9727:
%val9732 = load i64, i64* %jPtr
%val9733 = load <4 x float>*, <4 x float>** %ccPtr
; shuffle vector
%val9735 = load i64, i64* %jPtr
%val9736 = load <4 x float>*, <4 x float>** %aaPtr
; pointer ref
%val9737 = getelementptr <4 x float>, <4 x float>* %val9736, i64 %val9735
%null9738 = bitcast i8* null to i8*
%val9739 = load <4 x float>, <4 x float>* %val9737
%vect9740 = shufflevector <4 x float> %val9739, <4 x float> undef, <4 x i32> <i32 0, i32 0, i32 2, i32 2>; shuffle vector
%val9742 = load i64, i64* %jPtr
%val9743 = load <4 x float>*, <4 x float>** %bbPtr
; pointer ref
%val9744 = getelementptr <4 x float>, <4 x float>* %val9743, i64 %val9742
%null9745 = bitcast i8* null to i8*
%val9746 = load <4 x float>, <4 x float>* %val9744
%vect9747 = shufflevector <4 x float> %val9746, <4 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>%val9748 = fmul <4 x float> %vect9740, %vect9747
; shuffle vector
%val9750 = load i64, i64* %jPtr
%val9751 = load <4 x float>*, <4 x float>** %aaPtr
; pointer ref
%val9752 = getelementptr <4 x float>, <4 x float>* %val9751, i64 %val9750
%null9753 = bitcast i8* null to i8*
%val9754 = load <4 x float>, <4 x float>* %val9752
%vect9755 = shufflevector <4 x float> %val9754, <4 x float> undef, <4 x i32> <i32 1, i32 1, i32 3, i32 3>; shuffle vector
%val9757 = load i64, i64* %jPtr
%val9758 = load <4 x float>*, <4 x float>** %bbPtr
; pointer ref
%val9759 = getelementptr <4 x float>, <4 x float>* %val9758, i64 %val9757
%null9760 = bitcast i8* null to i8*
%val9761 = load <4 x float>, <4 x float>* %val9759
%vect9762 = shufflevector <4 x float> %val9761, <4 x float> undef, <4 x i32> <i32 1, i32 0, i32 3, i32 2>%val9763 = fmul <4 x float> %vect9755, %vect9762
%val9764 = load <4 x float>*, <4 x float>** %ddPtr
%val9765 = load <4 x float>, <4 x float>* %val9764
%val9766 = fmul <4 x float> %val9763, %val9765
%val9767 = fadd <4 x float> %val9748, %val9766
; set pointer
%val9768 = getelementptr <4 x float>, <4 x float>* %val9733, i64 %val9732
store <4 x float> %val9767, <4 x float>* %val9768
%loop_cnt9727 = load i64, i64* %jPtr
%next9727 = add i64 %loop_cnt9727, 1
store i64 %next9727, i64* %jPtr
%cmp9727 = icmp ult i64 %next9727, %num9770
br i1 %cmp9727, label %loop9727, label %after9727

after9727:
ret void

else9705:
%tzone9774 = load i8*, i8** %_impzPtr
%zone9775 = bitcast i8* %tzone9774 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val9778 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val9833 = load i64, i64* %iPtr
%num9834 = add i64 %val9778, %val9833
%comp9835 = icmp ult i64 %val9778, 1
br i1 %comp9835, label %after9776, label %loop9776

loop9776:
%val9779 = load i64, i64* %iPtr
%val9780 = load %Complexf*, %Complexf** %cPtr
; pointer ref
%val9781 = getelementptr %Complexf, %Complexf* %val9780, i64 %val9779
%val9782 = load i64, i64* %iPtr
%val9783 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val9784 = getelementptr %Complexf, %Complexf* %val9783, i64 %val9782
; tuple ref
%val9785 = getelementptr %Complexf, %Complexf* %val9784, i64 0, i32 0
%val9786 = load float, float* %val9785
%val9787 = load i64, i64* %iPtr
%val9788 = load %Complexf*, %Complexf** %bPtr
; pointer ref
%val9789 = getelementptr %Complexf, %Complexf* %val9788, i64 %val9787
; tuple ref
%val9790 = getelementptr %Complexf, %Complexf* %val9789, i64 0, i32 0
%val9791 = load float, float* %val9790
%val9792 = fmul float %val9786, %val9791
%val9793 = load i64, i64* %iPtr
%val9794 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val9795 = getelementptr %Complexf, %Complexf* %val9794, i64 %val9793
; tuple ref
%val9796 = getelementptr %Complexf, %Complexf* %val9795, i64 0, i32 1
%val9797 = load float, float* %val9796
%val9798 = load i64, i64* %iPtr
%val9799 = load %Complexf*, %Complexf** %bPtr
; pointer ref
%val9800 = getelementptr %Complexf, %Complexf* %val9799, i64 %val9798
; tuple ref
%val9801 = getelementptr %Complexf, %Complexf* %val9800, i64 0, i32 1
%val9802 = load float, float* %val9801
%val9803 = fmul float %val9797, %val9802
%val9804 = fsub float %val9792, %val9803
; set tuple
%val9805 = getelementptr %Complexf, %Complexf* %val9781, i64 0, i32 0
store float %val9804, float* %val9805
%val9806 = load i64, i64* %iPtr
%val9807 = load %Complexf*, %Complexf** %cPtr
; pointer ref
%val9808 = getelementptr %Complexf, %Complexf* %val9807, i64 %val9806
%val9809 = load i64, i64* %iPtr
%val9810 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val9811 = getelementptr %Complexf, %Complexf* %val9810, i64 %val9809
; tuple ref
%val9812 = getelementptr %Complexf, %Complexf* %val9811, i64 0, i32 0
%val9813 = load float, float* %val9812
%val9814 = load i64, i64* %iPtr
%val9815 = load %Complexf*, %Complexf** %bPtr
; pointer ref
%val9816 = getelementptr %Complexf, %Complexf* %val9815, i64 %val9814
; tuple ref
%val9817 = getelementptr %Complexf, %Complexf* %val9816, i64 0, i32 1
%val9818 = load float, float* %val9817
%val9819 = fmul float %val9813, %val9818
%val9820 = load i64, i64* %iPtr
%val9821 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val9822 = getelementptr %Complexf, %Complexf* %val9821, i64 %val9820
; tuple ref
%val9823 = getelementptr %Complexf, %Complexf* %val9822, i64 0, i32 1
%val9824 = load float, float* %val9823
%val9825 = load i64, i64* %iPtr
%val9826 = load %Complexf*, %Complexf** %bPtr
; pointer ref
%val9827 = getelementptr %Complexf, %Complexf* %val9826, i64 %val9825
; tuple ref
%val9828 = getelementptr %Complexf, %Complexf* %val9827, i64 0, i32 0
%val9829 = load float, float* %val9828
%val9830 = fmul float %val9824, %val9829
%val9831 = fadd float %val9819, %val9830
; set tuple
%val9832 = getelementptr %Complexf, %Complexf* %val9808, i64 0, i32 1
store float %val9831, float* %val9832
%loop_cnt9776 = load i64, i64* %iPtr
%next9776 = add i64 %loop_cnt9776, 1
store i64 %next9776, i64* %iPtr
%cmp9776 = icmp ult i64 %next9776, %num9834
br i1 %cmp9776, label %loop9776, label %after9776

after9776:
ret void
}
@gsxtmmath405 = hidden constant [143 x i8] c"Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9872 = load i8*, i8** %_impzPtr
%zone9873 = bitcast i8* %tzone9872 to %mzone*

; let assign value to symbol Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ
%dat_Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone9873, i64 8)
%Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr = bitcast i8* %dat_Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ to {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***
%tzone9686 = load i8*, i8** %_impzPtr
%zone9687 = bitcast i8* %tzone9686 to %mzone*

; let assign value to symbol dd
%dat_dd = call i8* @llvm_zone_malloc(%mzone* %zone9687, i64 8)
%ddPtr = bitcast i8* %dat_dd to <4 x float>**
%tzone9682 = load i8*, i8** %_impzPtr
%zone9683 = bitcast i8* %tzone9682 to %mzone*
%dat9684 = call i8* @llvm_zone_malloc(%mzone* %zone9683, i64 16)
call i8* @memset(i8* %dat9684, i32 0, i64 16)
%val9685 = bitcast i8* %dat9684 to <4 x float>*

; let value assignment
%dd = select i1 true, <4 x float>* %val9685, <4 x float>* %val9685
store <4 x float>* %dd, <4 x float>** %ddPtr

%val9688 = load <4 x float>*, <4 x float>** %ddPtr
; set vector
%vect9689 = load <4 x float>, <4 x float>* %val9688
%vect29690 = insertelement <4 x float> %vect9689, float 0xbff0000000000000, i32 0
store <4 x float> %vect29690, <4 x float>* %val9688
%val9692 = load <4 x float>*, <4 x float>** %ddPtr
; set vector
%vect9693 = load <4 x float>, <4 x float>* %val9692
%vect29694 = insertelement <4 x float> %vect9693, float 0x3ff0000000000000, i32 1
store <4 x float> %vect29694, <4 x float>* %val9692
%val9696 = load <4 x float>*, <4 x float>** %ddPtr
; set vector
%vect9697 = load <4 x float>, <4 x float>* %val9696
%vect29698 = insertelement <4 x float> %vect9697, float 0xbff0000000000000, i32 2
store <4 x float> %vect29698, <4 x float>* %val9696
%val9700 = load <4 x float>*, <4 x float>** %ddPtr
; set vector
%vect9701 = load <4 x float>, <4 x float>* %val9700
%vect29702 = insertelement <4 x float> %vect9701, float 0x3ff0000000000000, i32 3
store <4 x float> %vect29702, <4 x float>* %val9700
%tzone9869 = load i8*, i8** %_impzPtr
%zone9870 = bitcast i8* %tzone9869 to %mzone*

; let assign value to symbol _anon_lambda_11
%dat__anon_lambda_11 = call i8* @llvm_zone_malloc(%mzone* %zone9870, i64 8)
%_anon_lambda_11Ptr = bitcast i8* %dat__anon_lambda_11 to { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***
%tzone9840 = load i8*, i8** %_impzPtr
%zone9841 = bitcast i8* %tzone9840 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9841)
; malloc closure structure
%clsptr9842 = call i8* @llvm_zone_malloc(%mzone* %zone9841, i64 24)
%closure9843 = bitcast i8* %clsptr9842 to { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*

; malloc environment structure
%envptr9844 = call i8* @llvm_zone_malloc(%mzone* %zone9841, i64 24)
%environment9845 = bitcast i8* %envptr9844 to {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***, <4 x float>**, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}*

; malloc closure address table
%addytable9846 = call %clsvar* @new_address_table()
%var9847 = bitcast [90 x i8]* @gsxtmmath401 to i8*
%var9848 = bitcast [72 x i8]* @gsxtmmath387 to i8*
%addytable9849 = call %clsvar* @add_address_table(%mzone* %zone9841, i8* %var9847, i32 0, i8* %var9848, i32 3, %clsvar* %addytable9846)
%var9850 = bitcast [3 x i8]* @gsxtmmath402 to i8*
%var9851 = bitcast [13 x i8]* @gsxtmmath403 to i8*
%addytable9852 = call %clsvar* @add_address_table(%mzone* %zone9841, i8* %var9850, i32 8, i8* %var9851, i32 3, %clsvar* %addytable9849)
%var9853 = bitcast [16 x i8]* @gsxtmmath404 to i8*
%var9854 = bitcast [72 x i8]* @gsxtmmath387 to i8*
%addytable9855 = call %clsvar* @add_address_table(%mzone* %zone9841, i8* %var9853, i32 16, i8* %var9854, i32 3, %clsvar* %addytable9852)
%address-table9856 = bitcast %clsvar* %addytable9855 to i8*

; insert table, function and environment into closure struct
%closure.table9863 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure9843, i32 0, i32 0
store i8* %address-table9856, i8** %closure.table9863
%closure.env9864 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure9843, i32 0, i32 1
store i8* %envptr9844, i8** %closure.env9864
%closure.func9865 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure9843, i32 0, i32 2
store void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)* @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ__9681, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)** %closure.func9865
%closure_size9866 = call i64 @llvm_zone_mark_size(%mzone* %zone9841)
call void @llvm_zone_ptr_set_size(i8* %clsptr9842, i64 %closure_size9866)
%wrapper_ptr9867 = call i8* @llvm_zone_malloc(%mzone* %zone9841, i64 8)
%closure_wrapper9868 = bitcast i8* %wrapper_ptr9867 to { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**
store { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure9843, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_wrapper9868

; let value assignment
%_anon_lambda_11 = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_wrapper9868, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_wrapper9868
store { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %_anon_lambda_11, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*** %_anon_lambda_11Ptr

; add data to environment
; don't need to alloc for env var Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ
%tmp_envptr9858 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***, <4 x float>**, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***, <4 x float>**, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}* %environment9845, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*** %Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**** %tmp_envptr9858

; don't need to alloc for env var dd
%tmp_envptr9860 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***, <4 x float>**, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***, <4 x float>**, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}* %environment9845, i32 0, i32 1
store <4 x float>** %ddPtr, <4 x float>*** %tmp_envptr9860

; don't need to alloc for env var _anon_lambda_11
%tmp_envptr9862 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***, <4 x float>**, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***, <4 x float>**, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}* %environment9845, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*** %_anon_lambda_11Ptr, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**** %tmp_envptr9862


%val9871 = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*** %_anon_lambda_11Ptr

; let value assignment
%Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ = select i1 true, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %val9871, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %val9871
store {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*** %Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr

%val9874 = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*** %Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %val9874
}


@Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ(%Complexf* %arg_0,%Complexf* %arg_1,%Complexf* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, %Complexf* %arg_1, %Complexf* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc void @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_native(%Complexf* %arg_0,%Complexf* %arg_1,%Complexf* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, %Complexf* %arg_1, %Complexf* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc i8*  @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var9875 = bitcast [143 x i8]* @gsxtmmath405 to i8*
call i32 (i8*, ...) @printf(i8* %var9875)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexf*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var9876 = bitcast [143 x i8]* @gsxtmmath405 to i8*
call i32 (i8*, ...) @printf(i8* %var9876)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Complexf*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var9877 = bitcast [143 x i8]* @gsxtmmath405 to i8*
call i32 (i8*, ...) @printf(i8* %var9877)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Complexf*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var9878 = bitcast [143 x i8]* @gsxtmmath405 to i8*
call i32 (i8*, ...) @printf(i8* %var9878)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, %Complexf* %arg_1, %Complexf* %arg_2, i64 %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf*, %Complexf*, %Complexf*, i64}*
%arg_p_0 = getelementptr {%Complexf*, %Complexf*, %Complexf*, i64}, {%Complexf*, %Complexf*, %Complexf*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf*, %Complexf** %arg_p_0
%arg_p_1 = getelementptr {%Complexf*, %Complexf*, %Complexf*, i64}, {%Complexf*, %Complexf*, %Complexf*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexf*, %Complexf** %arg_p_1
%arg_p_2 = getelementptr {%Complexf*, %Complexf*, %Complexf*, i64}, {%Complexf*, %Complexf*, %Complexf*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load %Complexf*, %Complexf** %arg_p_2
%arg_p_3 = getelementptr {%Complexf*, %Complexf*, %Complexf*, i64}, {%Complexf*, %Complexf*, %Complexf*, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_multiplication_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, %Complexf* %arg_1, %Complexf* %arg_2, i64 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath406 = hidden constant [58 x i8] c"xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ\00"
define dllexport fastcc %Complexf @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ__9879(i8* %_impz,i8* %_impenv, %Complexf %a, %Complexf %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9880 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}*
%xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr_ = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}* %impenv, i32 0, i32 0
%xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**** %xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr_

; setup arguments
%aPtr = alloca %Complexf
store %Complexf %a, %Complexf* %aPtr
%bPtr = alloca %Complexf
store %Complexf %b, %Complexf* %bPtr


%tzone9892 = load i8*, i8** %_impzPtr
%zone9893 = bitcast i8* %tzone9892 to %mzone*

; let assign value to symbol i
%iPtr = alloca float
%tzone9905 = load i8*, i8** %_impzPtr
%zone9906 = bitcast i8* %tzone9905 to %mzone*

; let assign value to symbol j
%jPtr = alloca float
%tzone9918 = load i8*, i8** %_impzPtr
%zone9919 = bitcast i8* %tzone9918 to %mzone*

; let assign value to symbol k
%kPtr = alloca float
%val9881 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9882 = extractvalue %Complexf %val9881, 0
%val9883 = load %Complexf, %Complexf* %bPtr
; tuple ref
%val9884 = extractvalue %Complexf %val9883, 0
%val9885 = fmul float %val9882, %val9884
%val9886 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9887 = extractvalue %Complexf %val9886, 1
%val9888 = load %Complexf, %Complexf* %bPtr
; tuple ref
%val9889 = extractvalue %Complexf %val9888, 1
%val9890 = fmul float %val9887, %val9889
%val9891 = fadd float %val9885, %val9890

; let value assignment
%i = select i1 true, float %val9891, float %val9891
store float %i, float* %iPtr

%val9894 = load %Complexf, %Complexf* %bPtr
; tuple ref
%val9895 = extractvalue %Complexf %val9894, 0
%val9896 = load %Complexf, %Complexf* %bPtr
; tuple ref
%val9897 = extractvalue %Complexf %val9896, 0
%val9898 = fmul float %val9895, %val9897
%val9899 = load %Complexf, %Complexf* %bPtr
; tuple ref
%val9900 = extractvalue %Complexf %val9899, 1
%val9901 = load %Complexf, %Complexf* %bPtr
; tuple ref
%val9902 = extractvalue %Complexf %val9901, 1
%val9903 = fmul float %val9900, %val9902
%val9904 = fadd float %val9898, %val9903

; let value assignment
%j = select i1 true, float %val9904, float %val9904
store float %j, float* %jPtr

%val9907 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9908 = extractvalue %Complexf %val9907, 1
%val9909 = load %Complexf, %Complexf* %bPtr
; tuple ref
%val9910 = extractvalue %Complexf %val9909, 0
%val9911 = fmul float %val9908, %val9910
%val9912 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9913 = extractvalue %Complexf %val9912, 0
%val9914 = load %Complexf, %Complexf* %bPtr
; tuple ref
%val9915 = extractvalue %Complexf %val9914, 1
%val9916 = fmul float %val9913, %val9915
%val9917 = fsub float %val9911, %val9916

; let value assignment
%k = select i1 true, float %val9917, float %val9917
store float %k, float* %kPtr

%val9920 = load float, float* %iPtr
%val9921 = load float, float* %jPtr
%val9922 = fdiv float %val9920, %val9921
%val9923 = load float, float* %kPtr
%val9924 = load float, float* %jPtr
%val9925 = fdiv float %val9923, %val9924
%res9926 = call fastcc %Complexf @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ(float %val9922, float %val9925)
ret %Complexf %res9926
}
define dllexport ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9946 = load i8*, i8** %_impzPtr
%zone9947 = bitcast i8* %tzone9946 to %mzone*

; let assign value to symbol xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ
%dat_xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ = call i8* @llvm_zone_malloc(%mzone* %zone9947, i64 8)
%xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr = bitcast i8* %dat_xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***
%tzone9927 = load i8*, i8** %_impzPtr
%zone9928 = bitcast i8* %tzone9927 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9928)
; malloc closure structure
%clsptr9929 = call i8* @llvm_zone_malloc(%mzone* %zone9928, i64 24)
%closure9930 = bitcast i8* %clsptr9929 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*

; malloc environment structure
%envptr9931 = call i8* @llvm_zone_malloc(%mzone* %zone9928, i64 8)
%environment9932 = bitcast i8* %envptr9931 to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}*

; malloc closure address table
%addytable9933 = call %clsvar* @new_address_table()
%var9934 = bitcast [58 x i8]* @gsxtmmath406 to i8*
%var9935 = bitcast [58 x i8]* @gsxtmmath379 to i8*
%addytable9936 = call %clsvar* @add_address_table(%mzone* %zone9928, i8* %var9934, i32 0, i8* %var9935, i32 3, %clsvar* %addytable9933)
%address-table9937 = bitcast %clsvar* %addytable9936 to i8*

; insert table, function and environment into closure struct
%closure.table9940 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure9930, i32 0, i32 0
store i8* %address-table9937, i8** %closure.table9940
%closure.env9941 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure9930, i32 0, i32 1
store i8* %envptr9931, i8** %closure.env9941
%closure.func9942 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure9930, i32 0, i32 2
store %Complexf (i8*, i8*, %Complexf, %Complexf)* @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ__9879, %Complexf (i8*, i8*, %Complexf, %Complexf)** %closure.func9942
%closure_size9943 = call i64 @llvm_zone_mark_size(%mzone* %zone9928)
call void @llvm_zone_ptr_set_size(i8* %clsptr9929, i64 %closure_size9943)
%wrapper_ptr9944 = call i8* @llvm_zone_malloc(%mzone* %zone9928, i64 8)
%closure_wrapper9945 = bitcast i8* %wrapper_ptr9944 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure9930, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_wrapper9945

; let value assignment
%xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ = select i1 true, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_wrapper9945, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_wrapper9945
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*** %xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr

; add data to environment
; don't need to alloc for env var xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ
%tmp_envptr9939 = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}***}* %environment9932, i32 0, i32 0
store {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*** %xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**** %tmp_envptr9939


%val9948 = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*** %xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQPtr
ret {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %val9948
}


@xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ(%Complexf %arg_0,%Complexf %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, %Complexf)*,  %Complexf (i8*, i8*, %Complexf, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, %Complexf %arg_1)
ret %Complexf %result
}


define dllexport ccc %Complexf @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_native(%Complexf %arg_0,%Complexf %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, %Complexf)*,  %Complexf (i8*, i8*, %Complexf, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, %Complexf %arg_1)
ret %Complexf %result
}


define dllexport ccc void @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf, %Complexf}*
%arg_p_0 = getelementptr {%Complexf, %Complexf}, {%Complexf, %Complexf}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf, %Complexf* %arg_p_0
%arg_p_1 = getelementptr {%Complexf, %Complexf}, {%Complexf, %Complexf}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexf, %Complexf* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, %Complexf)*,  %Complexf (i8*, i8*, %Complexf, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, %Complexf %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath407 = hidden constant [54 x i8] c"xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ\00"
define dllexport fastcc %Complexf @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ__9949(i8* %_impz,i8* %_impenv, %Complexf %a, float %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9950 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}*
%xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}* %impenv, i32 0, i32 0
%xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**** %xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr_

; setup arguments
%aPtr = alloca %Complexf
store %Complexf %a, %Complexf* %aPtr
%bPtr = alloca float
store float %b, float* %bPtr


%tzone9958 = load i8*, i8** %_impzPtr
%zone9959 = bitcast i8* %tzone9958 to %mzone*

; let assign value to symbol i
%iPtr = alloca float
%tzone9963 = load i8*, i8** %_impzPtr
%zone9964 = bitcast i8* %tzone9963 to %mzone*

; let assign value to symbol j
%jPtr = alloca float
%tzone9972 = load i8*, i8** %_impzPtr
%zone9973 = bitcast i8* %tzone9972 to %mzone*

; let assign value to symbol k
%kPtr = alloca float
%val9951 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9952 = extractvalue %Complexf %val9951, 0
%val9953 = load float, float* %bPtr
%val9954 = fmul float %val9952, %val9953
%val9955 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9956 = extractvalue %Complexf %val9955, 1
%val9957 = fadd float %val9954, %val9956

; let value assignment
%i = select i1 true, float %val9957, float %val9957
store float %i, float* %iPtr

%val9960 = load float, float* %bPtr
%val9961 = load float, float* %bPtr
%val9962 = fmul float %val9960, %val9961

; let value assignment
%j = select i1 true, float %val9962, float %val9962
store float %j, float* %jPtr

%val9965 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9966 = extractvalue %Complexf %val9965, 1
%val9967 = load float, float* %bPtr
%val9968 = fmul float %val9966, %val9967
%val9969 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val9970 = extractvalue %Complexf %val9969, 0
%val9971 = fsub float %val9968, %val9970

; let value assignment
%k = select i1 true, float %val9971, float %val9971
store float %k, float* %kPtr

%val9974 = load float, float* %iPtr
%val9975 = load float, float* %jPtr
%val9976 = fdiv float %val9974, %val9975
%val9977 = load float, float* %kPtr
%val9978 = load float, float* %jPtr
%val9979 = fdiv float %val9977, %val9978
%res9980 = call fastcc %Complexf @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ(float %val9976, float %val9979)
ret %Complexf %res9980
}
@gsxtmmath408 = hidden constant [107 x i8] c"xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10000 = load i8*, i8** %_impzPtr
%zone10001 = bitcast i8* %tzone10000 to %mzone*

; let assign value to symbol xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ
%dat_xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone10001, i64 8)
%xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr = bitcast i8* %dat_xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***
%tzone9981 = load i8*, i8** %_impzPtr
%zone9982 = bitcast i8* %tzone9981 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9982)
; malloc closure structure
%clsptr9983 = call i8* @llvm_zone_malloc(%mzone* %zone9982, i64 24)
%closure9984 = bitcast i8* %clsptr9983 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*

; malloc environment structure
%envptr9985 = call i8* @llvm_zone_malloc(%mzone* %zone9982, i64 8)
%environment9986 = bitcast i8* %envptr9985 to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}*

; malloc closure address table
%addytable9987 = call %clsvar* @new_address_table()
%var9988 = bitcast [54 x i8]* @gsxtmmath407 to i8*
%var9989 = bitcast [54 x i8]* @gsxtmmath381 to i8*
%addytable9990 = call %clsvar* @add_address_table(%mzone* %zone9982, i8* %var9988, i32 0, i8* %var9989, i32 3, %clsvar* %addytable9987)
%address-table9991 = bitcast %clsvar* %addytable9990 to i8*

; insert table, function and environment into closure struct
%closure.table9994 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure9984, i32 0, i32 0
store i8* %address-table9991, i8** %closure.table9994
%closure.env9995 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure9984, i32 0, i32 1
store i8* %envptr9985, i8** %closure.env9995
%closure.func9996 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure9984, i32 0, i32 2
store %Complexf (i8*, i8*, %Complexf, float)* @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ__9949, %Complexf (i8*, i8*, %Complexf, float)** %closure.func9996
%closure_size9997 = call i64 @llvm_zone_mark_size(%mzone* %zone9982)
call void @llvm_zone_ptr_set_size(i8* %clsptr9983, i64 %closure_size9997)
%wrapper_ptr9998 = call i8* @llvm_zone_malloc(%mzone* %zone9982, i64 8)
%closure_wrapper9999 = bitcast i8* %wrapper_ptr9998 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure9984, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_wrapper9999

; let value assignment
%xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ = select i1 true, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_wrapper9999, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_wrapper9999
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ, { i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*** %xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ
%tmp_envptr9993 = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}***}* %environment9986, i32 0, i32 0
store {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*** %xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**** %tmp_envptr9993


%val10002 = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*** %xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQPtr
ret {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %val10002
}


@xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ(%Complexf %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, float)*,  %Complexf (i8*, i8*, %Complexf, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, float %arg_1)
ret %Complexf %result
}


define dllexport ccc %Complexf @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_native(%Complexf %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, float)*,  %Complexf (i8*, i8*, %Complexf, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, float %arg_1)
ret %Complexf %result
}


define dllexport ccc void @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf, float}*
%arg_p_0 = getelementptr {%Complexf, float}, {%Complexf, float}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf, %Complexf* %arg_p_0
%arg_p_1 = getelementptr {%Complexf, float}, {%Complexf, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhmLENvbXBsZXhmLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf, float)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf, float)*,  %Complexf (i8*, i8*, %Complexf, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath409 = hidden constant [54 x i8] c"xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ\00"
define dllexport fastcc %Complexf @xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ__10004(i8* %_impz,i8* %_impenv, float %b, %Complexf %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10005 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}*
%xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr_ = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}* %impenv, i32 0, i32 0
%xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr = load {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**** %xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr_

; setup arguments
%bPtr = alloca float
store float %b, float* %bPtr
%aPtr = alloca %Complexf
store %Complexf %a, %Complexf* %aPtr


%tzone10013 = load i8*, i8** %_impzPtr
%zone10014 = bitcast i8* %tzone10013 to %mzone*

; let assign value to symbol i
%iPtr = alloca float
%tzone10018 = load i8*, i8** %_impzPtr
%zone10019 = bitcast i8* %tzone10018 to %mzone*

; let assign value to symbol j
%jPtr = alloca float
%tzone10027 = load i8*, i8** %_impzPtr
%zone10028 = bitcast i8* %tzone10027 to %mzone*

; let assign value to symbol k
%kPtr = alloca float
%val10006 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10007 = extractvalue %Complexf %val10006, 0
%val10008 = load float, float* %bPtr
%val10009 = fmul float %val10007, %val10008
%val10010 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10011 = extractvalue %Complexf %val10010, 1
%val10012 = fadd float %val10009, %val10011

; let value assignment
%i = select i1 true, float %val10012, float %val10012
store float %i, float* %iPtr

%val10015 = load float, float* %bPtr
%val10016 = load float, float* %bPtr
%val10017 = fmul float %val10015, %val10016

; let value assignment
%j = select i1 true, float %val10017, float %val10017
store float %j, float* %jPtr

%val10020 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10021 = extractvalue %Complexf %val10020, 1
%val10022 = load float, float* %bPtr
%val10023 = fmul float %val10021, %val10022
%val10024 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10025 = extractvalue %Complexf %val10024, 0
%val10026 = fsub float %val10023, %val10025

; let value assignment
%k = select i1 true, float %val10026, float %val10026
store float %k, float* %kPtr

%val10029 = load float, float* %iPtr
%val10030 = load float, float* %jPtr
%val10031 = fdiv float %val10029, %val10030
%val10032 = load float, float* %kPtr
%val10033 = load float, float* %jPtr
%val10034 = fdiv float %val10032, %val10033
%res10035 = call fastcc %Complexf @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ(float %val10031, float %val10034)
ret %Complexf %res10035
}
@gsxtmmath410 = hidden constant [107 x i8] c"xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** @xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10055 = load i8*, i8** %_impzPtr
%zone10056 = bitcast i8* %tzone10055 to %mzone*

; let assign value to symbol xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ
%dat_xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ = call i8* @llvm_zone_malloc(%mzone* %zone10056, i64 8)
%xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr = bitcast i8* %dat_xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ to { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***
%tzone10036 = load i8*, i8** %_impzPtr
%zone10037 = bitcast i8* %tzone10036 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10037)
; malloc closure structure
%clsptr10038 = call i8* @llvm_zone_malloc(%mzone* %zone10037, i64 24)
%closure10039 = bitcast i8* %clsptr10038 to { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*

; malloc environment structure
%envptr10040 = call i8* @llvm_zone_malloc(%mzone* %zone10037, i64 8)
%environment10041 = bitcast i8* %envptr10040 to {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}*

; malloc closure address table
%addytable10042 = call %clsvar* @new_address_table()
%var10043 = bitcast [54 x i8]* @gsxtmmath409 to i8*
%var10044 = bitcast [54 x i8]* @gsxtmmath384 to i8*
%addytable10045 = call %clsvar* @add_address_table(%mzone* %zone10037, i8* %var10043, i32 0, i8* %var10044, i32 3, %clsvar* %addytable10042)
%address-table10046 = bitcast %clsvar* %addytable10045 to i8*

; insert table, function and environment into closure struct
%closure.table10049 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure10039, i32 0, i32 0
store i8* %address-table10046, i8** %closure.table10049
%closure.env10050 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure10039, i32 0, i32 1
store i8* %envptr10040, i8** %closure.env10050
%closure.func10051 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure10039, i32 0, i32 2
store %Complexf (i8*, i8*, float, %Complexf)* @xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ__10004, %Complexf (i8*, i8*, float, %Complexf)** %closure.func10051
%closure_size10052 = call i64 @llvm_zone_mark_size(%mzone* %zone10037)
call void @llvm_zone_ptr_set_size(i8* %clsptr10038, i64 %closure_size10052)
%wrapper_ptr10053 = call i8* @llvm_zone_malloc(%mzone* %zone10037, i64 8)
%closure_wrapper10054 = bitcast i8* %wrapper_ptr10053 to { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**
store { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure10039, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_wrapper10054

; let value assignment
%xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ = select i1 true, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_wrapper10054, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_wrapper10054
store { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ, { i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*** %xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr

; add data to environment
; don't need to alloc for env var xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ
%tmp_envptr10048 = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}***}* %environment10041, i32 0, i32 0
store {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*** %xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**** %tmp_envptr10048


%val10057 = load {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*** %xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQPtr
ret {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %val10057
}


@xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** @xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf @xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ(float %arg_0,%Complexf %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, float, %Complexf)*,  %Complexf (i8*, i8*, float, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, float %arg_0, %Complexf %arg_1)
ret %Complexf %result
}


define dllexport ccc %Complexf @xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_native(float %arg_0,%Complexf %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, float, %Complexf)*,  %Complexf (i8*, i8*, float, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, float %arg_0, %Complexf %arg_1)
ret %Complexf %result
}


define dllexport ccc void @xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, %Complexf}*
%arg_p_0 = getelementptr {float, %Complexf}, {float, %Complexf}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, %Complexf}, {float, %Complexf}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexf, %Complexf* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W0NvbXBsZXhmLGZsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, float, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, float, %Complexf)*,  %Complexf (i8*, i8*, float, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, float %arg_0, %Complexf %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath411 = hidden constant [84 x i8] c"Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ\00"
define dllexport fastcc void @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ__10059(i8* %_impz,i8* %_impenv, %Complexf* %a, %Complexf* %b, %Complexf* %c, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10060 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}*
%Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}* %impenv, i32 0, i32 0
%Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**** %Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr_

; setup arguments
%aPtr = alloca %Complexf*
store %Complexf* %a, %Complexf** %aPtr
%bPtr = alloca %Complexf*
store %Complexf* %b, %Complexf** %bPtr
%cPtr = alloca %Complexf*
store %Complexf* %c, %Complexf** %cPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone10061 = load i8*, i8** %_impzPtr
%zone10062 = bitcast i8* %tzone10061 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%tzone10063 = load i8*, i8** %_impzPtr
%zone10064 = bitcast i8* %tzone10063 to %mzone*

; let assign value to symbol j
%jPtr = alloca float
%tzone10065 = load i8*, i8** %_impzPtr
%zone10066 = bitcast i8* %tzone10065 to %mzone*

; let assign value to symbol k
%kPtr = alloca float
%tzone10067 = load i8*, i8** %_impzPtr
%zone10068 = bitcast i8* %tzone10067 to %mzone*

; let assign value to symbol l
%lPtr = alloca float

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr


; let value assignment
%j = select i1 true, float 0x0, float 0x0
store float %j, float* %jPtr


; let value assignment
%k = select i1 true, float 0x0, float 0x0
store float %k, float* %kPtr


; let value assignment
%l = select i1 true, float 0x0, float 0x0
store float %l, float* %lPtr

; setup loop
%val10071 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val10155 = load i64, i64* %iPtr
%num10156 = add i64 %val10071, %val10155
%comp10157 = icmp ult i64 %val10071, 1
br i1 %comp10157, label %after10069, label %loop10069

loop10069:
; do set!
%val10072 = load i64, i64* %iPtr
%val10073 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val10074 = getelementptr %Complexf, %Complexf* %val10073, i64 %val10072
; tuple ref
%val10075 = getelementptr %Complexf, %Complexf* %val10074, i64 0, i32 0
%val10076 = load float, float* %val10075
%val10077 = load i64, i64* %iPtr
%val10078 = load %Complexf*, %Complexf** %bPtr
; pointer ref
%val10079 = getelementptr %Complexf, %Complexf* %val10078, i64 %val10077
; tuple ref
%val10080 = getelementptr %Complexf, %Complexf* %val10079, i64 0, i32 0
%val10081 = load float, float* %val10080
%val10082 = fmul float %val10076, %val10081
%val10083 = load i64, i64* %iPtr
%val10084 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val10085 = getelementptr %Complexf, %Complexf* %val10084, i64 %val10083
; tuple ref
%val10086 = getelementptr %Complexf, %Complexf* %val10085, i64 0, i32 1
%val10087 = load float, float* %val10086
%val10088 = load i64, i64* %iPtr
%val10089 = load %Complexf*, %Complexf** %bPtr
; pointer ref
%val10090 = getelementptr %Complexf, %Complexf* %val10089, i64 %val10088
; tuple ref
%val10091 = getelementptr %Complexf, %Complexf* %val10090, i64 0, i32 1
%val10092 = load float, float* %val10091
%val10093 = fmul float %val10087, %val10092
%val10094 = fadd float %val10082, %val10093
store float %val10094, float* %jPtr
; do set!
%val10095 = load i64, i64* %iPtr
%val10096 = load %Complexf*, %Complexf** %bPtr
; pointer ref
%val10097 = getelementptr %Complexf, %Complexf* %val10096, i64 %val10095
; tuple ref
%val10098 = getelementptr %Complexf, %Complexf* %val10097, i64 0, i32 0
%val10099 = load float, float* %val10098
%val10100 = load i64, i64* %iPtr
%val10101 = load %Complexf*, %Complexf** %bPtr
; pointer ref
%val10102 = getelementptr %Complexf, %Complexf* %val10101, i64 %val10100
; tuple ref
%val10103 = getelementptr %Complexf, %Complexf* %val10102, i64 0, i32 0
%val10104 = load float, float* %val10103
%val10105 = fmul float %val10099, %val10104
%val10106 = load i64, i64* %iPtr
%val10107 = load %Complexf*, %Complexf** %bPtr
; pointer ref
%val10108 = getelementptr %Complexf, %Complexf* %val10107, i64 %val10106
; tuple ref
%val10109 = getelementptr %Complexf, %Complexf* %val10108, i64 0, i32 1
%val10110 = load float, float* %val10109
%val10111 = load i64, i64* %iPtr
%val10112 = load %Complexf*, %Complexf** %bPtr
; pointer ref
%val10113 = getelementptr %Complexf, %Complexf* %val10112, i64 %val10111
; tuple ref
%val10114 = getelementptr %Complexf, %Complexf* %val10113, i64 0, i32 1
%val10115 = load float, float* %val10114
%val10116 = fmul float %val10110, %val10115
%val10117 = fadd float %val10105, %val10116
store float %val10117, float* %kPtr
; do set!
%val10118 = load i64, i64* %iPtr
%val10119 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val10120 = getelementptr %Complexf, %Complexf* %val10119, i64 %val10118
; tuple ref
%val10121 = getelementptr %Complexf, %Complexf* %val10120, i64 0, i32 1
%val10122 = load float, float* %val10121
%val10123 = load i64, i64* %iPtr
%val10124 = load %Complexf*, %Complexf** %bPtr
; pointer ref
%val10125 = getelementptr %Complexf, %Complexf* %val10124, i64 %val10123
; tuple ref
%val10126 = getelementptr %Complexf, %Complexf* %val10125, i64 0, i32 0
%val10127 = load float, float* %val10126
%val10128 = fmul float %val10122, %val10127
%val10129 = load i64, i64* %iPtr
%val10130 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val10131 = getelementptr %Complexf, %Complexf* %val10130, i64 %val10129
; tuple ref
%val10132 = getelementptr %Complexf, %Complexf* %val10131, i64 0, i32 0
%val10133 = load float, float* %val10132
%val10134 = load i64, i64* %iPtr
%val10135 = load %Complexf*, %Complexf** %bPtr
; pointer ref
%val10136 = getelementptr %Complexf, %Complexf* %val10135, i64 %val10134
; tuple ref
%val10137 = getelementptr %Complexf, %Complexf* %val10136, i64 0, i32 1
%val10138 = load float, float* %val10137
%val10139 = fmul float %val10133, %val10138
%val10140 = fsub float %val10128, %val10139
store float %val10140, float* %lPtr
%val10141 = load i64, i64* %iPtr
%val10142 = load %Complexf*, %Complexf** %cPtr
; pointer ref
%val10143 = getelementptr %Complexf, %Complexf* %val10142, i64 %val10141
%val10144 = load float, float* %jPtr
%val10145 = load float, float* %kPtr
%val10146 = fdiv float %val10144, %val10145
; set tuple
%val10147 = getelementptr %Complexf, %Complexf* %val10143, i64 0, i32 0
store float %val10146, float* %val10147
%val10148 = load i64, i64* %iPtr
%val10149 = load %Complexf*, %Complexf** %cPtr
; pointer ref
%val10150 = getelementptr %Complexf, %Complexf* %val10149, i64 %val10148
%val10151 = load float, float* %lPtr
%val10152 = load float, float* %kPtr
%val10153 = fdiv float %val10151, %val10152
; set tuple
%val10154 = getelementptr %Complexf, %Complexf* %val10150, i64 0, i32 1
store float %val10153, float* %val10154
%loop_cnt10069 = load i64, i64* %iPtr
%next10069 = add i64 %loop_cnt10069, 1
store i64 %next10069, i64* %iPtr
%cmp10069 = icmp ult i64 %next10069, %num10156
br i1 %cmp10069, label %loop10069, label %after10069

after10069:
ret void
}
@gsxtmmath412 = hidden constant [137 x i8] c"Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10179 = load i8*, i8** %_impzPtr
%zone10180 = bitcast i8* %tzone10179 to %mzone*

; let assign value to symbol Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ
%dat_Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone10180, i64 8)
%Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr = bitcast i8* %dat_Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ to { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***
%tzone10160 = load i8*, i8** %_impzPtr
%zone10161 = bitcast i8* %tzone10160 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10161)
; malloc closure structure
%clsptr10162 = call i8* @llvm_zone_malloc(%mzone* %zone10161, i64 24)
%closure10163 = bitcast i8* %clsptr10162 to { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*

; malloc environment structure
%envptr10164 = call i8* @llvm_zone_malloc(%mzone* %zone10161, i64 8)
%environment10165 = bitcast i8* %envptr10164 to {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}*

; malloc closure address table
%addytable10166 = call %clsvar* @new_address_table()
%var10167 = bitcast [84 x i8]* @gsxtmmath411 to i8*
%var10168 = bitcast [72 x i8]* @gsxtmmath387 to i8*
%addytable10169 = call %clsvar* @add_address_table(%mzone* %zone10161, i8* %var10167, i32 0, i8* %var10168, i32 3, %clsvar* %addytable10166)
%address-table10170 = bitcast %clsvar* %addytable10169 to i8*

; insert table, function and environment into closure struct
%closure.table10173 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure10163, i32 0, i32 0
store i8* %address-table10170, i8** %closure.table10173
%closure.env10174 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure10163, i32 0, i32 1
store i8* %envptr10164, i8** %closure.env10174
%closure.func10175 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure10163, i32 0, i32 2
store void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)* @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ__10059, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)** %closure.func10175
%closure_size10176 = call i64 @llvm_zone_mark_size(%mzone* %zone10161)
call void @llvm_zone_ptr_set_size(i8* %clsptr10162, i64 %closure_size10176)
%wrapper_ptr10177 = call i8* @llvm_zone_malloc(%mzone* %zone10161, i64 8)
%closure_wrapper10178 = bitcast i8* %wrapper_ptr10177 to { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**
store { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure10163, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_wrapper10178

; let value assignment
%Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_wrapper10178, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_wrapper10178
store { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ, { i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*** %Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr

; add data to environment
; don't need to alloc for env var Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ
%tmp_envptr10172 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}***}* %environment10165, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*** %Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**** %tmp_envptr10172


%val10181 = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*** %Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %val10181
}


@Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ(%Complexf* %arg_0,%Complexf* %arg_1,%Complexf* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, %Complexf* %arg_1, %Complexf* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc void @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_native(%Complexf* %arg_0,%Complexf* %arg_1,%Complexf* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, %Complexf* %arg_1, %Complexf* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc i8*  @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var10182 = bitcast [137 x i8]* @gsxtmmath412 to i8*
call i32 (i8*, ...) @printf(i8* %var10182)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexf*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var10183 = bitcast [137 x i8]* @gsxtmmath412 to i8*
call i32 (i8*, ...) @printf(i8* %var10183)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Complexf*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var10184 = bitcast [137 x i8]* @gsxtmmath412 to i8*
call i32 (i8*, ...) @printf(i8* %var10184)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Complexf*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var10185 = bitcast [137 x i8]* @gsxtmmath412 to i8*
call i32 (i8*, ...) @printf(i8* %var10185)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, %Complexf* %arg_1, %Complexf* %arg_2, i64 %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf*, %Complexf*, %Complexf*, i64}*
%arg_p_0 = getelementptr {%Complexf*, %Complexf*, %Complexf*, i64}, {%Complexf*, %Complexf*, %Complexf*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf*, %Complexf** %arg_p_0
%arg_p_1 = getelementptr {%Complexf*, %Complexf*, %Complexf*, i64}, {%Complexf*, %Complexf*, %Complexf*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexf*, %Complexf** %arg_p_1
%arg_p_2 = getelementptr {%Complexf*, %Complexf*, %Complexf*, i64}, {%Complexf*, %Complexf*, %Complexf*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load %Complexf*, %Complexf** %arg_p_2
%arg_p_3 = getelementptr {%Complexf*, %Complexf*, %Complexf*, i64}, {%Complexf*, %Complexf*, %Complexf*, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_division_bybuf_adhoc_W3ZvaWQsQ29tcGxleGYqLENvbXBsZXhmKixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, %Complexf*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, %Complexf* %arg_1, %Complexf* %arg_2, i64 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath413 = hidden constant [41 x i8] c"Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ\00"
@gsxtmmath414 = hidden constant [43 x i8] c"{i8*, i8*, float (i8*, i8*, %Complexf)*}**\00"
define dllexport fastcc float @Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ__10186(i8* %_impz,i8* %_impenv, %Complexf %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10187 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, %Complexf)*}***}*
%Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, %Complexf)*}***}, {{i8*, i8*, float (i8*, i8*, %Complexf)*}***}* %impenv, i32 0, i32 0
%Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQPtr = load {i8*, i8*, float (i8*, i8*, %Complexf)*}***, {i8*, i8*, float (i8*, i8*, %Complexf)*}**** %Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQPtr_

; setup arguments
%aPtr = alloca %Complexf
store %Complexf %a, %Complexf* %aPtr


%val10188 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10189 = extractvalue %Complexf %val10188, 0
%val10190 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10191 = extractvalue %Complexf %val10190, 0
%val10192 = fmul float %val10189, %val10191
%val10193 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10194 = extractvalue %Complexf %val10193, 1
%val10195 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10196 = extractvalue %Complexf %val10195, 1
%val10197 = fmul float %val10194, %val10196
%val10198 = fadd float %val10192, %val10197
%val10199 = call float @llvm.sqrt.f32(float %val10198)
ret float %val10199
}
define dllexport ccc {i8*, i8*, float (i8*, i8*, %Complexf)*}** @Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10219 = load i8*, i8** %_impzPtr
%zone10220 = bitcast i8* %tzone10219 to %mzone*

; let assign value to symbol Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ
%dat_Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ = call i8* @llvm_zone_malloc(%mzone* %zone10220, i64 8)
%Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQPtr = bitcast i8* %dat_Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ to { i8*, i8*, float (i8*, i8*, %Complexf)*}***
%tzone10200 = load i8*, i8** %_impzPtr
%zone10201 = bitcast i8* %tzone10200 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10201)
; malloc closure structure
%clsptr10202 = call i8* @llvm_zone_malloc(%mzone* %zone10201, i64 24)
%closure10203 = bitcast i8* %clsptr10202 to { i8*, i8*, float (i8*, i8*, %Complexf)*}*

; malloc environment structure
%envptr10204 = call i8* @llvm_zone_malloc(%mzone* %zone10201, i64 8)
%environment10205 = bitcast i8* %envptr10204 to {{i8*, i8*, float (i8*, i8*, %Complexf)*}***}*

; malloc closure address table
%addytable10206 = call %clsvar* @new_address_table()
%var10207 = bitcast [41 x i8]* @gsxtmmath413 to i8*
%var10208 = bitcast [43 x i8]* @gsxtmmath414 to i8*
%addytable10209 = call %clsvar* @add_address_table(%mzone* %zone10201, i8* %var10207, i32 0, i8* %var10208, i32 3, %clsvar* %addytable10206)
%address-table10210 = bitcast %clsvar* %addytable10209 to i8*

; insert table, function and environment into closure struct
%closure.table10213 = getelementptr { i8*, i8*, float (i8*, i8*, %Complexf)*}, { i8*, i8*, float (i8*, i8*, %Complexf)*}* %closure10203, i32 0, i32 0
store i8* %address-table10210, i8** %closure.table10213
%closure.env10214 = getelementptr { i8*, i8*, float (i8*, i8*, %Complexf)*}, { i8*, i8*, float (i8*, i8*, %Complexf)*}* %closure10203, i32 0, i32 1
store i8* %envptr10204, i8** %closure.env10214
%closure.func10215 = getelementptr { i8*, i8*, float (i8*, i8*, %Complexf)*}, { i8*, i8*, float (i8*, i8*, %Complexf)*}* %closure10203, i32 0, i32 2
store float (i8*, i8*, %Complexf)* @Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ__10186, float (i8*, i8*, %Complexf)** %closure.func10215
%closure_size10216 = call i64 @llvm_zone_mark_size(%mzone* %zone10201)
call void @llvm_zone_ptr_set_size(i8* %clsptr10202, i64 %closure_size10216)
%wrapper_ptr10217 = call i8* @llvm_zone_malloc(%mzone* %zone10201, i64 8)
%closure_wrapper10218 = bitcast i8* %wrapper_ptr10217 to { i8*, i8*, float (i8*, i8*, %Complexf)*}**
store { i8*, i8*, float (i8*, i8*, %Complexf)*}* %closure10203, { i8*, i8*, float (i8*, i8*, %Complexf)*}** %closure_wrapper10218

; let value assignment
%Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ = select i1 true, { i8*, i8*, float (i8*, i8*, %Complexf)*}** %closure_wrapper10218, { i8*, i8*, float (i8*, i8*, %Complexf)*}** %closure_wrapper10218
store { i8*, i8*, float (i8*, i8*, %Complexf)*}** %Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ, { i8*, i8*, float (i8*, i8*, %Complexf)*}*** %Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQPtr

; add data to environment
; don't need to alloc for env var Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ
%tmp_envptr10212 = getelementptr {{i8*, i8*, float (i8*, i8*, %Complexf)*}***}, {{i8*, i8*, float (i8*, i8*, %Complexf)*}***}* %environment10205, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, %Complexf)*}*** %Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQPtr, {i8*, i8*, float (i8*, i8*, %Complexf)*}**** %tmp_envptr10212


%val10221 = load {i8*, i8*, float (i8*, i8*, %Complexf)*}**, {i8*, i8*, float (i8*, i8*, %Complexf)*}*** %Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQPtr
ret {i8*, i8*, float (i8*, i8*, %Complexf)*}** %val10221
}


@Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, %Complexf)*}** @Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, %Complexf)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ(%Complexf %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %Complexf)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %Complexf)*}*, {i8*, i8*, float (i8*, i8*, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %Complexf)*}, {i8*, i8*, float (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %Complexf)*}, {i8*, i8*, float (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %Complexf)*,  float (i8*, i8*, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %Complexf %arg_0)
ret float %result
}


define dllexport ccc float @Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_native(%Complexf %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %Complexf)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %Complexf)*}*, {i8*, i8*, float (i8*, i8*, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %Complexf)*}, {i8*, i8*, float (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %Complexf)*}, {i8*, i8*, float (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %Complexf)*,  float (i8*, i8*, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %Complexf %arg_0)
ret float %result
}


define dllexport ccc void @Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf}*
%arg_p_0 = getelementptr {%Complexf}, {%Complexf}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf, %Complexf* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_mag_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %Complexf)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %Complexf)*}*, {i8*, i8*, float (i8*, i8*, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %Complexf)*}, {i8*, i8*, float (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %Complexf)*}, {i8*, i8*, float (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %Complexf)*,  float (i8*, i8*, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %Complexf %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath415 = hidden constant [43 x i8] c"Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ\00"
define dllexport fastcc float @Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ__10222(i8* %_impz,i8* %_impenv, %Complexf %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10223 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, %Complexf)*}***}*
%Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, %Complexf)*}***}, {{i8*, i8*, float (i8*, i8*, %Complexf)*}***}* %impenv, i32 0, i32 0
%Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQPtr = load {i8*, i8*, float (i8*, i8*, %Complexf)*}***, {i8*, i8*, float (i8*, i8*, %Complexf)*}**** %Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQPtr_

; setup arguments
%aPtr = alloca %Complexf
store %Complexf %a, %Complexf* %aPtr


%val10224 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10225 = extractvalue %Complexf %val10224, 1
%val10226 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10227 = extractvalue %Complexf %val10226, 0
%res10228 = call ccc float @atan2f(float %val10225, float %val10227)
ret float %res10228
}
define dllexport ccc {i8*, i8*, float (i8*, i8*, %Complexf)*}** @Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10248 = load i8*, i8** %_impzPtr
%zone10249 = bitcast i8* %tzone10248 to %mzone*

; let assign value to symbol Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ
%dat_Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ = call i8* @llvm_zone_malloc(%mzone* %zone10249, i64 8)
%Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQPtr = bitcast i8* %dat_Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ to { i8*, i8*, float (i8*, i8*, %Complexf)*}***
%tzone10229 = load i8*, i8** %_impzPtr
%zone10230 = bitcast i8* %tzone10229 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10230)
; malloc closure structure
%clsptr10231 = call i8* @llvm_zone_malloc(%mzone* %zone10230, i64 24)
%closure10232 = bitcast i8* %clsptr10231 to { i8*, i8*, float (i8*, i8*, %Complexf)*}*

; malloc environment structure
%envptr10233 = call i8* @llvm_zone_malloc(%mzone* %zone10230, i64 8)
%environment10234 = bitcast i8* %envptr10233 to {{i8*, i8*, float (i8*, i8*, %Complexf)*}***}*

; malloc closure address table
%addytable10235 = call %clsvar* @new_address_table()
%var10236 = bitcast [43 x i8]* @gsxtmmath415 to i8*
%var10237 = bitcast [43 x i8]* @gsxtmmath414 to i8*
%addytable10238 = call %clsvar* @add_address_table(%mzone* %zone10230, i8* %var10236, i32 0, i8* %var10237, i32 3, %clsvar* %addytable10235)
%address-table10239 = bitcast %clsvar* %addytable10238 to i8*

; insert table, function and environment into closure struct
%closure.table10242 = getelementptr { i8*, i8*, float (i8*, i8*, %Complexf)*}, { i8*, i8*, float (i8*, i8*, %Complexf)*}* %closure10232, i32 0, i32 0
store i8* %address-table10239, i8** %closure.table10242
%closure.env10243 = getelementptr { i8*, i8*, float (i8*, i8*, %Complexf)*}, { i8*, i8*, float (i8*, i8*, %Complexf)*}* %closure10232, i32 0, i32 1
store i8* %envptr10233, i8** %closure.env10243
%closure.func10244 = getelementptr { i8*, i8*, float (i8*, i8*, %Complexf)*}, { i8*, i8*, float (i8*, i8*, %Complexf)*}* %closure10232, i32 0, i32 2
store float (i8*, i8*, %Complexf)* @Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ__10222, float (i8*, i8*, %Complexf)** %closure.func10244
%closure_size10245 = call i64 @llvm_zone_mark_size(%mzone* %zone10230)
call void @llvm_zone_ptr_set_size(i8* %clsptr10231, i64 %closure_size10245)
%wrapper_ptr10246 = call i8* @llvm_zone_malloc(%mzone* %zone10230, i64 8)
%closure_wrapper10247 = bitcast i8* %wrapper_ptr10246 to { i8*, i8*, float (i8*, i8*, %Complexf)*}**
store { i8*, i8*, float (i8*, i8*, %Complexf)*}* %closure10232, { i8*, i8*, float (i8*, i8*, %Complexf)*}** %closure_wrapper10247

; let value assignment
%Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ = select i1 true, { i8*, i8*, float (i8*, i8*, %Complexf)*}** %closure_wrapper10247, { i8*, i8*, float (i8*, i8*, %Complexf)*}** %closure_wrapper10247
store { i8*, i8*, float (i8*, i8*, %Complexf)*}** %Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ, { i8*, i8*, float (i8*, i8*, %Complexf)*}*** %Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQPtr

; add data to environment
; don't need to alloc for env var Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ
%tmp_envptr10241 = getelementptr {{i8*, i8*, float (i8*, i8*, %Complexf)*}***}, {{i8*, i8*, float (i8*, i8*, %Complexf)*}***}* %environment10234, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, %Complexf)*}*** %Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQPtr, {i8*, i8*, float (i8*, i8*, %Complexf)*}**** %tmp_envptr10241


%val10250 = load {i8*, i8*, float (i8*, i8*, %Complexf)*}**, {i8*, i8*, float (i8*, i8*, %Complexf)*}*** %Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQPtr
ret {i8*, i8*, float (i8*, i8*, %Complexf)*}** %val10250
}


@Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, %Complexf)*}** @Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, %Complexf)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ(%Complexf %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %Complexf)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %Complexf)*}*, {i8*, i8*, float (i8*, i8*, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %Complexf)*}, {i8*, i8*, float (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %Complexf)*}, {i8*, i8*, float (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %Complexf)*,  float (i8*, i8*, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %Complexf %arg_0)
ret float %result
}


define dllexport ccc float @Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_native(%Complexf %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %Complexf)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %Complexf)*}*, {i8*, i8*, float (i8*, i8*, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %Complexf)*}, {i8*, i8*, float (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %Complexf)*}, {i8*, i8*, float (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %Complexf)*,  float (i8*, i8*, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %Complexf %arg_0)
ret float %result
}


define dllexport ccc void @Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf}*
%arg_p_0 = getelementptr {%Complexf}, {%Complexf}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf, %Complexf* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_phase_adhoc_W2Zsb2F0LENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %Complexf)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %Complexf)*}*, {i8*, i8*, float (i8*, i8*, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %Complexf)*}, {i8*, i8*, float (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %Complexf)*}, {i8*, i8*, float (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %Complexf)*,  float (i8*, i8*, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %Complexf %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath416 = hidden constant [46 x i8] c"Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ\00"
@gsxtmmath417 = hidden constant [47 x i8] c"{i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**\00"
define dllexport fastcc %Complexf @Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ__10251(i8* %_impz,i8* %_impenv, %Complexf %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10252 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***}*
%Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQPtr_ = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***}* %impenv, i32 0, i32 0
%Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQPtr = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**** %Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQPtr_

; setup arguments
%aPtr = alloca %Complexf
store %Complexf %a, %Complexf* %aPtr


%val10253 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10254 = extractvalue %Complexf %val10253, 0
%val10255 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10256 = extractvalue %Complexf %val10255, 0
%val10257 = fmul float 0xbff0000000000000, %val10256
%res10258 = call fastcc %Complexf @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ(float %val10254, float %val10257)
ret %Complexf %res10258
}
define dllexport ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** @Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10278 = load i8*, i8** %_impzPtr
%zone10279 = bitcast i8* %tzone10278 to %mzone*

; let assign value to symbol Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ
%dat_Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ = call i8* @llvm_zone_malloc(%mzone* %zone10279, i64 8)
%Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQPtr = bitcast i8* %dat_Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ to { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***
%tzone10259 = load i8*, i8** %_impzPtr
%zone10260 = bitcast i8* %tzone10259 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10260)
; malloc closure structure
%clsptr10261 = call i8* @llvm_zone_malloc(%mzone* %zone10260, i64 24)
%closure10262 = bitcast i8* %clsptr10261 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}*

; malloc environment structure
%envptr10263 = call i8* @llvm_zone_malloc(%mzone* %zone10260, i64 8)
%environment10264 = bitcast i8* %envptr10263 to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***}*

; malloc closure address table
%addytable10265 = call %clsvar* @new_address_table()
%var10266 = bitcast [46 x i8]* @gsxtmmath416 to i8*
%var10267 = bitcast [47 x i8]* @gsxtmmath417 to i8*
%addytable10268 = call %clsvar* @add_address_table(%mzone* %zone10260, i8* %var10266, i32 0, i8* %var10267, i32 3, %clsvar* %addytable10265)
%address-table10269 = bitcast %clsvar* %addytable10268 to i8*

; insert table, function and environment into closure struct
%closure.table10272 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure10262, i32 0, i32 0
store i8* %address-table10269, i8** %closure.table10272
%closure.env10273 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure10262, i32 0, i32 1
store i8* %envptr10263, i8** %closure.env10273
%closure.func10274 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure10262, i32 0, i32 2
store %Complexf (i8*, i8*, %Complexf)* @Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ__10251, %Complexf (i8*, i8*, %Complexf)** %closure.func10274
%closure_size10275 = call i64 @llvm_zone_mark_size(%mzone* %zone10260)
call void @llvm_zone_ptr_set_size(i8* %clsptr10261, i64 %closure_size10275)
%wrapper_ptr10276 = call i8* @llvm_zone_malloc(%mzone* %zone10260, i64 8)
%closure_wrapper10277 = bitcast i8* %wrapper_ptr10276 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure10262, { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %closure_wrapper10277

; let value assignment
%Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ = select i1 true, { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %closure_wrapper10277, { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %closure_wrapper10277
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ, { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}*** %Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQPtr

; add data to environment
; don't need to alloc for env var Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ
%tmp_envptr10271 = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***}* %environment10264, i32 0, i32 0
store {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}*** %Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQPtr, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**** %tmp_envptr10271


%val10280 = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}*** %Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQPtr
ret {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %val10280
}


@Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** @Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf @Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ(%Complexf %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf)*,  %Complexf (i8*, i8*, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0)
ret %Complexf %result
}


define dllexport ccc %Complexf @Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_native(%Complexf %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf)*,  %Complexf (i8*, i8*, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0)
ret %Complexf %result
}


define dllexport ccc void @Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf}*
%arg_p_0 = getelementptr {%Complexf}, {%Complexf}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf, %Complexf* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_conj_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf)*,  %Complexf (i8*, i8*, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath418 = hidden constant [45 x i8] c"cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ\00"
define dllexport fastcc %Complexf @cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ__10281(i8* %_impz,i8* %_impenv, %Complexf %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10282 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***}*
%cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQPtr_ = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***}* %impenv, i32 0, i32 0
%cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQPtr = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**** %cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQPtr_

; setup arguments
%aPtr = alloca %Complexf
store %Complexf %a, %Complexf* %aPtr


%val10283 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10284 = extractvalue %Complexf %val10283, 0
%val10285 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10286 = extractvalue %Complexf %val10285, 0
%val10287 = fmul float %val10284, %val10286
%val10288 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10289 = extractvalue %Complexf %val10288, 1
%val10290 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10291 = extractvalue %Complexf %val10290, 1
%val10292 = fmul float %val10289, %val10291
%val10293 = fadd float %val10287, %val10292
%val10294 = call float @llvm.sqrt.f32(float %val10293)
%val10295 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10296 = extractvalue %Complexf %val10295, 1
%val10297 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10298 = extractvalue %Complexf %val10297, 0
%res10299 = call ccc float @atan2f(float %val10296, float %val10298)
%res10300 = call fastcc %Complexf @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ(float %val10294, float %res10299)
ret %Complexf %res10300
}
define dllexport ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** @cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10320 = load i8*, i8** %_impzPtr
%zone10321 = bitcast i8* %tzone10320 to %mzone*

; let assign value to symbol cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ
%dat_cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ = call i8* @llvm_zone_malloc(%mzone* %zone10321, i64 8)
%cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQPtr = bitcast i8* %dat_cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ to { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***
%tzone10301 = load i8*, i8** %_impzPtr
%zone10302 = bitcast i8* %tzone10301 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10302)
; malloc closure structure
%clsptr10303 = call i8* @llvm_zone_malloc(%mzone* %zone10302, i64 24)
%closure10304 = bitcast i8* %clsptr10303 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}*

; malloc environment structure
%envptr10305 = call i8* @llvm_zone_malloc(%mzone* %zone10302, i64 8)
%environment10306 = bitcast i8* %envptr10305 to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***}*

; malloc closure address table
%addytable10307 = call %clsvar* @new_address_table()
%var10308 = bitcast [45 x i8]* @gsxtmmath418 to i8*
%var10309 = bitcast [47 x i8]* @gsxtmmath417 to i8*
%addytable10310 = call %clsvar* @add_address_table(%mzone* %zone10302, i8* %var10308, i32 0, i8* %var10309, i32 3, %clsvar* %addytable10307)
%address-table10311 = bitcast %clsvar* %addytable10310 to i8*

; insert table, function and environment into closure struct
%closure.table10314 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure10304, i32 0, i32 0
store i8* %address-table10311, i8** %closure.table10314
%closure.env10315 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure10304, i32 0, i32 1
store i8* %envptr10305, i8** %closure.env10315
%closure.func10316 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure10304, i32 0, i32 2
store %Complexf (i8*, i8*, %Complexf)* @cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ__10281, %Complexf (i8*, i8*, %Complexf)** %closure.func10316
%closure_size10317 = call i64 @llvm_zone_mark_size(%mzone* %zone10302)
call void @llvm_zone_ptr_set_size(i8* %clsptr10303, i64 %closure_size10317)
%wrapper_ptr10318 = call i8* @llvm_zone_malloc(%mzone* %zone10302, i64 8)
%closure_wrapper10319 = bitcast i8* %wrapper_ptr10318 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure10304, { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %closure_wrapper10319

; let value assignment
%cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ = select i1 true, { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %closure_wrapper10319, { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %closure_wrapper10319
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ, { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}*** %cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQPtr

; add data to environment
; don't need to alloc for env var cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ
%tmp_envptr10313 = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***}* %environment10306, i32 0, i32 0
store {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}*** %cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQPtr, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**** %tmp_envptr10313


%val10322 = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}*** %cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQPtr
ret {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %val10322
}


@cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var = dllexport global [1 x i8*] [ i8* null ]

@cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** @cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf @cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ(%Complexf %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf)*,  %Complexf (i8*, i8*, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0)
ret %Complexf %result
}


define dllexport ccc %Complexf @cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_native(%Complexf %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf)*,  %Complexf (i8*, i8*, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0)
ret %Complexf %result
}


define dllexport ccc void @cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf}*
%arg_p_0 = getelementptr {%Complexf}, {%Complexf}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf, %Complexf* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf)*,  %Complexf (i8*, i8*, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath419 = hidden constant [46 x i8] c"cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0\00"
@gsxtmmath420 = hidden constant [48 x i8] c"{i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}**\00"
define dllexport fastcc void @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0__10323(i8* %_impz,i8* %_impenv, %Complexf* %a, i64 %n) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10324 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}***}*
%cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}***}* %impenv, i32 0, i32 0
%cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0Ptr = load {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}***, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}**** %cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0Ptr_

; setup arguments
%aPtr = alloca %Complexf*
store %Complexf* %a, %Complexf** %aPtr
%nPtr = alloca i64
store i64 %n, i64* %nPtr


%tzone10325 = load i8*, i8** %_impzPtr
%zone10326 = bitcast i8* %tzone10325 to %mzone*

; let assign value to symbol temp
%tempPtr = alloca float

; let value assignment
%temp = select i1 true, float 0x0, float 0x0
store float %temp, float* %tempPtr

%tzone10328 = load i8*, i8** %_impzPtr
%zone10329 = bitcast i8* %tzone10328 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val10327 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val10327, i64 %val10327
store i64 %i, i64* %iPtr

; setup loop
%val10332 = load i64, i64* %nPtr
store i64 0, i64* %iPtr
%val10377 = load i64, i64* %iPtr
%num10378 = add i64 %val10332, %val10377
%comp10379 = icmp ult i64 %val10332, 1
br i1 %comp10379, label %after10330, label %loop10330

loop10330:
; do set!
%val10333 = load i64, i64* %iPtr
%val10334 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val10335 = getelementptr %Complexf, %Complexf* %val10334, i64 %val10333
%val10336 = load %Complexf, %Complexf* %val10335
; tuple ref
%val10337 = extractvalue %Complexf %val10336, 0
%val10338 = load i64, i64* %iPtr
%val10339 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val10340 = getelementptr %Complexf, %Complexf* %val10339, i64 %val10338
%val10341 = load %Complexf, %Complexf* %val10340
; tuple ref
%val10342 = extractvalue %Complexf %val10341, 0
%val10343 = fmul float %val10337, %val10342
%val10344 = load i64, i64* %iPtr
%val10345 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val10346 = getelementptr %Complexf, %Complexf* %val10345, i64 %val10344
%val10347 = load %Complexf, %Complexf* %val10346
; tuple ref
%val10348 = extractvalue %Complexf %val10347, 1
%val10349 = load i64, i64* %iPtr
%val10350 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val10351 = getelementptr %Complexf, %Complexf* %val10350, i64 %val10349
%val10352 = load %Complexf, %Complexf* %val10351
; tuple ref
%val10353 = extractvalue %Complexf %val10352, 1
%val10354 = fmul float %val10348, %val10353
%val10355 = fadd float %val10343, %val10354
%val10356 = call float @llvm.sqrt.f32(float %val10355)
store float %val10356, float* %tempPtr
%val10357 = load i64, i64* %iPtr
%val10358 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val10359 = getelementptr %Complexf, %Complexf* %val10358, i64 %val10357
%val10360 = load i64, i64* %iPtr
%val10361 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val10362 = getelementptr %Complexf, %Complexf* %val10361, i64 %val10360
%val10363 = load %Complexf, %Complexf* %val10362
; tuple ref
%val10364 = extractvalue %Complexf %val10363, 1
%val10365 = load i64, i64* %iPtr
%val10366 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val10367 = getelementptr %Complexf, %Complexf* %val10366, i64 %val10365
%val10368 = load %Complexf, %Complexf* %val10367
; tuple ref
%val10369 = extractvalue %Complexf %val10368, 0
%res10370 = call ccc float @atan2f(float %val10364, float %val10369)
; set tuple
%val10371 = getelementptr %Complexf, %Complexf* %val10359, i64 0, i32 1
store float %res10370, float* %val10371
%val10372 = load i64, i64* %iPtr
%val10373 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val10374 = getelementptr %Complexf, %Complexf* %val10373, i64 %val10372
%val10375 = load float, float* %tempPtr
; set tuple
%val10376 = getelementptr %Complexf, %Complexf* %val10374, i64 0, i32 0
store float %val10375, float* %val10376
%loop_cnt10330 = load i64, i64* %iPtr
%next10330 = add i64 %loop_cnt10330, 1
store i64 %next10330, i64* %iPtr
%cmp10330 = icmp ult i64 %next10330, %num10378
br i1 %cmp10330, label %loop10330, label %after10330

after10330:
ret void
}
@gsxtmmath421 = hidden constant [99 x i8] c"cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10401 = load i8*, i8** %_impzPtr
%zone10402 = bitcast i8* %tzone10401 to %mzone*

; let assign value to symbol cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0
%dat_cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone10402, i64 8)
%cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0Ptr = bitcast i8* %dat_cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0 to { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}***
%tzone10382 = load i8*, i8** %_impzPtr
%zone10383 = bitcast i8* %tzone10382 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10383)
; malloc closure structure
%clsptr10384 = call i8* @llvm_zone_malloc(%mzone* %zone10383, i64 24)
%closure10385 = bitcast i8* %clsptr10384 to { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}*

; malloc environment structure
%envptr10386 = call i8* @llvm_zone_malloc(%mzone* %zone10383, i64 8)
%environment10387 = bitcast i8* %envptr10386 to {{i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}***}*

; malloc closure address table
%addytable10388 = call %clsvar* @new_address_table()
%var10389 = bitcast [46 x i8]* @gsxtmmath419 to i8*
%var10390 = bitcast [48 x i8]* @gsxtmmath420 to i8*
%addytable10391 = call %clsvar* @add_address_table(%mzone* %zone10383, i8* %var10389, i32 0, i8* %var10390, i32 3, %clsvar* %addytable10388)
%address-table10392 = bitcast %clsvar* %addytable10391 to i8*

; insert table, function and environment into closure struct
%closure.table10395 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure10385, i32 0, i32 0
store i8* %address-table10392, i8** %closure.table10395
%closure.env10396 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure10385, i32 0, i32 1
store i8* %envptr10386, i8** %closure.env10396
%closure.func10397 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure10385, i32 0, i32 2
store void (i8*, i8*, %Complexf*, i64)* @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0__10323, void (i8*, i8*, %Complexf*, i64)** %closure.func10397
%closure_size10398 = call i64 @llvm_zone_mark_size(%mzone* %zone10383)
call void @llvm_zone_ptr_set_size(i8* %clsptr10384, i64 %closure_size10398)
%wrapper_ptr10399 = call i8* @llvm_zone_malloc(%mzone* %zone10383, i64 8)
%closure_wrapper10400 = bitcast i8* %wrapper_ptr10399 to { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}**
store { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure10385, { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** %closure_wrapper10400

; let value assignment
%cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0 = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** %closure_wrapper10400, { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** %closure_wrapper10400
store { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** %cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0, { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}*** %cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0
%tmp_envptr10394 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}***}* %environment10387, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}*** %cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0Ptr, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}**** %tmp_envptr10394


%val10403 = load {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}**, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}*** %cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0Ptr
ret {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** %val10403
}


@cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0(%Complexf* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc void @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_native(%Complexf* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc i8*  @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var10404 = bitcast [99 x i8]* @gsxtmmath421 to i8*
call i32 (i8*, ...) @printf(i8* %var10404)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexf*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var10405 = bitcast [99 x i8]* @gsxtmmath421 to i8*
call i32 (i8*, ...) @printf(i8* %var10405)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf*, i64}*
%arg_p_0 = getelementptr {%Complexf*, i64}, {%Complexf*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf*, %Complexf** %arg_p_0
%arg_p_1 = getelementptr {%Complexf*, i64}, {%Complexf*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cart_to_pol_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath422 = hidden constant [45 x i8] c"pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ\00"
define dllexport fastcc %Complexf @pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ__10406(i8* %_impz,i8* %_impenv, %Complexf %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10407 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***}*
%pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQPtr_ = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***}* %impenv, i32 0, i32 0
%pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQPtr = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**** %pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQPtr_

; setup arguments
%aPtr = alloca %Complexf
store %Complexf %a, %Complexf* %aPtr


%val10408 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10409 = extractvalue %Complexf %val10408, 0
%val10410 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10411 = extractvalue %Complexf %val10410, 1
%val10412 = call float @llvm.cos.f32(float %val10411)
%val10413 = fmul float %val10409, %val10412
%val10414 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10415 = extractvalue %Complexf %val10414, 0
%val10416 = load %Complexf, %Complexf* %aPtr
; tuple ref
%val10417 = extractvalue %Complexf %val10416, 1
%val10418 = call float @llvm.sin.f32(float %val10417)
%val10419 = fmul float %val10415, %val10418
%res10420 = call fastcc %Complexf @Cpxf_adhoc_W0NvbXBsZXhmLGZsb2F0LGZsb2F0XQ(float %val10413, float %val10419)
ret %Complexf %res10420
}
define dllexport ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** @pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10440 = load i8*, i8** %_impzPtr
%zone10441 = bitcast i8* %tzone10440 to %mzone*

; let assign value to symbol pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ
%dat_pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ = call i8* @llvm_zone_malloc(%mzone* %zone10441, i64 8)
%pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQPtr = bitcast i8* %dat_pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ to { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***
%tzone10421 = load i8*, i8** %_impzPtr
%zone10422 = bitcast i8* %tzone10421 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10422)
; malloc closure structure
%clsptr10423 = call i8* @llvm_zone_malloc(%mzone* %zone10422, i64 24)
%closure10424 = bitcast i8* %clsptr10423 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}*

; malloc environment structure
%envptr10425 = call i8* @llvm_zone_malloc(%mzone* %zone10422, i64 8)
%environment10426 = bitcast i8* %envptr10425 to {{i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***}*

; malloc closure address table
%addytable10427 = call %clsvar* @new_address_table()
%var10428 = bitcast [45 x i8]* @gsxtmmath422 to i8*
%var10429 = bitcast [47 x i8]* @gsxtmmath417 to i8*
%addytable10430 = call %clsvar* @add_address_table(%mzone* %zone10422, i8* %var10428, i32 0, i8* %var10429, i32 3, %clsvar* %addytable10427)
%address-table10431 = bitcast %clsvar* %addytable10430 to i8*

; insert table, function and environment into closure struct
%closure.table10434 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure10424, i32 0, i32 0
store i8* %address-table10431, i8** %closure.table10434
%closure.env10435 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure10424, i32 0, i32 1
store i8* %envptr10425, i8** %closure.env10435
%closure.func10436 = getelementptr { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure10424, i32 0, i32 2
store %Complexf (i8*, i8*, %Complexf)* @pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ__10406, %Complexf (i8*, i8*, %Complexf)** %closure.func10436
%closure_size10437 = call i64 @llvm_zone_mark_size(%mzone* %zone10422)
call void @llvm_zone_ptr_set_size(i8* %clsptr10423, i64 %closure_size10437)
%wrapper_ptr10438 = call i8* @llvm_zone_malloc(%mzone* %zone10422, i64 8)
%closure_wrapper10439 = bitcast i8* %wrapper_ptr10438 to { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure10424, { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %closure_wrapper10439

; let value assignment
%pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ = select i1 true, { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %closure_wrapper10439, { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %closure_wrapper10439
store { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ, { i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}*** %pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQPtr

; add data to environment
; don't need to alloc for env var pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ
%tmp_envptr10433 = getelementptr {{i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***}, {{i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}***}* %environment10426, i32 0, i32 0
store {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}*** %pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQPtr, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**** %tmp_envptr10433


%val10442 = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}*** %pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQPtr
ret {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %val10442
}


@pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var = dllexport global [1 x i8*] [ i8* null ]

@pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** @pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Complexf @pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ(%Complexf %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf)*,  %Complexf (i8*, i8*, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0)
ret %Complexf %result
}


define dllexport ccc %Complexf @pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_native(%Complexf %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf)*,  %Complexf (i8*, i8*, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0)
ret %Complexf %result
}


define dllexport ccc void @pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf}*
%arg_p_0 = getelementptr {%Complexf}, {%Complexf}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf, %Complexf* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W0NvbXBsZXhmLENvbXBsZXhmXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}**
%closure = load {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}*, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}, {i8*, i8*, %Complexf (i8*, i8*, %Complexf)*}* %closure, i32 0, i32 1
%ff = load  %Complexf (i8*, i8*, %Complexf)*,  %Complexf (i8*, i8*, %Complexf)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Complexf %ff(i8* %_impz, i8* %ee, %Complexf %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath423 = hidden constant [46 x i8] c"pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0\00"
define dllexport fastcc void @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0__10443(i8* %_impz,i8* %_impenv, %Complexf* %a, i64 %n) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10444 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}***}*
%pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}***}* %impenv, i32 0, i32 0
%pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0Ptr = load {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}***, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}**** %pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0Ptr_

; setup arguments
%aPtr = alloca %Complexf*
store %Complexf* %a, %Complexf** %aPtr
%nPtr = alloca i64
store i64 %n, i64* %nPtr


%tzone10445 = load i8*, i8** %_impzPtr
%zone10446 = bitcast i8* %tzone10445 to %mzone*

; let assign value to symbol temp
%tempPtr = alloca float

; let value assignment
%temp = select i1 true, float 0x0, float 0x0
store float %temp, float* %tempPtr

%tzone10448 = load i8*, i8** %_impzPtr
%zone10449 = bitcast i8* %tzone10448 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val10447 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val10447, i64 %val10447
store i64 %i, i64* %iPtr

; setup loop
%val10452 = load i64, i64* %nPtr
store i64 0, i64* %iPtr
%val10486 = load i64, i64* %iPtr
%num10487 = add i64 %val10452, %val10486
%comp10488 = icmp ult i64 %val10452, 1
br i1 %comp10488, label %after10450, label %loop10450

loop10450:
; do set!
%val10453 = load i64, i64* %iPtr
%val10454 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val10455 = getelementptr %Complexf, %Complexf* %val10454, i64 %val10453
%val10456 = load %Complexf, %Complexf* %val10455
; tuple ref
%val10457 = extractvalue %Complexf %val10456, 0
%val10458 = load i64, i64* %iPtr
%val10459 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val10460 = getelementptr %Complexf, %Complexf* %val10459, i64 %val10458
%val10461 = load %Complexf, %Complexf* %val10460
; tuple ref
%val10462 = extractvalue %Complexf %val10461, 1
%val10463 = call float @llvm.cos.f32(float %val10462)
%val10464 = fmul float %val10457, %val10463
store float %val10464, float* %tempPtr
%val10465 = load i64, i64* %iPtr
%val10466 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val10467 = getelementptr %Complexf, %Complexf* %val10466, i64 %val10465
%val10468 = load i64, i64* %iPtr
%val10469 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val10470 = getelementptr %Complexf, %Complexf* %val10469, i64 %val10468
%val10471 = load %Complexf, %Complexf* %val10470
; tuple ref
%val10472 = extractvalue %Complexf %val10471, 0
%val10473 = load i64, i64* %iPtr
%val10474 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val10475 = getelementptr %Complexf, %Complexf* %val10474, i64 %val10473
%val10476 = load %Complexf, %Complexf* %val10475
; tuple ref
%val10477 = extractvalue %Complexf %val10476, 1
%val10478 = call float @llvm.sin.f32(float %val10477)
%val10479 = fmul float %val10472, %val10478
; set tuple
%val10480 = getelementptr %Complexf, %Complexf* %val10467, i64 0, i32 1
store float %val10479, float* %val10480
%val10481 = load i64, i64* %iPtr
%val10482 = load %Complexf*, %Complexf** %aPtr
; pointer ref
%val10483 = getelementptr %Complexf, %Complexf* %val10482, i64 %val10481
%val10484 = load float, float* %tempPtr
; set tuple
%val10485 = getelementptr %Complexf, %Complexf* %val10483, i64 0, i32 0
store float %val10484, float* %val10485
%loop_cnt10450 = load i64, i64* %iPtr
%next10450 = add i64 %loop_cnt10450, 1
store i64 %next10450, i64* %iPtr
%cmp10450 = icmp ult i64 %next10450, %num10487
br i1 %cmp10450, label %loop10450, label %after10450

after10450:
ret void
}
@gsxtmmath424 = hidden constant [99 x i8] c"pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10510 = load i8*, i8** %_impzPtr
%zone10511 = bitcast i8* %tzone10510 to %mzone*

; let assign value to symbol pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0
%dat_pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone10511, i64 8)
%pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0Ptr = bitcast i8* %dat_pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0 to { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}***
%tzone10491 = load i8*, i8** %_impzPtr
%zone10492 = bitcast i8* %tzone10491 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10492)
; malloc closure structure
%clsptr10493 = call i8* @llvm_zone_malloc(%mzone* %zone10492, i64 24)
%closure10494 = bitcast i8* %clsptr10493 to { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}*

; malloc environment structure
%envptr10495 = call i8* @llvm_zone_malloc(%mzone* %zone10492, i64 8)
%environment10496 = bitcast i8* %envptr10495 to {{i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}***}*

; malloc closure address table
%addytable10497 = call %clsvar* @new_address_table()
%var10498 = bitcast [46 x i8]* @gsxtmmath423 to i8*
%var10499 = bitcast [48 x i8]* @gsxtmmath420 to i8*
%addytable10500 = call %clsvar* @add_address_table(%mzone* %zone10492, i8* %var10498, i32 0, i8* %var10499, i32 3, %clsvar* %addytable10497)
%address-table10501 = bitcast %clsvar* %addytable10500 to i8*

; insert table, function and environment into closure struct
%closure.table10504 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure10494, i32 0, i32 0
store i8* %address-table10501, i8** %closure.table10504
%closure.env10505 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure10494, i32 0, i32 1
store i8* %envptr10495, i8** %closure.env10505
%closure.func10506 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure10494, i32 0, i32 2
store void (i8*, i8*, %Complexf*, i64)* @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0__10443, void (i8*, i8*, %Complexf*, i64)** %closure.func10506
%closure_size10507 = call i64 @llvm_zone_mark_size(%mzone* %zone10492)
call void @llvm_zone_ptr_set_size(i8* %clsptr10493, i64 %closure_size10507)
%wrapper_ptr10508 = call i8* @llvm_zone_malloc(%mzone* %zone10492, i64 8)
%closure_wrapper10509 = bitcast i8* %wrapper_ptr10508 to { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}**
store { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure10494, { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** %closure_wrapper10509

; let value assignment
%pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0 = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** %closure_wrapper10509, { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** %closure_wrapper10509
store { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** %pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0, { i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}*** %pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0
%tmp_envptr10503 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}***}* %environment10496, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}*** %pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0Ptr, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}**** %tmp_envptr10503


%val10512 = load {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}**, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}*** %pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0Ptr
ret {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** %val10512
}


@pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0(%Complexf* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc void @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_native(%Complexf* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc i8*  @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var10513 = bitcast [99 x i8]* @gsxtmmath424 to i8*
call i32 (i8*, ...) @printf(i8* %var10513)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexf*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var10514 = bitcast [99 x i8]* @gsxtmmath424 to i8*
call i32 (i8*, ...) @printf(i8* %var10514)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf*, i64}*
%arg_p_0 = getelementptr {%Complexf*, i64}, {%Complexf*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf*, %Complexf** %arg_p_0
%arg_p_1 = getelementptr {%Complexf*, i64}, {%Complexf*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pol_to_cart_adhoc_W3ZvaWQsQ29tcGxleGYqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, i64)*,  void (i8*, i8*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath425 = hidden constant [71 x i8] c"Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ\00"
@gsxtmmath426 = hidden constant [64 x i8] c"{i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}**\00"
define dllexport fastcc void @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ__10515(i8* %_impz,i8* %_impenv, float* %re, float* %im, %Complexf* %com, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10516 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}***}*
%Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}***}* %impenv, i32 0, i32 0
%Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}***, {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}**** %Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQPtr_

; setup arguments
%rePtr = alloca float*
store float* %re, float** %rePtr
%imPtr = alloca float*
store float* %im, float** %imPtr
%comPtr = alloca %Complexf*
store %Complexf* %com, %Complexf** %comPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone10517 = load i8*, i8** %_impzPtr
%zone10518 = bitcast i8* %tzone10517 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val10521 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val10538 = load i64, i64* %iPtr
%num10539 = add i64 %val10521, %val10538
%comp10540 = icmp ult i64 %val10521, 1
br i1 %comp10540, label %after10519, label %loop10519

loop10519:
%val10522 = load i64, i64* %iPtr
%val10523 = load %Complexf*, %Complexf** %comPtr
; pointer ref
%val10524 = getelementptr %Complexf, %Complexf* %val10523, i64 %val10522
%val10525 = load i64, i64* %iPtr
%val10526 = load float*, float** %rePtr
; pointer ref
%val10527 = getelementptr float, float* %val10526, i64 %val10525
%val10528 = load float, float* %val10527
; set tuple
%val10529 = getelementptr %Complexf, %Complexf* %val10524, i64 0, i32 0
store float %val10528, float* %val10529
%val10530 = load i64, i64* %iPtr
%val10531 = load %Complexf*, %Complexf** %comPtr
; pointer ref
%val10532 = getelementptr %Complexf, %Complexf* %val10531, i64 %val10530
%val10533 = load i64, i64* %iPtr
%val10534 = load float*, float** %imPtr
; pointer ref
%val10535 = getelementptr float, float* %val10534, i64 %val10533
%val10536 = load float, float* %val10535
; set tuple
%val10537 = getelementptr %Complexf, %Complexf* %val10532, i64 0, i32 1
store float %val10536, float* %val10537
%loop_cnt10519 = load i64, i64* %iPtr
%next10519 = add i64 %loop_cnt10519, 1
store i64 %next10519, i64* %iPtr
%cmp10519 = icmp ult i64 %next10519, %num10539
br i1 %cmp10519, label %loop10519, label %after10519

after10519:
ret void
}
@gsxtmmath427 = hidden constant [124 x i8] c"Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}** @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10562 = load i8*, i8** %_impzPtr
%zone10563 = bitcast i8* %tzone10562 to %mzone*

; let assign value to symbol Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ
%dat_Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone10563, i64 8)
%Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQPtr = bitcast i8* %dat_Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ to { i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}***
%tzone10543 = load i8*, i8** %_impzPtr
%zone10544 = bitcast i8* %tzone10543 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10544)
; malloc closure structure
%clsptr10545 = call i8* @llvm_zone_malloc(%mzone* %zone10544, i64 24)
%closure10546 = bitcast i8* %clsptr10545 to { i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}*

; malloc environment structure
%envptr10547 = call i8* @llvm_zone_malloc(%mzone* %zone10544, i64 8)
%environment10548 = bitcast i8* %envptr10547 to {{i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}***}*

; malloc closure address table
%addytable10549 = call %clsvar* @new_address_table()
%var10550 = bitcast [71 x i8]* @gsxtmmath425 to i8*
%var10551 = bitcast [64 x i8]* @gsxtmmath426 to i8*
%addytable10552 = call %clsvar* @add_address_table(%mzone* %zone10544, i8* %var10550, i32 0, i8* %var10551, i32 3, %clsvar* %addytable10549)
%address-table10553 = bitcast %clsvar* %addytable10552 to i8*

; insert table, function and environment into closure struct
%closure.table10556 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}* %closure10546, i32 0, i32 0
store i8* %address-table10553, i8** %closure.table10556
%closure.env10557 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}* %closure10546, i32 0, i32 1
store i8* %envptr10547, i8** %closure.env10557
%closure.func10558 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}* %closure10546, i32 0, i32 2
store void (i8*, i8*, float*, float*, %Complexf*, i64)* @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ__10515, void (i8*, i8*, float*, float*, %Complexf*, i64)** %closure.func10558
%closure_size10559 = call i64 @llvm_zone_mark_size(%mzone* %zone10544)
call void @llvm_zone_ptr_set_size(i8* %clsptr10545, i64 %closure_size10559)
%wrapper_ptr10560 = call i8* @llvm_zone_malloc(%mzone* %zone10544, i64 8)
%closure_wrapper10561 = bitcast i8* %wrapper_ptr10560 to { i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}**
store { i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}* %closure10546, { i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}** %closure_wrapper10561

; let value assignment
%Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}** %closure_wrapper10561, { i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}** %closure_wrapper10561
store { i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}** %Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ, { i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}*** %Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQPtr

; add data to environment
; don't need to alloc for env var Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ
%tmp_envptr10555 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}***}* %environment10548, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}*** %Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQPtr, {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}**** %tmp_envptr10555


%val10564 = load {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}**, {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}*** %Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}** %val10564
}


@Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}** @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ(float* %arg_0,float* %arg_1,%Complexf* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, %Complexf*, i64)*,  void (i8*, i8*, float*, float*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, %Complexf* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc void @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ_native(float* %arg_0,float* %arg_1,%Complexf* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, %Complexf*, i64)*,  void (i8*, i8*, float*, float*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, %Complexf* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc i8*  @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var10565 = bitcast [124 x i8]* @gsxtmmath427 to i8*
call i32 (i8*, ...) @printf(i8* %var10565)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var10566 = bitcast [124 x i8]* @gsxtmmath427 to i8*
call i32 (i8*, ...) @printf(i8* %var10566)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var10567 = bitcast [124 x i8]* @gsxtmmath427 to i8*
call i32 (i8*, ...) @printf(i8* %var10567)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Complexf*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var10568 = bitcast [124 x i8]* @gsxtmmath427 to i8*
call i32 (i8*, ...) @printf(i8* %var10568)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, %Complexf*, i64)*,  void (i8*, i8*, float*, float*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, %Complexf* %arg_2, i64 %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, %Complexf*, i64}*
%arg_p_0 = getelementptr {float*, float*, %Complexf*, i64}, {float*, float*, %Complexf*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, %Complexf*, i64}, {float*, float*, %Complexf*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, %Complexf*, i64}, {float*, float*, %Complexf*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load %Complexf*, %Complexf** %arg_p_2
%arg_p_3 = getelementptr {float*, float*, %Complexf*, i64}, {float*, float*, %Complexf*, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixDb21wbGV4ZiosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, float*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, %Complexf*, i64)*,  void (i8*, i8*, float*, float*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, %Complexf* %arg_2, i64 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath428 = hidden constant [61 x i8] c"Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd\00"
@gsxtmmath429 = hidden constant [56 x i8] c"{i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}**\00"
define dllexport fastcc void @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd__10569(i8* %_impz,i8* %_impenv, float* %re, %Complexf* %com, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10570 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}***}*
%Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}***}* %impenv, i32 0, i32 0
%Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRdPtr = load {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}***, {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}**** %Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRdPtr_

; setup arguments
%rePtr = alloca float*
store float* %re, float** %rePtr
%comPtr = alloca %Complexf*
store %Complexf* %com, %Complexf** %comPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone10571 = load i8*, i8** %_impzPtr
%zone10572 = bitcast i8* %tzone10571 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val10575 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val10588 = load i64, i64* %iPtr
%num10589 = add i64 %val10575, %val10588
%comp10590 = icmp ult i64 %val10575, 1
br i1 %comp10590, label %after10573, label %loop10573

loop10573:
%val10576 = load i64, i64* %iPtr
%val10577 = load %Complexf*, %Complexf** %comPtr
; pointer ref
%val10578 = getelementptr %Complexf, %Complexf* %val10577, i64 %val10576
%val10579 = load i64, i64* %iPtr
%val10580 = load float*, float** %rePtr
; pointer ref
%val10581 = getelementptr float, float* %val10580, i64 %val10579
%val10582 = load float, float* %val10581
; set tuple
%val10583 = getelementptr %Complexf, %Complexf* %val10578, i64 0, i32 0
store float %val10582, float* %val10583
%val10584 = load i64, i64* %iPtr
%val10585 = load %Complexf*, %Complexf** %comPtr
; pointer ref
%val10586 = getelementptr %Complexf, %Complexf* %val10585, i64 %val10584
; set tuple
%val10587 = getelementptr %Complexf, %Complexf* %val10586, i64 0, i32 1
store float 0x0, float* %val10587
%loop_cnt10573 = load i64, i64* %iPtr
%next10573 = add i64 %loop_cnt10573, 1
store i64 %next10573, i64* %iPtr
%cmp10573 = icmp ult i64 %next10573, %num10589
br i1 %cmp10573, label %loop10573, label %after10573

after10573:
ret void
}
@gsxtmmath430 = hidden constant [114 x i8] c"Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}** @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10612 = load i8*, i8** %_impzPtr
%zone10613 = bitcast i8* %tzone10612 to %mzone*

; let assign value to symbol Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd
%dat_Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone10613, i64 8)
%Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRdPtr = bitcast i8* %dat_Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd to { i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}***
%tzone10593 = load i8*, i8** %_impzPtr
%zone10594 = bitcast i8* %tzone10593 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10594)
; malloc closure structure
%clsptr10595 = call i8* @llvm_zone_malloc(%mzone* %zone10594, i64 24)
%closure10596 = bitcast i8* %clsptr10595 to { i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}*

; malloc environment structure
%envptr10597 = call i8* @llvm_zone_malloc(%mzone* %zone10594, i64 8)
%environment10598 = bitcast i8* %envptr10597 to {{i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}***}*

; malloc closure address table
%addytable10599 = call %clsvar* @new_address_table()
%var10600 = bitcast [61 x i8]* @gsxtmmath428 to i8*
%var10601 = bitcast [56 x i8]* @gsxtmmath429 to i8*
%addytable10602 = call %clsvar* @add_address_table(%mzone* %zone10594, i8* %var10600, i32 0, i8* %var10601, i32 3, %clsvar* %addytable10599)
%address-table10603 = bitcast %clsvar* %addytable10602 to i8*

; insert table, function and environment into closure struct
%closure.table10606 = getelementptr { i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}* %closure10596, i32 0, i32 0
store i8* %address-table10603, i8** %closure.table10606
%closure.env10607 = getelementptr { i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}* %closure10596, i32 0, i32 1
store i8* %envptr10597, i8** %closure.env10607
%closure.func10608 = getelementptr { i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}, { i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}* %closure10596, i32 0, i32 2
store void (i8*, i8*, float*, %Complexf*, i64)* @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd__10569, void (i8*, i8*, float*, %Complexf*, i64)** %closure.func10608
%closure_size10609 = call i64 @llvm_zone_mark_size(%mzone* %zone10594)
call void @llvm_zone_ptr_set_size(i8* %clsptr10595, i64 %closure_size10609)
%wrapper_ptr10610 = call i8* @llvm_zone_malloc(%mzone* %zone10594, i64 8)
%closure_wrapper10611 = bitcast i8* %wrapper_ptr10610 to { i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}**
store { i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}* %closure10596, { i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}** %closure_wrapper10611

; let value assignment
%Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd = select i1 true, { i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}** %closure_wrapper10611, { i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}** %closure_wrapper10611
store { i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}** %Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd, { i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}*** %Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRdPtr

; add data to environment
; don't need to alloc for env var Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd
%tmp_envptr10605 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}***}* %environment10598, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}*** %Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRdPtr, {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}**** %tmp_envptr10605


%val10614 = load {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}**, {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}*** %Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRdPtr
ret {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}** %val10614
}


@Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}** @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd(float* %arg_0,%Complexf* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, %Complexf*, i64)*,  void (i8*, i8*, float*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, %Complexf* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd_native(float* %arg_0,%Complexf* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, %Complexf*, i64)*,  void (i8*, i8*, float*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, %Complexf* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var10615 = bitcast [114 x i8]* @gsxtmmath430 to i8*
call i32 (i8*, ...) @printf(i8* %var10615)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var10616 = bitcast [114 x i8]* @gsxtmmath430 to i8*
call i32 (i8*, ...) @printf(i8* %var10616)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Complexf*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var10617 = bitcast [114 x i8]* @gsxtmmath430 to i8*
call i32 (i8*, ...) @printf(i8* %var10617)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, %Complexf*, i64)*,  void (i8*, i8*, float*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, %Complexf* %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, %Complexf*, i64}*
%arg_p_0 = getelementptr {float*, %Complexf*, i64}, {float*, %Complexf*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, %Complexf*, i64}, {float*, %Complexf*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexf*, %Complexf** %arg_p_1
%arg_p_2 = getelementptr {float*, %Complexf*, i64}, {float*, %Complexf*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZmxvYXQqLENvbXBsZXhmKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, %Complexf*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, %Complexf*, i64)*,  void (i8*, i8*, float*, %Complexf*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, %Complexf* %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath431 = hidden constant [73 x i8] c"Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd\00"
@gsxtmmath432 = hidden constant [66 x i8] c"{i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}**\00"
define dllexport fastcc void @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd__10618(i8* %_impz,i8* %_impenv, double* %re, double* %im, %Complexd* %com, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10619 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}***}*
%Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}***}* %impenv, i32 0, i32 0
%Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRdPtr = load {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}***, {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}**** %Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRdPtr_

; setup arguments
%rePtr = alloca double*
store double* %re, double** %rePtr
%imPtr = alloca double*
store double* %im, double** %imPtr
%comPtr = alloca %Complexd*
store %Complexd* %com, %Complexd** %comPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone10620 = load i8*, i8** %_impzPtr
%zone10621 = bitcast i8* %tzone10620 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val10624 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val10641 = load i64, i64* %iPtr
%num10642 = add i64 %val10624, %val10641
%comp10643 = icmp ult i64 %val10624, 1
br i1 %comp10643, label %after10622, label %loop10622

loop10622:
%val10625 = load i64, i64* %iPtr
%val10626 = load %Complexd*, %Complexd** %comPtr
; pointer ref
%val10627 = getelementptr %Complexd, %Complexd* %val10626, i64 %val10625
%val10628 = load i64, i64* %iPtr
%val10629 = load double*, double** %rePtr
; pointer ref
%val10630 = getelementptr double, double* %val10629, i64 %val10628
%val10631 = load double, double* %val10630
; set tuple
%val10632 = getelementptr %Complexd, %Complexd* %val10627, i64 0, i32 0
store double %val10631, double* %val10632
%val10633 = load i64, i64* %iPtr
%val10634 = load %Complexd*, %Complexd** %comPtr
; pointer ref
%val10635 = getelementptr %Complexd, %Complexd* %val10634, i64 %val10633
%val10636 = load i64, i64* %iPtr
%val10637 = load double*, double** %imPtr
; pointer ref
%val10638 = getelementptr double, double* %val10637, i64 %val10636
%val10639 = load double, double* %val10638
; set tuple
%val10640 = getelementptr %Complexd, %Complexd* %val10635, i64 0, i32 1
store double %val10639, double* %val10640
%loop_cnt10622 = load i64, i64* %iPtr
%next10622 = add i64 %loop_cnt10622, 1
store i64 %next10622, i64* %iPtr
%cmp10622 = icmp ult i64 %next10622, %num10642
br i1 %cmp10622, label %loop10622, label %after10622

after10622:
ret void
}
@gsxtmmath433 = hidden constant [126 x i8] c"Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}** @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10665 = load i8*, i8** %_impzPtr
%zone10666 = bitcast i8* %tzone10665 to %mzone*

; let assign value to symbol Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd
%dat_Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone10666, i64 8)
%Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRdPtr = bitcast i8* %dat_Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd to { i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}***
%tzone10646 = load i8*, i8** %_impzPtr
%zone10647 = bitcast i8* %tzone10646 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10647)
; malloc closure structure
%clsptr10648 = call i8* @llvm_zone_malloc(%mzone* %zone10647, i64 24)
%closure10649 = bitcast i8* %clsptr10648 to { i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}*

; malloc environment structure
%envptr10650 = call i8* @llvm_zone_malloc(%mzone* %zone10647, i64 8)
%environment10651 = bitcast i8* %envptr10650 to {{i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}***}*

; malloc closure address table
%addytable10652 = call %clsvar* @new_address_table()
%var10653 = bitcast [73 x i8]* @gsxtmmath431 to i8*
%var10654 = bitcast [66 x i8]* @gsxtmmath432 to i8*
%addytable10655 = call %clsvar* @add_address_table(%mzone* %zone10647, i8* %var10653, i32 0, i8* %var10654, i32 3, %clsvar* %addytable10652)
%address-table10656 = bitcast %clsvar* %addytable10655 to i8*

; insert table, function and environment into closure struct
%closure.table10659 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}* %closure10649, i32 0, i32 0
store i8* %address-table10656, i8** %closure.table10659
%closure.env10660 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}* %closure10649, i32 0, i32 1
store i8* %envptr10650, i8** %closure.env10660
%closure.func10661 = getelementptr { i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}* %closure10649, i32 0, i32 2
store void (i8*, i8*, double*, double*, %Complexd*, i64)* @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd__10618, void (i8*, i8*, double*, double*, %Complexd*, i64)** %closure.func10661
%closure_size10662 = call i64 @llvm_zone_mark_size(%mzone* %zone10647)
call void @llvm_zone_ptr_set_size(i8* %clsptr10648, i64 %closure_size10662)
%wrapper_ptr10663 = call i8* @llvm_zone_malloc(%mzone* %zone10647, i64 8)
%closure_wrapper10664 = bitcast i8* %wrapper_ptr10663 to { i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}**
store { i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}* %closure10649, { i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}** %closure_wrapper10664

; let value assignment
%Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd = select i1 true, { i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}** %closure_wrapper10664, { i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}** %closure_wrapper10664
store { i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}** %Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd, { i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}*** %Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRdPtr

; add data to environment
; don't need to alloc for env var Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd
%tmp_envptr10658 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}***}* %environment10651, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}*** %Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRdPtr, {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}**** %tmp_envptr10658


%val10667 = load {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}**, {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}*** %Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRdPtr
ret {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}** %val10667
}


@Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}** @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd(double* %arg_0,double* %arg_1,%Complexd* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, %Complexd*, i64)*,  void (i8*, i8*, double*, double*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, %Complexd* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc void @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd_native(double* %arg_0,double* %arg_1,%Complexd* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, %Complexd*, i64)*,  void (i8*, i8*, double*, double*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, %Complexd* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc i8*  @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var10668 = bitcast [126 x i8]* @gsxtmmath433 to i8*
call i32 (i8*, ...) @printf(i8* %var10668)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var10669 = bitcast [126 x i8]* @gsxtmmath433 to i8*
call i32 (i8*, ...) @printf(i8* %var10669)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to double*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var10670 = bitcast [126 x i8]* @gsxtmmath433 to i8*
call i32 (i8*, ...) @printf(i8* %var10670)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Complexd*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var10671 = bitcast [126 x i8]* @gsxtmmath433 to i8*
call i32 (i8*, ...) @printf(i8* %var10671)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, %Complexd*, i64)*,  void (i8*, i8*, double*, double*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, %Complexd* %arg_2, i64 %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, double*, %Complexd*, i64}*
%arg_p_0 = getelementptr {double*, double*, %Complexd*, i64}, {double*, double*, %Complexd*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, double*, %Complexd*, i64}, {double*, double*, %Complexd*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load double*, double** %arg_p_1
%arg_p_2 = getelementptr {double*, double*, %Complexd*, i64}, {double*, double*, %Complexd*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load %Complexd*, %Complexd** %arg_p_2
%arg_p_3 = getelementptr {double*, double*, %Complexd*, i64}, {double*, double*, %Complexd*, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixkb3VibGUqLENvbXBsZXhkKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, double*, %Complexd*, i64)*,  void (i8*, i8*, double*, double*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, double* %arg_1, %Complexd* %arg_2, i64 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath434 = hidden constant [63 x i8] c"Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ\00"
@gsxtmmath435 = hidden constant [57 x i8] c"{i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}**\00"
define dllexport fastcc void @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ__10672(i8* %_impz,i8* %_impenv, double* %re, %Complexd* %com, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10673 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}***}*
%Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}***}* %impenv, i32 0, i32 0
%Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}***, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}**** %Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQPtr_

; setup arguments
%rePtr = alloca double*
store double* %re, double** %rePtr
%comPtr = alloca %Complexd*
store %Complexd* %com, %Complexd** %comPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone10674 = load i8*, i8** %_impzPtr
%zone10675 = bitcast i8* %tzone10674 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val10678 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val10691 = load i64, i64* %iPtr
%num10692 = add i64 %val10678, %val10691
%comp10693 = icmp ult i64 %val10678, 1
br i1 %comp10693, label %after10676, label %loop10676

loop10676:
%val10679 = load i64, i64* %iPtr
%val10680 = load %Complexd*, %Complexd** %comPtr
; pointer ref
%val10681 = getelementptr %Complexd, %Complexd* %val10680, i64 %val10679
%val10682 = load i64, i64* %iPtr
%val10683 = load double*, double** %rePtr
; pointer ref
%val10684 = getelementptr double, double* %val10683, i64 %val10682
%val10685 = load double, double* %val10684
; set tuple
%val10686 = getelementptr %Complexd, %Complexd* %val10681, i64 0, i32 0
store double %val10685, double* %val10686
%val10687 = load i64, i64* %iPtr
%val10688 = load %Complexd*, %Complexd** %comPtr
; pointer ref
%val10689 = getelementptr %Complexd, %Complexd* %val10688, i64 %val10687
; set tuple
%val10690 = getelementptr %Complexd, %Complexd* %val10689, i64 0, i32 1
store double 0.00000000000000000000, double* %val10690
%loop_cnt10676 = load i64, i64* %iPtr
%next10676 = add i64 %loop_cnt10676, 1
store i64 %next10676, i64* %iPtr
%cmp10676 = icmp ult i64 %next10676, %num10692
br i1 %cmp10676, label %loop10676, label %after10676

after10676:
ret void
}
@gsxtmmath436 = hidden constant [116 x i8] c"Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10715 = load i8*, i8** %_impzPtr
%zone10716 = bitcast i8* %tzone10715 to %mzone*

; let assign value to symbol Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ
%dat_Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone10716, i64 8)
%Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQPtr = bitcast i8* %dat_Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ to { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}***
%tzone10696 = load i8*, i8** %_impzPtr
%zone10697 = bitcast i8* %tzone10696 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10697)
; malloc closure structure
%clsptr10698 = call i8* @llvm_zone_malloc(%mzone* %zone10697, i64 24)
%closure10699 = bitcast i8* %clsptr10698 to { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}*

; malloc environment structure
%envptr10700 = call i8* @llvm_zone_malloc(%mzone* %zone10697, i64 8)
%environment10701 = bitcast i8* %envptr10700 to {{i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}***}*

; malloc closure address table
%addytable10702 = call %clsvar* @new_address_table()
%var10703 = bitcast [63 x i8]* @gsxtmmath434 to i8*
%var10704 = bitcast [57 x i8]* @gsxtmmath435 to i8*
%addytable10705 = call %clsvar* @add_address_table(%mzone* %zone10697, i8* %var10703, i32 0, i8* %var10704, i32 3, %clsvar* %addytable10702)
%address-table10706 = bitcast %clsvar* %addytable10705 to i8*

; insert table, function and environment into closure struct
%closure.table10709 = getelementptr { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure10699, i32 0, i32 0
store i8* %address-table10706, i8** %closure.table10709
%closure.env10710 = getelementptr { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure10699, i32 0, i32 1
store i8* %envptr10700, i8** %closure.env10710
%closure.func10711 = getelementptr { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure10699, i32 0, i32 2
store void (i8*, i8*, double*, %Complexd*, i64)* @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ__10672, void (i8*, i8*, double*, %Complexd*, i64)** %closure.func10711
%closure_size10712 = call i64 @llvm_zone_mark_size(%mzone* %zone10697)
call void @llvm_zone_ptr_set_size(i8* %clsptr10698, i64 %closure_size10712)
%wrapper_ptr10713 = call i8* @llvm_zone_malloc(%mzone* %zone10697, i64 8)
%closure_wrapper10714 = bitcast i8* %wrapper_ptr10713 to { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}**
store { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure10699, { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** %closure_wrapper10714

; let value assignment
%Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** %closure_wrapper10714, { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** %closure_wrapper10714
store { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** %Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ, { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}*** %Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQPtr

; add data to environment
; don't need to alloc for env var Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ
%tmp_envptr10708 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}***}* %environment10701, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}*** %Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQPtr, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}**** %tmp_envptr10708


%val10717 = load {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}**, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}*** %Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** %val10717
}


@Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ(double* %arg_0,%Complexd* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, %Complexd*, i64)*,  void (i8*, i8*, double*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, %Complexd* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_native(double* %arg_0,%Complexd* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, %Complexd*, i64)*,  void (i8*, i8*, double*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, %Complexd* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var10718 = bitcast [116 x i8]* @gsxtmmath436 to i8*
call i32 (i8*, ...) @printf(i8* %var10718)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var10719 = bitcast [116 x i8]* @gsxtmmath436 to i8*
call i32 (i8*, ...) @printf(i8* %var10719)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Complexd*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var10720 = bitcast [116 x i8]* @gsxtmmath436 to i8*
call i32 (i8*, ...) @printf(i8* %var10720)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, %Complexd*, i64)*,  void (i8*, i8*, double*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, %Complexd* %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, %Complexd*, i64}*
%arg_p_0 = getelementptr {double*, %Complexd*, i64}, {double*, %Complexd*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, %Complexd*, i64}, {double*, %Complexd*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexd*, %Complexd** %arg_p_1
%arg_p_2 = getelementptr {double*, %Complexd*, i64}, {double*, %Complexd*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_bufferize_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, %Complexd*, i64)*,  void (i8*, i8*, double*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, %Complexd* %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath437 = hidden constant [73 x i8] c"Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ\00"
@gsxtmmath438 = hidden constant [64 x i8] c"{i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}**\00"
define dllexport fastcc void @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ__10721(i8* %_impz,i8* %_impenv, %Complexf* %com, float* %re, float* %im, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10722 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}***}*
%Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}***}* %impenv, i32 0, i32 0
%Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}***, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}**** %Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQPtr_

; setup arguments
%comPtr = alloca %Complexf*
store %Complexf* %com, %Complexf** %comPtr
%rePtr = alloca float*
store float* %re, float** %rePtr
%imPtr = alloca float*
store float* %im, float** %imPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone10723 = load i8*, i8** %_impzPtr
%zone10724 = bitcast i8* %tzone10723 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val10727 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val10744 = load i64, i64* %iPtr
%num10745 = add i64 %val10727, %val10744
%comp10746 = icmp ult i64 %val10727, 1
br i1 %comp10746, label %after10725, label %loop10725

loop10725:
%val10728 = load i64, i64* %iPtr
%val10729 = load float*, float** %rePtr
%val10730 = load i64, i64* %iPtr
%val10731 = load %Complexf*, %Complexf** %comPtr
; pointer ref
%val10732 = getelementptr %Complexf, %Complexf* %val10731, i64 %val10730
; tuple ref
%val10733 = getelementptr %Complexf, %Complexf* %val10732, i64 0, i32 0
%val10734 = load float, float* %val10733
; set pointer
%val10735 = getelementptr float, float* %val10729, i64 %val10728
store float %val10734, float* %val10735
%val10736 = load i64, i64* %iPtr
%val10737 = load float*, float** %imPtr
%val10738 = load i64, i64* %iPtr
%val10739 = load %Complexf*, %Complexf** %comPtr
; pointer ref
%val10740 = getelementptr %Complexf, %Complexf* %val10739, i64 %val10738
; tuple ref
%val10741 = getelementptr %Complexf, %Complexf* %val10740, i64 0, i32 1
%val10742 = load float, float* %val10741
; set pointer
%val10743 = getelementptr float, float* %val10737, i64 %val10736
store float %val10742, float* %val10743
%loop_cnt10725 = load i64, i64* %iPtr
%next10725 = add i64 %loop_cnt10725, 1
store i64 %next10725, i64* %iPtr
%cmp10725 = icmp ult i64 %next10725, %num10745
br i1 %cmp10725, label %loop10725, label %after10725

after10725:
ret void
}
@gsxtmmath439 = hidden constant [126 x i8] c"Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}** @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10768 = load i8*, i8** %_impzPtr
%zone10769 = bitcast i8* %tzone10768 to %mzone*

; let assign value to symbol Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ
%dat_Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone10769, i64 8)
%Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQPtr = bitcast i8* %dat_Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ to { i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}***
%tzone10749 = load i8*, i8** %_impzPtr
%zone10750 = bitcast i8* %tzone10749 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10750)
; malloc closure structure
%clsptr10751 = call i8* @llvm_zone_malloc(%mzone* %zone10750, i64 24)
%closure10752 = bitcast i8* %clsptr10751 to { i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}*

; malloc environment structure
%envptr10753 = call i8* @llvm_zone_malloc(%mzone* %zone10750, i64 8)
%environment10754 = bitcast i8* %envptr10753 to {{i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}***}*

; malloc closure address table
%addytable10755 = call %clsvar* @new_address_table()
%var10756 = bitcast [73 x i8]* @gsxtmmath437 to i8*
%var10757 = bitcast [64 x i8]* @gsxtmmath438 to i8*
%addytable10758 = call %clsvar* @add_address_table(%mzone* %zone10750, i8* %var10756, i32 0, i8* %var10757, i32 3, %clsvar* %addytable10755)
%address-table10759 = bitcast %clsvar* %addytable10758 to i8*

; insert table, function and environment into closure struct
%closure.table10762 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}* %closure10752, i32 0, i32 0
store i8* %address-table10759, i8** %closure.table10762
%closure.env10763 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}* %closure10752, i32 0, i32 1
store i8* %envptr10753, i8** %closure.env10763
%closure.func10764 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}* %closure10752, i32 0, i32 2
store void (i8*, i8*, %Complexf*, float*, float*, i64)* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ__10721, void (i8*, i8*, %Complexf*, float*, float*, i64)** %closure.func10764
%closure_size10765 = call i64 @llvm_zone_mark_size(%mzone* %zone10750)
call void @llvm_zone_ptr_set_size(i8* %clsptr10751, i64 %closure_size10765)
%wrapper_ptr10766 = call i8* @llvm_zone_malloc(%mzone* %zone10750, i64 8)
%closure_wrapper10767 = bitcast i8* %wrapper_ptr10766 to { i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}**
store { i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}* %closure10752, { i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}** %closure_wrapper10767

; let value assignment
%Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}** %closure_wrapper10767, { i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}** %closure_wrapper10767
store { i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}** %Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ, { i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}*** %Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQPtr

; add data to environment
; don't need to alloc for env var Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ
%tmp_envptr10761 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}***}* %environment10754, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}*** %Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQPtr, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}**** %tmp_envptr10761


%val10770 = load {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}**, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}*** %Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}** %val10770
}


@Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}** @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ(%Complexf* %arg_0,float* %arg_1,float* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, float*, float*, i64)*,  void (i8*, i8*, %Complexf*, float*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, float* %arg_1, float* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc void @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ_native(%Complexf* %arg_0,float* %arg_1,float* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, float*, float*, i64)*,  void (i8*, i8*, %Complexf*, float*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, float* %arg_1, float* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc i8*  @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var10771 = bitcast [126 x i8]* @gsxtmmath439 to i8*
call i32 (i8*, ...) @printf(i8* %var10771)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexf*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var10772 = bitcast [126 x i8]* @gsxtmmath439 to i8*
call i32 (i8*, ...) @printf(i8* %var10772)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var10773 = bitcast [126 x i8]* @gsxtmmath439 to i8*
call i32 (i8*, ...) @printf(i8* %var10773)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var10774 = bitcast [126 x i8]* @gsxtmmath439 to i8*
call i32 (i8*, ...) @printf(i8* %var10774)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, float*, float*, i64)*,  void (i8*, i8*, %Complexf*, float*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, float* %arg_1, float* %arg_2, i64 %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf*, float*, float*, i64}*
%arg_p_0 = getelementptr {%Complexf*, float*, float*, i64}, {%Complexf*, float*, float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf*, %Complexf** %arg_p_0
%arg_p_1 = getelementptr {%Complexf*, float*, float*, i64}, {%Complexf*, float*, float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {%Complexf*, float*, float*, i64}, {%Complexf*, float*, float*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%Complexf*, float*, float*, i64}, {%Complexf*, float*, float*, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixmbG9hdCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, float*, float*, i64)*,  void (i8*, i8*, %Complexf*, float*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, float* %arg_1, float* %arg_2, i64 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath440 = hidden constant [63 x i8] c"Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd\00"
@gsxtmmath441 = hidden constant [56 x i8] c"{i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}**\00"
define dllexport fastcc void @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd__10775(i8* %_impz,i8* %_impenv, %Complexf* %com, float* %re, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10776 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}***}*
%Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}***}* %impenv, i32 0, i32 0
%Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRdPtr = load {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}***, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}**** %Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRdPtr_

; setup arguments
%comPtr = alloca %Complexf*
store %Complexf* %com, %Complexf** %comPtr
%rePtr = alloca float*
store float* %re, float** %rePtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone10777 = load i8*, i8** %_impzPtr
%zone10778 = bitcast i8* %tzone10777 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val10781 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val10790 = load i64, i64* %iPtr
%num10791 = add i64 %val10781, %val10790
%comp10792 = icmp ult i64 %val10781, 1
br i1 %comp10792, label %after10779, label %loop10779

loop10779:
%val10782 = load i64, i64* %iPtr
%val10783 = load float*, float** %rePtr
%val10784 = load i64, i64* %iPtr
%val10785 = load %Complexf*, %Complexf** %comPtr
; pointer ref
%val10786 = getelementptr %Complexf, %Complexf* %val10785, i64 %val10784
; tuple ref
%val10787 = getelementptr %Complexf, %Complexf* %val10786, i64 0, i32 0
%val10788 = load float, float* %val10787
; set pointer
%val10789 = getelementptr float, float* %val10783, i64 %val10782
store float %val10788, float* %val10789
%loop_cnt10779 = load i64, i64* %iPtr
%next10779 = add i64 %loop_cnt10779, 1
store i64 %next10779, i64* %iPtr
%cmp10779 = icmp ult i64 %next10779, %num10791
br i1 %cmp10779, label %loop10779, label %after10779

after10779:
ret void
}
@gsxtmmath442 = hidden constant [116 x i8] c"Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}** @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10814 = load i8*, i8** %_impzPtr
%zone10815 = bitcast i8* %tzone10814 to %mzone*

; let assign value to symbol Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd
%dat_Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone10815, i64 8)
%Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRdPtr = bitcast i8* %dat_Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd to { i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}***
%tzone10795 = load i8*, i8** %_impzPtr
%zone10796 = bitcast i8* %tzone10795 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10796)
; malloc closure structure
%clsptr10797 = call i8* @llvm_zone_malloc(%mzone* %zone10796, i64 24)
%closure10798 = bitcast i8* %clsptr10797 to { i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}*

; malloc environment structure
%envptr10799 = call i8* @llvm_zone_malloc(%mzone* %zone10796, i64 8)
%environment10800 = bitcast i8* %envptr10799 to {{i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}***}*

; malloc closure address table
%addytable10801 = call %clsvar* @new_address_table()
%var10802 = bitcast [63 x i8]* @gsxtmmath440 to i8*
%var10803 = bitcast [56 x i8]* @gsxtmmath441 to i8*
%addytable10804 = call %clsvar* @add_address_table(%mzone* %zone10796, i8* %var10802, i32 0, i8* %var10803, i32 3, %clsvar* %addytable10801)
%address-table10805 = bitcast %clsvar* %addytable10804 to i8*

; insert table, function and environment into closure struct
%closure.table10808 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}* %closure10798, i32 0, i32 0
store i8* %address-table10805, i8** %closure.table10808
%closure.env10809 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}* %closure10798, i32 0, i32 1
store i8* %envptr10799, i8** %closure.env10809
%closure.func10810 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}* %closure10798, i32 0, i32 2
store void (i8*, i8*, %Complexf*, float*, i64)* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd__10775, void (i8*, i8*, %Complexf*, float*, i64)** %closure.func10810
%closure_size10811 = call i64 @llvm_zone_mark_size(%mzone* %zone10796)
call void @llvm_zone_ptr_set_size(i8* %clsptr10797, i64 %closure_size10811)
%wrapper_ptr10812 = call i8* @llvm_zone_malloc(%mzone* %zone10796, i64 8)
%closure_wrapper10813 = bitcast i8* %wrapper_ptr10812 to { i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}**
store { i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}* %closure10798, { i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}** %closure_wrapper10813

; let value assignment
%Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}** %closure_wrapper10813, { i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}** %closure_wrapper10813
store { i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}** %Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd, { i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}*** %Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRdPtr

; add data to environment
; don't need to alloc for env var Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd
%tmp_envptr10807 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}***}* %environment10800, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}*** %Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRdPtr, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}**** %tmp_envptr10807


%val10816 = load {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}**, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}*** %Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRdPtr
ret {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}** %val10816
}


@Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}** @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd(%Complexf* %arg_0,float* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, float*, i64)*,  void (i8*, i8*, %Complexf*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, float* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd_native(%Complexf* %arg_0,float* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, float*, i64)*,  void (i8*, i8*, %Complexf*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, float* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var10817 = bitcast [116 x i8]* @gsxtmmath442 to i8*
call i32 (i8*, ...) @printf(i8* %var10817)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexf*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var10818 = bitcast [116 x i8]* @gsxtmmath442 to i8*
call i32 (i8*, ...) @printf(i8* %var10818)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var10819 = bitcast [116 x i8]* @gsxtmmath442 to i8*
call i32 (i8*, ...) @printf(i8* %var10819)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, float*, i64)*,  void (i8*, i8*, %Complexf*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, float* %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexf*, float*, i64}*
%arg_p_0 = getelementptr {%Complexf*, float*, i64}, {%Complexf*, float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexf*, %Complexf** %arg_p_0
%arg_p_1 = getelementptr {%Complexf*, float*, i64}, {%Complexf*, float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {%Complexf*, float*, i64}, {%Complexf*, float*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGYqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexf*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexf*, float*, i64)*,  void (i8*, i8*, %Complexf*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexf* %arg_0, float* %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath443 = hidden constant [75 x i8] c"Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd\00"
@gsxtmmath444 = hidden constant [66 x i8] c"{i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}**\00"
define dllexport fastcc void @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd__10820(i8* %_impz,i8* %_impenv, %Complexd* %com, double* %re, double* %im, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10821 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}***}*
%Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}***}* %impenv, i32 0, i32 0
%Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRdPtr = load {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}***, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}**** %Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRdPtr_

; setup arguments
%comPtr = alloca %Complexd*
store %Complexd* %com, %Complexd** %comPtr
%rePtr = alloca double*
store double* %re, double** %rePtr
%imPtr = alloca double*
store double* %im, double** %imPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone10822 = load i8*, i8** %_impzPtr
%zone10823 = bitcast i8* %tzone10822 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val10826 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val10843 = load i64, i64* %iPtr
%num10844 = add i64 %val10826, %val10843
%comp10845 = icmp ult i64 %val10826, 1
br i1 %comp10845, label %after10824, label %loop10824

loop10824:
%val10827 = load i64, i64* %iPtr
%val10828 = load double*, double** %rePtr
%val10829 = load i64, i64* %iPtr
%val10830 = load %Complexd*, %Complexd** %comPtr
; pointer ref
%val10831 = getelementptr %Complexd, %Complexd* %val10830, i64 %val10829
; tuple ref
%val10832 = getelementptr %Complexd, %Complexd* %val10831, i64 0, i32 0
%val10833 = load double, double* %val10832
; set pointer
%val10834 = getelementptr double, double* %val10828, i64 %val10827
store double %val10833, double* %val10834
%val10835 = load i64, i64* %iPtr
%val10836 = load double*, double** %imPtr
%val10837 = load i64, i64* %iPtr
%val10838 = load %Complexd*, %Complexd** %comPtr
; pointer ref
%val10839 = getelementptr %Complexd, %Complexd* %val10838, i64 %val10837
; tuple ref
%val10840 = getelementptr %Complexd, %Complexd* %val10839, i64 0, i32 1
%val10841 = load double, double* %val10840
; set pointer
%val10842 = getelementptr double, double* %val10836, i64 %val10835
store double %val10841, double* %val10842
%loop_cnt10824 = load i64, i64* %iPtr
%next10824 = add i64 %loop_cnt10824, 1
store i64 %next10824, i64* %iPtr
%cmp10824 = icmp ult i64 %next10824, %num10844
br i1 %cmp10824, label %loop10824, label %after10824

after10824:
ret void
}
@gsxtmmath445 = hidden constant [128 x i8] c"Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}** @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10867 = load i8*, i8** %_impzPtr
%zone10868 = bitcast i8* %tzone10867 to %mzone*

; let assign value to symbol Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd
%dat_Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone10868, i64 8)
%Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRdPtr = bitcast i8* %dat_Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd to { i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}***
%tzone10848 = load i8*, i8** %_impzPtr
%zone10849 = bitcast i8* %tzone10848 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10849)
; malloc closure structure
%clsptr10850 = call i8* @llvm_zone_malloc(%mzone* %zone10849, i64 24)
%closure10851 = bitcast i8* %clsptr10850 to { i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}*

; malloc environment structure
%envptr10852 = call i8* @llvm_zone_malloc(%mzone* %zone10849, i64 8)
%environment10853 = bitcast i8* %envptr10852 to {{i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}***}*

; malloc closure address table
%addytable10854 = call %clsvar* @new_address_table()
%var10855 = bitcast [75 x i8]* @gsxtmmath443 to i8*
%var10856 = bitcast [66 x i8]* @gsxtmmath444 to i8*
%addytable10857 = call %clsvar* @add_address_table(%mzone* %zone10849, i8* %var10855, i32 0, i8* %var10856, i32 3, %clsvar* %addytable10854)
%address-table10858 = bitcast %clsvar* %addytable10857 to i8*

; insert table, function and environment into closure struct
%closure.table10861 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}* %closure10851, i32 0, i32 0
store i8* %address-table10858, i8** %closure.table10861
%closure.env10862 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}* %closure10851, i32 0, i32 1
store i8* %envptr10852, i8** %closure.env10862
%closure.func10863 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}* %closure10851, i32 0, i32 2
store void (i8*, i8*, %Complexd*, double*, double*, i64)* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd__10820, void (i8*, i8*, %Complexd*, double*, double*, i64)** %closure.func10863
%closure_size10864 = call i64 @llvm_zone_mark_size(%mzone* %zone10849)
call void @llvm_zone_ptr_set_size(i8* %clsptr10850, i64 %closure_size10864)
%wrapper_ptr10865 = call i8* @llvm_zone_malloc(%mzone* %zone10849, i64 8)
%closure_wrapper10866 = bitcast i8* %wrapper_ptr10865 to { i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}**
store { i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}* %closure10851, { i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}** %closure_wrapper10866

; let value assignment
%Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}** %closure_wrapper10866, { i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}** %closure_wrapper10866
store { i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}** %Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd, { i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}*** %Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRdPtr

; add data to environment
; don't need to alloc for env var Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd
%tmp_envptr10860 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}***}* %environment10853, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}*** %Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRdPtr, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}**** %tmp_envptr10860


%val10869 = load {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}**, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}*** %Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRdPtr
ret {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}** %val10869
}


@Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}** @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd(%Complexd* %arg_0,double* %arg_1,double* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, double*, double*, i64)*,  void (i8*, i8*, %Complexd*, double*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, double* %arg_1, double* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc void @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd_native(%Complexd* %arg_0,double* %arg_1,double* %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, double*, double*, i64)*,  void (i8*, i8*, %Complexd*, double*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, double* %arg_1, double* %arg_2, i64 %arg_3)
ret void
}


define dllexport ccc i8*  @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var10870 = bitcast [128 x i8]* @gsxtmmath445 to i8*
call i32 (i8*, ...) @printf(i8* %var10870)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexd*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var10871 = bitcast [128 x i8]* @gsxtmmath445 to i8*
call i32 (i8*, ...) @printf(i8* %var10871)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to double*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var10872 = bitcast [128 x i8]* @gsxtmmath445 to i8*
call i32 (i8*, ...) @printf(i8* %var10872)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to double*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var10873 = bitcast [128 x i8]* @gsxtmmath445 to i8*
call i32 (i8*, ...) @printf(i8* %var10873)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, double*, double*, i64)*,  void (i8*, i8*, %Complexd*, double*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, double* %arg_1, double* %arg_2, i64 %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd*, double*, double*, i64}*
%arg_p_0 = getelementptr {%Complexd*, double*, double*, i64}, {%Complexd*, double*, double*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd*, %Complexd** %arg_p_0
%arg_p_1 = getelementptr {%Complexd*, double*, double*, i64}, {%Complexd*, double*, double*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load double*, double** %arg_p_1
%arg_p_2 = getelementptr {%Complexd*, double*, double*, i64}, {%Complexd*, double*, double*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load double*, double** %arg_p_2
%arg_p_3 = getelementptr {%Complexd*, double*, double*, i64}, {%Complexd*, double*, double*, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosZG91YmxlKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, double*, double*, i64)*,  void (i8*, i8*, %Complexd*, double*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, double* %arg_1, double* %arg_2, i64 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath446 = hidden constant [65 x i8] c"Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ\00"
@gsxtmmath447 = hidden constant [57 x i8] c"{i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}**\00"
define dllexport fastcc void @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ__10874(i8* %_impz,i8* %_impenv, %Complexd* %com, double* %re, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10875 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}***}*
%Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}***}* %impenv, i32 0, i32 0
%Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}***, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}**** %Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQPtr_

; setup arguments
%comPtr = alloca %Complexd*
store %Complexd* %com, %Complexd** %comPtr
%rePtr = alloca double*
store double* %re, double** %rePtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone10876 = load i8*, i8** %_impzPtr
%zone10877 = bitcast i8* %tzone10876 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val10880 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val10889 = load i64, i64* %iPtr
%num10890 = add i64 %val10880, %val10889
%comp10891 = icmp ult i64 %val10880, 1
br i1 %comp10891, label %after10878, label %loop10878

loop10878:
%val10881 = load i64, i64* %iPtr
%val10882 = load double*, double** %rePtr
%val10883 = load i64, i64* %iPtr
%val10884 = load %Complexd*, %Complexd** %comPtr
; pointer ref
%val10885 = getelementptr %Complexd, %Complexd* %val10884, i64 %val10883
; tuple ref
%val10886 = getelementptr %Complexd, %Complexd* %val10885, i64 0, i32 0
%val10887 = load double, double* %val10886
; set pointer
%val10888 = getelementptr double, double* %val10882, i64 %val10881
store double %val10887, double* %val10888
%loop_cnt10878 = load i64, i64* %iPtr
%next10878 = add i64 %loop_cnt10878, 1
store i64 %next10878, i64* %iPtr
%cmp10878 = icmp ult i64 %next10878, %num10890
br i1 %cmp10878, label %loop10878, label %after10878

after10878:
ret void
}
@gsxtmmath448 = hidden constant [118 x i8] c"Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10913 = load i8*, i8** %_impzPtr
%zone10914 = bitcast i8* %tzone10913 to %mzone*

; let assign value to symbol Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ
%dat_Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone10914, i64 8)
%Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQPtr = bitcast i8* %dat_Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ to { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}***
%tzone10894 = load i8*, i8** %_impzPtr
%zone10895 = bitcast i8* %tzone10894 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10895)
; malloc closure structure
%clsptr10896 = call i8* @llvm_zone_malloc(%mzone* %zone10895, i64 24)
%closure10897 = bitcast i8* %clsptr10896 to { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}*

; malloc environment structure
%envptr10898 = call i8* @llvm_zone_malloc(%mzone* %zone10895, i64 8)
%environment10899 = bitcast i8* %envptr10898 to {{i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}***}*

; malloc closure address table
%addytable10900 = call %clsvar* @new_address_table()
%var10901 = bitcast [65 x i8]* @gsxtmmath446 to i8*
%var10902 = bitcast [57 x i8]* @gsxtmmath447 to i8*
%addytable10903 = call %clsvar* @add_address_table(%mzone* %zone10895, i8* %var10901, i32 0, i8* %var10902, i32 3, %clsvar* %addytable10900)
%address-table10904 = bitcast %clsvar* %addytable10903 to i8*

; insert table, function and environment into closure struct
%closure.table10907 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure10897, i32 0, i32 0
store i8* %address-table10904, i8** %closure.table10907
%closure.env10908 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure10897, i32 0, i32 1
store i8* %envptr10898, i8** %closure.env10908
%closure.func10909 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure10897, i32 0, i32 2
store void (i8*, i8*, %Complexd*, double*, i64)* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ__10874, void (i8*, i8*, %Complexd*, double*, i64)** %closure.func10909
%closure_size10910 = call i64 @llvm_zone_mark_size(%mzone* %zone10895)
call void @llvm_zone_ptr_set_size(i8* %clsptr10896, i64 %closure_size10910)
%wrapper_ptr10911 = call i8* @llvm_zone_malloc(%mzone* %zone10895, i64 8)
%closure_wrapper10912 = bitcast i8* %wrapper_ptr10911 to { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}**
store { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure10897, { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** %closure_wrapper10912

; let value assignment
%Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** %closure_wrapper10912, { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** %closure_wrapper10912
store { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** %Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ, { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}*** %Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQPtr

; add data to environment
; don't need to alloc for env var Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ
%tmp_envptr10906 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}***}* %environment10899, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}*** %Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQPtr, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}**** %tmp_envptr10906


%val10915 = load {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}**, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}*** %Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** %val10915
}


@Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ(%Complexd* %arg_0,double* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, double*, i64)*,  void (i8*, i8*, %Complexd*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, double* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_native(%Complexd* %arg_0,double* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, double*, i64)*,  void (i8*, i8*, %Complexd*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, double* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var10916 = bitcast [118 x i8]* @gsxtmmath448 to i8*
call i32 (i8*, ...) @printf(i8* %var10916)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexd*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var10917 = bitcast [118 x i8]* @gsxtmmath448 to i8*
call i32 (i8*, ...) @printf(i8* %var10917)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to double*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var10918 = bitcast [118 x i8]* @gsxtmmath448 to i8*
call i32 (i8*, ...) @printf(i8* %var10918)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, double*, i64)*,  void (i8*, i8*, %Complexd*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, double* %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd*, double*, i64}*
%arg_p_0 = getelementptr {%Complexd*, double*, i64}, {%Complexd*, double*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd*, %Complexd** %arg_p_0
%arg_p_1 = getelementptr {%Complexd*, double*, i64}, {%Complexd*, double*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load double*, double** %arg_p_1
%arg_p_2 = getelementptr {%Complexd*, double*, i64}, {%Complexd*, double*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Complex_unbufferize_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, double*, i64)*,  void (i8*, i8*, %Complexd*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, double* %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%HistBin = type {float,float}
@gsxtmmath449 = hidden constant [45 x i8] c"HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ\00"
@gsxtmmath450 = hidden constant [50 x i8] c"{i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**\00"
define dllexport fastcc %HistBin* @HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ__10919(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10920 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***}*
%HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***}, {{i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***}* %impenv, i32 0, i32 0
%HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**** %HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr


%tzone10925 = load i8*, i8** %_impzPtr
%zone10926 = bitcast i8* %tzone10925 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %HistBin*
%tzone10921 = load i8*, i8** %_impzPtr
%zone10922 = bitcast i8* %tzone10921 to %mzone*
%dat10923 = call i8* @llvm_zone_malloc(%mzone* %zone10922, i64 8)
call i8* @memset(i8* %dat10923, i32 0, i64 8)
%val10924 = bitcast i8* %dat10923 to %HistBin*

; let value assignment
%obj = select i1 true, %HistBin* %val10924, %HistBin* %val10924
store %HistBin* %obj, %HistBin** %objPtr

%val10927 = load %HistBin*, %HistBin** %objPtr
%val10928 = load float, float* %arg_0Ptr
; set tuple
%val10929 = getelementptr %HistBin, %HistBin* %val10927, i64 0, i32 0
store float %val10928, float* %val10929
%val10930 = load %HistBin*, %HistBin** %objPtr
%val10931 = load float, float* %arg_1Ptr
; set tuple
%val10932 = getelementptr %HistBin, %HistBin* %val10930, i64 0, i32 1
store float %val10931, float* %val10932
%val10933 = load %HistBin*, %HistBin** %objPtr
ret %HistBin* %val10933
}
@gsxtmmath451 = hidden constant [98 x i8] c"HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** @HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10953 = load i8*, i8** %_impzPtr
%zone10954 = bitcast i8* %tzone10953 to %mzone*

; let assign value to symbol HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ
%dat_HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone10954, i64 8)
%HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ to { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***
%tzone10934 = load i8*, i8** %_impzPtr
%zone10935 = bitcast i8* %tzone10934 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10935)
; malloc closure structure
%clsptr10936 = call i8* @llvm_zone_malloc(%mzone* %zone10935, i64 24)
%closure10937 = bitcast i8* %clsptr10936 to { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*

; malloc environment structure
%envptr10938 = call i8* @llvm_zone_malloc(%mzone* %zone10935, i64 8)
%environment10939 = bitcast i8* %envptr10938 to {{i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***}*

; malloc closure address table
%addytable10940 = call %clsvar* @new_address_table()
%var10941 = bitcast [45 x i8]* @gsxtmmath449 to i8*
%var10942 = bitcast [50 x i8]* @gsxtmmath450 to i8*
%addytable10943 = call %clsvar* @add_address_table(%mzone* %zone10935, i8* %var10941, i32 0, i8* %var10942, i32 3, %clsvar* %addytable10940)
%address-table10944 = bitcast %clsvar* %addytable10943 to i8*

; insert table, function and environment into closure struct
%closure.table10947 = getelementptr { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure10937, i32 0, i32 0
store i8* %address-table10944, i8** %closure.table10947
%closure.env10948 = getelementptr { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure10937, i32 0, i32 1
store i8* %envptr10938, i8** %closure.env10948
%closure.func10949 = getelementptr { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure10937, i32 0, i32 2
store %HistBin* (i8*, i8*, float, float)* @HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ__10919, %HistBin* (i8*, i8*, float, float)** %closure.func10949
%closure_size10950 = call i64 @llvm_zone_mark_size(%mzone* %zone10935)
call void @llvm_zone_ptr_set_size(i8* %clsptr10936, i64 %closure_size10950)
%wrapper_ptr10951 = call i8* @llvm_zone_malloc(%mzone* %zone10935, i64 8)
%closure_wrapper10952 = bitcast i8* %wrapper_ptr10951 to { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**
store { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure10937, { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure_wrapper10952

; let value assignment
%HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure_wrapper10952, { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure_wrapper10952
store { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ, { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*** %HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ
%tmp_envptr10946 = getelementptr {{i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***}, {{i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***}* %environment10939, i32 0, i32 0
store {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*** %HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**** %tmp_envptr10946


%val10955 = load {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*** %HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %val10955
}


@HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** @HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %HistBin* @HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, float, float)*,  %HistBin* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %HistBin* %result
}


define dllexport ccc %HistBin* @HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_native(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, float, float)*,  %HistBin* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %HistBin* %result
}


define dllexport ccc i8*  @HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var10956 = bitcast [98 x i8]* @gsxtmmath451 to i8*
call i32 (i8*, ...) @printf(i8* %var10956)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var10957 = bitcast [98 x i8]* @gsxtmmath451 to i8*
call i32 (i8*, ...) @printf(i8* %var10957)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, float, float)*,  %HistBin* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%tmpres = bitcast %HistBin* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float}*
%arg_p_0 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @HistBin_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, float, float)*,  %HistBin* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath452 = hidden constant [47 x i8] c"HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ\00"
define dllexport fastcc %HistBin* @HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ__10958(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10959 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***}*
%HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***}, {{i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***}* %impenv, i32 0, i32 0
%HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**** %HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr


%tzone10964 = load i8*, i8** %_impzPtr
%zone10965 = bitcast i8* %tzone10964 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %HistBin*
%tzone10960 = load i8*, i8** %_impzPtr
%zone10961 = bitcast i8* %tzone10960 to %mzone*
%dat10962 = call i8* @llvm_zone_malloc(%mzone* %zone10961, i64 8)
call i8* @memset(i8* %dat10962, i32 0, i64 8)
%val10963 = bitcast i8* %dat10962 to %HistBin*

; let value assignment
%obj = select i1 true, %HistBin* %val10963, %HistBin* %val10963
store %HistBin* %obj, %HistBin** %objPtr

%val10966 = load %HistBin*, %HistBin** %objPtr
%val10967 = load float, float* %arg_0Ptr
; set tuple
%val10968 = getelementptr %HistBin, %HistBin* %val10966, i64 0, i32 0
store float %val10967, float* %val10968
%val10969 = load %HistBin*, %HistBin** %objPtr
%val10970 = load float, float* %arg_1Ptr
; set tuple
%val10971 = getelementptr %HistBin, %HistBin* %val10969, i64 0, i32 1
store float %val10970, float* %val10971
%val10972 = load %HistBin*, %HistBin** %objPtr
ret %HistBin* %val10972
}
@gsxtmmath453 = hidden constant [100 x i8] c"HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** @HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10992 = load i8*, i8** %_impzPtr
%zone10993 = bitcast i8* %tzone10992 to %mzone*

; let assign value to symbol HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ
%dat_HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone10993, i64 8)
%HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ to { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***
%tzone10973 = load i8*, i8** %_impzPtr
%zone10974 = bitcast i8* %tzone10973 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10974)
; malloc closure structure
%clsptr10975 = call i8* @llvm_zone_malloc(%mzone* %zone10974, i64 24)
%closure10976 = bitcast i8* %clsptr10975 to { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*

; malloc environment structure
%envptr10977 = call i8* @llvm_zone_malloc(%mzone* %zone10974, i64 8)
%environment10978 = bitcast i8* %envptr10977 to {{i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***}*

; malloc closure address table
%addytable10979 = call %clsvar* @new_address_table()
%var10980 = bitcast [47 x i8]* @gsxtmmath452 to i8*
%var10981 = bitcast [50 x i8]* @gsxtmmath450 to i8*
%addytable10982 = call %clsvar* @add_address_table(%mzone* %zone10974, i8* %var10980, i32 0, i8* %var10981, i32 3, %clsvar* %addytable10979)
%address-table10983 = bitcast %clsvar* %addytable10982 to i8*

; insert table, function and environment into closure struct
%closure.table10986 = getelementptr { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure10976, i32 0, i32 0
store i8* %address-table10983, i8** %closure.table10986
%closure.env10987 = getelementptr { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure10976, i32 0, i32 1
store i8* %envptr10977, i8** %closure.env10987
%closure.func10988 = getelementptr { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure10976, i32 0, i32 2
store %HistBin* (i8*, i8*, float, float)* @HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ__10958, %HistBin* (i8*, i8*, float, float)** %closure.func10988
%closure_size10989 = call i64 @llvm_zone_mark_size(%mzone* %zone10974)
call void @llvm_zone_ptr_set_size(i8* %clsptr10975, i64 %closure_size10989)
%wrapper_ptr10990 = call i8* @llvm_zone_malloc(%mzone* %zone10974, i64 8)
%closure_wrapper10991 = bitcast i8* %wrapper_ptr10990 to { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**
store { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure10976, { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure_wrapper10991

; let value assignment
%HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure_wrapper10991, { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure_wrapper10991
store { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ, { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*** %HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ
%tmp_envptr10985 = getelementptr {{i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***}, {{i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***}* %environment10978, i32 0, i32 0
store {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*** %HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**** %tmp_envptr10985


%val10994 = load {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*** %HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %val10994
}


@HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** @HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %HistBin* @HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, float, float)*,  %HistBin* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %HistBin* %result
}


define dllexport ccc %HistBin* @HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_native(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, float, float)*,  %HistBin* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %HistBin* %result
}


define dllexport ccc i8*  @HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var10995 = bitcast [100 x i8]* @gsxtmmath453 to i8*
call i32 (i8*, ...) @printf(i8* %var10995)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var10996 = bitcast [100 x i8]* @gsxtmmath453 to i8*
call i32 (i8*, ...) @printf(i8* %var10996)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, float, float)*,  %HistBin* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%tmpres = bitcast %HistBin* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float}*
%arg_p_0 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @HistBin_z_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, float, float)*,  %HistBin* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath454 = hidden constant [47 x i8] c"HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ\00"
define dllexport fastcc %HistBin* @HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ__10997(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10998 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***}*
%HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***}, {{i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***}* %impenv, i32 0, i32 0
%HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**** %HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr


%tzone11001 = load i8*, i8** %_impzPtr
%zone11002 = bitcast i8* %tzone11001 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %HistBin*
%dat10999 = call i8* @malloc(i64 8)
call i8* @memset(i8* %dat10999, i32 0, i64 8)
%val11000 = bitcast i8* %dat10999 to %HistBin*

; let value assignment
%obj = select i1 true, %HistBin* %val11000, %HistBin* %val11000
store %HistBin* %obj, %HistBin** %objPtr

%val11003 = load %HistBin*, %HistBin** %objPtr
%val11004 = load float, float* %arg_0Ptr
; set tuple
%val11005 = getelementptr %HistBin, %HistBin* %val11003, i64 0, i32 0
store float %val11004, float* %val11005
%val11006 = load %HistBin*, %HistBin** %objPtr
%val11007 = load float, float* %arg_1Ptr
; set tuple
%val11008 = getelementptr %HistBin, %HistBin* %val11006, i64 0, i32 1
store float %val11007, float* %val11008
%val11009 = load %HistBin*, %HistBin** %objPtr
ret %HistBin* %val11009
}
@gsxtmmath455 = hidden constant [100 x i8] c"HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** @HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11029 = load i8*, i8** %_impzPtr
%zone11030 = bitcast i8* %tzone11029 to %mzone*

; let assign value to symbol HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ
%dat_HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone11030, i64 8)
%HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ to { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***
%tzone11010 = load i8*, i8** %_impzPtr
%zone11011 = bitcast i8* %tzone11010 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11011)
; malloc closure structure
%clsptr11012 = call i8* @llvm_zone_malloc(%mzone* %zone11011, i64 24)
%closure11013 = bitcast i8* %clsptr11012 to { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*

; malloc environment structure
%envptr11014 = call i8* @llvm_zone_malloc(%mzone* %zone11011, i64 8)
%environment11015 = bitcast i8* %envptr11014 to {{i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***}*

; malloc closure address table
%addytable11016 = call %clsvar* @new_address_table()
%var11017 = bitcast [47 x i8]* @gsxtmmath454 to i8*
%var11018 = bitcast [50 x i8]* @gsxtmmath450 to i8*
%addytable11019 = call %clsvar* @add_address_table(%mzone* %zone11011, i8* %var11017, i32 0, i8* %var11018, i32 3, %clsvar* %addytable11016)
%address-table11020 = bitcast %clsvar* %addytable11019 to i8*

; insert table, function and environment into closure struct
%closure.table11023 = getelementptr { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure11013, i32 0, i32 0
store i8* %address-table11020, i8** %closure.table11023
%closure.env11024 = getelementptr { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure11013, i32 0, i32 1
store i8* %envptr11014, i8** %closure.env11024
%closure.func11025 = getelementptr { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure11013, i32 0, i32 2
store %HistBin* (i8*, i8*, float, float)* @HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ__10997, %HistBin* (i8*, i8*, float, float)** %closure.func11025
%closure_size11026 = call i64 @llvm_zone_mark_size(%mzone* %zone11011)
call void @llvm_zone_ptr_set_size(i8* %clsptr11012, i64 %closure_size11026)
%wrapper_ptr11027 = call i8* @llvm_zone_malloc(%mzone* %zone11011, i64 8)
%closure_wrapper11028 = bitcast i8* %wrapper_ptr11027 to { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**
store { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure11013, { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure_wrapper11028

; let value assignment
%HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure_wrapper11028, { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure_wrapper11028
store { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ, { i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*** %HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ
%tmp_envptr11022 = getelementptr {{i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***}, {{i8*, i8*, %HistBin* (i8*, i8*, float, float)*}***}* %environment11015, i32 0, i32 0
store {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*** %HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**** %tmp_envptr11022


%val11031 = load {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*** %HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %val11031
}


@HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** @HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %HistBin* @HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, float, float)*,  %HistBin* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %HistBin* %result
}


define dllexport ccc %HistBin* @HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_native(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, float, float)*,  %HistBin* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %HistBin* %result
}


define dllexport ccc i8*  @HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11032 = bitcast [100 x i8]* @gsxtmmath455 to i8*
call i32 (i8*, ...) @printf(i8* %var11032)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var11033 = bitcast [100 x i8]* @gsxtmmath455 to i8*
call i32 (i8*, ...) @printf(i8* %var11033)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, float, float)*,  %HistBin* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%tmpres = bitcast %HistBin* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float}*
%arg_p_0 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @HistBin_h_adhoc_W0hpc3RCaW4qLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}*, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, float, float)*,  %HistBin* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath456 = hidden constant [47 x i8] c"HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd\00"
@gsxtmmath457 = hidden constant [49 x i8] c"{i8*, i8*, %HistBin (i8*, i8*, float, float)*}**\00"
define dllexport fastcc %HistBin @HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd__11034(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11035 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %HistBin (i8*, i8*, float, float)*}***}*
%HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, %HistBin (i8*, i8*, float, float)*}***}, {{i8*, i8*, %HistBin (i8*, i8*, float, float)*}***}* %impenv, i32 0, i32 0
%HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRdPtr = load {i8*, i8*, %HistBin (i8*, i8*, float, float)*}***, {i8*, i8*, %HistBin (i8*, i8*, float, float)*}**** %HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRdPtr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr


%tzone11037 = load i8*, i8** %_impzPtr
%zone11038 = bitcast i8* %tzone11037 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %HistBin*
%dat11036 = alloca %HistBin, align 16

; let value assignment
%obj = select i1 true, %HistBin* %dat11036, %HistBin* %dat11036
store %HistBin* %obj, %HistBin** %objPtr

%val11039 = load %HistBin*, %HistBin** %objPtr
%val11040 = load float, float* %arg_0Ptr
; set tuple
%val11041 = getelementptr %HistBin, %HistBin* %val11039, i64 0, i32 0
store float %val11040, float* %val11041
%val11042 = load %HistBin*, %HistBin** %objPtr
%val11043 = load float, float* %arg_1Ptr
; set tuple
%val11044 = getelementptr %HistBin, %HistBin* %val11042, i64 0, i32 1
store float %val11043, float* %val11044
%val11045 = load %HistBin*, %HistBin** %objPtr
; pointer ref
%val11046 = getelementptr %HistBin, %HistBin* %val11045, i64 0
%val11047 = load %HistBin, %HistBin* %val11046
ret %HistBin %val11047
}
@gsxtmmath458 = hidden constant [100 x i8] c"HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %HistBin (i8*, i8*, float, float)*}** @HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11067 = load i8*, i8** %_impzPtr
%zone11068 = bitcast i8* %tzone11067 to %mzone*

; let assign value to symbol HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd
%dat_HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone11068, i64 8)
%HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRdPtr = bitcast i8* %dat_HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd to { i8*, i8*, %HistBin (i8*, i8*, float, float)*}***
%tzone11048 = load i8*, i8** %_impzPtr
%zone11049 = bitcast i8* %tzone11048 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11049)
; malloc closure structure
%clsptr11050 = call i8* @llvm_zone_malloc(%mzone* %zone11049, i64 24)
%closure11051 = bitcast i8* %clsptr11050 to { i8*, i8*, %HistBin (i8*, i8*, float, float)*}*

; malloc environment structure
%envptr11052 = call i8* @llvm_zone_malloc(%mzone* %zone11049, i64 8)
%environment11053 = bitcast i8* %envptr11052 to {{i8*, i8*, %HistBin (i8*, i8*, float, float)*}***}*

; malloc closure address table
%addytable11054 = call %clsvar* @new_address_table()
%var11055 = bitcast [47 x i8]* @gsxtmmath456 to i8*
%var11056 = bitcast [49 x i8]* @gsxtmmath457 to i8*
%addytable11057 = call %clsvar* @add_address_table(%mzone* %zone11049, i8* %var11055, i32 0, i8* %var11056, i32 3, %clsvar* %addytable11054)
%address-table11058 = bitcast %clsvar* %addytable11057 to i8*

; insert table, function and environment into closure struct
%closure.table11061 = getelementptr { i8*, i8*, %HistBin (i8*, i8*, float, float)*}, { i8*, i8*, %HistBin (i8*, i8*, float, float)*}* %closure11051, i32 0, i32 0
store i8* %address-table11058, i8** %closure.table11061
%closure.env11062 = getelementptr { i8*, i8*, %HistBin (i8*, i8*, float, float)*}, { i8*, i8*, %HistBin (i8*, i8*, float, float)*}* %closure11051, i32 0, i32 1
store i8* %envptr11052, i8** %closure.env11062
%closure.func11063 = getelementptr { i8*, i8*, %HistBin (i8*, i8*, float, float)*}, { i8*, i8*, %HistBin (i8*, i8*, float, float)*}* %closure11051, i32 0, i32 2
store %HistBin (i8*, i8*, float, float)* @HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd__11034, %HistBin (i8*, i8*, float, float)** %closure.func11063
%closure_size11064 = call i64 @llvm_zone_mark_size(%mzone* %zone11049)
call void @llvm_zone_ptr_set_size(i8* %clsptr11050, i64 %closure_size11064)
%wrapper_ptr11065 = call i8* @llvm_zone_malloc(%mzone* %zone11049, i64 8)
%closure_wrapper11066 = bitcast i8* %wrapper_ptr11065 to { i8*, i8*, %HistBin (i8*, i8*, float, float)*}**
store { i8*, i8*, %HistBin (i8*, i8*, float, float)*}* %closure11051, { i8*, i8*, %HistBin (i8*, i8*, float, float)*}** %closure_wrapper11066

; let value assignment
%HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd = select i1 true, { i8*, i8*, %HistBin (i8*, i8*, float, float)*}** %closure_wrapper11066, { i8*, i8*, %HistBin (i8*, i8*, float, float)*}** %closure_wrapper11066
store { i8*, i8*, %HistBin (i8*, i8*, float, float)*}** %HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd, { i8*, i8*, %HistBin (i8*, i8*, float, float)*}*** %HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd
%tmp_envptr11060 = getelementptr {{i8*, i8*, %HistBin (i8*, i8*, float, float)*}***}, {{i8*, i8*, %HistBin (i8*, i8*, float, float)*}***}* %environment11053, i32 0, i32 0
store {i8*, i8*, %HistBin (i8*, i8*, float, float)*}*** %HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRdPtr, {i8*, i8*, %HistBin (i8*, i8*, float, float)*}**** %tmp_envptr11060


%val11069 = load {i8*, i8*, %HistBin (i8*, i8*, float, float)*}**, {i8*, i8*, %HistBin (i8*, i8*, float, float)*}*** %HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRdPtr
ret {i8*, i8*, %HistBin (i8*, i8*, float, float)*}** %val11069
}


@HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %HistBin (i8*, i8*, float, float)*}** @HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %HistBin (i8*, i8*, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %HistBin @HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %HistBin (i8*, i8*, float, float)*}*, {i8*, i8*, %HistBin (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %HistBin (i8*, i8*, float, float)*,  %HistBin (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %HistBin %result
}


define dllexport ccc %HistBin @HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd_native(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %HistBin (i8*, i8*, float, float)*}*, {i8*, i8*, %HistBin (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %HistBin (i8*, i8*, float, float)*,  %HistBin (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %HistBin %result
}


define dllexport ccc void @HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float}*
%arg_p_0 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @HistBin_val_adhoc_W0hpc3RCaW4sZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %HistBin (i8*, i8*, float, float)*}*, {i8*, i8*, %HistBin (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin (i8*, i8*, float, float)*}, {i8*, i8*, %HistBin (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %HistBin (i8*, i8*, float, float)*,  %HistBin (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath459 = hidden constant [39 x i8] c"hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ\00"
@gsxtmmath460 = hidden constant [47 x i8] c"{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}**\00"
define dllexport fastcc %HistBin* @hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ__11072(i8* %_impz,i8* %_impenv, %HistBin* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11073 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}***}*
%hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQPtr_ = getelementptr {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}***}, {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQPtr = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}***, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}**** %hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQPtr_

; setup arguments
%xPtr = alloca %HistBin*
store %HistBin* %x, %HistBin** %xPtr


%tzone11076 = load i8*, i8** %_impzPtr
%zone11077 = bitcast i8* %tzone11076 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %HistBin*
%dat11074 = call i8* @malloc(i64 8)
call i8* @memset(i8* %dat11074, i32 0, i64 8)
%val11075 = bitcast i8* %dat11074 to %HistBin*

; let value assignment
%obj = select i1 true, %HistBin* %val11075, %HistBin* %val11075
store %HistBin* %obj, %HistBin** %objPtr

%val11078 = load %HistBin*, %HistBin** %objPtr
%val11079 = load %HistBin*, %HistBin** %xPtr
; tuple ref
%val11080 = getelementptr %HistBin, %HistBin* %val11079, i64 0, i32 0
%val11081 = load float, float* %val11080
; set tuple
%val11082 = getelementptr %HistBin, %HistBin* %val11078, i64 0, i32 0
store float %val11081, float* %val11082
%val11083 = load %HistBin*, %HistBin** %objPtr
%val11084 = load %HistBin*, %HistBin** %xPtr
; tuple ref
%val11085 = getelementptr %HistBin, %HistBin* %val11084, i64 0, i32 1
%val11086 = load float, float* %val11085
; set tuple
%val11087 = getelementptr %HistBin, %HistBin* %val11083, i64 0, i32 1
store float %val11086, float* %val11087
%val11088 = load %HistBin*, %HistBin** %objPtr
ret %HistBin* %val11088
}
@gsxtmmath461 = hidden constant [92 x i8] c"hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}** @hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11108 = load i8*, i8** %_impzPtr
%zone11109 = bitcast i8* %tzone11108 to %mzone*

; let assign value to symbol hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ
%dat_hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ = call i8* @llvm_zone_malloc(%mzone* %zone11109, i64 8)
%hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQPtr = bitcast i8* %dat_hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ to { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}***
%tzone11089 = load i8*, i8** %_impzPtr
%zone11090 = bitcast i8* %tzone11089 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11090)
; malloc closure structure
%clsptr11091 = call i8* @llvm_zone_malloc(%mzone* %zone11090, i64 24)
%closure11092 = bitcast i8* %clsptr11091 to { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}*

; malloc environment structure
%envptr11093 = call i8* @llvm_zone_malloc(%mzone* %zone11090, i64 8)
%environment11094 = bitcast i8* %envptr11093 to {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}***}*

; malloc closure address table
%addytable11095 = call %clsvar* @new_address_table()
%var11096 = bitcast [39 x i8]* @gsxtmmath459 to i8*
%var11097 = bitcast [47 x i8]* @gsxtmmath460 to i8*
%addytable11098 = call %clsvar* @add_address_table(%mzone* %zone11090, i8* %var11096, i32 0, i8* %var11097, i32 3, %clsvar* %addytable11095)
%address-table11099 = bitcast %clsvar* %addytable11098 to i8*

; insert table, function and environment into closure struct
%closure.table11102 = getelementptr { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}* %closure11092, i32 0, i32 0
store i8* %address-table11099, i8** %closure.table11102
%closure.env11103 = getelementptr { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}* %closure11092, i32 0, i32 1
store i8* %envptr11093, i8** %closure.env11103
%closure.func11104 = getelementptr { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}* %closure11092, i32 0, i32 2
store %HistBin* (i8*, i8*, %HistBin*)* @hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ__11072, %HistBin* (i8*, i8*, %HistBin*)** %closure.func11104
%closure_size11105 = call i64 @llvm_zone_mark_size(%mzone* %zone11090)
call void @llvm_zone_ptr_set_size(i8* %clsptr11091, i64 %closure_size11105)
%wrapper_ptr11106 = call i8* @llvm_zone_malloc(%mzone* %zone11090, i64 8)
%closure_wrapper11107 = bitcast i8* %wrapper_ptr11106 to { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}**
store { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}* %closure11092, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}** %closure_wrapper11107

; let value assignment
%hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ = select i1 true, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}** %closure_wrapper11107, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}** %closure_wrapper11107
store { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}** %hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}*** %hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ
%tmp_envptr11101 = getelementptr {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}***}, {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}***}* %environment11094, i32 0, i32 0
store {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}*** %hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQPtr, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}**** %tmp_envptr11101


%val11110 = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}**, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}*** %hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQPtr
ret {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}** %val11110
}


@hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}** @hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %HistBin* @hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ(%HistBin* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}*, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, %HistBin*)*,  %HistBin* (i8*, i8*, %HistBin*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0)
ret %HistBin* %result
}


define dllexport ccc %HistBin* @hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ_native(%HistBin* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}*, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, %HistBin*)*,  %HistBin* (i8*, i8*, %HistBin*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0)
ret %HistBin* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11111 = bitcast [92 x i8]* @gsxtmmath461 to i8*
call i32 (i8*, ...) @printf(i8* %var11111)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %HistBin*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}*, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, %HistBin*)*,  %HistBin* (i8*, i8*, %HistBin*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0)
%tmpres = bitcast %HistBin* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%HistBin*}*
%arg_p_0 = getelementptr {%HistBin*}, {%HistBin*}* %fstruct, i32 0, i32 0
%arg_0 = load %HistBin*, %HistBin** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}*, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, %HistBin*)*,  %HistBin* (i8*, i8*, %HistBin*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath462 = hidden constant [33 x i8] c"hfree_adhoc_W3ZvaWQsSGlzdEJpbipd\00"
@gsxtmmath463 = hidden constant [42 x i8] c"{i8*, i8*, void (i8*, i8*, %HistBin*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsSGlzdEJpbipd__11112(i8* %_impz,i8* %_impenv, %HistBin* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11113 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %HistBin*)*}***}*
%hfree_adhoc_W3ZvaWQsSGlzdEJpbipdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %HistBin*)*}***}, {{i8*, i8*, void (i8*, i8*, %HistBin*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsSGlzdEJpbipdPtr = load {i8*, i8*, void (i8*, i8*, %HistBin*)*}***, {i8*, i8*, void (i8*, i8*, %HistBin*)*}**** %hfree_adhoc_W3ZvaWQsSGlzdEJpbipdPtr_

; setup arguments
%xPtr = alloca %HistBin*
store %HistBin* %x, %HistBin** %xPtr


%val11114 = load %HistBin*, %HistBin** %xPtr
%val11115 = bitcast %HistBin* %val11114 to i8*
call ccc void @free(i8* %val11115)
ret void
}
@gsxtmmath464 = hidden constant [86 x i8] c"hfree_adhoc_W3ZvaWQsSGlzdEJpbipd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %HistBin*)*}** @hfree_adhoc_W3ZvaWQsSGlzdEJpbipd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11137 = load i8*, i8** %_impzPtr
%zone11138 = bitcast i8* %tzone11137 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsSGlzdEJpbipd
%dat_hfree_adhoc_W3ZvaWQsSGlzdEJpbipd = call i8* @llvm_zone_malloc(%mzone* %zone11138, i64 8)
%hfree_adhoc_W3ZvaWQsSGlzdEJpbipdPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsSGlzdEJpbipd to { i8*, i8*, void (i8*, i8*, %HistBin*)*}***
%tzone11118 = load i8*, i8** %_impzPtr
%zone11119 = bitcast i8* %tzone11118 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11119)
; malloc closure structure
%clsptr11120 = call i8* @llvm_zone_malloc(%mzone* %zone11119, i64 24)
%closure11121 = bitcast i8* %clsptr11120 to { i8*, i8*, void (i8*, i8*, %HistBin*)*}*

; malloc environment structure
%envptr11122 = call i8* @llvm_zone_malloc(%mzone* %zone11119, i64 8)
%environment11123 = bitcast i8* %envptr11122 to {{i8*, i8*, void (i8*, i8*, %HistBin*)*}***}*

; malloc closure address table
%addytable11124 = call %clsvar* @new_address_table()
%var11125 = bitcast [33 x i8]* @gsxtmmath462 to i8*
%var11126 = bitcast [42 x i8]* @gsxtmmath463 to i8*
%addytable11127 = call %clsvar* @add_address_table(%mzone* %zone11119, i8* %var11125, i32 0, i8* %var11126, i32 3, %clsvar* %addytable11124)
%address-table11128 = bitcast %clsvar* %addytable11127 to i8*

; insert table, function and environment into closure struct
%closure.table11131 = getelementptr { i8*, i8*, void (i8*, i8*, %HistBin*)*}, { i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure11121, i32 0, i32 0
store i8* %address-table11128, i8** %closure.table11131
%closure.env11132 = getelementptr { i8*, i8*, void (i8*, i8*, %HistBin*)*}, { i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure11121, i32 0, i32 1
store i8* %envptr11122, i8** %closure.env11132
%closure.func11133 = getelementptr { i8*, i8*, void (i8*, i8*, %HistBin*)*}, { i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure11121, i32 0, i32 2
store void (i8*, i8*, %HistBin*)* @hfree_adhoc_W3ZvaWQsSGlzdEJpbipd__11112, void (i8*, i8*, %HistBin*)** %closure.func11133
%closure_size11134 = call i64 @llvm_zone_mark_size(%mzone* %zone11119)
call void @llvm_zone_ptr_set_size(i8* %clsptr11120, i64 %closure_size11134)
%wrapper_ptr11135 = call i8* @llvm_zone_malloc(%mzone* %zone11119, i64 8)
%closure_wrapper11136 = bitcast i8* %wrapper_ptr11135 to { i8*, i8*, void (i8*, i8*, %HistBin*)*}**
store { i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure11121, { i8*, i8*, void (i8*, i8*, %HistBin*)*}** %closure_wrapper11136

; let value assignment
%hfree_adhoc_W3ZvaWQsSGlzdEJpbipd = select i1 true, { i8*, i8*, void (i8*, i8*, %HistBin*)*}** %closure_wrapper11136, { i8*, i8*, void (i8*, i8*, %HistBin*)*}** %closure_wrapper11136
store { i8*, i8*, void (i8*, i8*, %HistBin*)*}** %hfree_adhoc_W3ZvaWQsSGlzdEJpbipd, { i8*, i8*, void (i8*, i8*, %HistBin*)*}*** %hfree_adhoc_W3ZvaWQsSGlzdEJpbipdPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsSGlzdEJpbipd
%tmp_envptr11130 = getelementptr {{i8*, i8*, void (i8*, i8*, %HistBin*)*}***}, {{i8*, i8*, void (i8*, i8*, %HistBin*)*}***}* %environment11123, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %HistBin*)*}*** %hfree_adhoc_W3ZvaWQsSGlzdEJpbipdPtr, {i8*, i8*, void (i8*, i8*, %HistBin*)*}**** %tmp_envptr11130


%val11139 = load {i8*, i8*, void (i8*, i8*, %HistBin*)*}**, {i8*, i8*, void (i8*, i8*, %HistBin*)*}*** %hfree_adhoc_W3ZvaWQsSGlzdEJpbipdPtr
ret {i8*, i8*, void (i8*, i8*, %HistBin*)*}** %val11139
}


@hfree_adhoc_W3ZvaWQsSGlzdEJpbipd_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsSGlzdEJpbipd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsSGlzdEJpbipd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsSGlzdEJpbipd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %HistBin*)*}** @hfree_adhoc_W3ZvaWQsSGlzdEJpbipd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %HistBin*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsSGlzdEJpbipd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsSGlzdEJpbipd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsSGlzdEJpbipd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsSGlzdEJpbipd(%HistBin* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsSGlzdEJpbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %HistBin*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %HistBin*)*}*, {i8*, i8*, void (i8*, i8*, %HistBin*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %HistBin*)*}, {i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %HistBin*)*}, {i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %HistBin*)*,  void (i8*, i8*, %HistBin*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsSGlzdEJpbipd_native(%HistBin* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsSGlzdEJpbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %HistBin*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %HistBin*)*}*, {i8*, i8*, void (i8*, i8*, %HistBin*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %HistBin*)*}, {i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %HistBin*)*}, {i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %HistBin*)*,  void (i8*, i8*, %HistBin*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsSGlzdEJpbipd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11140 = bitcast [86 x i8]* @gsxtmmath464 to i8*
call i32 (i8*, ...) @printf(i8* %var11140)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %HistBin*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsSGlzdEJpbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %HistBin*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %HistBin*)*}*, {i8*, i8*, void (i8*, i8*, %HistBin*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %HistBin*)*}, {i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %HistBin*)*}, {i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %HistBin*)*,  void (i8*, i8*, %HistBin*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsSGlzdEJpbipd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%HistBin*}*
%arg_p_0 = getelementptr {%HistBin*}, {%HistBin*}* %fstruct, i32 0, i32 0
%arg_0 = load %HistBin*, %HistBin** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsSGlzdEJpbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %HistBin*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %HistBin*)*}*, {i8*, i8*, void (i8*, i8*, %HistBin*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %HistBin*)*}, {i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %HistBin*)*}, {i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %HistBin*)*,  void (i8*, i8*, %HistBin*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath465 = hidden constant [57 x i8] c"zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd\00"
@gsxtmmath466 = hidden constant [65 x i8] c"{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %HistBin* @zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd__11141(i8* %_impz,i8* %_impenv, %HistBin* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11142 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpdPtr = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}***, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpdPtr_

; setup arguments
%xPtr = alloca %HistBin*
store %HistBin* %x, %HistBin** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val11144 = load %mzone*, %mzone** %fromzPtr
%val11145 = load %HistBin*, %HistBin** %xPtr
%val11146 = bitcast %HistBin* %val11145 to i8*
%res11147 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val11144, i8* %val11146)
br i1 %res11147, label %then11143, label %else11143

then11143:
%val11148 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val11148)
%zone_ptr11149 = bitcast %mzone* %val11148 to i8*
store i8* %zone_ptr11149, i8** %_impzPtr
%tzone11155 = load i8*, i8** %_impzPtr
%zone11156 = bitcast i8* %tzone11155 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %HistBin*
%tzone11151 = load i8*, i8** %_impzPtr
%zone11152 = bitcast i8* %tzone11151 to %mzone*
%dat11153 = call i8* @llvm_zone_malloc(%mzone* %zone11152, i64 8)
call i8* @memset(i8* %dat11153, i32 0, i64 8)
%val11154 = bitcast i8* %dat11153 to %HistBin*

; let value assignment
%obj = select i1 true, %HistBin* %val11154, %HistBin* %val11154
store %HistBin* %obj, %HistBin** %objPtr

%val11157 = load %HistBin*, %HistBin** %objPtr
%val11158 = load %HistBin*, %HistBin** %xPtr
; tuple ref
%val11159 = getelementptr %HistBin, %HistBin* %val11158, i64 0, i32 0
%val11160 = load float, float* %val11159
; set tuple
%val11161 = getelementptr %HistBin, %HistBin* %val11157, i64 0, i32 0
store float %val11160, float* %val11161
%val11162 = load %HistBin*, %HistBin** %objPtr
%val11163 = load %HistBin*, %HistBin** %xPtr
; tuple ref
%val11164 = getelementptr %HistBin, %HistBin* %val11163, i64 0, i32 1
%val11165 = load float, float* %val11164
; set tuple
%val11166 = getelementptr %HistBin, %HistBin* %val11162, i64 0, i32 1
store float %val11165, float* %val11166
%oldzone11167 = call %mzone* @llvm_pop_zone_stack()
%newzone11168 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr11169 = bitcast %mzone* %newzone11168 to i8*
store i8* %zone_ptr11169, i8** %_impzPtr
%val11170 = load %HistBin*, %HistBin** %objPtr
ret %HistBin* %val11170

else11143:
%val11171 = load %HistBin*, %HistBin** %xPtr
ret %HistBin* %val11171
}
@gsxtmmath467 = hidden constant [110 x i8] c"zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}** @zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11191 = load i8*, i8** %_impzPtr
%zone11192 = bitcast i8* %tzone11191 to %mzone*

; let assign value to symbol zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd
%dat_zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone11192, i64 8)
%zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpdPtr = bitcast i8* %dat_zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd to { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}***
%tzone11172 = load i8*, i8** %_impzPtr
%zone11173 = bitcast i8* %tzone11172 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11173)
; malloc closure structure
%clsptr11174 = call i8* @llvm_zone_malloc(%mzone* %zone11173, i64 24)
%closure11175 = bitcast i8* %clsptr11174 to { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr11176 = call i8* @llvm_zone_malloc(%mzone* %zone11173, i64 8)
%environment11177 = bitcast i8* %envptr11176 to {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable11178 = call %clsvar* @new_address_table()
%var11179 = bitcast [57 x i8]* @gsxtmmath465 to i8*
%var11180 = bitcast [65 x i8]* @gsxtmmath466 to i8*
%addytable11181 = call %clsvar* @add_address_table(%mzone* %zone11173, i8* %var11179, i32 0, i8* %var11180, i32 3, %clsvar* %addytable11178)
%address-table11182 = bitcast %clsvar* %addytable11181 to i8*

; insert table, function and environment into closure struct
%closure.table11185 = getelementptr { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}* %closure11175, i32 0, i32 0
store i8* %address-table11182, i8** %closure.table11185
%closure.env11186 = getelementptr { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}* %closure11175, i32 0, i32 1
store i8* %envptr11176, i8** %closure.env11186
%closure.func11187 = getelementptr { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}* %closure11175, i32 0, i32 2
store %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)* @zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd__11141, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)** %closure.func11187
%closure_size11188 = call i64 @llvm_zone_mark_size(%mzone* %zone11173)
call void @llvm_zone_ptr_set_size(i8* %clsptr11174, i64 %closure_size11188)
%wrapper_ptr11189 = call i8* @llvm_zone_malloc(%mzone* %zone11173, i64 8)
%closure_wrapper11190 = bitcast i8* %wrapper_ptr11189 to { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}**
store { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}* %closure11175, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}** %closure_wrapper11190

; let value assignment
%zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd = select i1 true, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}** %closure_wrapper11190, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}** %closure_wrapper11190
store { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}** %zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd
%tmp_envptr11184 = getelementptr {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}***}* %environment11177, i32 0, i32 0
store {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpdPtr, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}**** %tmp_envptr11184


%val11193 = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}**, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpdPtr
ret {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}** %val11193
}


@zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}** @zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %HistBin* @zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd(%HistBin* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}*, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*,  %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %HistBin* %result
}


define dllexport ccc %HistBin* @zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd_native(%HistBin* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}*, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*,  %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %HistBin* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11194 = bitcast [110 x i8]* @gsxtmmath467 to i8*
call i32 (i8*, ...) @printf(i8* %var11194)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %HistBin*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var11195 = bitcast [110 x i8]* @gsxtmmath467 to i8*
call i32 (i8*, ...) @printf(i8* %var11195)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var11196 = bitcast [110 x i8]* @gsxtmmath467 to i8*
call i32 (i8*, ...) @printf(i8* %var11196)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}*, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*,  %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %HistBin* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%HistBin*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%HistBin*, %mzone*, %mzone*}, {%HistBin*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %HistBin*, %HistBin** %arg_p_0
%arg_p_1 = getelementptr {%HistBin*, %mzone*, %mzone*}, {%HistBin*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%HistBin*, %mzone*, %mzone*}, {%HistBin*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}*, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)*,  %HistBin* (i8*, i8*, %HistBin*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath468 = hidden constant [14 x i8] c"<HistBin 0x0>\00"
@gsxtmmath469 = hidden constant [32 x i8] c"<HistBin %p minval=%f count=%f>\00"
@gsxtmmath470 = hidden constant [33 x i8] c"print_adhoc_W3ZvaWQsSGlzdEJpbipd\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsSGlzdEJpbipd__11197(i8* %_impz,i8* %_impenv, %HistBin* %histbin) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11198 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %HistBin*)*}***}*
%print_adhoc_W3ZvaWQsSGlzdEJpbipdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %HistBin*)*}***}, {{i8*, i8*, void (i8*, i8*, %HistBin*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsSGlzdEJpbipdPtr = load {i8*, i8*, void (i8*, i8*, %HistBin*)*}***, {i8*, i8*, void (i8*, i8*, %HistBin*)*}**** %print_adhoc_W3ZvaWQsSGlzdEJpbipdPtr_

; setup arguments
%histbinPtr = alloca %HistBin*
store %HistBin* %histbin, %HistBin** %histbinPtr

; promote local stack var allocations
%tzone11217 = load i8*, i8** %_impzPtr
%zone11218 = bitcast i8* %tzone11217 to %mzone*
%ifptr11199 = alloca i32

%val11200 = load %HistBin*, %HistBin** %histbinPtr
%val11201 = icmp eq %HistBin* %val11200, null
br i1 %val11201, label %then11199, label %else11199

then11199:
%var11202 = bitcast [14 x i8]* @gsxtmmath468 to i8*

%val11203 = call i32 (i8*, ...) @printf(i8* %var11202)
store i32 %val11203, i32* %ifptr11199
br label %ifcont11199

else11199:
%var11204 = bitcast [32 x i8]* @gsxtmmath469 to i8*
%val11205 = load %HistBin*, %HistBin** %histbinPtr
%val11206 = load %HistBin*, %HistBin** %histbinPtr
; tuple ref
%val11207 = getelementptr %HistBin, %HistBin* %val11206, i64 0, i32 0
%val11208 = load float, float* %val11207
%val11209 = fpext float %val11208 to double
%val11210 = load %HistBin*, %HistBin** %histbinPtr
; tuple ref
%val11211 = getelementptr %HistBin, %HistBin* %val11210, i64 0, i32 1
%val11212 = load float, float* %val11211
%val11213 = fpext float %val11212 to double

%val11214 = call i32 (i8*, ...) @printf(i8* %var11204, %HistBin* %val11205, double %val11209, double %val11213)
store i32 %val11214, i32* %ifptr11199
br label %ifcont11199

ifcont11199:
%ifres11215 = load i32, i32* %ifptr11199

ret void
}
@gsxtmmath471 = hidden constant [86 x i8] c"print_adhoc_W3ZvaWQsSGlzdEJpbipd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %HistBin*)*}** @print_adhoc_W3ZvaWQsSGlzdEJpbipd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11238 = load i8*, i8** %_impzPtr
%zone11239 = bitcast i8* %tzone11238 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsSGlzdEJpbipd
%dat_print_adhoc_W3ZvaWQsSGlzdEJpbipd = call i8* @llvm_zone_malloc(%mzone* %zone11239, i64 8)
%print_adhoc_W3ZvaWQsSGlzdEJpbipdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsSGlzdEJpbipd to { i8*, i8*, void (i8*, i8*, %HistBin*)*}***
%tzone11219 = load i8*, i8** %_impzPtr
%zone11220 = bitcast i8* %tzone11219 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11220)
; malloc closure structure
%clsptr11221 = call i8* @llvm_zone_malloc(%mzone* %zone11220, i64 24)
%closure11222 = bitcast i8* %clsptr11221 to { i8*, i8*, void (i8*, i8*, %HistBin*)*}*

; malloc environment structure
%envptr11223 = call i8* @llvm_zone_malloc(%mzone* %zone11220, i64 8)
%environment11224 = bitcast i8* %envptr11223 to {{i8*, i8*, void (i8*, i8*, %HistBin*)*}***}*

; malloc closure address table
%addytable11225 = call %clsvar* @new_address_table()
%var11226 = bitcast [33 x i8]* @gsxtmmath470 to i8*
%var11227 = bitcast [42 x i8]* @gsxtmmath463 to i8*
%addytable11228 = call %clsvar* @add_address_table(%mzone* %zone11220, i8* %var11226, i32 0, i8* %var11227, i32 3, %clsvar* %addytable11225)
%address-table11229 = bitcast %clsvar* %addytable11228 to i8*

; insert table, function and environment into closure struct
%closure.table11232 = getelementptr { i8*, i8*, void (i8*, i8*, %HistBin*)*}, { i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure11222, i32 0, i32 0
store i8* %address-table11229, i8** %closure.table11232
%closure.env11233 = getelementptr { i8*, i8*, void (i8*, i8*, %HistBin*)*}, { i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure11222, i32 0, i32 1
store i8* %envptr11223, i8** %closure.env11233
%closure.func11234 = getelementptr { i8*, i8*, void (i8*, i8*, %HistBin*)*}, { i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure11222, i32 0, i32 2
store void (i8*, i8*, %HistBin*)* @print_adhoc_W3ZvaWQsSGlzdEJpbipd__11197, void (i8*, i8*, %HistBin*)** %closure.func11234
%closure_size11235 = call i64 @llvm_zone_mark_size(%mzone* %zone11220)
call void @llvm_zone_ptr_set_size(i8* %clsptr11221, i64 %closure_size11235)
%wrapper_ptr11236 = call i8* @llvm_zone_malloc(%mzone* %zone11220, i64 8)
%closure_wrapper11237 = bitcast i8* %wrapper_ptr11236 to { i8*, i8*, void (i8*, i8*, %HistBin*)*}**
store { i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure11222, { i8*, i8*, void (i8*, i8*, %HistBin*)*}** %closure_wrapper11237

; let value assignment
%print_adhoc_W3ZvaWQsSGlzdEJpbipd = select i1 true, { i8*, i8*, void (i8*, i8*, %HistBin*)*}** %closure_wrapper11237, { i8*, i8*, void (i8*, i8*, %HistBin*)*}** %closure_wrapper11237
store { i8*, i8*, void (i8*, i8*, %HistBin*)*}** %print_adhoc_W3ZvaWQsSGlzdEJpbipd, { i8*, i8*, void (i8*, i8*, %HistBin*)*}*** %print_adhoc_W3ZvaWQsSGlzdEJpbipdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsSGlzdEJpbipd
%tmp_envptr11231 = getelementptr {{i8*, i8*, void (i8*, i8*, %HistBin*)*}***}, {{i8*, i8*, void (i8*, i8*, %HistBin*)*}***}* %environment11224, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %HistBin*)*}*** %print_adhoc_W3ZvaWQsSGlzdEJpbipdPtr, {i8*, i8*, void (i8*, i8*, %HistBin*)*}**** %tmp_envptr11231


%val11240 = load {i8*, i8*, void (i8*, i8*, %HistBin*)*}**, {i8*, i8*, void (i8*, i8*, %HistBin*)*}*** %print_adhoc_W3ZvaWQsSGlzdEJpbipdPtr
ret {i8*, i8*, void (i8*, i8*, %HistBin*)*}** %val11240
}


@print_adhoc_W3ZvaWQsSGlzdEJpbipd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsSGlzdEJpbipd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsSGlzdEJpbipd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsSGlzdEJpbipd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %HistBin*)*}** @print_adhoc_W3ZvaWQsSGlzdEJpbipd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %HistBin*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsSGlzdEJpbipd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsSGlzdEJpbipd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsSGlzdEJpbipd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsSGlzdEJpbipd(%HistBin* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsSGlzdEJpbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %HistBin*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %HistBin*)*}*, {i8*, i8*, void (i8*, i8*, %HistBin*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %HistBin*)*}, {i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %HistBin*)*}, {i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %HistBin*)*,  void (i8*, i8*, %HistBin*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsSGlzdEJpbipd_native(%HistBin* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsSGlzdEJpbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %HistBin*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %HistBin*)*}*, {i8*, i8*, void (i8*, i8*, %HistBin*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %HistBin*)*}, {i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %HistBin*)*}, {i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %HistBin*)*,  void (i8*, i8*, %HistBin*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsSGlzdEJpbipd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11241 = bitcast [86 x i8]* @gsxtmmath471 to i8*
call i32 (i8*, ...) @printf(i8* %var11241)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %HistBin*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsSGlzdEJpbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %HistBin*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %HistBin*)*}*, {i8*, i8*, void (i8*, i8*, %HistBin*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %HistBin*)*}, {i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %HistBin*)*}, {i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %HistBin*)*,  void (i8*, i8*, %HistBin*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsSGlzdEJpbipd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%HistBin*}*
%arg_p_0 = getelementptr {%HistBin*}, {%HistBin*}* %fstruct, i32 0, i32 0
%arg_0 = load %HistBin*, %HistBin** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsSGlzdEJpbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %HistBin*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %HistBin*)*}*, {i8*, i8*, void (i8*, i8*, %HistBin*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %HistBin*)*}, {i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %HistBin*)*}, {i8*, i8*, void (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %HistBin*)*,  void (i8*, i8*, %HistBin*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath472 = hidden constant [40 x i8] c"toString_adhoc_W1N0cmluZyosSGlzdEJpbipd\00"
@gsxtmmath473 = hidden constant [46 x i8] c"{i8*, i8*, %String* (i8*, i8*, %HistBin*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosSGlzdEJpbipd__11242(i8* %_impz,i8* %_impenv, %HistBin* %histbin) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11243 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %HistBin*)*}***}*
%toString_adhoc_W1N0cmluZyosSGlzdEJpbipdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %HistBin*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %HistBin*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosSGlzdEJpbipdPtr = load {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}***, {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}**** %toString_adhoc_W1N0cmluZyosSGlzdEJpbipdPtr_

; setup arguments
%histbinPtr = alloca %HistBin*
store %HistBin* %histbin, %HistBin** %histbinPtr


%tzone11245 = load i8*, i8** %_impzPtr
%zone11246 = bitcast i8* %tzone11245 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat11244 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat11244, i8* %dat11244
store i8* %str, i8** %strPtr

; promote local stack var allocations
%tzone11268 = load i8*, i8** %_impzPtr
%zone11269 = bitcast i8* %tzone11268 to %mzone*
%ifptr11247 = alloca i32
%val11248 = load %HistBin*, %HistBin** %histbinPtr
%val11249 = icmp eq %HistBin* %val11248, null
br i1 %val11249, label %then11247, label %else11247

then11247:
%val11250 = load i8*, i8** %strPtr
%var11251 = bitcast [14 x i8]* @gsxtmmath468 to i8*

%val11252 = call i32 (i8*,i8*, ...) @sprintf(i8* %val11250, i8* %var11251)
store i32 %val11252, i32* %ifptr11247
br label %ifcont11247

else11247:
%val11253 = load i8*, i8** %strPtr
%var11254 = bitcast [32 x i8]* @gsxtmmath469 to i8*
%val11255 = load %HistBin*, %HistBin** %histbinPtr
%val11256 = load %HistBin*, %HistBin** %histbinPtr
; tuple ref
%val11257 = getelementptr %HistBin, %HistBin* %val11256, i64 0, i32 0
%val11258 = load float, float* %val11257
%val11259 = fpext float %val11258 to double
%val11260 = load %HistBin*, %HistBin** %histbinPtr
; tuple ref
%val11261 = getelementptr %HistBin, %HistBin* %val11260, i64 0, i32 1
%val11262 = load float, float* %val11261
%val11263 = fpext float %val11262 to double

%val11264 = call i32 (i8*,i8*, ...) @sprintf(i8* %val11253, i8* %var11254, %HistBin* %val11255, double %val11259, double %val11263)
store i32 %val11264, i32* %ifptr11247
br label %ifcont11247

ifcont11247:
%ifres11265 = load i32, i32* %ifptr11247

%val11266 = load i8*, i8** %strPtr
%res11267 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val11266)
ret %String* %res11267
}
@gsxtmmath474 = hidden constant [93 x i8] c"toString_adhoc_W1N0cmluZyosSGlzdEJpbipd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}** @toString_adhoc_W1N0cmluZyosSGlzdEJpbipd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11289 = load i8*, i8** %_impzPtr
%zone11290 = bitcast i8* %tzone11289 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosSGlzdEJpbipd
%dat_toString_adhoc_W1N0cmluZyosSGlzdEJpbipd = call i8* @llvm_zone_malloc(%mzone* %zone11290, i64 8)
%toString_adhoc_W1N0cmluZyosSGlzdEJpbipdPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosSGlzdEJpbipd to { i8*, i8*, %String* (i8*, i8*, %HistBin*)*}***
%tzone11270 = load i8*, i8** %_impzPtr
%zone11271 = bitcast i8* %tzone11270 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11271)
; malloc closure structure
%clsptr11272 = call i8* @llvm_zone_malloc(%mzone* %zone11271, i64 24)
%closure11273 = bitcast i8* %clsptr11272 to { i8*, i8*, %String* (i8*, i8*, %HistBin*)*}*

; malloc environment structure
%envptr11274 = call i8* @llvm_zone_malloc(%mzone* %zone11271, i64 8)
%environment11275 = bitcast i8* %envptr11274 to {{i8*, i8*, %String* (i8*, i8*, %HistBin*)*}***}*

; malloc closure address table
%addytable11276 = call %clsvar* @new_address_table()
%var11277 = bitcast [40 x i8]* @gsxtmmath472 to i8*
%var11278 = bitcast [46 x i8]* @gsxtmmath473 to i8*
%addytable11279 = call %clsvar* @add_address_table(%mzone* %zone11271, i8* %var11277, i32 0, i8* %var11278, i32 3, %clsvar* %addytable11276)
%address-table11280 = bitcast %clsvar* %addytable11279 to i8*

; insert table, function and environment into closure struct
%closure.table11283 = getelementptr { i8*, i8*, %String* (i8*, i8*, %HistBin*)*}, { i8*, i8*, %String* (i8*, i8*, %HistBin*)*}* %closure11273, i32 0, i32 0
store i8* %address-table11280, i8** %closure.table11283
%closure.env11284 = getelementptr { i8*, i8*, %String* (i8*, i8*, %HistBin*)*}, { i8*, i8*, %String* (i8*, i8*, %HistBin*)*}* %closure11273, i32 0, i32 1
store i8* %envptr11274, i8** %closure.env11284
%closure.func11285 = getelementptr { i8*, i8*, %String* (i8*, i8*, %HistBin*)*}, { i8*, i8*, %String* (i8*, i8*, %HistBin*)*}* %closure11273, i32 0, i32 2
store %String* (i8*, i8*, %HistBin*)* @toString_adhoc_W1N0cmluZyosSGlzdEJpbipd__11242, %String* (i8*, i8*, %HistBin*)** %closure.func11285
%closure_size11286 = call i64 @llvm_zone_mark_size(%mzone* %zone11271)
call void @llvm_zone_ptr_set_size(i8* %clsptr11272, i64 %closure_size11286)
%wrapper_ptr11287 = call i8* @llvm_zone_malloc(%mzone* %zone11271, i64 8)
%closure_wrapper11288 = bitcast i8* %wrapper_ptr11287 to { i8*, i8*, %String* (i8*, i8*, %HistBin*)*}**
store { i8*, i8*, %String* (i8*, i8*, %HistBin*)*}* %closure11273, { i8*, i8*, %String* (i8*, i8*, %HistBin*)*}** %closure_wrapper11288

; let value assignment
%toString_adhoc_W1N0cmluZyosSGlzdEJpbipd = select i1 true, { i8*, i8*, %String* (i8*, i8*, %HistBin*)*}** %closure_wrapper11288, { i8*, i8*, %String* (i8*, i8*, %HistBin*)*}** %closure_wrapper11288
store { i8*, i8*, %String* (i8*, i8*, %HistBin*)*}** %toString_adhoc_W1N0cmluZyosSGlzdEJpbipd, { i8*, i8*, %String* (i8*, i8*, %HistBin*)*}*** %toString_adhoc_W1N0cmluZyosSGlzdEJpbipdPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosSGlzdEJpbipd
%tmp_envptr11282 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %HistBin*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %HistBin*)*}***}* %environment11275, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}*** %toString_adhoc_W1N0cmluZyosSGlzdEJpbipdPtr, {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}**** %tmp_envptr11282


%val11291 = load {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}**, {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}*** %toString_adhoc_W1N0cmluZyosSGlzdEJpbipdPtr
ret {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}** %val11291
}


@toString_adhoc_W1N0cmluZyosSGlzdEJpbipd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosSGlzdEJpbipd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosSGlzdEJpbipd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosSGlzdEJpbipd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}** @toString_adhoc_W1N0cmluZyosSGlzdEJpbipd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosSGlzdEJpbipd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosSGlzdEJpbipd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosSGlzdEJpbipd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosSGlzdEJpbipd(%HistBin* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosSGlzdEJpbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}*, {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}, {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}, {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %HistBin*)*,  %String* (i8*, i8*, %HistBin*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosSGlzdEJpbipd_native(%HistBin* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosSGlzdEJpbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}*, {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}, {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}, {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %HistBin*)*,  %String* (i8*, i8*, %HistBin*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosSGlzdEJpbipd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11292 = bitcast [93 x i8]* @gsxtmmath474 to i8*
call i32 (i8*, ...) @printf(i8* %var11292)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %HistBin*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosSGlzdEJpbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}*, {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}, {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}, {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %HistBin*)*,  %String* (i8*, i8*, %HistBin*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosSGlzdEJpbipd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%HistBin*}*
%arg_p_0 = getelementptr {%HistBin*}, {%HistBin*}* %fstruct, i32 0, i32 0
%arg_0 = load %HistBin*, %HistBin** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosSGlzdEJpbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}*, {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}, {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}, {i8*, i8*, %String* (i8*, i8*, %HistBin*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %HistBin*)*,  %String* (i8*, i8*, %HistBin*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath475 = hidden constant [3 x i8] c"%s\00"
@gsxtmmath476 = hidden constant [67 x i8] c"Error in histogram: range (- upper lower) must be greater than 0.0\00"
@gsxtmmath477 = hidden constant [79 x i8] c"histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ\00"
@gsxtmmath478 = hidden constant [79 x i8] c"{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}**\00"
define dllexport fastcc %HistBin* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ__11293(i8* %_impz,i8* %_impenv, %HistBin* %hist, float* %buf, i64 %len, float %lower, float %upper, i64 %nbins) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11294 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}***}*
%histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQPtr_ = getelementptr {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}***}, {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}***}* %impenv, i32 0, i32 0
%histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQPtr = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}***, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}**** %histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQPtr_

; setup arguments
%histPtr = alloca %HistBin*
store %HistBin* %hist, %HistBin** %histPtr
%bufPtr = alloca float*
store float* %buf, float** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%lowerPtr = alloca float
store float %lower, float* %lowerPtr
%upperPtr = alloca float
store float %upper, float* %upperPtr
%nbinsPtr = alloca i64
store i64 %nbins, i64* %nbinsPtr


%tzone11296 = load i8*, i8** %_impzPtr
%zone11297 = bitcast i8* %tzone11296 to %mzone*

; let assign value to symbol current_bin
%current_binPtr = alloca %HistBin*
%tzone11301 = load i8*, i8** %_impzPtr
%zone11302 = bitcast i8* %tzone11301 to %mzone*

; let assign value to symbol range
%rangePtr = alloca float
%null11295 = bitcast i8* null to %HistBin*

; let value assignment
%current_bin = select i1 true, %HistBin* %null11295, %HistBin* %null11295
store %HistBin* %current_bin, %HistBin** %current_binPtr

%val11298 = load float, float* %upperPtr
%val11299 = load float, float* %lowerPtr
%val11300 = fsub float %val11298, %val11299

; let value assignment
%range = select i1 true, float %val11300, float %val11300
store float %range, float* %rangePtr

; promote local stack var allocations
%tzone11375 = load i8*, i8** %_impzPtr
%zone11376 = bitcast i8* %tzone11375 to %mzone*
%ifptr11304 = alloca i1
%val11305 = load float, float* %rangePtr
%cmp11306 = fcmp ugt float %val11305, 0x0
br i1 %cmp11306, label %then11304, label %else11304

then11304:
%res11307 = call ccc i1 @impc_false()
store i1 %res11307, i1* %ifptr11304
br label %ifcont11304

else11304:
%res11308 = call ccc i1 @impc_true()
store i1 %res11308, i1* %ifptr11304
br label %ifcont11304

ifcont11304:
%ifres11309 = load i1, i1* %ifptr11304

br i1 %ifres11309, label %then11303, label %else11303

then11303:
%var11310 = bitcast [3 x i8]* @gsxtmmath475 to i8*
%var11311 = bitcast [67 x i8]* @gsxtmmath476 to i8*

%val11312 = call i32 (i8*, ...) @printf(i8* %var11310, i8* %var11311)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%null11314 = bitcast i8* null to %HistBin*
ret %HistBin* %null11314

else11303:
%tzone11316 = load i8*, i8** %_impzPtr
%zone11317 = bitcast i8* %tzone11316 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val11315 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val11315, i64 %val11315
store i64 %i, i64* %iPtr

; setup loop
%val11320 = load i64, i64* %nbinsPtr
store i64 0, i64* %iPtr
%val11338 = load i64, i64* %iPtr
%num11339 = add i64 %val11320, %val11338
%comp11340 = icmp ult i64 %val11320, 1
br i1 %comp11340, label %after11318, label %loop11318

loop11318:
%val11321 = load i64, i64* %iPtr
%val11322 = load %HistBin*, %HistBin** %histPtr
; pointer ref
%val11323 = getelementptr %HistBin, %HistBin* %val11322, i64 %val11321
%val11324 = load float, float* %lowerPtr
%val11325 = load i64, i64* %iPtr
%val11326 = sitofp i64 %val11325 to float
%val11327 = load float, float* %rangePtr
%val11328 = load i64, i64* %nbinsPtr
%val11329 = sitofp i64 %val11328 to float
%val11330 = fdiv float %val11327, %val11329
%val11331 = fmul float %val11326, %val11330
%val11332 = fadd float %val11324, %val11331
; set tuple
%val11333 = getelementptr %HistBin, %HistBin* %val11323, i64 0, i32 0
store float %val11332, float* %val11333
%val11334 = load i64, i64* %iPtr
%val11335 = load %HistBin*, %HistBin** %histPtr
; pointer ref
%val11336 = getelementptr %HistBin, %HistBin* %val11335, i64 %val11334
; set tuple
%val11337 = getelementptr %HistBin, %HistBin* %val11336, i64 0, i32 1
store float 0x0, float* %val11337
%loop_cnt11318 = load i64, i64* %iPtr
%next11318 = add i64 %loop_cnt11318, 1
store i64 %next11318, i64* %iPtr
%cmp11318 = icmp ult i64 %next11318, %num11339
br i1 %cmp11318, label %loop11318, label %after11318

after11318:
%tzone11343 = load i8*, i8** %_impzPtr
%zone11344 = bitcast i8* %tzone11343 to %mzone*

; let assign value to symbol i_s_1
%i_s_1Ptr = alloca i64
%val11342 = bitcast i64 0 to i64

; let value assignment
%i_s_1 = select i1 true, i64 %val11342, i64 %val11342
store i64 %i_s_1, i64* %i_s_1Ptr

; setup loop
%val11347 = load i64, i64* %lenPtr
store i64 0, i64* %i_s_1Ptr
%val11370 = load i64, i64* %i_s_1Ptr
%num11371 = add i64 %val11347, %val11370
%comp11372 = icmp ult i64 %val11347, 1
br i1 %comp11372, label %after11345, label %loop11345

loop11345:
; do set!
%val11348 = load i64, i64* %nbinsPtr
%val11349 = sitofp i64 %val11348 to float
%val11350 = load i64, i64* %i_s_1Ptr
%val11351 = load float*, float** %bufPtr
; pointer ref
%val11352 = getelementptr float, float* %val11351, i64 %val11350
%val11353 = load float, float* %val11352
%val11354 = load float, float* %lowerPtr
%val11355 = fsub float %val11353, %val11354
%val11356 = load float, float* %rangePtr
%val11357 = fdiv float %val11355, %val11356
%val11358 = fmul float %val11349, %val11357
%val11359 = fptosi float %val11358 to i64
%val11360 = load i64, i64* %nbinsPtr
%val11361 = srem i64 %val11359, %val11360
%val11362 = load %HistBin*, %HistBin** %histPtr
; pointer ref
%val11363 = getelementptr %HistBin, %HistBin* %val11362, i64 %val11361
store %HistBin* %val11363, %HistBin** %current_binPtr
%val11364 = load %HistBin*, %HistBin** %current_binPtr
%val11365 = load %HistBin*, %HistBin** %current_binPtr
; tuple ref
%val11366 = getelementptr %HistBin, %HistBin* %val11365, i64 0, i32 1
%val11367 = load float, float* %val11366
%val11368 = fadd float %val11367, 0x3ff0000000000000
; set tuple
%val11369 = getelementptr %HistBin, %HistBin* %val11364, i64 0, i32 1
store float %val11368, float* %val11369
%loop_cnt11345 = load i64, i64* %i_s_1Ptr
%next11345 = add i64 %loop_cnt11345, 1
store i64 %next11345, i64* %i_s_1Ptr
%cmp11345 = icmp ult i64 %next11345, %num11371
br i1 %cmp11345, label %loop11345, label %after11345

after11345:
%val11374 = load %HistBin*, %HistBin** %histPtr
ret %HistBin* %val11374
}
@gsxtmmath479 = hidden constant [132 x i8] c"histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}** @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11396 = load i8*, i8** %_impzPtr
%zone11397 = bitcast i8* %tzone11396 to %mzone*

; let assign value to symbol histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ
%dat_histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone11397, i64 8)
%histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQPtr = bitcast i8* %dat_histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ to { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}***
%tzone11377 = load i8*, i8** %_impzPtr
%zone11378 = bitcast i8* %tzone11377 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11378)
; malloc closure structure
%clsptr11379 = call i8* @llvm_zone_malloc(%mzone* %zone11378, i64 24)
%closure11380 = bitcast i8* %clsptr11379 to { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}*

; malloc environment structure
%envptr11381 = call i8* @llvm_zone_malloc(%mzone* %zone11378, i64 8)
%environment11382 = bitcast i8* %envptr11381 to {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}***}*

; malloc closure address table
%addytable11383 = call %clsvar* @new_address_table()
%var11384 = bitcast [79 x i8]* @gsxtmmath477 to i8*
%var11385 = bitcast [79 x i8]* @gsxtmmath478 to i8*
%addytable11386 = call %clsvar* @add_address_table(%mzone* %zone11378, i8* %var11384, i32 0, i8* %var11385, i32 3, %clsvar* %addytable11383)
%address-table11387 = bitcast %clsvar* %addytable11386 to i8*

; insert table, function and environment into closure struct
%closure.table11390 = getelementptr { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}* %closure11380, i32 0, i32 0
store i8* %address-table11387, i8** %closure.table11390
%closure.env11391 = getelementptr { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}* %closure11380, i32 0, i32 1
store i8* %envptr11381, i8** %closure.env11391
%closure.func11392 = getelementptr { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}* %closure11380, i32 0, i32 2
store %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ__11293, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)** %closure.func11392
%closure_size11393 = call i64 @llvm_zone_mark_size(%mzone* %zone11378)
call void @llvm_zone_ptr_set_size(i8* %clsptr11379, i64 %closure_size11393)
%wrapper_ptr11394 = call i8* @llvm_zone_malloc(%mzone* %zone11378, i64 8)
%closure_wrapper11395 = bitcast i8* %wrapper_ptr11394 to { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}**
store { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}* %closure11380, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}** %closure_wrapper11395

; let value assignment
%histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ = select i1 true, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}** %closure_wrapper11395, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}** %closure_wrapper11395
store { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}** %histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}*** %histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ
%tmp_envptr11389 = getelementptr {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}***}, {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}***}* %environment11382, i32 0, i32 0
store {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}*** %histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQPtr, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}**** %tmp_envptr11389


%val11398 = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}**, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}*** %histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQPtr
ret {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}** %val11398
}


@histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}** @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %HistBin* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ(%HistBin* %arg_0,float* %arg_1,i64 %arg_2,float %arg_3,float %arg_4,i64 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}*, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*,  %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0, float* %arg_1, i64 %arg_2, float %arg_3, float %arg_4, i64 %arg_5)
ret %HistBin* %result
}


define dllexport ccc %HistBin* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ_native(%HistBin* %arg_0,float* %arg_1,i64 %arg_2,float %arg_3,float %arg_4,i64 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}*, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*,  %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0, float* %arg_1, i64 %arg_2, float %arg_3, float %arg_4, i64 %arg_5)
ret %HistBin* %result
}


define dllexport ccc i8*  @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11399 = bitcast [132 x i8]* @gsxtmmath479 to i8*
call i32 (i8*, ...) @printf(i8* %var11399)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %HistBin*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var11400 = bitcast [132 x i8]* @gsxtmmath479 to i8*
call i32 (i8*, ...) @printf(i8* %var11400)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var11401 = bitcast [132 x i8]* @gsxtmmath479 to i8*
call i32 (i8*, ...) @printf(i8* %var11401)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var11402 = bitcast [132 x i8]* @gsxtmmath479 to i8*
call i32 (i8*, ...) @printf(i8* %var11402)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var11403 = bitcast [132 x i8]* @gsxtmmath479 to i8*
call i32 (i8*, ...) @printf(i8* %var11403)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var11404 = bitcast [132 x i8]* @gsxtmmath479 to i8*
call i32 (i8*, ...) @printf(i8* %var11404)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i64  @i64value(i8* %arg_5_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}*, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*,  %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0, float* %arg_1, i64 %arg_2, float %arg_3, float %arg_4, i64 %arg_5)
%tmpres = bitcast %HistBin* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%HistBin*, float*, i64, float, float, i64}*
%arg_p_0 = getelementptr {%HistBin*, float*, i64, float, float, i64}, {%HistBin*, float*, i64, float, float, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %HistBin*, %HistBin** %arg_p_0
%arg_p_1 = getelementptr {%HistBin*, float*, i64, float, float, i64}, {%HistBin*, float*, i64, float, float, i64}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {%HistBin*, float*, i64, float, float, i64}, {%HistBin*, float*, i64, float, float, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {%HistBin*, float*, i64, float, float, i64}, {%HistBin*, float*, i64, float, float, i64}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {%HistBin*, float*, i64, float, float, i64}, {%HistBin*, float*, i64, float, float, i64}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
%arg_p_5 = getelementptr {%HistBin*, float*, i64, float, float, i64}, {%HistBin*, float*, i64, float, float, i64}* %fstruct, i32 0, i32 5
%arg_5 = load i64, i64* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}*, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)*,  %HistBin* (i8*, i8*, %HistBin*, float*, i64, float, float, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0, float* %arg_1, i64 %arg_2, float %arg_3, float %arg_4, i64 %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath480 = hidden constant [63 x i8] c"histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ\00"
@gsxtmmath481 = hidden constant [65 x i8] c"{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}**\00"
define dllexport fastcc %HistBin* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ__11405(i8* %_impz,i8* %_impenv, %HistBin* %hist, float* %buf, i64 %len, i64 %nbins) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11406 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}***}*
%histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}***}, {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}***}* %impenv, i32 0, i32 0
%histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQPtr = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}***, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}**** %histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQPtr_

; setup arguments
%histPtr = alloca %HistBin*
store %HistBin* %hist, %HistBin** %histPtr
%bufPtr = alloca float*
store float* %buf, float** %bufPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr
%nbinsPtr = alloca i64
store i64 %nbins, i64* %nbinsPtr


%tzone11407 = load i8*, i8** %_impzPtr
%zone11408 = bitcast i8* %tzone11407 to %mzone*

; let assign value to symbol lower
%lowerPtr = alloca float
%tzone11409 = load i8*, i8** %_impzPtr
%zone11410 = bitcast i8* %tzone11409 to %mzone*

; let assign value to symbol upper
%upperPtr = alloca float

; let value assignment
%lower = select i1 true, float 0x0, float 0x0
store float %lower, float* %lowerPtr


; let value assignment
%upper = select i1 true, float 0x0, float 0x0
store float %upper, float* %upperPtr

%tzone11412 = load i8*, i8** %_impzPtr
%zone11413 = bitcast i8* %tzone11412 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val11411 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val11411, i64 %val11411
store i64 %i, i64* %iPtr

; promote local stack var allocations
%tzone11445 = load i8*, i8** %_impzPtr
%zone11446 = bitcast i8* %tzone11445 to %mzone*
%ifptr11429 = alloca float
%ifptr11417 = alloca float
; setup loop
%val11416 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val11441 = load i64, i64* %iPtr
%num11442 = add i64 %val11416, %val11441
%comp11443 = icmp ult i64 %val11416, 1
br i1 %comp11443, label %after11414, label %loop11414

loop11414:
%val11418 = load i64, i64* %iPtr
%val11419 = load float*, float** %bufPtr
; pointer ref
%val11420 = getelementptr float, float* %val11419, i64 %val11418
%val11421 = load float, float* %val11420
%val11422 = load float, float* %lowerPtr
%cmp11423 = fcmp ult float %val11421, %val11422
br i1 %cmp11423, label %then11417, label %else11417

then11417:
; do set!
%val11424 = load i64, i64* %iPtr
%val11425 = load float*, float** %bufPtr
; pointer ref
%val11426 = getelementptr float, float* %val11425, i64 %val11424
%val11427 = load float, float* %val11426
store float %val11427, float* %lowerPtr
store float %val11427, float* %ifptr11417
br label %ifcont11417

else11417:
br label %ifcont11417

ifcont11417:
%ifres11428 = load float, float* %ifptr11417

%val11430 = load i64, i64* %iPtr
%val11431 = load float*, float** %bufPtr
; pointer ref
%val11432 = getelementptr float, float* %val11431, i64 %val11430
%val11433 = load float, float* %val11432
%val11434 = load float, float* %upperPtr
%cmp11435 = fcmp ugt float %val11433, %val11434
br i1 %cmp11435, label %then11429, label %else11429

then11429:
; do set!
%val11436 = load i64, i64* %iPtr
%val11437 = load float*, float** %bufPtr
; pointer ref
%val11438 = getelementptr float, float* %val11437, i64 %val11436
%val11439 = load float, float* %val11438
store float %val11439, float* %upperPtr
store float %val11439, float* %ifptr11429
br label %ifcont11429

else11429:
br label %ifcont11429

ifcont11429:
%ifres11440 = load float, float* %ifptr11429

%loop_cnt11414 = load i64, i64* %iPtr
%next11414 = add i64 %loop_cnt11414, 1
store i64 %next11414, i64* %iPtr
%cmp11414 = icmp ult i64 %next11414, %num11442
br i1 %cmp11414, label %loop11414, label %after11414

after11414:
%val11447 = load %HistBin*, %HistBin** %histPtr
%val11448 = load float*, float** %bufPtr
%val11449 = load i64, i64* %lenPtr
%val11450 = load float, float* %lowerPtr
%val11451 = load float, float* %upperPtr
%val11452 = load i64, i64* %nbinsPtr
%res11453 = call fastcc %HistBin* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsaTY0XQ(%HistBin* %val11447, float* %val11448, i64 %val11449, float %val11450, float %val11451, i64 %val11452)
ret %HistBin* %res11453
}
@gsxtmmath482 = hidden constant [116 x i8] c"histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}** @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11473 = load i8*, i8** %_impzPtr
%zone11474 = bitcast i8* %tzone11473 to %mzone*

; let assign value to symbol histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ
%dat_histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone11474, i64 8)
%histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQPtr = bitcast i8* %dat_histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ to { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}***
%tzone11454 = load i8*, i8** %_impzPtr
%zone11455 = bitcast i8* %tzone11454 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11455)
; malloc closure structure
%clsptr11456 = call i8* @llvm_zone_malloc(%mzone* %zone11455, i64 24)
%closure11457 = bitcast i8* %clsptr11456 to { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}*

; malloc environment structure
%envptr11458 = call i8* @llvm_zone_malloc(%mzone* %zone11455, i64 8)
%environment11459 = bitcast i8* %envptr11458 to {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}***}*

; malloc closure address table
%addytable11460 = call %clsvar* @new_address_table()
%var11461 = bitcast [63 x i8]* @gsxtmmath480 to i8*
%var11462 = bitcast [65 x i8]* @gsxtmmath481 to i8*
%addytable11463 = call %clsvar* @add_address_table(%mzone* %zone11455, i8* %var11461, i32 0, i8* %var11462, i32 3, %clsvar* %addytable11460)
%address-table11464 = bitcast %clsvar* %addytable11463 to i8*

; insert table, function and environment into closure struct
%closure.table11467 = getelementptr { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}* %closure11457, i32 0, i32 0
store i8* %address-table11464, i8** %closure.table11467
%closure.env11468 = getelementptr { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}* %closure11457, i32 0, i32 1
store i8* %envptr11458, i8** %closure.env11468
%closure.func11469 = getelementptr { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}* %closure11457, i32 0, i32 2
store %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ__11405, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)** %closure.func11469
%closure_size11470 = call i64 @llvm_zone_mark_size(%mzone* %zone11455)
call void @llvm_zone_ptr_set_size(i8* %clsptr11456, i64 %closure_size11470)
%wrapper_ptr11471 = call i8* @llvm_zone_malloc(%mzone* %zone11455, i64 8)
%closure_wrapper11472 = bitcast i8* %wrapper_ptr11471 to { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}**
store { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}* %closure11457, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}** %closure_wrapper11472

; let value assignment
%histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ = select i1 true, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}** %closure_wrapper11472, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}** %closure_wrapper11472
store { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}** %histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ, { i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}*** %histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ
%tmp_envptr11466 = getelementptr {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}***}, {{i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}***}* %environment11459, i32 0, i32 0
store {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}*** %histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQPtr, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}**** %tmp_envptr11466


%val11475 = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}**, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}*** %histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQPtr
ret {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}** %val11475
}


@histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}** @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %HistBin* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ(%HistBin* %arg_0,float* %arg_1,i64 %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}*, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*,  %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0, float* %arg_1, i64 %arg_2, i64 %arg_3)
ret %HistBin* %result
}


define dllexport ccc %HistBin* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ_native(%HistBin* %arg_0,float* %arg_1,i64 %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}*, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*,  %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0, float* %arg_1, i64 %arg_2, i64 %arg_3)
ret %HistBin* %result
}


define dllexport ccc i8*  @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11476 = bitcast [116 x i8]* @gsxtmmath482 to i8*
call i32 (i8*, ...) @printf(i8* %var11476)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %HistBin*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var11477 = bitcast [116 x i8]* @gsxtmmath482 to i8*
call i32 (i8*, ...) @printf(i8* %var11477)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var11478 = bitcast [116 x i8]* @gsxtmmath482 to i8*
call i32 (i8*, ...) @printf(i8* %var11478)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var11479 = bitcast [116 x i8]* @gsxtmmath482 to i8*
call i32 (i8*, ...) @printf(i8* %var11479)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}*, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*,  %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0, float* %arg_1, i64 %arg_2, i64 %arg_3)
%tmpres = bitcast %HistBin* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%HistBin*, float*, i64, i64}*
%arg_p_0 = getelementptr {%HistBin*, float*, i64, i64}, {%HistBin*, float*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %HistBin*, %HistBin** %arg_p_0
%arg_p_1 = getelementptr {%HistBin*, float*, i64, i64}, {%HistBin*, float*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {%HistBin*, float*, i64, i64}, {%HistBin*, float*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {%HistBin*, float*, i64, i64}, {%HistBin*, float*, i64, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @histogram_adhoc_W0hpc3RCaW4qLEhpc3RCaW4qLGZsb2F0KixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}**
%closure = load {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}*, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}, {i8*, i8*, %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)*,  %HistBin* (i8*, i8*, %HistBin*, float*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %HistBin* %ff(i8* %_impz, i8* %ee, %HistBin* %arg_0, float* %arg_1, i64 %arg_2, i64 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath483 = hidden constant [49 x i8] c"dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ\00"
define dllexport fastcc void @dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ__11480(i8* %_impz,i8* %_impenv, double* %in, %Complexd* %out, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11481 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}***}*
%dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}***}* %impenv, i32 0, i32 0
%dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}***, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}**** %dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQPtr_

; setup arguments
%inPtr = alloca double*
store double* %in, double** %inPtr
%outPtr = alloca %Complexd*
store %Complexd* %out, %Complexd** %outPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone11482 = load i8*, i8** %_impzPtr
%zone11483 = bitcast i8* %tzone11482 to %mzone*

; let assign value to symbol n
%nPtr = alloca i64
%tzone11484 = load i8*, i8** %_impzPtr
%zone11485 = bitcast i8* %tzone11484 to %mzone*

; let assign value to symbol k
%kPtr = alloca i64
%tzone11486 = load i8*, i8** %_impzPtr
%zone11487 = bitcast i8* %tzone11486 to %mzone*

; let assign value to symbol tmp
%tmpPtr = alloca double
%tzone11489 = load i8*, i8** %_impzPtr
%zone11490 = bitcast i8* %tzone11489 to %mzone*

; let assign value to symbol cpx
%cpxPtr = alloca %Complexd*
%tzone11493 = load i8*, i8** %_impzPtr
%zone11494 = bitcast i8* %tzone11493 to %mzone*

; let assign value to symbol N
%NPtr = alloca double

; let value assignment
%n = select i1 true, i64 0, i64 0
store i64 %n, i64* %nPtr


; let value assignment
%k = select i1 true, i64 0, i64 0
store i64 %k, i64* %kPtr


; let value assignment
%tmp = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %tmp, double* %tmpPtr

%null11488 = bitcast i8* null to %Complexd*

; let value assignment
%cpx = select i1 true, %Complexd* %null11488, %Complexd* %null11488
store %Complexd* %cpx, %Complexd** %cpxPtr

%val11491 = load i64, i64* %lenPtr
%res11492 = call ccc double @i64tod(i64 %val11491)

; let value assignment
%N = select i1 true, double %res11492, double %res11492
store double %N, double* %NPtr

%val11495 = load %Complexd*, %Complexd** %outPtr
%val11496 = bitcast %Complexd* %val11495 to i8*
%val11497 = load i64, i64* %lenPtr
%val11498 = mul i64 %val11497, 16
%val11499 = bitcast i64 %val11498 to i64
%res11500 = call ccc i8* @memset(i8* %val11496, i32 0, i64 %val11499)
; setup loop
%val11503 = load i64, i64* %lenPtr
store i64 0, i64* %kPtr
%val11548 = load i64, i64* %kPtr
%num11549 = add i64 %val11503, %val11548
%comp11550 = icmp ult i64 %val11503, 1
br i1 %comp11550, label %after11501, label %loop11501

loop11501:
; do set!
%val11504 = load i64, i64* %kPtr
%val11505 = load %Complexd*, %Complexd** %outPtr
; pointer ref
%val11506 = getelementptr %Complexd, %Complexd* %val11505, i64 %val11504
store %Complexd* %val11506, %Complexd** %cpxPtr
; setup loop
%val11509 = load i64, i64* %lenPtr
store i64 0, i64* %nPtr
%val11544 = load i64, i64* %nPtr
%num11545 = add i64 %val11509, %val11544
%comp11546 = icmp ult i64 %val11509, 1
br i1 %comp11546, label %after11507, label %loop11507

loop11507:
; do set!
%val11510 = load i64, i64* %kPtr
%val11511 = load i64, i64* %nPtr
%val11512 = mul i64 %val11510, %val11511
%res11513 = call ccc double @i64tod(i64 %val11512)
%val11514 = load double, double* @TWOPI
%val11515 = load double, double* %NPtr
%val11516 = fdiv double %val11514, %val11515
%val11517 = fmul double %res11513, %val11516
store double %val11517, double* %tmpPtr
%val11518 = load %Complexd*, %Complexd** %cpxPtr
%val11519 = load %Complexd*, %Complexd** %cpxPtr
; tuple ref
%val11520 = getelementptr %Complexd, %Complexd* %val11519, i64 0, i32 0
%val11521 = load double, double* %val11520
%val11522 = load i64, i64* %nPtr
%val11523 = load double*, double** %inPtr
; pointer ref
%val11524 = getelementptr double, double* %val11523, i64 %val11522
%val11525 = load double, double* %val11524
%val11526 = load double, double* %tmpPtr
%val11527 = call double @llvm.cos.f64(double %val11526)
%val11528 = fmul double %val11525, %val11527
%val11529 = fadd double %val11521, %val11528
; set tuple
%val11530 = getelementptr %Complexd, %Complexd* %val11518, i64 0, i32 0
store double %val11529, double* %val11530
%val11531 = load %Complexd*, %Complexd** %cpxPtr
%val11532 = load %Complexd*, %Complexd** %cpxPtr
; tuple ref
%val11533 = getelementptr %Complexd, %Complexd* %val11532, i64 0, i32 1
%val11534 = load double, double* %val11533
%val11535 = load i64, i64* %nPtr
%val11536 = load double*, double** %inPtr
; pointer ref
%val11537 = getelementptr double, double* %val11536, i64 %val11535
%val11538 = load double, double* %val11537
%val11539 = load double, double* %tmpPtr
%val11540 = call double @llvm.sin.f64(double %val11539)
%val11541 = fmul double %val11538, %val11540
%val11542 = fsub double %val11534, %val11541
; set tuple
%val11543 = getelementptr %Complexd, %Complexd* %val11531, i64 0, i32 1
store double %val11542, double* %val11543
%loop_cnt11507 = load i64, i64* %nPtr
%next11507 = add i64 %loop_cnt11507, 1
store i64 %next11507, i64* %nPtr
%cmp11507 = icmp ult i64 %next11507, %num11545
br i1 %cmp11507, label %loop11507, label %after11507

after11507:
%loop_cnt11501 = load i64, i64* %kPtr
%next11501 = add i64 %loop_cnt11501, 1
store i64 %next11501, i64* %kPtr
%cmp11501 = icmp ult i64 %next11501, %num11549
br i1 %cmp11501, label %loop11501, label %after11501

after11501:
ret void
}
@gsxtmmath484 = hidden constant [102 x i8] c"dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** @dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11572 = load i8*, i8** %_impzPtr
%zone11573 = bitcast i8* %tzone11572 to %mzone*

; let assign value to symbol dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ
%dat_dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone11573, i64 8)
%dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQPtr = bitcast i8* %dat_dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ to { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}***
%tzone11553 = load i8*, i8** %_impzPtr
%zone11554 = bitcast i8* %tzone11553 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11554)
; malloc closure structure
%clsptr11555 = call i8* @llvm_zone_malloc(%mzone* %zone11554, i64 24)
%closure11556 = bitcast i8* %clsptr11555 to { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}*

; malloc environment structure
%envptr11557 = call i8* @llvm_zone_malloc(%mzone* %zone11554, i64 8)
%environment11558 = bitcast i8* %envptr11557 to {{i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}***}*

; malloc closure address table
%addytable11559 = call %clsvar* @new_address_table()
%var11560 = bitcast [49 x i8]* @gsxtmmath483 to i8*
%var11561 = bitcast [57 x i8]* @gsxtmmath435 to i8*
%addytable11562 = call %clsvar* @add_address_table(%mzone* %zone11554, i8* %var11560, i32 0, i8* %var11561, i32 3, %clsvar* %addytable11559)
%address-table11563 = bitcast %clsvar* %addytable11562 to i8*

; insert table, function and environment into closure struct
%closure.table11566 = getelementptr { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure11556, i32 0, i32 0
store i8* %address-table11563, i8** %closure.table11566
%closure.env11567 = getelementptr { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure11556, i32 0, i32 1
store i8* %envptr11557, i8** %closure.env11567
%closure.func11568 = getelementptr { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure11556, i32 0, i32 2
store void (i8*, i8*, double*, %Complexd*, i64)* @dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ__11480, void (i8*, i8*, double*, %Complexd*, i64)** %closure.func11568
%closure_size11569 = call i64 @llvm_zone_mark_size(%mzone* %zone11554)
call void @llvm_zone_ptr_set_size(i8* %clsptr11555, i64 %closure_size11569)
%wrapper_ptr11570 = call i8* @llvm_zone_malloc(%mzone* %zone11554, i64 8)
%closure_wrapper11571 = bitcast i8* %wrapper_ptr11570 to { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}**
store { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure11556, { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** %closure_wrapper11571

; let value assignment
%dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** %closure_wrapper11571, { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** %closure_wrapper11571
store { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** %dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ, { i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}*** %dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQPtr

; add data to environment
; don't need to alloc for env var dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ
%tmp_envptr11565 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}***}* %environment11558, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}*** %dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQPtr, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}**** %tmp_envptr11565


%val11574 = load {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}**, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}*** %dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** %val11574
}


@dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** @dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ(double* %arg_0,%Complexd* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, %Complexd*, i64)*,  void (i8*, i8*, double*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, %Complexd* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_native(double* %arg_0,%Complexd* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, %Complexd*, i64)*,  void (i8*, i8*, double*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, %Complexd* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11575 = bitcast [102 x i8]* @gsxtmmath484 to i8*
call i32 (i8*, ...) @printf(i8* %var11575)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var11576 = bitcast [102 x i8]* @gsxtmmath484 to i8*
call i32 (i8*, ...) @printf(i8* %var11576)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Complexd*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var11577 = bitcast [102 x i8]* @gsxtmmath484 to i8*
call i32 (i8*, ...) @printf(i8* %var11577)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, %Complexd*, i64)*,  void (i8*, i8*, double*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, %Complexd* %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, %Complexd*, i64}*
%arg_p_0 = getelementptr {double*, %Complexd*, i64}, {double*, %Complexd*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, %Complexd*, i64}, {double*, %Complexd*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load %Complexd*, %Complexd** %arg_p_1
%arg_p_2 = getelementptr {double*, %Complexd*, i64}, {double*, %Complexd*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @dft_adhoc_W3ZvaWQsZG91YmxlKixDb21wbGV4ZCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, %Complexd*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, %Complexd*, i64)*,  void (i8*, i8*, double*, %Complexd*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, %Complexd* %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath485 = hidden constant [50 x i8] c"idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ\00"
define dllexport fastcc void @idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ__11578(i8* %_impz,i8* %_impenv, %Complexd* %in, double* %out, i64 %len) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11579 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}***}*
%idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}***}* %impenv, i32 0, i32 0
%idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}***, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}**** %idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQPtr_

; setup arguments
%inPtr = alloca %Complexd*
store %Complexd* %in, %Complexd** %inPtr
%outPtr = alloca double*
store double* %out, double** %outPtr
%lenPtr = alloca i64
store i64 %len, i64* %lenPtr


%tzone11580 = load i8*, i8** %_impzPtr
%zone11581 = bitcast i8* %tzone11580 to %mzone*

; let assign value to symbol n
%nPtr = alloca i64
%tzone11582 = load i8*, i8** %_impzPtr
%zone11583 = bitcast i8* %tzone11582 to %mzone*

; let assign value to symbol k
%kPtr = alloca i64
%tzone11584 = load i8*, i8** %_impzPtr
%zone11585 = bitcast i8* %tzone11584 to %mzone*

; let assign value to symbol tmp
%tmpPtr = alloca double
%tzone11587 = load i8*, i8** %_impzPtr
%zone11588 = bitcast i8* %tzone11587 to %mzone*

; let assign value to symbol cpx
%cpxPtr = alloca %Complexd*
%tzone11591 = load i8*, i8** %_impzPtr
%zone11592 = bitcast i8* %tzone11591 to %mzone*

; let assign value to symbol N
%NPtr = alloca double

; let value assignment
%n = select i1 true, i64 0, i64 0
store i64 %n, i64* %nPtr


; let value assignment
%k = select i1 true, i64 0, i64 0
store i64 %k, i64* %kPtr


; let value assignment
%tmp = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %tmp, double* %tmpPtr

%null11586 = bitcast i8* null to %Complexd*

; let value assignment
%cpx = select i1 true, %Complexd* %null11586, %Complexd* %null11586
store %Complexd* %cpx, %Complexd** %cpxPtr

%val11589 = load i64, i64* %lenPtr
%res11590 = call ccc double @i64tod(i64 %val11589)

; let value assignment
%N = select i1 true, double %res11590, double %res11590
store double %N, double* %NPtr

; setup loop
%val11595 = load i64, i64* %lenPtr
store i64 0, i64* %nPtr
%val11647 = load i64, i64* %nPtr
%num11648 = add i64 %val11595, %val11647
%comp11649 = icmp ult i64 %val11595, 1
br i1 %comp11649, label %after11593, label %loop11593

loop11593:
%val11596 = load i64, i64* %nPtr
%val11597 = load double*, double** %outPtr
; set pointer
%val11598 = getelementptr double, double* %val11597, i64 %val11596
store double 0.00000000000000000000, double* %val11598
; setup loop
%val11601 = load i64, i64* %lenPtr
store i64 0, i64* %kPtr
%val11634 = load i64, i64* %kPtr
%num11635 = add i64 %val11601, %val11634
%comp11636 = icmp ult i64 %val11601, 1
br i1 %comp11636, label %after11599, label %loop11599

loop11599:
; do set!
%val11602 = load i64, i64* %kPtr
%val11603 = load %Complexd*, %Complexd** %inPtr
; pointer ref
%val11604 = getelementptr %Complexd, %Complexd* %val11603, i64 %val11602
store %Complexd* %val11604, %Complexd** %cpxPtr
; do set!
%val11605 = load i64, i64* %kPtr
%val11606 = load i64, i64* %nPtr
%val11607 = mul i64 %val11605, %val11606
%res11608 = call ccc double @i64tod(i64 %val11607)
%val11609 = load double, double* @TWOPI
%val11610 = load double, double* %NPtr
%val11611 = fdiv double %val11609, %val11610
%val11612 = fmul double %res11608, %val11611
store double %val11612, double* %tmpPtr
%val11613 = load i64, i64* %nPtr
%val11614 = load double*, double** %outPtr
%val11615 = load i64, i64* %nPtr
%val11616 = load double*, double** %outPtr
; pointer ref
%val11617 = getelementptr double, double* %val11616, i64 %val11615
%val11618 = load double, double* %val11617
%val11619 = load %Complexd*, %Complexd** %cpxPtr
; tuple ref
%val11620 = getelementptr %Complexd, %Complexd* %val11619, i64 0, i32 0
%val11621 = load double, double* %val11620
%val11622 = load double, double* %tmpPtr
%val11623 = call double @llvm.cos.f64(double %val11622)
%val11624 = fmul double %val11621, %val11623
%val11625 = load %Complexd*, %Complexd** %cpxPtr
; tuple ref
%val11626 = getelementptr %Complexd, %Complexd* %val11625, i64 0, i32 1
%val11627 = load double, double* %val11626
%val11628 = load double, double* %tmpPtr
%val11629 = call double @llvm.sin.f64(double %val11628)
%val11630 = fmul double %val11627, %val11629
%val11631 = fsub double %val11624, %val11630
%val11632 = fadd double %val11618, %val11631
; set pointer
%val11633 = getelementptr double, double* %val11614, i64 %val11613
store double %val11632, double* %val11633
%loop_cnt11599 = load i64, i64* %kPtr
%next11599 = add i64 %loop_cnt11599, 1
store i64 %next11599, i64* %kPtr
%cmp11599 = icmp ult i64 %next11599, %num11635
br i1 %cmp11599, label %loop11599, label %after11599

after11599:
%val11638 = load i64, i64* %nPtr
%val11639 = load double*, double** %outPtr
%val11640 = load i64, i64* %nPtr
%val11641 = load double*, double** %outPtr
; pointer ref
%val11642 = getelementptr double, double* %val11641, i64 %val11640
%val11643 = load double, double* %val11642
%val11644 = load double, double* %NPtr
%val11645 = fdiv double %val11643, %val11644
; set pointer
%val11646 = getelementptr double, double* %val11639, i64 %val11638
store double %val11645, double* %val11646
%loop_cnt11593 = load i64, i64* %nPtr
%next11593 = add i64 %loop_cnt11593, 1
store i64 %next11593, i64* %nPtr
%cmp11593 = icmp ult i64 %next11593, %num11648
br i1 %cmp11593, label %loop11593, label %after11593

after11593:
ret void
}
@gsxtmmath486 = hidden constant [103 x i8] c"idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** @idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11671 = load i8*, i8** %_impzPtr
%zone11672 = bitcast i8* %tzone11671 to %mzone*

; let assign value to symbol idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ
%dat_idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone11672, i64 8)
%idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQPtr = bitcast i8* %dat_idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ to { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}***
%tzone11652 = load i8*, i8** %_impzPtr
%zone11653 = bitcast i8* %tzone11652 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11653)
; malloc closure structure
%clsptr11654 = call i8* @llvm_zone_malloc(%mzone* %zone11653, i64 24)
%closure11655 = bitcast i8* %clsptr11654 to { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}*

; malloc environment structure
%envptr11656 = call i8* @llvm_zone_malloc(%mzone* %zone11653, i64 8)
%environment11657 = bitcast i8* %envptr11656 to {{i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}***}*

; malloc closure address table
%addytable11658 = call %clsvar* @new_address_table()
%var11659 = bitcast [50 x i8]* @gsxtmmath485 to i8*
%var11660 = bitcast [57 x i8]* @gsxtmmath447 to i8*
%addytable11661 = call %clsvar* @add_address_table(%mzone* %zone11653, i8* %var11659, i32 0, i8* %var11660, i32 3, %clsvar* %addytable11658)
%address-table11662 = bitcast %clsvar* %addytable11661 to i8*

; insert table, function and environment into closure struct
%closure.table11665 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure11655, i32 0, i32 0
store i8* %address-table11662, i8** %closure.table11665
%closure.env11666 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure11655, i32 0, i32 1
store i8* %envptr11656, i8** %closure.env11666
%closure.func11667 = getelementptr { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure11655, i32 0, i32 2
store void (i8*, i8*, %Complexd*, double*, i64)* @idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ__11578, void (i8*, i8*, %Complexd*, double*, i64)** %closure.func11667
%closure_size11668 = call i64 @llvm_zone_mark_size(%mzone* %zone11653)
call void @llvm_zone_ptr_set_size(i8* %clsptr11654, i64 %closure_size11668)
%wrapper_ptr11669 = call i8* @llvm_zone_malloc(%mzone* %zone11653, i64 8)
%closure_wrapper11670 = bitcast i8* %wrapper_ptr11669 to { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}**
store { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure11655, { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** %closure_wrapper11670

; let value assignment
%idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** %closure_wrapper11670, { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** %closure_wrapper11670
store { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** %idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ, { i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}*** %idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQPtr

; add data to environment
; don't need to alloc for env var idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ
%tmp_envptr11664 = getelementptr {{i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}***}* %environment11657, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}*** %idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQPtr, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}**** %tmp_envptr11664


%val11673 = load {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}**, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}*** %idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** %val11673
}


@idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** @idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ(%Complexd* %arg_0,double* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, double*, i64)*,  void (i8*, i8*, %Complexd*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, double* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_native(%Complexd* %arg_0,double* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, double*, i64)*,  void (i8*, i8*, %Complexd*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, double* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11674 = bitcast [103 x i8]* @gsxtmmath486 to i8*
call i32 (i8*, ...) @printf(i8* %var11674)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Complexd*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var11675 = bitcast [103 x i8]* @gsxtmmath486 to i8*
call i32 (i8*, ...) @printf(i8* %var11675)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to double*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var11676 = bitcast [103 x i8]* @gsxtmmath486 to i8*
call i32 (i8*, ...) @printf(i8* %var11676)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, double*, i64)*,  void (i8*, i8*, %Complexd*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, double* %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Complexd*, double*, i64}*
%arg_p_0 = getelementptr {%Complexd*, double*, i64}, {%Complexd*, double*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Complexd*, %Complexd** %arg_p_0
%arg_p_1 = getelementptr {%Complexd*, double*, i64}, {%Complexd*, double*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load double*, double** %arg_p_1
%arg_p_2 = getelementptr {%Complexd*, double*, i64}, {%Complexd*, double*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @idft_adhoc_W3ZvaWQsQ29tcGxleGQqLGRvdWJsZSosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, %Complexd*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Complexd*, double*, i64)*,  void (i8*, i8*, %Complexd*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Complexd* %arg_0, double* %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath487 = hidden constant [25 x i8] c"gaussr_adhoc_W2RvdWJsZV0\00"
@gsxtmmath488 = hidden constant [33 x i8] c"{i8*, i8*, double (i8*, i8*)*}**\00"
@gsxtmmath489 = hidden constant [6 x i8] c"phase\00"
@gsxtmmath490 = hidden constant [16 x i8] c"_anon_lambda_12\00"
define dllexport fastcc double @gaussr_adhoc_W2RvdWJsZV0__11677(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11680 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*)*}***, i64*, {i8*, i8*, double (i8*, i8*)*}***}*
%gaussr_adhoc_W2RvdWJsZV0Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*)*}***, i64*, {i8*, i8*, double (i8*, i8*)*}***}, {{i8*, i8*, double (i8*, i8*)*}***, i64*, {i8*, i8*, double (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%gaussr_adhoc_W2RvdWJsZV0Ptr = load {i8*, i8*, double (i8*, i8*)*}***, {i8*, i8*, double (i8*, i8*)*}**** %gaussr_adhoc_W2RvdWJsZV0Ptr_
%phasePtr_ = getelementptr {{i8*, i8*, double (i8*, i8*)*}***, i64*, {i8*, i8*, double (i8*, i8*)*}***}, {{i8*, i8*, double (i8*, i8*)*}***, i64*, {i8*, i8*, double (i8*, i8*)*}***}* %impenv, i32 0, i32 1
%phasePtr = load i64*, i64** %phasePtr_
%_anon_lambda_12Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*)*}***, i64*, {i8*, i8*, double (i8*, i8*)*}***}, {{i8*, i8*, double (i8*, i8*)*}***, i64*, {i8*, i8*, double (i8*, i8*)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_12Ptr = load {i8*, i8*, double (i8*, i8*)*}***, {i8*, i8*, double (i8*, i8*)*}**** %_anon_lambda_12Ptr_

; setup arguments


%tzone11682 = load i8*, i8** %_impzPtr
%zone11683 = bitcast i8* %tzone11682 to %mzone*

; let assign value to symbol u1
%u1Ptr = alloca double
%tzone11685 = load i8*, i8** %_impzPtr
%zone11686 = bitcast i8* %tzone11685 to %mzone*

; let assign value to symbol u2
%u2Ptr = alloca double
%tzone11690 = load i8*, i8** %_impzPtr
%zone11691 = bitcast i8* %tzone11690 to %mzone*

; let assign value to symbol v1
%v1Ptr = alloca double
%tzone11695 = load i8*, i8** %_impzPtr
%zone11696 = bitcast i8* %tzone11695 to %mzone*

; let assign value to symbol v2
%v2Ptr = alloca double
%tzone11704 = load i8*, i8** %_impzPtr
%zone11705 = bitcast i8* %tzone11704 to %mzone*

; let assign value to symbol s
%sPtr = alloca double
%res11681 = call ccc double @imp_randd()

; let value assignment
%u1 = select i1 true, double %res11681, double %res11681
store double %u1, double* %u1Ptr

%res11684 = call ccc double @imp_randd()

; let value assignment
%u2 = select i1 true, double %res11684, double %res11684
store double %u2, double* %u2Ptr

%val11687 = load double, double* %u1Ptr
%val11688 = fmul double 2.0000000000000000000, %val11687
%val11689 = fsub double %val11688, 1.0000000000000000000

; let value assignment
%v1 = select i1 true, double %val11689, double %val11689
store double %v1, double* %v1Ptr

%val11692 = load double, double* %u2Ptr
%val11693 = fmul double 2.0000000000000000000, %val11692
%val11694 = fsub double %val11693, 1.0000000000000000000

; let value assignment
%v2 = select i1 true, double %val11694, double %val11694
store double %v2, double* %v2Ptr

%val11697 = load double, double* %v1Ptr
%val11698 = load double, double* %v1Ptr
%val11699 = fmul double %val11697, %val11698
%val11700 = load double, double* %v2Ptr
%val11701 = load double, double* %v2Ptr
%val11702 = fmul double %val11700, %val11701
%val11703 = fadd double %val11699, %val11702

; let value assignment
%s = select i1 true, double %val11703, double %val11703
store double %s, double* %sPtr

; promote local stack var allocations
%tzone11757 = load i8*, i8** %_impzPtr
%zone11758 = bitcast i8* %tzone11757 to %mzone*
%ifptr11710 = alloca i1
%ifptr11715 = alloca i1
%ifptr11720 = alloca i1
%val11707 = load i64, i64* %phasePtr
%cmp11708 = icmp eq i64 %val11707, 0
br i1 %cmp11708, label %then11706, label %else11706

then11706:
%val11711 = load double, double* %sPtr
%cmp11712 = fcmp ugt double %val11711, 1.0000000000000000000
br i1 %cmp11712, label %then11710, label %else11710

then11710:
%val11713 = load double, double* %sPtr
%cmp11714 = fcmp ugt double %val11713, 1.0000000000000000000
store i1 %cmp11714, i1* %ifptr11710
br label %ifcont11710

else11710:
%val11716 = load double, double* %sPtr
%cmp11717 = fcmp ueq double %val11716, 0.00000000000000000000
br i1 %cmp11717, label %then11715, label %else11715

then11715:
%val11718 = load double, double* %sPtr
%cmp11719 = fcmp ueq double %val11718, 0.00000000000000000000
store i1 %cmp11719, i1* %ifptr11715
br label %ifcont11715

else11715:
%val11721 = load double, double* %sPtr
%cmp11722 = fcmp ueq double %val11721, 1.0000000000000000000
br i1 %cmp11722, label %then11720, label %else11720

then11720:
%val11723 = load double, double* %sPtr
%cmp11724 = fcmp ueq double %val11723, 1.0000000000000000000
store i1 %cmp11724, i1* %ifptr11720
br label %ifcont11720

else11720:
%res11725 = call ccc i1 @impc_false()
store i1 %res11725, i1* %ifptr11720
br label %ifcont11720

ifcont11720:
%ifres11726 = load i1, i1* %ifptr11720

store i1 %ifres11726, i1* %ifptr11715
br label %ifcont11715

ifcont11715:
%ifres11727 = load i1, i1* %ifptr11715

store i1 %ifres11727, i1* %ifptr11710
br label %ifcont11710

ifcont11710:
%ifres11728 = load i1, i1* %ifptr11710

br i1 %ifres11728, label %then11709, label %else11709

then11709:

; apply closure 
%vval11729 = load {i8*, i8*, double (i8*, i8*)*}**, {i8*, i8*, double (i8*, i8*)*}*** %gaussr_adhoc_W2RvdWJsZV0Ptr
%val11730 = load {i8*, i8*, double (i8*, i8*)*}*,{i8*, i8*, double (i8*, i8*)*}** %vval11729
%fPtr11731 = getelementptr {i8*, i8*, double (i8*, i8*)*}, {i8*, i8*, double (i8*, i8*)*}* %val11730, i32 0, i32 2
%ePtr11732 = getelementptr {i8*, i8*, double (i8*, i8*)*}, {i8*, i8*, double (i8*, i8*)*}* %val11730, i32 0, i32 1
%f11733 = load double (i8*, i8*)*, double (i8*, i8*)** %fPtr11731
%e11734 = load i8*, i8** %ePtr11732
%tzone11735 = load i8*, i8** %_impzPtr
%zone11736 = bitcast i8* %tzone11735 to %mzone*
%z11737 = bitcast %mzone* %zone11736 to i8*
%result11738 = tail call fastcc double %f11733(i8* %z11737, i8* %e11734)
ret double %result11738

else11709:
%val11739 = load double, double* %v1Ptr
%val11740 = load double, double* %sPtr
%val11741 = call double @llvm.log.f64(double %val11740)
%val11742 = fmul double -2.0000000000000000000, %val11741
%val11743 = load double, double* %sPtr
%val11744 = fdiv double %val11742, %val11743
%val11745 = call double @llvm.sqrt.f64(double %val11744)
%val11746 = fmul double %val11739, %val11745
ret double %val11746

else11706:
; do set!
%val11747 = load i64, i64* %phasePtr
%val11748 = sub i64 1, %val11747
store i64 %val11748, i64* %phasePtr
%val11749 = load double, double* %v2Ptr
%val11750 = load double, double* %sPtr
%val11751 = call double @llvm.log.f64(double %val11750)
%val11752 = fmul double -2.0000000000000000000, %val11751
%val11753 = load double, double* %sPtr
%val11754 = fdiv double %val11752, %val11753
%val11755 = call double @llvm.sqrt.f64(double %val11754)
%val11756 = fmul double %val11749, %val11755
ret double %val11756
}
define dllexport ccc {i8*, i8*, double (i8*, i8*)*}** @gaussr_adhoc_W2RvdWJsZV0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11791 = load i8*, i8** %_impzPtr
%zone11792 = bitcast i8* %tzone11791 to %mzone*

; let assign value to symbol gaussr_adhoc_W2RvdWJsZV0
%dat_gaussr_adhoc_W2RvdWJsZV0 = call i8* @llvm_zone_malloc(%mzone* %zone11792, i64 8)
%gaussr_adhoc_W2RvdWJsZV0Ptr = bitcast i8* %dat_gaussr_adhoc_W2RvdWJsZV0 to {i8*, i8*, double (i8*, i8*)*}***
%tzone11678 = load i8*, i8** %_impzPtr
%zone11679 = bitcast i8* %tzone11678 to %mzone*

; let assign value to symbol phase
%dat_phase = call i8* @llvm_zone_malloc(%mzone* %zone11679, i64 8)
%phasePtr = bitcast i8* %dat_phase to i64*

; let value assignment
%phase = select i1 true, i64 0, i64 0
store i64 %phase, i64* %phasePtr

%tzone11788 = load i8*, i8** %_impzPtr
%zone11789 = bitcast i8* %tzone11788 to %mzone*

; let assign value to symbol _anon_lambda_12
%dat__anon_lambda_12 = call i8* @llvm_zone_malloc(%mzone* %zone11789, i64 8)
%_anon_lambda_12Ptr = bitcast i8* %dat__anon_lambda_12 to { i8*, i8*, double (i8*, i8*)*}***
%tzone11759 = load i8*, i8** %_impzPtr
%zone11760 = bitcast i8* %tzone11759 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11760)
; malloc closure structure
%clsptr11761 = call i8* @llvm_zone_malloc(%mzone* %zone11760, i64 24)
%closure11762 = bitcast i8* %clsptr11761 to { i8*, i8*, double (i8*, i8*)*}*

; malloc environment structure
%envptr11763 = call i8* @llvm_zone_malloc(%mzone* %zone11760, i64 24)
%environment11764 = bitcast i8* %envptr11763 to {{i8*, i8*, double (i8*, i8*)*}***, i64*, {i8*, i8*, double (i8*, i8*)*}***}*

; malloc closure address table
%addytable11765 = call %clsvar* @new_address_table()
%var11766 = bitcast [25 x i8]* @gsxtmmath487 to i8*
%var11767 = bitcast [33 x i8]* @gsxtmmath488 to i8*
%addytable11768 = call %clsvar* @add_address_table(%mzone* %zone11760, i8* %var11766, i32 0, i8* %var11767, i32 3, %clsvar* %addytable11765)
%var11769 = bitcast [6 x i8]* @gsxtmmath489 to i8*
%var11770 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable11771 = call %clsvar* @add_address_table(%mzone* %zone11760, i8* %var11769, i32 8, i8* %var11770, i32 3, %clsvar* %addytable11768)
%var11772 = bitcast [16 x i8]* @gsxtmmath490 to i8*
%var11773 = bitcast [33 x i8]* @gsxtmmath488 to i8*
%addytable11774 = call %clsvar* @add_address_table(%mzone* %zone11760, i8* %var11772, i32 16, i8* %var11773, i32 3, %clsvar* %addytable11771)
%address-table11775 = bitcast %clsvar* %addytable11774 to i8*

; insert table, function and environment into closure struct
%closure.table11782 = getelementptr { i8*, i8*, double (i8*, i8*)*}, { i8*, i8*, double (i8*, i8*)*}* %closure11762, i32 0, i32 0
store i8* %address-table11775, i8** %closure.table11782
%closure.env11783 = getelementptr { i8*, i8*, double (i8*, i8*)*}, { i8*, i8*, double (i8*, i8*)*}* %closure11762, i32 0, i32 1
store i8* %envptr11763, i8** %closure.env11783
%closure.func11784 = getelementptr { i8*, i8*, double (i8*, i8*)*}, { i8*, i8*, double (i8*, i8*)*}* %closure11762, i32 0, i32 2
store double (i8*, i8*)* @gaussr_adhoc_W2RvdWJsZV0__11677, double (i8*, i8*)** %closure.func11784
%closure_size11785 = call i64 @llvm_zone_mark_size(%mzone* %zone11760)
call void @llvm_zone_ptr_set_size(i8* %clsptr11761, i64 %closure_size11785)
%wrapper_ptr11786 = call i8* @llvm_zone_malloc(%mzone* %zone11760, i64 8)
%closure_wrapper11787 = bitcast i8* %wrapper_ptr11786 to { i8*, i8*, double (i8*, i8*)*}**
store { i8*, i8*, double (i8*, i8*)*}* %closure11762, { i8*, i8*, double (i8*, i8*)*}** %closure_wrapper11787

; let value assignment
%_anon_lambda_12 = select i1 true, { i8*, i8*, double (i8*, i8*)*}** %closure_wrapper11787, { i8*, i8*, double (i8*, i8*)*}** %closure_wrapper11787
store { i8*, i8*, double (i8*, i8*)*}** %_anon_lambda_12, { i8*, i8*, double (i8*, i8*)*}*** %_anon_lambda_12Ptr

; add data to environment
; don't need to alloc for env var gaussr_adhoc_W2RvdWJsZV0
%tmp_envptr11777 = getelementptr {{i8*, i8*, double (i8*, i8*)*}***, i64*, {i8*, i8*, double (i8*, i8*)*}***}, {{i8*, i8*, double (i8*, i8*)*}***, i64*, {i8*, i8*, double (i8*, i8*)*}***}* %environment11764, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*)*}*** %gaussr_adhoc_W2RvdWJsZV0Ptr, {i8*, i8*, double (i8*, i8*)*}**** %tmp_envptr11777

; don't need to alloc for env var phase
%tmp_envptr11779 = getelementptr {{i8*, i8*, double (i8*, i8*)*}***, i64*, {i8*, i8*, double (i8*, i8*)*}***}, {{i8*, i8*, double (i8*, i8*)*}***, i64*, {i8*, i8*, double (i8*, i8*)*}***}* %environment11764, i32 0, i32 1
store i64* %phasePtr, i64** %tmp_envptr11779

; don't need to alloc for env var _anon_lambda_12
%tmp_envptr11781 = getelementptr {{i8*, i8*, double (i8*, i8*)*}***, i64*, {i8*, i8*, double (i8*, i8*)*}***}, {{i8*, i8*, double (i8*, i8*)*}***, i64*, {i8*, i8*, double (i8*, i8*)*}***}* %environment11764, i32 0, i32 2
store {i8*, i8*, double (i8*, i8*)*}*** %_anon_lambda_12Ptr, {i8*, i8*, double (i8*, i8*)*}**** %tmp_envptr11781


%val11790 = load {i8*, i8*, double (i8*, i8*)*}**, {i8*, i8*, double (i8*, i8*)*}*** %_anon_lambda_12Ptr

; let value assignment
%gaussr_adhoc_W2RvdWJsZV0 = select i1 true, {i8*, i8*, double (i8*, i8*)*}** %val11790, {i8*, i8*, double (i8*, i8*)*}** %val11790
store {i8*, i8*, double (i8*, i8*)*}** %gaussr_adhoc_W2RvdWJsZV0, {i8*, i8*, double (i8*, i8*)*}*** %gaussr_adhoc_W2RvdWJsZV0Ptr

%val11793 = load {i8*, i8*, double (i8*, i8*)*}**, {i8*, i8*, double (i8*, i8*)*}*** %gaussr_adhoc_W2RvdWJsZV0Ptr
ret {i8*, i8*, double (i8*, i8*)*}** %val11793
}


@gaussr_adhoc_W2RvdWJsZV0_var = dllexport global [1 x i8*] [ i8* null ]

@gaussr_adhoc_W2RvdWJsZV0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @gaussr_adhoc_W2RvdWJsZV0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @gaussr_adhoc_W2RvdWJsZV0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*)*}** @gaussr_adhoc_W2RvdWJsZV0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @gaussr_adhoc_W2RvdWJsZV0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @gaussr_adhoc_W2RvdWJsZV0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gaussr_adhoc_W2RvdWJsZV0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @gaussr_adhoc_W2RvdWJsZV0() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gaussr_adhoc_W2RvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*)*}**
%closure = load {i8*, i8*, double (i8*, i8*)*}*, {i8*, i8*, double (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*)*}, {i8*, i8*, double (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*)*}, {i8*, i8*, double (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*)*,  double (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee)
ret double %result
}


define dllexport ccc double @gaussr_adhoc_W2RvdWJsZV0_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gaussr_adhoc_W2RvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*)*}**
%closure = load {i8*, i8*, double (i8*, i8*)*}*, {i8*, i8*, double (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*)*}, {i8*, i8*, double (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*)*}, {i8*, i8*, double (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*)*,  double (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee)
ret double %result
}


define dllexport ccc i8*  @gaussr_adhoc_W2RvdWJsZV0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gaussr_adhoc_W2RvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*)*}**
%closure = load {i8*, i8*, double (i8*, i8*)*}*, {i8*, i8*, double (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*)*}, {i8*, i8*, double (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*)*}, {i8*, i8*, double (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*)*,  double (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @gaussr_adhoc_W2RvdWJsZV0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gaussr_adhoc_W2RvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*)*}**
%closure = load {i8*, i8*, double (i8*, i8*)*}*, {i8*, i8*, double (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*)*}, {i8*, i8*, double (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*)*}, {i8*, i8*, double (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*)*,  double (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath491 = hidden constant [24 x i8] c"gaussr_adhoc_W2Zsb2F0XQ\00"
@gsxtmmath492 = hidden constant [32 x i8] c"{i8*, i8*, float (i8*, i8*)*}**\00"
@gsxtmmath493 = hidden constant [16 x i8] c"_anon_lambda_13\00"
define dllexport fastcc float @gaussr_adhoc_W2Zsb2F0XQ__11794(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11797 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*)*}***, i64*, {i8*, i8*, float (i8*, i8*)*}***}*
%gaussr_adhoc_W2Zsb2F0XQPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*)*}***, i64*, {i8*, i8*, float (i8*, i8*)*}***}, {{i8*, i8*, float (i8*, i8*)*}***, i64*, {i8*, i8*, float (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%gaussr_adhoc_W2Zsb2F0XQPtr = load {i8*, i8*, float (i8*, i8*)*}***, {i8*, i8*, float (i8*, i8*)*}**** %gaussr_adhoc_W2Zsb2F0XQPtr_
%phasePtr_ = getelementptr {{i8*, i8*, float (i8*, i8*)*}***, i64*, {i8*, i8*, float (i8*, i8*)*}***}, {{i8*, i8*, float (i8*, i8*)*}***, i64*, {i8*, i8*, float (i8*, i8*)*}***}* %impenv, i32 0, i32 1
%phasePtr = load i64*, i64** %phasePtr_
%_anon_lambda_13Ptr_ = getelementptr {{i8*, i8*, float (i8*, i8*)*}***, i64*, {i8*, i8*, float (i8*, i8*)*}***}, {{i8*, i8*, float (i8*, i8*)*}***, i64*, {i8*, i8*, float (i8*, i8*)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_13Ptr = load {i8*, i8*, float (i8*, i8*)*}***, {i8*, i8*, float (i8*, i8*)*}**** %_anon_lambda_13Ptr_

; setup arguments


%tzone11799 = load i8*, i8** %_impzPtr
%zone11800 = bitcast i8* %tzone11799 to %mzone*

; let assign value to symbol u1
%u1Ptr = alloca float
%tzone11802 = load i8*, i8** %_impzPtr
%zone11803 = bitcast i8* %tzone11802 to %mzone*

; let assign value to symbol u2
%u2Ptr = alloca float
%tzone11807 = load i8*, i8** %_impzPtr
%zone11808 = bitcast i8* %tzone11807 to %mzone*

; let assign value to symbol v1
%v1Ptr = alloca float
%tzone11812 = load i8*, i8** %_impzPtr
%zone11813 = bitcast i8* %tzone11812 to %mzone*

; let assign value to symbol v2
%v2Ptr = alloca float
%tzone11821 = load i8*, i8** %_impzPtr
%zone11822 = bitcast i8* %tzone11821 to %mzone*

; let assign value to symbol s
%sPtr = alloca float
%res11798 = call ccc float @imp_randf()

; let value assignment
%u1 = select i1 true, float %res11798, float %res11798
store float %u1, float* %u1Ptr

%res11801 = call ccc float @imp_randf()

; let value assignment
%u2 = select i1 true, float %res11801, float %res11801
store float %u2, float* %u2Ptr

%val11804 = load float, float* %u1Ptr
%val11805 = fmul float 0x4000000000000000, %val11804
%val11806 = fsub float %val11805, 0x3ff0000000000000

; let value assignment
%v1 = select i1 true, float %val11806, float %val11806
store float %v1, float* %v1Ptr

%val11809 = load float, float* %u2Ptr
%val11810 = fmul float 0x4000000000000000, %val11809
%val11811 = fsub float %val11810, 0x3ff0000000000000

; let value assignment
%v2 = select i1 true, float %val11811, float %val11811
store float %v2, float* %v2Ptr

%val11814 = load float, float* %v1Ptr
%val11815 = load float, float* %v1Ptr
%val11816 = fmul float %val11814, %val11815
%val11817 = load float, float* %v2Ptr
%val11818 = load float, float* %v2Ptr
%val11819 = fmul float %val11817, %val11818
%val11820 = fadd float %val11816, %val11819

; let value assignment
%s = select i1 true, float %val11820, float %val11820
store float %s, float* %sPtr

; promote local stack var allocations
%tzone11874 = load i8*, i8** %_impzPtr
%zone11875 = bitcast i8* %tzone11874 to %mzone*
%ifptr11827 = alloca i1
%ifptr11832 = alloca i1
%ifptr11837 = alloca i1
%val11824 = load i64, i64* %phasePtr
%cmp11825 = icmp eq i64 %val11824, 0
br i1 %cmp11825, label %then11823, label %else11823

then11823:
%val11828 = load float, float* %sPtr
%cmp11829 = fcmp ugt float %val11828, 0x3ff0000000000000
br i1 %cmp11829, label %then11827, label %else11827

then11827:
%val11830 = load float, float* %sPtr
%cmp11831 = fcmp ugt float %val11830, 0x3ff0000000000000
store i1 %cmp11831, i1* %ifptr11827
br label %ifcont11827

else11827:
%val11833 = load float, float* %sPtr
%cmp11834 = fcmp ueq float %val11833, 0x0
br i1 %cmp11834, label %then11832, label %else11832

then11832:
%val11835 = load float, float* %sPtr
%cmp11836 = fcmp ueq float %val11835, 0x0
store i1 %cmp11836, i1* %ifptr11832
br label %ifcont11832

else11832:
%val11838 = load float, float* %sPtr
%cmp11839 = fcmp ueq float %val11838, 0x3ff0000000000000
br i1 %cmp11839, label %then11837, label %else11837

then11837:
%val11840 = load float, float* %sPtr
%cmp11841 = fcmp ueq float %val11840, 0x3ff0000000000000
store i1 %cmp11841, i1* %ifptr11837
br label %ifcont11837

else11837:
%res11842 = call ccc i1 @impc_false()
store i1 %res11842, i1* %ifptr11837
br label %ifcont11837

ifcont11837:
%ifres11843 = load i1, i1* %ifptr11837

store i1 %ifres11843, i1* %ifptr11832
br label %ifcont11832

ifcont11832:
%ifres11844 = load i1, i1* %ifptr11832

store i1 %ifres11844, i1* %ifptr11827
br label %ifcont11827

ifcont11827:
%ifres11845 = load i1, i1* %ifptr11827

br i1 %ifres11845, label %then11826, label %else11826

then11826:

; apply closure 
%vval11846 = load {i8*, i8*, float (i8*, i8*)*}**, {i8*, i8*, float (i8*, i8*)*}*** %gaussr_adhoc_W2Zsb2F0XQPtr
%val11847 = load {i8*, i8*, float (i8*, i8*)*}*,{i8*, i8*, float (i8*, i8*)*}** %vval11846
%fPtr11848 = getelementptr {i8*, i8*, float (i8*, i8*)*}, {i8*, i8*, float (i8*, i8*)*}* %val11847, i32 0, i32 2
%ePtr11849 = getelementptr {i8*, i8*, float (i8*, i8*)*}, {i8*, i8*, float (i8*, i8*)*}* %val11847, i32 0, i32 1
%f11850 = load float (i8*, i8*)*, float (i8*, i8*)** %fPtr11848
%e11851 = load i8*, i8** %ePtr11849
%tzone11852 = load i8*, i8** %_impzPtr
%zone11853 = bitcast i8* %tzone11852 to %mzone*
%z11854 = bitcast %mzone* %zone11853 to i8*
%result11855 = tail call fastcc float %f11850(i8* %z11854, i8* %e11851)
ret float %result11855

else11826:
%val11856 = load float, float* %v1Ptr
%val11857 = load float, float* %sPtr
%val11858 = call float @llvm.log.f32(float %val11857)
%val11859 = fmul float 0xc000000000000000, %val11858
%val11860 = load float, float* %sPtr
%val11861 = fdiv float %val11859, %val11860
%val11862 = call float @llvm.sqrt.f32(float %val11861)
%val11863 = fmul float %val11856, %val11862
ret float %val11863

else11823:
; do set!
%val11864 = load i64, i64* %phasePtr
%val11865 = sub i64 1, %val11864
store i64 %val11865, i64* %phasePtr
%val11866 = load float, float* %v2Ptr
%val11867 = load float, float* %sPtr
%val11868 = call float @llvm.log.f32(float %val11867)
%val11869 = fmul float 0xc000000000000000, %val11868
%val11870 = load float, float* %sPtr
%val11871 = fdiv float %val11869, %val11870
%val11872 = call float @llvm.sqrt.f32(float %val11871)
%val11873 = fmul float %val11866, %val11872
ret float %val11873
}
define dllexport ccc {i8*, i8*, float (i8*, i8*)*}** @gaussr_adhoc_W2Zsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11908 = load i8*, i8** %_impzPtr
%zone11909 = bitcast i8* %tzone11908 to %mzone*

; let assign value to symbol gaussr_adhoc_W2Zsb2F0XQ
%dat_gaussr_adhoc_W2Zsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone11909, i64 8)
%gaussr_adhoc_W2Zsb2F0XQPtr = bitcast i8* %dat_gaussr_adhoc_W2Zsb2F0XQ to {i8*, i8*, float (i8*, i8*)*}***
%tzone11795 = load i8*, i8** %_impzPtr
%zone11796 = bitcast i8* %tzone11795 to %mzone*

; let assign value to symbol phase
%dat_phase = call i8* @llvm_zone_malloc(%mzone* %zone11796, i64 8)
%phasePtr = bitcast i8* %dat_phase to i64*

; let value assignment
%phase = select i1 true, i64 0, i64 0
store i64 %phase, i64* %phasePtr

%tzone11905 = load i8*, i8** %_impzPtr
%zone11906 = bitcast i8* %tzone11905 to %mzone*

; let assign value to symbol _anon_lambda_13
%dat__anon_lambda_13 = call i8* @llvm_zone_malloc(%mzone* %zone11906, i64 8)
%_anon_lambda_13Ptr = bitcast i8* %dat__anon_lambda_13 to { i8*, i8*, float (i8*, i8*)*}***
%tzone11876 = load i8*, i8** %_impzPtr
%zone11877 = bitcast i8* %tzone11876 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11877)
; malloc closure structure
%clsptr11878 = call i8* @llvm_zone_malloc(%mzone* %zone11877, i64 24)
%closure11879 = bitcast i8* %clsptr11878 to { i8*, i8*, float (i8*, i8*)*}*

; malloc environment structure
%envptr11880 = call i8* @llvm_zone_malloc(%mzone* %zone11877, i64 24)
%environment11881 = bitcast i8* %envptr11880 to {{i8*, i8*, float (i8*, i8*)*}***, i64*, {i8*, i8*, float (i8*, i8*)*}***}*

; malloc closure address table
%addytable11882 = call %clsvar* @new_address_table()
%var11883 = bitcast [24 x i8]* @gsxtmmath491 to i8*
%var11884 = bitcast [32 x i8]* @gsxtmmath492 to i8*
%addytable11885 = call %clsvar* @add_address_table(%mzone* %zone11877, i8* %var11883, i32 0, i8* %var11884, i32 3, %clsvar* %addytable11882)
%var11886 = bitcast [6 x i8]* @gsxtmmath489 to i8*
%var11887 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable11888 = call %clsvar* @add_address_table(%mzone* %zone11877, i8* %var11886, i32 8, i8* %var11887, i32 3, %clsvar* %addytable11885)
%var11889 = bitcast [16 x i8]* @gsxtmmath493 to i8*
%var11890 = bitcast [32 x i8]* @gsxtmmath492 to i8*
%addytable11891 = call %clsvar* @add_address_table(%mzone* %zone11877, i8* %var11889, i32 16, i8* %var11890, i32 3, %clsvar* %addytable11888)
%address-table11892 = bitcast %clsvar* %addytable11891 to i8*

; insert table, function and environment into closure struct
%closure.table11899 = getelementptr { i8*, i8*, float (i8*, i8*)*}, { i8*, i8*, float (i8*, i8*)*}* %closure11879, i32 0, i32 0
store i8* %address-table11892, i8** %closure.table11899
%closure.env11900 = getelementptr { i8*, i8*, float (i8*, i8*)*}, { i8*, i8*, float (i8*, i8*)*}* %closure11879, i32 0, i32 1
store i8* %envptr11880, i8** %closure.env11900
%closure.func11901 = getelementptr { i8*, i8*, float (i8*, i8*)*}, { i8*, i8*, float (i8*, i8*)*}* %closure11879, i32 0, i32 2
store float (i8*, i8*)* @gaussr_adhoc_W2Zsb2F0XQ__11794, float (i8*, i8*)** %closure.func11901
%closure_size11902 = call i64 @llvm_zone_mark_size(%mzone* %zone11877)
call void @llvm_zone_ptr_set_size(i8* %clsptr11878, i64 %closure_size11902)
%wrapper_ptr11903 = call i8* @llvm_zone_malloc(%mzone* %zone11877, i64 8)
%closure_wrapper11904 = bitcast i8* %wrapper_ptr11903 to { i8*, i8*, float (i8*, i8*)*}**
store { i8*, i8*, float (i8*, i8*)*}* %closure11879, { i8*, i8*, float (i8*, i8*)*}** %closure_wrapper11904

; let value assignment
%_anon_lambda_13 = select i1 true, { i8*, i8*, float (i8*, i8*)*}** %closure_wrapper11904, { i8*, i8*, float (i8*, i8*)*}** %closure_wrapper11904
store { i8*, i8*, float (i8*, i8*)*}** %_anon_lambda_13, { i8*, i8*, float (i8*, i8*)*}*** %_anon_lambda_13Ptr

; add data to environment
; don't need to alloc for env var gaussr_adhoc_W2Zsb2F0XQ
%tmp_envptr11894 = getelementptr {{i8*, i8*, float (i8*, i8*)*}***, i64*, {i8*, i8*, float (i8*, i8*)*}***}, {{i8*, i8*, float (i8*, i8*)*}***, i64*, {i8*, i8*, float (i8*, i8*)*}***}* %environment11881, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*)*}*** %gaussr_adhoc_W2Zsb2F0XQPtr, {i8*, i8*, float (i8*, i8*)*}**** %tmp_envptr11894

; don't need to alloc for env var phase
%tmp_envptr11896 = getelementptr {{i8*, i8*, float (i8*, i8*)*}***, i64*, {i8*, i8*, float (i8*, i8*)*}***}, {{i8*, i8*, float (i8*, i8*)*}***, i64*, {i8*, i8*, float (i8*, i8*)*}***}* %environment11881, i32 0, i32 1
store i64* %phasePtr, i64** %tmp_envptr11896

; don't need to alloc for env var _anon_lambda_13
%tmp_envptr11898 = getelementptr {{i8*, i8*, float (i8*, i8*)*}***, i64*, {i8*, i8*, float (i8*, i8*)*}***}, {{i8*, i8*, float (i8*, i8*)*}***, i64*, {i8*, i8*, float (i8*, i8*)*}***}* %environment11881, i32 0, i32 2
store {i8*, i8*, float (i8*, i8*)*}*** %_anon_lambda_13Ptr, {i8*, i8*, float (i8*, i8*)*}**** %tmp_envptr11898


%val11907 = load {i8*, i8*, float (i8*, i8*)*}**, {i8*, i8*, float (i8*, i8*)*}*** %_anon_lambda_13Ptr

; let value assignment
%gaussr_adhoc_W2Zsb2F0XQ = select i1 true, {i8*, i8*, float (i8*, i8*)*}** %val11907, {i8*, i8*, float (i8*, i8*)*}** %val11907
store {i8*, i8*, float (i8*, i8*)*}** %gaussr_adhoc_W2Zsb2F0XQ, {i8*, i8*, float (i8*, i8*)*}*** %gaussr_adhoc_W2Zsb2F0XQPtr

%val11910 = load {i8*, i8*, float (i8*, i8*)*}**, {i8*, i8*, float (i8*, i8*)*}*** %gaussr_adhoc_W2Zsb2F0XQPtr
ret {i8*, i8*, float (i8*, i8*)*}** %val11910
}


@gaussr_adhoc_W2Zsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@gaussr_adhoc_W2Zsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @gaussr_adhoc_W2Zsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @gaussr_adhoc_W2Zsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*)*}** @gaussr_adhoc_W2Zsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @gaussr_adhoc_W2Zsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @gaussr_adhoc_W2Zsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gaussr_adhoc_W2Zsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @gaussr_adhoc_W2Zsb2F0XQ() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gaussr_adhoc_W2Zsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*)*}**
%closure = load {i8*, i8*, float (i8*, i8*)*}*, {i8*, i8*, float (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*)*}, {i8*, i8*, float (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*)*}, {i8*, i8*, float (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*)*,  float (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee)
ret float %result
}


define dllexport ccc float @gaussr_adhoc_W2Zsb2F0XQ_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gaussr_adhoc_W2Zsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*)*}**
%closure = load {i8*, i8*, float (i8*, i8*)*}*, {i8*, i8*, float (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*)*}, {i8*, i8*, float (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*)*}, {i8*, i8*, float (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*)*,  float (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee)
ret float %result
}


define dllexport ccc i8*  @gaussr_adhoc_W2Zsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gaussr_adhoc_W2Zsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*)*}**
%closure = load {i8*, i8*, float (i8*, i8*)*}*, {i8*, i8*, float (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*)*}, {i8*, i8*, float (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*)*}, {i8*, i8*, float (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*)*,  float (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @gaussr_adhoc_W2Zsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gaussr_adhoc_W2Zsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*)*}**
%closure = load {i8*, i8*, float (i8*, i8*)*}*, {i8*, i8*, float (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*)*}, {i8*, i8*, float (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*)*}, {i8*, i8*, float (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*)*,  float (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath494 = hidden constant [35 x i8] c"hanning_adhoc_W2RvdWJsZSxkb3VibGVd\00"
@gsxtmmath495 = hidden constant [41 x i8] c"{i8*, i8*, double (i8*, i8*, double)*}**\00"
define dllexport fastcc double @hanning_adhoc_W2RvdWJsZSxkb3VibGVd__11911(i8* %_impz,i8* %_impenv, double %t) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11912 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, double)*}***}*
%hanning_adhoc_W2RvdWJsZSxkb3VibGVdPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}***}, {{i8*, i8*, double (i8*, i8*, double)*}***}* %impenv, i32 0, i32 0
%hanning_adhoc_W2RvdWJsZSxkb3VibGVdPtr = load {i8*, i8*, double (i8*, i8*, double)*}***, {i8*, i8*, double (i8*, i8*, double)*}**** %hanning_adhoc_W2RvdWJsZSxkb3VibGVdPtr_

; setup arguments
%tPtr = alloca double
store double %t, double* %tPtr


%val11913 = load double, double* @TWOPI
%val11914 = load double, double* %tPtr
%val11915 = fmul double %val11913, %val11914
%val11916 = call double @llvm.cos.f64(double %val11915)
%val11917 = fmul double 0.50000000000000000000, %val11916
%val11918 = fsub double 0.50000000000000000000, %val11917
ret double %val11918
}
@gsxtmmath496 = hidden constant [88 x i8] c"hanning_adhoc_W2RvdWJsZSxkb3VibGVd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, double)*}** @hanning_adhoc_W2RvdWJsZSxkb3VibGVd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11938 = load i8*, i8** %_impzPtr
%zone11939 = bitcast i8* %tzone11938 to %mzone*

; let assign value to symbol hanning_adhoc_W2RvdWJsZSxkb3VibGVd
%dat_hanning_adhoc_W2RvdWJsZSxkb3VibGVd = call i8* @llvm_zone_malloc(%mzone* %zone11939, i64 8)
%hanning_adhoc_W2RvdWJsZSxkb3VibGVdPtr = bitcast i8* %dat_hanning_adhoc_W2RvdWJsZSxkb3VibGVd to { i8*, i8*, double (i8*, i8*, double)*}***
%tzone11919 = load i8*, i8** %_impzPtr
%zone11920 = bitcast i8* %tzone11919 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11920)
; malloc closure structure
%clsptr11921 = call i8* @llvm_zone_malloc(%mzone* %zone11920, i64 24)
%closure11922 = bitcast i8* %clsptr11921 to { i8*, i8*, double (i8*, i8*, double)*}*

; malloc environment structure
%envptr11923 = call i8* @llvm_zone_malloc(%mzone* %zone11920, i64 8)
%environment11924 = bitcast i8* %envptr11923 to {{i8*, i8*, double (i8*, i8*, double)*}***}*

; malloc closure address table
%addytable11925 = call %clsvar* @new_address_table()
%var11926 = bitcast [35 x i8]* @gsxtmmath494 to i8*
%var11927 = bitcast [41 x i8]* @gsxtmmath495 to i8*
%addytable11928 = call %clsvar* @add_address_table(%mzone* %zone11920, i8* %var11926, i32 0, i8* %var11927, i32 3, %clsvar* %addytable11925)
%address-table11929 = bitcast %clsvar* %addytable11928 to i8*

; insert table, function and environment into closure struct
%closure.table11932 = getelementptr { i8*, i8*, double (i8*, i8*, double)*}, { i8*, i8*, double (i8*, i8*, double)*}* %closure11922, i32 0, i32 0
store i8* %address-table11929, i8** %closure.table11932
%closure.env11933 = getelementptr { i8*, i8*, double (i8*, i8*, double)*}, { i8*, i8*, double (i8*, i8*, double)*}* %closure11922, i32 0, i32 1
store i8* %envptr11923, i8** %closure.env11933
%closure.func11934 = getelementptr { i8*, i8*, double (i8*, i8*, double)*}, { i8*, i8*, double (i8*, i8*, double)*}* %closure11922, i32 0, i32 2
store double (i8*, i8*, double)* @hanning_adhoc_W2RvdWJsZSxkb3VibGVd__11911, double (i8*, i8*, double)** %closure.func11934
%closure_size11935 = call i64 @llvm_zone_mark_size(%mzone* %zone11920)
call void @llvm_zone_ptr_set_size(i8* %clsptr11921, i64 %closure_size11935)
%wrapper_ptr11936 = call i8* @llvm_zone_malloc(%mzone* %zone11920, i64 8)
%closure_wrapper11937 = bitcast i8* %wrapper_ptr11936 to { i8*, i8*, double (i8*, i8*, double)*}**
store { i8*, i8*, double (i8*, i8*, double)*}* %closure11922, { i8*, i8*, double (i8*, i8*, double)*}** %closure_wrapper11937

; let value assignment
%hanning_adhoc_W2RvdWJsZSxkb3VibGVd = select i1 true, { i8*, i8*, double (i8*, i8*, double)*}** %closure_wrapper11937, { i8*, i8*, double (i8*, i8*, double)*}** %closure_wrapper11937
store { i8*, i8*, double (i8*, i8*, double)*}** %hanning_adhoc_W2RvdWJsZSxkb3VibGVd, { i8*, i8*, double (i8*, i8*, double)*}*** %hanning_adhoc_W2RvdWJsZSxkb3VibGVdPtr

; add data to environment
; don't need to alloc for env var hanning_adhoc_W2RvdWJsZSxkb3VibGVd
%tmp_envptr11931 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}***}, {{i8*, i8*, double (i8*, i8*, double)*}***}* %environment11924, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, double)*}*** %hanning_adhoc_W2RvdWJsZSxkb3VibGVdPtr, {i8*, i8*, double (i8*, i8*, double)*}**** %tmp_envptr11931


%val11940 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %hanning_adhoc_W2RvdWJsZSxkb3VibGVdPtr
ret {i8*, i8*, double (i8*, i8*, double)*}** %val11940
}


@hanning_adhoc_W2RvdWJsZSxkb3VibGVd_var = dllexport global [1 x i8*] [ i8* null ]

@hanning_adhoc_W2RvdWJsZSxkb3VibGVd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hanning_adhoc_W2RvdWJsZSxkb3VibGVd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hanning_adhoc_W2RvdWJsZSxkb3VibGVd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, double)*}** @hanning_adhoc_W2RvdWJsZSxkb3VibGVd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hanning_adhoc_W2RvdWJsZSxkb3VibGVd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hanning_adhoc_W2RvdWJsZSxkb3VibGVd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hanning_adhoc_W2RvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @hanning_adhoc_W2RvdWJsZSxkb3VibGVd(double %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hanning_adhoc_W2RvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double)*}*, {i8*, i8*, double (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double)*,  double (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0)
ret double %result
}


define dllexport ccc double @hanning_adhoc_W2RvdWJsZSxkb3VibGVd_native(double %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hanning_adhoc_W2RvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double)*}*, {i8*, i8*, double (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double)*,  double (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0)
ret double %result
}


define dllexport ccc i8*  @hanning_adhoc_W2RvdWJsZSxkb3VibGVd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11941 = bitcast [88 x i8]* @gsxtmmath496 to i8*
call i32 (i8*, ...) @printf(i8* %var11941)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc double @r64value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hanning_adhoc_W2RvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double)*}*, {i8*, i8*, double (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double)*,  double (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @hanning_adhoc_W2RvdWJsZSxkb3VibGVd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double}*
%arg_p_0 = getelementptr {double}, {double}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hanning_adhoc_W2RvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double)*}*, {i8*, i8*, double (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double)*,  double (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath497 = hidden constant [46 x i8] c"window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd\00"
@gsxtmmath498 = hidden constant [16 x i8] c"_anon_lambda_14\00"
define dllexport fastcc void @window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd__11942(i8* %_impz,i8* %_impenv, double* %window_buffer, i64 %window_length) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11945 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}*
%window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}* %impenv, i32 0, i32 0
%window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRdPtr = load {i8*, i8*, void (i8*, i8*, double*, i64)*}***, {i8*, i8*, void (i8*, i8*, double*, i64)*}**** %window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRdPtr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}* %impenv, i32 0, i32 1
%iPtr = load i64*, i64** %iPtr_
%_anon_lambda_14Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_14Ptr = load {i8*, i8*, void (i8*, i8*, double*, i64)*}***, {i8*, i8*, void (i8*, i8*, double*, i64)*}**** %_anon_lambda_14Ptr_

; setup arguments
%window_bufferPtr = alloca double*
store double* %window_buffer, double** %window_bufferPtr
%window_lengthPtr = alloca i64
store i64 %window_length, i64* %window_lengthPtr


; setup loop
%val11948 = load i64, i64* %window_lengthPtr
store i64 0, i64* %iPtr
%val11968 = load i64, i64* %iPtr
%num11969 = add i64 %val11948, %val11968
%comp11970 = icmp ult i64 %val11948, 1
br i1 %comp11970, label %after11946, label %loop11946

loop11946:
%val11949 = load i64, i64* %iPtr
%val11950 = load double*, double** %window_bufferPtr
%val11951 = load i64, i64* %iPtr
%val11952 = load double*, double** %window_bufferPtr
; pointer ref
%val11953 = getelementptr double, double* %val11952, i64 %val11951
%val11954 = load double, double* %val11953
%val11955 = load double, double* @TWOPI
%val11956 = load i64, i64* %iPtr
%res11957 = call ccc double @i64tod(i64 %val11956)
%val11958 = fmul double %val11955, %res11957
%val11959 = load i64, i64* %window_lengthPtr
%val11960 = sub i64 %val11959, 1
%res11961 = call ccc double @i64tod(i64 %val11960)
%val11962 = fdiv double %val11958, %res11961
%val11963 = call double @llvm.cos.f64(double %val11962)
%val11964 = fmul double 0.50000000000000000000, %val11963
%val11965 = fsub double 0.50000000000000000000, %val11964
%val11966 = fmul double %val11954, %val11965
; set pointer
%val11967 = getelementptr double, double* %val11950, i64 %val11949
store double %val11966, double* %val11967
%loop_cnt11946 = load i64, i64* %iPtr
%next11946 = add i64 %loop_cnt11946, 1
store i64 %next11946, i64* %iPtr
%cmp11946 = icmp ult i64 %next11946, %num11969
br i1 %cmp11946, label %loop11946, label %after11946

after11946:
ret void
}
@gsxtmmath499 = hidden constant [99 x i8] c"window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, i64)*}** @window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12005 = load i8*, i8** %_impzPtr
%zone12006 = bitcast i8* %tzone12005 to %mzone*

; let assign value to symbol window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd
%dat_window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone12006, i64 8)
%window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRdPtr = bitcast i8* %dat_window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd to {i8*, i8*, void (i8*, i8*, double*, i64)*}***
%tzone11943 = load i8*, i8** %_impzPtr
%zone11944 = bitcast i8* %tzone11943 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone11944, i64 8)
%iPtr = bitcast i8* %dat_i to i64*

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

%tzone12002 = load i8*, i8** %_impzPtr
%zone12003 = bitcast i8* %tzone12002 to %mzone*

; let assign value to symbol _anon_lambda_14
%dat__anon_lambda_14 = call i8* @llvm_zone_malloc(%mzone* %zone12003, i64 8)
%_anon_lambda_14Ptr = bitcast i8* %dat__anon_lambda_14 to { i8*, i8*, void (i8*, i8*, double*, i64)*}***
%tzone11973 = load i8*, i8** %_impzPtr
%zone11974 = bitcast i8* %tzone11973 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11974)
; malloc closure structure
%clsptr11975 = call i8* @llvm_zone_malloc(%mzone* %zone11974, i64 24)
%closure11976 = bitcast i8* %clsptr11975 to { i8*, i8*, void (i8*, i8*, double*, i64)*}*

; malloc environment structure
%envptr11977 = call i8* @llvm_zone_malloc(%mzone* %zone11974, i64 24)
%environment11978 = bitcast i8* %envptr11977 to {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}*

; malloc closure address table
%addytable11979 = call %clsvar* @new_address_table()
%var11980 = bitcast [46 x i8]* @gsxtmmath497 to i8*
%var11981 = bitcast [45 x i8]* @gsxtmmath63 to i8*
%addytable11982 = call %clsvar* @add_address_table(%mzone* %zone11974, i8* %var11980, i32 0, i8* %var11981, i32 3, %clsvar* %addytable11979)
%var11983 = bitcast [2 x i8]* @gsxtmmath93 to i8*
%var11984 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable11985 = call %clsvar* @add_address_table(%mzone* %zone11974, i8* %var11983, i32 8, i8* %var11984, i32 3, %clsvar* %addytable11982)
%var11986 = bitcast [16 x i8]* @gsxtmmath498 to i8*
%var11987 = bitcast [45 x i8]* @gsxtmmath63 to i8*
%addytable11988 = call %clsvar* @add_address_table(%mzone* %zone11974, i8* %var11986, i32 16, i8* %var11987, i32 3, %clsvar* %addytable11985)
%address-table11989 = bitcast %clsvar* %addytable11988 to i8*

; insert table, function and environment into closure struct
%closure.table11996 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64)*}, { i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure11976, i32 0, i32 0
store i8* %address-table11989, i8** %closure.table11996
%closure.env11997 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64)*}, { i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure11976, i32 0, i32 1
store i8* %envptr11977, i8** %closure.env11997
%closure.func11998 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64)*}, { i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure11976, i32 0, i32 2
store void (i8*, i8*, double*, i64)* @window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd__11942, void (i8*, i8*, double*, i64)** %closure.func11998
%closure_size11999 = call i64 @llvm_zone_mark_size(%mzone* %zone11974)
call void @llvm_zone_ptr_set_size(i8* %clsptr11975, i64 %closure_size11999)
%wrapper_ptr12000 = call i8* @llvm_zone_malloc(%mzone* %zone11974, i64 8)
%closure_wrapper12001 = bitcast i8* %wrapper_ptr12000 to { i8*, i8*, void (i8*, i8*, double*, i64)*}**
store { i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure11976, { i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure_wrapper12001

; let value assignment
%_anon_lambda_14 = select i1 true, { i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure_wrapper12001, { i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure_wrapper12001
store { i8*, i8*, void (i8*, i8*, double*, i64)*}** %_anon_lambda_14, { i8*, i8*, void (i8*, i8*, double*, i64)*}*** %_anon_lambda_14Ptr

; add data to environment
; don't need to alloc for env var window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd
%tmp_envptr11991 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}* %environment11978, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, i64)*}*** %window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRdPtr, {i8*, i8*, void (i8*, i8*, double*, i64)*}**** %tmp_envptr11991

; don't need to alloc for env var i
%tmp_envptr11993 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}* %environment11978, i32 0, i32 1
store i64* %iPtr, i64** %tmp_envptr11993

; don't need to alloc for env var _anon_lambda_14
%tmp_envptr11995 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}* %environment11978, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, double*, i64)*}*** %_anon_lambda_14Ptr, {i8*, i8*, void (i8*, i8*, double*, i64)*}**** %tmp_envptr11995


%val12004 = load {i8*, i8*, void (i8*, i8*, double*, i64)*}**, {i8*, i8*, void (i8*, i8*, double*, i64)*}*** %_anon_lambda_14Ptr

; let value assignment
%window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd = select i1 true, {i8*, i8*, void (i8*, i8*, double*, i64)*}** %val12004, {i8*, i8*, void (i8*, i8*, double*, i64)*}** %val12004
store {i8*, i8*, void (i8*, i8*, double*, i64)*}** %window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd, {i8*, i8*, void (i8*, i8*, double*, i64)*}*** %window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRdPtr

%val12007 = load {i8*, i8*, void (i8*, i8*, double*, i64)*}**, {i8*, i8*, void (i8*, i8*, double*, i64)*}*** %window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRdPtr
ret {i8*, i8*, void (i8*, i8*, double*, i64)*}** %val12007
}


@window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, i64)*}** @window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64)*,  void (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc void @window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_native(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64)*,  void (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc i8*  @window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12008 = bitcast [99 x i8]* @gsxtmmath499 to i8*
call i32 (i8*, ...) @printf(i8* %var12008)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12009 = bitcast [99 x i8]* @gsxtmmath499 to i8*
call i32 (i8*, ...) @printf(i8* %var12009)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64)*,  void (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, i64}*
%arg_p_0 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @window_hanning_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64)*,  void (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath500 = hidden constant [45 x i8] c"window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0\00"
@gsxtmmath501 = hidden constant [16 x i8] c"_anon_lambda_15\00"
define dllexport fastcc void @window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0__12010(i8* %_impz,i8* %_impenv, float* %window_buffer, i64 %window_length) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12013 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}*
%window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 0
%window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0Ptr = load {i8*, i8*, void (i8*, i8*, float*, i64)*}***, {i8*, i8*, void (i8*, i8*, float*, i64)*}**** %window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0Ptr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 1
%iPtr = load i64*, i64** %iPtr_
%_anon_lambda_15Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_15Ptr = load {i8*, i8*, void (i8*, i8*, float*, i64)*}***, {i8*, i8*, void (i8*, i8*, float*, i64)*}**** %_anon_lambda_15Ptr_

; setup arguments
%window_bufferPtr = alloca float*
store float* %window_buffer, float** %window_bufferPtr
%window_lengthPtr = alloca i64
store i64 %window_length, i64* %window_lengthPtr


; setup loop
%val12016 = load i64, i64* %window_lengthPtr
store i64 0, i64* %iPtr
%val12036 = load i64, i64* %iPtr
%num12037 = add i64 %val12016, %val12036
%comp12038 = icmp ult i64 %val12016, 1
br i1 %comp12038, label %after12014, label %loop12014

loop12014:
%val12017 = load i64, i64* %iPtr
%val12018 = load float*, float** %window_bufferPtr
%val12019 = load i64, i64* %iPtr
%val12020 = load float*, float** %window_bufferPtr
; pointer ref
%val12021 = getelementptr float, float* %val12020, i64 %val12019
%val12022 = load float, float* %val12021
%val12023 = load float, float* @TWOPIf
%val12024 = load i64, i64* %iPtr
%res12025 = call ccc float @i64tof(i64 %val12024)
%val12026 = fmul float %val12023, %res12025
%val12027 = load i64, i64* %window_lengthPtr
%val12028 = sub i64 %val12027, 1
%res12029 = call ccc float @i64tof(i64 %val12028)
%val12030 = fdiv float %val12026, %res12029
%val12031 = call float @llvm.cos.f32(float %val12030)
%val12032 = fmul float 0x3fe0000000000000, %val12031
%val12033 = fsub float 0x3fe0000000000000, %val12032
%val12034 = fmul float %val12022, %val12033
; set pointer
%val12035 = getelementptr float, float* %val12018, i64 %val12017
store float %val12034, float* %val12035
%loop_cnt12014 = load i64, i64* %iPtr
%next12014 = add i64 %loop_cnt12014, 1
store i64 %next12014, i64* %iPtr
%cmp12014 = icmp ult i64 %next12014, %num12037
br i1 %cmp12014, label %loop12014, label %after12014

after12014:
ret void
}
@gsxtmmath502 = hidden constant [98 x i8] c"window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, i64)*}** @window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12073 = load i8*, i8** %_impzPtr
%zone12074 = bitcast i8* %tzone12073 to %mzone*

; let assign value to symbol window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0
%dat_window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone12074, i64 8)
%window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0Ptr = bitcast i8* %dat_window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0 to {i8*, i8*, void (i8*, i8*, float*, i64)*}***
%tzone12011 = load i8*, i8** %_impzPtr
%zone12012 = bitcast i8* %tzone12011 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone12012, i64 8)
%iPtr = bitcast i8* %dat_i to i64*

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

%tzone12070 = load i8*, i8** %_impzPtr
%zone12071 = bitcast i8* %tzone12070 to %mzone*

; let assign value to symbol _anon_lambda_15
%dat__anon_lambda_15 = call i8* @llvm_zone_malloc(%mzone* %zone12071, i64 8)
%_anon_lambda_15Ptr = bitcast i8* %dat__anon_lambda_15 to { i8*, i8*, void (i8*, i8*, float*, i64)*}***
%tzone12041 = load i8*, i8** %_impzPtr
%zone12042 = bitcast i8* %tzone12041 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12042)
; malloc closure structure
%clsptr12043 = call i8* @llvm_zone_malloc(%mzone* %zone12042, i64 24)
%closure12044 = bitcast i8* %clsptr12043 to { i8*, i8*, void (i8*, i8*, float*, i64)*}*

; malloc environment structure
%envptr12045 = call i8* @llvm_zone_malloc(%mzone* %zone12042, i64 24)
%environment12046 = bitcast i8* %envptr12045 to {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}*

; malloc closure address table
%addytable12047 = call %clsvar* @new_address_table()
%var12048 = bitcast [45 x i8]* @gsxtmmath500 to i8*
%var12049 = bitcast [44 x i8]* @gsxtmmath57 to i8*
%addytable12050 = call %clsvar* @add_address_table(%mzone* %zone12042, i8* %var12048, i32 0, i8* %var12049, i32 3, %clsvar* %addytable12047)
%var12051 = bitcast [2 x i8]* @gsxtmmath93 to i8*
%var12052 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable12053 = call %clsvar* @add_address_table(%mzone* %zone12042, i8* %var12051, i32 8, i8* %var12052, i32 3, %clsvar* %addytable12050)
%var12054 = bitcast [16 x i8]* @gsxtmmath501 to i8*
%var12055 = bitcast [44 x i8]* @gsxtmmath57 to i8*
%addytable12056 = call %clsvar* @add_address_table(%mzone* %zone12042, i8* %var12054, i32 16, i8* %var12055, i32 3, %clsvar* %addytable12053)
%address-table12057 = bitcast %clsvar* %addytable12056 to i8*

; insert table, function and environment into closure struct
%closure.table12064 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure12044, i32 0, i32 0
store i8* %address-table12057, i8** %closure.table12064
%closure.env12065 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure12044, i32 0, i32 1
store i8* %envptr12045, i8** %closure.env12065
%closure.func12066 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure12044, i32 0, i32 2
store void (i8*, i8*, float*, i64)* @window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0__12010, void (i8*, i8*, float*, i64)** %closure.func12066
%closure_size12067 = call i64 @llvm_zone_mark_size(%mzone* %zone12042)
call void @llvm_zone_ptr_set_size(i8* %clsptr12043, i64 %closure_size12067)
%wrapper_ptr12068 = call i8* @llvm_zone_malloc(%mzone* %zone12042, i64 8)
%closure_wrapper12069 = bitcast i8* %wrapper_ptr12068 to { i8*, i8*, void (i8*, i8*, float*, i64)*}**
store { i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure12044, { i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure_wrapper12069

; let value assignment
%_anon_lambda_15 = select i1 true, { i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure_wrapper12069, { i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure_wrapper12069
store { i8*, i8*, void (i8*, i8*, float*, i64)*}** %_anon_lambda_15, { i8*, i8*, void (i8*, i8*, float*, i64)*}*** %_anon_lambda_15Ptr

; add data to environment
; don't need to alloc for env var window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0
%tmp_envptr12059 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}* %environment12046, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, i64)*}*** %window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0Ptr, {i8*, i8*, void (i8*, i8*, float*, i64)*}**** %tmp_envptr12059

; don't need to alloc for env var i
%tmp_envptr12061 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}* %environment12046, i32 0, i32 1
store i64* %iPtr, i64** %tmp_envptr12061

; don't need to alloc for env var _anon_lambda_15
%tmp_envptr12063 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}* %environment12046, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, float*, i64)*}*** %_anon_lambda_15Ptr, {i8*, i8*, void (i8*, i8*, float*, i64)*}**** %tmp_envptr12063


%val12072 = load {i8*, i8*, void (i8*, i8*, float*, i64)*}**, {i8*, i8*, void (i8*, i8*, float*, i64)*}*** %_anon_lambda_15Ptr

; let value assignment
%window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0 = select i1 true, {i8*, i8*, void (i8*, i8*, float*, i64)*}** %val12072, {i8*, i8*, void (i8*, i8*, float*, i64)*}** %val12072
store {i8*, i8*, void (i8*, i8*, float*, i64)*}** %window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0, {i8*, i8*, void (i8*, i8*, float*, i64)*}*** %window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0Ptr

%val12075 = load {i8*, i8*, void (i8*, i8*, float*, i64)*}**, {i8*, i8*, void (i8*, i8*, float*, i64)*}*** %window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0Ptr
ret {i8*, i8*, void (i8*, i8*, float*, i64)*}** %val12075
}


@window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, i64)*}** @window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64)*,  void (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc void @window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_native(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64)*,  void (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc i8*  @window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12076 = bitcast [98 x i8]* @gsxtmmath502 to i8*
call i32 (i8*, ...) @printf(i8* %var12076)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12077 = bitcast [98 x i8]* @gsxtmmath502 to i8*
call i32 (i8*, ...) @printf(i8* %var12077)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64)*,  void (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64}*
%arg_p_0 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @window_hanning_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64)*,  void (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath503 = hidden constant [35 x i8] c"hamming_adhoc_W2RvdWJsZSxkb3VibGVd\00"
define dllexport fastcc double @hamming_adhoc_W2RvdWJsZSxkb3VibGVd__12078(i8* %_impz,i8* %_impenv, double %t) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12079 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, double)*}***}*
%hamming_adhoc_W2RvdWJsZSxkb3VibGVdPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}***}, {{i8*, i8*, double (i8*, i8*, double)*}***}* %impenv, i32 0, i32 0
%hamming_adhoc_W2RvdWJsZSxkb3VibGVdPtr = load {i8*, i8*, double (i8*, i8*, double)*}***, {i8*, i8*, double (i8*, i8*, double)*}**** %hamming_adhoc_W2RvdWJsZSxkb3VibGVdPtr_

; setup arguments
%tPtr = alloca double
store double %t, double* %tPtr


%val12080 = load double, double* @TWOPI
%val12081 = load double, double* %tPtr
%val12082 = fmul double %val12080, %val12081
%val12083 = call double @llvm.cos.f64(double %val12082)
%val12084 = fmul double 0.46000000000000001998, %val12083
%val12085 = fsub double 0.54000000000000003553, %val12084
ret double %val12085
}
@gsxtmmath504 = hidden constant [88 x i8] c"hamming_adhoc_W2RvdWJsZSxkb3VibGVd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, double)*}** @hamming_adhoc_W2RvdWJsZSxkb3VibGVd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12105 = load i8*, i8** %_impzPtr
%zone12106 = bitcast i8* %tzone12105 to %mzone*

; let assign value to symbol hamming_adhoc_W2RvdWJsZSxkb3VibGVd
%dat_hamming_adhoc_W2RvdWJsZSxkb3VibGVd = call i8* @llvm_zone_malloc(%mzone* %zone12106, i64 8)
%hamming_adhoc_W2RvdWJsZSxkb3VibGVdPtr = bitcast i8* %dat_hamming_adhoc_W2RvdWJsZSxkb3VibGVd to { i8*, i8*, double (i8*, i8*, double)*}***
%tzone12086 = load i8*, i8** %_impzPtr
%zone12087 = bitcast i8* %tzone12086 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12087)
; malloc closure structure
%clsptr12088 = call i8* @llvm_zone_malloc(%mzone* %zone12087, i64 24)
%closure12089 = bitcast i8* %clsptr12088 to { i8*, i8*, double (i8*, i8*, double)*}*

; malloc environment structure
%envptr12090 = call i8* @llvm_zone_malloc(%mzone* %zone12087, i64 8)
%environment12091 = bitcast i8* %envptr12090 to {{i8*, i8*, double (i8*, i8*, double)*}***}*

; malloc closure address table
%addytable12092 = call %clsvar* @new_address_table()
%var12093 = bitcast [35 x i8]* @gsxtmmath503 to i8*
%var12094 = bitcast [41 x i8]* @gsxtmmath495 to i8*
%addytable12095 = call %clsvar* @add_address_table(%mzone* %zone12087, i8* %var12093, i32 0, i8* %var12094, i32 3, %clsvar* %addytable12092)
%address-table12096 = bitcast %clsvar* %addytable12095 to i8*

; insert table, function and environment into closure struct
%closure.table12099 = getelementptr { i8*, i8*, double (i8*, i8*, double)*}, { i8*, i8*, double (i8*, i8*, double)*}* %closure12089, i32 0, i32 0
store i8* %address-table12096, i8** %closure.table12099
%closure.env12100 = getelementptr { i8*, i8*, double (i8*, i8*, double)*}, { i8*, i8*, double (i8*, i8*, double)*}* %closure12089, i32 0, i32 1
store i8* %envptr12090, i8** %closure.env12100
%closure.func12101 = getelementptr { i8*, i8*, double (i8*, i8*, double)*}, { i8*, i8*, double (i8*, i8*, double)*}* %closure12089, i32 0, i32 2
store double (i8*, i8*, double)* @hamming_adhoc_W2RvdWJsZSxkb3VibGVd__12078, double (i8*, i8*, double)** %closure.func12101
%closure_size12102 = call i64 @llvm_zone_mark_size(%mzone* %zone12087)
call void @llvm_zone_ptr_set_size(i8* %clsptr12088, i64 %closure_size12102)
%wrapper_ptr12103 = call i8* @llvm_zone_malloc(%mzone* %zone12087, i64 8)
%closure_wrapper12104 = bitcast i8* %wrapper_ptr12103 to { i8*, i8*, double (i8*, i8*, double)*}**
store { i8*, i8*, double (i8*, i8*, double)*}* %closure12089, { i8*, i8*, double (i8*, i8*, double)*}** %closure_wrapper12104

; let value assignment
%hamming_adhoc_W2RvdWJsZSxkb3VibGVd = select i1 true, { i8*, i8*, double (i8*, i8*, double)*}** %closure_wrapper12104, { i8*, i8*, double (i8*, i8*, double)*}** %closure_wrapper12104
store { i8*, i8*, double (i8*, i8*, double)*}** %hamming_adhoc_W2RvdWJsZSxkb3VibGVd, { i8*, i8*, double (i8*, i8*, double)*}*** %hamming_adhoc_W2RvdWJsZSxkb3VibGVdPtr

; add data to environment
; don't need to alloc for env var hamming_adhoc_W2RvdWJsZSxkb3VibGVd
%tmp_envptr12098 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}***}, {{i8*, i8*, double (i8*, i8*, double)*}***}* %environment12091, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, double)*}*** %hamming_adhoc_W2RvdWJsZSxkb3VibGVdPtr, {i8*, i8*, double (i8*, i8*, double)*}**** %tmp_envptr12098


%val12107 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %hamming_adhoc_W2RvdWJsZSxkb3VibGVdPtr
ret {i8*, i8*, double (i8*, i8*, double)*}** %val12107
}


@hamming_adhoc_W2RvdWJsZSxkb3VibGVd_var = dllexport global [1 x i8*] [ i8* null ]

@hamming_adhoc_W2RvdWJsZSxkb3VibGVd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hamming_adhoc_W2RvdWJsZSxkb3VibGVd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hamming_adhoc_W2RvdWJsZSxkb3VibGVd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, double)*}** @hamming_adhoc_W2RvdWJsZSxkb3VibGVd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hamming_adhoc_W2RvdWJsZSxkb3VibGVd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hamming_adhoc_W2RvdWJsZSxkb3VibGVd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hamming_adhoc_W2RvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @hamming_adhoc_W2RvdWJsZSxkb3VibGVd(double %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hamming_adhoc_W2RvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double)*}*, {i8*, i8*, double (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double)*,  double (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0)
ret double %result
}


define dllexport ccc double @hamming_adhoc_W2RvdWJsZSxkb3VibGVd_native(double %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hamming_adhoc_W2RvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double)*}*, {i8*, i8*, double (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double)*,  double (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0)
ret double %result
}


define dllexport ccc i8*  @hamming_adhoc_W2RvdWJsZSxkb3VibGVd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12108 = bitcast [88 x i8]* @gsxtmmath504 to i8*
call i32 (i8*, ...) @printf(i8* %var12108)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc double @r64value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hamming_adhoc_W2RvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double)*}*, {i8*, i8*, double (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double)*,  double (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @hamming_adhoc_W2RvdWJsZSxkb3VibGVd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double}*
%arg_p_0 = getelementptr {double}, {double}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hamming_adhoc_W2RvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double)*}*, {i8*, i8*, double (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double)*,  double (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath505 = hidden constant [46 x i8] c"window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd\00"
@gsxtmmath506 = hidden constant [16 x i8] c"_anon_lambda_16\00"
define dllexport fastcc void @window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd__12109(i8* %_impz,i8* %_impenv, double* %window_buffer, i64 %window_length) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12112 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}*
%window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}* %impenv, i32 0, i32 0
%window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRdPtr = load {i8*, i8*, void (i8*, i8*, double*, i64)*}***, {i8*, i8*, void (i8*, i8*, double*, i64)*}**** %window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRdPtr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}* %impenv, i32 0, i32 1
%iPtr = load i64*, i64** %iPtr_
%_anon_lambda_16Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_16Ptr = load {i8*, i8*, void (i8*, i8*, double*, i64)*}***, {i8*, i8*, void (i8*, i8*, double*, i64)*}**** %_anon_lambda_16Ptr_

; setup arguments
%window_bufferPtr = alloca double*
store double* %window_buffer, double** %window_bufferPtr
%window_lengthPtr = alloca i64
store i64 %window_length, i64* %window_lengthPtr


; setup loop
%val12115 = load i64, i64* %window_lengthPtr
store i64 0, i64* %iPtr
%val12135 = load i64, i64* %iPtr
%num12136 = add i64 %val12115, %val12135
%comp12137 = icmp ult i64 %val12115, 1
br i1 %comp12137, label %after12113, label %loop12113

loop12113:
%val12116 = load i64, i64* %iPtr
%val12117 = load double*, double** %window_bufferPtr
%val12118 = load i64, i64* %iPtr
%val12119 = load double*, double** %window_bufferPtr
; pointer ref
%val12120 = getelementptr double, double* %val12119, i64 %val12118
%val12121 = load double, double* %val12120
%val12122 = load double, double* @TWOPI
%val12123 = load i64, i64* %iPtr
%res12124 = call ccc double @i64tod(i64 %val12123)
%val12125 = fmul double %val12122, %res12124
%val12126 = load i64, i64* %window_lengthPtr
%val12127 = sub i64 %val12126, 1
%res12128 = call ccc double @i64tod(i64 %val12127)
%val12129 = fdiv double %val12125, %res12128
%val12130 = call double @llvm.cos.f64(double %val12129)
%val12131 = fmul double 0.46000000000000001998, %val12130
%val12132 = fsub double 0.54000000000000003553, %val12131
%val12133 = fmul double %val12121, %val12132
; set pointer
%val12134 = getelementptr double, double* %val12117, i64 %val12116
store double %val12133, double* %val12134
%loop_cnt12113 = load i64, i64* %iPtr
%next12113 = add i64 %loop_cnt12113, 1
store i64 %next12113, i64* %iPtr
%cmp12113 = icmp ult i64 %next12113, %num12136
br i1 %cmp12113, label %loop12113, label %after12113

after12113:
ret void
}
@gsxtmmath507 = hidden constant [99 x i8] c"window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double*, i64)*}** @window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12172 = load i8*, i8** %_impzPtr
%zone12173 = bitcast i8* %tzone12172 to %mzone*

; let assign value to symbol window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd
%dat_window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone12173, i64 8)
%window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRdPtr = bitcast i8* %dat_window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd to {i8*, i8*, void (i8*, i8*, double*, i64)*}***
%tzone12110 = load i8*, i8** %_impzPtr
%zone12111 = bitcast i8* %tzone12110 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone12111, i64 8)
%iPtr = bitcast i8* %dat_i to i64*

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

%tzone12169 = load i8*, i8** %_impzPtr
%zone12170 = bitcast i8* %tzone12169 to %mzone*

; let assign value to symbol _anon_lambda_16
%dat__anon_lambda_16 = call i8* @llvm_zone_malloc(%mzone* %zone12170, i64 8)
%_anon_lambda_16Ptr = bitcast i8* %dat__anon_lambda_16 to { i8*, i8*, void (i8*, i8*, double*, i64)*}***
%tzone12140 = load i8*, i8** %_impzPtr
%zone12141 = bitcast i8* %tzone12140 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12141)
; malloc closure structure
%clsptr12142 = call i8* @llvm_zone_malloc(%mzone* %zone12141, i64 24)
%closure12143 = bitcast i8* %clsptr12142 to { i8*, i8*, void (i8*, i8*, double*, i64)*}*

; malloc environment structure
%envptr12144 = call i8* @llvm_zone_malloc(%mzone* %zone12141, i64 24)
%environment12145 = bitcast i8* %envptr12144 to {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}*

; malloc closure address table
%addytable12146 = call %clsvar* @new_address_table()
%var12147 = bitcast [46 x i8]* @gsxtmmath505 to i8*
%var12148 = bitcast [45 x i8]* @gsxtmmath63 to i8*
%addytable12149 = call %clsvar* @add_address_table(%mzone* %zone12141, i8* %var12147, i32 0, i8* %var12148, i32 3, %clsvar* %addytable12146)
%var12150 = bitcast [2 x i8]* @gsxtmmath93 to i8*
%var12151 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable12152 = call %clsvar* @add_address_table(%mzone* %zone12141, i8* %var12150, i32 8, i8* %var12151, i32 3, %clsvar* %addytable12149)
%var12153 = bitcast [16 x i8]* @gsxtmmath506 to i8*
%var12154 = bitcast [45 x i8]* @gsxtmmath63 to i8*
%addytable12155 = call %clsvar* @add_address_table(%mzone* %zone12141, i8* %var12153, i32 16, i8* %var12154, i32 3, %clsvar* %addytable12152)
%address-table12156 = bitcast %clsvar* %addytable12155 to i8*

; insert table, function and environment into closure struct
%closure.table12163 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64)*}, { i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure12143, i32 0, i32 0
store i8* %address-table12156, i8** %closure.table12163
%closure.env12164 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64)*}, { i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure12143, i32 0, i32 1
store i8* %envptr12144, i8** %closure.env12164
%closure.func12165 = getelementptr { i8*, i8*, void (i8*, i8*, double*, i64)*}, { i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure12143, i32 0, i32 2
store void (i8*, i8*, double*, i64)* @window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd__12109, void (i8*, i8*, double*, i64)** %closure.func12165
%closure_size12166 = call i64 @llvm_zone_mark_size(%mzone* %zone12141)
call void @llvm_zone_ptr_set_size(i8* %clsptr12142, i64 %closure_size12166)
%wrapper_ptr12167 = call i8* @llvm_zone_malloc(%mzone* %zone12141, i64 8)
%closure_wrapper12168 = bitcast i8* %wrapper_ptr12167 to { i8*, i8*, void (i8*, i8*, double*, i64)*}**
store { i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure12143, { i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure_wrapper12168

; let value assignment
%_anon_lambda_16 = select i1 true, { i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure_wrapper12168, { i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure_wrapper12168
store { i8*, i8*, void (i8*, i8*, double*, i64)*}** %_anon_lambda_16, { i8*, i8*, void (i8*, i8*, double*, i64)*}*** %_anon_lambda_16Ptr

; add data to environment
; don't need to alloc for env var window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd
%tmp_envptr12158 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}* %environment12145, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double*, i64)*}*** %window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRdPtr, {i8*, i8*, void (i8*, i8*, double*, i64)*}**** %tmp_envptr12158

; don't need to alloc for env var i
%tmp_envptr12160 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}* %environment12145, i32 0, i32 1
store i64* %iPtr, i64** %tmp_envptr12160

; don't need to alloc for env var _anon_lambda_16
%tmp_envptr12162 = getelementptr {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, double*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, double*, i64)*}***}* %environment12145, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, double*, i64)*}*** %_anon_lambda_16Ptr, {i8*, i8*, void (i8*, i8*, double*, i64)*}**** %tmp_envptr12162


%val12171 = load {i8*, i8*, void (i8*, i8*, double*, i64)*}**, {i8*, i8*, void (i8*, i8*, double*, i64)*}*** %_anon_lambda_16Ptr

; let value assignment
%window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd = select i1 true, {i8*, i8*, void (i8*, i8*, double*, i64)*}** %val12171, {i8*, i8*, void (i8*, i8*, double*, i64)*}** %val12171
store {i8*, i8*, void (i8*, i8*, double*, i64)*}** %window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd, {i8*, i8*, void (i8*, i8*, double*, i64)*}*** %window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRdPtr

%val12174 = load {i8*, i8*, void (i8*, i8*, double*, i64)*}**, {i8*, i8*, void (i8*, i8*, double*, i64)*}*** %window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRdPtr
ret {i8*, i8*, void (i8*, i8*, double*, i64)*}** %val12174
}


@window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double*, i64)*}** @window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64)*,  void (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc void @window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_native(double* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64)*,  void (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc i8*  @window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12175 = bitcast [99 x i8]* @gsxtmmath507 to i8*
call i32 (i8*, ...) @printf(i8* %var12175)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to double*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12176 = bitcast [99 x i8]* @gsxtmmath507 to i8*
call i32 (i8*, ...) @printf(i8* %var12176)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64)*,  void (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double*, i64}*
%arg_p_0 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load double*, double** %arg_p_0
%arg_p_1 = getelementptr {double*, i64}, {double*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @window_hamming_adhoc_W3ZvaWQsZG91YmxlKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double*, i64)*}*, {i8*, i8*, void (i8*, i8*, double*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double*, i64)*}, {i8*, i8*, void (i8*, i8*, double*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double*, i64)*,  void (i8*, i8*, double*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath508 = hidden constant [45 x i8] c"window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0\00"
@gsxtmmath509 = hidden constant [16 x i8] c"_anon_lambda_17\00"
define dllexport fastcc void @window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0__12177(i8* %_impz,i8* %_impenv, float* %window_buffer, i64 %window_length) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12180 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}*
%window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 0
%window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0Ptr = load {i8*, i8*, void (i8*, i8*, float*, i64)*}***, {i8*, i8*, void (i8*, i8*, float*, i64)*}**** %window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0Ptr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 1
%iPtr = load i64*, i64** %iPtr_
%_anon_lambda_17Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_17Ptr = load {i8*, i8*, void (i8*, i8*, float*, i64)*}***, {i8*, i8*, void (i8*, i8*, float*, i64)*}**** %_anon_lambda_17Ptr_

; setup arguments
%window_bufferPtr = alloca float*
store float* %window_buffer, float** %window_bufferPtr
%window_lengthPtr = alloca i64
store i64 %window_length, i64* %window_lengthPtr


; setup loop
%val12183 = load i64, i64* %window_lengthPtr
store i64 0, i64* %iPtr
%val12203 = load i64, i64* %iPtr
%num12204 = add i64 %val12183, %val12203
%comp12205 = icmp ult i64 %val12183, 1
br i1 %comp12205, label %after12181, label %loop12181

loop12181:
%val12184 = load i64, i64* %iPtr
%val12185 = load float*, float** %window_bufferPtr
%val12186 = load i64, i64* %iPtr
%val12187 = load float*, float** %window_bufferPtr
; pointer ref
%val12188 = getelementptr float, float* %val12187, i64 %val12186
%val12189 = load float, float* %val12188
%val12190 = load float, float* @TWOPIf
%val12191 = load i64, i64* %iPtr
%res12192 = call ccc float @i64tof(i64 %val12191)
%val12193 = fmul float %val12190, %res12192
%val12194 = load i64, i64* %window_lengthPtr
%val12195 = sub i64 %val12194, 1
%res12196 = call ccc float @i64tof(i64 %val12195)
%val12197 = fdiv float %val12193, %res12196
%val12198 = call float @llvm.cos.f32(float %val12197)
%val12199 = fmul float 0x3fdd70a3e0000000, %val12198
%val12200 = fsub float 0x3fe147ae20000000, %val12199
%val12201 = fmul float %val12189, %val12200
; set pointer
%val12202 = getelementptr float, float* %val12185, i64 %val12184
store float %val12201, float* %val12202
%loop_cnt12181 = load i64, i64* %iPtr
%next12181 = add i64 %loop_cnt12181, 1
store i64 %next12181, i64* %iPtr
%cmp12181 = icmp ult i64 %next12181, %num12204
br i1 %cmp12181, label %loop12181, label %after12181

after12181:
ret void
}
@gsxtmmath510 = hidden constant [98 x i8] c"window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, i64)*}** @window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12240 = load i8*, i8** %_impzPtr
%zone12241 = bitcast i8* %tzone12240 to %mzone*

; let assign value to symbol window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0
%dat_window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone12241, i64 8)
%window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0Ptr = bitcast i8* %dat_window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0 to {i8*, i8*, void (i8*, i8*, float*, i64)*}***
%tzone12178 = load i8*, i8** %_impzPtr
%zone12179 = bitcast i8* %tzone12178 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone12179, i64 8)
%iPtr = bitcast i8* %dat_i to i64*

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

%tzone12237 = load i8*, i8** %_impzPtr
%zone12238 = bitcast i8* %tzone12237 to %mzone*

; let assign value to symbol _anon_lambda_17
%dat__anon_lambda_17 = call i8* @llvm_zone_malloc(%mzone* %zone12238, i64 8)
%_anon_lambda_17Ptr = bitcast i8* %dat__anon_lambda_17 to { i8*, i8*, void (i8*, i8*, float*, i64)*}***
%tzone12208 = load i8*, i8** %_impzPtr
%zone12209 = bitcast i8* %tzone12208 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12209)
; malloc closure structure
%clsptr12210 = call i8* @llvm_zone_malloc(%mzone* %zone12209, i64 24)
%closure12211 = bitcast i8* %clsptr12210 to { i8*, i8*, void (i8*, i8*, float*, i64)*}*

; malloc environment structure
%envptr12212 = call i8* @llvm_zone_malloc(%mzone* %zone12209, i64 24)
%environment12213 = bitcast i8* %envptr12212 to {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}*

; malloc closure address table
%addytable12214 = call %clsvar* @new_address_table()
%var12215 = bitcast [45 x i8]* @gsxtmmath508 to i8*
%var12216 = bitcast [44 x i8]* @gsxtmmath57 to i8*
%addytable12217 = call %clsvar* @add_address_table(%mzone* %zone12209, i8* %var12215, i32 0, i8* %var12216, i32 3, %clsvar* %addytable12214)
%var12218 = bitcast [2 x i8]* @gsxtmmath93 to i8*
%var12219 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable12220 = call %clsvar* @add_address_table(%mzone* %zone12209, i8* %var12218, i32 8, i8* %var12219, i32 3, %clsvar* %addytable12217)
%var12221 = bitcast [16 x i8]* @gsxtmmath509 to i8*
%var12222 = bitcast [44 x i8]* @gsxtmmath57 to i8*
%addytable12223 = call %clsvar* @add_address_table(%mzone* %zone12209, i8* %var12221, i32 16, i8* %var12222, i32 3, %clsvar* %addytable12220)
%address-table12224 = bitcast %clsvar* %addytable12223 to i8*

; insert table, function and environment into closure struct
%closure.table12231 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure12211, i32 0, i32 0
store i8* %address-table12224, i8** %closure.table12231
%closure.env12232 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure12211, i32 0, i32 1
store i8* %envptr12212, i8** %closure.env12232
%closure.func12233 = getelementptr { i8*, i8*, void (i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure12211, i32 0, i32 2
store void (i8*, i8*, float*, i64)* @window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0__12177, void (i8*, i8*, float*, i64)** %closure.func12233
%closure_size12234 = call i64 @llvm_zone_mark_size(%mzone* %zone12209)
call void @llvm_zone_ptr_set_size(i8* %clsptr12210, i64 %closure_size12234)
%wrapper_ptr12235 = call i8* @llvm_zone_malloc(%mzone* %zone12209, i64 8)
%closure_wrapper12236 = bitcast i8* %wrapper_ptr12235 to { i8*, i8*, void (i8*, i8*, float*, i64)*}**
store { i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure12211, { i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure_wrapper12236

; let value assignment
%_anon_lambda_17 = select i1 true, { i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure_wrapper12236, { i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure_wrapper12236
store { i8*, i8*, void (i8*, i8*, float*, i64)*}** %_anon_lambda_17, { i8*, i8*, void (i8*, i8*, float*, i64)*}*** %_anon_lambda_17Ptr

; add data to environment
; don't need to alloc for env var window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0
%tmp_envptr12226 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}* %environment12213, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, i64)*}*** %window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0Ptr, {i8*, i8*, void (i8*, i8*, float*, i64)*}**** %tmp_envptr12226

; don't need to alloc for env var i
%tmp_envptr12228 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}* %environment12213, i32 0, i32 1
store i64* %iPtr, i64** %tmp_envptr12228

; don't need to alloc for env var _anon_lambda_17
%tmp_envptr12230 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, float*, i64)*}***, i64*, {i8*, i8*, void (i8*, i8*, float*, i64)*}***}* %environment12213, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, float*, i64)*}*** %_anon_lambda_17Ptr, {i8*, i8*, void (i8*, i8*, float*, i64)*}**** %tmp_envptr12230


%val12239 = load {i8*, i8*, void (i8*, i8*, float*, i64)*}**, {i8*, i8*, void (i8*, i8*, float*, i64)*}*** %_anon_lambda_17Ptr

; let value assignment
%window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0 = select i1 true, {i8*, i8*, void (i8*, i8*, float*, i64)*}** %val12239, {i8*, i8*, void (i8*, i8*, float*, i64)*}** %val12239
store {i8*, i8*, void (i8*, i8*, float*, i64)*}** %window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0, {i8*, i8*, void (i8*, i8*, float*, i64)*}*** %window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0Ptr

%val12242 = load {i8*, i8*, void (i8*, i8*, float*, i64)*}**, {i8*, i8*, void (i8*, i8*, float*, i64)*}*** %window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0Ptr
ret {i8*, i8*, void (i8*, i8*, float*, i64)*}** %val12242
}


@window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, i64)*}** @window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64)*,  void (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc void @window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_native(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64)*,  void (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc i8*  @window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12243 = bitcast [98 x i8]* @gsxtmmath510 to i8*
call i32 (i8*, ...) @printf(i8* %var12243)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12244 = bitcast [98 x i8]* @gsxtmmath510 to i8*
call i32 (i8*, ...) @printf(i8* %var12244)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64)*,  void (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64}*
%arg_p_0 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @window_hamming_adhoc_W3ZvaWQsZmxvYXQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, i64)*,  void (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath511 = hidden constant [24 x i8] c"djb2_adhoc_W2k2NCxpOCpd\00"
@gsxtmmath512 = hidden constant [35 x i8] c"{i8*, i8*, i64 (i8*, i8*, i8*)*}**\00"
define dllexport fastcc i64 @djb2_adhoc_W2k2NCxpOCpd__12245(i8* %_impz,i8* %_impenv, i8* %str) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12246 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}*
%djb2_adhoc_W2k2NCxpOCpdPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%djb2_adhoc_W2k2NCxpOCpdPtr = load {i8*, i8*, i64 (i8*, i8*, i8*)*}***, {i8*, i8*, i64 (i8*, i8*, i8*)*}**** %djb2_adhoc_W2k2NCxpOCpdPtr_

; setup arguments
%strPtr = alloca i8*
store i8* %str, i8** %strPtr


%tzone12247 = load i8*, i8** %_impzPtr
%zone12248 = bitcast i8* %tzone12247 to %mzone*

; let assign value to symbol hash
%hashPtr = alloca i64
%tzone12251 = load i8*, i8** %_impzPtr
%zone12252 = bitcast i8* %tzone12251 to %mzone*

; let assign value to symbol len
%lenPtr = alloca i64
%tzone12253 = load i8*, i8** %_impzPtr
%zone12254 = bitcast i8* %tzone12253 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%hash = select i1 true, i64 5381, i64 5381
store i64 %hash, i64* %hashPtr

%val12249 = load i8*, i8** %strPtr
%res12250 = call ccc i64 @strlen(i8* %val12249)

; let value assignment
%len = select i1 true, i64 %res12250, i64 %res12250
store i64 %len, i64* %lenPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val12257 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val12268 = load i64, i64* %iPtr
%num12269 = add i64 %val12257, %val12268
%comp12270 = icmp ult i64 %val12257, 1
br i1 %comp12270, label %after12255, label %loop12255

loop12255:
; do set!
%val12258 = load i64, i64* %hashPtr
%val12259 = shl i64 %val12258, 5
%val12260 = load i64, i64* %hashPtr
%val12261 = add i64 %val12259, %val12260
%val12262 = load i64, i64* %iPtr
%val12263 = load i8*, i8** %strPtr
; pointer ref
%val12264 = getelementptr i8, i8* %val12263, i64 %val12262
%val12265 = load i8, i8* %val12264
%val12266 = sext i8 %val12265 to i64
%val12267 = add i64 %val12261, %val12266
store i64 %val12267, i64* %hashPtr
%loop_cnt12255 = load i64, i64* %iPtr
%next12255 = add i64 %loop_cnt12255, 1
store i64 %next12255, i64* %iPtr
%cmp12255 = icmp ult i64 %next12255, %num12269
br i1 %cmp12255, label %loop12255, label %after12255

after12255:
%val12272 = load i64, i64* %hashPtr
ret i64 %val12272
}
@gsxtmmath513 = hidden constant [77 x i8] c"djb2_adhoc_W2k2NCxpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, i8*)*}** @djb2_adhoc_W2k2NCxpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12292 = load i8*, i8** %_impzPtr
%zone12293 = bitcast i8* %tzone12292 to %mzone*

; let assign value to symbol djb2_adhoc_W2k2NCxpOCpd
%dat_djb2_adhoc_W2k2NCxpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone12293, i64 8)
%djb2_adhoc_W2k2NCxpOCpdPtr = bitcast i8* %dat_djb2_adhoc_W2k2NCxpOCpd to { i8*, i8*, i64 (i8*, i8*, i8*)*}***
%tzone12273 = load i8*, i8** %_impzPtr
%zone12274 = bitcast i8* %tzone12273 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12274)
; malloc closure structure
%clsptr12275 = call i8* @llvm_zone_malloc(%mzone* %zone12274, i64 24)
%closure12276 = bitcast i8* %clsptr12275 to { i8*, i8*, i64 (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr12277 = call i8* @llvm_zone_malloc(%mzone* %zone12274, i64 8)
%environment12278 = bitcast i8* %envptr12277 to {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable12279 = call %clsvar* @new_address_table()
%var12280 = bitcast [24 x i8]* @gsxtmmath511 to i8*
%var12281 = bitcast [35 x i8]* @gsxtmmath512 to i8*
%addytable12282 = call %clsvar* @add_address_table(%mzone* %zone12274, i8* %var12280, i32 0, i8* %var12281, i32 3, %clsvar* %addytable12279)
%address-table12283 = bitcast %clsvar* %addytable12282 to i8*

; insert table, function and environment into closure struct
%closure.table12286 = getelementptr { i8*, i8*, i64 (i8*, i8*, i8*)*}, { i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure12276, i32 0, i32 0
store i8* %address-table12283, i8** %closure.table12286
%closure.env12287 = getelementptr { i8*, i8*, i64 (i8*, i8*, i8*)*}, { i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure12276, i32 0, i32 1
store i8* %envptr12277, i8** %closure.env12287
%closure.func12288 = getelementptr { i8*, i8*, i64 (i8*, i8*, i8*)*}, { i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure12276, i32 0, i32 2
store i64 (i8*, i8*, i8*)* @djb2_adhoc_W2k2NCxpOCpd__12245, i64 (i8*, i8*, i8*)** %closure.func12288
%closure_size12289 = call i64 @llvm_zone_mark_size(%mzone* %zone12274)
call void @llvm_zone_ptr_set_size(i8* %clsptr12275, i64 %closure_size12289)
%wrapper_ptr12290 = call i8* @llvm_zone_malloc(%mzone* %zone12274, i64 8)
%closure_wrapper12291 = bitcast i8* %wrapper_ptr12290 to { i8*, i8*, i64 (i8*, i8*, i8*)*}**
store { i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure12276, { i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_wrapper12291

; let value assignment
%djb2_adhoc_W2k2NCxpOCpd = select i1 true, { i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_wrapper12291, { i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_wrapper12291
store { i8*, i8*, i64 (i8*, i8*, i8*)*}** %djb2_adhoc_W2k2NCxpOCpd, { i8*, i8*, i64 (i8*, i8*, i8*)*}*** %djb2_adhoc_W2k2NCxpOCpdPtr

; add data to environment
; don't need to alloc for env var djb2_adhoc_W2k2NCxpOCpd
%tmp_envptr12285 = getelementptr {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}* %environment12278, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, i8*)*}*** %djb2_adhoc_W2k2NCxpOCpdPtr, {i8*, i8*, i64 (i8*, i8*, i8*)*}**** %tmp_envptr12285


%val12294 = load {i8*, i8*, i64 (i8*, i8*, i8*)*}**, {i8*, i8*, i64 (i8*, i8*, i8*)*}*** %djb2_adhoc_W2k2NCxpOCpdPtr
ret {i8*, i8*, i64 (i8*, i8*, i8*)*}** %val12294
}


@djb2_adhoc_W2k2NCxpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@djb2_adhoc_W2k2NCxpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @djb2_adhoc_W2k2NCxpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @djb2_adhoc_W2k2NCxpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, i8*)*}** @djb2_adhoc_W2k2NCxpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @djb2_adhoc_W2k2NCxpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @djb2_adhoc_W2k2NCxpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @djb2_adhoc_W2k2NCxpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @djb2_adhoc_W2k2NCxpOCpd(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @djb2_adhoc_W2k2NCxpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i8*)*}*, {i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i8*)*,  i64 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i64 %result
}


define dllexport ccc i64 @djb2_adhoc_W2k2NCxpOCpd_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @djb2_adhoc_W2k2NCxpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i8*)*}*, {i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i8*)*,  i64 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i64 %result
}


define dllexport ccc i8*  @djb2_adhoc_W2k2NCxpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12295 = bitcast [77 x i8]* @gsxtmmath513 to i8*
call i32 (i8*, ...) @printf(i8* %var12295)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @djb2_adhoc_W2k2NCxpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i8*)*}*, {i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i8*)*,  i64 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @djb2_adhoc_W2k2NCxpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @djb2_adhoc_W2k2NCxpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i8*)*}*, {i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i8*)*,  i64 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath514 = hidden constant [24 x i8] c"sdbm_adhoc_W2k2NCxpOCpd\00"
define dllexport fastcc i64 @sdbm_adhoc_W2k2NCxpOCpd__12296(i8* %_impz,i8* %_impenv, i8* %str) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12297 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}*
%sdbm_adhoc_W2k2NCxpOCpdPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%sdbm_adhoc_W2k2NCxpOCpdPtr = load {i8*, i8*, i64 (i8*, i8*, i8*)*}***, {i8*, i8*, i64 (i8*, i8*, i8*)*}**** %sdbm_adhoc_W2k2NCxpOCpdPtr_

; setup arguments
%strPtr = alloca i8*
store i8* %str, i8** %strPtr


%tzone12298 = load i8*, i8** %_impzPtr
%zone12299 = bitcast i8* %tzone12298 to %mzone*

; let assign value to symbol hash
%hashPtr = alloca i64
%tzone12302 = load i8*, i8** %_impzPtr
%zone12303 = bitcast i8* %tzone12302 to %mzone*

; let assign value to symbol len
%lenPtr = alloca i64
%tzone12304 = load i8*, i8** %_impzPtr
%zone12305 = bitcast i8* %tzone12304 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%hash = select i1 true, i64 0, i64 0
store i64 %hash, i64* %hashPtr

%val12300 = load i8*, i8** %strPtr
%res12301 = call ccc i64 @strlen(i8* %val12300)

; let value assignment
%len = select i1 true, i64 %res12301, i64 %res12301
store i64 %len, i64* %lenPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val12308 = load i64, i64* %lenPtr
store i64 0, i64* %iPtr
%val12322 = load i64, i64* %iPtr
%num12323 = add i64 %val12308, %val12322
%comp12324 = icmp ult i64 %val12308, 1
br i1 %comp12324, label %after12306, label %loop12306

loop12306:
; do set!
%val12309 = load i64, i64* %iPtr
%val12310 = load i8*, i8** %strPtr
; pointer ref
%val12311 = getelementptr i8, i8* %val12310, i64 %val12309
%val12312 = load i8, i8* %val12311
%val12313 = sext i8 %val12312 to i64
%val12314 = load i64, i64* %hashPtr
%val12315 = shl i64 %val12314, 6
%val12316 = add i64 %val12313, %val12315
%val12317 = load i64, i64* %hashPtr
%val12318 = shl i64 %val12317, 16
%val12319 = add i64 %val12316, %val12318
%val12320 = load i64, i64* %hashPtr
%val12321 = sub i64 %val12319, %val12320
store i64 %val12321, i64* %hashPtr
%loop_cnt12306 = load i64, i64* %iPtr
%next12306 = add i64 %loop_cnt12306, 1
store i64 %next12306, i64* %iPtr
%cmp12306 = icmp ult i64 %next12306, %num12323
br i1 %cmp12306, label %loop12306, label %after12306

after12306:
%val12326 = load i64, i64* %hashPtr
ret i64 %val12326
}
@gsxtmmath515 = hidden constant [77 x i8] c"sdbm_adhoc_W2k2NCxpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, i8*)*}** @sdbm_adhoc_W2k2NCxpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12346 = load i8*, i8** %_impzPtr
%zone12347 = bitcast i8* %tzone12346 to %mzone*

; let assign value to symbol sdbm_adhoc_W2k2NCxpOCpd
%dat_sdbm_adhoc_W2k2NCxpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone12347, i64 8)
%sdbm_adhoc_W2k2NCxpOCpdPtr = bitcast i8* %dat_sdbm_adhoc_W2k2NCxpOCpd to { i8*, i8*, i64 (i8*, i8*, i8*)*}***
%tzone12327 = load i8*, i8** %_impzPtr
%zone12328 = bitcast i8* %tzone12327 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12328)
; malloc closure structure
%clsptr12329 = call i8* @llvm_zone_malloc(%mzone* %zone12328, i64 24)
%closure12330 = bitcast i8* %clsptr12329 to { i8*, i8*, i64 (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr12331 = call i8* @llvm_zone_malloc(%mzone* %zone12328, i64 8)
%environment12332 = bitcast i8* %envptr12331 to {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable12333 = call %clsvar* @new_address_table()
%var12334 = bitcast [24 x i8]* @gsxtmmath514 to i8*
%var12335 = bitcast [35 x i8]* @gsxtmmath512 to i8*
%addytable12336 = call %clsvar* @add_address_table(%mzone* %zone12328, i8* %var12334, i32 0, i8* %var12335, i32 3, %clsvar* %addytable12333)
%address-table12337 = bitcast %clsvar* %addytable12336 to i8*

; insert table, function and environment into closure struct
%closure.table12340 = getelementptr { i8*, i8*, i64 (i8*, i8*, i8*)*}, { i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure12330, i32 0, i32 0
store i8* %address-table12337, i8** %closure.table12340
%closure.env12341 = getelementptr { i8*, i8*, i64 (i8*, i8*, i8*)*}, { i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure12330, i32 0, i32 1
store i8* %envptr12331, i8** %closure.env12341
%closure.func12342 = getelementptr { i8*, i8*, i64 (i8*, i8*, i8*)*}, { i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure12330, i32 0, i32 2
store i64 (i8*, i8*, i8*)* @sdbm_adhoc_W2k2NCxpOCpd__12296, i64 (i8*, i8*, i8*)** %closure.func12342
%closure_size12343 = call i64 @llvm_zone_mark_size(%mzone* %zone12328)
call void @llvm_zone_ptr_set_size(i8* %clsptr12329, i64 %closure_size12343)
%wrapper_ptr12344 = call i8* @llvm_zone_malloc(%mzone* %zone12328, i64 8)
%closure_wrapper12345 = bitcast i8* %wrapper_ptr12344 to { i8*, i8*, i64 (i8*, i8*, i8*)*}**
store { i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure12330, { i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_wrapper12345

; let value assignment
%sdbm_adhoc_W2k2NCxpOCpd = select i1 true, { i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_wrapper12345, { i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_wrapper12345
store { i8*, i8*, i64 (i8*, i8*, i8*)*}** %sdbm_adhoc_W2k2NCxpOCpd, { i8*, i8*, i64 (i8*, i8*, i8*)*}*** %sdbm_adhoc_W2k2NCxpOCpdPtr

; add data to environment
; don't need to alloc for env var sdbm_adhoc_W2k2NCxpOCpd
%tmp_envptr12339 = getelementptr {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}* %environment12332, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, i8*)*}*** %sdbm_adhoc_W2k2NCxpOCpdPtr, {i8*, i8*, i64 (i8*, i8*, i8*)*}**** %tmp_envptr12339


%val12348 = load {i8*, i8*, i64 (i8*, i8*, i8*)*}**, {i8*, i8*, i64 (i8*, i8*, i8*)*}*** %sdbm_adhoc_W2k2NCxpOCpdPtr
ret {i8*, i8*, i64 (i8*, i8*, i8*)*}** %val12348
}


@sdbm_adhoc_W2k2NCxpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@sdbm_adhoc_W2k2NCxpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @sdbm_adhoc_W2k2NCxpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @sdbm_adhoc_W2k2NCxpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, i8*)*}** @sdbm_adhoc_W2k2NCxpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @sdbm_adhoc_W2k2NCxpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @sdbm_adhoc_W2k2NCxpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sdbm_adhoc_W2k2NCxpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @sdbm_adhoc_W2k2NCxpOCpd(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sdbm_adhoc_W2k2NCxpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i8*)*}*, {i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i8*)*,  i64 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i64 %result
}


define dllexport ccc i64 @sdbm_adhoc_W2k2NCxpOCpd_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sdbm_adhoc_W2k2NCxpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i8*)*}*, {i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i8*)*,  i64 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i64 %result
}


define dllexport ccc i8*  @sdbm_adhoc_W2k2NCxpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12349 = bitcast [77 x i8]* @gsxtmmath515 to i8*
call i32 (i8*, ...) @printf(i8* %var12349)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sdbm_adhoc_W2k2NCxpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i8*)*}*, {i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i8*)*,  i64 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @sdbm_adhoc_W2k2NCxpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sdbm_adhoc_W2k2NCxpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i8*)*}*, {i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i8*)*,  i64 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath516 = hidden constant [56 x i8] c"ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0\00"
@gsxtmmath517 = hidden constant [83 x i8] c"{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**\00"
define dllexport fastcc double @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0__12350(i8* %_impz,i8* %_impenv, {i8*, i8*, double (i8*, i8*, double)*}** %f, double %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12351 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***}*
%ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***}, {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***}* %impenv, i32 0, i32 0
%ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0Ptr = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**** %ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0Ptr_

; setup arguments
%fPtr = alloca {i8*, i8*, double (i8*, i8*, double)*}**
store {i8*, i8*, double (i8*, i8*, double)*}** %f, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%xPtr = alloca double
store double %x, double* %xPtr


%val12352 = load double, double* %xPtr
%val12353 = fdiv double 1.0000000000000000818e-05, 2.0000000000000000000
%val12354 = fadd double %val12352, %val12353

; apply closure 
%vval12355 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12356 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12355
%fPtr12357 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12356, i32 0, i32 2
%ePtr12358 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12356, i32 0, i32 1
%f12359 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12357
%e12360 = load i8*, i8** %ePtr12358
%tzone12361 = load i8*, i8** %_impzPtr
%zone12362 = bitcast i8* %tzone12361 to %mzone*
%z12363 = bitcast %mzone* %zone12362 to i8*
%result12364 = tail call fastcc double %f12359(i8* %z12363, i8* %e12360, double %val12354)
%val12365 = load double, double* %xPtr
%val12366 = fdiv double 1.0000000000000000818e-05, 2.0000000000000000000
%val12367 = fsub double %val12365, %val12366

; apply closure 
%vval12368 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12369 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12368
%fPtr12370 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12369, i32 0, i32 2
%ePtr12371 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12369, i32 0, i32 1
%f12372 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12370
%e12373 = load i8*, i8** %ePtr12371
%tzone12374 = load i8*, i8** %_impzPtr
%zone12375 = bitcast i8* %tzone12374 to %mzone*
%z12376 = bitcast %mzone* %zone12375 to i8*
%result12377 = tail call fastcc double %f12372(i8* %z12376, i8* %e12373, double %val12367)
%val12378 = fsub double %result12364, %result12377
%val12379 = fdiv double %val12378, 1.0000000000000000818e-05
ret double %val12379
}
@gsxtmmath518 = hidden constant [109 x i8] c"ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12399 = load i8*, i8** %_impzPtr
%zone12400 = bitcast i8* %tzone12399 to %mzone*

; let assign value to symbol ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0
%dat_ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0 = call i8* @llvm_zone_malloc(%mzone* %zone12400, i64 8)
%ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0Ptr = bitcast i8* %dat_ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0 to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***
%tzone12380 = load i8*, i8** %_impzPtr
%zone12381 = bitcast i8* %tzone12380 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12381)
; malloc closure structure
%clsptr12382 = call i8* @llvm_zone_malloc(%mzone* %zone12381, i64 24)
%closure12383 = bitcast i8* %clsptr12382 to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*

; malloc environment structure
%envptr12384 = call i8* @llvm_zone_malloc(%mzone* %zone12381, i64 8)
%environment12385 = bitcast i8* %envptr12384 to {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***}*

; malloc closure address table
%addytable12386 = call %clsvar* @new_address_table()
%var12387 = bitcast [56 x i8]* @gsxtmmath516 to i8*
%var12388 = bitcast [83 x i8]* @gsxtmmath517 to i8*
%addytable12389 = call %clsvar* @add_address_table(%mzone* %zone12381, i8* %var12387, i32 0, i8* %var12388, i32 3, %clsvar* %addytable12386)
%address-table12390 = bitcast %clsvar* %addytable12389 to i8*

; insert table, function and environment into closure struct
%closure.table12393 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure12383, i32 0, i32 0
store i8* %address-table12390, i8** %closure.table12393
%closure.env12394 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure12383, i32 0, i32 1
store i8* %envptr12384, i8** %closure.env12394
%closure.func12395 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure12383, i32 0, i32 2
store double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)* @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0__12350, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)** %closure.func12395
%closure_size12396 = call i64 @llvm_zone_mark_size(%mzone* %zone12381)
call void @llvm_zone_ptr_set_size(i8* %clsptr12382, i64 %closure_size12396)
%wrapper_ptr12397 = call i8* @llvm_zone_malloc(%mzone* %zone12381, i64 8)
%closure_wrapper12398 = bitcast i8* %wrapper_ptr12397 to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**
store { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure12383, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure_wrapper12398

; let value assignment
%ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0 = select i1 true, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure_wrapper12398, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure_wrapper12398
store { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*** %ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0Ptr

; add data to environment
; don't need to alloc for env var ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0
%tmp_envptr12392 = getelementptr {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***}, {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***}* %environment12385, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*** %ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0Ptr, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**** %tmp_envptr12392


%val12401 = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*** %ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0Ptr
ret {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %val12401
}


@ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var = dllexport global [1 x i8*] [ i8* null ]

@ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0({i8*, i8*, double (i8*, i8*, double)*}** %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1)
ret double %result
}


define dllexport ccc double @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_native({i8*, i8*, double (i8*, i8*, double)*}** %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1)
ret double %result
}


define dllexport ccc i8*  @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12402 = bitcast [109 x i8]* @gsxtmmath518 to i8*
call i32 (i8*, ...) @printf(i8* %var12402)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to {i8*, i8*, double (i8*, i8*, double)*}**
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12403 = bitcast [109 x i8]* @gsxtmmath518 to i8*
call i32 (i8*, ...) @printf(i8* %var12403)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {{i8*, i8*, double (i8*, i8*, double)*}**, double}*
%arg_p_0 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double}, {{i8*, i8*, double (i8*, i8*, double)*}**, double}* %fstruct, i32 0, i32 0
%arg_0 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %arg_p_0
%arg_p_1 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double}, {{i8*, i8*, double (i8*, i8*, double)*}**, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath519 = hidden constant [65 x i8] c"ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd\00"
@gsxtmmath520 = hidden constant [91 x i8] c"{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**\00"
define dllexport fastcc double @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd__12404(i8* %_impz,i8* %_impenv, {i8*, i8*, double (i8*, i8*, double)*}** %f, double %x, double %dx) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12405 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}*
%ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}* %impenv, i32 0, i32 0
%ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**** %ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr_

; setup arguments
%fPtr = alloca {i8*, i8*, double (i8*, i8*, double)*}**
store {i8*, i8*, double (i8*, i8*, double)*}** %f, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%xPtr = alloca double
store double %x, double* %xPtr
%dxPtr = alloca double
store double %dx, double* %dxPtr


%val12406 = load double, double* %xPtr
%val12407 = load double, double* %dxPtr
%val12408 = fdiv double %val12407, 2.0000000000000000000
%val12409 = fadd double %val12406, %val12408

; apply closure 
%vval12410 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12411 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12410
%fPtr12412 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12411, i32 0, i32 2
%ePtr12413 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12411, i32 0, i32 1
%f12414 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12412
%e12415 = load i8*, i8** %ePtr12413
%tzone12416 = load i8*, i8** %_impzPtr
%zone12417 = bitcast i8* %tzone12416 to %mzone*
%z12418 = bitcast %mzone* %zone12417 to i8*
%result12419 = tail call fastcc double %f12414(i8* %z12418, i8* %e12415, double %val12409)
%val12420 = load double, double* %xPtr
%val12421 = load double, double* %dxPtr
%val12422 = fdiv double %val12421, 2.0000000000000000000
%val12423 = fsub double %val12420, %val12422

; apply closure 
%vval12424 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12425 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12424
%fPtr12426 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12425, i32 0, i32 2
%ePtr12427 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12425, i32 0, i32 1
%f12428 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12426
%e12429 = load i8*, i8** %ePtr12427
%tzone12430 = load i8*, i8** %_impzPtr
%zone12431 = bitcast i8* %tzone12430 to %mzone*
%z12432 = bitcast %mzone* %zone12431 to i8*
%result12433 = tail call fastcc double %f12428(i8* %z12432, i8* %e12429, double %val12423)
%val12434 = fsub double %result12419, %result12433
%val12435 = load double, double* %dxPtr
%val12436 = fdiv double %val12434, %val12435
ret double %val12436
}
@gsxtmmath521 = hidden constant [118 x i8] c"ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12456 = load i8*, i8** %_impzPtr
%zone12457 = bitcast i8* %tzone12456 to %mzone*

; let assign value to symbol ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd
%dat_ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd = call i8* @llvm_zone_malloc(%mzone* %zone12457, i64 8)
%ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr = bitcast i8* %dat_ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***
%tzone12437 = load i8*, i8** %_impzPtr
%zone12438 = bitcast i8* %tzone12437 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12438)
; malloc closure structure
%clsptr12439 = call i8* @llvm_zone_malloc(%mzone* %zone12438, i64 24)
%closure12440 = bitcast i8* %clsptr12439 to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*

; malloc environment structure
%envptr12441 = call i8* @llvm_zone_malloc(%mzone* %zone12438, i64 8)
%environment12442 = bitcast i8* %envptr12441 to {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}*

; malloc closure address table
%addytable12443 = call %clsvar* @new_address_table()
%var12444 = bitcast [65 x i8]* @gsxtmmath519 to i8*
%var12445 = bitcast [91 x i8]* @gsxtmmath520 to i8*
%addytable12446 = call %clsvar* @add_address_table(%mzone* %zone12438, i8* %var12444, i32 0, i8* %var12445, i32 3, %clsvar* %addytable12443)
%address-table12447 = bitcast %clsvar* %addytable12446 to i8*

; insert table, function and environment into closure struct
%closure.table12450 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure12440, i32 0, i32 0
store i8* %address-table12447, i8** %closure.table12450
%closure.env12451 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure12440, i32 0, i32 1
store i8* %envptr12441, i8** %closure.env12451
%closure.func12452 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure12440, i32 0, i32 2
store double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)* @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd__12404, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)** %closure.func12452
%closure_size12453 = call i64 @llvm_zone_mark_size(%mzone* %zone12438)
call void @llvm_zone_ptr_set_size(i8* %clsptr12439, i64 %closure_size12453)
%wrapper_ptr12454 = call i8* @llvm_zone_malloc(%mzone* %zone12438, i64 8)
%closure_wrapper12455 = bitcast i8* %wrapper_ptr12454 to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**
store { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure12440, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_wrapper12455

; let value assignment
%ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd = select i1 true, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_wrapper12455, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_wrapper12455
store { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*** %ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr

; add data to environment
; don't need to alloc for env var ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd
%tmp_envptr12449 = getelementptr {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}* %environment12442, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*** %ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**** %tmp_envptr12449


%val12458 = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*** %ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr
ret {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %val12458
}


@ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var = dllexport global [1 x i8*] [ i8* null ]

@ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd({i8*, i8*, double (i8*, i8*, double)*}** %arg_0,double %arg_1,double %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1, double %arg_2)
ret double %result
}


define dllexport ccc double @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_native({i8*, i8*, double (i8*, i8*, double)*}** %arg_0,double %arg_1,double %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1, double %arg_2)
ret double %result
}


define dllexport ccc i8*  @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12459 = bitcast [118 x i8]* @gsxtmmath521 to i8*
call i32 (i8*, ...) @printf(i8* %var12459)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to {i8*, i8*, double (i8*, i8*, double)*}**
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12460 = bitcast [118 x i8]* @gsxtmmath521 to i8*
call i32 (i8*, ...) @printf(i8* %var12460)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var12461 = bitcast [118 x i8]* @gsxtmmath521 to i8*
call i32 (i8*, ...) @printf(i8* %var12461)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc double @r64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1, double %arg_2)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}*
%arg_p_0 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}, {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}* %fstruct, i32 0, i32 0
%arg_0 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %arg_p_0
%arg_p_1 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}, {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
%arg_p_2 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}, {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}* %fstruct, i32 0, i32 2
%arg_2 = load double, double* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1, double %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath522 = hidden constant [65 x i8] c"ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0\00"
define dllexport fastcc double @ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0__12462(i8* %_impz,i8* %_impenv, {i8*, i8*, double (i8*, i8*, double)*}** %f, double %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12463 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***}*
%ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***}, {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***}* %impenv, i32 0, i32 0
%ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0Ptr = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**** %ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0Ptr_

; setup arguments
%fPtr = alloca {i8*, i8*, double (i8*, i8*, double)*}**
store {i8*, i8*, double (i8*, i8*, double)*}** %f, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%xPtr = alloca double
store double %x, double* %xPtr


%val12464 = load double, double* %xPtr
%val12465 = fdiv double 1.0000000000000000818e-05, 2.0000000000000000000
%val12466 = fadd double %val12464, %val12465

; apply closure 
%vval12467 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12468 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12467
%fPtr12469 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12468, i32 0, i32 2
%ePtr12470 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12468, i32 0, i32 1
%f12471 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12469
%e12472 = load i8*, i8** %ePtr12470
%tzone12473 = load i8*, i8** %_impzPtr
%zone12474 = bitcast i8* %tzone12473 to %mzone*
%z12475 = bitcast %mzone* %zone12474 to i8*
%result12476 = tail call fastcc double %f12471(i8* %z12475, i8* %e12472, double %val12466)
%val12477 = load double, double* %xPtr
%val12478 = fdiv double 1.0000000000000000818e-05, 2.0000000000000000000
%val12479 = fsub double %val12477, %val12478

; apply closure 
%vval12480 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12481 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12480
%fPtr12482 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12481, i32 0, i32 2
%ePtr12483 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12481, i32 0, i32 1
%f12484 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12482
%e12485 = load i8*, i8** %ePtr12483
%tzone12486 = load i8*, i8** %_impzPtr
%zone12487 = bitcast i8* %tzone12486 to %mzone*
%z12488 = bitcast %mzone* %zone12487 to i8*
%result12489 = tail call fastcc double %f12484(i8* %z12488, i8* %e12485, double %val12479)
%val12490 = fsub double %result12476, %result12489
%val12491 = fdiv double %val12490, 1.0000000000000000818e-05
ret double %val12491
}
@gsxtmmath523 = hidden constant [118 x i8] c"ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** @ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12511 = load i8*, i8** %_impzPtr
%zone12512 = bitcast i8* %tzone12511 to %mzone*

; let assign value to symbol ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0
%dat_ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0 = call i8* @llvm_zone_malloc(%mzone* %zone12512, i64 8)
%ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0Ptr = bitcast i8* %dat_ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0 to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***
%tzone12492 = load i8*, i8** %_impzPtr
%zone12493 = bitcast i8* %tzone12492 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12493)
; malloc closure structure
%clsptr12494 = call i8* @llvm_zone_malloc(%mzone* %zone12493, i64 24)
%closure12495 = bitcast i8* %clsptr12494 to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*

; malloc environment structure
%envptr12496 = call i8* @llvm_zone_malloc(%mzone* %zone12493, i64 8)
%environment12497 = bitcast i8* %envptr12496 to {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***}*

; malloc closure address table
%addytable12498 = call %clsvar* @new_address_table()
%var12499 = bitcast [65 x i8]* @gsxtmmath522 to i8*
%var12500 = bitcast [83 x i8]* @gsxtmmath517 to i8*
%addytable12501 = call %clsvar* @add_address_table(%mzone* %zone12493, i8* %var12499, i32 0, i8* %var12500, i32 3, %clsvar* %addytable12498)
%address-table12502 = bitcast %clsvar* %addytable12501 to i8*

; insert table, function and environment into closure struct
%closure.table12505 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure12495, i32 0, i32 0
store i8* %address-table12502, i8** %closure.table12505
%closure.env12506 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure12495, i32 0, i32 1
store i8* %envptr12496, i8** %closure.env12506
%closure.func12507 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure12495, i32 0, i32 2
store double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)* @ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0__12462, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)** %closure.func12507
%closure_size12508 = call i64 @llvm_zone_mark_size(%mzone* %zone12493)
call void @llvm_zone_ptr_set_size(i8* %clsptr12494, i64 %closure_size12508)
%wrapper_ptr12509 = call i8* @llvm_zone_malloc(%mzone* %zone12493, i64 8)
%closure_wrapper12510 = bitcast i8* %wrapper_ptr12509 to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**
store { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure12495, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure_wrapper12510

; let value assignment
%ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0 = select i1 true, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure_wrapper12510, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure_wrapper12510
store { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*** %ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0Ptr

; add data to environment
; don't need to alloc for env var ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0
%tmp_envptr12504 = getelementptr {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***}, {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***}* %environment12497, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*** %ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0Ptr, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**** %tmp_envptr12504


%val12513 = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*** %ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0Ptr
ret {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %val12513
}


@ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var = dllexport global [1 x i8*] [ i8* null ]

@ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** @ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0({i8*, i8*, double (i8*, i8*, double)*}** %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1)
ret double %result
}


define dllexport ccc double @ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_native({i8*, i8*, double (i8*, i8*, double)*}** %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1)
ret double %result
}


define dllexport ccc i8*  @ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12514 = bitcast [118 x i8]* @gsxtmmath523 to i8*
call i32 (i8*, ...) @printf(i8* %var12514)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to {i8*, i8*, double (i8*, i8*, double)*}**
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12515 = bitcast [118 x i8]* @gsxtmmath523 to i8*
call i32 (i8*, ...) @printf(i8* %var12515)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {{i8*, i8*, double (i8*, i8*, double)*}**, double}*
%arg_p_0 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double}, {{i8*, i8*, double (i8*, i8*, double)*}**, double}* %fstruct, i32 0, i32 0
%arg_0 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %arg_p_0
%arg_p_1 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double}, {{i8*, i8*, double (i8*, i8*, double)*}**, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndifferentiate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath524 = hidden constant [78 x i8] c"ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd\00"
define dllexport fastcc double @ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd__12516(i8* %_impz,i8* %_impenv, {i8*, i8*, double (i8*, i8*, double)*}** %f, double %x, double %dx) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12517 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}*
%ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}* %impenv, i32 0, i32 0
%ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**** %ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr_

; setup arguments
%fPtr = alloca {i8*, i8*, double (i8*, i8*, double)*}**
store {i8*, i8*, double (i8*, i8*, double)*}** %f, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%xPtr = alloca double
store double %x, double* %xPtr
%dxPtr = alloca double
store double %dx, double* %dxPtr


%val12518 = load double, double* %xPtr
%val12519 = load double, double* %dxPtr
%val12520 = fdiv double %val12519, 4.0000000000000000000
%val12521 = fadd double %val12518, %val12520

; apply closure 
%vval12522 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12523 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12522
%fPtr12524 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12523, i32 0, i32 2
%ePtr12525 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12523, i32 0, i32 1
%f12526 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12524
%e12527 = load i8*, i8** %ePtr12525
%tzone12528 = load i8*, i8** %_impzPtr
%zone12529 = bitcast i8* %tzone12528 to %mzone*
%z12530 = bitcast %mzone* %zone12529 to i8*
%result12531 = tail call fastcc double %f12526(i8* %z12530, i8* %e12527, double %val12521)
%val12532 = load double, double* %xPtr
%val12533 = load double, double* %dxPtr
%val12534 = fdiv double %val12533, 4.0000000000000000000
%val12535 = fsub double %val12532, %val12534

; apply closure 
%vval12536 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12537 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12536
%fPtr12538 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12537, i32 0, i32 2
%ePtr12539 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12537, i32 0, i32 1
%f12540 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12538
%e12541 = load i8*, i8** %ePtr12539
%tzone12542 = load i8*, i8** %_impzPtr
%zone12543 = bitcast i8* %tzone12542 to %mzone*
%z12544 = bitcast %mzone* %zone12543 to i8*
%result12545 = tail call fastcc double %f12540(i8* %z12544, i8* %e12541, double %val12535)
%val12546 = fsub double %result12531, %result12545
%val12547 = fmul double 8.0000000000000000000, %val12546
%val12548 = load double, double* %xPtr
%val12549 = load double, double* %dxPtr
%val12550 = fdiv double %val12549, 2.0000000000000000000
%val12551 = fadd double %val12548, %val12550

; apply closure 
%vval12552 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12553 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12552
%fPtr12554 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12553, i32 0, i32 2
%ePtr12555 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12553, i32 0, i32 1
%f12556 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12554
%e12557 = load i8*, i8** %ePtr12555
%tzone12558 = load i8*, i8** %_impzPtr
%zone12559 = bitcast i8* %tzone12558 to %mzone*
%z12560 = bitcast %mzone* %zone12559 to i8*
%result12561 = tail call fastcc double %f12556(i8* %z12560, i8* %e12557, double %val12551)
%val12562 = load double, double* %xPtr
%val12563 = load double, double* %dxPtr
%val12564 = fdiv double %val12563, 2.0000000000000000000
%val12565 = fsub double %val12562, %val12564

; apply closure 
%vval12566 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12567 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12566
%fPtr12568 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12567, i32 0, i32 2
%ePtr12569 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12567, i32 0, i32 1
%f12570 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12568
%e12571 = load i8*, i8** %ePtr12569
%tzone12572 = load i8*, i8** %_impzPtr
%zone12573 = bitcast i8* %tzone12572 to %mzone*
%z12574 = bitcast %mzone* %zone12573 to i8*
%result12575 = tail call fastcc double %f12570(i8* %z12574, i8* %e12571, double %val12565)
%val12576 = fsub double %result12561, %result12575
%val12577 = fsub double %val12547, %val12576
%val12578 = load double, double* %dxPtr
%val12579 = fmul double 3.0000000000000000000, %val12578
%val12580 = fdiv double %val12577, %val12579
ret double %val12580
}
@gsxtmmath525 = hidden constant [131 x i8] c"ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** @ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12600 = load i8*, i8** %_impzPtr
%zone12601 = bitcast i8* %tzone12600 to %mzone*

; let assign value to symbol ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd
%dat_ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd = call i8* @llvm_zone_malloc(%mzone* %zone12601, i64 8)
%ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr = bitcast i8* %dat_ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***
%tzone12581 = load i8*, i8** %_impzPtr
%zone12582 = bitcast i8* %tzone12581 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12582)
; malloc closure structure
%clsptr12583 = call i8* @llvm_zone_malloc(%mzone* %zone12582, i64 24)
%closure12584 = bitcast i8* %clsptr12583 to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*

; malloc environment structure
%envptr12585 = call i8* @llvm_zone_malloc(%mzone* %zone12582, i64 8)
%environment12586 = bitcast i8* %envptr12585 to {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}*

; malloc closure address table
%addytable12587 = call %clsvar* @new_address_table()
%var12588 = bitcast [78 x i8]* @gsxtmmath524 to i8*
%var12589 = bitcast [91 x i8]* @gsxtmmath520 to i8*
%addytable12590 = call %clsvar* @add_address_table(%mzone* %zone12582, i8* %var12588, i32 0, i8* %var12589, i32 3, %clsvar* %addytable12587)
%address-table12591 = bitcast %clsvar* %addytable12590 to i8*

; insert table, function and environment into closure struct
%closure.table12594 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure12584, i32 0, i32 0
store i8* %address-table12591, i8** %closure.table12594
%closure.env12595 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure12584, i32 0, i32 1
store i8* %envptr12585, i8** %closure.env12595
%closure.func12596 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure12584, i32 0, i32 2
store double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)* @ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd__12516, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)** %closure.func12596
%closure_size12597 = call i64 @llvm_zone_mark_size(%mzone* %zone12582)
call void @llvm_zone_ptr_set_size(i8* %clsptr12583, i64 %closure_size12597)
%wrapper_ptr12598 = call i8* @llvm_zone_malloc(%mzone* %zone12582, i64 8)
%closure_wrapper12599 = bitcast i8* %wrapper_ptr12598 to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**
store { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure12584, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_wrapper12599

; let value assignment
%ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd = select i1 true, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_wrapper12599, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_wrapper12599
store { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*** %ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr

; add data to environment
; don't need to alloc for env var ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd
%tmp_envptr12593 = getelementptr {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}* %environment12586, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*** %ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**** %tmp_envptr12593


%val12602 = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*** %ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr
ret {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %val12602
}


@ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var = dllexport global [1 x i8*] [ i8* null ]

@ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** @ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd({i8*, i8*, double (i8*, i8*, double)*}** %arg_0,double %arg_1,double %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1, double %arg_2)
ret double %result
}


define dllexport ccc double @ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_native({i8*, i8*, double (i8*, i8*, double)*}** %arg_0,double %arg_1,double %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1, double %arg_2)
ret double %result
}


define dllexport ccc i8*  @ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12603 = bitcast [131 x i8]* @gsxtmmath525 to i8*
call i32 (i8*, ...) @printf(i8* %var12603)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to {i8*, i8*, double (i8*, i8*, double)*}**
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12604 = bitcast [131 x i8]* @gsxtmmath525 to i8*
call i32 (i8*, ...) @printf(i8* %var12604)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var12605 = bitcast [131 x i8]* @gsxtmmath525 to i8*
call i32 (i8*, ...) @printf(i8* %var12605)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc double @r64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1, double %arg_2)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}*
%arg_p_0 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}, {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}* %fstruct, i32 0, i32 0
%arg_0 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %arg_p_0
%arg_p_1 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}, {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
%arg_p_2 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}, {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}* %fstruct, i32 0, i32 2
%arg_2 = load double, double* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff_extrapolated_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1, double %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath526 = hidden constant [57 x i8] c"ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0\00"
define dllexport fastcc double @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0__12606(i8* %_impz,i8* %_impenv, {i8*, i8*, double (i8*, i8*, double)*}** %f, double %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12607 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***}*
%ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***}, {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***}* %impenv, i32 0, i32 0
%ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0Ptr = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**** %ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0Ptr_

; setup arguments
%fPtr = alloca {i8*, i8*, double (i8*, i8*, double)*}**
store {i8*, i8*, double (i8*, i8*, double)*}** %f, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%xPtr = alloca double
store double %x, double* %xPtr


%val12608 = load double, double* %xPtr
%val12609 = fadd double %val12608, 1.0000000000000000818e-05

; apply closure 
%vval12610 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12611 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12610
%fPtr12612 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12611, i32 0, i32 2
%ePtr12613 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12611, i32 0, i32 1
%f12614 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12612
%e12615 = load i8*, i8** %ePtr12613
%tzone12616 = load i8*, i8** %_impzPtr
%zone12617 = bitcast i8* %tzone12616 to %mzone*
%z12618 = bitcast %mzone* %zone12617 to i8*
%result12619 = tail call fastcc double %f12614(i8* %z12618, i8* %e12615, double %val12609)
%val12620 = load double, double* %xPtr

; apply closure 
%vval12621 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12622 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12621
%fPtr12623 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12622, i32 0, i32 2
%ePtr12624 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12622, i32 0, i32 1
%f12625 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12623
%e12626 = load i8*, i8** %ePtr12624
%tzone12627 = load i8*, i8** %_impzPtr
%zone12628 = bitcast i8* %tzone12627 to %mzone*
%z12629 = bitcast %mzone* %zone12628 to i8*
%result12630 = tail call fastcc double %f12625(i8* %z12629, i8* %e12626, double %val12620)
%val12631 = fsub double %result12619, %result12630
%val12632 = load double, double* %xPtr

; apply closure 
%vval12633 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12634 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12633
%fPtr12635 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12634, i32 0, i32 2
%ePtr12636 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12634, i32 0, i32 1
%f12637 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12635
%e12638 = load i8*, i8** %ePtr12636
%tzone12639 = load i8*, i8** %_impzPtr
%zone12640 = bitcast i8* %tzone12639 to %mzone*
%z12641 = bitcast %mzone* %zone12640 to i8*
%result12642 = tail call fastcc double %f12637(i8* %z12641, i8* %e12638, double %val12632)
%val12643 = load double, double* %xPtr
%val12644 = fsub double %val12643, 1.0000000000000000818e-05

; apply closure 
%vval12645 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12646 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12645
%fPtr12647 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12646, i32 0, i32 2
%ePtr12648 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12646, i32 0, i32 1
%f12649 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12647
%e12650 = load i8*, i8** %ePtr12648
%tzone12651 = load i8*, i8** %_impzPtr
%zone12652 = bitcast i8* %tzone12651 to %mzone*
%z12653 = bitcast %mzone* %zone12652 to i8*
%result12654 = tail call fastcc double %f12649(i8* %z12653, i8* %e12650, double %val12644)
%val12655 = fsub double %result12642, %result12654
%val12656 = fsub double %val12631, %val12655
%val12657 = fmul double 1.0000000000000000818e-05, 1.0000000000000000818e-05
%val12658 = fdiv double %val12656, %val12657
ret double %val12658
}
@gsxtmmath527 = hidden constant [110 x i8] c"ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12678 = load i8*, i8** %_impzPtr
%zone12679 = bitcast i8* %tzone12678 to %mzone*

; let assign value to symbol ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0
%dat_ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0 = call i8* @llvm_zone_malloc(%mzone* %zone12679, i64 8)
%ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0Ptr = bitcast i8* %dat_ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0 to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***
%tzone12659 = load i8*, i8** %_impzPtr
%zone12660 = bitcast i8* %tzone12659 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12660)
; malloc closure structure
%clsptr12661 = call i8* @llvm_zone_malloc(%mzone* %zone12660, i64 24)
%closure12662 = bitcast i8* %clsptr12661 to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*

; malloc environment structure
%envptr12663 = call i8* @llvm_zone_malloc(%mzone* %zone12660, i64 8)
%environment12664 = bitcast i8* %envptr12663 to {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***}*

; malloc closure address table
%addytable12665 = call %clsvar* @new_address_table()
%var12666 = bitcast [57 x i8]* @gsxtmmath526 to i8*
%var12667 = bitcast [83 x i8]* @gsxtmmath517 to i8*
%addytable12668 = call %clsvar* @add_address_table(%mzone* %zone12660, i8* %var12666, i32 0, i8* %var12667, i32 3, %clsvar* %addytable12665)
%address-table12669 = bitcast %clsvar* %addytable12668 to i8*

; insert table, function and environment into closure struct
%closure.table12672 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure12662, i32 0, i32 0
store i8* %address-table12669, i8** %closure.table12672
%closure.env12673 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure12662, i32 0, i32 1
store i8* %envptr12663, i8** %closure.env12673
%closure.func12674 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure12662, i32 0, i32 2
store double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)* @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0__12606, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)** %closure.func12674
%closure_size12675 = call i64 @llvm_zone_mark_size(%mzone* %zone12660)
call void @llvm_zone_ptr_set_size(i8* %clsptr12661, i64 %closure_size12675)
%wrapper_ptr12676 = call i8* @llvm_zone_malloc(%mzone* %zone12660, i64 8)
%closure_wrapper12677 = bitcast i8* %wrapper_ptr12676 to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**
store { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure12662, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure_wrapper12677

; let value assignment
%ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0 = select i1 true, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure_wrapper12677, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure_wrapper12677
store { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*** %ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0Ptr

; add data to environment
; don't need to alloc for env var ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0
%tmp_envptr12671 = getelementptr {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***}, {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}***}* %environment12664, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*** %ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0Ptr, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**** %tmp_envptr12671


%val12680 = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*** %ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0Ptr
ret {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %val12680
}


@ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var = dllexport global [1 x i8*] [ i8* null ]

@ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0({i8*, i8*, double (i8*, i8*, double)*}** %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1)
ret double %result
}


define dllexport ccc double @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_native({i8*, i8*, double (i8*, i8*, double)*}** %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1)
ret double %result
}


define dllexport ccc i8*  @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12681 = bitcast [110 x i8]* @gsxtmmath527 to i8*
call i32 (i8*, ...) @printf(i8* %var12681)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to {i8*, i8*, double (i8*, i8*, double)*}**
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12682 = bitcast [110 x i8]* @gsxtmmath527 to i8*
call i32 (i8*, ...) @printf(i8* %var12682)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {{i8*, i8*, double (i8*, i8*, double)*}**, double}*
%arg_p_0 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double}, {{i8*, i8*, double (i8*, i8*, double)*}**, double}* %fstruct, i32 0, i32 0
%arg_0 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %arg_p_0
%arg_p_1 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double}, {{i8*, i8*, double (i8*, i8*, double)*}**, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath528 = hidden constant [66 x i8] c"ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd\00"
define dllexport fastcc double @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd__12683(i8* %_impz,i8* %_impenv, {i8*, i8*, double (i8*, i8*, double)*}** %f, double %x, double %dx) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12684 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}*
%ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}* %impenv, i32 0, i32 0
%ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**** %ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr_

; setup arguments
%fPtr = alloca {i8*, i8*, double (i8*, i8*, double)*}**
store {i8*, i8*, double (i8*, i8*, double)*}** %f, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%xPtr = alloca double
store double %x, double* %xPtr
%dxPtr = alloca double
store double %dx, double* %dxPtr


%val12685 = load double, double* %xPtr
%val12686 = load double, double* %dxPtr
%val12687 = fadd double %val12685, %val12686

; apply closure 
%vval12688 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12689 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12688
%fPtr12690 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12689, i32 0, i32 2
%ePtr12691 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12689, i32 0, i32 1
%f12692 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12690
%e12693 = load i8*, i8** %ePtr12691
%tzone12694 = load i8*, i8** %_impzPtr
%zone12695 = bitcast i8* %tzone12694 to %mzone*
%z12696 = bitcast %mzone* %zone12695 to i8*
%result12697 = tail call fastcc double %f12692(i8* %z12696, i8* %e12693, double %val12687)
%val12698 = load double, double* %xPtr

; apply closure 
%vval12699 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12700 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12699
%fPtr12701 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12700, i32 0, i32 2
%ePtr12702 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12700, i32 0, i32 1
%f12703 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12701
%e12704 = load i8*, i8** %ePtr12702
%tzone12705 = load i8*, i8** %_impzPtr
%zone12706 = bitcast i8* %tzone12705 to %mzone*
%z12707 = bitcast %mzone* %zone12706 to i8*
%result12708 = tail call fastcc double %f12703(i8* %z12707, i8* %e12704, double %val12698)
%val12709 = fsub double %result12697, %result12708
%val12710 = load double, double* %xPtr

; apply closure 
%vval12711 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12712 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12711
%fPtr12713 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12712, i32 0, i32 2
%ePtr12714 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12712, i32 0, i32 1
%f12715 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12713
%e12716 = load i8*, i8** %ePtr12714
%tzone12717 = load i8*, i8** %_impzPtr
%zone12718 = bitcast i8* %tzone12717 to %mzone*
%z12719 = bitcast %mzone* %zone12718 to i8*
%result12720 = tail call fastcc double %f12715(i8* %z12719, i8* %e12716, double %val12710)
%val12721 = load double, double* %xPtr
%val12722 = load double, double* %dxPtr
%val12723 = fsub double %val12721, %val12722

; apply closure 
%vval12724 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12725 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12724
%fPtr12726 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12725, i32 0, i32 2
%ePtr12727 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12725, i32 0, i32 1
%f12728 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12726
%e12729 = load i8*, i8** %ePtr12727
%tzone12730 = load i8*, i8** %_impzPtr
%zone12731 = bitcast i8* %tzone12730 to %mzone*
%z12732 = bitcast %mzone* %zone12731 to i8*
%result12733 = tail call fastcc double %f12728(i8* %z12732, i8* %e12729, double %val12723)
%val12734 = fsub double %result12720, %result12733
%val12735 = fsub double %val12709, %val12734
%val12736 = load double, double* %dxPtr
%val12737 = load double, double* %dxPtr
%val12738 = fmul double %val12736, %val12737
%val12739 = fdiv double %val12735, %val12738
ret double %val12739
}
@gsxtmmath529 = hidden constant [119 x i8] c"ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12759 = load i8*, i8** %_impzPtr
%zone12760 = bitcast i8* %tzone12759 to %mzone*

; let assign value to symbol ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd
%dat_ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd = call i8* @llvm_zone_malloc(%mzone* %zone12760, i64 8)
%ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr = bitcast i8* %dat_ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***
%tzone12740 = load i8*, i8** %_impzPtr
%zone12741 = bitcast i8* %tzone12740 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12741)
; malloc closure structure
%clsptr12742 = call i8* @llvm_zone_malloc(%mzone* %zone12741, i64 24)
%closure12743 = bitcast i8* %clsptr12742 to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*

; malloc environment structure
%envptr12744 = call i8* @llvm_zone_malloc(%mzone* %zone12741, i64 8)
%environment12745 = bitcast i8* %envptr12744 to {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}*

; malloc closure address table
%addytable12746 = call %clsvar* @new_address_table()
%var12747 = bitcast [66 x i8]* @gsxtmmath528 to i8*
%var12748 = bitcast [91 x i8]* @gsxtmmath520 to i8*
%addytable12749 = call %clsvar* @add_address_table(%mzone* %zone12741, i8* %var12747, i32 0, i8* %var12748, i32 3, %clsvar* %addytable12746)
%address-table12750 = bitcast %clsvar* %addytable12749 to i8*

; insert table, function and environment into closure struct
%closure.table12753 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure12743, i32 0, i32 0
store i8* %address-table12750, i8** %closure.table12753
%closure.env12754 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure12743, i32 0, i32 1
store i8* %envptr12744, i8** %closure.env12754
%closure.func12755 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure12743, i32 0, i32 2
store double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)* @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd__12683, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)** %closure.func12755
%closure_size12756 = call i64 @llvm_zone_mark_size(%mzone* %zone12741)
call void @llvm_zone_ptr_set_size(i8* %clsptr12742, i64 %closure_size12756)
%wrapper_ptr12757 = call i8* @llvm_zone_malloc(%mzone* %zone12741, i64 8)
%closure_wrapper12758 = bitcast i8* %wrapper_ptr12757 to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**
store { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure12743, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_wrapper12758

; let value assignment
%ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd = select i1 true, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_wrapper12758, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_wrapper12758
store { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*** %ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr

; add data to environment
; don't need to alloc for env var ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd
%tmp_envptr12752 = getelementptr {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}* %environment12745, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*** %ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**** %tmp_envptr12752


%val12761 = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*** %ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr
ret {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %val12761
}


@ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var = dllexport global [1 x i8*] [ i8* null ]

@ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd({i8*, i8*, double (i8*, i8*, double)*}** %arg_0,double %arg_1,double %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1, double %arg_2)
ret double %result
}


define dllexport ccc double @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_native({i8*, i8*, double (i8*, i8*, double)*}** %arg_0,double %arg_1,double %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1, double %arg_2)
ret double %result
}


define dllexport ccc i8*  @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12762 = bitcast [119 x i8]* @gsxtmmath529 to i8*
call i32 (i8*, ...) @printf(i8* %var12762)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to {i8*, i8*, double (i8*, i8*, double)*}**
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12763 = bitcast [119 x i8]* @gsxtmmath529 to i8*
call i32 (i8*, ...) @printf(i8* %var12763)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var12764 = bitcast [119 x i8]* @gsxtmmath529 to i8*
call i32 (i8*, ...) @printf(i8* %var12764)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc double @r64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1, double %arg_2)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}*
%arg_p_0 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}, {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}* %fstruct, i32 0, i32 0
%arg_0 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %arg_p_0
%arg_p_1 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}, {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
%arg_p_2 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}, {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}* %fstruct, i32 0, i32 2
%arg_2 = load double, double* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ndiff2_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1, double %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath530 = hidden constant [76 x i8] c"nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ\00"
@gsxtmmath531 = hidden constant [96 x i8] c"{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}**\00"
define dllexport fastcc double @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ__12765(i8* %_impz,i8* %_impenv, {i8*, i8*, double (i8*, i8*, double)*}** %f, double %xmin, double %xmax, i64 %N) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12766 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}***}*
%nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}***}, {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}***}* %impenv, i32 0, i32 0
%nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQPtr = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}***, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}**** %nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQPtr_

; setup arguments
%fPtr = alloca {i8*, i8*, double (i8*, i8*, double)*}**
store {i8*, i8*, double (i8*, i8*, double)*}** %f, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%xminPtr = alloca double
store double %xmin, double* %xminPtr
%xmaxPtr = alloca double
store double %xmax, double* %xmaxPtr
%NPtr = alloca i64
store i64 %N, i64* %NPtr


%tzone12767 = load i8*, i8** %_impzPtr
%zone12768 = bitcast i8* %tzone12767 to %mzone*

; let assign value to symbol sumeven
%sumevenPtr = alloca double
%tzone12769 = load i8*, i8** %_impzPtr
%zone12770 = bitcast i8* %tzone12769 to %mzone*

; let assign value to symbol sumodd
%sumoddPtr = alloca double
%tzone12771 = load i8*, i8** %_impzPtr
%zone12772 = bitcast i8* %tzone12771 to %mzone*

; let assign value to symbol x
%xPtr = alloca double
%tzone12773 = load i8*, i8** %_impzPtr
%zone12774 = bitcast i8* %tzone12773 to %mzone*

; let assign value to symbol n
%nPtr = alloca i64
%tzone12782 = load i8*, i8** %_impzPtr
%zone12783 = bitcast i8* %tzone12782 to %mzone*

; let assign value to symbol interval
%intervalPtr = alloca double

; let value assignment
%sumeven = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %sumeven, double* %sumevenPtr


; let value assignment
%sumodd = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %sumodd, double* %sumoddPtr


; let value assignment
%x = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %x, double* %xPtr


; let value assignment
%n = select i1 true, i64 0, i64 0
store i64 %n, i64* %nPtr

%val12775 = load double, double* %xmaxPtr
%val12776 = load double, double* %xminPtr
%val12777 = fsub double %val12775, %val12776
%val12778 = load i64, i64* %NPtr
%val12779 = sub i64 %val12778, 1
%res12780 = call ccc double @i64tod(i64 %val12779)
%val12781 = fdiv double %val12777, %res12780

; let value assignment
%interval = select i1 true, double %val12781, double %val12781
store double %interval, double* %intervalPtr

; do set!
store i64 2, i64* %nPtr
; while loop
%val12785 = load i64, i64* %nPtr
%val12786 = load i64, i64* %NPtr
%cmp12787 = icmp slt i64 %val12785, %val12786
br i1 %cmp12787, label %loop12784, label %after12784

loop12784:
; do set!
%val12788 = load double, double* %xminPtr
%val12789 = load double, double* %intervalPtr
%val12790 = load i64, i64* %nPtr
%val12791 = sub i64 %val12790, 1
%res12792 = call ccc double @i64tod(i64 %val12791)
%val12793 = fmul double %val12789, %res12792
%val12794 = fadd double %val12788, %val12793
store double %val12794, double* %xPtr
; do set!
%val12795 = load double, double* %sumoddPtr
%val12796 = load double, double* %xPtr

; apply closure 
%vval12797 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12798 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12797
%fPtr12799 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12798, i32 0, i32 2
%ePtr12800 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12798, i32 0, i32 1
%f12801 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12799
%e12802 = load i8*, i8** %ePtr12800
%tzone12803 = load i8*, i8** %_impzPtr
%zone12804 = bitcast i8* %tzone12803 to %mzone*
%z12805 = bitcast %mzone* %zone12804 to i8*
%result12806 = tail call fastcc double %f12801(i8* %z12805, i8* %e12802, double %val12796)
%val12807 = fadd double %val12795, %result12806
store double %val12807, double* %sumoddPtr
; do set!
%val12808 = load i64, i64* %nPtr
%val12809 = add i64 %val12808, 2
store i64 %val12809, i64* %nPtr
%val12810 = load i64, i64* %nPtr
%val12811 = load i64, i64* %NPtr
%cmp12812 = icmp slt i64 %val12810, %val12811
br i1 %cmp12812, label %loop12784, label %after12784

after12784:
; do set!
store i64 3, i64* %nPtr
; while loop
%val12815 = load i64, i64* %nPtr
%val12816 = load i64, i64* %NPtr
%cmp12817 = icmp slt i64 %val12815, %val12816
br i1 %cmp12817, label %loop12814, label %after12814

loop12814:
; do set!
%val12818 = load double, double* %xminPtr
%val12819 = load double, double* %intervalPtr
%val12820 = load i64, i64* %nPtr
%val12821 = sub i64 %val12820, 1
%res12822 = call ccc double @i64tod(i64 %val12821)
%val12823 = fmul double %val12819, %res12822
%val12824 = fadd double %val12818, %val12823
store double %val12824, double* %xPtr
; do set!
%val12825 = load double, double* %sumevenPtr
%val12826 = load double, double* %xPtr

; apply closure 
%vval12827 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12828 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12827
%fPtr12829 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12828, i32 0, i32 2
%ePtr12830 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12828, i32 0, i32 1
%f12831 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12829
%e12832 = load i8*, i8** %ePtr12830
%tzone12833 = load i8*, i8** %_impzPtr
%zone12834 = bitcast i8* %tzone12833 to %mzone*
%z12835 = bitcast %mzone* %zone12834 to i8*
%result12836 = tail call fastcc double %f12831(i8* %z12835, i8* %e12832, double %val12826)
%val12837 = fadd double %val12825, %result12836
store double %val12837, double* %sumevenPtr
; do set!
%val12838 = load i64, i64* %nPtr
%val12839 = add i64 %val12838, 2
store i64 %val12839, i64* %nPtr
%val12840 = load i64, i64* %nPtr
%val12841 = load i64, i64* %NPtr
%cmp12842 = icmp slt i64 %val12840, %val12841
br i1 %cmp12842, label %loop12814, label %after12814

after12814:
%val12844 = load double, double* %sumevenPtr
%val12845 = fmul double %val12844, 2.0000000000000000000
%val12846 = load double, double* %sumoddPtr
%val12847 = fmul double %val12846, 4.0000000000000000000
%val12848 = fadd double %val12845, %val12847
%val12849 = load double, double* %xminPtr

; apply closure 
%vval12850 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12851 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12850
%fPtr12852 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12851, i32 0, i32 2
%ePtr12853 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12851, i32 0, i32 1
%f12854 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12852
%e12855 = load i8*, i8** %ePtr12853
%tzone12856 = load i8*, i8** %_impzPtr
%zone12857 = bitcast i8* %tzone12856 to %mzone*
%z12858 = bitcast %mzone* %zone12857 to i8*
%result12859 = tail call fastcc double %f12854(i8* %z12858, i8* %e12855, double %val12849)
%val12860 = fadd double %val12848, %result12859
%val12861 = load double, double* %xmaxPtr

; apply closure 
%vval12862 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12863 = load {i8*, i8*, double (i8*, i8*, double)*}*,{i8*, i8*, double (i8*, i8*, double)*}** %vval12862
%fPtr12864 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12863, i32 0, i32 2
%ePtr12865 = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %val12863, i32 0, i32 1
%f12866 = load double (i8*, i8*, double)*, double (i8*, i8*, double)** %fPtr12864
%e12867 = load i8*, i8** %ePtr12865
%tzone12868 = load i8*, i8** %_impzPtr
%zone12869 = bitcast i8* %tzone12868 to %mzone*
%z12870 = bitcast %mzone* %zone12869 to i8*
%result12871 = tail call fastcc double %f12866(i8* %z12870, i8* %e12867, double %val12861)
%val12872 = fadd double %val12860, %result12871
%val12873 = load double, double* %intervalPtr
%val12874 = fdiv double %val12873, 3.0000000000000000000
%val12875 = fmul double %val12872, %val12874
ret double %val12875
}
@gsxtmmath532 = hidden constant [129 x i8] c"nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}** @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12895 = load i8*, i8** %_impzPtr
%zone12896 = bitcast i8* %tzone12895 to %mzone*

; let assign value to symbol nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ
%dat_nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone12896, i64 8)
%nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQPtr = bitcast i8* %dat_nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}***
%tzone12876 = load i8*, i8** %_impzPtr
%zone12877 = bitcast i8* %tzone12876 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12877)
; malloc closure structure
%clsptr12878 = call i8* @llvm_zone_malloc(%mzone* %zone12877, i64 24)
%closure12879 = bitcast i8* %clsptr12878 to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}*

; malloc environment structure
%envptr12880 = call i8* @llvm_zone_malloc(%mzone* %zone12877, i64 8)
%environment12881 = bitcast i8* %envptr12880 to {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}***}*

; malloc closure address table
%addytable12882 = call %clsvar* @new_address_table()
%var12883 = bitcast [76 x i8]* @gsxtmmath530 to i8*
%var12884 = bitcast [96 x i8]* @gsxtmmath531 to i8*
%addytable12885 = call %clsvar* @add_address_table(%mzone* %zone12877, i8* %var12883, i32 0, i8* %var12884, i32 3, %clsvar* %addytable12882)
%address-table12886 = bitcast %clsvar* %addytable12885 to i8*

; insert table, function and environment into closure struct
%closure.table12889 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}* %closure12879, i32 0, i32 0
store i8* %address-table12886, i8** %closure.table12889
%closure.env12890 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}* %closure12879, i32 0, i32 1
store i8* %envptr12880, i8** %closure.env12890
%closure.func12891 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}* %closure12879, i32 0, i32 2
store double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)* @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ__12765, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)** %closure.func12891
%closure_size12892 = call i64 @llvm_zone_mark_size(%mzone* %zone12877)
call void @llvm_zone_ptr_set_size(i8* %clsptr12878, i64 %closure_size12892)
%wrapper_ptr12893 = call i8* @llvm_zone_malloc(%mzone* %zone12877, i64 8)
%closure_wrapper12894 = bitcast i8* %wrapper_ptr12893 to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}**
store { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}* %closure12879, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}** %closure_wrapper12894

; let value assignment
%nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ = select i1 true, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}** %closure_wrapper12894, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}** %closure_wrapper12894
store { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}** %nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}*** %nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQPtr

; add data to environment
; don't need to alloc for env var nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ
%tmp_envptr12888 = getelementptr {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}***}, {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}***}* %environment12881, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}*** %nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQPtr, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}**** %tmp_envptr12888


%val12897 = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}**, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}*** %nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQPtr
ret {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}** %val12897
}


@nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}** @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ({i8*, i8*, double (i8*, i8*, double)*}** %arg_0,double %arg_1,double %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1, double %arg_2, i64 %arg_3)
ret double %result
}


define dllexport ccc double @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ_native({i8*, i8*, double (i8*, i8*, double)*}** %arg_0,double %arg_1,double %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1, double %arg_2, i64 %arg_3)
ret double %result
}


define dllexport ccc i8*  @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12898 = bitcast [129 x i8]* @gsxtmmath532 to i8*
call i32 (i8*, ...) @printf(i8* %var12898)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to {i8*, i8*, double (i8*, i8*, double)*}**
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12899 = bitcast [129 x i8]* @gsxtmmath532 to i8*
call i32 (i8*, ...) @printf(i8* %var12899)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var12900 = bitcast [129 x i8]* @gsxtmmath532 to i8*
call i32 (i8*, ...) @printf(i8* %var12900)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc double @r64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var12901 = bitcast [129 x i8]* @gsxtmmath532 to i8*
call i32 (i8*, ...) @printf(i8* %var12901)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1, double %arg_2, i64 %arg_3)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {{i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64}*
%arg_p_0 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64}, {{i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64}* %fstruct, i32 0, i32 0
%arg_0 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %arg_p_0
%arg_p_1 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64}, {{i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
%arg_p_2 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64}, {{i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64}* %fstruct, i32 0, i32 2
%arg_2 = load double, double* %arg_p_2
%arg_p_3 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64}, {{i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1, double %arg_2, i64 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath533 = hidden constant [70 x i8] c"nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd\00"
define dllexport fastcc double @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd__12902(i8* %_impz,i8* %_impenv, {i8*, i8*, double (i8*, i8*, double)*}** %f, double %xmin, double %xmax) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12903 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}*
%nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}* %impenv, i32 0, i32 0
%nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**** %nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr_

; setup arguments
%fPtr = alloca {i8*, i8*, double (i8*, i8*, double)*}**
store {i8*, i8*, double (i8*, i8*, double)*}** %f, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%xminPtr = alloca double
store double %xmin, double* %xminPtr
%xmaxPtr = alloca double
store double %xmax, double* %xmaxPtr


%val12904 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fPtr
%val12905 = load double, double* %xminPtr
%val12906 = load double, double* %xmaxPtr
%res12907 = call fastcc double @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGUsaTY0XQ({i8*, i8*, double (i8*, i8*, double)*}** %val12904, double %val12905, double %val12906, i64 501)
ret double %res12907
}
@gsxtmmath534 = hidden constant [123 x i8] c"nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12927 = load i8*, i8** %_impzPtr
%zone12928 = bitcast i8* %tzone12927 to %mzone*

; let assign value to symbol nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd
%dat_nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd = call i8* @llvm_zone_malloc(%mzone* %zone12928, i64 8)
%nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr = bitcast i8* %dat_nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***
%tzone12908 = load i8*, i8** %_impzPtr
%zone12909 = bitcast i8* %tzone12908 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12909)
; malloc closure structure
%clsptr12910 = call i8* @llvm_zone_malloc(%mzone* %zone12909, i64 24)
%closure12911 = bitcast i8* %clsptr12910 to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*

; malloc environment structure
%envptr12912 = call i8* @llvm_zone_malloc(%mzone* %zone12909, i64 8)
%environment12913 = bitcast i8* %envptr12912 to {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}*

; malloc closure address table
%addytable12914 = call %clsvar* @new_address_table()
%var12915 = bitcast [70 x i8]* @gsxtmmath533 to i8*
%var12916 = bitcast [91 x i8]* @gsxtmmath520 to i8*
%addytable12917 = call %clsvar* @add_address_table(%mzone* %zone12909, i8* %var12915, i32 0, i8* %var12916, i32 3, %clsvar* %addytable12914)
%address-table12918 = bitcast %clsvar* %addytable12917 to i8*

; insert table, function and environment into closure struct
%closure.table12921 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure12911, i32 0, i32 0
store i8* %address-table12918, i8** %closure.table12921
%closure.env12922 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure12911, i32 0, i32 1
store i8* %envptr12912, i8** %closure.env12922
%closure.func12923 = getelementptr { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure12911, i32 0, i32 2
store double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)* @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd__12902, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)** %closure.func12923
%closure_size12924 = call i64 @llvm_zone_mark_size(%mzone* %zone12909)
call void @llvm_zone_ptr_set_size(i8* %clsptr12910, i64 %closure_size12924)
%wrapper_ptr12925 = call i8* @llvm_zone_malloc(%mzone* %zone12909, i64 8)
%closure_wrapper12926 = bitcast i8* %wrapper_ptr12925 to { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**
store { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure12911, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_wrapper12926

; let value assignment
%nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd = select i1 true, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_wrapper12926, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_wrapper12926
store { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd, { i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*** %nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr

; add data to environment
; don't need to alloc for env var nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd
%tmp_envptr12920 = getelementptr {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}***}* %environment12913, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*** %nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**** %tmp_envptr12920


%val12929 = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*** %nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVdPtr
ret {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %val12929
}


@nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var = dllexport global [1 x i8*] [ i8* null ]

@nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd({i8*, i8*, double (i8*, i8*, double)*}** %arg_0,double %arg_1,double %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1, double %arg_2)
ret double %result
}


define dllexport ccc double @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_native({i8*, i8*, double (i8*, i8*, double)*}** %arg_0,double %arg_1,double %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1, double %arg_2)
ret double %result
}


define dllexport ccc i8*  @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12930 = bitcast [123 x i8]* @gsxtmmath534 to i8*
call i32 (i8*, ...) @printf(i8* %var12930)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to {i8*, i8*, double (i8*, i8*, double)*}**
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12931 = bitcast [123 x i8]* @gsxtmmath534 to i8*
call i32 (i8*, ...) @printf(i8* %var12931)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var12932 = bitcast [123 x i8]* @gsxtmmath534 to i8*
call i32 (i8*, ...) @printf(i8* %var12932)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc double @r64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1, double %arg_2)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}*
%arg_p_0 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}, {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}* %fstruct, i32 0, i32 0
%arg_0 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %arg_p_0
%arg_p_1 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}, {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
%arg_p_2 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}, {{i8*, i8*, double (i8*, i8*, double)*}**, double, double}* %fstruct, i32 0, i32 2
%arg_2 = load double, double* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nintegrate_adhoc_W2RvdWJsZSxbZG91YmxlLGRvdWJsZV0qLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}*, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}, {i8*, i8*, double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)*,  double (i8*, i8*, {i8*, i8*, double (i8*, i8*, double)*}**, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, {i8*, i8*, double (i8*, i8*, double)*}** %arg_0, double %arg_1, double %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath535 = hidden constant [32 x i8] c"fade_adhoc_W2RvdWJsZSxkb3VibGVd\00"
define dllexport fastcc double @fade_adhoc_W2RvdWJsZSxkb3VibGVd__12933(i8* %_impz,i8* %_impenv, double %t) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12934 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, double)*}***}*
%fade_adhoc_W2RvdWJsZSxkb3VibGVdPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}***}, {{i8*, i8*, double (i8*, i8*, double)*}***}* %impenv, i32 0, i32 0
%fade_adhoc_W2RvdWJsZSxkb3VibGVdPtr = load {i8*, i8*, double (i8*, i8*, double)*}***, {i8*, i8*, double (i8*, i8*, double)*}**** %fade_adhoc_W2RvdWJsZSxkb3VibGVdPtr_

; setup arguments
%tPtr = alloca double
store double %t, double* %tPtr


%val12935 = load double, double* %tPtr
%val12936 = load double, double* %tPtr
%val12937 = fmul double %val12935, %val12936
%val12938 = load double, double* %tPtr
%val12939 = fmul double %val12937, %val12938
%val12940 = load double, double* %tPtr
%val12941 = load double, double* %tPtr
%val12942 = fmul double %val12941, 6.0000000000000000000
%val12943 = fsub double %val12942, 15.000000000000000000
%val12944 = fmul double %val12940, %val12943
%val12945 = fadd double %val12944, 10.000000000000000000
%val12946 = fmul double %val12939, %val12945
ret double %val12946
}
@gsxtmmath536 = hidden constant [85 x i8] c"fade_adhoc_W2RvdWJsZSxkb3VibGVd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, double)*}** @fade_adhoc_W2RvdWJsZSxkb3VibGVd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12966 = load i8*, i8** %_impzPtr
%zone12967 = bitcast i8* %tzone12966 to %mzone*

; let assign value to symbol fade_adhoc_W2RvdWJsZSxkb3VibGVd
%dat_fade_adhoc_W2RvdWJsZSxkb3VibGVd = call i8* @llvm_zone_malloc(%mzone* %zone12967, i64 8)
%fade_adhoc_W2RvdWJsZSxkb3VibGVdPtr = bitcast i8* %dat_fade_adhoc_W2RvdWJsZSxkb3VibGVd to { i8*, i8*, double (i8*, i8*, double)*}***
%tzone12947 = load i8*, i8** %_impzPtr
%zone12948 = bitcast i8* %tzone12947 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12948)
; malloc closure structure
%clsptr12949 = call i8* @llvm_zone_malloc(%mzone* %zone12948, i64 24)
%closure12950 = bitcast i8* %clsptr12949 to { i8*, i8*, double (i8*, i8*, double)*}*

; malloc environment structure
%envptr12951 = call i8* @llvm_zone_malloc(%mzone* %zone12948, i64 8)
%environment12952 = bitcast i8* %envptr12951 to {{i8*, i8*, double (i8*, i8*, double)*}***}*

; malloc closure address table
%addytable12953 = call %clsvar* @new_address_table()
%var12954 = bitcast [32 x i8]* @gsxtmmath535 to i8*
%var12955 = bitcast [41 x i8]* @gsxtmmath495 to i8*
%addytable12956 = call %clsvar* @add_address_table(%mzone* %zone12948, i8* %var12954, i32 0, i8* %var12955, i32 3, %clsvar* %addytable12953)
%address-table12957 = bitcast %clsvar* %addytable12956 to i8*

; insert table, function and environment into closure struct
%closure.table12960 = getelementptr { i8*, i8*, double (i8*, i8*, double)*}, { i8*, i8*, double (i8*, i8*, double)*}* %closure12950, i32 0, i32 0
store i8* %address-table12957, i8** %closure.table12960
%closure.env12961 = getelementptr { i8*, i8*, double (i8*, i8*, double)*}, { i8*, i8*, double (i8*, i8*, double)*}* %closure12950, i32 0, i32 1
store i8* %envptr12951, i8** %closure.env12961
%closure.func12962 = getelementptr { i8*, i8*, double (i8*, i8*, double)*}, { i8*, i8*, double (i8*, i8*, double)*}* %closure12950, i32 0, i32 2
store double (i8*, i8*, double)* @fade_adhoc_W2RvdWJsZSxkb3VibGVd__12933, double (i8*, i8*, double)** %closure.func12962
%closure_size12963 = call i64 @llvm_zone_mark_size(%mzone* %zone12948)
call void @llvm_zone_ptr_set_size(i8* %clsptr12949, i64 %closure_size12963)
%wrapper_ptr12964 = call i8* @llvm_zone_malloc(%mzone* %zone12948, i64 8)
%closure_wrapper12965 = bitcast i8* %wrapper_ptr12964 to { i8*, i8*, double (i8*, i8*, double)*}**
store { i8*, i8*, double (i8*, i8*, double)*}* %closure12950, { i8*, i8*, double (i8*, i8*, double)*}** %closure_wrapper12965

; let value assignment
%fade_adhoc_W2RvdWJsZSxkb3VibGVd = select i1 true, { i8*, i8*, double (i8*, i8*, double)*}** %closure_wrapper12965, { i8*, i8*, double (i8*, i8*, double)*}** %closure_wrapper12965
store { i8*, i8*, double (i8*, i8*, double)*}** %fade_adhoc_W2RvdWJsZSxkb3VibGVd, { i8*, i8*, double (i8*, i8*, double)*}*** %fade_adhoc_W2RvdWJsZSxkb3VibGVdPtr

; add data to environment
; don't need to alloc for env var fade_adhoc_W2RvdWJsZSxkb3VibGVd
%tmp_envptr12959 = getelementptr {{i8*, i8*, double (i8*, i8*, double)*}***}, {{i8*, i8*, double (i8*, i8*, double)*}***}* %environment12952, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, double)*}*** %fade_adhoc_W2RvdWJsZSxkb3VibGVdPtr, {i8*, i8*, double (i8*, i8*, double)*}**** %tmp_envptr12959


%val12968 = load {i8*, i8*, double (i8*, i8*, double)*}**, {i8*, i8*, double (i8*, i8*, double)*}*** %fade_adhoc_W2RvdWJsZSxkb3VibGVdPtr
ret {i8*, i8*, double (i8*, i8*, double)*}** %val12968
}


@fade_adhoc_W2RvdWJsZSxkb3VibGVd_var = dllexport global [1 x i8*] [ i8* null ]

@fade_adhoc_W2RvdWJsZSxkb3VibGVd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @fade_adhoc_W2RvdWJsZSxkb3VibGVd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @fade_adhoc_W2RvdWJsZSxkb3VibGVd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, double)*}** @fade_adhoc_W2RvdWJsZSxkb3VibGVd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @fade_adhoc_W2RvdWJsZSxkb3VibGVd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @fade_adhoc_W2RvdWJsZSxkb3VibGVd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fade_adhoc_W2RvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @fade_adhoc_W2RvdWJsZSxkb3VibGVd(double %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fade_adhoc_W2RvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double)*}*, {i8*, i8*, double (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double)*,  double (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0)
ret double %result
}


define dllexport ccc double @fade_adhoc_W2RvdWJsZSxkb3VibGVd_native(double %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fade_adhoc_W2RvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double)*}*, {i8*, i8*, double (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double)*,  double (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0)
ret double %result
}


define dllexport ccc i8*  @fade_adhoc_W2RvdWJsZSxkb3VibGVd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12969 = bitcast [85 x i8]* @gsxtmmath536 to i8*
call i32 (i8*, ...) @printf(i8* %var12969)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc double @r64value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fade_adhoc_W2RvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double)*}*, {i8*, i8*, double (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double)*,  double (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @fade_adhoc_W2RvdWJsZSxkb3VibGVd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double}*
%arg_p_0 = getelementptr {double}, {double}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fade_adhoc_W2RvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double)*}*, {i8*, i8*, double (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double)*}, {i8*, i8*, double (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double)*,  double (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath537 = hidden constant [56 x i8] c"grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd\00"
@gsxtmmath538 = hidden constant [62 x i8] c"{i8*, i8*, double (i8*, i8*, i64, double, double, double)*}**\00"
define dllexport fastcc double @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd__12970(i8* %_impz,i8* %_impenv, i64 %hash, double %x, double %y, double %z) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12971 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, i64, double, double, double)*}***}*
%grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVdPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, i64, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, i64, double, double, double)*}***}* %impenv, i32 0, i32 0
%grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVdPtr = load {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}***, {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}**** %grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVdPtr_

; setup arguments
%hashPtr = alloca i64
store i64 %hash, i64* %hashPtr
%xPtr = alloca double
store double %x, double* %xPtr
%yPtr = alloca double
store double %y, double* %yPtr
%zPtr = alloca double
store double %z, double* %zPtr


; do set!
%val12972 = load i64, i64* %hashPtr
%val12973 = and i64 %val12972, 15
store i64 %val12973, i64* %hashPtr
%val12975 = load i64, i64* %hashPtr
%cmp12976 = icmp eq i64 %val12975, 0
br i1 %cmp12976, label %then12974, label %else12974

then12974:
%val12977 = load double, double* %xPtr
%val12978 = load double, double* %yPtr
%val12979 = fadd double %val12977, %val12978
ret double %val12979

else12974:
%val12981 = load i64, i64* %hashPtr
%cmp12982 = icmp eq i64 %val12981, 1
br i1 %cmp12982, label %then12980, label %else12980

then12980:
%val12983 = load double, double* %xPtr
%val12984 = fsub double 0.00000000000000000000, %val12983
%val12985 = load double, double* %yPtr
%val12986 = fadd double %val12984, %val12985
ret double %val12986

else12980:
%val12988 = load i64, i64* %hashPtr
%cmp12989 = icmp eq i64 %val12988, 2
br i1 %cmp12989, label %then12987, label %else12987

then12987:
%val12990 = load double, double* %xPtr
%val12991 = load double, double* %yPtr
%val12992 = fsub double %val12990, %val12991
ret double %val12992

else12987:
%val12994 = load i64, i64* %hashPtr
%cmp12995 = icmp eq i64 %val12994, 3
br i1 %cmp12995, label %then12993, label %else12993

then12993:
%val12996 = load double, double* %xPtr
%val12997 = fsub double 0.00000000000000000000, %val12996
%val12998 = load double, double* %yPtr
%val12999 = fsub double %val12997, %val12998
ret double %val12999

else12993:
%val13001 = load i64, i64* %hashPtr
%cmp13002 = icmp eq i64 %val13001, 4
br i1 %cmp13002, label %then13000, label %else13000

then13000:
%val13003 = load double, double* %xPtr
%val13004 = load double, double* %zPtr
%val13005 = fadd double %val13003, %val13004
ret double %val13005

else13000:
%val13007 = load i64, i64* %hashPtr
%cmp13008 = icmp eq i64 %val13007, 5
br i1 %cmp13008, label %then13006, label %else13006

then13006:
%val13009 = load double, double* %xPtr
%val13010 = fsub double 0.00000000000000000000, %val13009
%val13011 = load double, double* %zPtr
%val13012 = fadd double %val13010, %val13011
ret double %val13012

else13006:
%val13014 = load i64, i64* %hashPtr
%cmp13015 = icmp eq i64 %val13014, 6
br i1 %cmp13015, label %then13013, label %else13013

then13013:
%val13016 = load double, double* %xPtr
%val13017 = load double, double* %zPtr
%val13018 = fsub double %val13016, %val13017
ret double %val13018

else13013:
%val13020 = load i64, i64* %hashPtr
%cmp13021 = icmp eq i64 %val13020, 7
br i1 %cmp13021, label %then13019, label %else13019

then13019:
%val13022 = load double, double* %xPtr
%val13023 = fsub double 0.00000000000000000000, %val13022
%val13024 = load double, double* %zPtr
%val13025 = fsub double %val13023, %val13024
ret double %val13025

else13019:
%val13027 = load i64, i64* %hashPtr
%cmp13028 = icmp eq i64 %val13027, 8
br i1 %cmp13028, label %then13026, label %else13026

then13026:
%val13029 = load double, double* %yPtr
%val13030 = load double, double* %zPtr
%val13031 = fadd double %val13029, %val13030
ret double %val13031

else13026:
%val13033 = load i64, i64* %hashPtr
%cmp13034 = icmp eq i64 %val13033, 9
br i1 %cmp13034, label %then13032, label %else13032

then13032:
%val13035 = load double, double* %yPtr
%val13036 = fsub double 0.00000000000000000000, %val13035
%val13037 = load double, double* %zPtr
%val13038 = fadd double %val13036, %val13037
ret double %val13038

else13032:
%val13040 = load i64, i64* %hashPtr
%cmp13041 = icmp eq i64 %val13040, 10
br i1 %cmp13041, label %then13039, label %else13039

then13039:
%val13042 = load double, double* %yPtr
%val13043 = load double, double* %zPtr
%val13044 = fsub double %val13042, %val13043
ret double %val13044

else13039:
%val13046 = load i64, i64* %hashPtr
%cmp13047 = icmp eq i64 %val13046, 11
br i1 %cmp13047, label %then13045, label %else13045

then13045:
%val13048 = load double, double* %yPtr
%val13049 = fsub double 0.00000000000000000000, %val13048
%val13050 = load double, double* %zPtr
%val13051 = fsub double %val13049, %val13050
ret double %val13051

else13045:
%val13053 = load i64, i64* %hashPtr
%cmp13054 = icmp eq i64 %val13053, 12
br i1 %cmp13054, label %then13052, label %else13052

then13052:
%val13055 = load double, double* %yPtr
%val13056 = load double, double* %xPtr
%val13057 = fadd double %val13055, %val13056
ret double %val13057

else13052:
%val13059 = load i64, i64* %hashPtr
%cmp13060 = icmp eq i64 %val13059, 13
br i1 %cmp13060, label %then13058, label %else13058

then13058:
%val13061 = load double, double* %yPtr
%val13062 = fsub double 0.00000000000000000000, %val13061
%val13063 = load double, double* %zPtr
%val13064 = fadd double %val13062, %val13063
ret double %val13064

else13058:
%val13066 = load i64, i64* %hashPtr
%cmp13067 = icmp eq i64 %val13066, 14
br i1 %cmp13067, label %then13065, label %else13065

then13065:
%val13068 = load double, double* %yPtr
%val13069 = load double, double* %xPtr
%val13070 = fsub double %val13068, %val13069
ret double %val13070

else13065:
%val13072 = load i64, i64* %hashPtr
%cmp13073 = icmp eq i64 %val13072, 15
br i1 %cmp13073, label %then13071, label %else13071

then13071:
%val13074 = load double, double* %yPtr
%val13075 = fsub double 0.00000000000000000000, %val13074
%val13076 = load double, double* %zPtr
%val13077 = fsub double %val13075, %val13076
ret double %val13077

else13071:
ret double 0.00000000000000000000
}
@gsxtmmath539 = hidden constant [109 x i8] c"grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}** @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13097 = load i8*, i8** %_impzPtr
%zone13098 = bitcast i8* %tzone13097 to %mzone*

; let assign value to symbol grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd
%dat_grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd = call i8* @llvm_zone_malloc(%mzone* %zone13098, i64 8)
%grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVdPtr = bitcast i8* %dat_grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd to { i8*, i8*, double (i8*, i8*, i64, double, double, double)*}***
%tzone13078 = load i8*, i8** %_impzPtr
%zone13079 = bitcast i8* %tzone13078 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13079)
; malloc closure structure
%clsptr13080 = call i8* @llvm_zone_malloc(%mzone* %zone13079, i64 24)
%closure13081 = bitcast i8* %clsptr13080 to { i8*, i8*, double (i8*, i8*, i64, double, double, double)*}*

; malloc environment structure
%envptr13082 = call i8* @llvm_zone_malloc(%mzone* %zone13079, i64 8)
%environment13083 = bitcast i8* %envptr13082 to {{i8*, i8*, double (i8*, i8*, i64, double, double, double)*}***}*

; malloc closure address table
%addytable13084 = call %clsvar* @new_address_table()
%var13085 = bitcast [56 x i8]* @gsxtmmath537 to i8*
%var13086 = bitcast [62 x i8]* @gsxtmmath538 to i8*
%addytable13087 = call %clsvar* @add_address_table(%mzone* %zone13079, i8* %var13085, i32 0, i8* %var13086, i32 3, %clsvar* %addytable13084)
%address-table13088 = bitcast %clsvar* %addytable13087 to i8*

; insert table, function and environment into closure struct
%closure.table13091 = getelementptr { i8*, i8*, double (i8*, i8*, i64, double, double, double)*}, { i8*, i8*, double (i8*, i8*, i64, double, double, double)*}* %closure13081, i32 0, i32 0
store i8* %address-table13088, i8** %closure.table13091
%closure.env13092 = getelementptr { i8*, i8*, double (i8*, i8*, i64, double, double, double)*}, { i8*, i8*, double (i8*, i8*, i64, double, double, double)*}* %closure13081, i32 0, i32 1
store i8* %envptr13082, i8** %closure.env13092
%closure.func13093 = getelementptr { i8*, i8*, double (i8*, i8*, i64, double, double, double)*}, { i8*, i8*, double (i8*, i8*, i64, double, double, double)*}* %closure13081, i32 0, i32 2
store double (i8*, i8*, i64, double, double, double)* @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd__12970, double (i8*, i8*, i64, double, double, double)** %closure.func13093
%closure_size13094 = call i64 @llvm_zone_mark_size(%mzone* %zone13079)
call void @llvm_zone_ptr_set_size(i8* %clsptr13080, i64 %closure_size13094)
%wrapper_ptr13095 = call i8* @llvm_zone_malloc(%mzone* %zone13079, i64 8)
%closure_wrapper13096 = bitcast i8* %wrapper_ptr13095 to { i8*, i8*, double (i8*, i8*, i64, double, double, double)*}**
store { i8*, i8*, double (i8*, i8*, i64, double, double, double)*}* %closure13081, { i8*, i8*, double (i8*, i8*, i64, double, double, double)*}** %closure_wrapper13096

; let value assignment
%grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd = select i1 true, { i8*, i8*, double (i8*, i8*, i64, double, double, double)*}** %closure_wrapper13096, { i8*, i8*, double (i8*, i8*, i64, double, double, double)*}** %closure_wrapper13096
store { i8*, i8*, double (i8*, i8*, i64, double, double, double)*}** %grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd, { i8*, i8*, double (i8*, i8*, i64, double, double, double)*}*** %grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVdPtr

; add data to environment
; don't need to alloc for env var grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd
%tmp_envptr13090 = getelementptr {{i8*, i8*, double (i8*, i8*, i64, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, i64, double, double, double)*}***}* %environment13083, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}*** %grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVdPtr, {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}**** %tmp_envptr13090


%val13099 = load {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}**, {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}*** %grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVdPtr
ret {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}** %val13099
}


@grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd_var = dllexport global [1 x i8*] [ i8* null ]

@grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}** @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd(i64 %arg_0,double %arg_1,double %arg_2,double %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}*, {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}, {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}, {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, i64, double, double, double)*,  double (i8*, i8*, i64, double, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, i64 %arg_0, double %arg_1, double %arg_2, double %arg_3)
ret double %result
}


define dllexport ccc double @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd_native(i64 %arg_0,double %arg_1,double %arg_2,double %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}*, {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}, {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}, {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, i64, double, double, double)*,  double (i8*, i8*, i64, double, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, i64 %arg_0, double %arg_1, double %arg_2, double %arg_3)
ret double %result
}


define dllexport ccc i8*  @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13100 = bitcast [109 x i8]* @gsxtmmath539 to i8*
call i32 (i8*, ...) @printf(i8* %var13100)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var13101 = bitcast [109 x i8]* @gsxtmmath539 to i8*
call i32 (i8*, ...) @printf(i8* %var13101)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var13102 = bitcast [109 x i8]* @gsxtmmath539 to i8*
call i32 (i8*, ...) @printf(i8* %var13102)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc double @r64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var13103 = bitcast [109 x i8]* @gsxtmmath539 to i8*
call i32 (i8*, ...) @printf(i8* %var13103)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc double @r64value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}*, {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}, {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}, {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, i64, double, double, double)*,  double (i8*, i8*, i64, double, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, i64 %arg_0, double %arg_1, double %arg_2, double %arg_3)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, double, double, double}*
%arg_p_0 = getelementptr {i64, double, double, double}, {i64, double, double, double}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, double, double, double}, {i64, double, double, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
%arg_p_2 = getelementptr {i64, double, double, double}, {i64, double, double, double}* %fstruct, i32 0, i32 2
%arg_2 = load double, double* %arg_p_2
%arg_p_3 = getelementptr {i64, double, double, double}, {i64, double, double, double}* %fstruct, i32 0, i32 3
%arg_3 = load double, double* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}*, {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}, {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}, {i8*, i8*, double (i8*, i8*, i64, double, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, i64, double, double, double)*,  double (i8*, i8*, i64, double, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, i64 %arg_0, double %arg_1, double %arg_2, double %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath540 = hidden constant [51 x i8] c"lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0\00"
@gsxtmmath541 = hidden constant [57 x i8] c"{i8*, i8*, double (i8*, i8*, double, double, double)*}**\00"
define dllexport fastcc double @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0__13104(i8* %_impz,i8* %_impenv, double %a, double %b, double %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13105 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, double, double, double)*}***}*
%lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 0
%lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0Ptr = load {i8*, i8*, double (i8*, i8*, double, double, double)*}***, {i8*, i8*, double (i8*, i8*, double, double, double)*}**** %lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0Ptr_

; setup arguments
%aPtr = alloca double
store double %a, double* %aPtr
%bPtr = alloca double
store double %b, double* %bPtr
%xPtr = alloca double
store double %x, double* %xPtr


%val13106 = load double, double* %aPtr
%val13107 = load double, double* %xPtr
%val13108 = load double, double* %bPtr
%val13109 = load double, double* %aPtr
%val13110 = fsub double %val13108, %val13109
%val13111 = fmul double %val13107, %val13110
%val13112 = fadd double %val13106, %val13111
ret double %val13112
}
@gsxtmmath542 = hidden constant [104 x i8] c"lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, double, double, double)*}** @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13132 = load i8*, i8** %_impzPtr
%zone13133 = bitcast i8* %tzone13132 to %mzone*

; let assign value to symbol lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0
%dat_lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0 = call i8* @llvm_zone_malloc(%mzone* %zone13133, i64 8)
%lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0Ptr = bitcast i8* %dat_lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0 to { i8*, i8*, double (i8*, i8*, double, double, double)*}***
%tzone13113 = load i8*, i8** %_impzPtr
%zone13114 = bitcast i8* %tzone13113 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13114)
; malloc closure structure
%clsptr13115 = call i8* @llvm_zone_malloc(%mzone* %zone13114, i64 24)
%closure13116 = bitcast i8* %clsptr13115 to { i8*, i8*, double (i8*, i8*, double, double, double)*}*

; malloc environment structure
%envptr13117 = call i8* @llvm_zone_malloc(%mzone* %zone13114, i64 8)
%environment13118 = bitcast i8* %envptr13117 to {{i8*, i8*, double (i8*, i8*, double, double, double)*}***}*

; malloc closure address table
%addytable13119 = call %clsvar* @new_address_table()
%var13120 = bitcast [51 x i8]* @gsxtmmath540 to i8*
%var13121 = bitcast [57 x i8]* @gsxtmmath541 to i8*
%addytable13122 = call %clsvar* @add_address_table(%mzone* %zone13114, i8* %var13120, i32 0, i8* %var13121, i32 3, %clsvar* %addytable13119)
%address-table13123 = bitcast %clsvar* %addytable13122 to i8*

; insert table, function and environment into closure struct
%closure.table13126 = getelementptr { i8*, i8*, double (i8*, i8*, double, double, double)*}, { i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure13116, i32 0, i32 0
store i8* %address-table13123, i8** %closure.table13126
%closure.env13127 = getelementptr { i8*, i8*, double (i8*, i8*, double, double, double)*}, { i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure13116, i32 0, i32 1
store i8* %envptr13117, i8** %closure.env13127
%closure.func13128 = getelementptr { i8*, i8*, double (i8*, i8*, double, double, double)*}, { i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure13116, i32 0, i32 2
store double (i8*, i8*, double, double, double)* @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0__13104, double (i8*, i8*, double, double, double)** %closure.func13128
%closure_size13129 = call i64 @llvm_zone_mark_size(%mzone* %zone13114)
call void @llvm_zone_ptr_set_size(i8* %clsptr13115, i64 %closure_size13129)
%wrapper_ptr13130 = call i8* @llvm_zone_malloc(%mzone* %zone13114, i64 8)
%closure_wrapper13131 = bitcast i8* %wrapper_ptr13130 to { i8*, i8*, double (i8*, i8*, double, double, double)*}**
store { i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure13116, { i8*, i8*, double (i8*, i8*, double, double, double)*}** %closure_wrapper13131

; let value assignment
%lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0 = select i1 true, { i8*, i8*, double (i8*, i8*, double, double, double)*}** %closure_wrapper13131, { i8*, i8*, double (i8*, i8*, double, double, double)*}** %closure_wrapper13131
store { i8*, i8*, double (i8*, i8*, double, double, double)*}** %lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0, { i8*, i8*, double (i8*, i8*, double, double, double)*}*** %lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0Ptr

; add data to environment
; don't need to alloc for env var lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0
%tmp_envptr13125 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13118, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, double, double, double)*}*** %lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0Ptr, {i8*, i8*, double (i8*, i8*, double, double, double)*}**** %tmp_envptr13125


%val13134 = load {i8*, i8*, double (i8*, i8*, double, double, double)*}**, {i8*, i8*, double (i8*, i8*, double, double, double)*}*** %lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0Ptr
ret {i8*, i8*, double (i8*, i8*, double, double, double)*}** %val13134
}


@lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_var = dllexport global [1 x i8*] [ i8* null ]

@lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, double, double, double)*}** @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, double, double, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0(double %arg_0,double %arg_1,double %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, double, double)*}*, {i8*, i8*, double (i8*, i8*, double, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, double, double)*}, {i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, double, double)*}, {i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, double, double)*,  double (i8*, i8*, double, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1, double %arg_2)
ret double %result
}


define dllexport ccc double @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_native(double %arg_0,double %arg_1,double %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, double, double)*}*, {i8*, i8*, double (i8*, i8*, double, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, double, double)*}, {i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, double, double)*}, {i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, double, double)*,  double (i8*, i8*, double, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1, double %arg_2)
ret double %result
}


define dllexport ccc i8*  @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13135 = bitcast [104 x i8]* @gsxtmmath542 to i8*
call i32 (i8*, ...) @printf(i8* %var13135)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc double @r64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var13136 = bitcast [104 x i8]* @gsxtmmath542 to i8*
call i32 (i8*, ...) @printf(i8* %var13136)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var13137 = bitcast [104 x i8]* @gsxtmmath542 to i8*
call i32 (i8*, ...) @printf(i8* %var13137)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc double @r64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, double, double)*}*, {i8*, i8*, double (i8*, i8*, double, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, double, double)*}, {i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, double, double)*}, {i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, double, double)*,  double (i8*, i8*, double, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1, double %arg_2)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double, double, double}*
%arg_p_0 = getelementptr {double, double, double}, {double, double, double}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
%arg_p_1 = getelementptr {double, double, double}, {double, double, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
%arg_p_2 = getelementptr {double, double, double}, {double, double, double}* %fstruct, i32 0, i32 2
%arg_2 = load double, double* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, double, double)*}*, {i8*, i8*, double (i8*, i8*, double, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, double, double)*}, {i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, double, double)*}, {i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, double, double)*,  double (i8*, i8*, double, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1, double %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmmath543 = hidden constant [53 x i8] c"perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0\00"
@gsxtmmath544 = hidden constant [3 x i8] c"y2\00"
@gsxtmmath545 = hidden constant [3 x i8] c"y1\00"
@gsxtmmath546 = hidden constant [3 x i8] c"x2\00"
@gsxtmmath547 = hidden constant [3 x i8] c"x1\00"
@gsxtmmath548 = hidden constant [4 x i8] c"bbb\00"
@gsxtmmath549 = hidden constant [4 x i8] c"bab\00"
@gsxtmmath550 = hidden constant [4 x i8] c"bba\00"
@gsxtmmath551 = hidden constant [4 x i8] c"baa\00"
@gsxtmmath552 = hidden constant [4 x i8] c"abb\00"
@gsxtmmath553 = hidden constant [4 x i8] c"aab\00"
@gsxtmmath554 = hidden constant [4 x i8] c"aba\00"
@gsxtmmath555 = hidden constant [4 x i8] c"aaa\00"
@gsxtmmath556 = hidden constant [2 x i8] c"w\00"
@gsxtmmath557 = hidden constant [2 x i8] c"v\00"
@gsxtmmath558 = hidden constant [2 x i8] c"u\00"
@gsxtmmath559 = hidden constant [3 x i8] c"zf\00"
@gsxtmmath560 = hidden constant [3 x i8] c"yf\00"
@gsxtmmath561 = hidden constant [3 x i8] c"xf\00"
@gsxtmmath562 = hidden constant [3 x i8] c"zi\00"
@gsxtmmath563 = hidden constant [3 x i8] c"yi\00"
@gsxtmmath564 = hidden constant [3 x i8] c"xi\00"
@gsxtmmath565 = hidden constant [2 x i8] c"p\00"
@gsxtmmath566 = hidden constant [13 x i8] c"[512 x i64]*\00"
@gsxtmmath567 = hidden constant [12 x i8] c"permutation\00"
@gsxtmmath568 = hidden constant [13 x i8] c"[256 x i64]*\00"
@gsxtmmath569 = hidden constant [16 x i8] c"_anon_lambda_18\00"
define dllexport fastcc double @perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0__13138(i8* %_impz,i8* %_impenv, double %x, double %y, double %z) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13727 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}*
%perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 0
%perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0Ptr = load {i8*, i8*, double (i8*, i8*, double, double, double)*}***, {i8*, i8*, double (i8*, i8*, double, double, double)*}**** %perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0Ptr_
%y2Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 1
%y2Ptr = load double*, double** %y2Ptr_
%y1Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 2
%y1Ptr = load double*, double** %y1Ptr_
%x2Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 3
%x2Ptr = load double*, double** %x2Ptr_
%x1Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 4
%x1Ptr = load double*, double** %x1Ptr_
%bbbPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 5
%bbbPtr = load i64*, i64** %bbbPtr_
%babPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 6
%babPtr = load i64*, i64** %babPtr_
%bbaPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 7
%bbaPtr = load i64*, i64** %bbaPtr_
%baaPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 8
%baaPtr = load i64*, i64** %baaPtr_
%abbPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 9
%abbPtr = load i64*, i64** %abbPtr_
%aabPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 10
%aabPtr = load i64*, i64** %aabPtr_
%abaPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 11
%abaPtr = load i64*, i64** %abaPtr_
%aaaPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 12
%aaaPtr = load i64*, i64** %aaaPtr_
%wPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 13
%wPtr = load double*, double** %wPtr_
%vPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 14
%vPtr = load double*, double** %vPtr_
%uPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 15
%uPtr = load double*, double** %uPtr_
%zfPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 16
%zfPtr = load double*, double** %zfPtr_
%yfPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 17
%yfPtr = load double*, double** %yfPtr_
%xfPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 18
%xfPtr = load double*, double** %xfPtr_
%ziPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 19
%ziPtr = load i64*, i64** %ziPtr_
%yiPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 20
%yiPtr = load i64*, i64** %yiPtr_
%xiPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 21
%xiPtr = load i64*, i64** %xiPtr_
%iPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 22
%iPtr = load i64*, i64** %iPtr_
%pPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 23
%pPtr = load [512 x i64]**, [512 x i64]*** %pPtr_
%permutationPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 24
%permutationPtr = load [256 x i64]**, [256 x i64]*** %permutationPtr_
%_anon_lambda_18Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %impenv, i32 0, i32 25
%_anon_lambda_18Ptr = load {i8*, i8*, double (i8*, i8*, double, double, double)*}***, {i8*, i8*, double (i8*, i8*, double, double, double)*}**** %_anon_lambda_18Ptr_

; setup arguments
%xPtr = alloca double
store double %x, double* %xPtr
%yPtr = alloca double
store double %y, double* %yPtr
%zPtr = alloca double
store double %z, double* %zPtr


; do set!
%val13728 = load double, double* %xPtr
%res13729 = call ccc i64 @dtoi64(double %val13728)
%val13730 = and i64 %res13729, 255
store i64 %val13730, i64* %xiPtr
; do set!
%val13731 = load double, double* %yPtr
%res13732 = call ccc i64 @dtoi64(double %val13731)
%val13733 = and i64 %res13732, 255
store i64 %val13733, i64* %yiPtr
; do set!
%val13734 = load double, double* %zPtr
%res13735 = call ccc i64 @dtoi64(double %val13734)
%val13736 = and i64 %res13735, 255
store i64 %val13736, i64* %ziPtr
; do set!
%val13737 = load double, double* %xPtr
%val13738 = load double, double* %xPtr
%res13739 = call ccc i64 @dtoi64(double %val13738)
%res13740 = call ccc double @i64tod(i64 %res13739)
%val13741 = fsub double %val13737, %res13740
store double %val13741, double* %xfPtr
; do set!
%val13742 = load double, double* %yPtr
%val13743 = load double, double* %yPtr
%res13744 = call ccc i64 @dtoi64(double %val13743)
%res13745 = call ccc double @i64tod(i64 %res13744)
%val13746 = fsub double %val13742, %res13745
store double %val13746, double* %yfPtr
; do set!
%val13747 = load double, double* %zPtr
%val13748 = load double, double* %zPtr
%res13749 = call ccc i64 @dtoi64(double %val13748)
%res13750 = call ccc double @i64tod(i64 %res13749)
%val13751 = fsub double %val13747, %res13750
store double %val13751, double* %zfPtr
; do set!
%val13752 = load double, double* %xfPtr
%res13753 = call fastcc double @fade_adhoc_W2RvdWJsZSxkb3VibGVd(double %val13752)
store double %res13753, double* %uPtr
; do set!
%val13754 = load double, double* %yfPtr
%res13755 = call fastcc double @fade_adhoc_W2RvdWJsZSxkb3VibGVd(double %val13754)
store double %res13755, double* %vPtr
; do set!
%val13756 = load double, double* %zfPtr
%res13757 = call fastcc double @fade_adhoc_W2RvdWJsZSxkb3VibGVd(double %val13756)
store double %res13757, double* %wPtr
; do set!
%val13758 = load i64, i64* %xiPtr
%val13759 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13760 = getelementptr [512 x i64], [512 x i64]* %val13759, i32 0, i64 %val13758
%val13761 = load i64, i64* %_val13760
%val13762 = load i64, i64* %yiPtr
%val13763 = add i64 %val13761, %val13762
%val13764 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13765 = getelementptr [512 x i64], [512 x i64]* %val13764, i32 0, i64 %val13763
%val13766 = load i64, i64* %_val13765
%val13767 = load i64, i64* %ziPtr
%val13768 = add i64 %val13766, %val13767
%val13769 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13770 = getelementptr [512 x i64], [512 x i64]* %val13769, i32 0, i64 %val13768
%val13771 = load i64, i64* %_val13770
store i64 %val13771, i64* %aaaPtr
; do set!
%val13772 = load i64, i64* %xiPtr
%val13773 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13774 = getelementptr [512 x i64], [512 x i64]* %val13773, i32 0, i64 %val13772
%val13775 = load i64, i64* %_val13774
%val13776 = load i64, i64* %yiPtr
%val13777 = add i64 %val13776, 1
%val13778 = add i64 %val13775, %val13777
%val13779 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13780 = getelementptr [512 x i64], [512 x i64]* %val13779, i32 0, i64 %val13778
%val13781 = load i64, i64* %_val13780
%val13782 = load i64, i64* %ziPtr
%val13783 = add i64 %val13781, %val13782
%val13784 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13785 = getelementptr [512 x i64], [512 x i64]* %val13784, i32 0, i64 %val13783
%val13786 = load i64, i64* %_val13785
store i64 %val13786, i64* %abaPtr
; do set!
%val13787 = load i64, i64* %xiPtr
%val13788 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13789 = getelementptr [512 x i64], [512 x i64]* %val13788, i32 0, i64 %val13787
%val13790 = load i64, i64* %_val13789
%val13791 = load i64, i64* %yiPtr
%val13792 = add i64 %val13790, %val13791
%val13793 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13794 = getelementptr [512 x i64], [512 x i64]* %val13793, i32 0, i64 %val13792
%val13795 = load i64, i64* %_val13794
%val13796 = load i64, i64* %ziPtr
%val13797 = add i64 %val13796, 1
%val13798 = add i64 %val13795, %val13797
%val13799 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13800 = getelementptr [512 x i64], [512 x i64]* %val13799, i32 0, i64 %val13798
%val13801 = load i64, i64* %_val13800
store i64 %val13801, i64* %aabPtr
; do set!
%val13802 = load i64, i64* %xiPtr
%val13803 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13804 = getelementptr [512 x i64], [512 x i64]* %val13803, i32 0, i64 %val13802
%val13805 = load i64, i64* %_val13804
%val13806 = load i64, i64* %yiPtr
%val13807 = add i64 %val13806, 1
%val13808 = add i64 %val13805, %val13807
%val13809 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13810 = getelementptr [512 x i64], [512 x i64]* %val13809, i32 0, i64 %val13808
%val13811 = load i64, i64* %_val13810
%val13812 = load i64, i64* %ziPtr
%val13813 = add i64 %val13812, 1
%val13814 = add i64 %val13811, %val13813
%val13815 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13816 = getelementptr [512 x i64], [512 x i64]* %val13815, i32 0, i64 %val13814
%val13817 = load i64, i64* %_val13816
store i64 %val13817, i64* %abbPtr
; do set!
%val13818 = load i64, i64* %xiPtr
%val13819 = add i64 %val13818, 1
%val13820 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13821 = getelementptr [512 x i64], [512 x i64]* %val13820, i32 0, i64 %val13819
%val13822 = load i64, i64* %_val13821
%val13823 = load i64, i64* %yiPtr
%val13824 = add i64 %val13822, %val13823
%val13825 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13826 = getelementptr [512 x i64], [512 x i64]* %val13825, i32 0, i64 %val13824
%val13827 = load i64, i64* %_val13826
%val13828 = load i64, i64* %ziPtr
%val13829 = add i64 %val13827, %val13828
%val13830 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13831 = getelementptr [512 x i64], [512 x i64]* %val13830, i32 0, i64 %val13829
%val13832 = load i64, i64* %_val13831
store i64 %val13832, i64* %baaPtr
; do set!
%val13833 = load i64, i64* %xiPtr
%val13834 = add i64 %val13833, 1
%val13835 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13836 = getelementptr [512 x i64], [512 x i64]* %val13835, i32 0, i64 %val13834
%val13837 = load i64, i64* %_val13836
%val13838 = load i64, i64* %yiPtr
%val13839 = add i64 %val13838, 1
%val13840 = add i64 %val13837, %val13839
%val13841 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13842 = getelementptr [512 x i64], [512 x i64]* %val13841, i32 0, i64 %val13840
%val13843 = load i64, i64* %_val13842
%val13844 = load i64, i64* %ziPtr
%val13845 = add i64 %val13843, %val13844
%val13846 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13847 = getelementptr [512 x i64], [512 x i64]* %val13846, i32 0, i64 %val13845
%val13848 = load i64, i64* %_val13847
store i64 %val13848, i64* %bbaPtr
; do set!
%val13849 = load i64, i64* %xiPtr
%val13850 = add i64 %val13849, 1
%val13851 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13852 = getelementptr [512 x i64], [512 x i64]* %val13851, i32 0, i64 %val13850
%val13853 = load i64, i64* %_val13852
%val13854 = load i64, i64* %yiPtr
%val13855 = add i64 %val13853, %val13854
%val13856 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13857 = getelementptr [512 x i64], [512 x i64]* %val13856, i32 0, i64 %val13855
%val13858 = load i64, i64* %_val13857
%val13859 = load i64, i64* %ziPtr
%val13860 = add i64 %val13859, 1
%val13861 = add i64 %val13858, %val13860
%val13862 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13863 = getelementptr [512 x i64], [512 x i64]* %val13862, i32 0, i64 %val13861
%val13864 = load i64, i64* %_val13863
store i64 %val13864, i64* %babPtr
; do set!
%val13865 = load i64, i64* %xiPtr
%val13866 = add i64 %val13865, 1
%val13867 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13868 = getelementptr [512 x i64], [512 x i64]* %val13867, i32 0, i64 %val13866
%val13869 = load i64, i64* %_val13868
%val13870 = load i64, i64* %yiPtr
%val13871 = add i64 %val13870, 1
%val13872 = add i64 %val13869, %val13871
%val13873 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13874 = getelementptr [512 x i64], [512 x i64]* %val13873, i32 0, i64 %val13872
%val13875 = load i64, i64* %_val13874
%val13876 = load i64, i64* %ziPtr
%val13877 = add i64 %val13876, 1
%val13878 = add i64 %val13875, %val13877
%val13879 = load [512 x i64]*, [512 x i64]** %pPtr
; array ref
%_val13880 = getelementptr [512 x i64], [512 x i64]* %val13879, i32 0, i64 %val13878
%val13881 = load i64, i64* %_val13880
store i64 %val13881, i64* %bbbPtr
; do set!
%val13882 = load i64, i64* %aaaPtr
%val13883 = load double, double* %xfPtr
%val13884 = load double, double* %yfPtr
%val13885 = load double, double* %zfPtr
%res13886 = call fastcc double @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd(i64 %val13882, double %val13883, double %val13884, double %val13885)
%val13887 = load i64, i64* %baaPtr
%val13888 = load double, double* %xfPtr
%val13889 = fsub double %val13888, 1.0000000000000000000
%val13890 = load double, double* %yfPtr
%val13891 = load double, double* %zfPtr
%res13892 = call fastcc double @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd(i64 %val13887, double %val13889, double %val13890, double %val13891)
%val13893 = load double, double* %uPtr
%res13894 = call fastcc double @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0(double %res13886, double %res13892, double %val13893)
store double %res13894, double* %x1Ptr
; do set!
%val13895 = load i64, i64* %abaPtr
%val13896 = load double, double* %xfPtr
%val13897 = load double, double* %yfPtr
%val13898 = fsub double %val13897, 1.0000000000000000000
%val13899 = load double, double* %zfPtr
%res13900 = call fastcc double @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd(i64 %val13895, double %val13896, double %val13898, double %val13899)
%val13901 = load i64, i64* %bbaPtr
%val13902 = load double, double* %xfPtr
%val13903 = fsub double %val13902, 1.0000000000000000000
%val13904 = load double, double* %yfPtr
%val13905 = fsub double %val13904, 1.0000000000000000000
%val13906 = load double, double* %zfPtr
%res13907 = call fastcc double @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd(i64 %val13901, double %val13903, double %val13905, double %val13906)
%val13908 = load double, double* %uPtr
%res13909 = call fastcc double @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0(double %res13900, double %res13907, double %val13908)
store double %res13909, double* %x2Ptr
; do set!
%val13910 = load double, double* %x1Ptr
%val13911 = load double, double* %x2Ptr
%val13912 = load double, double* %vPtr
%res13913 = call fastcc double @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0(double %val13910, double %val13911, double %val13912)
store double %res13913, double* %y1Ptr
; do set!
%val13914 = load i64, i64* %aabPtr
%val13915 = load double, double* %xfPtr
%val13916 = load double, double* %yfPtr
%val13917 = load double, double* %zfPtr
%val13918 = fsub double %val13917, 1.0000000000000000000
%res13919 = call fastcc double @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd(i64 %val13914, double %val13915, double %val13916, double %val13918)
%val13920 = load i64, i64* %babPtr
%val13921 = load double, double* %xfPtr
%val13922 = fsub double %val13921, 1.0000000000000000000
%val13923 = load double, double* %yfPtr
%val13924 = load double, double* %zfPtr
%val13925 = fsub double %val13924, 1.0000000000000000000
%res13926 = call fastcc double @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd(i64 %val13920, double %val13922, double %val13923, double %val13925)
%val13927 = load double, double* %uPtr
%res13928 = call fastcc double @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0(double %res13919, double %res13926, double %val13927)
store double %res13928, double* %x1Ptr
; do set!
%val13929 = load i64, i64* %abbPtr
%val13930 = load double, double* %xfPtr
%val13931 = load double, double* %yfPtr
%val13932 = fsub double %val13931, 1.0000000000000000000
%val13933 = load double, double* %zfPtr
%val13934 = fsub double %val13933, 1.0000000000000000000
%res13935 = call fastcc double @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd(i64 %val13929, double %val13930, double %val13932, double %val13934)
%val13936 = load i64, i64* %bbbPtr
%val13937 = load double, double* %xfPtr
%val13938 = fsub double %val13937, 1.0000000000000000000
%val13939 = load double, double* %yfPtr
%val13940 = fsub double %val13939, 1.0000000000000000000
%val13941 = load double, double* %zfPtr
%val13942 = fsub double %val13941, 1.0000000000000000000
%res13943 = call fastcc double @grad_adhoc_W2RvdWJsZSxpNjQsZG91YmxlLGRvdWJsZSxkb3VibGVd(i64 %val13936, double %val13938, double %val13940, double %val13942)
%val13944 = load double, double* %uPtr
%res13945 = call fastcc double @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0(double %res13935, double %res13943, double %val13944)
store double %res13945, double* %x2Ptr
; do set!
%val13946 = load double, double* %x1Ptr
%val13947 = load double, double* %x2Ptr
%val13948 = load double, double* %vPtr
%res13949 = call fastcc double @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0(double %val13946, double %val13947, double %val13948)
store double %res13949, double* %y2Ptr
%val13950 = load double, double* %y1Ptr
%val13951 = load double, double* %y2Ptr
%val13952 = load double, double* %wPtr
%res13953 = call fastcc double @lerp_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0(double %val13950, double %val13951, double %val13952)
%val13954 = fadd double %res13953, 1.0000000000000000000
%val13955 = fdiv double %val13954, 2.0000000000000000000
ret double %val13955
}
@gsxtmmath570 = hidden constant [106 x i8] c"perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, double, double, double)*}** @perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone14103 = load i8*, i8** %_impzPtr
%zone14104 = bitcast i8* %tzone14103 to %mzone*

; let assign value to symbol perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0
%dat_perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0 = call i8* @llvm_zone_malloc(%mzone* %zone14104, i64 8)
%perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0Ptr = bitcast i8* %dat_perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0 to {i8*, i8*, double (i8*, i8*, double, double, double)*}***
%tzone13143 = load i8*, i8** %_impzPtr
%zone13144 = bitcast i8* %tzone13143 to %mzone*

; let assign value to symbol permutation
%dat_permutation = call i8* @llvm_zone_malloc(%mzone* %zone13144, i64 8)
%permutationPtr = bitcast i8* %dat_permutation to [256 x i64]**
%tzone13149 = load i8*, i8** %_impzPtr
%zone13150 = bitcast i8* %tzone13149 to %mzone*

; let assign value to symbol p
%dat_p = call i8* @llvm_zone_malloc(%mzone* %zone13150, i64 8)
%pPtr = bitcast i8* %dat_p to [512 x i64]**
%tzone13151 = load i8*, i8** %_impzPtr
%zone13152 = bitcast i8* %tzone13151 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone13152, i64 8)
%iPtr = bitcast i8* %dat_i to i64*
%tzone13153 = load i8*, i8** %_impzPtr
%zone13154 = bitcast i8* %tzone13153 to %mzone*

; let assign value to symbol xi
%dat_xi = call i8* @llvm_zone_malloc(%mzone* %zone13154, i64 8)
%xiPtr = bitcast i8* %dat_xi to i64*
%tzone13155 = load i8*, i8** %_impzPtr
%zone13156 = bitcast i8* %tzone13155 to %mzone*

; let assign value to symbol yi
%dat_yi = call i8* @llvm_zone_malloc(%mzone* %zone13156, i64 8)
%yiPtr = bitcast i8* %dat_yi to i64*
%tzone13157 = load i8*, i8** %_impzPtr
%zone13158 = bitcast i8* %tzone13157 to %mzone*

; let assign value to symbol zi
%dat_zi = call i8* @llvm_zone_malloc(%mzone* %zone13158, i64 8)
%ziPtr = bitcast i8* %dat_zi to i64*
%tzone13159 = load i8*, i8** %_impzPtr
%zone13160 = bitcast i8* %tzone13159 to %mzone*

; let assign value to symbol xf
%dat_xf = call i8* @llvm_zone_malloc(%mzone* %zone13160, i64 8)
%xfPtr = bitcast i8* %dat_xf to double*
%tzone13161 = load i8*, i8** %_impzPtr
%zone13162 = bitcast i8* %tzone13161 to %mzone*

; let assign value to symbol yf
%dat_yf = call i8* @llvm_zone_malloc(%mzone* %zone13162, i64 8)
%yfPtr = bitcast i8* %dat_yf to double*
%tzone13163 = load i8*, i8** %_impzPtr
%zone13164 = bitcast i8* %tzone13163 to %mzone*

; let assign value to symbol zf
%dat_zf = call i8* @llvm_zone_malloc(%mzone* %zone13164, i64 8)
%zfPtr = bitcast i8* %dat_zf to double*
%tzone13165 = load i8*, i8** %_impzPtr
%zone13166 = bitcast i8* %tzone13165 to %mzone*

; let assign value to symbol u
%dat_u = call i8* @llvm_zone_malloc(%mzone* %zone13166, i64 8)
%uPtr = bitcast i8* %dat_u to double*
%tzone13167 = load i8*, i8** %_impzPtr
%zone13168 = bitcast i8* %tzone13167 to %mzone*

; let assign value to symbol v
%dat_v = call i8* @llvm_zone_malloc(%mzone* %zone13168, i64 8)
%vPtr = bitcast i8* %dat_v to double*
%tzone13169 = load i8*, i8** %_impzPtr
%zone13170 = bitcast i8* %tzone13169 to %mzone*

; let assign value to symbol w
%dat_w = call i8* @llvm_zone_malloc(%mzone* %zone13170, i64 8)
%wPtr = bitcast i8* %dat_w to double*
%tzone13171 = load i8*, i8** %_impzPtr
%zone13172 = bitcast i8* %tzone13171 to %mzone*

; let assign value to symbol aaa
%dat_aaa = call i8* @llvm_zone_malloc(%mzone* %zone13172, i64 8)
%aaaPtr = bitcast i8* %dat_aaa to i64*
%tzone13173 = load i8*, i8** %_impzPtr
%zone13174 = bitcast i8* %tzone13173 to %mzone*

; let assign value to symbol aba
%dat_aba = call i8* @llvm_zone_malloc(%mzone* %zone13174, i64 8)
%abaPtr = bitcast i8* %dat_aba to i64*
%tzone13175 = load i8*, i8** %_impzPtr
%zone13176 = bitcast i8* %tzone13175 to %mzone*

; let assign value to symbol aab
%dat_aab = call i8* @llvm_zone_malloc(%mzone* %zone13176, i64 8)
%aabPtr = bitcast i8* %dat_aab to i64*
%tzone13177 = load i8*, i8** %_impzPtr
%zone13178 = bitcast i8* %tzone13177 to %mzone*

; let assign value to symbol abb
%dat_abb = call i8* @llvm_zone_malloc(%mzone* %zone13178, i64 8)
%abbPtr = bitcast i8* %dat_abb to i64*
%tzone13179 = load i8*, i8** %_impzPtr
%zone13180 = bitcast i8* %tzone13179 to %mzone*

; let assign value to symbol baa
%dat_baa = call i8* @llvm_zone_malloc(%mzone* %zone13180, i64 8)
%baaPtr = bitcast i8* %dat_baa to i64*
%tzone13181 = load i8*, i8** %_impzPtr
%zone13182 = bitcast i8* %tzone13181 to %mzone*

; let assign value to symbol bba
%dat_bba = call i8* @llvm_zone_malloc(%mzone* %zone13182, i64 8)
%bbaPtr = bitcast i8* %dat_bba to i64*
%tzone13183 = load i8*, i8** %_impzPtr
%zone13184 = bitcast i8* %tzone13183 to %mzone*

; let assign value to symbol bab
%dat_bab = call i8* @llvm_zone_malloc(%mzone* %zone13184, i64 8)
%babPtr = bitcast i8* %dat_bab to i64*
%tzone13185 = load i8*, i8** %_impzPtr
%zone13186 = bitcast i8* %tzone13185 to %mzone*

; let assign value to symbol bbb
%dat_bbb = call i8* @llvm_zone_malloc(%mzone* %zone13186, i64 8)
%bbbPtr = bitcast i8* %dat_bbb to i64*
%tzone13187 = load i8*, i8** %_impzPtr
%zone13188 = bitcast i8* %tzone13187 to %mzone*

; let assign value to symbol x1
%dat_x1 = call i8* @llvm_zone_malloc(%mzone* %zone13188, i64 8)
%x1Ptr = bitcast i8* %dat_x1 to double*
%tzone13189 = load i8*, i8** %_impzPtr
%zone13190 = bitcast i8* %tzone13189 to %mzone*

; let assign value to symbol x2
%dat_x2 = call i8* @llvm_zone_malloc(%mzone* %zone13190, i64 8)
%x2Ptr = bitcast i8* %dat_x2 to double*
%tzone13191 = load i8*, i8** %_impzPtr
%zone13192 = bitcast i8* %tzone13191 to %mzone*

; let assign value to symbol y1
%dat_y1 = call i8* @llvm_zone_malloc(%mzone* %zone13192, i64 8)
%y1Ptr = bitcast i8* %dat_y1 to double*
%tzone13193 = load i8*, i8** %_impzPtr
%zone13194 = bitcast i8* %tzone13193 to %mzone*

; let assign value to symbol y2
%dat_y2 = call i8* @llvm_zone_malloc(%mzone* %zone13194, i64 8)
%y2Ptr = bitcast i8* %dat_y2 to double*
%tzone13139 = load i8*, i8** %_impzPtr
%zone13140 = bitcast i8* %tzone13139 to %mzone*
%dat13141 = call i8* @llvm_zone_malloc(%mzone* %zone13140, i64 2048)
call i8* @memset(i8* %dat13141, i32 0, i64 2048)
%val13142 = bitcast i8* %dat13141 to [256 x i64]*

; let value assignment
%permutation = select i1 true, [256 x i64]* %val13142, [256 x i64]* %val13142
store [256 x i64]* %permutation, [256 x i64]** %permutationPtr

%tzone13145 = load i8*, i8** %_impzPtr
%zone13146 = bitcast i8* %tzone13145 to %mzone*
%dat13147 = call i8* @llvm_zone_malloc(%mzone* %zone13146, i64 4096)
call i8* @memset(i8* %dat13147, i32 0, i64 4096)
%val13148 = bitcast i8* %dat13147 to [512 x i64]*

; let value assignment
%p = select i1 true, [512 x i64]* %val13148, [512 x i64]* %val13148
store [512 x i64]* %p, [512 x i64]** %pPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr


; let value assignment
%xi = select i1 true, i64 0, i64 0
store i64 %xi, i64* %xiPtr


; let value assignment
%yi = select i1 true, i64 0, i64 0
store i64 %yi, i64* %yiPtr


; let value assignment
%zi = select i1 true, i64 0, i64 0
store i64 %zi, i64* %ziPtr


; let value assignment
%xf = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %xf, double* %xfPtr


; let value assignment
%yf = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %yf, double* %yfPtr


; let value assignment
%zf = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %zf, double* %zfPtr


; let value assignment
%u = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %u, double* %uPtr


; let value assignment
%v = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %v, double* %vPtr


; let value assignment
%w = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %w, double* %wPtr


; let value assignment
%aaa = select i1 true, i64 0, i64 0
store i64 %aaa, i64* %aaaPtr


; let value assignment
%aba = select i1 true, i64 0, i64 0
store i64 %aba, i64* %abaPtr


; let value assignment
%aab = select i1 true, i64 0, i64 0
store i64 %aab, i64* %aabPtr


; let value assignment
%abb = select i1 true, i64 0, i64 0
store i64 %abb, i64* %abbPtr


; let value assignment
%baa = select i1 true, i64 0, i64 0
store i64 %baa, i64* %baaPtr


; let value assignment
%bba = select i1 true, i64 0, i64 0
store i64 %bba, i64* %bbaPtr


; let value assignment
%bab = select i1 true, i64 0, i64 0
store i64 %bab, i64* %babPtr


; let value assignment
%bbb = select i1 true, i64 0, i64 0
store i64 %bbb, i64* %bbbPtr


; let value assignment
%x1 = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %x1, double* %x1Ptr


; let value assignment
%x2 = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %x2, double* %x2Ptr


; let value assignment
%y1 = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %y1, double* %y1Ptr


; let value assignment
%y2 = select i1 true, double 0.00000000000000000000, double 0.00000000000000000000
store double %y2, double* %y2Ptr

%val13195 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13196 = getelementptr [256 x i64], [256 x i64]* %val13195, i32 0, i64 0
store i64 151, i64* %val13196
%val13197 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13198 = getelementptr [256 x i64], [256 x i64]* %val13197, i32 0, i64 1
store i64 160, i64* %val13198
%val13199 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13200 = getelementptr [256 x i64], [256 x i64]* %val13199, i32 0, i64 2
store i64 137, i64* %val13200
%val13201 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13202 = getelementptr [256 x i64], [256 x i64]* %val13201, i32 0, i64 3
store i64 91, i64* %val13202
%val13203 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13204 = getelementptr [256 x i64], [256 x i64]* %val13203, i32 0, i64 4
store i64 90, i64* %val13204
%val13205 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13206 = getelementptr [256 x i64], [256 x i64]* %val13205, i32 0, i64 5
store i64 15, i64* %val13206
%val13207 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13208 = getelementptr [256 x i64], [256 x i64]* %val13207, i32 0, i64 6
store i64 131, i64* %val13208
%val13209 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13210 = getelementptr [256 x i64], [256 x i64]* %val13209, i32 0, i64 7
store i64 13, i64* %val13210
%val13211 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13212 = getelementptr [256 x i64], [256 x i64]* %val13211, i32 0, i64 8
store i64 201, i64* %val13212
%val13213 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13214 = getelementptr [256 x i64], [256 x i64]* %val13213, i32 0, i64 9
store i64 95, i64* %val13214
%val13215 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13216 = getelementptr [256 x i64], [256 x i64]* %val13215, i32 0, i64 10
store i64 96, i64* %val13216
%val13217 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13218 = getelementptr [256 x i64], [256 x i64]* %val13217, i32 0, i64 11
store i64 53, i64* %val13218
%val13219 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13220 = getelementptr [256 x i64], [256 x i64]* %val13219, i32 0, i64 12
store i64 194, i64* %val13220
%val13221 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13222 = getelementptr [256 x i64], [256 x i64]* %val13221, i32 0, i64 13
store i64 233, i64* %val13222
%val13223 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13224 = getelementptr [256 x i64], [256 x i64]* %val13223, i32 0, i64 14
store i64 7, i64* %val13224
%val13225 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13226 = getelementptr [256 x i64], [256 x i64]* %val13225, i32 0, i64 15
store i64 225, i64* %val13226
%val13227 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13228 = getelementptr [256 x i64], [256 x i64]* %val13227, i32 0, i64 16
store i64 140, i64* %val13228
%val13229 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13230 = getelementptr [256 x i64], [256 x i64]* %val13229, i32 0, i64 17
store i64 36, i64* %val13230
%val13231 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13232 = getelementptr [256 x i64], [256 x i64]* %val13231, i32 0, i64 18
store i64 103, i64* %val13232
%val13233 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13234 = getelementptr [256 x i64], [256 x i64]* %val13233, i32 0, i64 19
store i64 30, i64* %val13234
%val13235 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13236 = getelementptr [256 x i64], [256 x i64]* %val13235, i32 0, i64 20
store i64 69, i64* %val13236
%val13237 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13238 = getelementptr [256 x i64], [256 x i64]* %val13237, i32 0, i64 21
store i64 142, i64* %val13238
%val13239 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13240 = getelementptr [256 x i64], [256 x i64]* %val13239, i32 0, i64 22
store i64 8, i64* %val13240
%val13241 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13242 = getelementptr [256 x i64], [256 x i64]* %val13241, i32 0, i64 23
store i64 99, i64* %val13242
%val13243 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13244 = getelementptr [256 x i64], [256 x i64]* %val13243, i32 0, i64 24
store i64 37, i64* %val13244
%val13245 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13246 = getelementptr [256 x i64], [256 x i64]* %val13245, i32 0, i64 25
store i64 240, i64* %val13246
%val13247 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13248 = getelementptr [256 x i64], [256 x i64]* %val13247, i32 0, i64 26
store i64 21, i64* %val13248
%val13249 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13250 = getelementptr [256 x i64], [256 x i64]* %val13249, i32 0, i64 27
store i64 10, i64* %val13250
%val13251 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13252 = getelementptr [256 x i64], [256 x i64]* %val13251, i32 0, i64 28
store i64 23, i64* %val13252
%val13253 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13254 = getelementptr [256 x i64], [256 x i64]* %val13253, i32 0, i64 29
store i64 190, i64* %val13254
%val13255 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13256 = getelementptr [256 x i64], [256 x i64]* %val13255, i32 0, i64 30
store i64 6, i64* %val13256
%val13257 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13258 = getelementptr [256 x i64], [256 x i64]* %val13257, i32 0, i64 31
store i64 148, i64* %val13258
%val13259 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13260 = getelementptr [256 x i64], [256 x i64]* %val13259, i32 0, i64 32
store i64 247, i64* %val13260
%val13261 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13262 = getelementptr [256 x i64], [256 x i64]* %val13261, i32 0, i64 33
store i64 120, i64* %val13262
%val13263 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13264 = getelementptr [256 x i64], [256 x i64]* %val13263, i32 0, i64 34
store i64 234, i64* %val13264
%val13265 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13266 = getelementptr [256 x i64], [256 x i64]* %val13265, i32 0, i64 35
store i64 75, i64* %val13266
%val13267 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13268 = getelementptr [256 x i64], [256 x i64]* %val13267, i32 0, i64 36
store i64 0, i64* %val13268
%val13269 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13270 = getelementptr [256 x i64], [256 x i64]* %val13269, i32 0, i64 37
store i64 26, i64* %val13270
%val13271 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13272 = getelementptr [256 x i64], [256 x i64]* %val13271, i32 0, i64 38
store i64 197, i64* %val13272
%val13273 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13274 = getelementptr [256 x i64], [256 x i64]* %val13273, i32 0, i64 39
store i64 62, i64* %val13274
%val13275 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13276 = getelementptr [256 x i64], [256 x i64]* %val13275, i32 0, i64 40
store i64 94, i64* %val13276
%val13277 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13278 = getelementptr [256 x i64], [256 x i64]* %val13277, i32 0, i64 41
store i64 252, i64* %val13278
%val13279 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13280 = getelementptr [256 x i64], [256 x i64]* %val13279, i32 0, i64 42
store i64 219, i64* %val13280
%val13281 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13282 = getelementptr [256 x i64], [256 x i64]* %val13281, i32 0, i64 43
store i64 203, i64* %val13282
%val13283 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13284 = getelementptr [256 x i64], [256 x i64]* %val13283, i32 0, i64 44
store i64 117, i64* %val13284
%val13285 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13286 = getelementptr [256 x i64], [256 x i64]* %val13285, i32 0, i64 45
store i64 35, i64* %val13286
%val13287 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13288 = getelementptr [256 x i64], [256 x i64]* %val13287, i32 0, i64 46
store i64 11, i64* %val13288
%val13289 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13290 = getelementptr [256 x i64], [256 x i64]* %val13289, i32 0, i64 47
store i64 32, i64* %val13290
%val13291 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13292 = getelementptr [256 x i64], [256 x i64]* %val13291, i32 0, i64 48
store i64 57, i64* %val13292
%val13293 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13294 = getelementptr [256 x i64], [256 x i64]* %val13293, i32 0, i64 49
store i64 177, i64* %val13294
%val13295 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13296 = getelementptr [256 x i64], [256 x i64]* %val13295, i32 0, i64 50
store i64 33, i64* %val13296
%val13297 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13298 = getelementptr [256 x i64], [256 x i64]* %val13297, i32 0, i64 51
store i64 88, i64* %val13298
%val13299 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13300 = getelementptr [256 x i64], [256 x i64]* %val13299, i32 0, i64 52
store i64 237, i64* %val13300
%val13301 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13302 = getelementptr [256 x i64], [256 x i64]* %val13301, i32 0, i64 53
store i64 149, i64* %val13302
%val13303 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13304 = getelementptr [256 x i64], [256 x i64]* %val13303, i32 0, i64 54
store i64 56, i64* %val13304
%val13305 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13306 = getelementptr [256 x i64], [256 x i64]* %val13305, i32 0, i64 55
store i64 87, i64* %val13306
%val13307 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13308 = getelementptr [256 x i64], [256 x i64]* %val13307, i32 0, i64 56
store i64 174, i64* %val13308
%val13309 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13310 = getelementptr [256 x i64], [256 x i64]* %val13309, i32 0, i64 57
store i64 20, i64* %val13310
%val13311 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13312 = getelementptr [256 x i64], [256 x i64]* %val13311, i32 0, i64 58
store i64 125, i64* %val13312
%val13313 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13314 = getelementptr [256 x i64], [256 x i64]* %val13313, i32 0, i64 59
store i64 136, i64* %val13314
%val13315 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13316 = getelementptr [256 x i64], [256 x i64]* %val13315, i32 0, i64 60
store i64 171, i64* %val13316
%val13317 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13318 = getelementptr [256 x i64], [256 x i64]* %val13317, i32 0, i64 61
store i64 168, i64* %val13318
%val13319 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13320 = getelementptr [256 x i64], [256 x i64]* %val13319, i32 0, i64 62
store i64 68, i64* %val13320
%val13321 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13322 = getelementptr [256 x i64], [256 x i64]* %val13321, i32 0, i64 63
store i64 175, i64* %val13322
%val13323 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13324 = getelementptr [256 x i64], [256 x i64]* %val13323, i32 0, i64 64
store i64 74, i64* %val13324
%val13325 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13326 = getelementptr [256 x i64], [256 x i64]* %val13325, i32 0, i64 65
store i64 165, i64* %val13326
%val13327 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13328 = getelementptr [256 x i64], [256 x i64]* %val13327, i32 0, i64 66
store i64 71, i64* %val13328
%val13329 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13330 = getelementptr [256 x i64], [256 x i64]* %val13329, i32 0, i64 67
store i64 134, i64* %val13330
%val13331 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13332 = getelementptr [256 x i64], [256 x i64]* %val13331, i32 0, i64 68
store i64 139, i64* %val13332
%val13333 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13334 = getelementptr [256 x i64], [256 x i64]* %val13333, i32 0, i64 69
store i64 48, i64* %val13334
%val13335 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13336 = getelementptr [256 x i64], [256 x i64]* %val13335, i32 0, i64 70
store i64 27, i64* %val13336
%val13337 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13338 = getelementptr [256 x i64], [256 x i64]* %val13337, i32 0, i64 71
store i64 166, i64* %val13338
%val13339 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13340 = getelementptr [256 x i64], [256 x i64]* %val13339, i32 0, i64 72
store i64 77, i64* %val13340
%val13341 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13342 = getelementptr [256 x i64], [256 x i64]* %val13341, i32 0, i64 73
store i64 146, i64* %val13342
%val13343 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13344 = getelementptr [256 x i64], [256 x i64]* %val13343, i32 0, i64 74
store i64 158, i64* %val13344
%val13345 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13346 = getelementptr [256 x i64], [256 x i64]* %val13345, i32 0, i64 75
store i64 231, i64* %val13346
%val13347 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13348 = getelementptr [256 x i64], [256 x i64]* %val13347, i32 0, i64 76
store i64 83, i64* %val13348
%val13349 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13350 = getelementptr [256 x i64], [256 x i64]* %val13349, i32 0, i64 77
store i64 111, i64* %val13350
%val13351 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13352 = getelementptr [256 x i64], [256 x i64]* %val13351, i32 0, i64 78
store i64 229, i64* %val13352
%val13353 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13354 = getelementptr [256 x i64], [256 x i64]* %val13353, i32 0, i64 79
store i64 122, i64* %val13354
%val13355 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13356 = getelementptr [256 x i64], [256 x i64]* %val13355, i32 0, i64 80
store i64 60, i64* %val13356
%val13357 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13358 = getelementptr [256 x i64], [256 x i64]* %val13357, i32 0, i64 81
store i64 211, i64* %val13358
%val13359 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13360 = getelementptr [256 x i64], [256 x i64]* %val13359, i32 0, i64 82
store i64 133, i64* %val13360
%val13361 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13362 = getelementptr [256 x i64], [256 x i64]* %val13361, i32 0, i64 83
store i64 230, i64* %val13362
%val13363 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13364 = getelementptr [256 x i64], [256 x i64]* %val13363, i32 0, i64 84
store i64 220, i64* %val13364
%val13365 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13366 = getelementptr [256 x i64], [256 x i64]* %val13365, i32 0, i64 85
store i64 105, i64* %val13366
%val13367 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13368 = getelementptr [256 x i64], [256 x i64]* %val13367, i32 0, i64 86
store i64 92, i64* %val13368
%val13369 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13370 = getelementptr [256 x i64], [256 x i64]* %val13369, i32 0, i64 87
store i64 41, i64* %val13370
%val13371 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13372 = getelementptr [256 x i64], [256 x i64]* %val13371, i32 0, i64 88
store i64 55, i64* %val13372
%val13373 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13374 = getelementptr [256 x i64], [256 x i64]* %val13373, i32 0, i64 89
store i64 46, i64* %val13374
%val13375 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13376 = getelementptr [256 x i64], [256 x i64]* %val13375, i32 0, i64 90
store i64 245, i64* %val13376
%val13377 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13378 = getelementptr [256 x i64], [256 x i64]* %val13377, i32 0, i64 91
store i64 40, i64* %val13378
%val13379 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13380 = getelementptr [256 x i64], [256 x i64]* %val13379, i32 0, i64 92
store i64 244, i64* %val13380
%val13381 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13382 = getelementptr [256 x i64], [256 x i64]* %val13381, i32 0, i64 93
store i64 102, i64* %val13382
%val13383 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13384 = getelementptr [256 x i64], [256 x i64]* %val13383, i32 0, i64 94
store i64 143, i64* %val13384
%val13385 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13386 = getelementptr [256 x i64], [256 x i64]* %val13385, i32 0, i64 95
store i64 54, i64* %val13386
%val13387 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13388 = getelementptr [256 x i64], [256 x i64]* %val13387, i32 0, i64 96
store i64 65, i64* %val13388
%val13389 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13390 = getelementptr [256 x i64], [256 x i64]* %val13389, i32 0, i64 97
store i64 25, i64* %val13390
%val13391 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13392 = getelementptr [256 x i64], [256 x i64]* %val13391, i32 0, i64 98
store i64 63, i64* %val13392
%val13393 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13394 = getelementptr [256 x i64], [256 x i64]* %val13393, i32 0, i64 99
store i64 161, i64* %val13394
%val13395 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13396 = getelementptr [256 x i64], [256 x i64]* %val13395, i32 0, i64 100
store i64 1, i64* %val13396
%val13397 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13398 = getelementptr [256 x i64], [256 x i64]* %val13397, i32 0, i64 101
store i64 216, i64* %val13398
%val13399 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13400 = getelementptr [256 x i64], [256 x i64]* %val13399, i32 0, i64 102
store i64 80, i64* %val13400
%val13401 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13402 = getelementptr [256 x i64], [256 x i64]* %val13401, i32 0, i64 103
store i64 73, i64* %val13402
%val13403 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13404 = getelementptr [256 x i64], [256 x i64]* %val13403, i32 0, i64 104
store i64 209, i64* %val13404
%val13405 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13406 = getelementptr [256 x i64], [256 x i64]* %val13405, i32 0, i64 105
store i64 76, i64* %val13406
%val13407 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13408 = getelementptr [256 x i64], [256 x i64]* %val13407, i32 0, i64 106
store i64 132, i64* %val13408
%val13409 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13410 = getelementptr [256 x i64], [256 x i64]* %val13409, i32 0, i64 107
store i64 187, i64* %val13410
%val13411 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13412 = getelementptr [256 x i64], [256 x i64]* %val13411, i32 0, i64 108
store i64 208, i64* %val13412
%val13413 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13414 = getelementptr [256 x i64], [256 x i64]* %val13413, i32 0, i64 109
store i64 89, i64* %val13414
%val13415 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13416 = getelementptr [256 x i64], [256 x i64]* %val13415, i32 0, i64 110
store i64 18, i64* %val13416
%val13417 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13418 = getelementptr [256 x i64], [256 x i64]* %val13417, i32 0, i64 111
store i64 169, i64* %val13418
%val13419 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13420 = getelementptr [256 x i64], [256 x i64]* %val13419, i32 0, i64 112
store i64 200, i64* %val13420
%val13421 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13422 = getelementptr [256 x i64], [256 x i64]* %val13421, i32 0, i64 113
store i64 196, i64* %val13422
%val13423 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13424 = getelementptr [256 x i64], [256 x i64]* %val13423, i32 0, i64 114
store i64 135, i64* %val13424
%val13425 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13426 = getelementptr [256 x i64], [256 x i64]* %val13425, i32 0, i64 115
store i64 130, i64* %val13426
%val13427 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13428 = getelementptr [256 x i64], [256 x i64]* %val13427, i32 0, i64 116
store i64 116, i64* %val13428
%val13429 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13430 = getelementptr [256 x i64], [256 x i64]* %val13429, i32 0, i64 117
store i64 188, i64* %val13430
%val13431 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13432 = getelementptr [256 x i64], [256 x i64]* %val13431, i32 0, i64 118
store i64 159, i64* %val13432
%val13433 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13434 = getelementptr [256 x i64], [256 x i64]* %val13433, i32 0, i64 119
store i64 86, i64* %val13434
%val13435 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13436 = getelementptr [256 x i64], [256 x i64]* %val13435, i32 0, i64 120
store i64 164, i64* %val13436
%val13437 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13438 = getelementptr [256 x i64], [256 x i64]* %val13437, i32 0, i64 121
store i64 100, i64* %val13438
%val13439 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13440 = getelementptr [256 x i64], [256 x i64]* %val13439, i32 0, i64 122
store i64 109, i64* %val13440
%val13441 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13442 = getelementptr [256 x i64], [256 x i64]* %val13441, i32 0, i64 123
store i64 198, i64* %val13442
%val13443 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13444 = getelementptr [256 x i64], [256 x i64]* %val13443, i32 0, i64 124
store i64 173, i64* %val13444
%val13445 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13446 = getelementptr [256 x i64], [256 x i64]* %val13445, i32 0, i64 125
store i64 186, i64* %val13446
%val13447 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13448 = getelementptr [256 x i64], [256 x i64]* %val13447, i32 0, i64 126
store i64 3, i64* %val13448
%val13449 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13450 = getelementptr [256 x i64], [256 x i64]* %val13449, i32 0, i64 127
store i64 64, i64* %val13450
%val13451 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13452 = getelementptr [256 x i64], [256 x i64]* %val13451, i32 0, i64 128
store i64 52, i64* %val13452
%val13453 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13454 = getelementptr [256 x i64], [256 x i64]* %val13453, i32 0, i64 129
store i64 217, i64* %val13454
%val13455 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13456 = getelementptr [256 x i64], [256 x i64]* %val13455, i32 0, i64 130
store i64 226, i64* %val13456
%val13457 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13458 = getelementptr [256 x i64], [256 x i64]* %val13457, i32 0, i64 131
store i64 250, i64* %val13458
%val13459 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13460 = getelementptr [256 x i64], [256 x i64]* %val13459, i32 0, i64 132
store i64 124, i64* %val13460
%val13461 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13462 = getelementptr [256 x i64], [256 x i64]* %val13461, i32 0, i64 133
store i64 123, i64* %val13462
%val13463 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13464 = getelementptr [256 x i64], [256 x i64]* %val13463, i32 0, i64 134
store i64 5, i64* %val13464
%val13465 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13466 = getelementptr [256 x i64], [256 x i64]* %val13465, i32 0, i64 135
store i64 202, i64* %val13466
%val13467 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13468 = getelementptr [256 x i64], [256 x i64]* %val13467, i32 0, i64 136
store i64 38, i64* %val13468
%val13469 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13470 = getelementptr [256 x i64], [256 x i64]* %val13469, i32 0, i64 137
store i64 147, i64* %val13470
%val13471 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13472 = getelementptr [256 x i64], [256 x i64]* %val13471, i32 0, i64 138
store i64 118, i64* %val13472
%val13473 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13474 = getelementptr [256 x i64], [256 x i64]* %val13473, i32 0, i64 139
store i64 126, i64* %val13474
%val13475 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13476 = getelementptr [256 x i64], [256 x i64]* %val13475, i32 0, i64 140
store i64 255, i64* %val13476
%val13477 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13478 = getelementptr [256 x i64], [256 x i64]* %val13477, i32 0, i64 141
store i64 82, i64* %val13478
%val13479 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13480 = getelementptr [256 x i64], [256 x i64]* %val13479, i32 0, i64 142
store i64 85, i64* %val13480
%val13481 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13482 = getelementptr [256 x i64], [256 x i64]* %val13481, i32 0, i64 143
store i64 212, i64* %val13482
%val13483 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13484 = getelementptr [256 x i64], [256 x i64]* %val13483, i32 0, i64 144
store i64 207, i64* %val13484
%val13485 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13486 = getelementptr [256 x i64], [256 x i64]* %val13485, i32 0, i64 145
store i64 206, i64* %val13486
%val13487 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13488 = getelementptr [256 x i64], [256 x i64]* %val13487, i32 0, i64 146
store i64 59, i64* %val13488
%val13489 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13490 = getelementptr [256 x i64], [256 x i64]* %val13489, i32 0, i64 147
store i64 227, i64* %val13490
%val13491 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13492 = getelementptr [256 x i64], [256 x i64]* %val13491, i32 0, i64 148
store i64 47, i64* %val13492
%val13493 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13494 = getelementptr [256 x i64], [256 x i64]* %val13493, i32 0, i64 149
store i64 16, i64* %val13494
%val13495 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13496 = getelementptr [256 x i64], [256 x i64]* %val13495, i32 0, i64 150
store i64 58, i64* %val13496
%val13497 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13498 = getelementptr [256 x i64], [256 x i64]* %val13497, i32 0, i64 151
store i64 17, i64* %val13498
%val13499 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13500 = getelementptr [256 x i64], [256 x i64]* %val13499, i32 0, i64 152
store i64 182, i64* %val13500
%val13501 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13502 = getelementptr [256 x i64], [256 x i64]* %val13501, i32 0, i64 153
store i64 189, i64* %val13502
%val13503 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13504 = getelementptr [256 x i64], [256 x i64]* %val13503, i32 0, i64 154
store i64 28, i64* %val13504
%val13505 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13506 = getelementptr [256 x i64], [256 x i64]* %val13505, i32 0, i64 155
store i64 42, i64* %val13506
%val13507 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13508 = getelementptr [256 x i64], [256 x i64]* %val13507, i32 0, i64 156
store i64 223, i64* %val13508
%val13509 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13510 = getelementptr [256 x i64], [256 x i64]* %val13509, i32 0, i64 157
store i64 183, i64* %val13510
%val13511 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13512 = getelementptr [256 x i64], [256 x i64]* %val13511, i32 0, i64 158
store i64 170, i64* %val13512
%val13513 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13514 = getelementptr [256 x i64], [256 x i64]* %val13513, i32 0, i64 159
store i64 213, i64* %val13514
%val13515 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13516 = getelementptr [256 x i64], [256 x i64]* %val13515, i32 0, i64 160
store i64 119, i64* %val13516
%val13517 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13518 = getelementptr [256 x i64], [256 x i64]* %val13517, i32 0, i64 161
store i64 248, i64* %val13518
%val13519 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13520 = getelementptr [256 x i64], [256 x i64]* %val13519, i32 0, i64 162
store i64 152, i64* %val13520
%val13521 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13522 = getelementptr [256 x i64], [256 x i64]* %val13521, i32 0, i64 163
store i64 2, i64* %val13522
%val13523 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13524 = getelementptr [256 x i64], [256 x i64]* %val13523, i32 0, i64 164
store i64 44, i64* %val13524
%val13525 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13526 = getelementptr [256 x i64], [256 x i64]* %val13525, i32 0, i64 165
store i64 154, i64* %val13526
%val13527 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13528 = getelementptr [256 x i64], [256 x i64]* %val13527, i32 0, i64 166
store i64 163, i64* %val13528
%val13529 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13530 = getelementptr [256 x i64], [256 x i64]* %val13529, i32 0, i64 167
store i64 70, i64* %val13530
%val13531 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13532 = getelementptr [256 x i64], [256 x i64]* %val13531, i32 0, i64 168
store i64 221, i64* %val13532
%val13533 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13534 = getelementptr [256 x i64], [256 x i64]* %val13533, i32 0, i64 169
store i64 153, i64* %val13534
%val13535 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13536 = getelementptr [256 x i64], [256 x i64]* %val13535, i32 0, i64 170
store i64 101, i64* %val13536
%val13537 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13538 = getelementptr [256 x i64], [256 x i64]* %val13537, i32 0, i64 171
store i64 155, i64* %val13538
%val13539 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13540 = getelementptr [256 x i64], [256 x i64]* %val13539, i32 0, i64 172
store i64 167, i64* %val13540
%val13541 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13542 = getelementptr [256 x i64], [256 x i64]* %val13541, i32 0, i64 173
store i64 43, i64* %val13542
%val13543 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13544 = getelementptr [256 x i64], [256 x i64]* %val13543, i32 0, i64 174
store i64 172, i64* %val13544
%val13545 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13546 = getelementptr [256 x i64], [256 x i64]* %val13545, i32 0, i64 175
store i64 9, i64* %val13546
%val13547 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13548 = getelementptr [256 x i64], [256 x i64]* %val13547, i32 0, i64 176
store i64 129, i64* %val13548
%val13549 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13550 = getelementptr [256 x i64], [256 x i64]* %val13549, i32 0, i64 177
store i64 22, i64* %val13550
%val13551 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13552 = getelementptr [256 x i64], [256 x i64]* %val13551, i32 0, i64 178
store i64 39, i64* %val13552
%val13553 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13554 = getelementptr [256 x i64], [256 x i64]* %val13553, i32 0, i64 179
store i64 253, i64* %val13554
%val13555 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13556 = getelementptr [256 x i64], [256 x i64]* %val13555, i32 0, i64 180
store i64 19, i64* %val13556
%val13557 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13558 = getelementptr [256 x i64], [256 x i64]* %val13557, i32 0, i64 181
store i64 98, i64* %val13558
%val13559 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13560 = getelementptr [256 x i64], [256 x i64]* %val13559, i32 0, i64 182
store i64 108, i64* %val13560
%val13561 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13562 = getelementptr [256 x i64], [256 x i64]* %val13561, i32 0, i64 183
store i64 110, i64* %val13562
%val13563 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13564 = getelementptr [256 x i64], [256 x i64]* %val13563, i32 0, i64 184
store i64 79, i64* %val13564
%val13565 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13566 = getelementptr [256 x i64], [256 x i64]* %val13565, i32 0, i64 185
store i64 113, i64* %val13566
%val13567 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13568 = getelementptr [256 x i64], [256 x i64]* %val13567, i32 0, i64 186
store i64 224, i64* %val13568
%val13569 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13570 = getelementptr [256 x i64], [256 x i64]* %val13569, i32 0, i64 187
store i64 232, i64* %val13570
%val13571 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13572 = getelementptr [256 x i64], [256 x i64]* %val13571, i32 0, i64 188
store i64 178, i64* %val13572
%val13573 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13574 = getelementptr [256 x i64], [256 x i64]* %val13573, i32 0, i64 189
store i64 185, i64* %val13574
%val13575 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13576 = getelementptr [256 x i64], [256 x i64]* %val13575, i32 0, i64 190
store i64 112, i64* %val13576
%val13577 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13578 = getelementptr [256 x i64], [256 x i64]* %val13577, i32 0, i64 191
store i64 104, i64* %val13578
%val13579 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13580 = getelementptr [256 x i64], [256 x i64]* %val13579, i32 0, i64 192
store i64 218, i64* %val13580
%val13581 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13582 = getelementptr [256 x i64], [256 x i64]* %val13581, i32 0, i64 193
store i64 246, i64* %val13582
%val13583 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13584 = getelementptr [256 x i64], [256 x i64]* %val13583, i32 0, i64 194
store i64 97, i64* %val13584
%val13585 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13586 = getelementptr [256 x i64], [256 x i64]* %val13585, i32 0, i64 195
store i64 228, i64* %val13586
%val13587 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13588 = getelementptr [256 x i64], [256 x i64]* %val13587, i32 0, i64 196
store i64 251, i64* %val13588
%val13589 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13590 = getelementptr [256 x i64], [256 x i64]* %val13589, i32 0, i64 197
store i64 34, i64* %val13590
%val13591 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13592 = getelementptr [256 x i64], [256 x i64]* %val13591, i32 0, i64 198
store i64 242, i64* %val13592
%val13593 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13594 = getelementptr [256 x i64], [256 x i64]* %val13593, i32 0, i64 199
store i64 193, i64* %val13594
%val13595 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13596 = getelementptr [256 x i64], [256 x i64]* %val13595, i32 0, i64 200
store i64 238, i64* %val13596
%val13597 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13598 = getelementptr [256 x i64], [256 x i64]* %val13597, i32 0, i64 201
store i64 210, i64* %val13598
%val13599 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13600 = getelementptr [256 x i64], [256 x i64]* %val13599, i32 0, i64 202
store i64 144, i64* %val13600
%val13601 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13602 = getelementptr [256 x i64], [256 x i64]* %val13601, i32 0, i64 203
store i64 12, i64* %val13602
%val13603 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13604 = getelementptr [256 x i64], [256 x i64]* %val13603, i32 0, i64 204
store i64 191, i64* %val13604
%val13605 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13606 = getelementptr [256 x i64], [256 x i64]* %val13605, i32 0, i64 205
store i64 179, i64* %val13606
%val13607 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13608 = getelementptr [256 x i64], [256 x i64]* %val13607, i32 0, i64 206
store i64 162, i64* %val13608
%val13609 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13610 = getelementptr [256 x i64], [256 x i64]* %val13609, i32 0, i64 207
store i64 241, i64* %val13610
%val13611 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13612 = getelementptr [256 x i64], [256 x i64]* %val13611, i32 0, i64 208
store i64 81, i64* %val13612
%val13613 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13614 = getelementptr [256 x i64], [256 x i64]* %val13613, i32 0, i64 209
store i64 51, i64* %val13614
%val13615 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13616 = getelementptr [256 x i64], [256 x i64]* %val13615, i32 0, i64 210
store i64 145, i64* %val13616
%val13617 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13618 = getelementptr [256 x i64], [256 x i64]* %val13617, i32 0, i64 211
store i64 235, i64* %val13618
%val13619 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13620 = getelementptr [256 x i64], [256 x i64]* %val13619, i32 0, i64 212
store i64 249, i64* %val13620
%val13621 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13622 = getelementptr [256 x i64], [256 x i64]* %val13621, i32 0, i64 213
store i64 14, i64* %val13622
%val13623 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13624 = getelementptr [256 x i64], [256 x i64]* %val13623, i32 0, i64 214
store i64 239, i64* %val13624
%val13625 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13626 = getelementptr [256 x i64], [256 x i64]* %val13625, i32 0, i64 215
store i64 107, i64* %val13626
%val13627 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13628 = getelementptr [256 x i64], [256 x i64]* %val13627, i32 0, i64 216
store i64 49, i64* %val13628
%val13629 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13630 = getelementptr [256 x i64], [256 x i64]* %val13629, i32 0, i64 217
store i64 192, i64* %val13630
%val13631 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13632 = getelementptr [256 x i64], [256 x i64]* %val13631, i32 0, i64 218
store i64 214, i64* %val13632
%val13633 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13634 = getelementptr [256 x i64], [256 x i64]* %val13633, i32 0, i64 219
store i64 31, i64* %val13634
%val13635 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13636 = getelementptr [256 x i64], [256 x i64]* %val13635, i32 0, i64 220
store i64 181, i64* %val13636
%val13637 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13638 = getelementptr [256 x i64], [256 x i64]* %val13637, i32 0, i64 221
store i64 199, i64* %val13638
%val13639 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13640 = getelementptr [256 x i64], [256 x i64]* %val13639, i32 0, i64 222
store i64 106, i64* %val13640
%val13641 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13642 = getelementptr [256 x i64], [256 x i64]* %val13641, i32 0, i64 223
store i64 157, i64* %val13642
%val13643 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13644 = getelementptr [256 x i64], [256 x i64]* %val13643, i32 0, i64 224
store i64 184, i64* %val13644
%val13645 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13646 = getelementptr [256 x i64], [256 x i64]* %val13645, i32 0, i64 225
store i64 84, i64* %val13646
%val13647 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13648 = getelementptr [256 x i64], [256 x i64]* %val13647, i32 0, i64 226
store i64 204, i64* %val13648
%val13649 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13650 = getelementptr [256 x i64], [256 x i64]* %val13649, i32 0, i64 227
store i64 176, i64* %val13650
%val13651 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13652 = getelementptr [256 x i64], [256 x i64]* %val13651, i32 0, i64 228
store i64 115, i64* %val13652
%val13653 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13654 = getelementptr [256 x i64], [256 x i64]* %val13653, i32 0, i64 229
store i64 121, i64* %val13654
%val13655 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13656 = getelementptr [256 x i64], [256 x i64]* %val13655, i32 0, i64 230
store i64 50, i64* %val13656
%val13657 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13658 = getelementptr [256 x i64], [256 x i64]* %val13657, i32 0, i64 231
store i64 45, i64* %val13658
%val13659 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13660 = getelementptr [256 x i64], [256 x i64]* %val13659, i32 0, i64 232
store i64 127, i64* %val13660
%val13661 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13662 = getelementptr [256 x i64], [256 x i64]* %val13661, i32 0, i64 233
store i64 4, i64* %val13662
%val13663 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13664 = getelementptr [256 x i64], [256 x i64]* %val13663, i32 0, i64 234
store i64 150, i64* %val13664
%val13665 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13666 = getelementptr [256 x i64], [256 x i64]* %val13665, i32 0, i64 235
store i64 254, i64* %val13666
%val13667 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13668 = getelementptr [256 x i64], [256 x i64]* %val13667, i32 0, i64 236
store i64 138, i64* %val13668
%val13669 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13670 = getelementptr [256 x i64], [256 x i64]* %val13669, i32 0, i64 237
store i64 236, i64* %val13670
%val13671 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13672 = getelementptr [256 x i64], [256 x i64]* %val13671, i32 0, i64 238
store i64 205, i64* %val13672
%val13673 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13674 = getelementptr [256 x i64], [256 x i64]* %val13673, i32 0, i64 239
store i64 93, i64* %val13674
%val13675 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13676 = getelementptr [256 x i64], [256 x i64]* %val13675, i32 0, i64 240
store i64 222, i64* %val13676
%val13677 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13678 = getelementptr [256 x i64], [256 x i64]* %val13677, i32 0, i64 241
store i64 114, i64* %val13678
%val13679 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13680 = getelementptr [256 x i64], [256 x i64]* %val13679, i32 0, i64 242
store i64 67, i64* %val13680
%val13681 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13682 = getelementptr [256 x i64], [256 x i64]* %val13681, i32 0, i64 243
store i64 29, i64* %val13682
%val13683 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13684 = getelementptr [256 x i64], [256 x i64]* %val13683, i32 0, i64 244
store i64 24, i64* %val13684
%val13685 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13686 = getelementptr [256 x i64], [256 x i64]* %val13685, i32 0, i64 245
store i64 72, i64* %val13686
%val13687 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13688 = getelementptr [256 x i64], [256 x i64]* %val13687, i32 0, i64 246
store i64 243, i64* %val13688
%val13689 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13690 = getelementptr [256 x i64], [256 x i64]* %val13689, i32 0, i64 247
store i64 141, i64* %val13690
%val13691 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13692 = getelementptr [256 x i64], [256 x i64]* %val13691, i32 0, i64 248
store i64 128, i64* %val13692
%val13693 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13694 = getelementptr [256 x i64], [256 x i64]* %val13693, i32 0, i64 249
store i64 195, i64* %val13694
%val13695 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13696 = getelementptr [256 x i64], [256 x i64]* %val13695, i32 0, i64 250
store i64 78, i64* %val13696
%val13697 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13698 = getelementptr [256 x i64], [256 x i64]* %val13697, i32 0, i64 251
store i64 66, i64* %val13698
%val13699 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13700 = getelementptr [256 x i64], [256 x i64]* %val13699, i32 0, i64 252
store i64 215, i64* %val13700
%val13701 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13702 = getelementptr [256 x i64], [256 x i64]* %val13701, i32 0, i64 253
store i64 61, i64* %val13702
%val13703 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13704 = getelementptr [256 x i64], [256 x i64]* %val13703, i32 0, i64 254
store i64 156, i64* %val13704
%val13705 = load [256 x i64]*, [256 x i64]** %permutationPtr
; set array
%val13706 = getelementptr [256 x i64], [256 x i64]* %val13705, i32 0, i64 255
store i64 180, i64* %val13706
; setup loop
store i64 0, i64* %iPtr
%val13723 = load i64, i64* %iPtr
%num13724 = add i64 256, %val13723
%comp13725 = icmp ult i64 256, 1
br i1 %comp13725, label %after13707, label %loop13707

loop13707:
%val13708 = load i64, i64* %iPtr
%val13709 = load [512 x i64]*, [512 x i64]** %pPtr
%val13710 = load i64, i64* %iPtr
%val13711 = load [256 x i64]*, [256 x i64]** %permutationPtr
; array ref
%_val13712 = getelementptr [256 x i64], [256 x i64]* %val13711, i32 0, i64 %val13710
%val13713 = load i64, i64* %_val13712
; set array
%val13714 = getelementptr [512 x i64], [512 x i64]* %val13709, i32 0, i64 %val13708
store i64 %val13713, i64* %val13714
%val13715 = load i64, i64* %iPtr
%val13716 = add i64 %val13715, 256
%val13717 = load [512 x i64]*, [512 x i64]** %pPtr
%val13718 = load i64, i64* %iPtr
%val13719 = load [256 x i64]*, [256 x i64]** %permutationPtr
; array ref
%_val13720 = getelementptr [256 x i64], [256 x i64]* %val13719, i32 0, i64 %val13718
%val13721 = load i64, i64* %_val13720
; set array
%val13722 = getelementptr [512 x i64], [512 x i64]* %val13717, i32 0, i64 %val13716
store i64 %val13721, i64* %val13722
%loop_cnt13707 = load i64, i64* %iPtr
%next13707 = add i64 %loop_cnt13707, 1
store i64 %next13707, i64* %iPtr
%cmp13707 = icmp ult i64 %next13707, %num13724
br i1 %cmp13707, label %loop13707, label %after13707

after13707:
%tzone14100 = load i8*, i8** %_impzPtr
%zone14101 = bitcast i8* %tzone14100 to %mzone*

; let assign value to symbol _anon_lambda_18
%dat__anon_lambda_18 = call i8* @llvm_zone_malloc(%mzone* %zone14101, i64 8)
%_anon_lambda_18Ptr = bitcast i8* %dat__anon_lambda_18 to { i8*, i8*, double (i8*, i8*, double, double, double)*}***
%tzone13956 = load i8*, i8** %_impzPtr
%zone13957 = bitcast i8* %tzone13956 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13957)
; malloc closure structure
%clsptr13958 = call i8* @llvm_zone_malloc(%mzone* %zone13957, i64 24)
%closure13959 = bitcast i8* %clsptr13958 to { i8*, i8*, double (i8*, i8*, double, double, double)*}*

; malloc environment structure
%envptr13960 = call i8* @llvm_zone_malloc(%mzone* %zone13957, i64 208)
%environment13961 = bitcast i8* %envptr13960 to {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}*

; malloc closure address table
%addytable13962 = call %clsvar* @new_address_table()
%var13963 = bitcast [53 x i8]* @gsxtmmath543 to i8*
%var13964 = bitcast [57 x i8]* @gsxtmmath541 to i8*
%addytable13965 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var13963, i32 0, i8* %var13964, i32 3, %clsvar* %addytable13962)
%var13966 = bitcast [3 x i8]* @gsxtmmath544 to i8*
%var13967 = bitcast [7 x i8]* @gsxtmmath211 to i8*
%addytable13968 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var13966, i32 8, i8* %var13967, i32 3, %clsvar* %addytable13965)
%var13969 = bitcast [3 x i8]* @gsxtmmath545 to i8*
%var13970 = bitcast [7 x i8]* @gsxtmmath211 to i8*
%addytable13971 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var13969, i32 16, i8* %var13970, i32 3, %clsvar* %addytable13968)
%var13972 = bitcast [3 x i8]* @gsxtmmath546 to i8*
%var13973 = bitcast [7 x i8]* @gsxtmmath211 to i8*
%addytable13974 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var13972, i32 24, i8* %var13973, i32 3, %clsvar* %addytable13971)
%var13975 = bitcast [3 x i8]* @gsxtmmath547 to i8*
%var13976 = bitcast [7 x i8]* @gsxtmmath211 to i8*
%addytable13977 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var13975, i32 32, i8* %var13976, i32 3, %clsvar* %addytable13974)
%var13978 = bitcast [4 x i8]* @gsxtmmath548 to i8*
%var13979 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable13980 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var13978, i32 40, i8* %var13979, i32 3, %clsvar* %addytable13977)
%var13981 = bitcast [4 x i8]* @gsxtmmath549 to i8*
%var13982 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable13983 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var13981, i32 48, i8* %var13982, i32 3, %clsvar* %addytable13980)
%var13984 = bitcast [4 x i8]* @gsxtmmath550 to i8*
%var13985 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable13986 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var13984, i32 56, i8* %var13985, i32 3, %clsvar* %addytable13983)
%var13987 = bitcast [4 x i8]* @gsxtmmath551 to i8*
%var13988 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable13989 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var13987, i32 64, i8* %var13988, i32 3, %clsvar* %addytable13986)
%var13990 = bitcast [4 x i8]* @gsxtmmath552 to i8*
%var13991 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable13992 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var13990, i32 72, i8* %var13991, i32 3, %clsvar* %addytable13989)
%var13993 = bitcast [4 x i8]* @gsxtmmath553 to i8*
%var13994 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable13995 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var13993, i32 80, i8* %var13994, i32 3, %clsvar* %addytable13992)
%var13996 = bitcast [4 x i8]* @gsxtmmath554 to i8*
%var13997 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable13998 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var13996, i32 88, i8* %var13997, i32 3, %clsvar* %addytable13995)
%var13999 = bitcast [4 x i8]* @gsxtmmath555 to i8*
%var14000 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable14001 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var13999, i32 96, i8* %var14000, i32 3, %clsvar* %addytable13998)
%var14002 = bitcast [2 x i8]* @gsxtmmath556 to i8*
%var14003 = bitcast [7 x i8]* @gsxtmmath211 to i8*
%addytable14004 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var14002, i32 104, i8* %var14003, i32 3, %clsvar* %addytable14001)
%var14005 = bitcast [2 x i8]* @gsxtmmath557 to i8*
%var14006 = bitcast [7 x i8]* @gsxtmmath211 to i8*
%addytable14007 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var14005, i32 112, i8* %var14006, i32 3, %clsvar* %addytable14004)
%var14008 = bitcast [2 x i8]* @gsxtmmath558 to i8*
%var14009 = bitcast [7 x i8]* @gsxtmmath211 to i8*
%addytable14010 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var14008, i32 120, i8* %var14009, i32 3, %clsvar* %addytable14007)
%var14011 = bitcast [3 x i8]* @gsxtmmath559 to i8*
%var14012 = bitcast [7 x i8]* @gsxtmmath211 to i8*
%addytable14013 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var14011, i32 128, i8* %var14012, i32 3, %clsvar* %addytable14010)
%var14014 = bitcast [3 x i8]* @gsxtmmath560 to i8*
%var14015 = bitcast [7 x i8]* @gsxtmmath211 to i8*
%addytable14016 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var14014, i32 136, i8* %var14015, i32 3, %clsvar* %addytable14013)
%var14017 = bitcast [3 x i8]* @gsxtmmath561 to i8*
%var14018 = bitcast [7 x i8]* @gsxtmmath211 to i8*
%addytable14019 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var14017, i32 144, i8* %var14018, i32 3, %clsvar* %addytable14016)
%var14020 = bitcast [3 x i8]* @gsxtmmath562 to i8*
%var14021 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable14022 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var14020, i32 152, i8* %var14021, i32 3, %clsvar* %addytable14019)
%var14023 = bitcast [3 x i8]* @gsxtmmath563 to i8*
%var14024 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable14025 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var14023, i32 160, i8* %var14024, i32 3, %clsvar* %addytable14022)
%var14026 = bitcast [3 x i8]* @gsxtmmath564 to i8*
%var14027 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable14028 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var14026, i32 168, i8* %var14027, i32 3, %clsvar* %addytable14025)
%var14029 = bitcast [2 x i8]* @gsxtmmath93 to i8*
%var14030 = bitcast [4 x i8]* @gsxtmmath94 to i8*
%addytable14031 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var14029, i32 176, i8* %var14030, i32 3, %clsvar* %addytable14028)
%var14032 = bitcast [2 x i8]* @gsxtmmath565 to i8*
%var14033 = bitcast [13 x i8]* @gsxtmmath566 to i8*
%addytable14034 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var14032, i32 184, i8* %var14033, i32 3, %clsvar* %addytable14031)
%var14035 = bitcast [12 x i8]* @gsxtmmath567 to i8*
%var14036 = bitcast [13 x i8]* @gsxtmmath568 to i8*
%addytable14037 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var14035, i32 192, i8* %var14036, i32 3, %clsvar* %addytable14034)
%var14038 = bitcast [16 x i8]* @gsxtmmath569 to i8*
%var14039 = bitcast [57 x i8]* @gsxtmmath541 to i8*
%addytable14040 = call %clsvar* @add_address_table(%mzone* %zone13957, i8* %var14038, i32 200, i8* %var14039, i32 3, %clsvar* %addytable14037)
%address-table14041 = bitcast %clsvar* %addytable14040 to i8*

; insert table, function and environment into closure struct
%closure.table14094 = getelementptr { i8*, i8*, double (i8*, i8*, double, double, double)*}, { i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure13959, i32 0, i32 0
store i8* %address-table14041, i8** %closure.table14094
%closure.env14095 = getelementptr { i8*, i8*, double (i8*, i8*, double, double, double)*}, { i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure13959, i32 0, i32 1
store i8* %envptr13960, i8** %closure.env14095
%closure.func14096 = getelementptr { i8*, i8*, double (i8*, i8*, double, double, double)*}, { i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure13959, i32 0, i32 2
store double (i8*, i8*, double, double, double)* @perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0__13138, double (i8*, i8*, double, double, double)** %closure.func14096
%closure_size14097 = call i64 @llvm_zone_mark_size(%mzone* %zone13957)
call void @llvm_zone_ptr_set_size(i8* %clsptr13958, i64 %closure_size14097)
%wrapper_ptr14098 = call i8* @llvm_zone_malloc(%mzone* %zone13957, i64 8)
%closure_wrapper14099 = bitcast i8* %wrapper_ptr14098 to { i8*, i8*, double (i8*, i8*, double, double, double)*}**
store { i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure13959, { i8*, i8*, double (i8*, i8*, double, double, double)*}** %closure_wrapper14099

; let value assignment
%_anon_lambda_18 = select i1 true, { i8*, i8*, double (i8*, i8*, double, double, double)*}** %closure_wrapper14099, { i8*, i8*, double (i8*, i8*, double, double, double)*}** %closure_wrapper14099
store { i8*, i8*, double (i8*, i8*, double, double, double)*}** %_anon_lambda_18, { i8*, i8*, double (i8*, i8*, double, double, double)*}*** %_anon_lambda_18Ptr

; add data to environment
; don't need to alloc for env var perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0
%tmp_envptr14043 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, double, double, double)*}*** %perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0Ptr, {i8*, i8*, double (i8*, i8*, double, double, double)*}**** %tmp_envptr14043

; don't need to alloc for env var y2
%tmp_envptr14045 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 1
store double* %y2Ptr, double** %tmp_envptr14045

; don't need to alloc for env var y1
%tmp_envptr14047 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 2
store double* %y1Ptr, double** %tmp_envptr14047

; don't need to alloc for env var x2
%tmp_envptr14049 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 3
store double* %x2Ptr, double** %tmp_envptr14049

; don't need to alloc for env var x1
%tmp_envptr14051 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 4
store double* %x1Ptr, double** %tmp_envptr14051

; don't need to alloc for env var bbb
%tmp_envptr14053 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 5
store i64* %bbbPtr, i64** %tmp_envptr14053

; don't need to alloc for env var bab
%tmp_envptr14055 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 6
store i64* %babPtr, i64** %tmp_envptr14055

; don't need to alloc for env var bba
%tmp_envptr14057 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 7
store i64* %bbaPtr, i64** %tmp_envptr14057

; don't need to alloc for env var baa
%tmp_envptr14059 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 8
store i64* %baaPtr, i64** %tmp_envptr14059

; don't need to alloc for env var abb
%tmp_envptr14061 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 9
store i64* %abbPtr, i64** %tmp_envptr14061

; don't need to alloc for env var aab
%tmp_envptr14063 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 10
store i64* %aabPtr, i64** %tmp_envptr14063

; don't need to alloc for env var aba
%tmp_envptr14065 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 11
store i64* %abaPtr, i64** %tmp_envptr14065

; don't need to alloc for env var aaa
%tmp_envptr14067 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 12
store i64* %aaaPtr, i64** %tmp_envptr14067

; don't need to alloc for env var w
%tmp_envptr14069 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 13
store double* %wPtr, double** %tmp_envptr14069

; don't need to alloc for env var v
%tmp_envptr14071 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 14
store double* %vPtr, double** %tmp_envptr14071

; don't need to alloc for env var u
%tmp_envptr14073 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 15
store double* %uPtr, double** %tmp_envptr14073

; don't need to alloc for env var zf
%tmp_envptr14075 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 16
store double* %zfPtr, double** %tmp_envptr14075

; don't need to alloc for env var yf
%tmp_envptr14077 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 17
store double* %yfPtr, double** %tmp_envptr14077

; don't need to alloc for env var xf
%tmp_envptr14079 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 18
store double* %xfPtr, double** %tmp_envptr14079

; don't need to alloc for env var zi
%tmp_envptr14081 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 19
store i64* %ziPtr, i64** %tmp_envptr14081

; don't need to alloc for env var yi
%tmp_envptr14083 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 20
store i64* %yiPtr, i64** %tmp_envptr14083

; don't need to alloc for env var xi
%tmp_envptr14085 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 21
store i64* %xiPtr, i64** %tmp_envptr14085

; don't need to alloc for env var i
%tmp_envptr14087 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 22
store i64* %iPtr, i64** %tmp_envptr14087

; don't need to alloc for env var p
%tmp_envptr14089 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 23
store [512 x i64]** %pPtr, [512 x i64]*** %tmp_envptr14089

; don't need to alloc for env var permutation
%tmp_envptr14091 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 24
store [256 x i64]** %permutationPtr, [256 x i64]*** %tmp_envptr14091

; don't need to alloc for env var _anon_lambda_18
%tmp_envptr14093 = getelementptr {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}, {{i8*, i8*, double (i8*, i8*, double, double, double)*}***, double*, double*, double*, double*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, i64*, double*, double*, double*, double*, double*, double*, i64*, i64*, i64*, i64*, [512 x i64]**, [256 x i64]**, {i8*, i8*, double (i8*, i8*, double, double, double)*}***}* %environment13961, i32 0, i32 25
store {i8*, i8*, double (i8*, i8*, double, double, double)*}*** %_anon_lambda_18Ptr, {i8*, i8*, double (i8*, i8*, double, double, double)*}**** %tmp_envptr14093


%val14102 = load {i8*, i8*, double (i8*, i8*, double, double, double)*}**, {i8*, i8*, double (i8*, i8*, double, double, double)*}*** %_anon_lambda_18Ptr

; let value assignment
%perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0 = select i1 true, {i8*, i8*, double (i8*, i8*, double, double, double)*}** %val14102, {i8*, i8*, double (i8*, i8*, double, double, double)*}** %val14102
store {i8*, i8*, double (i8*, i8*, double, double, double)*}** %perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0, {i8*, i8*, double (i8*, i8*, double, double, double)*}*** %perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0Ptr

%val14105 = load {i8*, i8*, double (i8*, i8*, double, double, double)*}**, {i8*, i8*, double (i8*, i8*, double, double, double)*}*** %perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0Ptr
ret {i8*, i8*, double (i8*, i8*, double, double, double)*}** %val14105
}


@perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_var = dllexport global [1 x i8*] [ i8* null ]

@perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, double, double, double)*}** @perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, double, double, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0(double %arg_0,double %arg_1,double %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, double, double)*}*, {i8*, i8*, double (i8*, i8*, double, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, double, double)*}, {i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, double, double)*}, {i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, double, double)*,  double (i8*, i8*, double, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1, double %arg_2)
ret double %result
}


define dllexport ccc double @perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_native(double %arg_0,double %arg_1,double %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, double, double)*}*, {i8*, i8*, double (i8*, i8*, double, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, double, double)*}, {i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, double, double)*}, {i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, double, double)*,  double (i8*, i8*, double, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1, double %arg_2)
ret double %result
}


define dllexport ccc i8*  @perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var14106 = bitcast [106 x i8]* @gsxtmmath570 to i8*
call i32 (i8*, ...) @printf(i8* %var14106)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc double @r64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var14107 = bitcast [106 x i8]* @gsxtmmath570 to i8*
call i32 (i8*, ...) @printf(i8* %var14107)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var14108 = bitcast [106 x i8]* @gsxtmmath570 to i8*
call i32 (i8*, ...) @printf(i8* %var14108)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc double @r64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, double, double)*}*, {i8*, i8*, double (i8*, i8*, double, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, double, double)*}, {i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, double, double)*}, {i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, double, double)*,  double (i8*, i8*, double, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1, double %arg_2)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double, double, double}*
%arg_p_0 = getelementptr {double, double, double}, {double, double, double}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
%arg_p_1 = getelementptr {double, double, double}, {double, double, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
%arg_p_2 = getelementptr {double, double, double}, {double, double, double}* %fstruct, i32 0, i32 2
%arg_2 = load double, double* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @perlin_adhoc_W2RvdWJsZSxkb3VibGUsZG91YmxlLGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, double, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, double, double)*}*, {i8*, i8*, double (i8*, i8*, double, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, double, double)*}, {i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, double, double)*}, {i8*, i8*, double (i8*, i8*, double, double, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, double, double)*,  double (i8*, i8*, double, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, double %arg_1, double %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


