%NVGcolor = type {float,float,float,float}
@gsxtmnanovg0 = hidden constant [63 x i8] c"NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0\00"
@gsxtmnanovg1 = hidden constant [65 x i8] c"{i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**\00"
define dllexport fastcc %NVGcolor* @NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0__1(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1, float %arg_2, float %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***}*
%NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr_ = getelementptr {{i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr = load {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**** %NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr
%arg_2Ptr = alloca float
store float %arg_2, float* %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr


%tzone7 = load i8*, i8** %_impzPtr
%zone8 = bitcast i8* %tzone7 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGcolor*
%tzone3 = load i8*, i8** %_impzPtr
%zone4 = bitcast i8* %tzone3 to %mzone*
%dat5 = call i8* @llvm_zone_malloc(%mzone* %zone4, i64 16)
call i8* @memset(i8* %dat5, i32 0, i64 16)
%val6 = bitcast i8* %dat5 to %NVGcolor*

; let value assignment
%obj = select i1 true, %NVGcolor* %val6, %NVGcolor* %val6
store %NVGcolor* %obj, %NVGcolor** %objPtr

%val9 = load %NVGcolor*, %NVGcolor** %objPtr
%val10 = load float, float* %arg_0Ptr
; set tuple
%val11 = getelementptr %NVGcolor, %NVGcolor* %val9, i64 0, i32 0
store float %val10, float* %val11
%val12 = load %NVGcolor*, %NVGcolor** %objPtr
%val13 = load float, float* %arg_1Ptr
; set tuple
%val14 = getelementptr %NVGcolor, %NVGcolor* %val12, i64 0, i32 1
store float %val13, float* %val14
%val15 = load %NVGcolor*, %NVGcolor** %objPtr
%val16 = load float, float* %arg_2Ptr
; set tuple
%val17 = getelementptr %NVGcolor, %NVGcolor* %val15, i64 0, i32 2
store float %val16, float* %val17
%val18 = load %NVGcolor*, %NVGcolor** %objPtr
%val19 = load float, float* %arg_3Ptr
; set tuple
%val20 = getelementptr %NVGcolor, %NVGcolor* %val18, i64 0, i32 3
store float %val19, float* %val20
%val21 = load %NVGcolor*, %NVGcolor** %objPtr
ret %NVGcolor* %val21
}
@gsxtmnanovg2 = hidden constant [116 x i8] c"NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** @NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone41 = load i8*, i8** %_impzPtr
%zone42 = bitcast i8* %tzone41 to %mzone*

; let assign value to symbol NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0
%dat_NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0 = call i8* @llvm_zone_malloc(%mzone* %zone42, i64 8)
%NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr = bitcast i8* %dat_NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0 to { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***
%tzone22 = load i8*, i8** %_impzPtr
%zone23 = bitcast i8* %tzone22 to %mzone*
call void @llvm_zone_mark(%mzone* %zone23)
; malloc closure structure
%clsptr24 = call i8* @llvm_zone_malloc(%mzone* %zone23, i64 24)
%closure25 = bitcast i8* %clsptr24 to { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*

; malloc environment structure
%envptr26 = call i8* @llvm_zone_malloc(%mzone* %zone23, i64 8)
%environment27 = bitcast i8* %envptr26 to {{i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***}*

; malloc closure address table
%addytable28 = call %clsvar* @new_address_table()
%var29 = bitcast [63 x i8]* @gsxtmnanovg0 to i8*
%var30 = bitcast [65 x i8]* @gsxtmnanovg1 to i8*
%addytable31 = call %clsvar* @add_address_table(%mzone* %zone23, i8* %var29, i32 0, i8* %var30, i32 3, %clsvar* %addytable28)
%address-table32 = bitcast %clsvar* %addytable31 to i8*

; insert table, function and environment into closure struct
%closure.table35 = getelementptr { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure25, i32 0, i32 0
store i8* %address-table32, i8** %closure.table35
%closure.env36 = getelementptr { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure25, i32 0, i32 1
store i8* %envptr26, i8** %closure.env36
%closure.func37 = getelementptr { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure25, i32 0, i32 2
store %NVGcolor* (i8*, i8*, float, float, float, float)* @NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0__1, %NVGcolor* (i8*, i8*, float, float, float, float)** %closure.func37
%closure_size38 = call i64 @llvm_zone_mark_size(%mzone* %zone23)
call void @llvm_zone_ptr_set_size(i8* %clsptr24, i64 %closure_size38)
%wrapper_ptr39 = call i8* @llvm_zone_malloc(%mzone* %zone23, i64 8)
%closure_wrapper40 = bitcast i8* %wrapper_ptr39 to { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**
store { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure25, { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure_wrapper40

; let value assignment
%NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0 = select i1 true, { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure_wrapper40, { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure_wrapper40
store { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0, { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*** %NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr

; add data to environment
; don't need to alloc for env var NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0
%tmp_envptr34 = getelementptr {{i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***}* %environment27, i32 0, i32 0
store {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*** %NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**** %tmp_envptr34


%val43 = load {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*** %NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr
ret {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %val43
}


@NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var = dllexport global [1 x i8*] [ i8* null ]

@NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** @NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGcolor* @NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, float, float, float, float)*,  %NVGcolor* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGcolor* %result
}


define dllexport ccc %NVGcolor* @NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_native(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, float, float, float, float)*,  %NVGcolor* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGcolor* %result
}


define dllexport ccc i8*  @NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var44 = bitcast [116 x i8]* @gsxtmnanovg2 to i8*
call i32 (i8*, ...) @printf(i8* %var44)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var45 = bitcast [116 x i8]* @gsxtmnanovg2 to i8*
call i32 (i8*, ...) @printf(i8* %var45)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var46 = bitcast [116 x i8]* @gsxtmnanovg2 to i8*
call i32 (i8*, ...) @printf(i8* %var46)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var47 = bitcast [116 x i8]* @gsxtmnanovg2 to i8*
call i32 (i8*, ...) @printf(i8* %var47)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, float, float, float, float)*,  %NVGcolor* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%tmpres = bitcast %NVGcolor* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float, float, float}*
%arg_p_0 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, float, float, float, float)*,  %NVGcolor* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg3 = hidden constant [65 x i8] c"NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0\00"
define dllexport fastcc %NVGcolor* @NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0__48(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1, float %arg_2, float %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone49 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***}*
%NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr_ = getelementptr {{i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr = load {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**** %NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr
%arg_2Ptr = alloca float
store float %arg_2, float* %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr


%tzone54 = load i8*, i8** %_impzPtr
%zone55 = bitcast i8* %tzone54 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGcolor*
%tzone50 = load i8*, i8** %_impzPtr
%zone51 = bitcast i8* %tzone50 to %mzone*
%dat52 = call i8* @llvm_zone_malloc(%mzone* %zone51, i64 16)
call i8* @memset(i8* %dat52, i32 0, i64 16)
%val53 = bitcast i8* %dat52 to %NVGcolor*

; let value assignment
%obj = select i1 true, %NVGcolor* %val53, %NVGcolor* %val53
store %NVGcolor* %obj, %NVGcolor** %objPtr

%val56 = load %NVGcolor*, %NVGcolor** %objPtr
%val57 = load float, float* %arg_0Ptr
; set tuple
%val58 = getelementptr %NVGcolor, %NVGcolor* %val56, i64 0, i32 0
store float %val57, float* %val58
%val59 = load %NVGcolor*, %NVGcolor** %objPtr
%val60 = load float, float* %arg_1Ptr
; set tuple
%val61 = getelementptr %NVGcolor, %NVGcolor* %val59, i64 0, i32 1
store float %val60, float* %val61
%val62 = load %NVGcolor*, %NVGcolor** %objPtr
%val63 = load float, float* %arg_2Ptr
; set tuple
%val64 = getelementptr %NVGcolor, %NVGcolor* %val62, i64 0, i32 2
store float %val63, float* %val64
%val65 = load %NVGcolor*, %NVGcolor** %objPtr
%val66 = load float, float* %arg_3Ptr
; set tuple
%val67 = getelementptr %NVGcolor, %NVGcolor* %val65, i64 0, i32 3
store float %val66, float* %val67
%val68 = load %NVGcolor*, %NVGcolor** %objPtr
ret %NVGcolor* %val68
}
@gsxtmnanovg4 = hidden constant [118 x i8] c"NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** @NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone88 = load i8*, i8** %_impzPtr
%zone89 = bitcast i8* %tzone88 to %mzone*

; let assign value to symbol NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0
%dat_NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0 = call i8* @llvm_zone_malloc(%mzone* %zone89, i64 8)
%NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr = bitcast i8* %dat_NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0 to { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***
%tzone69 = load i8*, i8** %_impzPtr
%zone70 = bitcast i8* %tzone69 to %mzone*
call void @llvm_zone_mark(%mzone* %zone70)
; malloc closure structure
%clsptr71 = call i8* @llvm_zone_malloc(%mzone* %zone70, i64 24)
%closure72 = bitcast i8* %clsptr71 to { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*

; malloc environment structure
%envptr73 = call i8* @llvm_zone_malloc(%mzone* %zone70, i64 8)
%environment74 = bitcast i8* %envptr73 to {{i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***}*

; malloc closure address table
%addytable75 = call %clsvar* @new_address_table()
%var76 = bitcast [65 x i8]* @gsxtmnanovg3 to i8*
%var77 = bitcast [65 x i8]* @gsxtmnanovg1 to i8*
%addytable78 = call %clsvar* @add_address_table(%mzone* %zone70, i8* %var76, i32 0, i8* %var77, i32 3, %clsvar* %addytable75)
%address-table79 = bitcast %clsvar* %addytable78 to i8*

; insert table, function and environment into closure struct
%closure.table82 = getelementptr { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure72, i32 0, i32 0
store i8* %address-table79, i8** %closure.table82
%closure.env83 = getelementptr { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure72, i32 0, i32 1
store i8* %envptr73, i8** %closure.env83
%closure.func84 = getelementptr { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure72, i32 0, i32 2
store %NVGcolor* (i8*, i8*, float, float, float, float)* @NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0__48, %NVGcolor* (i8*, i8*, float, float, float, float)** %closure.func84
%closure_size85 = call i64 @llvm_zone_mark_size(%mzone* %zone70)
call void @llvm_zone_ptr_set_size(i8* %clsptr71, i64 %closure_size85)
%wrapper_ptr86 = call i8* @llvm_zone_malloc(%mzone* %zone70, i64 8)
%closure_wrapper87 = bitcast i8* %wrapper_ptr86 to { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**
store { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure72, { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure_wrapper87

; let value assignment
%NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0 = select i1 true, { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure_wrapper87, { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure_wrapper87
store { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0, { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*** %NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr

; add data to environment
; don't need to alloc for env var NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0
%tmp_envptr81 = getelementptr {{i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***}* %environment74, i32 0, i32 0
store {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*** %NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**** %tmp_envptr81


%val90 = load {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*** %NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr
ret {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %val90
}


@NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var = dllexport global [1 x i8*] [ i8* null ]

@NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** @NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGcolor* @NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, float, float, float, float)*,  %NVGcolor* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGcolor* %result
}


define dllexport ccc %NVGcolor* @NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_native(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, float, float, float, float)*,  %NVGcolor* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGcolor* %result
}


define dllexport ccc i8*  @NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var91 = bitcast [118 x i8]* @gsxtmnanovg4 to i8*
call i32 (i8*, ...) @printf(i8* %var91)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var92 = bitcast [118 x i8]* @gsxtmnanovg4 to i8*
call i32 (i8*, ...) @printf(i8* %var92)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var93 = bitcast [118 x i8]* @gsxtmnanovg4 to i8*
call i32 (i8*, ...) @printf(i8* %var93)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var94 = bitcast [118 x i8]* @gsxtmnanovg4 to i8*
call i32 (i8*, ...) @printf(i8* %var94)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, float, float, float, float)*,  %NVGcolor* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%tmpres = bitcast %NVGcolor* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float, float, float}*
%arg_p_0 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_z_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, float, float, float, float)*,  %NVGcolor* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg5 = hidden constant [65 x i8] c"NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0\00"
define dllexport fastcc %NVGcolor* @NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0__95(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1, float %arg_2, float %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone96 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***}*
%NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr_ = getelementptr {{i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr = load {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**** %NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr
%arg_2Ptr = alloca float
store float %arg_2, float* %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr


%tzone99 = load i8*, i8** %_impzPtr
%zone100 = bitcast i8* %tzone99 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGcolor*
%dat97 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat97, i32 0, i64 16)
%val98 = bitcast i8* %dat97 to %NVGcolor*

; let value assignment
%obj = select i1 true, %NVGcolor* %val98, %NVGcolor* %val98
store %NVGcolor* %obj, %NVGcolor** %objPtr

%val101 = load %NVGcolor*, %NVGcolor** %objPtr
%val102 = load float, float* %arg_0Ptr
; set tuple
%val103 = getelementptr %NVGcolor, %NVGcolor* %val101, i64 0, i32 0
store float %val102, float* %val103
%val104 = load %NVGcolor*, %NVGcolor** %objPtr
%val105 = load float, float* %arg_1Ptr
; set tuple
%val106 = getelementptr %NVGcolor, %NVGcolor* %val104, i64 0, i32 1
store float %val105, float* %val106
%val107 = load %NVGcolor*, %NVGcolor** %objPtr
%val108 = load float, float* %arg_2Ptr
; set tuple
%val109 = getelementptr %NVGcolor, %NVGcolor* %val107, i64 0, i32 2
store float %val108, float* %val109
%val110 = load %NVGcolor*, %NVGcolor** %objPtr
%val111 = load float, float* %arg_3Ptr
; set tuple
%val112 = getelementptr %NVGcolor, %NVGcolor* %val110, i64 0, i32 3
store float %val111, float* %val112
%val113 = load %NVGcolor*, %NVGcolor** %objPtr
ret %NVGcolor* %val113
}
@gsxtmnanovg6 = hidden constant [118 x i8] c"NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** @NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone133 = load i8*, i8** %_impzPtr
%zone134 = bitcast i8* %tzone133 to %mzone*

; let assign value to symbol NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0
%dat_NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0 = call i8* @llvm_zone_malloc(%mzone* %zone134, i64 8)
%NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr = bitcast i8* %dat_NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0 to { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***
%tzone114 = load i8*, i8** %_impzPtr
%zone115 = bitcast i8* %tzone114 to %mzone*
call void @llvm_zone_mark(%mzone* %zone115)
; malloc closure structure
%clsptr116 = call i8* @llvm_zone_malloc(%mzone* %zone115, i64 24)
%closure117 = bitcast i8* %clsptr116 to { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*

; malloc environment structure
%envptr118 = call i8* @llvm_zone_malloc(%mzone* %zone115, i64 8)
%environment119 = bitcast i8* %envptr118 to {{i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***}*

; malloc closure address table
%addytable120 = call %clsvar* @new_address_table()
%var121 = bitcast [65 x i8]* @gsxtmnanovg5 to i8*
%var122 = bitcast [65 x i8]* @gsxtmnanovg1 to i8*
%addytable123 = call %clsvar* @add_address_table(%mzone* %zone115, i8* %var121, i32 0, i8* %var122, i32 3, %clsvar* %addytable120)
%address-table124 = bitcast %clsvar* %addytable123 to i8*

; insert table, function and environment into closure struct
%closure.table127 = getelementptr { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure117, i32 0, i32 0
store i8* %address-table124, i8** %closure.table127
%closure.env128 = getelementptr { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure117, i32 0, i32 1
store i8* %envptr118, i8** %closure.env128
%closure.func129 = getelementptr { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure117, i32 0, i32 2
store %NVGcolor* (i8*, i8*, float, float, float, float)* @NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0__95, %NVGcolor* (i8*, i8*, float, float, float, float)** %closure.func129
%closure_size130 = call i64 @llvm_zone_mark_size(%mzone* %zone115)
call void @llvm_zone_ptr_set_size(i8* %clsptr116, i64 %closure_size130)
%wrapper_ptr131 = call i8* @llvm_zone_malloc(%mzone* %zone115, i64 8)
%closure_wrapper132 = bitcast i8* %wrapper_ptr131 to { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**
store { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure117, { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure_wrapper132

; let value assignment
%NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0 = select i1 true, { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure_wrapper132, { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure_wrapper132
store { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0, { i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*** %NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr

; add data to environment
; don't need to alloc for env var NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0
%tmp_envptr126 = getelementptr {{i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}***}* %environment119, i32 0, i32 0
store {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*** %NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**** %tmp_envptr126


%val135 = load {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*** %NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr
ret {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %val135
}


@NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var = dllexport global [1 x i8*] [ i8* null ]

@NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** @NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGcolor* @NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, float, float, float, float)*,  %NVGcolor* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGcolor* %result
}


define dllexport ccc %NVGcolor* @NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_native(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, float, float, float, float)*,  %NVGcolor* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGcolor* %result
}


define dllexport ccc i8*  @NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var136 = bitcast [118 x i8]* @gsxtmnanovg6 to i8*
call i32 (i8*, ...) @printf(i8* %var136)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var137 = bitcast [118 x i8]* @gsxtmnanovg6 to i8*
call i32 (i8*, ...) @printf(i8* %var137)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var138 = bitcast [118 x i8]* @gsxtmnanovg6 to i8*
call i32 (i8*, ...) @printf(i8* %var138)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var139 = bitcast [118 x i8]* @gsxtmnanovg6 to i8*
call i32 (i8*, ...) @printf(i8* %var139)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, float, float, float, float)*,  %NVGcolor* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%tmpres = bitcast %NVGcolor* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float, float, float}*
%arg_p_0 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_h_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, float, float, float, float)*,  %NVGcolor* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg7 = hidden constant [66 x i8] c"NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
@gsxtmnanovg8 = hidden constant [64 x i8] c"{i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}**\00"
define dllexport fastcc %NVGcolor @NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__140(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1, float %arg_2, float %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone141 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}***}*
%NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}***, {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}**** %NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr
%arg_2Ptr = alloca float
store float %arg_2, float* %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr


%tzone143 = load i8*, i8** %_impzPtr
%zone144 = bitcast i8* %tzone143 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGcolor*
%dat142 = alloca %NVGcolor, align 16

; let value assignment
%obj = select i1 true, %NVGcolor* %dat142, %NVGcolor* %dat142
store %NVGcolor* %obj, %NVGcolor** %objPtr

%val145 = load %NVGcolor*, %NVGcolor** %objPtr
%val146 = load float, float* %arg_0Ptr
; set tuple
%val147 = getelementptr %NVGcolor, %NVGcolor* %val145, i64 0, i32 0
store float %val146, float* %val147
%val148 = load %NVGcolor*, %NVGcolor** %objPtr
%val149 = load float, float* %arg_1Ptr
; set tuple
%val150 = getelementptr %NVGcolor, %NVGcolor* %val148, i64 0, i32 1
store float %val149, float* %val150
%val151 = load %NVGcolor*, %NVGcolor** %objPtr
%val152 = load float, float* %arg_2Ptr
; set tuple
%val153 = getelementptr %NVGcolor, %NVGcolor* %val151, i64 0, i32 2
store float %val152, float* %val153
%val154 = load %NVGcolor*, %NVGcolor** %objPtr
%val155 = load float, float* %arg_3Ptr
; set tuple
%val156 = getelementptr %NVGcolor, %NVGcolor* %val154, i64 0, i32 3
store float %val155, float* %val156
%val157 = load %NVGcolor*, %NVGcolor** %objPtr
; pointer ref
%val158 = getelementptr %NVGcolor, %NVGcolor* %val157, i64 0
%val159 = load %NVGcolor, %NVGcolor* %val158
ret %NVGcolor %val159
}
@gsxtmnanovg9 = hidden constant [119 x i8] c"NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}** @NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone179 = load i8*, i8** %_impzPtr
%zone180 = bitcast i8* %tzone179 to %mzone*

; let assign value to symbol NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone180, i64 8)
%NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ to { i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}***
%tzone160 = load i8*, i8** %_impzPtr
%zone161 = bitcast i8* %tzone160 to %mzone*
call void @llvm_zone_mark(%mzone* %zone161)
; malloc closure structure
%clsptr162 = call i8* @llvm_zone_malloc(%mzone* %zone161, i64 24)
%closure163 = bitcast i8* %clsptr162 to { i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}*

; malloc environment structure
%envptr164 = call i8* @llvm_zone_malloc(%mzone* %zone161, i64 8)
%environment165 = bitcast i8* %envptr164 to {{i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}***}*

; malloc closure address table
%addytable166 = call %clsvar* @new_address_table()
%var167 = bitcast [66 x i8]* @gsxtmnanovg7 to i8*
%var168 = bitcast [64 x i8]* @gsxtmnanovg8 to i8*
%addytable169 = call %clsvar* @add_address_table(%mzone* %zone161, i8* %var167, i32 0, i8* %var168, i32 3, %clsvar* %addytable166)
%address-table170 = bitcast %clsvar* %addytable169 to i8*

; insert table, function and environment into closure struct
%closure.table173 = getelementptr { i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}* %closure163, i32 0, i32 0
store i8* %address-table170, i8** %closure.table173
%closure.env174 = getelementptr { i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}* %closure163, i32 0, i32 1
store i8* %envptr164, i8** %closure.env174
%closure.func175 = getelementptr { i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}* %closure163, i32 0, i32 2
store %NVGcolor (i8*, i8*, float, float, float, float)* @NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__140, %NVGcolor (i8*, i8*, float, float, float, float)** %closure.func175
%closure_size176 = call i64 @llvm_zone_mark_size(%mzone* %zone161)
call void @llvm_zone_ptr_set_size(i8* %clsptr162, i64 %closure_size176)
%wrapper_ptr177 = call i8* @llvm_zone_malloc(%mzone* %zone161, i64 8)
%closure_wrapper178 = bitcast i8* %wrapper_ptr177 to { i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}**
store { i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}* %closure163, { i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}** %closure_wrapper178

; let value assignment
%NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}** %closure_wrapper178, { i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}** %closure_wrapper178
store { i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}** %NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ, { i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}*** %NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr172 = getelementptr {{i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}***}* %environment165, i32 0, i32 0
store {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}*** %NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}**** %tmp_envptr172


%val181 = load {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}**, {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}*** %NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}** %val181
}


@NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}** @NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGcolor @NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor (i8*, i8*, float, float, float, float)*,  %NVGcolor (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGcolor %result
}


define dllexport ccc %NVGcolor @NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_native(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor (i8*, i8*, float, float, float, float)*,  %NVGcolor (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGcolor %result
}


define dllexport ccc void @NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float, float, float}*
%arg_p_0 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_val_adhoc_W05WR2NvbG9yLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGcolor (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor (i8*, i8*, float, float, float, float)*,  %NVGcolor (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg10 = hidden constant [41 x i8] c"hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd\00"
@gsxtmnanovg11 = hidden constant [49 x i8] c"{i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}**\00"
define dllexport fastcc %NVGcolor* @hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd__186(i8* %_impz,i8* %_impenv, %NVGcolor* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone187 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}***}*
%hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipdPtr_ = getelementptr {{i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}***}, {{i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipdPtr = load {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}***, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}**** %hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipdPtr_

; setup arguments
%xPtr = alloca %NVGcolor*
store %NVGcolor* %x, %NVGcolor** %xPtr


%tzone190 = load i8*, i8** %_impzPtr
%zone191 = bitcast i8* %tzone190 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGcolor*
%dat188 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat188, i32 0, i64 16)
%val189 = bitcast i8* %dat188 to %NVGcolor*

; let value assignment
%obj = select i1 true, %NVGcolor* %val189, %NVGcolor* %val189
store %NVGcolor* %obj, %NVGcolor** %objPtr

%val192 = load %NVGcolor*, %NVGcolor** %objPtr
%val193 = load %NVGcolor*, %NVGcolor** %xPtr
; tuple ref
%val194 = getelementptr %NVGcolor, %NVGcolor* %val193, i64 0, i32 0
%val195 = load float, float* %val194
; set tuple
%val196 = getelementptr %NVGcolor, %NVGcolor* %val192, i64 0, i32 0
store float %val195, float* %val196
%val197 = load %NVGcolor*, %NVGcolor** %objPtr
%val198 = load %NVGcolor*, %NVGcolor** %xPtr
; tuple ref
%val199 = getelementptr %NVGcolor, %NVGcolor* %val198, i64 0, i32 1
%val200 = load float, float* %val199
; set tuple
%val201 = getelementptr %NVGcolor, %NVGcolor* %val197, i64 0, i32 1
store float %val200, float* %val201
%val202 = load %NVGcolor*, %NVGcolor** %objPtr
%val203 = load %NVGcolor*, %NVGcolor** %xPtr
; tuple ref
%val204 = getelementptr %NVGcolor, %NVGcolor* %val203, i64 0, i32 2
%val205 = load float, float* %val204
; set tuple
%val206 = getelementptr %NVGcolor, %NVGcolor* %val202, i64 0, i32 2
store float %val205, float* %val206
%val207 = load %NVGcolor*, %NVGcolor** %objPtr
%val208 = load %NVGcolor*, %NVGcolor** %xPtr
; tuple ref
%val209 = getelementptr %NVGcolor, %NVGcolor* %val208, i64 0, i32 3
%val210 = load float, float* %val209
; set tuple
%val211 = getelementptr %NVGcolor, %NVGcolor* %val207, i64 0, i32 3
store float %val210, float* %val211
%val212 = load %NVGcolor*, %NVGcolor** %objPtr
ret %NVGcolor* %val212
}
@gsxtmnanovg12 = hidden constant [94 x i8] c"hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}** @hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone232 = load i8*, i8** %_impzPtr
%zone233 = bitcast i8* %tzone232 to %mzone*

; let assign value to symbol hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd
%dat_hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd = call i8* @llvm_zone_malloc(%mzone* %zone233, i64 8)
%hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipdPtr = bitcast i8* %dat_hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd to { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}***
%tzone213 = load i8*, i8** %_impzPtr
%zone214 = bitcast i8* %tzone213 to %mzone*
call void @llvm_zone_mark(%mzone* %zone214)
; malloc closure structure
%clsptr215 = call i8* @llvm_zone_malloc(%mzone* %zone214, i64 24)
%closure216 = bitcast i8* %clsptr215 to { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}*

; malloc environment structure
%envptr217 = call i8* @llvm_zone_malloc(%mzone* %zone214, i64 8)
%environment218 = bitcast i8* %envptr217 to {{i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}***}*

; malloc closure address table
%addytable219 = call %clsvar* @new_address_table()
%var220 = bitcast [41 x i8]* @gsxtmnanovg10 to i8*
%var221 = bitcast [49 x i8]* @gsxtmnanovg11 to i8*
%addytable222 = call %clsvar* @add_address_table(%mzone* %zone214, i8* %var220, i32 0, i8* %var221, i32 3, %clsvar* %addytable219)
%address-table223 = bitcast %clsvar* %addytable222 to i8*

; insert table, function and environment into closure struct
%closure.table226 = getelementptr { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}, { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}* %closure216, i32 0, i32 0
store i8* %address-table223, i8** %closure.table226
%closure.env227 = getelementptr { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}, { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}* %closure216, i32 0, i32 1
store i8* %envptr217, i8** %closure.env227
%closure.func228 = getelementptr { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}, { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}* %closure216, i32 0, i32 2
store %NVGcolor* (i8*, i8*, %NVGcolor*)* @hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd__186, %NVGcolor* (i8*, i8*, %NVGcolor*)** %closure.func228
%closure_size229 = call i64 @llvm_zone_mark_size(%mzone* %zone214)
call void @llvm_zone_ptr_set_size(i8* %clsptr215, i64 %closure_size229)
%wrapper_ptr230 = call i8* @llvm_zone_malloc(%mzone* %zone214, i64 8)
%closure_wrapper231 = bitcast i8* %wrapper_ptr230 to { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}**
store { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}* %closure216, { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}** %closure_wrapper231

; let value assignment
%hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd = select i1 true, { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}** %closure_wrapper231, { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}** %closure_wrapper231
store { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}** %hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd, { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}*** %hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipdPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd
%tmp_envptr225 = getelementptr {{i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}***}, {{i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}***}* %environment218, i32 0, i32 0
store {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}*** %hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipdPtr, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}**** %tmp_envptr225


%val234 = load {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}**, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}*** %hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipdPtr
ret {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}** %val234
}


@hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}** @hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGcolor* @hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd(%NVGcolor* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, %NVGcolor*)*,  %NVGcolor* (i8*, i8*, %NVGcolor*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, %NVGcolor* %arg_0)
ret %NVGcolor* %result
}


define dllexport ccc %NVGcolor* @hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd_native(%NVGcolor* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, %NVGcolor*)*,  %NVGcolor* (i8*, i8*, %NVGcolor*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, %NVGcolor* %arg_0)
ret %NVGcolor* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var235 = bitcast [94 x i8]* @gsxtmnanovg12 to i8*
call i32 (i8*, ...) @printf(i8* %var235)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGcolor*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, %NVGcolor*)*,  %NVGcolor* (i8*, i8*, %NVGcolor*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, %NVGcolor* %arg_0)
%tmpres = bitcast %NVGcolor* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGcolor*}*
%arg_p_0 = getelementptr {%NVGcolor*}, {%NVGcolor*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGcolor*, %NVGcolor** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, %NVGcolor*)*,  %NVGcolor* (i8*, i8*, %NVGcolor*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, %NVGcolor* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg13 = hidden constant [35 x i8] c"hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ\00"
@gsxtmnanovg14 = hidden constant [43 x i8] c"{i8*, i8*, void (i8*, i8*, %NVGcolor*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ__236(i8* %_impz,i8* %_impenv, %NVGcolor* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone237 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %NVGcolor*)*}***}*
%hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGcolor*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGcolor*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQPtr = load {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}***, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}**** %hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQPtr_

; setup arguments
%xPtr = alloca %NVGcolor*
store %NVGcolor* %x, %NVGcolor** %xPtr


%val238 = load %NVGcolor*, %NVGcolor** %xPtr
%val239 = bitcast %NVGcolor* %val238 to i8*
call ccc void @free(i8* %val239)
ret void
}
@gsxtmnanovg15 = hidden constant [88 x i8] c"hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** @hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone261 = load i8*, i8** %_impzPtr
%zone262 = bitcast i8* %tzone261 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ
%dat_hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ = call i8* @llvm_zone_malloc(%mzone* %zone262, i64 8)
%hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ to { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}***
%tzone242 = load i8*, i8** %_impzPtr
%zone243 = bitcast i8* %tzone242 to %mzone*
call void @llvm_zone_mark(%mzone* %zone243)
; malloc closure structure
%clsptr244 = call i8* @llvm_zone_malloc(%mzone* %zone243, i64 24)
%closure245 = bitcast i8* %clsptr244 to { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}*

; malloc environment structure
%envptr246 = call i8* @llvm_zone_malloc(%mzone* %zone243, i64 8)
%environment247 = bitcast i8* %envptr246 to {{i8*, i8*, void (i8*, i8*, %NVGcolor*)*}***}*

; malloc closure address table
%addytable248 = call %clsvar* @new_address_table()
%var249 = bitcast [35 x i8]* @gsxtmnanovg13 to i8*
%var250 = bitcast [43 x i8]* @gsxtmnanovg14 to i8*
%addytable251 = call %clsvar* @add_address_table(%mzone* %zone243, i8* %var249, i32 0, i8* %var250, i32 3, %clsvar* %addytable248)
%address-table252 = bitcast %clsvar* %addytable251 to i8*

; insert table, function and environment into closure struct
%closure.table255 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure245, i32 0, i32 0
store i8* %address-table252, i8** %closure.table255
%closure.env256 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure245, i32 0, i32 1
store i8* %envptr246, i8** %closure.env256
%closure.func257 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure245, i32 0, i32 2
store void (i8*, i8*, %NVGcolor*)* @hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ__236, void (i8*, i8*, %NVGcolor*)** %closure.func257
%closure_size258 = call i64 @llvm_zone_mark_size(%mzone* %zone243)
call void @llvm_zone_ptr_set_size(i8* %clsptr244, i64 %closure_size258)
%wrapper_ptr259 = call i8* @llvm_zone_malloc(%mzone* %zone243, i64 8)
%closure_wrapper260 = bitcast i8* %wrapper_ptr259 to { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}**
store { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure245, { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** %closure_wrapper260

; let value assignment
%hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** %closure_wrapper260, { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** %closure_wrapper260
store { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** %hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ, { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}*** %hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ
%tmp_envptr254 = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGcolor*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGcolor*)*}***}* %environment247, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}*** %hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQPtr, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}**** %tmp_envptr254


%val263 = load {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}**, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}*** %hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQPtr
ret {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** %val263
}


@hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** @hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ(%NVGcolor* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}*, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGcolor*)*,  void (i8*, i8*, %NVGcolor*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGcolor* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_native(%NVGcolor* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}*, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGcolor*)*,  void (i8*, i8*, %NVGcolor*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGcolor* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var264 = bitcast [88 x i8]* @gsxtmnanovg15 to i8*
call i32 (i8*, ...) @printf(i8* %var264)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGcolor*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}*, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGcolor*)*,  void (i8*, i8*, %NVGcolor*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGcolor* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGcolor*}*
%arg_p_0 = getelementptr {%NVGcolor*}, {%NVGcolor*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGcolor*, %NVGcolor** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}*, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGcolor*)*,  void (i8*, i8*, %NVGcolor*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGcolor* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg16 = hidden constant [60 x i8] c"zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0\00"
@gsxtmnanovg17 = hidden constant [67 x i8] c"{i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %NVGcolor* @zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0__265(i8* %_impz,i8* %_impenv, %NVGcolor* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone266 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0Ptr_ = getelementptr {{i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0Ptr = load {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}***, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0Ptr_

; setup arguments
%xPtr = alloca %NVGcolor*
store %NVGcolor* %x, %NVGcolor** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val268 = load %mzone*, %mzone** %fromzPtr
%val269 = load %NVGcolor*, %NVGcolor** %xPtr
%val270 = bitcast %NVGcolor* %val269 to i8*
%res271 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val268, i8* %val270)
br i1 %res271, label %then267, label %else267

then267:
%val272 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val272)
%zone_ptr273 = bitcast %mzone* %val272 to i8*
store i8* %zone_ptr273, i8** %_impzPtr
%tzone279 = load i8*, i8** %_impzPtr
%zone280 = bitcast i8* %tzone279 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGcolor*
%tzone275 = load i8*, i8** %_impzPtr
%zone276 = bitcast i8* %tzone275 to %mzone*
%dat277 = call i8* @llvm_zone_malloc(%mzone* %zone276, i64 16)
call i8* @memset(i8* %dat277, i32 0, i64 16)
%val278 = bitcast i8* %dat277 to %NVGcolor*

; let value assignment
%obj = select i1 true, %NVGcolor* %val278, %NVGcolor* %val278
store %NVGcolor* %obj, %NVGcolor** %objPtr

%val281 = load %NVGcolor*, %NVGcolor** %objPtr
%val282 = load %NVGcolor*, %NVGcolor** %xPtr
; tuple ref
%val283 = getelementptr %NVGcolor, %NVGcolor* %val282, i64 0, i32 0
%val284 = load float, float* %val283
; set tuple
%val285 = getelementptr %NVGcolor, %NVGcolor* %val281, i64 0, i32 0
store float %val284, float* %val285
%val286 = load %NVGcolor*, %NVGcolor** %objPtr
%val287 = load %NVGcolor*, %NVGcolor** %xPtr
; tuple ref
%val288 = getelementptr %NVGcolor, %NVGcolor* %val287, i64 0, i32 1
%val289 = load float, float* %val288
; set tuple
%val290 = getelementptr %NVGcolor, %NVGcolor* %val286, i64 0, i32 1
store float %val289, float* %val290
%val291 = load %NVGcolor*, %NVGcolor** %objPtr
%val292 = load %NVGcolor*, %NVGcolor** %xPtr
; tuple ref
%val293 = getelementptr %NVGcolor, %NVGcolor* %val292, i64 0, i32 2
%val294 = load float, float* %val293
; set tuple
%val295 = getelementptr %NVGcolor, %NVGcolor* %val291, i64 0, i32 2
store float %val294, float* %val295
%val296 = load %NVGcolor*, %NVGcolor** %objPtr
%val297 = load %NVGcolor*, %NVGcolor** %xPtr
; tuple ref
%val298 = getelementptr %NVGcolor, %NVGcolor* %val297, i64 0, i32 3
%val299 = load float, float* %val298
; set tuple
%val300 = getelementptr %NVGcolor, %NVGcolor* %val296, i64 0, i32 3
store float %val299, float* %val300
%oldzone301 = call %mzone* @llvm_pop_zone_stack()
%newzone302 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr303 = bitcast %mzone* %newzone302 to i8*
store i8* %zone_ptr303, i8** %_impzPtr
%val304 = load %NVGcolor*, %NVGcolor** %objPtr
ret %NVGcolor* %val304

else267:
%val305 = load %NVGcolor*, %NVGcolor** %xPtr
ret %NVGcolor* %val305
}
@gsxtmnanovg18 = hidden constant [113 x i8] c"zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}** @zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone325 = load i8*, i8** %_impzPtr
%zone326 = bitcast i8* %tzone325 to %mzone*

; let assign value to symbol zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0
%dat_zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone326, i64 8)
%zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0Ptr = bitcast i8* %dat_zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0 to { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}***
%tzone306 = load i8*, i8** %_impzPtr
%zone307 = bitcast i8* %tzone306 to %mzone*
call void @llvm_zone_mark(%mzone* %zone307)
; malloc closure structure
%clsptr308 = call i8* @llvm_zone_malloc(%mzone* %zone307, i64 24)
%closure309 = bitcast i8* %clsptr308 to { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr310 = call i8* @llvm_zone_malloc(%mzone* %zone307, i64 8)
%environment311 = bitcast i8* %envptr310 to {{i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable312 = call %clsvar* @new_address_table()
%var313 = bitcast [60 x i8]* @gsxtmnanovg16 to i8*
%var314 = bitcast [67 x i8]* @gsxtmnanovg17 to i8*
%addytable315 = call %clsvar* @add_address_table(%mzone* %zone307, i8* %var313, i32 0, i8* %var314, i32 3, %clsvar* %addytable312)
%address-table316 = bitcast %clsvar* %addytable315 to i8*

; insert table, function and environment into closure struct
%closure.table319 = getelementptr { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}* %closure309, i32 0, i32 0
store i8* %address-table316, i8** %closure.table319
%closure.env320 = getelementptr { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}* %closure309, i32 0, i32 1
store i8* %envptr310, i8** %closure.env320
%closure.func321 = getelementptr { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}* %closure309, i32 0, i32 2
store %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)* @zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0__265, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)** %closure.func321
%closure_size322 = call i64 @llvm_zone_mark_size(%mzone* %zone307)
call void @llvm_zone_ptr_set_size(i8* %clsptr308, i64 %closure_size322)
%wrapper_ptr323 = call i8* @llvm_zone_malloc(%mzone* %zone307, i64 8)
%closure_wrapper324 = bitcast i8* %wrapper_ptr323 to { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}**
store { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}* %closure309, { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}** %closure_wrapper324

; let value assignment
%zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0 = select i1 true, { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}** %closure_wrapper324, { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}** %closure_wrapper324
store { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}** %zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0, { i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0Ptr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0
%tmp_envptr318 = getelementptr {{i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}***}* %environment311, i32 0, i32 0
store {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0Ptr, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}**** %tmp_envptr318


%val327 = load {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}**, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0Ptr
ret {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}** %val327
}


@zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}** @zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGcolor* @zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0(%NVGcolor* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*,  %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, %NVGcolor* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %NVGcolor* %result
}


define dllexport ccc %NVGcolor* @zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0_native(%NVGcolor* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*,  %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, %NVGcolor* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %NVGcolor* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var328 = bitcast [113 x i8]* @gsxtmnanovg18 to i8*
call i32 (i8*, ...) @printf(i8* %var328)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGcolor*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var329 = bitcast [113 x i8]* @gsxtmnanovg18 to i8*
call i32 (i8*, ...) @printf(i8* %var329)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var330 = bitcast [113 x i8]* @gsxtmnanovg18 to i8*
call i32 (i8*, ...) @printf(i8* %var330)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*,  %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, %NVGcolor* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %NVGcolor* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGcolor*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%NVGcolor*, %mzone*, %mzone*}, {%NVGcolor*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGcolor*, %NVGcolor** %arg_p_0
%arg_p_1 = getelementptr {%NVGcolor*, %mzone*, %mzone*}, {%NVGcolor*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%NVGcolor*, %mzone*, %mzone*}, {%NVGcolor*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR2NvbG9yKixOVkdjb2xvciosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)*,  %NVGcolor* (i8*, i8*, %NVGcolor*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, %NVGcolor* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg19 = hidden constant [43 x i8] c"<NVGcolor: r=%.3f, g=%.3f, b=%.3f, a=%.3f>\00"
@gsxtmnanovg20 = hidden constant [35 x i8] c"print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ__331(i8* %_impz,i8* %_impenv, %NVGcolor* %color) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone332 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %NVGcolor*)*}***}*
%print_adhoc_W3ZvaWQsTlZHY29sb3IqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGcolor*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGcolor*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsTlZHY29sb3IqXQPtr = load {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}***, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}**** %print_adhoc_W3ZvaWQsTlZHY29sb3IqXQPtr_

; setup arguments
%colorPtr = alloca %NVGcolor*
store %NVGcolor* %color, %NVGcolor** %colorPtr


%var333 = bitcast [43 x i8]* @gsxtmnanovg19 to i8*
%val334 = load %NVGcolor*, %NVGcolor** %colorPtr
; tuple ref
%val335 = getelementptr %NVGcolor, %NVGcolor* %val334, i64 0, i32 0
%val336 = load float, float* %val335
%val337 = fpext float %val336 to double
%val338 = load %NVGcolor*, %NVGcolor** %colorPtr
; tuple ref
%val339 = getelementptr %NVGcolor, %NVGcolor* %val338, i64 0, i32 1
%val340 = load float, float* %val339
%val341 = fpext float %val340 to double
%val342 = load %NVGcolor*, %NVGcolor** %colorPtr
; tuple ref
%val343 = getelementptr %NVGcolor, %NVGcolor* %val342, i64 0, i32 2
%val344 = load float, float* %val343
%val345 = fpext float %val344 to double
%val346 = load %NVGcolor*, %NVGcolor** %colorPtr
; tuple ref
%val347 = getelementptr %NVGcolor, %NVGcolor* %val346, i64 0, i32 3
%val348 = load float, float* %val347
%val349 = fpext float %val348 to double

%val350 = call i32 (i8*, ...) @printf(i8* %var333, double %val337, double %val341, double %val345, double %val349)
ret void
}
@gsxtmnanovg21 = hidden constant [88 x i8] c"print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** @print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone371 = load i8*, i8** %_impzPtr
%zone372 = bitcast i8* %tzone371 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ
%dat_print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ = call i8* @llvm_zone_malloc(%mzone* %zone372, i64 8)
%print_adhoc_W3ZvaWQsTlZHY29sb3IqXQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ to { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}***
%tzone352 = load i8*, i8** %_impzPtr
%zone353 = bitcast i8* %tzone352 to %mzone*
call void @llvm_zone_mark(%mzone* %zone353)
; malloc closure structure
%clsptr354 = call i8* @llvm_zone_malloc(%mzone* %zone353, i64 24)
%closure355 = bitcast i8* %clsptr354 to { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}*

; malloc environment structure
%envptr356 = call i8* @llvm_zone_malloc(%mzone* %zone353, i64 8)
%environment357 = bitcast i8* %envptr356 to {{i8*, i8*, void (i8*, i8*, %NVGcolor*)*}***}*

; malloc closure address table
%addytable358 = call %clsvar* @new_address_table()
%var359 = bitcast [35 x i8]* @gsxtmnanovg20 to i8*
%var360 = bitcast [43 x i8]* @gsxtmnanovg14 to i8*
%addytable361 = call %clsvar* @add_address_table(%mzone* %zone353, i8* %var359, i32 0, i8* %var360, i32 3, %clsvar* %addytable358)
%address-table362 = bitcast %clsvar* %addytable361 to i8*

; insert table, function and environment into closure struct
%closure.table365 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure355, i32 0, i32 0
store i8* %address-table362, i8** %closure.table365
%closure.env366 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure355, i32 0, i32 1
store i8* %envptr356, i8** %closure.env366
%closure.func367 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure355, i32 0, i32 2
store void (i8*, i8*, %NVGcolor*)* @print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ__331, void (i8*, i8*, %NVGcolor*)** %closure.func367
%closure_size368 = call i64 @llvm_zone_mark_size(%mzone* %zone353)
call void @llvm_zone_ptr_set_size(i8* %clsptr354, i64 %closure_size368)
%wrapper_ptr369 = call i8* @llvm_zone_malloc(%mzone* %zone353, i64 8)
%closure_wrapper370 = bitcast i8* %wrapper_ptr369 to { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}**
store { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure355, { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** %closure_wrapper370

; let value assignment
%print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** %closure_wrapper370, { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** %closure_wrapper370
store { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** %print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ, { i8*, i8*, void (i8*, i8*, %NVGcolor*)*}*** %print_adhoc_W3ZvaWQsTlZHY29sb3IqXQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ
%tmp_envptr364 = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGcolor*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGcolor*)*}***}* %environment357, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}*** %print_adhoc_W3ZvaWQsTlZHY29sb3IqXQPtr, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}**** %tmp_envptr364


%val373 = load {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}**, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}*** %print_adhoc_W3ZvaWQsTlZHY29sb3IqXQPtr
ret {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** %val373
}


@print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** @print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ(%NVGcolor* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}*, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGcolor*)*,  void (i8*, i8*, %NVGcolor*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGcolor* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_native(%NVGcolor* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}*, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGcolor*)*,  void (i8*, i8*, %NVGcolor*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGcolor* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var374 = bitcast [88 x i8]* @gsxtmnanovg21 to i8*
call i32 (i8*, ...) @printf(i8* %var374)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGcolor*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}*, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGcolor*)*,  void (i8*, i8*, %NVGcolor*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGcolor* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGcolor*}*
%arg_p_0 = getelementptr {%NVGcolor*}, {%NVGcolor*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGcolor*, %NVGcolor** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHY29sb3IqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}*, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}, {i8*, i8*, void (i8*, i8*, %NVGcolor*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGcolor*)*,  void (i8*, i8*, %NVGcolor*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGcolor* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg22 = hidden constant [40 x i8] c"NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd\00"
@gsxtmnanovg23 = hidden constant [42 x i8] c"{i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}**\00"
define dllexport fastcc %NVGcolor* @NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd__375(i8* %_impz,i8* %_impenv, i64 %hex_value) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone376 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}***}*
%NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRdPtr_ = getelementptr {{i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}***}, {{i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}***}* %impenv, i32 0, i32 0
%NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRdPtr = load {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}***, {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}**** %NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRdPtr_

; setup arguments
%hex_valuePtr = alloca i64
store i64 %hex_value, i64* %hex_valuePtr


%val377 = load i64, i64* %hex_valuePtr
%val378 = and i64 %val377, -16777216
%val379 = mul i64 4, 6
%val380 = lshr i64 %val378, %val379
%val381 = sitofp i64 %val380 to float
%val382 = sitofp i64 255 to float
%val383 = fdiv float %val381, %val382
%val384 = load i64, i64* %hex_valuePtr
%val385 = and i64 %val384, 16711680
%val386 = mul i64 4, 4
%val387 = lshr i64 %val385, %val386
%val388 = sitofp i64 %val387 to float
%val389 = sitofp i64 255 to float
%val390 = fdiv float %val388, %val389
%val391 = load i64, i64* %hex_valuePtr
%val392 = and i64 %val391, 65280
%val393 = mul i64 4, 2
%val394 = lshr i64 %val392, %val393
%val395 = sitofp i64 %val394 to float
%val396 = sitofp i64 255 to float
%val397 = fdiv float %val395, %val396
%val398 = load i64, i64* %hex_valuePtr
%val399 = and i64 %val398, 255
%val400 = sitofp i64 %val399 to float
%val401 = sitofp i64 255 to float
%val402 = fdiv float %val400, %val401
%res403 = call fastcc %NVGcolor* @NVGcolor_adhoc_W05WR2NvbG9yKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0(float %val383, float %val390, float %val397, float %val402)
ret %NVGcolor* %res403
}
@gsxtmnanovg24 = hidden constant [93 x i8] c"NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}** @NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone423 = load i8*, i8** %_impzPtr
%zone424 = bitcast i8* %tzone423 to %mzone*

; let assign value to symbol NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd
%dat_NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone424, i64 8)
%NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRdPtr = bitcast i8* %dat_NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd to { i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}***
%tzone404 = load i8*, i8** %_impzPtr
%zone405 = bitcast i8* %tzone404 to %mzone*
call void @llvm_zone_mark(%mzone* %zone405)
; malloc closure structure
%clsptr406 = call i8* @llvm_zone_malloc(%mzone* %zone405, i64 24)
%closure407 = bitcast i8* %clsptr406 to { i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}*

; malloc environment structure
%envptr408 = call i8* @llvm_zone_malloc(%mzone* %zone405, i64 8)
%environment409 = bitcast i8* %envptr408 to {{i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}***}*

; malloc closure address table
%addytable410 = call %clsvar* @new_address_table()
%var411 = bitcast [40 x i8]* @gsxtmnanovg22 to i8*
%var412 = bitcast [42 x i8]* @gsxtmnanovg23 to i8*
%addytable413 = call %clsvar* @add_address_table(%mzone* %zone405, i8* %var411, i32 0, i8* %var412, i32 3, %clsvar* %addytable410)
%address-table414 = bitcast %clsvar* %addytable413 to i8*

; insert table, function and environment into closure struct
%closure.table417 = getelementptr { i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}, { i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}* %closure407, i32 0, i32 0
store i8* %address-table414, i8** %closure.table417
%closure.env418 = getelementptr { i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}, { i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}* %closure407, i32 0, i32 1
store i8* %envptr408, i8** %closure.env418
%closure.func419 = getelementptr { i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}, { i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}* %closure407, i32 0, i32 2
store %NVGcolor* (i8*, i8*, i64)* @NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd__375, %NVGcolor* (i8*, i8*, i64)** %closure.func419
%closure_size420 = call i64 @llvm_zone_mark_size(%mzone* %zone405)
call void @llvm_zone_ptr_set_size(i8* %clsptr406, i64 %closure_size420)
%wrapper_ptr421 = call i8* @llvm_zone_malloc(%mzone* %zone405, i64 8)
%closure_wrapper422 = bitcast i8* %wrapper_ptr421 to { i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}**
store { i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}* %closure407, { i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}** %closure_wrapper422

; let value assignment
%NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd = select i1 true, { i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}** %closure_wrapper422, { i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}** %closure_wrapper422
store { i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}** %NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd, { i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}*** %NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRdPtr

; add data to environment
; don't need to alloc for env var NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd
%tmp_envptr416 = getelementptr {{i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}***}, {{i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}***}* %environment409, i32 0, i32 0
store {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}*** %NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRdPtr, {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}**** %tmp_envptr416


%val425 = load {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}**, {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}*** %NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRdPtr
ret {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}** %val425
}


@NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}** @NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGcolor* @NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd(i64 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, i64)*,  %NVGcolor* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
ret %NVGcolor* %result
}


define dllexport ccc %NVGcolor* @NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd_native(i64 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, i64)*,  %NVGcolor* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
ret %NVGcolor* %result
}


define dllexport ccc i8*  @NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var426 = bitcast [93 x i8]* @gsxtmnanovg24 to i8*
call i32 (i8*, ...) @printf(i8* %var426)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, i64)*,  %NVGcolor* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
%tmpres = bitcast %NVGcolor* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64}*
%arg_p_0 = getelementptr {i64}, {i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcolor_hex_adhoc_W05WR2NvbG9yKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}*, {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}, {i8*, i8*, %NVGcolor* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %NVGcolor* (i8*, i8*, i64)*,  %NVGcolor* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcolor* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%NVGpaint = type {[6 x float],[2 x float],float,float,%NVGcolor,%NVGcolor,i32}
@gsxtmnanovg25 = hidden constant [103 x i8] c"NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0\00"
@gsxtmnanovg26 = hidden constant [104 x i8] c"{i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**\00"
define dllexport fastcc %NVGpaint* @NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0__427(i8* %_impz,i8* %_impenv, [6 x float] %arg_0, [2 x float] %arg_1, float %arg_2, float %arg_3, %NVGcolor %arg_4, %NVGcolor %arg_5, i32 %arg_6) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone428 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}*
%NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}, {{i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}* %impenv, i32 0, i32 0
%NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0Ptr = load {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**** %NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca [6 x float]
store [6 x float] %arg_0, [6 x float]* %arg_0Ptr
%arg_1Ptr = alloca [2 x float]
store [2 x float] %arg_1, [2 x float]* %arg_1Ptr
%arg_2Ptr = alloca float
store float %arg_2, float* %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr
%arg_4Ptr = alloca %NVGcolor
store %NVGcolor %arg_4, %NVGcolor* %arg_4Ptr
%arg_5Ptr = alloca %NVGcolor
store %NVGcolor %arg_5, %NVGcolor* %arg_5Ptr
%arg_6Ptr = alloca i32
store i32 %arg_6, i32* %arg_6Ptr


%tzone433 = load i8*, i8** %_impzPtr
%zone434 = bitcast i8* %tzone433 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGpaint*
%tzone429 = load i8*, i8** %_impzPtr
%zone430 = bitcast i8* %tzone429 to %mzone*
%dat431 = call i8* @llvm_zone_malloc(%mzone* %zone430, i64 76)
call i8* @memset(i8* %dat431, i32 0, i64 76)
%val432 = bitcast i8* %dat431 to %NVGpaint*

; let value assignment
%obj = select i1 true, %NVGpaint* %val432, %NVGpaint* %val432
store %NVGpaint* %obj, %NVGpaint** %objPtr

%val435 = load %NVGpaint*, %NVGpaint** %objPtr
%val436 = load [6 x float], [6 x float]* %arg_0Ptr
; set tuple
%val437 = getelementptr %NVGpaint, %NVGpaint* %val435, i64 0, i32 0
store [6 x float] %val436, [6 x float]* %val437
%val438 = load %NVGpaint*, %NVGpaint** %objPtr
%val439 = load [2 x float], [2 x float]* %arg_1Ptr
; set tuple
%val440 = getelementptr %NVGpaint, %NVGpaint* %val438, i64 0, i32 1
store [2 x float] %val439, [2 x float]* %val440
%val441 = load %NVGpaint*, %NVGpaint** %objPtr
%val442 = load float, float* %arg_2Ptr
; set tuple
%val443 = getelementptr %NVGpaint, %NVGpaint* %val441, i64 0, i32 2
store float %val442, float* %val443
%val444 = load %NVGpaint*, %NVGpaint** %objPtr
%val445 = load float, float* %arg_3Ptr
; set tuple
%val446 = getelementptr %NVGpaint, %NVGpaint* %val444, i64 0, i32 3
store float %val445, float* %val446
%val447 = load %NVGpaint*, %NVGpaint** %objPtr
%val448 = load %NVGcolor, %NVGcolor* %arg_4Ptr
; set tuple
%val449 = getelementptr %NVGpaint, %NVGpaint* %val447, i64 0, i32 4
store %NVGcolor %val448, %NVGcolor* %val449
%val450 = load %NVGpaint*, %NVGpaint** %objPtr
%val451 = load %NVGcolor, %NVGcolor* %arg_5Ptr
; set tuple
%val452 = getelementptr %NVGpaint, %NVGpaint* %val450, i64 0, i32 5
store %NVGcolor %val451, %NVGcolor* %val452
%val453 = load %NVGpaint*, %NVGpaint** %objPtr
%val454 = load i32, i32* %arg_6Ptr
; set tuple
%val455 = getelementptr %NVGpaint, %NVGpaint* %val453, i64 0, i32 6
store i32 %val454, i32* %val455
%val456 = load %NVGpaint*, %NVGpaint** %objPtr
ret %NVGpaint* %val456
}
@gsxtmnanovg27 = hidden constant [156 x i8] c"NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** @NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone476 = load i8*, i8** %_impzPtr
%zone477 = bitcast i8* %tzone476 to %mzone*

; let assign value to symbol NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0
%dat_NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone477, i64 8)
%NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0Ptr = bitcast i8* %dat_NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0 to { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***
%tzone457 = load i8*, i8** %_impzPtr
%zone458 = bitcast i8* %tzone457 to %mzone*
call void @llvm_zone_mark(%mzone* %zone458)
; malloc closure structure
%clsptr459 = call i8* @llvm_zone_malloc(%mzone* %zone458, i64 24)
%closure460 = bitcast i8* %clsptr459 to { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*

; malloc environment structure
%envptr461 = call i8* @llvm_zone_malloc(%mzone* %zone458, i64 8)
%environment462 = bitcast i8* %envptr461 to {{i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}*

; malloc closure address table
%addytable463 = call %clsvar* @new_address_table()
%var464 = bitcast [103 x i8]* @gsxtmnanovg25 to i8*
%var465 = bitcast [104 x i8]* @gsxtmnanovg26 to i8*
%addytable466 = call %clsvar* @add_address_table(%mzone* %zone458, i8* %var464, i32 0, i8* %var465, i32 3, %clsvar* %addytable463)
%address-table467 = bitcast %clsvar* %addytable466 to i8*

; insert table, function and environment into closure struct
%closure.table470 = getelementptr { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure460, i32 0, i32 0
store i8* %address-table467, i8** %closure.table470
%closure.env471 = getelementptr { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure460, i32 0, i32 1
store i8* %envptr461, i8** %closure.env471
%closure.func472 = getelementptr { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure460, i32 0, i32 2
store %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)* @NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0__427, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)** %closure.func472
%closure_size473 = call i64 @llvm_zone_mark_size(%mzone* %zone458)
call void @llvm_zone_ptr_set_size(i8* %clsptr459, i64 %closure_size473)
%wrapper_ptr474 = call i8* @llvm_zone_malloc(%mzone* %zone458, i64 8)
%closure_wrapper475 = bitcast i8* %wrapper_ptr474 to { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**
store { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure460, { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_wrapper475

; let value assignment
%NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0 = select i1 true, { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_wrapper475, { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_wrapper475
store { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0, { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*** %NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0
%tmp_envptr469 = getelementptr {{i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}, {{i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}* %environment462, i32 0, i32 0
store {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*** %NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0Ptr, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**** %tmp_envptr469


%val478 = load {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*** %NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0Ptr
ret {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %val478
}


@NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** @NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGpaint* @NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0([6 x float] %arg_0,[2 x float] %arg_1,float %arg_2,float %arg_3,%NVGcolor %arg_4,%NVGcolor %arg_5,i32 %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**
%closure = load {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*,  %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpaint* %ff(i8* %_impz, i8* %ee, [6 x float] %arg_0, [2 x float] %arg_1, float %arg_2, float %arg_3, %NVGcolor %arg_4, %NVGcolor %arg_5, i32 %arg_6)
ret %NVGpaint* %result
}


define dllexport ccc %NVGpaint* @NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_native([6 x float] %arg_0,[2 x float] %arg_1,float %arg_2,float %arg_3,%NVGcolor %arg_4,%NVGcolor %arg_5,i32 %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**
%closure = load {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*,  %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpaint* %ff(i8* %_impz, i8* %ee, [6 x float] %arg_0, [2 x float] %arg_1, float %arg_2, float %arg_3, %NVGcolor %arg_4, %NVGcolor %arg_5, i32 %arg_6)
ret %NVGpaint* %result
}


define dllexport ccc void @NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}*
%arg_p_0 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 0
%arg_0 = load [6 x float], [6 x float]* %arg_p_0
%arg_p_1 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 1
%arg_1 = load [2 x float], [2 x float]* %arg_p_1
%arg_p_2 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 4
%arg_4 = load %NVGcolor, %NVGcolor* %arg_p_4
%arg_p_5 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 5
%arg_5 = load %NVGcolor, %NVGcolor* %arg_p_5
%arg_p_6 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 6
%arg_6 = load i32, i32* %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpaint_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**
%closure = load {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*,  %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpaint* %ff(i8* %_impz, i8* %ee, [6 x float] %arg_0, [2 x float] %arg_1, float %arg_2, float %arg_3, %NVGcolor %arg_4, %NVGcolor %arg_5, i32 %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg28 = hidden constant [105 x i8] c"NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0\00"
define dllexport fastcc %NVGpaint* @NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0__482(i8* %_impz,i8* %_impenv, [6 x float] %arg_0, [2 x float] %arg_1, float %arg_2, float %arg_3, %NVGcolor %arg_4, %NVGcolor %arg_5, i32 %arg_6) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone483 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}*
%NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}, {{i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}* %impenv, i32 0, i32 0
%NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0Ptr = load {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**** %NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca [6 x float]
store [6 x float] %arg_0, [6 x float]* %arg_0Ptr
%arg_1Ptr = alloca [2 x float]
store [2 x float] %arg_1, [2 x float]* %arg_1Ptr
%arg_2Ptr = alloca float
store float %arg_2, float* %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr
%arg_4Ptr = alloca %NVGcolor
store %NVGcolor %arg_4, %NVGcolor* %arg_4Ptr
%arg_5Ptr = alloca %NVGcolor
store %NVGcolor %arg_5, %NVGcolor* %arg_5Ptr
%arg_6Ptr = alloca i32
store i32 %arg_6, i32* %arg_6Ptr


%tzone488 = load i8*, i8** %_impzPtr
%zone489 = bitcast i8* %tzone488 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGpaint*
%tzone484 = load i8*, i8** %_impzPtr
%zone485 = bitcast i8* %tzone484 to %mzone*
%dat486 = call i8* @llvm_zone_malloc(%mzone* %zone485, i64 76)
call i8* @memset(i8* %dat486, i32 0, i64 76)
%val487 = bitcast i8* %dat486 to %NVGpaint*

; let value assignment
%obj = select i1 true, %NVGpaint* %val487, %NVGpaint* %val487
store %NVGpaint* %obj, %NVGpaint** %objPtr

%val490 = load %NVGpaint*, %NVGpaint** %objPtr
%val491 = load [6 x float], [6 x float]* %arg_0Ptr
; set tuple
%val492 = getelementptr %NVGpaint, %NVGpaint* %val490, i64 0, i32 0
store [6 x float] %val491, [6 x float]* %val492
%val493 = load %NVGpaint*, %NVGpaint** %objPtr
%val494 = load [2 x float], [2 x float]* %arg_1Ptr
; set tuple
%val495 = getelementptr %NVGpaint, %NVGpaint* %val493, i64 0, i32 1
store [2 x float] %val494, [2 x float]* %val495
%val496 = load %NVGpaint*, %NVGpaint** %objPtr
%val497 = load float, float* %arg_2Ptr
; set tuple
%val498 = getelementptr %NVGpaint, %NVGpaint* %val496, i64 0, i32 2
store float %val497, float* %val498
%val499 = load %NVGpaint*, %NVGpaint** %objPtr
%val500 = load float, float* %arg_3Ptr
; set tuple
%val501 = getelementptr %NVGpaint, %NVGpaint* %val499, i64 0, i32 3
store float %val500, float* %val501
%val502 = load %NVGpaint*, %NVGpaint** %objPtr
%val503 = load %NVGcolor, %NVGcolor* %arg_4Ptr
; set tuple
%val504 = getelementptr %NVGpaint, %NVGpaint* %val502, i64 0, i32 4
store %NVGcolor %val503, %NVGcolor* %val504
%val505 = load %NVGpaint*, %NVGpaint** %objPtr
%val506 = load %NVGcolor, %NVGcolor* %arg_5Ptr
; set tuple
%val507 = getelementptr %NVGpaint, %NVGpaint* %val505, i64 0, i32 5
store %NVGcolor %val506, %NVGcolor* %val507
%val508 = load %NVGpaint*, %NVGpaint** %objPtr
%val509 = load i32, i32* %arg_6Ptr
; set tuple
%val510 = getelementptr %NVGpaint, %NVGpaint* %val508, i64 0, i32 6
store i32 %val509, i32* %val510
%val511 = load %NVGpaint*, %NVGpaint** %objPtr
ret %NVGpaint* %val511
}
@gsxtmnanovg29 = hidden constant [158 x i8] c"NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** @NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone531 = load i8*, i8** %_impzPtr
%zone532 = bitcast i8* %tzone531 to %mzone*

; let assign value to symbol NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0
%dat_NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone532, i64 8)
%NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0Ptr = bitcast i8* %dat_NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0 to { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***
%tzone512 = load i8*, i8** %_impzPtr
%zone513 = bitcast i8* %tzone512 to %mzone*
call void @llvm_zone_mark(%mzone* %zone513)
; malloc closure structure
%clsptr514 = call i8* @llvm_zone_malloc(%mzone* %zone513, i64 24)
%closure515 = bitcast i8* %clsptr514 to { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*

; malloc environment structure
%envptr516 = call i8* @llvm_zone_malloc(%mzone* %zone513, i64 8)
%environment517 = bitcast i8* %envptr516 to {{i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}*

; malloc closure address table
%addytable518 = call %clsvar* @new_address_table()
%var519 = bitcast [105 x i8]* @gsxtmnanovg28 to i8*
%var520 = bitcast [104 x i8]* @gsxtmnanovg26 to i8*
%addytable521 = call %clsvar* @add_address_table(%mzone* %zone513, i8* %var519, i32 0, i8* %var520, i32 3, %clsvar* %addytable518)
%address-table522 = bitcast %clsvar* %addytable521 to i8*

; insert table, function and environment into closure struct
%closure.table525 = getelementptr { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure515, i32 0, i32 0
store i8* %address-table522, i8** %closure.table525
%closure.env526 = getelementptr { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure515, i32 0, i32 1
store i8* %envptr516, i8** %closure.env526
%closure.func527 = getelementptr { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure515, i32 0, i32 2
store %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)* @NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0__482, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)** %closure.func527
%closure_size528 = call i64 @llvm_zone_mark_size(%mzone* %zone513)
call void @llvm_zone_ptr_set_size(i8* %clsptr514, i64 %closure_size528)
%wrapper_ptr529 = call i8* @llvm_zone_malloc(%mzone* %zone513, i64 8)
%closure_wrapper530 = bitcast i8* %wrapper_ptr529 to { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**
store { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure515, { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_wrapper530

; let value assignment
%NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0 = select i1 true, { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_wrapper530, { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_wrapper530
store { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0, { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*** %NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0
%tmp_envptr524 = getelementptr {{i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}, {{i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}* %environment517, i32 0, i32 0
store {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*** %NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0Ptr, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**** %tmp_envptr524


%val533 = load {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*** %NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0Ptr
ret {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %val533
}


@NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** @NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGpaint* @NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0([6 x float] %arg_0,[2 x float] %arg_1,float %arg_2,float %arg_3,%NVGcolor %arg_4,%NVGcolor %arg_5,i32 %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**
%closure = load {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*,  %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpaint* %ff(i8* %_impz, i8* %ee, [6 x float] %arg_0, [2 x float] %arg_1, float %arg_2, float %arg_3, %NVGcolor %arg_4, %NVGcolor %arg_5, i32 %arg_6)
ret %NVGpaint* %result
}


define dllexport ccc %NVGpaint* @NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_native([6 x float] %arg_0,[2 x float] %arg_1,float %arg_2,float %arg_3,%NVGcolor %arg_4,%NVGcolor %arg_5,i32 %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**
%closure = load {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*,  %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpaint* %ff(i8* %_impz, i8* %ee, [6 x float] %arg_0, [2 x float] %arg_1, float %arg_2, float %arg_3, %NVGcolor %arg_4, %NVGcolor %arg_5, i32 %arg_6)
ret %NVGpaint* %result
}


define dllexport ccc void @NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}*
%arg_p_0 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 0
%arg_0 = load [6 x float], [6 x float]* %arg_p_0
%arg_p_1 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 1
%arg_1 = load [2 x float], [2 x float]* %arg_p_1
%arg_p_2 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 4
%arg_4 = load %NVGcolor, %NVGcolor* %arg_p_4
%arg_p_5 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 5
%arg_5 = load %NVGcolor, %NVGcolor* %arg_p_5
%arg_p_6 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 6
%arg_6 = load i32, i32* %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpaint_z_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**
%closure = load {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*,  %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpaint* %ff(i8* %_impz, i8* %ee, [6 x float] %arg_0, [2 x float] %arg_1, float %arg_2, float %arg_3, %NVGcolor %arg_4, %NVGcolor %arg_5, i32 %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg30 = hidden constant [105 x i8] c"NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0\00"
define dllexport fastcc %NVGpaint* @NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0__537(i8* %_impz,i8* %_impenv, [6 x float] %arg_0, [2 x float] %arg_1, float %arg_2, float %arg_3, %NVGcolor %arg_4, %NVGcolor %arg_5, i32 %arg_6) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone538 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}*
%NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}, {{i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}* %impenv, i32 0, i32 0
%NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0Ptr = load {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**** %NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca [6 x float]
store [6 x float] %arg_0, [6 x float]* %arg_0Ptr
%arg_1Ptr = alloca [2 x float]
store [2 x float] %arg_1, [2 x float]* %arg_1Ptr
%arg_2Ptr = alloca float
store float %arg_2, float* %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr
%arg_4Ptr = alloca %NVGcolor
store %NVGcolor %arg_4, %NVGcolor* %arg_4Ptr
%arg_5Ptr = alloca %NVGcolor
store %NVGcolor %arg_5, %NVGcolor* %arg_5Ptr
%arg_6Ptr = alloca i32
store i32 %arg_6, i32* %arg_6Ptr


%tzone541 = load i8*, i8** %_impzPtr
%zone542 = bitcast i8* %tzone541 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGpaint*
%dat539 = call i8* @malloc(i64 76)
call i8* @memset(i8* %dat539, i32 0, i64 76)
%val540 = bitcast i8* %dat539 to %NVGpaint*

; let value assignment
%obj = select i1 true, %NVGpaint* %val540, %NVGpaint* %val540
store %NVGpaint* %obj, %NVGpaint** %objPtr

%val543 = load %NVGpaint*, %NVGpaint** %objPtr
%val544 = load [6 x float], [6 x float]* %arg_0Ptr
; set tuple
%val545 = getelementptr %NVGpaint, %NVGpaint* %val543, i64 0, i32 0
store [6 x float] %val544, [6 x float]* %val545
%val546 = load %NVGpaint*, %NVGpaint** %objPtr
%val547 = load [2 x float], [2 x float]* %arg_1Ptr
; set tuple
%val548 = getelementptr %NVGpaint, %NVGpaint* %val546, i64 0, i32 1
store [2 x float] %val547, [2 x float]* %val548
%val549 = load %NVGpaint*, %NVGpaint** %objPtr
%val550 = load float, float* %arg_2Ptr
; set tuple
%val551 = getelementptr %NVGpaint, %NVGpaint* %val549, i64 0, i32 2
store float %val550, float* %val551
%val552 = load %NVGpaint*, %NVGpaint** %objPtr
%val553 = load float, float* %arg_3Ptr
; set tuple
%val554 = getelementptr %NVGpaint, %NVGpaint* %val552, i64 0, i32 3
store float %val553, float* %val554
%val555 = load %NVGpaint*, %NVGpaint** %objPtr
%val556 = load %NVGcolor, %NVGcolor* %arg_4Ptr
; set tuple
%val557 = getelementptr %NVGpaint, %NVGpaint* %val555, i64 0, i32 4
store %NVGcolor %val556, %NVGcolor* %val557
%val558 = load %NVGpaint*, %NVGpaint** %objPtr
%val559 = load %NVGcolor, %NVGcolor* %arg_5Ptr
; set tuple
%val560 = getelementptr %NVGpaint, %NVGpaint* %val558, i64 0, i32 5
store %NVGcolor %val559, %NVGcolor* %val560
%val561 = load %NVGpaint*, %NVGpaint** %objPtr
%val562 = load i32, i32* %arg_6Ptr
; set tuple
%val563 = getelementptr %NVGpaint, %NVGpaint* %val561, i64 0, i32 6
store i32 %val562, i32* %val563
%val564 = load %NVGpaint*, %NVGpaint** %objPtr
ret %NVGpaint* %val564
}
@gsxtmnanovg31 = hidden constant [158 x i8] c"NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** @NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone584 = load i8*, i8** %_impzPtr
%zone585 = bitcast i8* %tzone584 to %mzone*

; let assign value to symbol NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0
%dat_NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone585, i64 8)
%NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0Ptr = bitcast i8* %dat_NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0 to { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***
%tzone565 = load i8*, i8** %_impzPtr
%zone566 = bitcast i8* %tzone565 to %mzone*
call void @llvm_zone_mark(%mzone* %zone566)
; malloc closure structure
%clsptr567 = call i8* @llvm_zone_malloc(%mzone* %zone566, i64 24)
%closure568 = bitcast i8* %clsptr567 to { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*

; malloc environment structure
%envptr569 = call i8* @llvm_zone_malloc(%mzone* %zone566, i64 8)
%environment570 = bitcast i8* %envptr569 to {{i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}*

; malloc closure address table
%addytable571 = call %clsvar* @new_address_table()
%var572 = bitcast [105 x i8]* @gsxtmnanovg30 to i8*
%var573 = bitcast [104 x i8]* @gsxtmnanovg26 to i8*
%addytable574 = call %clsvar* @add_address_table(%mzone* %zone566, i8* %var572, i32 0, i8* %var573, i32 3, %clsvar* %addytable571)
%address-table575 = bitcast %clsvar* %addytable574 to i8*

; insert table, function and environment into closure struct
%closure.table578 = getelementptr { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure568, i32 0, i32 0
store i8* %address-table575, i8** %closure.table578
%closure.env579 = getelementptr { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure568, i32 0, i32 1
store i8* %envptr569, i8** %closure.env579
%closure.func580 = getelementptr { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure568, i32 0, i32 2
store %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)* @NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0__537, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)** %closure.func580
%closure_size581 = call i64 @llvm_zone_mark_size(%mzone* %zone566)
call void @llvm_zone_ptr_set_size(i8* %clsptr567, i64 %closure_size581)
%wrapper_ptr582 = call i8* @llvm_zone_malloc(%mzone* %zone566, i64 8)
%closure_wrapper583 = bitcast i8* %wrapper_ptr582 to { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**
store { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure568, { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_wrapper583

; let value assignment
%NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0 = select i1 true, { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_wrapper583, { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_wrapper583
store { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0, { i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*** %NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0
%tmp_envptr577 = getelementptr {{i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}, {{i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}* %environment570, i32 0, i32 0
store {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*** %NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0Ptr, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**** %tmp_envptr577


%val586 = load {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*** %NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0Ptr
ret {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %val586
}


@NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** @NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGpaint* @NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0([6 x float] %arg_0,[2 x float] %arg_1,float %arg_2,float %arg_3,%NVGcolor %arg_4,%NVGcolor %arg_5,i32 %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**
%closure = load {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*,  %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpaint* %ff(i8* %_impz, i8* %ee, [6 x float] %arg_0, [2 x float] %arg_1, float %arg_2, float %arg_3, %NVGcolor %arg_4, %NVGcolor %arg_5, i32 %arg_6)
ret %NVGpaint* %result
}


define dllexport ccc %NVGpaint* @NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_native([6 x float] %arg_0,[2 x float] %arg_1,float %arg_2,float %arg_3,%NVGcolor %arg_4,%NVGcolor %arg_5,i32 %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**
%closure = load {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*,  %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpaint* %ff(i8* %_impz, i8* %ee, [6 x float] %arg_0, [2 x float] %arg_1, float %arg_2, float %arg_3, %NVGcolor %arg_4, %NVGcolor %arg_5, i32 %arg_6)
ret %NVGpaint* %result
}


define dllexport ccc void @NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}*
%arg_p_0 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 0
%arg_0 = load [6 x float], [6 x float]* %arg_p_0
%arg_p_1 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 1
%arg_1 = load [2 x float], [2 x float]* %arg_p_1
%arg_p_2 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 4
%arg_4 = load %NVGcolor, %NVGcolor* %arg_p_4
%arg_p_5 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 5
%arg_5 = load %NVGcolor, %NVGcolor* %arg_p_5
%arg_p_6 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 6
%arg_6 = load i32, i32* %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpaint_h_adhoc_W05WR3BhaW50Kix8NixmbG9hdHwsfDIsZmxvYXR8LGZsb2F0LGZsb2F0LE5WR2NvbG9yLE5WR2NvbG9yLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**
%closure = load {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*,  %NVGpaint* (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpaint* %ff(i8* %_impz, i8* %ee, [6 x float] %arg_0, [2 x float] %arg_1, float %arg_2, float %arg_3, %NVGcolor %arg_4, %NVGcolor %arg_5, i32 %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg32 = hidden constant [106 x i8] c"NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ\00"
@gsxtmnanovg33 = hidden constant [103 x i8] c"{i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**\00"
define dllexport fastcc %NVGpaint @NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ__590(i8* %_impz,i8* %_impenv, [6 x float] %arg_0, [2 x float] %arg_1, float %arg_2, float %arg_3, %NVGcolor %arg_4, %NVGcolor %arg_5, i32 %arg_6) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone591 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}*
%NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQPtr_ = getelementptr {{i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}, {{i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}* %impenv, i32 0, i32 0
%NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQPtr = load {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***, {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**** %NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQPtr_

; setup arguments
%arg_0Ptr = alloca [6 x float]
store [6 x float] %arg_0, [6 x float]* %arg_0Ptr
%arg_1Ptr = alloca [2 x float]
store [2 x float] %arg_1, [2 x float]* %arg_1Ptr
%arg_2Ptr = alloca float
store float %arg_2, float* %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr
%arg_4Ptr = alloca %NVGcolor
store %NVGcolor %arg_4, %NVGcolor* %arg_4Ptr
%arg_5Ptr = alloca %NVGcolor
store %NVGcolor %arg_5, %NVGcolor* %arg_5Ptr
%arg_6Ptr = alloca i32
store i32 %arg_6, i32* %arg_6Ptr


%tzone593 = load i8*, i8** %_impzPtr
%zone594 = bitcast i8* %tzone593 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGpaint*
%dat592 = alloca %NVGpaint, align 16

; let value assignment
%obj = select i1 true, %NVGpaint* %dat592, %NVGpaint* %dat592
store %NVGpaint* %obj, %NVGpaint** %objPtr

%val595 = load %NVGpaint*, %NVGpaint** %objPtr
%val596 = load [6 x float], [6 x float]* %arg_0Ptr
; set tuple
%val597 = getelementptr %NVGpaint, %NVGpaint* %val595, i64 0, i32 0
store [6 x float] %val596, [6 x float]* %val597
%val598 = load %NVGpaint*, %NVGpaint** %objPtr
%val599 = load [2 x float], [2 x float]* %arg_1Ptr
; set tuple
%val600 = getelementptr %NVGpaint, %NVGpaint* %val598, i64 0, i32 1
store [2 x float] %val599, [2 x float]* %val600
%val601 = load %NVGpaint*, %NVGpaint** %objPtr
%val602 = load float, float* %arg_2Ptr
; set tuple
%val603 = getelementptr %NVGpaint, %NVGpaint* %val601, i64 0, i32 2
store float %val602, float* %val603
%val604 = load %NVGpaint*, %NVGpaint** %objPtr
%val605 = load float, float* %arg_3Ptr
; set tuple
%val606 = getelementptr %NVGpaint, %NVGpaint* %val604, i64 0, i32 3
store float %val605, float* %val606
%val607 = load %NVGpaint*, %NVGpaint** %objPtr
%val608 = load %NVGcolor, %NVGcolor* %arg_4Ptr
; set tuple
%val609 = getelementptr %NVGpaint, %NVGpaint* %val607, i64 0, i32 4
store %NVGcolor %val608, %NVGcolor* %val609
%val610 = load %NVGpaint*, %NVGpaint** %objPtr
%val611 = load %NVGcolor, %NVGcolor* %arg_5Ptr
; set tuple
%val612 = getelementptr %NVGpaint, %NVGpaint* %val610, i64 0, i32 5
store %NVGcolor %val611, %NVGcolor* %val612
%val613 = load %NVGpaint*, %NVGpaint** %objPtr
%val614 = load i32, i32* %arg_6Ptr
; set tuple
%val615 = getelementptr %NVGpaint, %NVGpaint* %val613, i64 0, i32 6
store i32 %val614, i32* %val615
%val616 = load %NVGpaint*, %NVGpaint** %objPtr
; pointer ref
%val617 = getelementptr %NVGpaint, %NVGpaint* %val616, i64 0
%val618 = load %NVGpaint, %NVGpaint* %val617
ret %NVGpaint %val618
}
@gsxtmnanovg34 = hidden constant [159 x i8] c"NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** @NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone638 = load i8*, i8** %_impzPtr
%zone639 = bitcast i8* %tzone638 to %mzone*

; let assign value to symbol NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ
%dat_NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone639, i64 8)
%NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQPtr = bitcast i8* %dat_NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ to { i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***
%tzone619 = load i8*, i8** %_impzPtr
%zone620 = bitcast i8* %tzone619 to %mzone*
call void @llvm_zone_mark(%mzone* %zone620)
; malloc closure structure
%clsptr621 = call i8* @llvm_zone_malloc(%mzone* %zone620, i64 24)
%closure622 = bitcast i8* %clsptr621 to { i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*

; malloc environment structure
%envptr623 = call i8* @llvm_zone_malloc(%mzone* %zone620, i64 8)
%environment624 = bitcast i8* %envptr623 to {{i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}*

; malloc closure address table
%addytable625 = call %clsvar* @new_address_table()
%var626 = bitcast [106 x i8]* @gsxtmnanovg32 to i8*
%var627 = bitcast [103 x i8]* @gsxtmnanovg33 to i8*
%addytable628 = call %clsvar* @add_address_table(%mzone* %zone620, i8* %var626, i32 0, i8* %var627, i32 3, %clsvar* %addytable625)
%address-table629 = bitcast %clsvar* %addytable628 to i8*

; insert table, function and environment into closure struct
%closure.table632 = getelementptr { i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, { i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure622, i32 0, i32 0
store i8* %address-table629, i8** %closure.table632
%closure.env633 = getelementptr { i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, { i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure622, i32 0, i32 1
store i8* %envptr623, i8** %closure.env633
%closure.func634 = getelementptr { i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, { i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure622, i32 0, i32 2
store %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)* @NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ__590, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)** %closure.func634
%closure_size635 = call i64 @llvm_zone_mark_size(%mzone* %zone620)
call void @llvm_zone_ptr_set_size(i8* %clsptr621, i64 %closure_size635)
%wrapper_ptr636 = call i8* @llvm_zone_malloc(%mzone* %zone620, i64 8)
%closure_wrapper637 = bitcast i8* %wrapper_ptr636 to { i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**
store { i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure622, { i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_wrapper637

; let value assignment
%NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ = select i1 true, { i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_wrapper637, { i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_wrapper637
store { i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ, { i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*** %NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQPtr

; add data to environment
; don't need to alloc for env var NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ
%tmp_envptr631 = getelementptr {{i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}, {{i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}***}* %environment624, i32 0, i32 0
store {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*** %NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQPtr, {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**** %tmp_envptr631


%val640 = load {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**, {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*** %NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQPtr
ret {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %val640
}


@NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** @NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGpaint @NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ([6 x float] %arg_0,[2 x float] %arg_1,float %arg_2,float %arg_3,%NVGcolor %arg_4,%NVGcolor %arg_5,i32 %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**
%closure = load {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*, {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*,  %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpaint %ff(i8* %_impz, i8* %ee, [6 x float] %arg_0, [2 x float] %arg_1, float %arg_2, float %arg_3, %NVGcolor %arg_4, %NVGcolor %arg_5, i32 %arg_6)
ret %NVGpaint %result
}


define dllexport ccc %NVGpaint @NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ_native([6 x float] %arg_0,[2 x float] %arg_1,float %arg_2,float %arg_3,%NVGcolor %arg_4,%NVGcolor %arg_5,i32 %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**
%closure = load {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*, {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*,  %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpaint %ff(i8* %_impz, i8* %ee, [6 x float] %arg_0, [2 x float] %arg_1, float %arg_2, float %arg_3, %NVGcolor %arg_4, %NVGcolor %arg_5, i32 %arg_6)
ret %NVGpaint %result
}


define dllexport ccc void @NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}*
%arg_p_0 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 0
%arg_0 = load [6 x float], [6 x float]* %arg_p_0
%arg_p_1 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 1
%arg_1 = load [2 x float], [2 x float]* %arg_p_1
%arg_p_2 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 4
%arg_4 = load %NVGcolor, %NVGcolor* %arg_p_4
%arg_p_5 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 5
%arg_5 = load %NVGcolor, %NVGcolor* %arg_p_5
%arg_p_6 = getelementptr {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}, {[6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32}* %fstruct, i32 0, i32 6
%arg_6 = load i32, i32* %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpaint_val_adhoc_W05WR3BhaW50LHw2LGZsb2F0fCx8MixmbG9hdHwsZmxvYXQsZmxvYXQsTlZHY29sb3IsTlZHY29sb3IsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}**
%closure = load {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}*, {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}, {i8*, i8*, %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)*,  %NVGpaint (i8*, i8*, [6 x float], [2 x float], float, float, %NVGcolor, %NVGcolor, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpaint %ff(i8* %_impz, i8* %ee, [6 x float] %arg_0, [2 x float] %arg_1, float %arg_2, float %arg_3, %NVGcolor %arg_4, %NVGcolor %arg_5, i32 %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg35 = hidden constant [41 x i8] c"hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd\00"
@gsxtmnanovg36 = hidden constant [49 x i8] c"{i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}**\00"
define dllexport fastcc %NVGpaint* @hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd__644(i8* %_impz,i8* %_impenv, %NVGpaint* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone645 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}***}*
%hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpdPtr_ = getelementptr {{i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}***}, {{i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpdPtr = load {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}***, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}**** %hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpdPtr_

; setup arguments
%xPtr = alloca %NVGpaint*
store %NVGpaint* %x, %NVGpaint** %xPtr


%tzone648 = load i8*, i8** %_impzPtr
%zone649 = bitcast i8* %tzone648 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGpaint*
%dat646 = call i8* @malloc(i64 76)
call i8* @memset(i8* %dat646, i32 0, i64 76)
%val647 = bitcast i8* %dat646 to %NVGpaint*

; let value assignment
%obj = select i1 true, %NVGpaint* %val647, %NVGpaint* %val647
store %NVGpaint* %obj, %NVGpaint** %objPtr

%val650 = load %NVGpaint*, %NVGpaint** %objPtr
%val651 = load %NVGpaint*, %NVGpaint** %xPtr
; tuple ref
%val652 = getelementptr %NVGpaint, %NVGpaint* %val651, i64 0, i32 0
%val653 = load [6 x float], [6 x float]* %val652
; set tuple
%val654 = getelementptr %NVGpaint, %NVGpaint* %val650, i64 0, i32 0
store [6 x float] %val653, [6 x float]* %val654
%val655 = load %NVGpaint*, %NVGpaint** %objPtr
%val656 = load %NVGpaint*, %NVGpaint** %xPtr
; tuple ref
%val657 = getelementptr %NVGpaint, %NVGpaint* %val656, i64 0, i32 1
%val658 = load [2 x float], [2 x float]* %val657
; set tuple
%val659 = getelementptr %NVGpaint, %NVGpaint* %val655, i64 0, i32 1
store [2 x float] %val658, [2 x float]* %val659
%val660 = load %NVGpaint*, %NVGpaint** %objPtr
%val661 = load %NVGpaint*, %NVGpaint** %xPtr
; tuple ref
%val662 = getelementptr %NVGpaint, %NVGpaint* %val661, i64 0, i32 2
%val663 = load float, float* %val662
; set tuple
%val664 = getelementptr %NVGpaint, %NVGpaint* %val660, i64 0, i32 2
store float %val663, float* %val664
%val665 = load %NVGpaint*, %NVGpaint** %objPtr
%val666 = load %NVGpaint*, %NVGpaint** %xPtr
; tuple ref
%val667 = getelementptr %NVGpaint, %NVGpaint* %val666, i64 0, i32 3
%val668 = load float, float* %val667
; set tuple
%val669 = getelementptr %NVGpaint, %NVGpaint* %val665, i64 0, i32 3
store float %val668, float* %val669
%val670 = load %NVGpaint*, %NVGpaint** %objPtr
%val671 = load %NVGpaint*, %NVGpaint** %xPtr
; tuple ref
%val672 = getelementptr %NVGpaint, %NVGpaint* %val671, i64 0, i32 4
%val673 = load %NVGcolor, %NVGcolor* %val672
; set tuple
%val674 = getelementptr %NVGpaint, %NVGpaint* %val670, i64 0, i32 4
store %NVGcolor %val673, %NVGcolor* %val674
%val675 = load %NVGpaint*, %NVGpaint** %objPtr
%val676 = load %NVGpaint*, %NVGpaint** %xPtr
; tuple ref
%val677 = getelementptr %NVGpaint, %NVGpaint* %val676, i64 0, i32 5
%val678 = load %NVGcolor, %NVGcolor* %val677
; set tuple
%val679 = getelementptr %NVGpaint, %NVGpaint* %val675, i64 0, i32 5
store %NVGcolor %val678, %NVGcolor* %val679
%val680 = load %NVGpaint*, %NVGpaint** %objPtr
%val681 = load %NVGpaint*, %NVGpaint** %xPtr
; tuple ref
%val682 = getelementptr %NVGpaint, %NVGpaint* %val681, i64 0, i32 6
%val683 = load i32, i32* %val682
; set tuple
%val684 = getelementptr %NVGpaint, %NVGpaint* %val680, i64 0, i32 6
store i32 %val683, i32* %val684
%val685 = load %NVGpaint*, %NVGpaint** %objPtr
ret %NVGpaint* %val685
}
@gsxtmnanovg37 = hidden constant [94 x i8] c"hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}** @hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone705 = load i8*, i8** %_impzPtr
%zone706 = bitcast i8* %tzone705 to %mzone*

; let assign value to symbol hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd
%dat_hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd = call i8* @llvm_zone_malloc(%mzone* %zone706, i64 8)
%hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpdPtr = bitcast i8* %dat_hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd to { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}***
%tzone686 = load i8*, i8** %_impzPtr
%zone687 = bitcast i8* %tzone686 to %mzone*
call void @llvm_zone_mark(%mzone* %zone687)
; malloc closure structure
%clsptr688 = call i8* @llvm_zone_malloc(%mzone* %zone687, i64 24)
%closure689 = bitcast i8* %clsptr688 to { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}*

; malloc environment structure
%envptr690 = call i8* @llvm_zone_malloc(%mzone* %zone687, i64 8)
%environment691 = bitcast i8* %envptr690 to {{i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}***}*

; malloc closure address table
%addytable692 = call %clsvar* @new_address_table()
%var693 = bitcast [41 x i8]* @gsxtmnanovg35 to i8*
%var694 = bitcast [49 x i8]* @gsxtmnanovg36 to i8*
%addytable695 = call %clsvar* @add_address_table(%mzone* %zone687, i8* %var693, i32 0, i8* %var694, i32 3, %clsvar* %addytable692)
%address-table696 = bitcast %clsvar* %addytable695 to i8*

; insert table, function and environment into closure struct
%closure.table699 = getelementptr { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}, { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}* %closure689, i32 0, i32 0
store i8* %address-table696, i8** %closure.table699
%closure.env700 = getelementptr { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}, { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}* %closure689, i32 0, i32 1
store i8* %envptr690, i8** %closure.env700
%closure.func701 = getelementptr { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}, { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}* %closure689, i32 0, i32 2
store %NVGpaint* (i8*, i8*, %NVGpaint*)* @hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd__644, %NVGpaint* (i8*, i8*, %NVGpaint*)** %closure.func701
%closure_size702 = call i64 @llvm_zone_mark_size(%mzone* %zone687)
call void @llvm_zone_ptr_set_size(i8* %clsptr688, i64 %closure_size702)
%wrapper_ptr703 = call i8* @llvm_zone_malloc(%mzone* %zone687, i64 8)
%closure_wrapper704 = bitcast i8* %wrapper_ptr703 to { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}**
store { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}* %closure689, { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}** %closure_wrapper704

; let value assignment
%hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd = select i1 true, { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}** %closure_wrapper704, { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}** %closure_wrapper704
store { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}** %hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd, { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}*** %hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpdPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd
%tmp_envptr698 = getelementptr {{i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}***}, {{i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}***}* %environment691, i32 0, i32 0
store {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}*** %hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpdPtr, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}**** %tmp_envptr698


%val707 = load {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}**, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}*** %hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpdPtr
ret {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}** %val707
}


@hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}** @hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGpaint* @hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd(%NVGpaint* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}**
%closure = load {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}*, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 1
%ff = load  %NVGpaint* (i8*, i8*, %NVGpaint*)*,  %NVGpaint* (i8*, i8*, %NVGpaint*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpaint* %ff(i8* %_impz, i8* %ee, %NVGpaint* %arg_0)
ret %NVGpaint* %result
}


define dllexport ccc %NVGpaint* @hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd_native(%NVGpaint* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}**
%closure = load {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}*, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 1
%ff = load  %NVGpaint* (i8*, i8*, %NVGpaint*)*,  %NVGpaint* (i8*, i8*, %NVGpaint*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpaint* %ff(i8* %_impz, i8* %ee, %NVGpaint* %arg_0)
ret %NVGpaint* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var708 = bitcast [94 x i8]* @gsxtmnanovg37 to i8*
call i32 (i8*, ...) @printf(i8* %var708)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGpaint*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}**
%closure = load {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}*, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 1
%ff = load  %NVGpaint* (i8*, i8*, %NVGpaint*)*,  %NVGpaint* (i8*, i8*, %NVGpaint*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpaint* %ff(i8* %_impz, i8* %ee, %NVGpaint* %arg_0)
%tmpres = bitcast %NVGpaint* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGpaint*}*
%arg_p_0 = getelementptr {%NVGpaint*}, {%NVGpaint*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGpaint*, %NVGpaint** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}**
%closure = load {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}*, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 1
%ff = load  %NVGpaint* (i8*, i8*, %NVGpaint*)*,  %NVGpaint* (i8*, i8*, %NVGpaint*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpaint* %ff(i8* %_impz, i8* %ee, %NVGpaint* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg38 = hidden constant [35 x i8] c"hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ\00"
@gsxtmnanovg39 = hidden constant [43 x i8] c"{i8*, i8*, void (i8*, i8*, %NVGpaint*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ__709(i8* %_impz,i8* %_impenv, %NVGpaint* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone710 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %NVGpaint*)*}***}*
%hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGpaint*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGpaint*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQPtr = load {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}***, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}**** %hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQPtr_

; setup arguments
%xPtr = alloca %NVGpaint*
store %NVGpaint* %x, %NVGpaint** %xPtr


%val711 = load %NVGpaint*, %NVGpaint** %xPtr
%val712 = bitcast %NVGpaint* %val711 to i8*
call ccc void @free(i8* %val712)
ret void
}
@gsxtmnanovg40 = hidden constant [88 x i8] c"hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** @hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone734 = load i8*, i8** %_impzPtr
%zone735 = bitcast i8* %tzone734 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ
%dat_hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone735, i64 8)
%hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ to { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}***
%tzone715 = load i8*, i8** %_impzPtr
%zone716 = bitcast i8* %tzone715 to %mzone*
call void @llvm_zone_mark(%mzone* %zone716)
; malloc closure structure
%clsptr717 = call i8* @llvm_zone_malloc(%mzone* %zone716, i64 24)
%closure718 = bitcast i8* %clsptr717 to { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}*

; malloc environment structure
%envptr719 = call i8* @llvm_zone_malloc(%mzone* %zone716, i64 8)
%environment720 = bitcast i8* %envptr719 to {{i8*, i8*, void (i8*, i8*, %NVGpaint*)*}***}*

; malloc closure address table
%addytable721 = call %clsvar* @new_address_table()
%var722 = bitcast [35 x i8]* @gsxtmnanovg38 to i8*
%var723 = bitcast [43 x i8]* @gsxtmnanovg39 to i8*
%addytable724 = call %clsvar* @add_address_table(%mzone* %zone716, i8* %var722, i32 0, i8* %var723, i32 3, %clsvar* %addytable721)
%address-table725 = bitcast %clsvar* %addytable724 to i8*

; insert table, function and environment into closure struct
%closure.table728 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure718, i32 0, i32 0
store i8* %address-table725, i8** %closure.table728
%closure.env729 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure718, i32 0, i32 1
store i8* %envptr719, i8** %closure.env729
%closure.func730 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure718, i32 0, i32 2
store void (i8*, i8*, %NVGpaint*)* @hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ__709, void (i8*, i8*, %NVGpaint*)** %closure.func730
%closure_size731 = call i64 @llvm_zone_mark_size(%mzone* %zone716)
call void @llvm_zone_ptr_set_size(i8* %clsptr717, i64 %closure_size731)
%wrapper_ptr732 = call i8* @llvm_zone_malloc(%mzone* %zone716, i64 8)
%closure_wrapper733 = bitcast i8* %wrapper_ptr732 to { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}**
store { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure718, { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** %closure_wrapper733

; let value assignment
%hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** %closure_wrapper733, { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** %closure_wrapper733
store { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** %hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ, { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}*** %hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ
%tmp_envptr727 = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGpaint*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGpaint*)*}***}* %environment720, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}*** %hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQPtr, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}**** %tmp_envptr727


%val736 = load {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}**, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}*** %hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQPtr
ret {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** %val736
}


@hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** @hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ(%NVGpaint* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}*, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGpaint*)*,  void (i8*, i8*, %NVGpaint*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGpaint* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_native(%NVGpaint* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}*, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGpaint*)*,  void (i8*, i8*, %NVGpaint*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGpaint* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var737 = bitcast [88 x i8]* @gsxtmnanovg40 to i8*
call i32 (i8*, ...) @printf(i8* %var737)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGpaint*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}*, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGpaint*)*,  void (i8*, i8*, %NVGpaint*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGpaint* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGpaint*}*
%arg_p_0 = getelementptr {%NVGpaint*}, {%NVGpaint*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGpaint*, %NVGpaint** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}*, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGpaint*)*,  void (i8*, i8*, %NVGpaint*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGpaint* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg41 = hidden constant [60 x i8] c"zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0\00"
@gsxtmnanovg42 = hidden constant [67 x i8] c"{i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %NVGpaint* @zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0__738(i8* %_impz,i8* %_impenv, %NVGpaint* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone739 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0Ptr_ = getelementptr {{i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0Ptr = load {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}***, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0Ptr_

; setup arguments
%xPtr = alloca %NVGpaint*
store %NVGpaint* %x, %NVGpaint** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val741 = load %mzone*, %mzone** %fromzPtr
%val742 = load %NVGpaint*, %NVGpaint** %xPtr
%val743 = bitcast %NVGpaint* %val742 to i8*
%res744 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val741, i8* %val743)
br i1 %res744, label %then740, label %else740

then740:
%val745 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val745)
%zone_ptr746 = bitcast %mzone* %val745 to i8*
store i8* %zone_ptr746, i8** %_impzPtr
%tzone752 = load i8*, i8** %_impzPtr
%zone753 = bitcast i8* %tzone752 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGpaint*
%tzone748 = load i8*, i8** %_impzPtr
%zone749 = bitcast i8* %tzone748 to %mzone*
%dat750 = call i8* @llvm_zone_malloc(%mzone* %zone749, i64 76)
call i8* @memset(i8* %dat750, i32 0, i64 76)
%val751 = bitcast i8* %dat750 to %NVGpaint*

; let value assignment
%obj = select i1 true, %NVGpaint* %val751, %NVGpaint* %val751
store %NVGpaint* %obj, %NVGpaint** %objPtr

%val754 = load %NVGpaint*, %NVGpaint** %objPtr
%val755 = load %NVGpaint*, %NVGpaint** %xPtr
; tuple ref
%val756 = getelementptr %NVGpaint, %NVGpaint* %val755, i64 0, i32 0
%val757 = load [6 x float], [6 x float]* %val756
; set tuple
%val758 = getelementptr %NVGpaint, %NVGpaint* %val754, i64 0, i32 0
store [6 x float] %val757, [6 x float]* %val758
%val759 = load %NVGpaint*, %NVGpaint** %objPtr
%val760 = load %NVGpaint*, %NVGpaint** %xPtr
; tuple ref
%val761 = getelementptr %NVGpaint, %NVGpaint* %val760, i64 0, i32 1
%val762 = load [2 x float], [2 x float]* %val761
; set tuple
%val763 = getelementptr %NVGpaint, %NVGpaint* %val759, i64 0, i32 1
store [2 x float] %val762, [2 x float]* %val763
%val764 = load %NVGpaint*, %NVGpaint** %objPtr
%val765 = load %NVGpaint*, %NVGpaint** %xPtr
; tuple ref
%val766 = getelementptr %NVGpaint, %NVGpaint* %val765, i64 0, i32 2
%val767 = load float, float* %val766
; set tuple
%val768 = getelementptr %NVGpaint, %NVGpaint* %val764, i64 0, i32 2
store float %val767, float* %val768
%val769 = load %NVGpaint*, %NVGpaint** %objPtr
%val770 = load %NVGpaint*, %NVGpaint** %xPtr
; tuple ref
%val771 = getelementptr %NVGpaint, %NVGpaint* %val770, i64 0, i32 3
%val772 = load float, float* %val771
; set tuple
%val773 = getelementptr %NVGpaint, %NVGpaint* %val769, i64 0, i32 3
store float %val772, float* %val773
%val774 = load %NVGpaint*, %NVGpaint** %objPtr
%val775 = load %NVGpaint*, %NVGpaint** %xPtr
; tuple ref
%val776 = getelementptr %NVGpaint, %NVGpaint* %val775, i64 0, i32 4
%val777 = load %NVGcolor, %NVGcolor* %val776
; set tuple
%val778 = getelementptr %NVGpaint, %NVGpaint* %val774, i64 0, i32 4
store %NVGcolor %val777, %NVGcolor* %val778
%val779 = load %NVGpaint*, %NVGpaint** %objPtr
%val780 = load %NVGpaint*, %NVGpaint** %xPtr
; tuple ref
%val781 = getelementptr %NVGpaint, %NVGpaint* %val780, i64 0, i32 5
%val782 = load %NVGcolor, %NVGcolor* %val781
; set tuple
%val783 = getelementptr %NVGpaint, %NVGpaint* %val779, i64 0, i32 5
store %NVGcolor %val782, %NVGcolor* %val783
%val784 = load %NVGpaint*, %NVGpaint** %objPtr
%val785 = load %NVGpaint*, %NVGpaint** %xPtr
; tuple ref
%val786 = getelementptr %NVGpaint, %NVGpaint* %val785, i64 0, i32 6
%val787 = load i32, i32* %val786
; set tuple
%val788 = getelementptr %NVGpaint, %NVGpaint* %val784, i64 0, i32 6
store i32 %val787, i32* %val788
%oldzone789 = call %mzone* @llvm_pop_zone_stack()
%newzone790 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr791 = bitcast %mzone* %newzone790 to i8*
store i8* %zone_ptr791, i8** %_impzPtr
%val792 = load %NVGpaint*, %NVGpaint** %objPtr
ret %NVGpaint* %val792

else740:
%val793 = load %NVGpaint*, %NVGpaint** %xPtr
ret %NVGpaint* %val793
}
@gsxtmnanovg43 = hidden constant [113 x i8] c"zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}** @zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone813 = load i8*, i8** %_impzPtr
%zone814 = bitcast i8* %tzone813 to %mzone*

; let assign value to symbol zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0
%dat_zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone814, i64 8)
%zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0Ptr = bitcast i8* %dat_zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0 to { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}***
%tzone794 = load i8*, i8** %_impzPtr
%zone795 = bitcast i8* %tzone794 to %mzone*
call void @llvm_zone_mark(%mzone* %zone795)
; malloc closure structure
%clsptr796 = call i8* @llvm_zone_malloc(%mzone* %zone795, i64 24)
%closure797 = bitcast i8* %clsptr796 to { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr798 = call i8* @llvm_zone_malloc(%mzone* %zone795, i64 8)
%environment799 = bitcast i8* %envptr798 to {{i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable800 = call %clsvar* @new_address_table()
%var801 = bitcast [60 x i8]* @gsxtmnanovg41 to i8*
%var802 = bitcast [67 x i8]* @gsxtmnanovg42 to i8*
%addytable803 = call %clsvar* @add_address_table(%mzone* %zone795, i8* %var801, i32 0, i8* %var802, i32 3, %clsvar* %addytable800)
%address-table804 = bitcast %clsvar* %addytable803 to i8*

; insert table, function and environment into closure struct
%closure.table807 = getelementptr { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}* %closure797, i32 0, i32 0
store i8* %address-table804, i8** %closure.table807
%closure.env808 = getelementptr { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}* %closure797, i32 0, i32 1
store i8* %envptr798, i8** %closure.env808
%closure.func809 = getelementptr { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}* %closure797, i32 0, i32 2
store %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)* @zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0__738, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)** %closure.func809
%closure_size810 = call i64 @llvm_zone_mark_size(%mzone* %zone795)
call void @llvm_zone_ptr_set_size(i8* %clsptr796, i64 %closure_size810)
%wrapper_ptr811 = call i8* @llvm_zone_malloc(%mzone* %zone795, i64 8)
%closure_wrapper812 = bitcast i8* %wrapper_ptr811 to { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}**
store { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}* %closure797, { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}** %closure_wrapper812

; let value assignment
%zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0 = select i1 true, { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}** %closure_wrapper812, { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}** %closure_wrapper812
store { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}** %zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0, { i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0Ptr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0
%tmp_envptr806 = getelementptr {{i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}***}* %environment799, i32 0, i32 0
store {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0Ptr, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}**** %tmp_envptr806


%val815 = load {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}**, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0Ptr
ret {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}** %val815
}


@zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}** @zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGpaint* @zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0(%NVGpaint* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*,  %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpaint* %ff(i8* %_impz, i8* %ee, %NVGpaint* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %NVGpaint* %result
}


define dllexport ccc %NVGpaint* @zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0_native(%NVGpaint* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*,  %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpaint* %ff(i8* %_impz, i8* %ee, %NVGpaint* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %NVGpaint* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var816 = bitcast [113 x i8]* @gsxtmnanovg43 to i8*
call i32 (i8*, ...) @printf(i8* %var816)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGpaint*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var817 = bitcast [113 x i8]* @gsxtmnanovg43 to i8*
call i32 (i8*, ...) @printf(i8* %var817)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var818 = bitcast [113 x i8]* @gsxtmnanovg43 to i8*
call i32 (i8*, ...) @printf(i8* %var818)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*,  %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpaint* %ff(i8* %_impz, i8* %ee, %NVGpaint* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %NVGpaint* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGpaint*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%NVGpaint*, %mzone*, %mzone*}, {%NVGpaint*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGpaint*, %NVGpaint** %arg_p_0
%arg_p_1 = getelementptr {%NVGpaint*, %mzone*, %mzone*}, {%NVGpaint*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%NVGpaint*, %mzone*, %mzone*}, {%NVGpaint*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3BhaW50KixOVkdwYWludCosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)*,  %NVGpaint* (i8*, i8*, %NVGpaint*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpaint* %ff(i8* %_impz, i8* %ee, %NVGpaint* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg44 = hidden constant [23 x i8] c"<NVGpaint:
    xform=|\00"
@gsxtmnanovg45 = hidden constant [6 x i8] c"%.3f \00"
@gsxtmnanovg46 = hidden constant [6 x i8] c"%.3f|\00"
@gsxtmnanovg47 = hidden constant [25 x i8] c"
    extent=|%.3f %.3f|
\00"
@gsxtmnanovg48 = hidden constant [34 x i8] c"    radius=%.3f
    feather=%.3f
\00"
@gsxtmnanovg49 = hidden constant [59 x i8] c"    innerColor=<NVGcolor: r=%.3f, g=%.3f, b=%.3f, a=%.3f>
\00"
@gsxtmnanovg50 = hidden constant [59 x i8] c"    outerColor=<NVGcolor: r=%.3f, g=%.3f, b=%.3f, a=%.3f>
\00"
@gsxtmnanovg51 = hidden constant [14 x i8] c"    image=%d>\00"
@gsxtmnanovg52 = hidden constant [35 x i8] c"print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ__819(i8* %_impz,i8* %_impenv, %NVGpaint* %paint) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone820 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %NVGpaint*)*}***}*
%print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGpaint*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGpaint*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQPtr = load {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}***, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}**** %print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQPtr_

; setup arguments
%paintPtr = alloca %NVGpaint*
store %NVGpaint* %paint, %NVGpaint** %paintPtr


%var821 = bitcast [23 x i8]* @gsxtmnanovg44 to i8*

%val822 = call i32 (i8*, ...) @printf(i8* %var821)
%var823 = bitcast [6 x i8]* @gsxtmnanovg45 to i8*
%val824 = load %NVGpaint*, %NVGpaint** %paintPtr
; tuple ref
%val825 = getelementptr %NVGpaint, %NVGpaint* %val824, i64 0, i32 0
%val826 = load [6 x float], [6 x float]* %val825
; array ref
%val827 = extractvalue [6 x float] %val826, 0
%val828 = fpext float %val827 to double

%val829 = call i32 (i8*, ...) @printf(i8* %var823, double %val828)
%var830 = bitcast [6 x i8]* @gsxtmnanovg45 to i8*
%val831 = load %NVGpaint*, %NVGpaint** %paintPtr
; tuple ref
%val832 = getelementptr %NVGpaint, %NVGpaint* %val831, i64 0, i32 0
%val833 = load [6 x float], [6 x float]* %val832
; array ref
%val834 = extractvalue [6 x float] %val833, 1
%val835 = fpext float %val834 to double

%val836 = call i32 (i8*, ...) @printf(i8* %var830, double %val835)
%var837 = bitcast [6 x i8]* @gsxtmnanovg45 to i8*
%val838 = load %NVGpaint*, %NVGpaint** %paintPtr
; tuple ref
%val839 = getelementptr %NVGpaint, %NVGpaint* %val838, i64 0, i32 0
%val840 = load [6 x float], [6 x float]* %val839
; array ref
%val841 = extractvalue [6 x float] %val840, 2
%val842 = fpext float %val841 to double

%val843 = call i32 (i8*, ...) @printf(i8* %var837, double %val842)
%var844 = bitcast [6 x i8]* @gsxtmnanovg45 to i8*
%val845 = load %NVGpaint*, %NVGpaint** %paintPtr
; tuple ref
%val846 = getelementptr %NVGpaint, %NVGpaint* %val845, i64 0, i32 0
%val847 = load [6 x float], [6 x float]* %val846
; array ref
%val848 = extractvalue [6 x float] %val847, 3
%val849 = fpext float %val848 to double

%val850 = call i32 (i8*, ...) @printf(i8* %var844, double %val849)
%var851 = bitcast [6 x i8]* @gsxtmnanovg45 to i8*
%val852 = load %NVGpaint*, %NVGpaint** %paintPtr
; tuple ref
%val853 = getelementptr %NVGpaint, %NVGpaint* %val852, i64 0, i32 0
%val854 = load [6 x float], [6 x float]* %val853
; array ref
%val855 = extractvalue [6 x float] %val854, 4
%val856 = fpext float %val855 to double

%val857 = call i32 (i8*, ...) @printf(i8* %var851, double %val856)
%var858 = bitcast [6 x i8]* @gsxtmnanovg46 to i8*
%val859 = load %NVGpaint*, %NVGpaint** %paintPtr
; tuple ref
%val860 = getelementptr %NVGpaint, %NVGpaint* %val859, i64 0, i32 0
%val861 = load [6 x float], [6 x float]* %val860
; array ref
%val862 = extractvalue [6 x float] %val861, 5
%val863 = fpext float %val862 to double

%val864 = call i32 (i8*, ...) @printf(i8* %var858, double %val863)
%var865 = bitcast [25 x i8]* @gsxtmnanovg47 to i8*
%val866 = load %NVGpaint*, %NVGpaint** %paintPtr
; tuple ref
%val867 = getelementptr %NVGpaint, %NVGpaint* %val866, i64 0, i32 1
%val868 = load [2 x float], [2 x float]* %val867
; array ref
%val869 = extractvalue [2 x float] %val868, 0
%val870 = fpext float %val869 to double
%val871 = load %NVGpaint*, %NVGpaint** %paintPtr
; tuple ref
%val872 = getelementptr %NVGpaint, %NVGpaint* %val871, i64 0, i32 1
%val873 = load [2 x float], [2 x float]* %val872
; array ref
%val874 = extractvalue [2 x float] %val873, 1
%val875 = fpext float %val874 to double

%val876 = call i32 (i8*, ...) @printf(i8* %var865, double %val870, double %val875)
%var877 = bitcast [34 x i8]* @gsxtmnanovg48 to i8*
%val878 = load %NVGpaint*, %NVGpaint** %paintPtr
; tuple ref
%val879 = getelementptr %NVGpaint, %NVGpaint* %val878, i64 0, i32 2
%val880 = load float, float* %val879
%val881 = fpext float %val880 to double
%val882 = load %NVGpaint*, %NVGpaint** %paintPtr
; tuple ref
%val883 = getelementptr %NVGpaint, %NVGpaint* %val882, i64 0, i32 3
%val884 = load float, float* %val883
%val885 = fpext float %val884 to double

%val886 = call i32 (i8*, ...) @printf(i8* %var877, double %val881, double %val885)
%var887 = bitcast [59 x i8]* @gsxtmnanovg49 to i8*
%val888 = load %NVGpaint*, %NVGpaint** %paintPtr
; tuple ref
%val889 = getelementptr %NVGpaint, %NVGpaint* %val888, i64 0, i32 4
%val890 = load %NVGcolor, %NVGcolor* %val889
; tuple ref
%val891 = extractvalue %NVGcolor %val890, 0
%val892 = fpext float %val891 to double
%val893 = load %NVGpaint*, %NVGpaint** %paintPtr
; tuple ref
%val894 = getelementptr %NVGpaint, %NVGpaint* %val893, i64 0, i32 4
%val895 = load %NVGcolor, %NVGcolor* %val894
; tuple ref
%val896 = extractvalue %NVGcolor %val895, 1
%val897 = fpext float %val896 to double
%val898 = load %NVGpaint*, %NVGpaint** %paintPtr
; tuple ref
%val899 = getelementptr %NVGpaint, %NVGpaint* %val898, i64 0, i32 4
%val900 = load %NVGcolor, %NVGcolor* %val899
; tuple ref
%val901 = extractvalue %NVGcolor %val900, 2
%val902 = fpext float %val901 to double
%val903 = load %NVGpaint*, %NVGpaint** %paintPtr
; tuple ref
%val904 = getelementptr %NVGpaint, %NVGpaint* %val903, i64 0, i32 4
%val905 = load %NVGcolor, %NVGcolor* %val904
; tuple ref
%val906 = extractvalue %NVGcolor %val905, 3
%val907 = fpext float %val906 to double

%val908 = call i32 (i8*, ...) @printf(i8* %var887, double %val892, double %val897, double %val902, double %val907)
%var909 = bitcast [59 x i8]* @gsxtmnanovg50 to i8*
%val910 = load %NVGpaint*, %NVGpaint** %paintPtr
; tuple ref
%val911 = getelementptr %NVGpaint, %NVGpaint* %val910, i64 0, i32 5
%val912 = load %NVGcolor, %NVGcolor* %val911
; tuple ref
%val913 = extractvalue %NVGcolor %val912, 0
%val914 = fpext float %val913 to double
%val915 = load %NVGpaint*, %NVGpaint** %paintPtr
; tuple ref
%val916 = getelementptr %NVGpaint, %NVGpaint* %val915, i64 0, i32 5
%val917 = load %NVGcolor, %NVGcolor* %val916
; tuple ref
%val918 = extractvalue %NVGcolor %val917, 1
%val919 = fpext float %val918 to double
%val920 = load %NVGpaint*, %NVGpaint** %paintPtr
; tuple ref
%val921 = getelementptr %NVGpaint, %NVGpaint* %val920, i64 0, i32 5
%val922 = load %NVGcolor, %NVGcolor* %val921
; tuple ref
%val923 = extractvalue %NVGcolor %val922, 2
%val924 = fpext float %val923 to double
%val925 = load %NVGpaint*, %NVGpaint** %paintPtr
; tuple ref
%val926 = getelementptr %NVGpaint, %NVGpaint* %val925, i64 0, i32 5
%val927 = load %NVGcolor, %NVGcolor* %val926
; tuple ref
%val928 = extractvalue %NVGcolor %val927, 3
%val929 = fpext float %val928 to double

%val930 = call i32 (i8*, ...) @printf(i8* %var909, double %val914, double %val919, double %val924, double %val929)
%var931 = bitcast [14 x i8]* @gsxtmnanovg51 to i8*
%val932 = load %NVGpaint*, %NVGpaint** %paintPtr
; tuple ref
%val933 = getelementptr %NVGpaint, %NVGpaint* %val932, i64 0, i32 6
%val934 = load i32, i32* %val933

%val935 = call i32 (i8*, ...) @printf(i8* %var931, i32 %val934)
ret void
}
@gsxtmnanovg53 = hidden constant [88 x i8] c"print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** @print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone956 = load i8*, i8** %_impzPtr
%zone957 = bitcast i8* %tzone956 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ
%dat_print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone957, i64 8)
%print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ to { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}***
%tzone937 = load i8*, i8** %_impzPtr
%zone938 = bitcast i8* %tzone937 to %mzone*
call void @llvm_zone_mark(%mzone* %zone938)
; malloc closure structure
%clsptr939 = call i8* @llvm_zone_malloc(%mzone* %zone938, i64 24)
%closure940 = bitcast i8* %clsptr939 to { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}*

; malloc environment structure
%envptr941 = call i8* @llvm_zone_malloc(%mzone* %zone938, i64 8)
%environment942 = bitcast i8* %envptr941 to {{i8*, i8*, void (i8*, i8*, %NVGpaint*)*}***}*

; malloc closure address table
%addytable943 = call %clsvar* @new_address_table()
%var944 = bitcast [35 x i8]* @gsxtmnanovg52 to i8*
%var945 = bitcast [43 x i8]* @gsxtmnanovg39 to i8*
%addytable946 = call %clsvar* @add_address_table(%mzone* %zone938, i8* %var944, i32 0, i8* %var945, i32 3, %clsvar* %addytable943)
%address-table947 = bitcast %clsvar* %addytable946 to i8*

; insert table, function and environment into closure struct
%closure.table950 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure940, i32 0, i32 0
store i8* %address-table947, i8** %closure.table950
%closure.env951 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure940, i32 0, i32 1
store i8* %envptr941, i8** %closure.env951
%closure.func952 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure940, i32 0, i32 2
store void (i8*, i8*, %NVGpaint*)* @print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ__819, void (i8*, i8*, %NVGpaint*)** %closure.func952
%closure_size953 = call i64 @llvm_zone_mark_size(%mzone* %zone938)
call void @llvm_zone_ptr_set_size(i8* %clsptr939, i64 %closure_size953)
%wrapper_ptr954 = call i8* @llvm_zone_malloc(%mzone* %zone938, i64 8)
%closure_wrapper955 = bitcast i8* %wrapper_ptr954 to { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}**
store { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure940, { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** %closure_wrapper955

; let value assignment
%print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** %closure_wrapper955, { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** %closure_wrapper955
store { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** %print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ, { i8*, i8*, void (i8*, i8*, %NVGpaint*)*}*** %print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ
%tmp_envptr949 = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGpaint*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGpaint*)*}***}* %environment942, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}*** %print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQPtr, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}**** %tmp_envptr949


%val958 = load {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}**, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}*** %print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQPtr
ret {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** %val958
}


@print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** @print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ(%NVGpaint* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}*, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGpaint*)*,  void (i8*, i8*, %NVGpaint*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGpaint* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_native(%NVGpaint* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}*, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGpaint*)*,  void (i8*, i8*, %NVGpaint*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGpaint* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var959 = bitcast [88 x i8]* @gsxtmnanovg53 to i8*
call i32 (i8*, ...) @printf(i8* %var959)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGpaint*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}*, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGpaint*)*,  void (i8*, i8*, %NVGpaint*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGpaint* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGpaint*}*
%arg_p_0 = getelementptr {%NVGpaint*}, {%NVGpaint*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGpaint*, %NVGpaint** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHcGFpbnQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}*, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}, {i8*, i8*, void (i8*, i8*, %NVGpaint*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGpaint*)*,  void (i8*, i8*, %NVGpaint*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGpaint* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@NVG_CCW = dllexport global i32 1
@NVG_CW = dllexport global i32 2
@NVG_SOLID = dllexport global i32 1
@NVG_HOLE = dllexport global i32 2
@NVG_BUTT = dllexport global i32 0
@NVG_ROUND = dllexport global i32 1
@NVG_SQUARE = dllexport global i32 2
@NVG_BEVEL = dllexport global i32 3
@NVG_MITER = dllexport global i32 4
@NVG_ALIGN_LEFT = dllexport global i32 zeroinitializer
@NVG_ALIGN_CENTER = dllexport global i32 zeroinitializer
@NVG_ALIGN_RIGHT = dllexport global i32 zeroinitializer
@NVG_ALIGN_TOP = dllexport global i32 zeroinitializer
@NVG_ALIGN_MIDDLE = dllexport global i32 zeroinitializer
@NVG_ALIGN_BOTTOM = dllexport global i32 zeroinitializer
@NVG_ALIGN_BASELINE = dllexport global i32 zeroinitializer
@NVG_ZERO = dllexport global i32 zeroinitializer
@NVG_ONE = dllexport global i32 zeroinitializer
@NVG_SRC_COLOR = dllexport global i32 zeroinitializer
@NVG_ONE_MINUS_SRC_COLOR = dllexport global i32 zeroinitializer
@NVG_DST_COLOR = dllexport global i32 zeroinitializer
@NVG_ONE_MINUS_DST_COLOR = dllexport global i32 zeroinitializer
@NVG_SRC_ALPHA = dllexport global i32 zeroinitializer
@NVG_ONE_MINUS_SRC_ALPHA = dllexport global i32 zeroinitializer
@NVG_DST_ALPHA = dllexport global i32 zeroinitializer
@NVG_ONE_MINUS_DST_ALPHA = dllexport global i32 zeroinitializer
@NVG_SRC_ALPHA_SATURATE = dllexport global i32 zeroinitializer
@NVG_SOURCE_OVER = dllexport global i32 0
@NVG_SOURCE_IN = dllexport global i32 1
@NVG_SOURCE_OUT = dllexport global i32 2
@NVG_ATOP = dllexport global i32 3
@NVG_DESTINATION_OVER = dllexport global i32 4
@NVG_DESTINATION_IN = dllexport global i32 5
@NVG_DESTINATION_OUT = dllexport global i32 6
@NVG_DESTINATION_ATOP = dllexport global i32 7
@NVG_LIGHTER = dllexport global i32 8
@NVG_COPY = dllexport global i32 9
@NVG_XOR = dllexport global i32 10
%NVGcompositeOperationState = type {i32,i32,i32,i32}
@gsxtmnanovg54 = hidden constant [94 x i8] c"NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd\00"
@gsxtmnanovg55 = hidden constant [75 x i8] c"{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**\00"
define dllexport fastcc %NVGcompositeOperationState* @NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd__960(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone961 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***}*
%NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJdPtr_ = getelementptr {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***}, {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJdPtr = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**** %NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr


%tzone966 = load i8*, i8** %_impzPtr
%zone967 = bitcast i8* %tzone966 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGcompositeOperationState*
%tzone962 = load i8*, i8** %_impzPtr
%zone963 = bitcast i8* %tzone962 to %mzone*
%dat964 = call i8* @llvm_zone_malloc(%mzone* %zone963, i64 16)
call i8* @memset(i8* %dat964, i32 0, i64 16)
%val965 = bitcast i8* %dat964 to %NVGcompositeOperationState*

; let value assignment
%obj = select i1 true, %NVGcompositeOperationState* %val965, %NVGcompositeOperationState* %val965
store %NVGcompositeOperationState* %obj, %NVGcompositeOperationState** %objPtr

%val968 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val969 = load i32, i32* %arg_0Ptr
; set tuple
%val970 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val968, i64 0, i32 0
store i32 %val969, i32* %val970
%val971 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val972 = load i32, i32* %arg_1Ptr
; set tuple
%val973 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val971, i64 0, i32 1
store i32 %val972, i32* %val973
%val974 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val975 = load i32, i32* %arg_2Ptr
; set tuple
%val976 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val974, i64 0, i32 2
store i32 %val975, i32* %val976
%val977 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val978 = load i32, i32* %arg_3Ptr
; set tuple
%val979 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val977, i64 0, i32 3
store i32 %val978, i32* %val979
%val980 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
ret %NVGcompositeOperationState* %val980
}
@gsxtmnanovg56 = hidden constant [147 x i8] c"NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** @NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1000 = load i8*, i8** %_impzPtr
%zone1001 = bitcast i8* %tzone1000 to %mzone*

; let assign value to symbol NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd
%dat_NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone1001, i64 8)
%NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJdPtr = bitcast i8* %dat_NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd to { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***
%tzone981 = load i8*, i8** %_impzPtr
%zone982 = bitcast i8* %tzone981 to %mzone*
call void @llvm_zone_mark(%mzone* %zone982)
; malloc closure structure
%clsptr983 = call i8* @llvm_zone_malloc(%mzone* %zone982, i64 24)
%closure984 = bitcast i8* %clsptr983 to { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr985 = call i8* @llvm_zone_malloc(%mzone* %zone982, i64 8)
%environment986 = bitcast i8* %envptr985 to {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable987 = call %clsvar* @new_address_table()
%var988 = bitcast [94 x i8]* @gsxtmnanovg54 to i8*
%var989 = bitcast [75 x i8]* @gsxtmnanovg55 to i8*
%addytable990 = call %clsvar* @add_address_table(%mzone* %zone982, i8* %var988, i32 0, i8* %var989, i32 3, %clsvar* %addytable987)
%address-table991 = bitcast %clsvar* %addytable990 to i8*

; insert table, function and environment into closure struct
%closure.table994 = getelementptr { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure984, i32 0, i32 0
store i8* %address-table991, i8** %closure.table994
%closure.env995 = getelementptr { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure984, i32 0, i32 1
store i8* %envptr985, i8** %closure.env995
%closure.func996 = getelementptr { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure984, i32 0, i32 2
store %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)* @NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd__960, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)** %closure.func996
%closure_size997 = call i64 @llvm_zone_mark_size(%mzone* %zone982)
call void @llvm_zone_ptr_set_size(i8* %clsptr983, i64 %closure_size997)
%wrapper_ptr998 = call i8* @llvm_zone_malloc(%mzone* %zone982, i64 8)
%closure_wrapper999 = bitcast i8* %wrapper_ptr998 to { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**
store { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure984, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure_wrapper999

; let value assignment
%NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd = select i1 true, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure_wrapper999, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure_wrapper999
store { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*** %NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJdPtr

; add data to environment
; don't need to alloc for env var NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd
%tmp_envptr993 = getelementptr {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***}, {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***}* %environment986, i32 0, i32 0
store {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*** %NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJdPtr, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**** %tmp_envptr993


%val1002 = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*** %NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJdPtr
ret {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %val1002
}


@NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** @NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGcompositeOperationState* @NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*,  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
ret %NVGcompositeOperationState* %result
}


define dllexport ccc %NVGcompositeOperationState* @NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_native(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*,  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
ret %NVGcompositeOperationState* %result
}


define dllexport ccc i8*  @NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1003 = bitcast [147 x i8]* @gsxtmnanovg56 to i8*
call i32 (i8*, ...) @printf(i8* %var1003)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1004 = bitcast [147 x i8]* @gsxtmnanovg56 to i8*
call i32 (i8*, ...) @printf(i8* %var1004)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1005 = bitcast [147 x i8]* @gsxtmnanovg56 to i8*
call i32 (i8*, ...) @printf(i8* %var1005)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var1006 = bitcast [147 x i8]* @gsxtmnanovg56 to i8*
call i32 (i8*, ...) @printf(i8* %var1006)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*,  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
%tmpres = bitcast %NVGcompositeOperationState* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i32, i32}*
%arg_p_0 = getelementptr {i32, i32, i32, i32}, {i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i32, i32}, {i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i32, i32}, {i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i32, i32}, {i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*,  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg57 = hidden constant [96 x i8] c"NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd\00"
define dllexport fastcc %NVGcompositeOperationState* @NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd__1007(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1008 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***}*
%NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJdPtr_ = getelementptr {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***}, {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJdPtr = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**** %NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr


%tzone1013 = load i8*, i8** %_impzPtr
%zone1014 = bitcast i8* %tzone1013 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGcompositeOperationState*
%tzone1009 = load i8*, i8** %_impzPtr
%zone1010 = bitcast i8* %tzone1009 to %mzone*
%dat1011 = call i8* @llvm_zone_malloc(%mzone* %zone1010, i64 16)
call i8* @memset(i8* %dat1011, i32 0, i64 16)
%val1012 = bitcast i8* %dat1011 to %NVGcompositeOperationState*

; let value assignment
%obj = select i1 true, %NVGcompositeOperationState* %val1012, %NVGcompositeOperationState* %val1012
store %NVGcompositeOperationState* %obj, %NVGcompositeOperationState** %objPtr

%val1015 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val1016 = load i32, i32* %arg_0Ptr
; set tuple
%val1017 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1015, i64 0, i32 0
store i32 %val1016, i32* %val1017
%val1018 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val1019 = load i32, i32* %arg_1Ptr
; set tuple
%val1020 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1018, i64 0, i32 1
store i32 %val1019, i32* %val1020
%val1021 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val1022 = load i32, i32* %arg_2Ptr
; set tuple
%val1023 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1021, i64 0, i32 2
store i32 %val1022, i32* %val1023
%val1024 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val1025 = load i32, i32* %arg_3Ptr
; set tuple
%val1026 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1024, i64 0, i32 3
store i32 %val1025, i32* %val1026
%val1027 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
ret %NVGcompositeOperationState* %val1027
}
@gsxtmnanovg58 = hidden constant [149 x i8] c"NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** @NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1047 = load i8*, i8** %_impzPtr
%zone1048 = bitcast i8* %tzone1047 to %mzone*

; let assign value to symbol NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd
%dat_NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone1048, i64 8)
%NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJdPtr = bitcast i8* %dat_NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd to { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***
%tzone1028 = load i8*, i8** %_impzPtr
%zone1029 = bitcast i8* %tzone1028 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1029)
; malloc closure structure
%clsptr1030 = call i8* @llvm_zone_malloc(%mzone* %zone1029, i64 24)
%closure1031 = bitcast i8* %clsptr1030 to { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr1032 = call i8* @llvm_zone_malloc(%mzone* %zone1029, i64 8)
%environment1033 = bitcast i8* %envptr1032 to {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable1034 = call %clsvar* @new_address_table()
%var1035 = bitcast [96 x i8]* @gsxtmnanovg57 to i8*
%var1036 = bitcast [75 x i8]* @gsxtmnanovg55 to i8*
%addytable1037 = call %clsvar* @add_address_table(%mzone* %zone1029, i8* %var1035, i32 0, i8* %var1036, i32 3, %clsvar* %addytable1034)
%address-table1038 = bitcast %clsvar* %addytable1037 to i8*

; insert table, function and environment into closure struct
%closure.table1041 = getelementptr { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure1031, i32 0, i32 0
store i8* %address-table1038, i8** %closure.table1041
%closure.env1042 = getelementptr { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure1031, i32 0, i32 1
store i8* %envptr1032, i8** %closure.env1042
%closure.func1043 = getelementptr { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure1031, i32 0, i32 2
store %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)* @NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd__1007, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)** %closure.func1043
%closure_size1044 = call i64 @llvm_zone_mark_size(%mzone* %zone1029)
call void @llvm_zone_ptr_set_size(i8* %clsptr1030, i64 %closure_size1044)
%wrapper_ptr1045 = call i8* @llvm_zone_malloc(%mzone* %zone1029, i64 8)
%closure_wrapper1046 = bitcast i8* %wrapper_ptr1045 to { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**
store { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure1031, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure_wrapper1046

; let value assignment
%NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd = select i1 true, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure_wrapper1046, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure_wrapper1046
store { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*** %NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJdPtr

; add data to environment
; don't need to alloc for env var NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd
%tmp_envptr1040 = getelementptr {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***}, {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***}* %environment1033, i32 0, i32 0
store {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*** %NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJdPtr, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**** %tmp_envptr1040


%val1049 = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*** %NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJdPtr
ret {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %val1049
}


@NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** @NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGcompositeOperationState* @NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*,  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
ret %NVGcompositeOperationState* %result
}


define dllexport ccc %NVGcompositeOperationState* @NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_native(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*,  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
ret %NVGcompositeOperationState* %result
}


define dllexport ccc i8*  @NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1050 = bitcast [149 x i8]* @gsxtmnanovg58 to i8*
call i32 (i8*, ...) @printf(i8* %var1050)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1051 = bitcast [149 x i8]* @gsxtmnanovg58 to i8*
call i32 (i8*, ...) @printf(i8* %var1051)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1052 = bitcast [149 x i8]* @gsxtmnanovg58 to i8*
call i32 (i8*, ...) @printf(i8* %var1052)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var1053 = bitcast [149 x i8]* @gsxtmnanovg58 to i8*
call i32 (i8*, ...) @printf(i8* %var1053)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*,  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
%tmpres = bitcast %NVGcompositeOperationState* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i32, i32}*
%arg_p_0 = getelementptr {i32, i32, i32, i32}, {i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i32, i32}, {i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i32, i32}, {i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i32, i32}, {i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_z_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*,  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg59 = hidden constant [96 x i8] c"NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd\00"
define dllexport fastcc %NVGcompositeOperationState* @NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd__1054(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1055 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***}*
%NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJdPtr_ = getelementptr {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***}, {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJdPtr = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**** %NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr


%tzone1058 = load i8*, i8** %_impzPtr
%zone1059 = bitcast i8* %tzone1058 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGcompositeOperationState*
%dat1056 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat1056, i32 0, i64 16)
%val1057 = bitcast i8* %dat1056 to %NVGcompositeOperationState*

; let value assignment
%obj = select i1 true, %NVGcompositeOperationState* %val1057, %NVGcompositeOperationState* %val1057
store %NVGcompositeOperationState* %obj, %NVGcompositeOperationState** %objPtr

%val1060 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val1061 = load i32, i32* %arg_0Ptr
; set tuple
%val1062 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1060, i64 0, i32 0
store i32 %val1061, i32* %val1062
%val1063 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val1064 = load i32, i32* %arg_1Ptr
; set tuple
%val1065 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1063, i64 0, i32 1
store i32 %val1064, i32* %val1065
%val1066 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val1067 = load i32, i32* %arg_2Ptr
; set tuple
%val1068 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1066, i64 0, i32 2
store i32 %val1067, i32* %val1068
%val1069 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val1070 = load i32, i32* %arg_3Ptr
; set tuple
%val1071 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1069, i64 0, i32 3
store i32 %val1070, i32* %val1071
%val1072 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
ret %NVGcompositeOperationState* %val1072
}
@gsxtmnanovg60 = hidden constant [149 x i8] c"NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** @NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1092 = load i8*, i8** %_impzPtr
%zone1093 = bitcast i8* %tzone1092 to %mzone*

; let assign value to symbol NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd
%dat_NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone1093, i64 8)
%NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJdPtr = bitcast i8* %dat_NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd to { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***
%tzone1073 = load i8*, i8** %_impzPtr
%zone1074 = bitcast i8* %tzone1073 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1074)
; malloc closure structure
%clsptr1075 = call i8* @llvm_zone_malloc(%mzone* %zone1074, i64 24)
%closure1076 = bitcast i8* %clsptr1075 to { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr1077 = call i8* @llvm_zone_malloc(%mzone* %zone1074, i64 8)
%environment1078 = bitcast i8* %envptr1077 to {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable1079 = call %clsvar* @new_address_table()
%var1080 = bitcast [96 x i8]* @gsxtmnanovg59 to i8*
%var1081 = bitcast [75 x i8]* @gsxtmnanovg55 to i8*
%addytable1082 = call %clsvar* @add_address_table(%mzone* %zone1074, i8* %var1080, i32 0, i8* %var1081, i32 3, %clsvar* %addytable1079)
%address-table1083 = bitcast %clsvar* %addytable1082 to i8*

; insert table, function and environment into closure struct
%closure.table1086 = getelementptr { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure1076, i32 0, i32 0
store i8* %address-table1083, i8** %closure.table1086
%closure.env1087 = getelementptr { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure1076, i32 0, i32 1
store i8* %envptr1077, i8** %closure.env1087
%closure.func1088 = getelementptr { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure1076, i32 0, i32 2
store %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)* @NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd__1054, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)** %closure.func1088
%closure_size1089 = call i64 @llvm_zone_mark_size(%mzone* %zone1074)
call void @llvm_zone_ptr_set_size(i8* %clsptr1075, i64 %closure_size1089)
%wrapper_ptr1090 = call i8* @llvm_zone_malloc(%mzone* %zone1074, i64 8)
%closure_wrapper1091 = bitcast i8* %wrapper_ptr1090 to { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**
store { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure1076, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure_wrapper1091

; let value assignment
%NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd = select i1 true, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure_wrapper1091, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure_wrapper1091
store { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*** %NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJdPtr

; add data to environment
; don't need to alloc for env var NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd
%tmp_envptr1085 = getelementptr {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***}, {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}***}* %environment1078, i32 0, i32 0
store {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*** %NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJdPtr, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**** %tmp_envptr1085


%val1094 = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*** %NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJdPtr
ret {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %val1094
}


@NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** @NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGcompositeOperationState* @NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*,  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
ret %NVGcompositeOperationState* %result
}


define dllexport ccc %NVGcompositeOperationState* @NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_native(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*,  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
ret %NVGcompositeOperationState* %result
}


define dllexport ccc i8*  @NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1095 = bitcast [149 x i8]* @gsxtmnanovg60 to i8*
call i32 (i8*, ...) @printf(i8* %var1095)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1096 = bitcast [149 x i8]* @gsxtmnanovg60 to i8*
call i32 (i8*, ...) @printf(i8* %var1096)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1097 = bitcast [149 x i8]* @gsxtmnanovg60 to i8*
call i32 (i8*, ...) @printf(i8* %var1097)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var1098 = bitcast [149 x i8]* @gsxtmnanovg60 to i8*
call i32 (i8*, ...) @printf(i8* %var1098)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*,  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
%tmpres = bitcast %NVGcompositeOperationState* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i32, i32}*
%arg_p_0 = getelementptr {i32, i32, i32, i32}, {i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i32, i32}, {i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i32, i32}, {i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i32, i32}, {i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_h_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}*, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)*,  %NVGcompositeOperationState* (i8*, i8*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg61 = hidden constant [3 x i8] c"%s\00"
@gsxtmnanovg62 = hidden constant [34 x i8] c"<NVGcompositeOperationState:null>\00"
@gsxtmnanovg63 = hidden constant [29 x i8] c"<NVGcompositeOperationState:\00"
@gsxtmnanovg64 = hidden constant [2 x i8] c",\00"
@gsxtmnanovg65 = hidden constant [2 x i8] c">\00"
@gsxtmnanovg66 = hidden constant [66 x i8] c"toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ\00"
@gsxtmnanovg67 = hidden constant [65 x i8] c"{i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ__1099(i8* %_impz,i8* %_impenv, %NVGcompositeOperationState* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1100 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}***}*
%toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQPtr = load {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}***, {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}**** %toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQPtr_

; setup arguments
%xPtr = alloca %NVGcompositeOperationState*
store %NVGcompositeOperationState* %x, %NVGcompositeOperationState** %xPtr


%val1102 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %xPtr
%val1103 = icmp eq %NVGcompositeOperationState* %val1102, null
br i1 %val1103, label %then1101, label %else1101

then1101:
%zone1104 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone1104)
%zone_ptr1105 = bitcast %mzone* %zone1104 to i8*
store i8* %zone_ptr1105, i8** %_impzPtr
%tzone1115 = load i8*, i8** %_impzPtr
%zone1116 = bitcast i8* %tzone1115 to %mzone*

; let assign value to symbol res0
%res0Ptr = alloca %String*
%tzone1120 = load i8*, i8** %_impzPtr
%zone1121 = bitcast i8* %tzone1120 to %mzone*

; let assign value to symbol zone0
%zone0Ptr = alloca %mzone*
%tzone1123 = load i8*, i8** %_impzPtr
%zone1124 = bitcast i8* %tzone1123 to %mzone*

; let assign value to symbol newz0
%newz0Ptr = alloca %mzone*
%tzone1107 = load i8*, i8** %_impzPtr
%zone1108 = bitcast i8* %tzone1107 to %mzone*

; let assign value to symbol xx_t_mst
%xx_t_mstPtr = alloca i8*
%dat1106 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst = select i1 true, i8* %dat1106, i8* %dat1106
store i8* %xx_t_mst, i8** %xx_t_mstPtr

%val1109 = load i8*, i8** %xx_t_mstPtr
%var1110 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1111 = bitcast [34 x i8]* @gsxtmnanovg62 to i8*

%val1112 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1109, i8* %var1110, i8* %var1111)
%val1113 = load i8*, i8** %xx_t_mstPtr
%res1114 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1113)

; let value assignment
%res0 = select i1 true, %String* %res1114, %String* %res1114
store %String* %res0, %String** %res0Ptr

%oldzone1117 = call %mzone* @llvm_pop_zone_stack()
%newzone1118 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr1119 = bitcast %mzone* %newzone1118 to i8*
store i8* %zone_ptr1119, i8** %_impzPtr

; let value assignment
%zone0 = select i1 true, %mzone* %oldzone1117, %mzone* %oldzone1117
store %mzone* %zone0, %mzone** %zone0Ptr

%res1122 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz0 = select i1 true, %mzone* %res1122, %mzone* %res1122
store %mzone* %newz0, %mzone** %newz0Ptr

%tzone1129 = load i8*, i8** %_impzPtr
%zone1130 = bitcast i8* %tzone1129 to %mzone*

; let assign value to symbol rescopy0
%rescopy0Ptr = alloca %String*
%tzone1135 = load i8*, i8** %_impzPtr
%zone1136 = bitcast i8* %tzone1135 to %mzone*

; let assign value to symbol hook
%hookPtr = alloca {i64,i8*,i8*}*
%tzone1138 = load i8*, i8** %_impzPtr
%zone1139 = bitcast i8* %tzone1138 to %mzone*

; let assign value to symbol f
%fPtr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val1125 = load %String*, %String** %res0Ptr
%val1126 = load %mzone*, %mzone** %zone0Ptr
%val1127 = load %mzone*, %mzone** %newz0Ptr
%res1128 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val1125, %mzone* %val1126, %mzone* %val1127)

; let value assignment
%rescopy0 = select i1 true, %String* %res1128, %String* %res1128
store %String* %rescopy0, %String** %rescopy0Ptr

%val1131 = load %mzone*, %mzone** %zone0Ptr
; tuple ref
%val1132 = getelementptr %mzone, %mzone* %val1131, i64 0, i32 4
%val1133 = load i8*, i8** %val1132
%val1134 = bitcast i8* %val1133 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val1134, {i64,i8*,i8*}* %val1134
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%null1137 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null1137, {i8*, i8*, void (i8*, i8*)*}** %null1137
store {i8*, i8*, void (i8*, i8*)*}** %f, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; promote local stack var allocations
%tzone1175 = load i8*, i8** %_impzPtr
%zone1176 = bitcast i8* %tzone1175 to %mzone*
%ifptr1165 = alloca i1
%ifptr1141 = alloca i1
; while loop
%val1142 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val1143 = icmp eq {i64,i8*,i8*}* %val1142, null
br i1 %val1143, label %then1141, label %else1141

then1141:
%res1144 = call ccc i1 @impc_false()
store i1 %res1144, i1* %ifptr1141
br label %ifcont1141

else1141:
%res1145 = call ccc i1 @impc_true()
store i1 %res1145, i1* %ifptr1141
br label %ifcont1141

ifcont1141:
%ifres1146 = load i1, i1* %ifptr1141

br i1 %ifres1146, label %loop1140, label %after1140

loop1140:
; do set!
%val1147 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val1148 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1147, i64 0, i32 1
%val1149 = load i8*, i8** %val1148
%val1150 = bitcast i8* %val1149 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val1150, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; apply closure 
%vval1151 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val1152 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval1151
%fPtr1153 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1152, i32 0, i32 2
%ePtr1154 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1152, i32 0, i32 1
%f1155 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr1153
%e1156 = load i8*, i8** %ePtr1154
%tzone1157 = load i8*, i8** %_impzPtr
%zone1158 = bitcast i8* %tzone1157 to %mzone*
%z1159 = bitcast %mzone* %zone1158 to i8*
tail call fastcc void %f1155(i8* %z1159, i8* %e1156)
; do set!
%val1161 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val1162 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1161, i64 0, i32 2
%val1163 = load i8*, i8** %val1162
%val1164 = bitcast i8* %val1163 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val1164, {i64,i8*,i8*}** %hookPtr
%val1166 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val1167 = icmp eq {i64,i8*,i8*}* %val1166, null
br i1 %val1167, label %then1165, label %else1165

then1165:
%res1168 = call ccc i1 @impc_false()
store i1 %res1168, i1* %ifptr1165
br label %ifcont1165

else1165:
%res1169 = call ccc i1 @impc_true()
store i1 %res1169, i1* %ifptr1165
br label %ifcont1165

ifcont1165:
%ifres1170 = load i1, i1* %ifptr1165

br i1 %ifres1170, label %loop1140, label %after1140

after1140:
%val1172 = load %mzone*, %mzone** %zone0Ptr
call ccc void @llvm_zone_destroy(%mzone* %val1172)
%val1174 = load %String*, %String** %rescopy0Ptr
ret %String* %val1174

else1101:
%zone1177 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone1177)
%zone_ptr1178 = bitcast %mzone* %zone1177 to i8*
store i8* %zone_ptr1178, i8** %_impzPtr
%tzone1248 = load i8*, i8** %_impzPtr
%zone1249 = bitcast i8* %tzone1248 to %mzone*

; let assign value to symbol res1
%res1Ptr = alloca %String*
%tzone1253 = load i8*, i8** %_impzPtr
%zone1254 = bitcast i8* %tzone1253 to %mzone*

; let assign value to symbol zone1
%zone1Ptr = alloca %mzone*
%tzone1256 = load i8*, i8** %_impzPtr
%zone1257 = bitcast i8* %tzone1256 to %mzone*

; let assign value to symbol newz1
%newz1Ptr = alloca %mzone*
%tzone1180 = load i8*, i8** %_impzPtr
%zone1181 = bitcast i8* %tzone1180 to %mzone*

; let assign value to symbol xx_t_mst_s_1
%xx_t_mst_s_1Ptr = alloca i8*
%dat1179 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_1 = select i1 true, i8* %dat1179, i8* %dat1179
store i8* %xx_t_mst_s_1, i8** %xx_t_mst_s_1Ptr

%val1182 = load i8*, i8** %xx_t_mst_s_1Ptr
%var1183 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1184 = bitcast [29 x i8]* @gsxtmnanovg63 to i8*

%val1185 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1182, i8* %var1183, i8* %var1184)
%val1186 = load i8*, i8** %xx_t_mst_s_1Ptr
%res1187 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1186)
%val1188 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %xPtr
; tuple ref
%val1189 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1188, i64 0, i32 0
%val1190 = load i32, i32* %val1189
%res1191 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val1190)
%res1192 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1187, %String* %res1191)
%tzone1194 = load i8*, i8** %_impzPtr
%zone1195 = bitcast i8* %tzone1194 to %mzone*

; let assign value to symbol xx_t_mst_s_2
%xx_t_mst_s_2Ptr = alloca i8*
%dat1193 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_2 = select i1 true, i8* %dat1193, i8* %dat1193
store i8* %xx_t_mst_s_2, i8** %xx_t_mst_s_2Ptr

%val1196 = load i8*, i8** %xx_t_mst_s_2Ptr
%var1197 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1198 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val1199 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1196, i8* %var1197, i8* %var1198)
%val1200 = load i8*, i8** %xx_t_mst_s_2Ptr
%res1201 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1200)
%res1202 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1192, %String* %res1201)
%val1203 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %xPtr
; tuple ref
%val1204 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1203, i64 0, i32 1
%val1205 = load i32, i32* %val1204
%res1206 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val1205)
%res1207 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1202, %String* %res1206)
%tzone1209 = load i8*, i8** %_impzPtr
%zone1210 = bitcast i8* %tzone1209 to %mzone*

; let assign value to symbol xx_t_mst_s_3
%xx_t_mst_s_3Ptr = alloca i8*
%dat1208 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_3 = select i1 true, i8* %dat1208, i8* %dat1208
store i8* %xx_t_mst_s_3, i8** %xx_t_mst_s_3Ptr

%val1211 = load i8*, i8** %xx_t_mst_s_3Ptr
%var1212 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1213 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val1214 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1211, i8* %var1212, i8* %var1213)
%val1215 = load i8*, i8** %xx_t_mst_s_3Ptr
%res1216 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1215)
%res1217 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1207, %String* %res1216)
%val1218 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %xPtr
; tuple ref
%val1219 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1218, i64 0, i32 2
%val1220 = load i32, i32* %val1219
%res1221 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val1220)
%res1222 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1217, %String* %res1221)
%tzone1224 = load i8*, i8** %_impzPtr
%zone1225 = bitcast i8* %tzone1224 to %mzone*

; let assign value to symbol xx_t_mst_s_4
%xx_t_mst_s_4Ptr = alloca i8*
%dat1223 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_4 = select i1 true, i8* %dat1223, i8* %dat1223
store i8* %xx_t_mst_s_4, i8** %xx_t_mst_s_4Ptr

%val1226 = load i8*, i8** %xx_t_mst_s_4Ptr
%var1227 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1228 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val1229 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1226, i8* %var1227, i8* %var1228)
%val1230 = load i8*, i8** %xx_t_mst_s_4Ptr
%res1231 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1230)
%res1232 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1222, %String* %res1231)
%val1233 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %xPtr
; tuple ref
%val1234 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1233, i64 0, i32 3
%val1235 = load i32, i32* %val1234
%res1236 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val1235)
%res1237 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1232, %String* %res1236)
%tzone1239 = load i8*, i8** %_impzPtr
%zone1240 = bitcast i8* %tzone1239 to %mzone*

; let assign value to symbol xx_t_mst_s_5
%xx_t_mst_s_5Ptr = alloca i8*
%dat1238 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_5 = select i1 true, i8* %dat1238, i8* %dat1238
store i8* %xx_t_mst_s_5, i8** %xx_t_mst_s_5Ptr

%val1241 = load i8*, i8** %xx_t_mst_s_5Ptr
%var1242 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1243 = bitcast [2 x i8]* @gsxtmnanovg65 to i8*

%val1244 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1241, i8* %var1242, i8* %var1243)
%val1245 = load i8*, i8** %xx_t_mst_s_5Ptr
%res1246 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1245)
%res1247 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1237, %String* %res1246)

; let value assignment
%res1 = select i1 true, %String* %res1247, %String* %res1247
store %String* %res1, %String** %res1Ptr

%oldzone1250 = call %mzone* @llvm_pop_zone_stack()
%newzone1251 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr1252 = bitcast %mzone* %newzone1251 to i8*
store i8* %zone_ptr1252, i8** %_impzPtr

; let value assignment
%zone1 = select i1 true, %mzone* %oldzone1250, %mzone* %oldzone1250
store %mzone* %zone1, %mzone** %zone1Ptr

%res1255 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz1 = select i1 true, %mzone* %res1255, %mzone* %res1255
store %mzone* %newz1, %mzone** %newz1Ptr

%tzone1262 = load i8*, i8** %_impzPtr
%zone1263 = bitcast i8* %tzone1262 to %mzone*

; let assign value to symbol rescopy1
%rescopy1Ptr = alloca %String*
%tzone1268 = load i8*, i8** %_impzPtr
%zone1269 = bitcast i8* %tzone1268 to %mzone*

; let assign value to symbol hook_s_6
%hook_s_6Ptr = alloca {i64,i8*,i8*}*
%tzone1271 = load i8*, i8** %_impzPtr
%zone1272 = bitcast i8* %tzone1271 to %mzone*

; let assign value to symbol f_s_7
%f_s_7Ptr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val1258 = load %String*, %String** %res1Ptr
%val1259 = load %mzone*, %mzone** %zone1Ptr
%val1260 = load %mzone*, %mzone** %newz1Ptr
%res1261 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val1258, %mzone* %val1259, %mzone* %val1260)

; let value assignment
%rescopy1 = select i1 true, %String* %res1261, %String* %res1261
store %String* %rescopy1, %String** %rescopy1Ptr

%val1264 = load %mzone*, %mzone** %zone1Ptr
; tuple ref
%val1265 = getelementptr %mzone, %mzone* %val1264, i64 0, i32 4
%val1266 = load i8*, i8** %val1265
%val1267 = bitcast i8* %val1266 to {i64,i8*,i8*}*

; let value assignment
%hook_s_6 = select i1 true, {i64,i8*,i8*}* %val1267, {i64,i8*,i8*}* %val1267
store {i64,i8*,i8*}* %hook_s_6, {i64,i8*,i8*}** %hook_s_6Ptr

%null1270 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f_s_7 = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null1270, {i8*, i8*, void (i8*, i8*)*}** %null1270
store {i8*, i8*, void (i8*, i8*)*}** %f_s_7, {i8*, i8*, void (i8*, i8*)*}*** %f_s_7Ptr

; promote local stack var allocations
%tzone1308 = load i8*, i8** %_impzPtr
%zone1309 = bitcast i8* %tzone1308 to %mzone*
%ifptr1298 = alloca i1
%ifptr1274 = alloca i1
; while loop
%val1275 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_6Ptr
%val1276 = icmp eq {i64,i8*,i8*}* %val1275, null
br i1 %val1276, label %then1274, label %else1274

then1274:
%res1277 = call ccc i1 @impc_false()
store i1 %res1277, i1* %ifptr1274
br label %ifcont1274

else1274:
%res1278 = call ccc i1 @impc_true()
store i1 %res1278, i1* %ifptr1274
br label %ifcont1274

ifcont1274:
%ifres1279 = load i1, i1* %ifptr1274

br i1 %ifres1279, label %loop1273, label %after1273

loop1273:
; do set!
%val1280 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_6Ptr
; tuple ref
%val1281 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1280, i64 0, i32 1
%val1282 = load i8*, i8** %val1281
%val1283 = bitcast i8* %val1282 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val1283, {i8*, i8*, void (i8*, i8*)*}*** %f_s_7Ptr

; apply closure 
%vval1284 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %f_s_7Ptr
%val1285 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval1284
%fPtr1286 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1285, i32 0, i32 2
%ePtr1287 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1285, i32 0, i32 1
%f1288 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr1286
%e1289 = load i8*, i8** %ePtr1287
%tzone1290 = load i8*, i8** %_impzPtr
%zone1291 = bitcast i8* %tzone1290 to %mzone*
%z1292 = bitcast %mzone* %zone1291 to i8*
tail call fastcc void %f1288(i8* %z1292, i8* %e1289)
; do set!
%val1294 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_6Ptr
; tuple ref
%val1295 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1294, i64 0, i32 2
%val1296 = load i8*, i8** %val1295
%val1297 = bitcast i8* %val1296 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val1297, {i64,i8*,i8*}** %hook_s_6Ptr
%val1299 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_6Ptr
%val1300 = icmp eq {i64,i8*,i8*}* %val1299, null
br i1 %val1300, label %then1298, label %else1298

then1298:
%res1301 = call ccc i1 @impc_false()
store i1 %res1301, i1* %ifptr1298
br label %ifcont1298

else1298:
%res1302 = call ccc i1 @impc_true()
store i1 %res1302, i1* %ifptr1298
br label %ifcont1298

ifcont1298:
%ifres1303 = load i1, i1* %ifptr1298

br i1 %ifres1303, label %loop1273, label %after1273

after1273:
%val1305 = load %mzone*, %mzone** %zone1Ptr
call ccc void @llvm_zone_destroy(%mzone* %val1305)
%val1307 = load %String*, %String** %rescopy1Ptr
ret %String* %val1307
}
@gsxtmnanovg68 = hidden constant [119 x i8] c"toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}** @toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1329 = load i8*, i8** %_impzPtr
%zone1330 = bitcast i8* %tzone1329 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ
%dat_toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone1330, i64 8)
%toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ to { i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}***
%tzone1310 = load i8*, i8** %_impzPtr
%zone1311 = bitcast i8* %tzone1310 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1311)
; malloc closure structure
%clsptr1312 = call i8* @llvm_zone_malloc(%mzone* %zone1311, i64 24)
%closure1313 = bitcast i8* %clsptr1312 to { i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}*

; malloc environment structure
%envptr1314 = call i8* @llvm_zone_malloc(%mzone* %zone1311, i64 8)
%environment1315 = bitcast i8* %envptr1314 to {{i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}***}*

; malloc closure address table
%addytable1316 = call %clsvar* @new_address_table()
%var1317 = bitcast [66 x i8]* @gsxtmnanovg66 to i8*
%var1318 = bitcast [65 x i8]* @gsxtmnanovg67 to i8*
%addytable1319 = call %clsvar* @add_address_table(%mzone* %zone1311, i8* %var1317, i32 0, i8* %var1318, i32 3, %clsvar* %addytable1316)
%address-table1320 = bitcast %clsvar* %addytable1319 to i8*

; insert table, function and environment into closure struct
%closure.table1323 = getelementptr { i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}, { i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure1313, i32 0, i32 0
store i8* %address-table1320, i8** %closure.table1323
%closure.env1324 = getelementptr { i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}, { i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure1313, i32 0, i32 1
store i8* %envptr1314, i8** %closure.env1324
%closure.func1325 = getelementptr { i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}, { i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure1313, i32 0, i32 2
store %String* (i8*, i8*, %NVGcompositeOperationState*)* @toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ__1099, %String* (i8*, i8*, %NVGcompositeOperationState*)** %closure.func1325
%closure_size1326 = call i64 @llvm_zone_mark_size(%mzone* %zone1311)
call void @llvm_zone_ptr_set_size(i8* %clsptr1312, i64 %closure_size1326)
%wrapper_ptr1327 = call i8* @llvm_zone_malloc(%mzone* %zone1311, i64 8)
%closure_wrapper1328 = bitcast i8* %wrapper_ptr1327 to { i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}**
store { i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure1313, { i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_wrapper1328

; let value assignment
%toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_wrapper1328, { i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_wrapper1328
store { i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}** %toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ, { i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}*** %toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ
%tmp_envptr1322 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}***}* %environment1315, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}*** %toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQPtr, {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}**** %tmp_envptr1322


%val1331 = load {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}**, {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}*** %toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}** %val1331
}


@toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}** @toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ(%NVGcompositeOperationState* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGcompositeOperationState*)*,  %String* (i8*, i8*, %NVGcompositeOperationState*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGcompositeOperationState* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_native(%NVGcompositeOperationState* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGcompositeOperationState*)*,  %String* (i8*, i8*, %NVGcompositeOperationState*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGcompositeOperationState* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1332 = bitcast [119 x i8]* @gsxtmnanovg68 to i8*
call i32 (i8*, ...) @printf(i8* %var1332)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGcompositeOperationState*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGcompositeOperationState*)*,  %String* (i8*, i8*, %NVGcompositeOperationState*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGcompositeOperationState* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGcompositeOperationState*}*
%arg_p_0 = getelementptr {%NVGcompositeOperationState*}, {%NVGcompositeOperationState*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGcompositeOperationState*)*,  %String* (i8*, i8*, %NVGcompositeOperationState*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGcompositeOperationState* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg69 = hidden constant [59 x i8] c"print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ\00"
@gsxtmnanovg70 = hidden constant [61 x i8] c"{i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ__1333(i8* %_impz,i8* %_impenv, %NVGcompositeOperationState* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1334 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}***}*
%print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQPtr = load {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}***, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}**** %print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQPtr_

; setup arguments
%xPtr = alloca %NVGcompositeOperationState*
store %NVGcompositeOperationState* %x, %NVGcompositeOperationState** %xPtr


%val1336 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %xPtr
%val1337 = icmp eq %NVGcompositeOperationState* %val1336, null
br i1 %val1337, label %then1335, label %else1335

then1335:
%var1338 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1339 = bitcast [34 x i8]* @gsxtmnanovg62 to i8*

%val1340 = call i32 (i8*, ...) @printf(i8* %var1338, i8* %var1339)
br label %ifcont1335

else1335:
%var1342 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1343 = bitcast [29 x i8]* @gsxtmnanovg63 to i8*

%val1344 = call i32 (i8*, ...) @printf(i8* %var1342, i8* %var1343)
%val1345 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %xPtr
; tuple ref
%val1346 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1345, i64 0, i32 0
%val1347 = load i32, i32* %val1346
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val1347)
%var1349 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1350 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val1351 = call i32 (i8*, ...) @printf(i8* %var1349, i8* %var1350)
%val1352 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %xPtr
; tuple ref
%val1353 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1352, i64 0, i32 1
%val1354 = load i32, i32* %val1353
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val1354)
%var1356 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1357 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val1358 = call i32 (i8*, ...) @printf(i8* %var1356, i8* %var1357)
%val1359 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %xPtr
; tuple ref
%val1360 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1359, i64 0, i32 2
%val1361 = load i32, i32* %val1360
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val1361)
%var1363 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1364 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val1365 = call i32 (i8*, ...) @printf(i8* %var1363, i8* %var1364)
%val1366 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %xPtr
; tuple ref
%val1367 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1366, i64 0, i32 3
%val1368 = load i32, i32* %val1367
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val1368)
%var1370 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1371 = bitcast [2 x i8]* @gsxtmnanovg65 to i8*

%val1372 = call i32 (i8*, ...) @printf(i8* %var1370, i8* %var1371)
br label %ifcont1335

ifcont1335:
ret void
}
@gsxtmnanovg71 = hidden constant [112 x i8] c"print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** @print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1394 = load i8*, i8** %_impzPtr
%zone1395 = bitcast i8* %tzone1394 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ
%dat_print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone1395, i64 8)
%print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ to { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}***
%tzone1375 = load i8*, i8** %_impzPtr
%zone1376 = bitcast i8* %tzone1375 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1376)
; malloc closure structure
%clsptr1377 = call i8* @llvm_zone_malloc(%mzone* %zone1376, i64 24)
%closure1378 = bitcast i8* %clsptr1377 to { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}*

; malloc environment structure
%envptr1379 = call i8* @llvm_zone_malloc(%mzone* %zone1376, i64 8)
%environment1380 = bitcast i8* %envptr1379 to {{i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}***}*

; malloc closure address table
%addytable1381 = call %clsvar* @new_address_table()
%var1382 = bitcast [59 x i8]* @gsxtmnanovg69 to i8*
%var1383 = bitcast [61 x i8]* @gsxtmnanovg70 to i8*
%addytable1384 = call %clsvar* @add_address_table(%mzone* %zone1376, i8* %var1382, i32 0, i8* %var1383, i32 3, %clsvar* %addytable1381)
%address-table1385 = bitcast %clsvar* %addytable1384 to i8*

; insert table, function and environment into closure struct
%closure.table1388 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure1378, i32 0, i32 0
store i8* %address-table1385, i8** %closure.table1388
%closure.env1389 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure1378, i32 0, i32 1
store i8* %envptr1379, i8** %closure.env1389
%closure.func1390 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure1378, i32 0, i32 2
store void (i8*, i8*, %NVGcompositeOperationState*)* @print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ__1333, void (i8*, i8*, %NVGcompositeOperationState*)** %closure.func1390
%closure_size1391 = call i64 @llvm_zone_mark_size(%mzone* %zone1376)
call void @llvm_zone_ptr_set_size(i8* %clsptr1377, i64 %closure_size1391)
%wrapper_ptr1392 = call i8* @llvm_zone_malloc(%mzone* %zone1376, i64 8)
%closure_wrapper1393 = bitcast i8* %wrapper_ptr1392 to { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}**
store { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure1378, { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_wrapper1393

; let value assignment
%print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_wrapper1393, { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_wrapper1393
store { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** %print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ, { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}*** %print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ
%tmp_envptr1387 = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}***}* %environment1380, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}*** %print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQPtr, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}**** %tmp_envptr1387


%val1396 = load {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}**, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}*** %print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQPtr
ret {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** %val1396
}


@print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** @print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ(%NVGcompositeOperationState* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}*, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGcompositeOperationState*)*,  void (i8*, i8*, %NVGcompositeOperationState*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGcompositeOperationState* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_native(%NVGcompositeOperationState* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}*, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGcompositeOperationState*)*,  void (i8*, i8*, %NVGcompositeOperationState*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGcompositeOperationState* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1397 = bitcast [112 x i8]* @gsxtmnanovg71 to i8*
call i32 (i8*, ...) @printf(i8* %var1397)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGcompositeOperationState*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}*, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGcompositeOperationState*)*,  void (i8*, i8*, %NVGcompositeOperationState*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGcompositeOperationState* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGcompositeOperationState*}*
%arg_p_0 = getelementptr {%NVGcompositeOperationState*}, {%NVGcompositeOperationState*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}*, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGcompositeOperationState*)*,  void (i8*, i8*, %NVGcompositeOperationState*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGcompositeOperationState* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg72 = hidden constant [97 x i8] c"NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0\00"
@gsxtmnanovg73 = hidden constant [74 x i8] c"{i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}**\00"
define dllexport fastcc %NVGcompositeOperationState @NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0__1398(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1399 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}***}*
%NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}***}, {{i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0Ptr = load {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}***, {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}**** %NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr


%tzone1401 = load i8*, i8** %_impzPtr
%zone1402 = bitcast i8* %tzone1401 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGcompositeOperationState*
%dat1400 = alloca %NVGcompositeOperationState, align 16

; let value assignment
%obj = select i1 true, %NVGcompositeOperationState* %dat1400, %NVGcompositeOperationState* %dat1400
store %NVGcompositeOperationState* %obj, %NVGcompositeOperationState** %objPtr

%val1403 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val1404 = load i32, i32* %arg_0Ptr
; set tuple
%val1405 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1403, i64 0, i32 0
store i32 %val1404, i32* %val1405
%val1406 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val1407 = load i32, i32* %arg_1Ptr
; set tuple
%val1408 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1406, i64 0, i32 1
store i32 %val1407, i32* %val1408
%val1409 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val1410 = load i32, i32* %arg_2Ptr
; set tuple
%val1411 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1409, i64 0, i32 2
store i32 %val1410, i32* %val1411
%val1412 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val1413 = load i32, i32* %arg_3Ptr
; set tuple
%val1414 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1412, i64 0, i32 3
store i32 %val1413, i32* %val1414
%val1415 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
; pointer ref
%val1416 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1415, i64 0
%val1417 = load %NVGcompositeOperationState, %NVGcompositeOperationState* %val1416
ret %NVGcompositeOperationState %val1417
}
@gsxtmnanovg74 = hidden constant [150 x i8] c"NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}** @NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1437 = load i8*, i8** %_impzPtr
%zone1438 = bitcast i8* %tzone1437 to %mzone*

; let assign value to symbol NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0
%dat_NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone1438, i64 8)
%NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0Ptr = bitcast i8* %dat_NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0 to { i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}***
%tzone1418 = load i8*, i8** %_impzPtr
%zone1419 = bitcast i8* %tzone1418 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1419)
; malloc closure structure
%clsptr1420 = call i8* @llvm_zone_malloc(%mzone* %zone1419, i64 24)
%closure1421 = bitcast i8* %clsptr1420 to { i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr1422 = call i8* @llvm_zone_malloc(%mzone* %zone1419, i64 8)
%environment1423 = bitcast i8* %envptr1422 to {{i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable1424 = call %clsvar* @new_address_table()
%var1425 = bitcast [97 x i8]* @gsxtmnanovg72 to i8*
%var1426 = bitcast [74 x i8]* @gsxtmnanovg73 to i8*
%addytable1427 = call %clsvar* @add_address_table(%mzone* %zone1419, i8* %var1425, i32 0, i8* %var1426, i32 3, %clsvar* %addytable1424)
%address-table1428 = bitcast %clsvar* %addytable1427 to i8*

; insert table, function and environment into closure struct
%closure.table1431 = getelementptr { i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}, { i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}* %closure1421, i32 0, i32 0
store i8* %address-table1428, i8** %closure.table1431
%closure.env1432 = getelementptr { i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}, { i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}* %closure1421, i32 0, i32 1
store i8* %envptr1422, i8** %closure.env1432
%closure.func1433 = getelementptr { i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}, { i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}* %closure1421, i32 0, i32 2
store %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)* @NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0__1398, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)** %closure.func1433
%closure_size1434 = call i64 @llvm_zone_mark_size(%mzone* %zone1419)
call void @llvm_zone_ptr_set_size(i8* %clsptr1420, i64 %closure_size1434)
%wrapper_ptr1435 = call i8* @llvm_zone_malloc(%mzone* %zone1419, i64 8)
%closure_wrapper1436 = bitcast i8* %wrapper_ptr1435 to { i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}**
store { i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}* %closure1421, { i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}** %closure_wrapper1436

; let value assignment
%NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0 = select i1 true, { i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}** %closure_wrapper1436, { i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}** %closure_wrapper1436
store { i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}** %NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0, { i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}*** %NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0
%tmp_envptr1430 = getelementptr {{i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}***}, {{i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}***}* %environment1423, i32 0, i32 0
store {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}*** %NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0Ptr, {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}**** %tmp_envptr1430


%val1439 = load {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}**, {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}*** %NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0Ptr
ret {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}** %val1439
}


@NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}** @NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGcompositeOperationState @NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}*, {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*,  %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
ret %NVGcompositeOperationState %result
}


define dllexport ccc %NVGcompositeOperationState @NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0_native(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}*, {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*,  %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
ret %NVGcompositeOperationState %result
}


define dllexport ccc void @NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i32, i32}*
%arg_p_0 = getelementptr {i32, i32, i32, i32}, {i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i32, i32}, {i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i32, i32}, {i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i32, i32}, {i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGcompositeOperationState_val_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}*, {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)*,  %NVGcompositeOperationState (i8*, i8*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg75 = hidden constant [89 x i8] c"hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd\00"
@gsxtmnanovg76 = hidden constant [85 x i8] c"{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}**\00"
define dllexport fastcc %NVGcompositeOperationState* @hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd__1444(i8* %_impz,i8* %_impenv, %NVGcompositeOperationState* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1445 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}***}*
%hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpdPtr_ = getelementptr {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}***}, {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpdPtr = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}***, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}**** %hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpdPtr_

; setup arguments
%xPtr = alloca %NVGcompositeOperationState*
store %NVGcompositeOperationState* %x, %NVGcompositeOperationState** %xPtr


%tzone1448 = load i8*, i8** %_impzPtr
%zone1449 = bitcast i8* %tzone1448 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGcompositeOperationState*
%dat1446 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat1446, i32 0, i64 16)
%val1447 = bitcast i8* %dat1446 to %NVGcompositeOperationState*

; let value assignment
%obj = select i1 true, %NVGcompositeOperationState* %val1447, %NVGcompositeOperationState* %val1447
store %NVGcompositeOperationState* %obj, %NVGcompositeOperationState** %objPtr

%val1450 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val1451 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %xPtr
; tuple ref
%val1452 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1451, i64 0, i32 0
%val1453 = load i32, i32* %val1452
; set tuple
%val1454 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1450, i64 0, i32 0
store i32 %val1453, i32* %val1454
%val1455 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val1456 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %xPtr
; tuple ref
%val1457 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1456, i64 0, i32 1
%val1458 = load i32, i32* %val1457
; set tuple
%val1459 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1455, i64 0, i32 1
store i32 %val1458, i32* %val1459
%val1460 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val1461 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %xPtr
; tuple ref
%val1462 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1461, i64 0, i32 2
%val1463 = load i32, i32* %val1462
; set tuple
%val1464 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1460, i64 0, i32 2
store i32 %val1463, i32* %val1464
%val1465 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val1466 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %xPtr
; tuple ref
%val1467 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1466, i64 0, i32 3
%val1468 = load i32, i32* %val1467
; set tuple
%val1469 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1465, i64 0, i32 3
store i32 %val1468, i32* %val1469
%val1470 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
ret %NVGcompositeOperationState* %val1470
}
@gsxtmnanovg77 = hidden constant [142 x i8] c"hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}** @hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1490 = load i8*, i8** %_impzPtr
%zone1491 = bitcast i8* %tzone1490 to %mzone*

; let assign value to symbol hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd
%dat_hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd = call i8* @llvm_zone_malloc(%mzone* %zone1491, i64 8)
%hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpdPtr = bitcast i8* %dat_hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd to { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}***
%tzone1471 = load i8*, i8** %_impzPtr
%zone1472 = bitcast i8* %tzone1471 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1472)
; malloc closure structure
%clsptr1473 = call i8* @llvm_zone_malloc(%mzone* %zone1472, i64 24)
%closure1474 = bitcast i8* %clsptr1473 to { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}*

; malloc environment structure
%envptr1475 = call i8* @llvm_zone_malloc(%mzone* %zone1472, i64 8)
%environment1476 = bitcast i8* %envptr1475 to {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}***}*

; malloc closure address table
%addytable1477 = call %clsvar* @new_address_table()
%var1478 = bitcast [89 x i8]* @gsxtmnanovg75 to i8*
%var1479 = bitcast [85 x i8]* @gsxtmnanovg76 to i8*
%addytable1480 = call %clsvar* @add_address_table(%mzone* %zone1472, i8* %var1478, i32 0, i8* %var1479, i32 3, %clsvar* %addytable1477)
%address-table1481 = bitcast %clsvar* %addytable1480 to i8*

; insert table, function and environment into closure struct
%closure.table1484 = getelementptr { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure1474, i32 0, i32 0
store i8* %address-table1481, i8** %closure.table1484
%closure.env1485 = getelementptr { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure1474, i32 0, i32 1
store i8* %envptr1475, i8** %closure.env1485
%closure.func1486 = getelementptr { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure1474, i32 0, i32 2
store %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)* @hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd__1444, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)** %closure.func1486
%closure_size1487 = call i64 @llvm_zone_mark_size(%mzone* %zone1472)
call void @llvm_zone_ptr_set_size(i8* %clsptr1473, i64 %closure_size1487)
%wrapper_ptr1488 = call i8* @llvm_zone_malloc(%mzone* %zone1472, i64 8)
%closure_wrapper1489 = bitcast i8* %wrapper_ptr1488 to { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}**
store { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure1474, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_wrapper1489

; let value assignment
%hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd = select i1 true, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_wrapper1489, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_wrapper1489
store { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}** %hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}*** %hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpdPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd
%tmp_envptr1483 = getelementptr {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}***}, {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}***}* %environment1476, i32 0, i32 0
store {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}*** %hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpdPtr, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}**** %tmp_envptr1483


%val1492 = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}**, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}*** %hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpdPtr
ret {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}** %val1492
}


@hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}** @hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGcompositeOperationState* @hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd(%NVGcompositeOperationState* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}*, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*,  %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState* %ff(i8* %_impz, i8* %ee, %NVGcompositeOperationState* %arg_0)
ret %NVGcompositeOperationState* %result
}


define dllexport ccc %NVGcompositeOperationState* @hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd_native(%NVGcompositeOperationState* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}*, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*,  %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState* %ff(i8* %_impz, i8* %ee, %NVGcompositeOperationState* %arg_0)
ret %NVGcompositeOperationState* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1493 = bitcast [142 x i8]* @gsxtmnanovg77 to i8*
call i32 (i8*, ...) @printf(i8* %var1493)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGcompositeOperationState*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}*, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*,  %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState* %ff(i8* %_impz, i8* %ee, %NVGcompositeOperationState* %arg_0)
%tmpres = bitcast %NVGcompositeOperationState* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGcompositeOperationState*}*
%arg_p_0 = getelementptr {%NVGcompositeOperationState*}, {%NVGcompositeOperationState*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}*, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)*,  %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState* %ff(i8* %_impz, i8* %ee, %NVGcompositeOperationState* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg78 = hidden constant [59 x i8] c"hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ__1494(i8* %_impz,i8* %_impenv, %NVGcompositeOperationState* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1495 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}***}*
%hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQPtr = load {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}***, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}**** %hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQPtr_

; setup arguments
%xPtr = alloca %NVGcompositeOperationState*
store %NVGcompositeOperationState* %x, %NVGcompositeOperationState** %xPtr


%val1496 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %xPtr
%val1497 = bitcast %NVGcompositeOperationState* %val1496 to i8*
call ccc void @free(i8* %val1497)
ret void
}
@gsxtmnanovg79 = hidden constant [112 x i8] c"hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** @hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1519 = load i8*, i8** %_impzPtr
%zone1520 = bitcast i8* %tzone1519 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ
%dat_hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone1520, i64 8)
%hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ to { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}***
%tzone1500 = load i8*, i8** %_impzPtr
%zone1501 = bitcast i8* %tzone1500 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1501)
; malloc closure structure
%clsptr1502 = call i8* @llvm_zone_malloc(%mzone* %zone1501, i64 24)
%closure1503 = bitcast i8* %clsptr1502 to { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}*

; malloc environment structure
%envptr1504 = call i8* @llvm_zone_malloc(%mzone* %zone1501, i64 8)
%environment1505 = bitcast i8* %envptr1504 to {{i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}***}*

; malloc closure address table
%addytable1506 = call %clsvar* @new_address_table()
%var1507 = bitcast [59 x i8]* @gsxtmnanovg78 to i8*
%var1508 = bitcast [61 x i8]* @gsxtmnanovg70 to i8*
%addytable1509 = call %clsvar* @add_address_table(%mzone* %zone1501, i8* %var1507, i32 0, i8* %var1508, i32 3, %clsvar* %addytable1506)
%address-table1510 = bitcast %clsvar* %addytable1509 to i8*

; insert table, function and environment into closure struct
%closure.table1513 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure1503, i32 0, i32 0
store i8* %address-table1510, i8** %closure.table1513
%closure.env1514 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure1503, i32 0, i32 1
store i8* %envptr1504, i8** %closure.env1514
%closure.func1515 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure1503, i32 0, i32 2
store void (i8*, i8*, %NVGcompositeOperationState*)* @hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ__1494, void (i8*, i8*, %NVGcompositeOperationState*)** %closure.func1515
%closure_size1516 = call i64 @llvm_zone_mark_size(%mzone* %zone1501)
call void @llvm_zone_ptr_set_size(i8* %clsptr1502, i64 %closure_size1516)
%wrapper_ptr1517 = call i8* @llvm_zone_malloc(%mzone* %zone1501, i64 8)
%closure_wrapper1518 = bitcast i8* %wrapper_ptr1517 to { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}**
store { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure1503, { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_wrapper1518

; let value assignment
%hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_wrapper1518, { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_wrapper1518
store { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** %hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ, { i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}*** %hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ
%tmp_envptr1512 = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}***}* %environment1505, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}*** %hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQPtr, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}**** %tmp_envptr1512


%val1521 = load {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}**, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}*** %hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQPtr
ret {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** %val1521
}


@hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** @hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ(%NVGcompositeOperationState* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}*, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGcompositeOperationState*)*,  void (i8*, i8*, %NVGcompositeOperationState*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGcompositeOperationState* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_native(%NVGcompositeOperationState* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}*, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGcompositeOperationState*)*,  void (i8*, i8*, %NVGcompositeOperationState*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGcompositeOperationState* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1522 = bitcast [112 x i8]* @gsxtmnanovg79 to i8*
call i32 (i8*, ...) @printf(i8* %var1522)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGcompositeOperationState*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}*, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGcompositeOperationState*)*,  void (i8*, i8*, %NVGcompositeOperationState*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGcompositeOperationState* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGcompositeOperationState*}*
%arg_p_0 = getelementptr {%NVGcompositeOperationState*}, {%NVGcompositeOperationState*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHY29tcG9zaXRlT3BlcmF0aW9uU3RhdGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}*, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}, {i8*, i8*, void (i8*, i8*, %NVGcompositeOperationState*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGcompositeOperationState*)*,  void (i8*, i8*, %NVGcompositeOperationState*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGcompositeOperationState* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg80 = hidden constant [108 x i8] c"zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0\00"
@gsxtmnanovg81 = hidden constant [103 x i8] c"{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %NVGcompositeOperationState* @zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0__1523(i8* %_impz,i8* %_impenv, %NVGcompositeOperationState* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1524 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0Ptr_ = getelementptr {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0Ptr = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}***, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0Ptr_

; setup arguments
%xPtr = alloca %NVGcompositeOperationState*
store %NVGcompositeOperationState* %x, %NVGcompositeOperationState** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val1526 = load %mzone*, %mzone** %fromzPtr
%val1527 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %xPtr
%val1528 = bitcast %NVGcompositeOperationState* %val1527 to i8*
%res1529 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val1526, i8* %val1528)
br i1 %res1529, label %then1525, label %else1525

then1525:
%val1530 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val1530)
%zone_ptr1531 = bitcast %mzone* %val1530 to i8*
store i8* %zone_ptr1531, i8** %_impzPtr
%tzone1537 = load i8*, i8** %_impzPtr
%zone1538 = bitcast i8* %tzone1537 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGcompositeOperationState*
%tzone1533 = load i8*, i8** %_impzPtr
%zone1534 = bitcast i8* %tzone1533 to %mzone*
%dat1535 = call i8* @llvm_zone_malloc(%mzone* %zone1534, i64 16)
call i8* @memset(i8* %dat1535, i32 0, i64 16)
%val1536 = bitcast i8* %dat1535 to %NVGcompositeOperationState*

; let value assignment
%obj = select i1 true, %NVGcompositeOperationState* %val1536, %NVGcompositeOperationState* %val1536
store %NVGcompositeOperationState* %obj, %NVGcompositeOperationState** %objPtr

%val1539 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val1540 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %xPtr
; tuple ref
%val1541 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1540, i64 0, i32 0
%val1542 = load i32, i32* %val1541
; set tuple
%val1543 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1539, i64 0, i32 0
store i32 %val1542, i32* %val1543
%val1544 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val1545 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %xPtr
; tuple ref
%val1546 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1545, i64 0, i32 1
%val1547 = load i32, i32* %val1546
; set tuple
%val1548 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1544, i64 0, i32 1
store i32 %val1547, i32* %val1548
%val1549 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val1550 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %xPtr
; tuple ref
%val1551 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1550, i64 0, i32 2
%val1552 = load i32, i32* %val1551
; set tuple
%val1553 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1549, i64 0, i32 2
store i32 %val1552, i32* %val1553
%val1554 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
%val1555 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %xPtr
; tuple ref
%val1556 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1555, i64 0, i32 3
%val1557 = load i32, i32* %val1556
; set tuple
%val1558 = getelementptr %NVGcompositeOperationState, %NVGcompositeOperationState* %val1554, i64 0, i32 3
store i32 %val1557, i32* %val1558
%oldzone1559 = call %mzone* @llvm_pop_zone_stack()
%newzone1560 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr1561 = bitcast %mzone* %newzone1560 to i8*
store i8* %zone_ptr1561, i8** %_impzPtr
%val1562 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %objPtr
ret %NVGcompositeOperationState* %val1562

else1525:
%val1563 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %xPtr
ret %NVGcompositeOperationState* %val1563
}
@gsxtmnanovg82 = hidden constant [161 x i8] c"zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}** @zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1583 = load i8*, i8** %_impzPtr
%zone1584 = bitcast i8* %tzone1583 to %mzone*

; let assign value to symbol zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0
%dat_zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1584, i64 8)
%zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0Ptr = bitcast i8* %dat_zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0 to { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}***
%tzone1564 = load i8*, i8** %_impzPtr
%zone1565 = bitcast i8* %tzone1564 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1565)
; malloc closure structure
%clsptr1566 = call i8* @llvm_zone_malloc(%mzone* %zone1565, i64 24)
%closure1567 = bitcast i8* %clsptr1566 to { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr1568 = call i8* @llvm_zone_malloc(%mzone* %zone1565, i64 8)
%environment1569 = bitcast i8* %envptr1568 to {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable1570 = call %clsvar* @new_address_table()
%var1571 = bitcast [108 x i8]* @gsxtmnanovg80 to i8*
%var1572 = bitcast [103 x i8]* @gsxtmnanovg81 to i8*
%addytable1573 = call %clsvar* @add_address_table(%mzone* %zone1565, i8* %var1571, i32 0, i8* %var1572, i32 3, %clsvar* %addytable1570)
%address-table1574 = bitcast %clsvar* %addytable1573 to i8*

; insert table, function and environment into closure struct
%closure.table1577 = getelementptr { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}* %closure1567, i32 0, i32 0
store i8* %address-table1574, i8** %closure.table1577
%closure.env1578 = getelementptr { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}* %closure1567, i32 0, i32 1
store i8* %envptr1568, i8** %closure.env1578
%closure.func1579 = getelementptr { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}* %closure1567, i32 0, i32 2
store %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)* @zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0__1523, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)** %closure.func1579
%closure_size1580 = call i64 @llvm_zone_mark_size(%mzone* %zone1565)
call void @llvm_zone_ptr_set_size(i8* %clsptr1566, i64 %closure_size1580)
%wrapper_ptr1581 = call i8* @llvm_zone_malloc(%mzone* %zone1565, i64 8)
%closure_wrapper1582 = bitcast i8* %wrapper_ptr1581 to { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}**
store { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}* %closure1567, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}** %closure_wrapper1582

; let value assignment
%zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0 = select i1 true, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}** %closure_wrapper1582, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}** %closure_wrapper1582
store { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}** %zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0, { i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0Ptr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0
%tmp_envptr1576 = getelementptr {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}***}* %environment1569, i32 0, i32 0
store {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0Ptr, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}**** %tmp_envptr1576


%val1585 = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}**, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0Ptr
ret {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}** %val1585
}


@zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}** @zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGcompositeOperationState* @zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0(%NVGcompositeOperationState* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*,  %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState* %ff(i8* %_impz, i8* %ee, %NVGcompositeOperationState* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %NVGcompositeOperationState* %result
}


define dllexport ccc %NVGcompositeOperationState* @zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0_native(%NVGcompositeOperationState* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*,  %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState* %ff(i8* %_impz, i8* %ee, %NVGcompositeOperationState* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %NVGcompositeOperationState* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1586 = bitcast [161 x i8]* @gsxtmnanovg82 to i8*
call i32 (i8*, ...) @printf(i8* %var1586)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGcompositeOperationState*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1587 = bitcast [161 x i8]* @gsxtmnanovg82 to i8*
call i32 (i8*, ...) @printf(i8* %var1587)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1588 = bitcast [161 x i8]* @gsxtmnanovg82 to i8*
call i32 (i8*, ...) @printf(i8* %var1588)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*,  %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState* %ff(i8* %_impz, i8* %ee, %NVGcompositeOperationState* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %NVGcompositeOperationState* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGcompositeOperationState*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%NVGcompositeOperationState*, %mzone*, %mzone*}, {%NVGcompositeOperationState*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGcompositeOperationState*, %NVGcompositeOperationState** %arg_p_0
%arg_p_1 = getelementptr {%NVGcompositeOperationState*, %mzone*, %mzone*}, {%NVGcompositeOperationState*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%NVGcompositeOperationState*, %mzone*, %mzone*}, {%NVGcompositeOperationState*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR2NvbXBvc2l0ZU9wZXJhdGlvblN0YXRlKixOVkdjb21wb3NpdGVPcGVyYXRpb25TdGF0ZSosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)*,  %NVGcompositeOperationState* (i8*, i8*, %NVGcompositeOperationState*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGcompositeOperationState* %ff(i8* %_impz, i8* %ee, %NVGcompositeOperationState* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


declare cc 0 void @nvgGlobalCompositeOperation(i8*,i32) nounwind
declare cc 0 void @nvgGlobalCompositeBlendFunc(i8*,i32,i32) nounwind
declare cc 0 void @nvgGlobalCompositeBlendFuncSeparate(i8*,i32,i32,i32,i32) nounwind
%NVGglyphPosition = type {i8*,float,float,float}
@gsxtmnanovg83 = hidden constant [79 x i8] c"NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0\00"
@gsxtmnanovg84 = hidden constant [71 x i8] c"{i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**\00"
define dllexport fastcc %NVGglyphPosition* @NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0__1589(i8* %_impz,i8* %_impenv, i8* %arg_0, float %arg_1, float %arg_2, float %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1590 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***}*
%NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0Ptr_ = getelementptr {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***}, {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***}* %impenv, i32 0, i32 0
%NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0Ptr = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**** %NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0Ptr_

; setup arguments
%arg_0Ptr = alloca i8*
store i8* %arg_0, i8** %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr
%arg_2Ptr = alloca float
store float %arg_2, float* %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr


%tzone1595 = load i8*, i8** %_impzPtr
%zone1596 = bitcast i8* %tzone1595 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGglyphPosition*
%tzone1591 = load i8*, i8** %_impzPtr
%zone1592 = bitcast i8* %tzone1591 to %mzone*
%dat1593 = call i8* @llvm_zone_malloc(%mzone* %zone1592, i64 24)
call i8* @memset(i8* %dat1593, i32 0, i64 24)
%val1594 = bitcast i8* %dat1593 to %NVGglyphPosition*

; let value assignment
%obj = select i1 true, %NVGglyphPosition* %val1594, %NVGglyphPosition* %val1594
store %NVGglyphPosition* %obj, %NVGglyphPosition** %objPtr

%val1597 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val1598 = load i8*, i8** %arg_0Ptr
; set tuple
%val1599 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val1597, i64 0, i32 0
store i8* %val1598, i8** %val1599
%val1600 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val1601 = load float, float* %arg_1Ptr
; set tuple
%val1602 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val1600, i64 0, i32 1
store float %val1601, float* %val1602
%val1603 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val1604 = load float, float* %arg_2Ptr
; set tuple
%val1605 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val1603, i64 0, i32 2
store float %val1604, float* %val1605
%val1606 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val1607 = load float, float* %arg_3Ptr
; set tuple
%val1608 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val1606, i64 0, i32 3
store float %val1607, float* %val1608
%val1609 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
ret %NVGglyphPosition* %val1609
}
@gsxtmnanovg85 = hidden constant [132 x i8] c"NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** @NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1629 = load i8*, i8** %_impzPtr
%zone1630 = bitcast i8* %tzone1629 to %mzone*

; let assign value to symbol NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0
%dat_NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0 = call i8* @llvm_zone_malloc(%mzone* %zone1630, i64 8)
%NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0Ptr = bitcast i8* %dat_NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0 to { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***
%tzone1610 = load i8*, i8** %_impzPtr
%zone1611 = bitcast i8* %tzone1610 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1611)
; malloc closure structure
%clsptr1612 = call i8* @llvm_zone_malloc(%mzone* %zone1611, i64 24)
%closure1613 = bitcast i8* %clsptr1612 to { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*

; malloc environment structure
%envptr1614 = call i8* @llvm_zone_malloc(%mzone* %zone1611, i64 8)
%environment1615 = bitcast i8* %envptr1614 to {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***}*

; malloc closure address table
%addytable1616 = call %clsvar* @new_address_table()
%var1617 = bitcast [79 x i8]* @gsxtmnanovg83 to i8*
%var1618 = bitcast [71 x i8]* @gsxtmnanovg84 to i8*
%addytable1619 = call %clsvar* @add_address_table(%mzone* %zone1611, i8* %var1617, i32 0, i8* %var1618, i32 3, %clsvar* %addytable1616)
%address-table1620 = bitcast %clsvar* %addytable1619 to i8*

; insert table, function and environment into closure struct
%closure.table1623 = getelementptr { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure1613, i32 0, i32 0
store i8* %address-table1620, i8** %closure.table1623
%closure.env1624 = getelementptr { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure1613, i32 0, i32 1
store i8* %envptr1614, i8** %closure.env1624
%closure.func1625 = getelementptr { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure1613, i32 0, i32 2
store %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)* @NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0__1589, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)** %closure.func1625
%closure_size1626 = call i64 @llvm_zone_mark_size(%mzone* %zone1611)
call void @llvm_zone_ptr_set_size(i8* %clsptr1612, i64 %closure_size1626)
%wrapper_ptr1627 = call i8* @llvm_zone_malloc(%mzone* %zone1611, i64 8)
%closure_wrapper1628 = bitcast i8* %wrapper_ptr1627 to { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**
store { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure1613, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure_wrapper1628

; let value assignment
%NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0 = select i1 true, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure_wrapper1628, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure_wrapper1628
store { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*** %NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0Ptr

; add data to environment
; don't need to alloc for env var NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0
%tmp_envptr1622 = getelementptr {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***}, {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***}* %environment1615, i32 0, i32 0
store {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*** %NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0Ptr, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**** %tmp_envptr1622


%val1631 = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*** %NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0Ptr
ret {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %val1631
}


@NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var = dllexport global [1 x i8*] [ i8* null ]

@NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** @NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGglyphPosition* @NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0(i8* %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*,  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition* %ff(i8* %_impz, i8* %ee, i8* %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGglyphPosition* %result
}


define dllexport ccc %NVGglyphPosition* @NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_native(i8* %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*,  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition* %ff(i8* %_impz, i8* %ee, i8* %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGglyphPosition* %result
}


define dllexport ccc i8*  @NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1632 = bitcast [132 x i8]* @gsxtmnanovg85 to i8*
call i32 (i8*, ...) @printf(i8* %var1632)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1633 = bitcast [132 x i8]* @gsxtmnanovg85 to i8*
call i32 (i8*, ...) @printf(i8* %var1633)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1634 = bitcast [132 x i8]* @gsxtmnanovg85 to i8*
call i32 (i8*, ...) @printf(i8* %var1634)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var1635 = bitcast [132 x i8]* @gsxtmnanovg85 to i8*
call i32 (i8*, ...) @printf(i8* %var1635)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*,  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition* %ff(i8* %_impz, i8* %ee, i8* %arg_0, float %arg_1, float %arg_2, float %arg_3)
%tmpres = bitcast %NVGglyphPosition* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, float, float, float}*
%arg_p_0 = getelementptr {i8*, float, float, float}, {i8*, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, float, float, float}, {i8*, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {i8*, float, float, float}, {i8*, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {i8*, float, float, float}, {i8*, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*,  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition* %ff(i8* %_impz, i8* %ee, i8* %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg86 = hidden constant [81 x i8] c"NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0\00"
define dllexport fastcc %NVGglyphPosition* @NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0__1636(i8* %_impz,i8* %_impenv, i8* %arg_0, float %arg_1, float %arg_2, float %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1637 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***}*
%NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0Ptr_ = getelementptr {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***}, {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***}* %impenv, i32 0, i32 0
%NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0Ptr = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**** %NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0Ptr_

; setup arguments
%arg_0Ptr = alloca i8*
store i8* %arg_0, i8** %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr
%arg_2Ptr = alloca float
store float %arg_2, float* %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr


%tzone1642 = load i8*, i8** %_impzPtr
%zone1643 = bitcast i8* %tzone1642 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGglyphPosition*
%tzone1638 = load i8*, i8** %_impzPtr
%zone1639 = bitcast i8* %tzone1638 to %mzone*
%dat1640 = call i8* @llvm_zone_malloc(%mzone* %zone1639, i64 24)
call i8* @memset(i8* %dat1640, i32 0, i64 24)
%val1641 = bitcast i8* %dat1640 to %NVGglyphPosition*

; let value assignment
%obj = select i1 true, %NVGglyphPosition* %val1641, %NVGglyphPosition* %val1641
store %NVGglyphPosition* %obj, %NVGglyphPosition** %objPtr

%val1644 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val1645 = load i8*, i8** %arg_0Ptr
; set tuple
%val1646 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val1644, i64 0, i32 0
store i8* %val1645, i8** %val1646
%val1647 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val1648 = load float, float* %arg_1Ptr
; set tuple
%val1649 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val1647, i64 0, i32 1
store float %val1648, float* %val1649
%val1650 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val1651 = load float, float* %arg_2Ptr
; set tuple
%val1652 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val1650, i64 0, i32 2
store float %val1651, float* %val1652
%val1653 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val1654 = load float, float* %arg_3Ptr
; set tuple
%val1655 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val1653, i64 0, i32 3
store float %val1654, float* %val1655
%val1656 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
ret %NVGglyphPosition* %val1656
}
@gsxtmnanovg87 = hidden constant [134 x i8] c"NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** @NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1676 = load i8*, i8** %_impzPtr
%zone1677 = bitcast i8* %tzone1676 to %mzone*

; let assign value to symbol NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0
%dat_NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0 = call i8* @llvm_zone_malloc(%mzone* %zone1677, i64 8)
%NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0Ptr = bitcast i8* %dat_NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0 to { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***
%tzone1657 = load i8*, i8** %_impzPtr
%zone1658 = bitcast i8* %tzone1657 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1658)
; malloc closure structure
%clsptr1659 = call i8* @llvm_zone_malloc(%mzone* %zone1658, i64 24)
%closure1660 = bitcast i8* %clsptr1659 to { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*

; malloc environment structure
%envptr1661 = call i8* @llvm_zone_malloc(%mzone* %zone1658, i64 8)
%environment1662 = bitcast i8* %envptr1661 to {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***}*

; malloc closure address table
%addytable1663 = call %clsvar* @new_address_table()
%var1664 = bitcast [81 x i8]* @gsxtmnanovg86 to i8*
%var1665 = bitcast [71 x i8]* @gsxtmnanovg84 to i8*
%addytable1666 = call %clsvar* @add_address_table(%mzone* %zone1658, i8* %var1664, i32 0, i8* %var1665, i32 3, %clsvar* %addytable1663)
%address-table1667 = bitcast %clsvar* %addytable1666 to i8*

; insert table, function and environment into closure struct
%closure.table1670 = getelementptr { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure1660, i32 0, i32 0
store i8* %address-table1667, i8** %closure.table1670
%closure.env1671 = getelementptr { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure1660, i32 0, i32 1
store i8* %envptr1661, i8** %closure.env1671
%closure.func1672 = getelementptr { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure1660, i32 0, i32 2
store %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)* @NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0__1636, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)** %closure.func1672
%closure_size1673 = call i64 @llvm_zone_mark_size(%mzone* %zone1658)
call void @llvm_zone_ptr_set_size(i8* %clsptr1659, i64 %closure_size1673)
%wrapper_ptr1674 = call i8* @llvm_zone_malloc(%mzone* %zone1658, i64 8)
%closure_wrapper1675 = bitcast i8* %wrapper_ptr1674 to { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**
store { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure1660, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure_wrapper1675

; let value assignment
%NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0 = select i1 true, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure_wrapper1675, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure_wrapper1675
store { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*** %NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0Ptr

; add data to environment
; don't need to alloc for env var NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0
%tmp_envptr1669 = getelementptr {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***}, {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***}* %environment1662, i32 0, i32 0
store {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*** %NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0Ptr, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**** %tmp_envptr1669


%val1678 = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*** %NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0Ptr
ret {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %val1678
}


@NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var = dllexport global [1 x i8*] [ i8* null ]

@NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** @NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGglyphPosition* @NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0(i8* %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*,  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition* %ff(i8* %_impz, i8* %ee, i8* %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGglyphPosition* %result
}


define dllexport ccc %NVGglyphPosition* @NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_native(i8* %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*,  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition* %ff(i8* %_impz, i8* %ee, i8* %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGglyphPosition* %result
}


define dllexport ccc i8*  @NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1679 = bitcast [134 x i8]* @gsxtmnanovg87 to i8*
call i32 (i8*, ...) @printf(i8* %var1679)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1680 = bitcast [134 x i8]* @gsxtmnanovg87 to i8*
call i32 (i8*, ...) @printf(i8* %var1680)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1681 = bitcast [134 x i8]* @gsxtmnanovg87 to i8*
call i32 (i8*, ...) @printf(i8* %var1681)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var1682 = bitcast [134 x i8]* @gsxtmnanovg87 to i8*
call i32 (i8*, ...) @printf(i8* %var1682)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*,  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition* %ff(i8* %_impz, i8* %ee, i8* %arg_0, float %arg_1, float %arg_2, float %arg_3)
%tmpres = bitcast %NVGglyphPosition* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, float, float, float}*
%arg_p_0 = getelementptr {i8*, float, float, float}, {i8*, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, float, float, float}, {i8*, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {i8*, float, float, float}, {i8*, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {i8*, float, float, float}, {i8*, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_z_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*,  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition* %ff(i8* %_impz, i8* %ee, i8* %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg88 = hidden constant [81 x i8] c"NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0\00"
define dllexport fastcc %NVGglyphPosition* @NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0__1683(i8* %_impz,i8* %_impenv, i8* %arg_0, float %arg_1, float %arg_2, float %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1684 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***}*
%NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0Ptr_ = getelementptr {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***}, {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***}* %impenv, i32 0, i32 0
%NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0Ptr = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**** %NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0Ptr_

; setup arguments
%arg_0Ptr = alloca i8*
store i8* %arg_0, i8** %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr
%arg_2Ptr = alloca float
store float %arg_2, float* %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr


%tzone1687 = load i8*, i8** %_impzPtr
%zone1688 = bitcast i8* %tzone1687 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGglyphPosition*
%dat1685 = call i8* @malloc(i64 24)
call i8* @memset(i8* %dat1685, i32 0, i64 24)
%val1686 = bitcast i8* %dat1685 to %NVGglyphPosition*

; let value assignment
%obj = select i1 true, %NVGglyphPosition* %val1686, %NVGglyphPosition* %val1686
store %NVGglyphPosition* %obj, %NVGglyphPosition** %objPtr

%val1689 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val1690 = load i8*, i8** %arg_0Ptr
; set tuple
%val1691 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val1689, i64 0, i32 0
store i8* %val1690, i8** %val1691
%val1692 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val1693 = load float, float* %arg_1Ptr
; set tuple
%val1694 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val1692, i64 0, i32 1
store float %val1693, float* %val1694
%val1695 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val1696 = load float, float* %arg_2Ptr
; set tuple
%val1697 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val1695, i64 0, i32 2
store float %val1696, float* %val1697
%val1698 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val1699 = load float, float* %arg_3Ptr
; set tuple
%val1700 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val1698, i64 0, i32 3
store float %val1699, float* %val1700
%val1701 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
ret %NVGglyphPosition* %val1701
}
@gsxtmnanovg89 = hidden constant [134 x i8] c"NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** @NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1721 = load i8*, i8** %_impzPtr
%zone1722 = bitcast i8* %tzone1721 to %mzone*

; let assign value to symbol NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0
%dat_NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0 = call i8* @llvm_zone_malloc(%mzone* %zone1722, i64 8)
%NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0Ptr = bitcast i8* %dat_NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0 to { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***
%tzone1702 = load i8*, i8** %_impzPtr
%zone1703 = bitcast i8* %tzone1702 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1703)
; malloc closure structure
%clsptr1704 = call i8* @llvm_zone_malloc(%mzone* %zone1703, i64 24)
%closure1705 = bitcast i8* %clsptr1704 to { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*

; malloc environment structure
%envptr1706 = call i8* @llvm_zone_malloc(%mzone* %zone1703, i64 8)
%environment1707 = bitcast i8* %envptr1706 to {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***}*

; malloc closure address table
%addytable1708 = call %clsvar* @new_address_table()
%var1709 = bitcast [81 x i8]* @gsxtmnanovg88 to i8*
%var1710 = bitcast [71 x i8]* @gsxtmnanovg84 to i8*
%addytable1711 = call %clsvar* @add_address_table(%mzone* %zone1703, i8* %var1709, i32 0, i8* %var1710, i32 3, %clsvar* %addytable1708)
%address-table1712 = bitcast %clsvar* %addytable1711 to i8*

; insert table, function and environment into closure struct
%closure.table1715 = getelementptr { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure1705, i32 0, i32 0
store i8* %address-table1712, i8** %closure.table1715
%closure.env1716 = getelementptr { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure1705, i32 0, i32 1
store i8* %envptr1706, i8** %closure.env1716
%closure.func1717 = getelementptr { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure1705, i32 0, i32 2
store %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)* @NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0__1683, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)** %closure.func1717
%closure_size1718 = call i64 @llvm_zone_mark_size(%mzone* %zone1703)
call void @llvm_zone_ptr_set_size(i8* %clsptr1704, i64 %closure_size1718)
%wrapper_ptr1719 = call i8* @llvm_zone_malloc(%mzone* %zone1703, i64 8)
%closure_wrapper1720 = bitcast i8* %wrapper_ptr1719 to { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**
store { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure1705, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure_wrapper1720

; let value assignment
%NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0 = select i1 true, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure_wrapper1720, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure_wrapper1720
store { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*** %NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0Ptr

; add data to environment
; don't need to alloc for env var NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0
%tmp_envptr1714 = getelementptr {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***}, {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}***}* %environment1707, i32 0, i32 0
store {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*** %NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0Ptr, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**** %tmp_envptr1714


%val1723 = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*** %NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0Ptr
ret {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %val1723
}


@NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var = dllexport global [1 x i8*] [ i8* null ]

@NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** @NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGglyphPosition* @NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0(i8* %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*,  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition* %ff(i8* %_impz, i8* %ee, i8* %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGglyphPosition* %result
}


define dllexport ccc %NVGglyphPosition* @NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_native(i8* %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*,  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition* %ff(i8* %_impz, i8* %ee, i8* %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGglyphPosition* %result
}


define dllexport ccc i8*  @NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1724 = bitcast [134 x i8]* @gsxtmnanovg89 to i8*
call i32 (i8*, ...) @printf(i8* %var1724)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1725 = bitcast [134 x i8]* @gsxtmnanovg89 to i8*
call i32 (i8*, ...) @printf(i8* %var1725)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1726 = bitcast [134 x i8]* @gsxtmnanovg89 to i8*
call i32 (i8*, ...) @printf(i8* %var1726)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var1727 = bitcast [134 x i8]* @gsxtmnanovg89 to i8*
call i32 (i8*, ...) @printf(i8* %var1727)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*,  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition* %ff(i8* %_impz, i8* %ee, i8* %arg_0, float %arg_1, float %arg_2, float %arg_3)
%tmpres = bitcast %NVGglyphPosition* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, float, float, float}*
%arg_p_0 = getelementptr {i8*, float, float, float}, {i8*, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, float, float, float}, {i8*, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {i8*, float, float, float}, {i8*, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {i8*, float, float, float}, {i8*, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_h_adhoc_W05WR2dseXBoUG9zaXRpb24qLGk4KixmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)*,  %NVGglyphPosition* (i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition* %ff(i8* %_impz, i8* %ee, i8* %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg90 = hidden constant [24 x i8] c"<NVGglyphPosition:null>\00"
@gsxtmnanovg91 = hidden constant [19 x i8] c"<NVGglyphPosition:\00"
@gsxtmnanovg92 = hidden constant [52 x i8] c"toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd\00"
@gsxtmnanovg93 = hidden constant [55 x i8] c"{i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd__1728(i8* %_impz,i8* %_impenv, %NVGglyphPosition* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1729 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}***}*
%toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipdPtr = load {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}***, {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}**** %toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipdPtr_

; setup arguments
%xPtr = alloca %NVGglyphPosition*
store %NVGglyphPosition* %x, %NVGglyphPosition** %xPtr


%val1731 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
%val1732 = icmp eq %NVGglyphPosition* %val1731, null
br i1 %val1732, label %then1730, label %else1730

then1730:
%zone1733 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone1733)
%zone_ptr1734 = bitcast %mzone* %zone1733 to i8*
store i8* %zone_ptr1734, i8** %_impzPtr
%tzone1744 = load i8*, i8** %_impzPtr
%zone1745 = bitcast i8* %tzone1744 to %mzone*

; let assign value to symbol res2
%res2Ptr = alloca %String*
%tzone1749 = load i8*, i8** %_impzPtr
%zone1750 = bitcast i8* %tzone1749 to %mzone*

; let assign value to symbol zone2
%zone2Ptr = alloca %mzone*
%tzone1752 = load i8*, i8** %_impzPtr
%zone1753 = bitcast i8* %tzone1752 to %mzone*

; let assign value to symbol newz2
%newz2Ptr = alloca %mzone*
%tzone1736 = load i8*, i8** %_impzPtr
%zone1737 = bitcast i8* %tzone1736 to %mzone*

; let assign value to symbol xx_t_mst
%xx_t_mstPtr = alloca i8*
%dat1735 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst = select i1 true, i8* %dat1735, i8* %dat1735
store i8* %xx_t_mst, i8** %xx_t_mstPtr

%val1738 = load i8*, i8** %xx_t_mstPtr
%var1739 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1740 = bitcast [24 x i8]* @gsxtmnanovg90 to i8*

%val1741 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1738, i8* %var1739, i8* %var1740)
%val1742 = load i8*, i8** %xx_t_mstPtr
%res1743 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1742)

; let value assignment
%res2 = select i1 true, %String* %res1743, %String* %res1743
store %String* %res2, %String** %res2Ptr

%oldzone1746 = call %mzone* @llvm_pop_zone_stack()
%newzone1747 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr1748 = bitcast %mzone* %newzone1747 to i8*
store i8* %zone_ptr1748, i8** %_impzPtr

; let value assignment
%zone2 = select i1 true, %mzone* %oldzone1746, %mzone* %oldzone1746
store %mzone* %zone2, %mzone** %zone2Ptr

%res1751 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz2 = select i1 true, %mzone* %res1751, %mzone* %res1751
store %mzone* %newz2, %mzone** %newz2Ptr

%tzone1758 = load i8*, i8** %_impzPtr
%zone1759 = bitcast i8* %tzone1758 to %mzone*

; let assign value to symbol rescopy2
%rescopy2Ptr = alloca %String*
%tzone1764 = load i8*, i8** %_impzPtr
%zone1765 = bitcast i8* %tzone1764 to %mzone*

; let assign value to symbol hook
%hookPtr = alloca {i64,i8*,i8*}*
%tzone1767 = load i8*, i8** %_impzPtr
%zone1768 = bitcast i8* %tzone1767 to %mzone*

; let assign value to symbol f
%fPtr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val1754 = load %String*, %String** %res2Ptr
%val1755 = load %mzone*, %mzone** %zone2Ptr
%val1756 = load %mzone*, %mzone** %newz2Ptr
%res1757 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val1754, %mzone* %val1755, %mzone* %val1756)

; let value assignment
%rescopy2 = select i1 true, %String* %res1757, %String* %res1757
store %String* %rescopy2, %String** %rescopy2Ptr

%val1760 = load %mzone*, %mzone** %zone2Ptr
; tuple ref
%val1761 = getelementptr %mzone, %mzone* %val1760, i64 0, i32 4
%val1762 = load i8*, i8** %val1761
%val1763 = bitcast i8* %val1762 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val1763, {i64,i8*,i8*}* %val1763
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%null1766 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null1766, {i8*, i8*, void (i8*, i8*)*}** %null1766
store {i8*, i8*, void (i8*, i8*)*}** %f, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; promote local stack var allocations
%tzone1804 = load i8*, i8** %_impzPtr
%zone1805 = bitcast i8* %tzone1804 to %mzone*
%ifptr1794 = alloca i1
%ifptr1770 = alloca i1
; while loop
%val1771 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val1772 = icmp eq {i64,i8*,i8*}* %val1771, null
br i1 %val1772, label %then1770, label %else1770

then1770:
%res1773 = call ccc i1 @impc_false()
store i1 %res1773, i1* %ifptr1770
br label %ifcont1770

else1770:
%res1774 = call ccc i1 @impc_true()
store i1 %res1774, i1* %ifptr1770
br label %ifcont1770

ifcont1770:
%ifres1775 = load i1, i1* %ifptr1770

br i1 %ifres1775, label %loop1769, label %after1769

loop1769:
; do set!
%val1776 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val1777 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1776, i64 0, i32 1
%val1778 = load i8*, i8** %val1777
%val1779 = bitcast i8* %val1778 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val1779, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; apply closure 
%vval1780 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val1781 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval1780
%fPtr1782 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1781, i32 0, i32 2
%ePtr1783 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1781, i32 0, i32 1
%f1784 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr1782
%e1785 = load i8*, i8** %ePtr1783
%tzone1786 = load i8*, i8** %_impzPtr
%zone1787 = bitcast i8* %tzone1786 to %mzone*
%z1788 = bitcast %mzone* %zone1787 to i8*
tail call fastcc void %f1784(i8* %z1788, i8* %e1785)
; do set!
%val1790 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val1791 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1790, i64 0, i32 2
%val1792 = load i8*, i8** %val1791
%val1793 = bitcast i8* %val1792 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val1793, {i64,i8*,i8*}** %hookPtr
%val1795 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val1796 = icmp eq {i64,i8*,i8*}* %val1795, null
br i1 %val1796, label %then1794, label %else1794

then1794:
%res1797 = call ccc i1 @impc_false()
store i1 %res1797, i1* %ifptr1794
br label %ifcont1794

else1794:
%res1798 = call ccc i1 @impc_true()
store i1 %res1798, i1* %ifptr1794
br label %ifcont1794

ifcont1794:
%ifres1799 = load i1, i1* %ifptr1794

br i1 %ifres1799, label %loop1769, label %after1769

after1769:
%val1801 = load %mzone*, %mzone** %zone2Ptr
call ccc void @llvm_zone_destroy(%mzone* %val1801)
%val1803 = load %String*, %String** %rescopy2Ptr
ret %String* %val1803

else1730:
%zone1806 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone1806)
%zone_ptr1807 = bitcast %mzone* %zone1806 to i8*
store i8* %zone_ptr1807, i8** %_impzPtr
%tzone1877 = load i8*, i8** %_impzPtr
%zone1878 = bitcast i8* %tzone1877 to %mzone*

; let assign value to symbol res3
%res3Ptr = alloca %String*
%tzone1882 = load i8*, i8** %_impzPtr
%zone1883 = bitcast i8* %tzone1882 to %mzone*

; let assign value to symbol zone3
%zone3Ptr = alloca %mzone*
%tzone1885 = load i8*, i8** %_impzPtr
%zone1886 = bitcast i8* %tzone1885 to %mzone*

; let assign value to symbol newz3
%newz3Ptr = alloca %mzone*
%tzone1809 = load i8*, i8** %_impzPtr
%zone1810 = bitcast i8* %tzone1809 to %mzone*

; let assign value to symbol xx_t_mst_s_8
%xx_t_mst_s_8Ptr = alloca i8*
%dat1808 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_8 = select i1 true, i8* %dat1808, i8* %dat1808
store i8* %xx_t_mst_s_8, i8** %xx_t_mst_s_8Ptr

%val1811 = load i8*, i8** %xx_t_mst_s_8Ptr
%var1812 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1813 = bitcast [19 x i8]* @gsxtmnanovg91 to i8*

%val1814 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1811, i8* %var1812, i8* %var1813)
%val1815 = load i8*, i8** %xx_t_mst_s_8Ptr
%res1816 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1815)
%val1817 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
; tuple ref
%val1818 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val1817, i64 0, i32 0
%val1819 = load i8*, i8** %val1818
%res1820 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1819)
%res1821 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1816, %String* %res1820)
%tzone1823 = load i8*, i8** %_impzPtr
%zone1824 = bitcast i8* %tzone1823 to %mzone*

; let assign value to symbol xx_t_mst_s_9
%xx_t_mst_s_9Ptr = alloca i8*
%dat1822 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_9 = select i1 true, i8* %dat1822, i8* %dat1822
store i8* %xx_t_mst_s_9, i8** %xx_t_mst_s_9Ptr

%val1825 = load i8*, i8** %xx_t_mst_s_9Ptr
%var1826 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1827 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val1828 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1825, i8* %var1826, i8* %var1827)
%val1829 = load i8*, i8** %xx_t_mst_s_9Ptr
%res1830 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1829)
%res1831 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1821, %String* %res1830)
%val1832 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
; tuple ref
%val1833 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val1832, i64 0, i32 1
%val1834 = load float, float* %val1833
%res1835 = call fastcc %String* @toString_adhoc_W1N0cmluZyosZmxvYXRd(float %val1834)
%res1836 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1831, %String* %res1835)
%tzone1838 = load i8*, i8** %_impzPtr
%zone1839 = bitcast i8* %tzone1838 to %mzone*

; let assign value to symbol xx_t_mst_s_10
%xx_t_mst_s_10Ptr = alloca i8*
%dat1837 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_10 = select i1 true, i8* %dat1837, i8* %dat1837
store i8* %xx_t_mst_s_10, i8** %xx_t_mst_s_10Ptr

%val1840 = load i8*, i8** %xx_t_mst_s_10Ptr
%var1841 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1842 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val1843 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1840, i8* %var1841, i8* %var1842)
%val1844 = load i8*, i8** %xx_t_mst_s_10Ptr
%res1845 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1844)
%res1846 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1836, %String* %res1845)
%val1847 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
; tuple ref
%val1848 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val1847, i64 0, i32 2
%val1849 = load float, float* %val1848
%res1850 = call fastcc %String* @toString_adhoc_W1N0cmluZyosZmxvYXRd(float %val1849)
%res1851 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1846, %String* %res1850)
%tzone1853 = load i8*, i8** %_impzPtr
%zone1854 = bitcast i8* %tzone1853 to %mzone*

; let assign value to symbol xx_t_mst_s_11
%xx_t_mst_s_11Ptr = alloca i8*
%dat1852 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_11 = select i1 true, i8* %dat1852, i8* %dat1852
store i8* %xx_t_mst_s_11, i8** %xx_t_mst_s_11Ptr

%val1855 = load i8*, i8** %xx_t_mst_s_11Ptr
%var1856 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1857 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val1858 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1855, i8* %var1856, i8* %var1857)
%val1859 = load i8*, i8** %xx_t_mst_s_11Ptr
%res1860 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1859)
%res1861 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1851, %String* %res1860)
%val1862 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
; tuple ref
%val1863 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val1862, i64 0, i32 3
%val1864 = load float, float* %val1863
%res1865 = call fastcc %String* @toString_adhoc_W1N0cmluZyosZmxvYXRd(float %val1864)
%res1866 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1861, %String* %res1865)
%tzone1868 = load i8*, i8** %_impzPtr
%zone1869 = bitcast i8* %tzone1868 to %mzone*

; let assign value to symbol xx_t_mst_s_12
%xx_t_mst_s_12Ptr = alloca i8*
%dat1867 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_12 = select i1 true, i8* %dat1867, i8* %dat1867
store i8* %xx_t_mst_s_12, i8** %xx_t_mst_s_12Ptr

%val1870 = load i8*, i8** %xx_t_mst_s_12Ptr
%var1871 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1872 = bitcast [2 x i8]* @gsxtmnanovg65 to i8*

%val1873 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1870, i8* %var1871, i8* %var1872)
%val1874 = load i8*, i8** %xx_t_mst_s_12Ptr
%res1875 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1874)
%res1876 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1866, %String* %res1875)

; let value assignment
%res3 = select i1 true, %String* %res1876, %String* %res1876
store %String* %res3, %String** %res3Ptr

%oldzone1879 = call %mzone* @llvm_pop_zone_stack()
%newzone1880 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr1881 = bitcast %mzone* %newzone1880 to i8*
store i8* %zone_ptr1881, i8** %_impzPtr

; let value assignment
%zone3 = select i1 true, %mzone* %oldzone1879, %mzone* %oldzone1879
store %mzone* %zone3, %mzone** %zone3Ptr

%res1884 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz3 = select i1 true, %mzone* %res1884, %mzone* %res1884
store %mzone* %newz3, %mzone** %newz3Ptr

%tzone1891 = load i8*, i8** %_impzPtr
%zone1892 = bitcast i8* %tzone1891 to %mzone*

; let assign value to symbol rescopy3
%rescopy3Ptr = alloca %String*
%tzone1897 = load i8*, i8** %_impzPtr
%zone1898 = bitcast i8* %tzone1897 to %mzone*

; let assign value to symbol hook_s_13
%hook_s_13Ptr = alloca {i64,i8*,i8*}*
%tzone1900 = load i8*, i8** %_impzPtr
%zone1901 = bitcast i8* %tzone1900 to %mzone*

; let assign value to symbol f_s_14
%f_s_14Ptr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val1887 = load %String*, %String** %res3Ptr
%val1888 = load %mzone*, %mzone** %zone3Ptr
%val1889 = load %mzone*, %mzone** %newz3Ptr
%res1890 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val1887, %mzone* %val1888, %mzone* %val1889)

; let value assignment
%rescopy3 = select i1 true, %String* %res1890, %String* %res1890
store %String* %rescopy3, %String** %rescopy3Ptr

%val1893 = load %mzone*, %mzone** %zone3Ptr
; tuple ref
%val1894 = getelementptr %mzone, %mzone* %val1893, i64 0, i32 4
%val1895 = load i8*, i8** %val1894
%val1896 = bitcast i8* %val1895 to {i64,i8*,i8*}*

; let value assignment
%hook_s_13 = select i1 true, {i64,i8*,i8*}* %val1896, {i64,i8*,i8*}* %val1896
store {i64,i8*,i8*}* %hook_s_13, {i64,i8*,i8*}** %hook_s_13Ptr

%null1899 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f_s_14 = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null1899, {i8*, i8*, void (i8*, i8*)*}** %null1899
store {i8*, i8*, void (i8*, i8*)*}** %f_s_14, {i8*, i8*, void (i8*, i8*)*}*** %f_s_14Ptr

; promote local stack var allocations
%tzone1937 = load i8*, i8** %_impzPtr
%zone1938 = bitcast i8* %tzone1937 to %mzone*
%ifptr1927 = alloca i1
%ifptr1903 = alloca i1
; while loop
%val1904 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_13Ptr
%val1905 = icmp eq {i64,i8*,i8*}* %val1904, null
br i1 %val1905, label %then1903, label %else1903

then1903:
%res1906 = call ccc i1 @impc_false()
store i1 %res1906, i1* %ifptr1903
br label %ifcont1903

else1903:
%res1907 = call ccc i1 @impc_true()
store i1 %res1907, i1* %ifptr1903
br label %ifcont1903

ifcont1903:
%ifres1908 = load i1, i1* %ifptr1903

br i1 %ifres1908, label %loop1902, label %after1902

loop1902:
; do set!
%val1909 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_13Ptr
; tuple ref
%val1910 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1909, i64 0, i32 1
%val1911 = load i8*, i8** %val1910
%val1912 = bitcast i8* %val1911 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val1912, {i8*, i8*, void (i8*, i8*)*}*** %f_s_14Ptr

; apply closure 
%vval1913 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %f_s_14Ptr
%val1914 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval1913
%fPtr1915 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1914, i32 0, i32 2
%ePtr1916 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1914, i32 0, i32 1
%f1917 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr1915
%e1918 = load i8*, i8** %ePtr1916
%tzone1919 = load i8*, i8** %_impzPtr
%zone1920 = bitcast i8* %tzone1919 to %mzone*
%z1921 = bitcast %mzone* %zone1920 to i8*
tail call fastcc void %f1917(i8* %z1921, i8* %e1918)
; do set!
%val1923 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_13Ptr
; tuple ref
%val1924 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1923, i64 0, i32 2
%val1925 = load i8*, i8** %val1924
%val1926 = bitcast i8* %val1925 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val1926, {i64,i8*,i8*}** %hook_s_13Ptr
%val1928 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_13Ptr
%val1929 = icmp eq {i64,i8*,i8*}* %val1928, null
br i1 %val1929, label %then1927, label %else1927

then1927:
%res1930 = call ccc i1 @impc_false()
store i1 %res1930, i1* %ifptr1927
br label %ifcont1927

else1927:
%res1931 = call ccc i1 @impc_true()
store i1 %res1931, i1* %ifptr1927
br label %ifcont1927

ifcont1927:
%ifres1932 = load i1, i1* %ifptr1927

br i1 %ifres1932, label %loop1902, label %after1902

after1902:
%val1934 = load %mzone*, %mzone** %zone3Ptr
call ccc void @llvm_zone_destroy(%mzone* %val1934)
%val1936 = load %String*, %String** %rescopy3Ptr
ret %String* %val1936
}
@gsxtmnanovg94 = hidden constant [105 x i8] c"toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}** @toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1958 = load i8*, i8** %_impzPtr
%zone1959 = bitcast i8* %tzone1958 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd
%dat_toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd = call i8* @llvm_zone_malloc(%mzone* %zone1959, i64 8)
%toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipdPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd to { i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}***
%tzone1939 = load i8*, i8** %_impzPtr
%zone1940 = bitcast i8* %tzone1939 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1940)
; malloc closure structure
%clsptr1941 = call i8* @llvm_zone_malloc(%mzone* %zone1940, i64 24)
%closure1942 = bitcast i8* %clsptr1941 to { i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}*

; malloc environment structure
%envptr1943 = call i8* @llvm_zone_malloc(%mzone* %zone1940, i64 8)
%environment1944 = bitcast i8* %envptr1943 to {{i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}***}*

; malloc closure address table
%addytable1945 = call %clsvar* @new_address_table()
%var1946 = bitcast [52 x i8]* @gsxtmnanovg92 to i8*
%var1947 = bitcast [55 x i8]* @gsxtmnanovg93 to i8*
%addytable1948 = call %clsvar* @add_address_table(%mzone* %zone1940, i8* %var1946, i32 0, i8* %var1947, i32 3, %clsvar* %addytable1945)
%address-table1949 = bitcast %clsvar* %addytable1948 to i8*

; insert table, function and environment into closure struct
%closure.table1952 = getelementptr { i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}, { i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}* %closure1942, i32 0, i32 0
store i8* %address-table1949, i8** %closure.table1952
%closure.env1953 = getelementptr { i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}, { i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}* %closure1942, i32 0, i32 1
store i8* %envptr1943, i8** %closure.env1953
%closure.func1954 = getelementptr { i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}, { i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}* %closure1942, i32 0, i32 2
store %String* (i8*, i8*, %NVGglyphPosition*)* @toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd__1728, %String* (i8*, i8*, %NVGglyphPosition*)** %closure.func1954
%closure_size1955 = call i64 @llvm_zone_mark_size(%mzone* %zone1940)
call void @llvm_zone_ptr_set_size(i8* %clsptr1941, i64 %closure_size1955)
%wrapper_ptr1956 = call i8* @llvm_zone_malloc(%mzone* %zone1940, i64 8)
%closure_wrapper1957 = bitcast i8* %wrapper_ptr1956 to { i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}**
store { i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}* %closure1942, { i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}** %closure_wrapper1957

; let value assignment
%toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd = select i1 true, { i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}** %closure_wrapper1957, { i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}** %closure_wrapper1957
store { i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}** %toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd, { i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}*** %toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipdPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd
%tmp_envptr1951 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}***}* %environment1944, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}*** %toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipdPtr, {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}**** %tmp_envptr1951


%val1960 = load {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}**, {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}*** %toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipdPtr
ret {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}** %val1960
}


@toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}** @toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd(%NVGglyphPosition* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGglyphPosition*)*,  %String* (i8*, i8*, %NVGglyphPosition*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGglyphPosition* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd_native(%NVGglyphPosition* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGglyphPosition*)*,  %String* (i8*, i8*, %NVGglyphPosition*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGglyphPosition* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1961 = bitcast [105 x i8]* @gsxtmnanovg94 to i8*
call i32 (i8*, ...) @printf(i8* %var1961)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGglyphPosition*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGglyphPosition*)*,  %String* (i8*, i8*, %NVGglyphPosition*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGglyphPosition* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGglyphPosition*}*
%arg_p_0 = getelementptr {%NVGglyphPosition*}, {%NVGglyphPosition*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGglyphPosition*, %NVGglyphPosition** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHZ2x5cGhQb3NpdGlvbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGglyphPosition*)*,  %String* (i8*, i8*, %NVGglyphPosition*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGglyphPosition* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg95 = hidden constant [45 x i8] c"print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd\00"
@gsxtmnanovg96 = hidden constant [51 x i8] c"{i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd__1962(i8* %_impz,i8* %_impenv, %NVGglyphPosition* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1963 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}***}*
%print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipdPtr = load {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}***, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}**** %print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipdPtr_

; setup arguments
%xPtr = alloca %NVGglyphPosition*
store %NVGglyphPosition* %x, %NVGglyphPosition** %xPtr


%val1965 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
%val1966 = icmp eq %NVGglyphPosition* %val1965, null
br i1 %val1966, label %then1964, label %else1964

then1964:
%var1967 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1968 = bitcast [24 x i8]* @gsxtmnanovg90 to i8*

%val1969 = call i32 (i8*, ...) @printf(i8* %var1967, i8* %var1968)
br label %ifcont1964

else1964:
%var1971 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1972 = bitcast [19 x i8]* @gsxtmnanovg91 to i8*

%val1973 = call i32 (i8*, ...) @printf(i8* %var1971, i8* %var1972)
%val1974 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
; tuple ref
%val1975 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val1974, i64 0, i32 0
%val1976 = load i8*, i8** %val1975
call fastcc void @print_adhoc_W3ZvaWQsaTgqXQ(i8* %val1976)
%var1978 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1979 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val1980 = call i32 (i8*, ...) @printf(i8* %var1978, i8* %var1979)
%val1981 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
; tuple ref
%val1982 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val1981, i64 0, i32 1
%val1983 = load float, float* %val1982
call fastcc void @print_adhoc_W3ZvaWQsZmxvYXRd(float %val1983)
%var1985 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1986 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val1987 = call i32 (i8*, ...) @printf(i8* %var1985, i8* %var1986)
%val1988 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
; tuple ref
%val1989 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val1988, i64 0, i32 2
%val1990 = load float, float* %val1989
call fastcc void @print_adhoc_W3ZvaWQsZmxvYXRd(float %val1990)
%var1992 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var1993 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val1994 = call i32 (i8*, ...) @printf(i8* %var1992, i8* %var1993)
%val1995 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
; tuple ref
%val1996 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val1995, i64 0, i32 3
%val1997 = load float, float* %val1996
call fastcc void @print_adhoc_W3ZvaWQsZmxvYXRd(float %val1997)
%var1999 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var2000 = bitcast [2 x i8]* @gsxtmnanovg65 to i8*

%val2001 = call i32 (i8*, ...) @printf(i8* %var1999, i8* %var2000)
br label %ifcont1964

ifcont1964:
ret void
}
@gsxtmnanovg97 = hidden constant [98 x i8] c"print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** @print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2023 = load i8*, i8** %_impzPtr
%zone2024 = bitcast i8* %tzone2023 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd
%dat_print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd = call i8* @llvm_zone_malloc(%mzone* %zone2024, i64 8)
%print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd to { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}***
%tzone2004 = load i8*, i8** %_impzPtr
%zone2005 = bitcast i8* %tzone2004 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2005)
; malloc closure structure
%clsptr2006 = call i8* @llvm_zone_malloc(%mzone* %zone2005, i64 24)
%closure2007 = bitcast i8* %clsptr2006 to { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}*

; malloc environment structure
%envptr2008 = call i8* @llvm_zone_malloc(%mzone* %zone2005, i64 8)
%environment2009 = bitcast i8* %envptr2008 to {{i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}***}*

; malloc closure address table
%addytable2010 = call %clsvar* @new_address_table()
%var2011 = bitcast [45 x i8]* @gsxtmnanovg95 to i8*
%var2012 = bitcast [51 x i8]* @gsxtmnanovg96 to i8*
%addytable2013 = call %clsvar* @add_address_table(%mzone* %zone2005, i8* %var2011, i32 0, i8* %var2012, i32 3, %clsvar* %addytable2010)
%address-table2014 = bitcast %clsvar* %addytable2013 to i8*

; insert table, function and environment into closure struct
%closure.table2017 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure2007, i32 0, i32 0
store i8* %address-table2014, i8** %closure.table2017
%closure.env2018 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure2007, i32 0, i32 1
store i8* %envptr2008, i8** %closure.env2018
%closure.func2019 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure2007, i32 0, i32 2
store void (i8*, i8*, %NVGglyphPosition*)* @print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd__1962, void (i8*, i8*, %NVGglyphPosition*)** %closure.func2019
%closure_size2020 = call i64 @llvm_zone_mark_size(%mzone* %zone2005)
call void @llvm_zone_ptr_set_size(i8* %clsptr2006, i64 %closure_size2020)
%wrapper_ptr2021 = call i8* @llvm_zone_malloc(%mzone* %zone2005, i64 8)
%closure_wrapper2022 = bitcast i8* %wrapper_ptr2021 to { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}**
store { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure2007, { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** %closure_wrapper2022

; let value assignment
%print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd = select i1 true, { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** %closure_wrapper2022, { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** %closure_wrapper2022
store { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** %print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd, { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}*** %print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd
%tmp_envptr2016 = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}***}* %environment2009, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}*** %print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipdPtr, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}**** %tmp_envptr2016


%val2025 = load {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}**, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}*** %print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipdPtr
ret {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** %val2025
}


@print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** @print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd(%NVGglyphPosition* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}*, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGglyphPosition*)*,  void (i8*, i8*, %NVGglyphPosition*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGglyphPosition* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_native(%NVGglyphPosition* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}*, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGglyphPosition*)*,  void (i8*, i8*, %NVGglyphPosition*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGglyphPosition* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2026 = bitcast [98 x i8]* @gsxtmnanovg97 to i8*
call i32 (i8*, ...) @printf(i8* %var2026)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGglyphPosition*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}*, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGglyphPosition*)*,  void (i8*, i8*, %NVGglyphPosition*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGglyphPosition* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGglyphPosition*}*
%arg_p_0 = getelementptr {%NVGglyphPosition*}, {%NVGglyphPosition*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGglyphPosition*, %NVGglyphPosition** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}*, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGglyphPosition*)*,  void (i8*, i8*, %NVGglyphPosition*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGglyphPosition* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg98 = hidden constant [82 x i8] c"NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
@gsxtmnanovg99 = hidden constant [70 x i8] c"{i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}**\00"
define dllexport fastcc %NVGglyphPosition @NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ__2027(i8* %_impz,i8* %_impenv, i8* %arg_0, float %arg_1, float %arg_2, float %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2028 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}***}*
%NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}***}, {{i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}***}* %impenv, i32 0, i32 0
%NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}***, {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}**** %NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%arg_0Ptr = alloca i8*
store i8* %arg_0, i8** %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr
%arg_2Ptr = alloca float
store float %arg_2, float* %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr


%tzone2030 = load i8*, i8** %_impzPtr
%zone2031 = bitcast i8* %tzone2030 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGglyphPosition*
%dat2029 = alloca %NVGglyphPosition, align 16

; let value assignment
%obj = select i1 true, %NVGglyphPosition* %dat2029, %NVGglyphPosition* %dat2029
store %NVGglyphPosition* %obj, %NVGglyphPosition** %objPtr

%val2032 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val2033 = load i8*, i8** %arg_0Ptr
; set tuple
%val2034 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2032, i64 0, i32 0
store i8* %val2033, i8** %val2034
%val2035 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val2036 = load float, float* %arg_1Ptr
; set tuple
%val2037 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2035, i64 0, i32 1
store float %val2036, float* %val2037
%val2038 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val2039 = load float, float* %arg_2Ptr
; set tuple
%val2040 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2038, i64 0, i32 2
store float %val2039, float* %val2040
%val2041 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val2042 = load float, float* %arg_3Ptr
; set tuple
%val2043 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2041, i64 0, i32 3
store float %val2042, float* %val2043
%val2044 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
; pointer ref
%val2045 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2044, i64 0
%val2046 = load %NVGglyphPosition, %NVGglyphPosition* %val2045
ret %NVGglyphPosition %val2046
}
@gsxtmnanovg100 = hidden constant [135 x i8] c"NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}** @NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2066 = load i8*, i8** %_impzPtr
%zone2067 = bitcast i8* %tzone2066 to %mzone*

; let assign value to symbol NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone2067, i64 8)
%NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ to { i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}***
%tzone2047 = load i8*, i8** %_impzPtr
%zone2048 = bitcast i8* %tzone2047 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2048)
; malloc closure structure
%clsptr2049 = call i8* @llvm_zone_malloc(%mzone* %zone2048, i64 24)
%closure2050 = bitcast i8* %clsptr2049 to { i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}*

; malloc environment structure
%envptr2051 = call i8* @llvm_zone_malloc(%mzone* %zone2048, i64 8)
%environment2052 = bitcast i8* %envptr2051 to {{i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}***}*

; malloc closure address table
%addytable2053 = call %clsvar* @new_address_table()
%var2054 = bitcast [82 x i8]* @gsxtmnanovg98 to i8*
%var2055 = bitcast [70 x i8]* @gsxtmnanovg99 to i8*
%addytable2056 = call %clsvar* @add_address_table(%mzone* %zone2048, i8* %var2054, i32 0, i8* %var2055, i32 3, %clsvar* %addytable2053)
%address-table2057 = bitcast %clsvar* %addytable2056 to i8*

; insert table, function and environment into closure struct
%closure.table2060 = getelementptr { i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}* %closure2050, i32 0, i32 0
store i8* %address-table2057, i8** %closure.table2060
%closure.env2061 = getelementptr { i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}* %closure2050, i32 0, i32 1
store i8* %envptr2051, i8** %closure.env2061
%closure.func2062 = getelementptr { i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}* %closure2050, i32 0, i32 2
store %NVGglyphPosition (i8*, i8*, i8*, float, float, float)* @NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ__2027, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)** %closure.func2062
%closure_size2063 = call i64 @llvm_zone_mark_size(%mzone* %zone2048)
call void @llvm_zone_ptr_set_size(i8* %clsptr2049, i64 %closure_size2063)
%wrapper_ptr2064 = call i8* @llvm_zone_malloc(%mzone* %zone2048, i64 8)
%closure_wrapper2065 = bitcast i8* %wrapper_ptr2064 to { i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}**
store { i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}* %closure2050, { i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}** %closure_wrapper2065

; let value assignment
%NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}** %closure_wrapper2065, { i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}** %closure_wrapper2065
store { i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}** %NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ, { i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}*** %NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr2059 = getelementptr {{i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}***}, {{i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}***}* %environment2052, i32 0, i32 0
store {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}*** %NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}**** %tmp_envptr2059


%val2068 = load {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}**, {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}*** %NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}** %val2068
}


@NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}** @NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGglyphPosition @NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ(i8* %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*,  %NVGglyphPosition (i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition %ff(i8* %_impz, i8* %ee, i8* %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGglyphPosition %result
}


define dllexport ccc %NVGglyphPosition @NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_native(i8* %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*,  %NVGglyphPosition (i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition %ff(i8* %_impz, i8* %ee, i8* %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGglyphPosition %result
}


define dllexport ccc void @NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, float, float, float}*
%arg_p_0 = getelementptr {i8*, float, float, float}, {i8*, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, float, float, float}, {i8*, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {i8*, float, float, float}, {i8*, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {i8*, float, float, float}, {i8*, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGglyphPosition_val_adhoc_W05WR2dseXBoUG9zaXRpb24saTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition (i8*, i8*, i8*, float, float, float)*,  %NVGglyphPosition (i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition %ff(i8* %_impz, i8* %ee, i8* %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg101 = hidden constant [63 x i8] c"hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ\00"
@gsxtmnanovg102 = hidden constant [65 x i8] c"{i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}**\00"
define dllexport fastcc %NVGglyphPosition* @hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ__2073(i8* %_impz,i8* %_impenv, %NVGglyphPosition* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2074 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}***}*
%hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQPtr_ = getelementptr {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}***}, {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQPtr = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}***, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}**** %hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQPtr_

; setup arguments
%xPtr = alloca %NVGglyphPosition*
store %NVGglyphPosition* %x, %NVGglyphPosition** %xPtr


%tzone2077 = load i8*, i8** %_impzPtr
%zone2078 = bitcast i8* %tzone2077 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGglyphPosition*
%dat2075 = call i8* @malloc(i64 24)
call i8* @memset(i8* %dat2075, i32 0, i64 24)
%val2076 = bitcast i8* %dat2075 to %NVGglyphPosition*

; let value assignment
%obj = select i1 true, %NVGglyphPosition* %val2076, %NVGglyphPosition* %val2076
store %NVGglyphPosition* %obj, %NVGglyphPosition** %objPtr

%val2079 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val2080 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
; tuple ref
%val2081 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2080, i64 0, i32 0
%val2082 = load i8*, i8** %val2081
; set tuple
%val2083 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2079, i64 0, i32 0
store i8* %val2082, i8** %val2083
%val2084 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val2085 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
; tuple ref
%val2086 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2085, i64 0, i32 1
%val2087 = load float, float* %val2086
; set tuple
%val2088 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2084, i64 0, i32 1
store float %val2087, float* %val2088
%val2089 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val2090 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
; tuple ref
%val2091 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2090, i64 0, i32 2
%val2092 = load float, float* %val2091
; set tuple
%val2093 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2089, i64 0, i32 2
store float %val2092, float* %val2093
%val2094 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val2095 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
; tuple ref
%val2096 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2095, i64 0, i32 3
%val2097 = load float, float* %val2096
; set tuple
%val2098 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2094, i64 0, i32 3
store float %val2097, float* %val2098
%val2099 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
ret %NVGglyphPosition* %val2099
}
@gsxtmnanovg103 = hidden constant [116 x i8] c"hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}** @hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2119 = load i8*, i8** %_impzPtr
%zone2120 = bitcast i8* %tzone2119 to %mzone*

; let assign value to symbol hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ
%dat_hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ = call i8* @llvm_zone_malloc(%mzone* %zone2120, i64 8)
%hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQPtr = bitcast i8* %dat_hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ to { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}***
%tzone2100 = load i8*, i8** %_impzPtr
%zone2101 = bitcast i8* %tzone2100 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2101)
; malloc closure structure
%clsptr2102 = call i8* @llvm_zone_malloc(%mzone* %zone2101, i64 24)
%closure2103 = bitcast i8* %clsptr2102 to { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}*

; malloc environment structure
%envptr2104 = call i8* @llvm_zone_malloc(%mzone* %zone2101, i64 8)
%environment2105 = bitcast i8* %envptr2104 to {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}***}*

; malloc closure address table
%addytable2106 = call %clsvar* @new_address_table()
%var2107 = bitcast [63 x i8]* @gsxtmnanovg101 to i8*
%var2108 = bitcast [65 x i8]* @gsxtmnanovg102 to i8*
%addytable2109 = call %clsvar* @add_address_table(%mzone* %zone2101, i8* %var2107, i32 0, i8* %var2108, i32 3, %clsvar* %addytable2106)
%address-table2110 = bitcast %clsvar* %addytable2109 to i8*

; insert table, function and environment into closure struct
%closure.table2113 = getelementptr { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}* %closure2103, i32 0, i32 0
store i8* %address-table2110, i8** %closure.table2113
%closure.env2114 = getelementptr { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}* %closure2103, i32 0, i32 1
store i8* %envptr2104, i8** %closure.env2114
%closure.func2115 = getelementptr { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}* %closure2103, i32 0, i32 2
store %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)* @hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ__2073, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)** %closure.func2115
%closure_size2116 = call i64 @llvm_zone_mark_size(%mzone* %zone2101)
call void @llvm_zone_ptr_set_size(i8* %clsptr2102, i64 %closure_size2116)
%wrapper_ptr2117 = call i8* @llvm_zone_malloc(%mzone* %zone2101, i64 8)
%closure_wrapper2118 = bitcast i8* %wrapper_ptr2117 to { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}**
store { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}* %closure2103, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}** %closure_wrapper2118

; let value assignment
%hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ = select i1 true, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}** %closure_wrapper2118, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}** %closure_wrapper2118
store { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}** %hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}*** %hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ
%tmp_envptr2112 = getelementptr {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}***}, {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}***}* %environment2105, i32 0, i32 0
store {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}*** %hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQPtr, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}**** %tmp_envptr2112


%val2121 = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}**, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}*** %hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQPtr
ret {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}** %val2121
}


@hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}** @hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGglyphPosition* @hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ(%NVGglyphPosition* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}**
%closure = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}*, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*,  %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition* %ff(i8* %_impz, i8* %ee, %NVGglyphPosition* %arg_0)
ret %NVGglyphPosition* %result
}


define dllexport ccc %NVGglyphPosition* @hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ_native(%NVGglyphPosition* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}**
%closure = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}*, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*,  %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition* %ff(i8* %_impz, i8* %ee, %NVGglyphPosition* %arg_0)
ret %NVGglyphPosition* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2122 = bitcast [116 x i8]* @gsxtmnanovg103 to i8*
call i32 (i8*, ...) @printf(i8* %var2122)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGglyphPosition*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}**
%closure = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}*, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*,  %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition* %ff(i8* %_impz, i8* %ee, %NVGglyphPosition* %arg_0)
%tmpres = bitcast %NVGglyphPosition* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGglyphPosition*}*
%arg_p_0 = getelementptr {%NVGglyphPosition*}, {%NVGglyphPosition*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGglyphPosition*, %NVGglyphPosition** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}**
%closure = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}*, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)*,  %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition* %ff(i8* %_impz, i8* %ee, %NVGglyphPosition* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg104 = hidden constant [45 x i8] c"hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd__2123(i8* %_impz,i8* %_impenv, %NVGglyphPosition* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2124 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}***}*
%hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipdPtr = load {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}***, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}**** %hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipdPtr_

; setup arguments
%xPtr = alloca %NVGglyphPosition*
store %NVGglyphPosition* %x, %NVGglyphPosition** %xPtr


%val2125 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
%val2126 = bitcast %NVGglyphPosition* %val2125 to i8*
call ccc void @free(i8* %val2126)
ret void
}
@gsxtmnanovg105 = hidden constant [98 x i8] c"hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** @hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2148 = load i8*, i8** %_impzPtr
%zone2149 = bitcast i8* %tzone2148 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd
%dat_hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd = call i8* @llvm_zone_malloc(%mzone* %zone2149, i64 8)
%hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipdPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd to { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}***
%tzone2129 = load i8*, i8** %_impzPtr
%zone2130 = bitcast i8* %tzone2129 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2130)
; malloc closure structure
%clsptr2131 = call i8* @llvm_zone_malloc(%mzone* %zone2130, i64 24)
%closure2132 = bitcast i8* %clsptr2131 to { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}*

; malloc environment structure
%envptr2133 = call i8* @llvm_zone_malloc(%mzone* %zone2130, i64 8)
%environment2134 = bitcast i8* %envptr2133 to {{i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}***}*

; malloc closure address table
%addytable2135 = call %clsvar* @new_address_table()
%var2136 = bitcast [45 x i8]* @gsxtmnanovg104 to i8*
%var2137 = bitcast [51 x i8]* @gsxtmnanovg96 to i8*
%addytable2138 = call %clsvar* @add_address_table(%mzone* %zone2130, i8* %var2136, i32 0, i8* %var2137, i32 3, %clsvar* %addytable2135)
%address-table2139 = bitcast %clsvar* %addytable2138 to i8*

; insert table, function and environment into closure struct
%closure.table2142 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure2132, i32 0, i32 0
store i8* %address-table2139, i8** %closure.table2142
%closure.env2143 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure2132, i32 0, i32 1
store i8* %envptr2133, i8** %closure.env2143
%closure.func2144 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure2132, i32 0, i32 2
store void (i8*, i8*, %NVGglyphPosition*)* @hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd__2123, void (i8*, i8*, %NVGglyphPosition*)** %closure.func2144
%closure_size2145 = call i64 @llvm_zone_mark_size(%mzone* %zone2130)
call void @llvm_zone_ptr_set_size(i8* %clsptr2131, i64 %closure_size2145)
%wrapper_ptr2146 = call i8* @llvm_zone_malloc(%mzone* %zone2130, i64 8)
%closure_wrapper2147 = bitcast i8* %wrapper_ptr2146 to { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}**
store { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure2132, { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** %closure_wrapper2147

; let value assignment
%hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd = select i1 true, { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** %closure_wrapper2147, { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** %closure_wrapper2147
store { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** %hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd, { i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}*** %hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipdPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd
%tmp_envptr2141 = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}***}* %environment2134, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}*** %hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipdPtr, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}**** %tmp_envptr2141


%val2150 = load {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}**, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}*** %hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipdPtr
ret {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** %val2150
}


@hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** @hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd(%NVGglyphPosition* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}*, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGglyphPosition*)*,  void (i8*, i8*, %NVGglyphPosition*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGglyphPosition* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_native(%NVGglyphPosition* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}*, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGglyphPosition*)*,  void (i8*, i8*, %NVGglyphPosition*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGglyphPosition* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2151 = bitcast [98 x i8]* @gsxtmnanovg105 to i8*
call i32 (i8*, ...) @printf(i8* %var2151)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGglyphPosition*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}*, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGglyphPosition*)*,  void (i8*, i8*, %NVGglyphPosition*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGglyphPosition* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGglyphPosition*}*
%arg_p_0 = getelementptr {%NVGglyphPosition*}, {%NVGglyphPosition*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGglyphPosition*, %NVGglyphPosition** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHZ2x5cGhQb3NpdGlvbipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}*, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}, {i8*, i8*, void (i8*, i8*, %NVGglyphPosition*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGglyphPosition*)*,  void (i8*, i8*, %NVGglyphPosition*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGglyphPosition* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg106 = hidden constant [81 x i8] c"zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd\00"
@gsxtmnanovg107 = hidden constant [83 x i8] c"{i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %NVGglyphPosition* @zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd__2152(i8* %_impz,i8* %_impenv, %NVGglyphPosition* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2153 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpdPtr = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}***, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpdPtr_

; setup arguments
%xPtr = alloca %NVGglyphPosition*
store %NVGglyphPosition* %x, %NVGglyphPosition** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val2155 = load %mzone*, %mzone** %fromzPtr
%val2156 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
%val2157 = bitcast %NVGglyphPosition* %val2156 to i8*
%res2158 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val2155, i8* %val2157)
br i1 %res2158, label %then2154, label %else2154

then2154:
%val2159 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val2159)
%zone_ptr2160 = bitcast %mzone* %val2159 to i8*
store i8* %zone_ptr2160, i8** %_impzPtr
%tzone2166 = load i8*, i8** %_impzPtr
%zone2167 = bitcast i8* %tzone2166 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGglyphPosition*
%tzone2162 = load i8*, i8** %_impzPtr
%zone2163 = bitcast i8* %tzone2162 to %mzone*
%dat2164 = call i8* @llvm_zone_malloc(%mzone* %zone2163, i64 24)
call i8* @memset(i8* %dat2164, i32 0, i64 24)
%val2165 = bitcast i8* %dat2164 to %NVGglyphPosition*

; let value assignment
%obj = select i1 true, %NVGglyphPosition* %val2165, %NVGglyphPosition* %val2165
store %NVGglyphPosition* %obj, %NVGglyphPosition** %objPtr

; promote local stack var allocations
%tzone2216 = load i8*, i8** %_impzPtr
%zone2217 = bitcast i8* %tzone2216 to %mzone*
%ifptr2168 = alloca i8*
%val2169 = load %mzone*, %mzone** %fromzPtr
%val2170 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
; tuple ref
%val2171 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2170, i64 0, i32 0
%val2172 = load i8*, i8** %val2171
%val2173 = bitcast i8* %val2172 to i8*
%res2174 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val2169, i8* %val2173)
br i1 %res2174, label %then2168, label %else2168

then2168:
%tzone2179 = load i8*, i8** %_impzPtr
%zone2180 = bitcast i8* %tzone2179 to %mzone*

; let assign value to symbol newptr
%newptrPtr = alloca i8*
%tzone2175 = load i8*, i8** %_impzPtr
%zone2176 = bitcast i8* %tzone2175 to %mzone*
%dat2177 = call i8* @llvm_zone_malloc(%mzone* %zone2176, i64 1)
call i8* @memset(i8* %dat2177, i32 0, i64 1)
%val2178 = bitcast i8* %dat2177 to i8*

; let value assignment
%newptr = select i1 true, i8* %val2178, i8* %val2178
store i8* %newptr, i8** %newptrPtr

%val2181 = load i8*, i8** %newptrPtr
%val2182 = bitcast i8* %val2181 to i8*
%val2183 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
; tuple ref
%val2184 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2183, i64 0, i32 0
%val2185 = load i8*, i8** %val2184
%val2186 = bitcast i8* %val2185 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val2182, i8* %val2186, i64 1, i32 1, i1 0)
%val2188 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val2189 = load i8*, i8** %newptrPtr
; set tuple
%val2190 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2188, i64 0, i32 0
store i8* %val2189, i8** %val2190
store i8* %val2189, i8** %ifptr2168
br label %ifcont2168

else2168:
%val2191 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val2192 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
; tuple ref
%val2193 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2192, i64 0, i32 0
%val2194 = load i8*, i8** %val2193
; set tuple
%val2195 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2191, i64 0, i32 0
store i8* %val2194, i8** %val2195
store i8* %val2194, i8** %ifptr2168
br label %ifcont2168

ifcont2168:
%ifres2196 = load i8*, i8** %ifptr2168

%val2197 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val2198 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
; tuple ref
%val2199 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2198, i64 0, i32 1
%val2200 = load float, float* %val2199
; set tuple
%val2201 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2197, i64 0, i32 1
store float %val2200, float* %val2201
%val2202 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val2203 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
; tuple ref
%val2204 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2203, i64 0, i32 2
%val2205 = load float, float* %val2204
; set tuple
%val2206 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2202, i64 0, i32 2
store float %val2205, float* %val2206
%val2207 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
%val2208 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
; tuple ref
%val2209 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2208, i64 0, i32 3
%val2210 = load float, float* %val2209
; set tuple
%val2211 = getelementptr %NVGglyphPosition, %NVGglyphPosition* %val2207, i64 0, i32 3
store float %val2210, float* %val2211
%oldzone2212 = call %mzone* @llvm_pop_zone_stack()
%newzone2213 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr2214 = bitcast %mzone* %newzone2213 to i8*
store i8* %zone_ptr2214, i8** %_impzPtr
%val2215 = load %NVGglyphPosition*, %NVGglyphPosition** %objPtr
ret %NVGglyphPosition* %val2215

else2154:
%val2218 = load %NVGglyphPosition*, %NVGglyphPosition** %xPtr
ret %NVGglyphPosition* %val2218
}
@gsxtmnanovg108 = hidden constant [134 x i8] c"zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}** @zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2238 = load i8*, i8** %_impzPtr
%zone2239 = bitcast i8* %tzone2238 to %mzone*

; let assign value to symbol zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd
%dat_zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone2239, i64 8)
%zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpdPtr = bitcast i8* %dat_zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd to { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}***
%tzone2219 = load i8*, i8** %_impzPtr
%zone2220 = bitcast i8* %tzone2219 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2220)
; malloc closure structure
%clsptr2221 = call i8* @llvm_zone_malloc(%mzone* %zone2220, i64 24)
%closure2222 = bitcast i8* %clsptr2221 to { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr2223 = call i8* @llvm_zone_malloc(%mzone* %zone2220, i64 8)
%environment2224 = bitcast i8* %envptr2223 to {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable2225 = call %clsvar* @new_address_table()
%var2226 = bitcast [81 x i8]* @gsxtmnanovg106 to i8*
%var2227 = bitcast [83 x i8]* @gsxtmnanovg107 to i8*
%addytable2228 = call %clsvar* @add_address_table(%mzone* %zone2220, i8* %var2226, i32 0, i8* %var2227, i32 3, %clsvar* %addytable2225)
%address-table2229 = bitcast %clsvar* %addytable2228 to i8*

; insert table, function and environment into closure struct
%closure.table2232 = getelementptr { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}* %closure2222, i32 0, i32 0
store i8* %address-table2229, i8** %closure.table2232
%closure.env2233 = getelementptr { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}* %closure2222, i32 0, i32 1
store i8* %envptr2223, i8** %closure.env2233
%closure.func2234 = getelementptr { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}* %closure2222, i32 0, i32 2
store %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)* @zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd__2152, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)** %closure.func2234
%closure_size2235 = call i64 @llvm_zone_mark_size(%mzone* %zone2220)
call void @llvm_zone_ptr_set_size(i8* %clsptr2221, i64 %closure_size2235)
%wrapper_ptr2236 = call i8* @llvm_zone_malloc(%mzone* %zone2220, i64 8)
%closure_wrapper2237 = bitcast i8* %wrapper_ptr2236 to { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}**
store { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}* %closure2222, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}** %closure_wrapper2237

; let value assignment
%zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd = select i1 true, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}** %closure_wrapper2237, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}** %closure_wrapper2237
store { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}** %zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd, { i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd
%tmp_envptr2231 = getelementptr {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}***}* %environment2224, i32 0, i32 0
store {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpdPtr, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}**** %tmp_envptr2231


%val2240 = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}**, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpdPtr
ret {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}** %val2240
}


@zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}** @zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGglyphPosition* @zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd(%NVGglyphPosition* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*,  %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition* %ff(i8* %_impz, i8* %ee, %NVGglyphPosition* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %NVGglyphPosition* %result
}


define dllexport ccc %NVGglyphPosition* @zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd_native(%NVGglyphPosition* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*,  %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition* %ff(i8* %_impz, i8* %ee, %NVGglyphPosition* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %NVGglyphPosition* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2241 = bitcast [134 x i8]* @gsxtmnanovg108 to i8*
call i32 (i8*, ...) @printf(i8* %var2241)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGglyphPosition*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2242 = bitcast [134 x i8]* @gsxtmnanovg108 to i8*
call i32 (i8*, ...) @printf(i8* %var2242)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2243 = bitcast [134 x i8]* @gsxtmnanovg108 to i8*
call i32 (i8*, ...) @printf(i8* %var2243)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*,  %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition* %ff(i8* %_impz, i8* %ee, %NVGglyphPosition* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %NVGglyphPosition* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGglyphPosition*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%NVGglyphPosition*, %mzone*, %mzone*}, {%NVGglyphPosition*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGglyphPosition*, %NVGglyphPosition** %arg_p_0
%arg_p_1 = getelementptr {%NVGglyphPosition*, %mzone*, %mzone*}, {%NVGglyphPosition*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%NVGglyphPosition*, %mzone*, %mzone*}, {%NVGglyphPosition*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR2dseXBoUG9zaXRpb24qLE5WR2dseXBoUG9zaXRpb24qLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)*,  %NVGglyphPosition* (i8*, i8*, %NVGglyphPosition*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGglyphPosition* %ff(i8* %_impz, i8* %ee, %NVGglyphPosition* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%NVGtextRow = type {i8*,i8*,i8*,float,float,float}
@gsxtmnanovg109 = hidden constant [76 x i8] c"NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
@gsxtmnanovg110 = hidden constant [75 x i8] c"{i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**\00"
define dllexport fastcc %NVGtextRow* @NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ__2244(i8* %_impz,i8* %_impenv, i8* %arg_0, i8* %arg_1, i8* %arg_2, float %arg_3, float %arg_4, float %arg_5) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2245 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}*
%NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}, {{i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}* %impenv, i32 0, i32 0
%NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**** %NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%arg_0Ptr = alloca i8*
store i8* %arg_0, i8** %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr
%arg_2Ptr = alloca i8*
store i8* %arg_2, i8** %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr
%arg_4Ptr = alloca float
store float %arg_4, float* %arg_4Ptr
%arg_5Ptr = alloca float
store float %arg_5, float* %arg_5Ptr


%tzone2250 = load i8*, i8** %_impzPtr
%zone2251 = bitcast i8* %tzone2250 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGtextRow*
%tzone2246 = load i8*, i8** %_impzPtr
%zone2247 = bitcast i8* %tzone2246 to %mzone*
%dat2248 = call i8* @llvm_zone_malloc(%mzone* %zone2247, i64 40)
call i8* @memset(i8* %dat2248, i32 0, i64 40)
%val2249 = bitcast i8* %dat2248 to %NVGtextRow*

; let value assignment
%obj = select i1 true, %NVGtextRow* %val2249, %NVGtextRow* %val2249
store %NVGtextRow* %obj, %NVGtextRow** %objPtr

%val2252 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2253 = load i8*, i8** %arg_0Ptr
; set tuple
%val2254 = getelementptr %NVGtextRow, %NVGtextRow* %val2252, i64 0, i32 0
store i8* %val2253, i8** %val2254
%val2255 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2256 = load i8*, i8** %arg_1Ptr
; set tuple
%val2257 = getelementptr %NVGtextRow, %NVGtextRow* %val2255, i64 0, i32 1
store i8* %val2256, i8** %val2257
%val2258 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2259 = load i8*, i8** %arg_2Ptr
; set tuple
%val2260 = getelementptr %NVGtextRow, %NVGtextRow* %val2258, i64 0, i32 2
store i8* %val2259, i8** %val2260
%val2261 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2262 = load float, float* %arg_3Ptr
; set tuple
%val2263 = getelementptr %NVGtextRow, %NVGtextRow* %val2261, i64 0, i32 3
store float %val2262, float* %val2263
%val2264 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2265 = load float, float* %arg_4Ptr
; set tuple
%val2266 = getelementptr %NVGtextRow, %NVGtextRow* %val2264, i64 0, i32 4
store float %val2265, float* %val2266
%val2267 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2268 = load float, float* %arg_5Ptr
; set tuple
%val2269 = getelementptr %NVGtextRow, %NVGtextRow* %val2267, i64 0, i32 5
store float %val2268, float* %val2269
%val2270 = load %NVGtextRow*, %NVGtextRow** %objPtr
ret %NVGtextRow* %val2270
}
@gsxtmnanovg111 = hidden constant [129 x i8] c"NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** @NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2290 = load i8*, i8** %_impzPtr
%zone2291 = bitcast i8* %tzone2290 to %mzone*

; let assign value to symbol NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone2291, i64 8)
%NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ to { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***
%tzone2271 = load i8*, i8** %_impzPtr
%zone2272 = bitcast i8* %tzone2271 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2272)
; malloc closure structure
%clsptr2273 = call i8* @llvm_zone_malloc(%mzone* %zone2272, i64 24)
%closure2274 = bitcast i8* %clsptr2273 to { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*

; malloc environment structure
%envptr2275 = call i8* @llvm_zone_malloc(%mzone* %zone2272, i64 8)
%environment2276 = bitcast i8* %envptr2275 to {{i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}*

; malloc closure address table
%addytable2277 = call %clsvar* @new_address_table()
%var2278 = bitcast [76 x i8]* @gsxtmnanovg109 to i8*
%var2279 = bitcast [75 x i8]* @gsxtmnanovg110 to i8*
%addytable2280 = call %clsvar* @add_address_table(%mzone* %zone2272, i8* %var2278, i32 0, i8* %var2279, i32 3, %clsvar* %addytable2277)
%address-table2281 = bitcast %clsvar* %addytable2280 to i8*

; insert table, function and environment into closure struct
%closure.table2284 = getelementptr { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure2274, i32 0, i32 0
store i8* %address-table2281, i8** %closure.table2284
%closure.env2285 = getelementptr { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure2274, i32 0, i32 1
store i8* %envptr2275, i8** %closure.env2285
%closure.func2286 = getelementptr { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure2274, i32 0, i32 2
store %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)* @NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ__2244, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)** %closure.func2286
%closure_size2287 = call i64 @llvm_zone_mark_size(%mzone* %zone2272)
call void @llvm_zone_ptr_set_size(i8* %clsptr2273, i64 %closure_size2287)
%wrapper_ptr2288 = call i8* @llvm_zone_malloc(%mzone* %zone2272, i64 8)
%closure_wrapper2289 = bitcast i8* %wrapper_ptr2288 to { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**
store { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure2274, { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_wrapper2289

; let value assignment
%NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_wrapper2289, { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_wrapper2289
store { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ, { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*** %NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr2283 = getelementptr {{i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}, {{i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}* %environment2276, i32 0, i32 0
store {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*** %NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**** %tmp_envptr2283


%val2292 = load {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*** %NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %val2292
}


@NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** @NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGtextRow* @NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ(i8* %arg_0,i8* %arg_1,i8* %arg_2,float %arg_3,float %arg_4,float %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*,  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2, float %arg_3, float %arg_4, float %arg_5)
ret %NVGtextRow* %result
}


define dllexport ccc %NVGtextRow* @NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_native(i8* %arg_0,i8* %arg_1,i8* %arg_2,float %arg_3,float %arg_4,float %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*,  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2, float %arg_3, float %arg_4, float %arg_5)
ret %NVGtextRow* %result
}


define dllexport ccc i8*  @NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2293 = bitcast [129 x i8]* @gsxtmnanovg111 to i8*
call i32 (i8*, ...) @printf(i8* %var2293)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2294 = bitcast [129 x i8]* @gsxtmnanovg111 to i8*
call i32 (i8*, ...) @printf(i8* %var2294)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2295 = bitcast [129 x i8]* @gsxtmnanovg111 to i8*
call i32 (i8*, ...) @printf(i8* %var2295)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2296 = bitcast [129 x i8]* @gsxtmnanovg111 to i8*
call i32 (i8*, ...) @printf(i8* %var2296)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var2297 = bitcast [129 x i8]* @gsxtmnanovg111 to i8*
call i32 (i8*, ...) @printf(i8* %var2297)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_real(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var2298 = bitcast [129 x i8]* @gsxtmnanovg111 to i8*
call i32 (i8*, ...) @printf(i8* %var2298)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc float  @r32value(i8* %arg_5_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*,  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2, float %arg_3, float %arg_4, float %arg_5)
%tmpres = bitcast %NVGtextRow* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i8*, i8*, float, float, float}*
%arg_p_0 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
%arg_p_3 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
%arg_p_5 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 5
%arg_5 = load float, float* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*,  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2, float %arg_3, float %arg_4, float %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg112 = hidden constant [78 x i8] c"NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
define dllexport fastcc %NVGtextRow* @NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ__2299(i8* %_impz,i8* %_impenv, i8* %arg_0, i8* %arg_1, i8* %arg_2, float %arg_3, float %arg_4, float %arg_5) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2300 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}*
%NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}, {{i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}* %impenv, i32 0, i32 0
%NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**** %NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%arg_0Ptr = alloca i8*
store i8* %arg_0, i8** %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr
%arg_2Ptr = alloca i8*
store i8* %arg_2, i8** %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr
%arg_4Ptr = alloca float
store float %arg_4, float* %arg_4Ptr
%arg_5Ptr = alloca float
store float %arg_5, float* %arg_5Ptr


%tzone2305 = load i8*, i8** %_impzPtr
%zone2306 = bitcast i8* %tzone2305 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGtextRow*
%tzone2301 = load i8*, i8** %_impzPtr
%zone2302 = bitcast i8* %tzone2301 to %mzone*
%dat2303 = call i8* @llvm_zone_malloc(%mzone* %zone2302, i64 40)
call i8* @memset(i8* %dat2303, i32 0, i64 40)
%val2304 = bitcast i8* %dat2303 to %NVGtextRow*

; let value assignment
%obj = select i1 true, %NVGtextRow* %val2304, %NVGtextRow* %val2304
store %NVGtextRow* %obj, %NVGtextRow** %objPtr

%val2307 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2308 = load i8*, i8** %arg_0Ptr
; set tuple
%val2309 = getelementptr %NVGtextRow, %NVGtextRow* %val2307, i64 0, i32 0
store i8* %val2308, i8** %val2309
%val2310 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2311 = load i8*, i8** %arg_1Ptr
; set tuple
%val2312 = getelementptr %NVGtextRow, %NVGtextRow* %val2310, i64 0, i32 1
store i8* %val2311, i8** %val2312
%val2313 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2314 = load i8*, i8** %arg_2Ptr
; set tuple
%val2315 = getelementptr %NVGtextRow, %NVGtextRow* %val2313, i64 0, i32 2
store i8* %val2314, i8** %val2315
%val2316 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2317 = load float, float* %arg_3Ptr
; set tuple
%val2318 = getelementptr %NVGtextRow, %NVGtextRow* %val2316, i64 0, i32 3
store float %val2317, float* %val2318
%val2319 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2320 = load float, float* %arg_4Ptr
; set tuple
%val2321 = getelementptr %NVGtextRow, %NVGtextRow* %val2319, i64 0, i32 4
store float %val2320, float* %val2321
%val2322 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2323 = load float, float* %arg_5Ptr
; set tuple
%val2324 = getelementptr %NVGtextRow, %NVGtextRow* %val2322, i64 0, i32 5
store float %val2323, float* %val2324
%val2325 = load %NVGtextRow*, %NVGtextRow** %objPtr
ret %NVGtextRow* %val2325
}
@gsxtmnanovg113 = hidden constant [131 x i8] c"NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** @NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2345 = load i8*, i8** %_impzPtr
%zone2346 = bitcast i8* %tzone2345 to %mzone*

; let assign value to symbol NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone2346, i64 8)
%NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ to { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***
%tzone2326 = load i8*, i8** %_impzPtr
%zone2327 = bitcast i8* %tzone2326 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2327)
; malloc closure structure
%clsptr2328 = call i8* @llvm_zone_malloc(%mzone* %zone2327, i64 24)
%closure2329 = bitcast i8* %clsptr2328 to { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*

; malloc environment structure
%envptr2330 = call i8* @llvm_zone_malloc(%mzone* %zone2327, i64 8)
%environment2331 = bitcast i8* %envptr2330 to {{i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}*

; malloc closure address table
%addytable2332 = call %clsvar* @new_address_table()
%var2333 = bitcast [78 x i8]* @gsxtmnanovg112 to i8*
%var2334 = bitcast [75 x i8]* @gsxtmnanovg110 to i8*
%addytable2335 = call %clsvar* @add_address_table(%mzone* %zone2327, i8* %var2333, i32 0, i8* %var2334, i32 3, %clsvar* %addytable2332)
%address-table2336 = bitcast %clsvar* %addytable2335 to i8*

; insert table, function and environment into closure struct
%closure.table2339 = getelementptr { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure2329, i32 0, i32 0
store i8* %address-table2336, i8** %closure.table2339
%closure.env2340 = getelementptr { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure2329, i32 0, i32 1
store i8* %envptr2330, i8** %closure.env2340
%closure.func2341 = getelementptr { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure2329, i32 0, i32 2
store %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)* @NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ__2299, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)** %closure.func2341
%closure_size2342 = call i64 @llvm_zone_mark_size(%mzone* %zone2327)
call void @llvm_zone_ptr_set_size(i8* %clsptr2328, i64 %closure_size2342)
%wrapper_ptr2343 = call i8* @llvm_zone_malloc(%mzone* %zone2327, i64 8)
%closure_wrapper2344 = bitcast i8* %wrapper_ptr2343 to { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**
store { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure2329, { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_wrapper2344

; let value assignment
%NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_wrapper2344, { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_wrapper2344
store { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ, { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*** %NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr2338 = getelementptr {{i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}, {{i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}* %environment2331, i32 0, i32 0
store {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*** %NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**** %tmp_envptr2338


%val2347 = load {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*** %NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %val2347
}


@NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** @NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGtextRow* @NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ(i8* %arg_0,i8* %arg_1,i8* %arg_2,float %arg_3,float %arg_4,float %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*,  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2, float %arg_3, float %arg_4, float %arg_5)
ret %NVGtextRow* %result
}


define dllexport ccc %NVGtextRow* @NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_native(i8* %arg_0,i8* %arg_1,i8* %arg_2,float %arg_3,float %arg_4,float %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*,  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2, float %arg_3, float %arg_4, float %arg_5)
ret %NVGtextRow* %result
}


define dllexport ccc i8*  @NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2348 = bitcast [131 x i8]* @gsxtmnanovg113 to i8*
call i32 (i8*, ...) @printf(i8* %var2348)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2349 = bitcast [131 x i8]* @gsxtmnanovg113 to i8*
call i32 (i8*, ...) @printf(i8* %var2349)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2350 = bitcast [131 x i8]* @gsxtmnanovg113 to i8*
call i32 (i8*, ...) @printf(i8* %var2350)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2351 = bitcast [131 x i8]* @gsxtmnanovg113 to i8*
call i32 (i8*, ...) @printf(i8* %var2351)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var2352 = bitcast [131 x i8]* @gsxtmnanovg113 to i8*
call i32 (i8*, ...) @printf(i8* %var2352)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_real(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var2353 = bitcast [131 x i8]* @gsxtmnanovg113 to i8*
call i32 (i8*, ...) @printf(i8* %var2353)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc float  @r32value(i8* %arg_5_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*,  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2, float %arg_3, float %arg_4, float %arg_5)
%tmpres = bitcast %NVGtextRow* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i8*, i8*, float, float, float}*
%arg_p_0 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
%arg_p_3 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
%arg_p_5 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 5
%arg_5 = load float, float* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_z_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*,  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2, float %arg_3, float %arg_4, float %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg114 = hidden constant [78 x i8] c"NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
define dllexport fastcc %NVGtextRow* @NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ__2354(i8* %_impz,i8* %_impenv, i8* %arg_0, i8* %arg_1, i8* %arg_2, float %arg_3, float %arg_4, float %arg_5) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2355 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}*
%NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}, {{i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}* %impenv, i32 0, i32 0
%NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**** %NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%arg_0Ptr = alloca i8*
store i8* %arg_0, i8** %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr
%arg_2Ptr = alloca i8*
store i8* %arg_2, i8** %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr
%arg_4Ptr = alloca float
store float %arg_4, float* %arg_4Ptr
%arg_5Ptr = alloca float
store float %arg_5, float* %arg_5Ptr


%tzone2358 = load i8*, i8** %_impzPtr
%zone2359 = bitcast i8* %tzone2358 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGtextRow*
%dat2356 = call i8* @malloc(i64 40)
call i8* @memset(i8* %dat2356, i32 0, i64 40)
%val2357 = bitcast i8* %dat2356 to %NVGtextRow*

; let value assignment
%obj = select i1 true, %NVGtextRow* %val2357, %NVGtextRow* %val2357
store %NVGtextRow* %obj, %NVGtextRow** %objPtr

%val2360 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2361 = load i8*, i8** %arg_0Ptr
; set tuple
%val2362 = getelementptr %NVGtextRow, %NVGtextRow* %val2360, i64 0, i32 0
store i8* %val2361, i8** %val2362
%val2363 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2364 = load i8*, i8** %arg_1Ptr
; set tuple
%val2365 = getelementptr %NVGtextRow, %NVGtextRow* %val2363, i64 0, i32 1
store i8* %val2364, i8** %val2365
%val2366 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2367 = load i8*, i8** %arg_2Ptr
; set tuple
%val2368 = getelementptr %NVGtextRow, %NVGtextRow* %val2366, i64 0, i32 2
store i8* %val2367, i8** %val2368
%val2369 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2370 = load float, float* %arg_3Ptr
; set tuple
%val2371 = getelementptr %NVGtextRow, %NVGtextRow* %val2369, i64 0, i32 3
store float %val2370, float* %val2371
%val2372 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2373 = load float, float* %arg_4Ptr
; set tuple
%val2374 = getelementptr %NVGtextRow, %NVGtextRow* %val2372, i64 0, i32 4
store float %val2373, float* %val2374
%val2375 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2376 = load float, float* %arg_5Ptr
; set tuple
%val2377 = getelementptr %NVGtextRow, %NVGtextRow* %val2375, i64 0, i32 5
store float %val2376, float* %val2377
%val2378 = load %NVGtextRow*, %NVGtextRow** %objPtr
ret %NVGtextRow* %val2378
}
@gsxtmnanovg115 = hidden constant [131 x i8] c"NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** @NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2398 = load i8*, i8** %_impzPtr
%zone2399 = bitcast i8* %tzone2398 to %mzone*

; let assign value to symbol NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone2399, i64 8)
%NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ to { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***
%tzone2379 = load i8*, i8** %_impzPtr
%zone2380 = bitcast i8* %tzone2379 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2380)
; malloc closure structure
%clsptr2381 = call i8* @llvm_zone_malloc(%mzone* %zone2380, i64 24)
%closure2382 = bitcast i8* %clsptr2381 to { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*

; malloc environment structure
%envptr2383 = call i8* @llvm_zone_malloc(%mzone* %zone2380, i64 8)
%environment2384 = bitcast i8* %envptr2383 to {{i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}*

; malloc closure address table
%addytable2385 = call %clsvar* @new_address_table()
%var2386 = bitcast [78 x i8]* @gsxtmnanovg114 to i8*
%var2387 = bitcast [75 x i8]* @gsxtmnanovg110 to i8*
%addytable2388 = call %clsvar* @add_address_table(%mzone* %zone2380, i8* %var2386, i32 0, i8* %var2387, i32 3, %clsvar* %addytable2385)
%address-table2389 = bitcast %clsvar* %addytable2388 to i8*

; insert table, function and environment into closure struct
%closure.table2392 = getelementptr { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure2382, i32 0, i32 0
store i8* %address-table2389, i8** %closure.table2392
%closure.env2393 = getelementptr { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure2382, i32 0, i32 1
store i8* %envptr2383, i8** %closure.env2393
%closure.func2394 = getelementptr { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure2382, i32 0, i32 2
store %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)* @NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ__2354, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)** %closure.func2394
%closure_size2395 = call i64 @llvm_zone_mark_size(%mzone* %zone2380)
call void @llvm_zone_ptr_set_size(i8* %clsptr2381, i64 %closure_size2395)
%wrapper_ptr2396 = call i8* @llvm_zone_malloc(%mzone* %zone2380, i64 8)
%closure_wrapper2397 = bitcast i8* %wrapper_ptr2396 to { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**
store { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure2382, { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_wrapper2397

; let value assignment
%NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_wrapper2397, { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_wrapper2397
store { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ, { i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*** %NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr2391 = getelementptr {{i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}, {{i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}* %environment2384, i32 0, i32 0
store {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*** %NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**** %tmp_envptr2391


%val2400 = load {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*** %NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %val2400
}


@NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** @NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGtextRow* @NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ(i8* %arg_0,i8* %arg_1,i8* %arg_2,float %arg_3,float %arg_4,float %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*,  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2, float %arg_3, float %arg_4, float %arg_5)
ret %NVGtextRow* %result
}


define dllexport ccc %NVGtextRow* @NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_native(i8* %arg_0,i8* %arg_1,i8* %arg_2,float %arg_3,float %arg_4,float %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*,  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2, float %arg_3, float %arg_4, float %arg_5)
ret %NVGtextRow* %result
}


define dllexport ccc i8*  @NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2401 = bitcast [131 x i8]* @gsxtmnanovg115 to i8*
call i32 (i8*, ...) @printf(i8* %var2401)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2402 = bitcast [131 x i8]* @gsxtmnanovg115 to i8*
call i32 (i8*, ...) @printf(i8* %var2402)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2403 = bitcast [131 x i8]* @gsxtmnanovg115 to i8*
call i32 (i8*, ...) @printf(i8* %var2403)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2404 = bitcast [131 x i8]* @gsxtmnanovg115 to i8*
call i32 (i8*, ...) @printf(i8* %var2404)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var2405 = bitcast [131 x i8]* @gsxtmnanovg115 to i8*
call i32 (i8*, ...) @printf(i8* %var2405)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_real(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var2406 = bitcast [131 x i8]* @gsxtmnanovg115 to i8*
call i32 (i8*, ...) @printf(i8* %var2406)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc float  @r32value(i8* %arg_5_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*,  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2, float %arg_3, float %arg_4, float %arg_5)
%tmpres = bitcast %NVGtextRow* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i8*, i8*, float, float, float}*
%arg_p_0 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
%arg_p_3 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
%arg_p_5 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 5
%arg_5 = load float, float* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_h_adhoc_W05WR3RleHRSb3cqLGk4KixpOCosaTgqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)*,  %NVGtextRow* (i8*, i8*, i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2, float %arg_3, float %arg_4, float %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg116 = hidden constant [18 x i8] c"<NVGtextRow:null>\00"
@gsxtmnanovg117 = hidden constant [13 x i8] c"<NVGtextRow:\00"
@gsxtmnanovg118 = hidden constant [44 x i8] c"toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd\00"
@gsxtmnanovg119 = hidden constant [49 x i8] c"{i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd__2407(i8* %_impz,i8* %_impenv, %NVGtextRow* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2408 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}***}*
%toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypdPtr = load {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}***, {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}**** %toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypdPtr_

; setup arguments
%xPtr = alloca %NVGtextRow*
store %NVGtextRow* %x, %NVGtextRow** %xPtr


%val2410 = load %NVGtextRow*, %NVGtextRow** %xPtr
%val2411 = icmp eq %NVGtextRow* %val2410, null
br i1 %val2411, label %then2409, label %else2409

then2409:
%zone2412 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone2412)
%zone_ptr2413 = bitcast %mzone* %zone2412 to i8*
store i8* %zone_ptr2413, i8** %_impzPtr
%tzone2423 = load i8*, i8** %_impzPtr
%zone2424 = bitcast i8* %tzone2423 to %mzone*

; let assign value to symbol res4
%res4Ptr = alloca %String*
%tzone2428 = load i8*, i8** %_impzPtr
%zone2429 = bitcast i8* %tzone2428 to %mzone*

; let assign value to symbol zone4
%zone4Ptr = alloca %mzone*
%tzone2431 = load i8*, i8** %_impzPtr
%zone2432 = bitcast i8* %tzone2431 to %mzone*

; let assign value to symbol newz4
%newz4Ptr = alloca %mzone*
%tzone2415 = load i8*, i8** %_impzPtr
%zone2416 = bitcast i8* %tzone2415 to %mzone*

; let assign value to symbol xx_t_mst
%xx_t_mstPtr = alloca i8*
%dat2414 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst = select i1 true, i8* %dat2414, i8* %dat2414
store i8* %xx_t_mst, i8** %xx_t_mstPtr

%val2417 = load i8*, i8** %xx_t_mstPtr
%var2418 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var2419 = bitcast [18 x i8]* @gsxtmnanovg116 to i8*

%val2420 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2417, i8* %var2418, i8* %var2419)
%val2421 = load i8*, i8** %xx_t_mstPtr
%res2422 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2421)

; let value assignment
%res4 = select i1 true, %String* %res2422, %String* %res2422
store %String* %res4, %String** %res4Ptr

%oldzone2425 = call %mzone* @llvm_pop_zone_stack()
%newzone2426 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr2427 = bitcast %mzone* %newzone2426 to i8*
store i8* %zone_ptr2427, i8** %_impzPtr

; let value assignment
%zone4 = select i1 true, %mzone* %oldzone2425, %mzone* %oldzone2425
store %mzone* %zone4, %mzone** %zone4Ptr

%res2430 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz4 = select i1 true, %mzone* %res2430, %mzone* %res2430
store %mzone* %newz4, %mzone** %newz4Ptr

%tzone2437 = load i8*, i8** %_impzPtr
%zone2438 = bitcast i8* %tzone2437 to %mzone*

; let assign value to symbol rescopy4
%rescopy4Ptr = alloca %String*
%tzone2443 = load i8*, i8** %_impzPtr
%zone2444 = bitcast i8* %tzone2443 to %mzone*

; let assign value to symbol hook
%hookPtr = alloca {i64,i8*,i8*}*
%tzone2446 = load i8*, i8** %_impzPtr
%zone2447 = bitcast i8* %tzone2446 to %mzone*

; let assign value to symbol f
%fPtr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val2433 = load %String*, %String** %res4Ptr
%val2434 = load %mzone*, %mzone** %zone4Ptr
%val2435 = load %mzone*, %mzone** %newz4Ptr
%res2436 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val2433, %mzone* %val2434, %mzone* %val2435)

; let value assignment
%rescopy4 = select i1 true, %String* %res2436, %String* %res2436
store %String* %rescopy4, %String** %rescopy4Ptr

%val2439 = load %mzone*, %mzone** %zone4Ptr
; tuple ref
%val2440 = getelementptr %mzone, %mzone* %val2439, i64 0, i32 4
%val2441 = load i8*, i8** %val2440
%val2442 = bitcast i8* %val2441 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val2442, {i64,i8*,i8*}* %val2442
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%null2445 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null2445, {i8*, i8*, void (i8*, i8*)*}** %null2445
store {i8*, i8*, void (i8*, i8*)*}** %f, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; promote local stack var allocations
%tzone2483 = load i8*, i8** %_impzPtr
%zone2484 = bitcast i8* %tzone2483 to %mzone*
%ifptr2473 = alloca i1
%ifptr2449 = alloca i1
; while loop
%val2450 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val2451 = icmp eq {i64,i8*,i8*}* %val2450, null
br i1 %val2451, label %then2449, label %else2449

then2449:
%res2452 = call ccc i1 @impc_false()
store i1 %res2452, i1* %ifptr2449
br label %ifcont2449

else2449:
%res2453 = call ccc i1 @impc_true()
store i1 %res2453, i1* %ifptr2449
br label %ifcont2449

ifcont2449:
%ifres2454 = load i1, i1* %ifptr2449

br i1 %ifres2454, label %loop2448, label %after2448

loop2448:
; do set!
%val2455 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val2456 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2455, i64 0, i32 1
%val2457 = load i8*, i8** %val2456
%val2458 = bitcast i8* %val2457 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val2458, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; apply closure 
%vval2459 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val2460 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval2459
%fPtr2461 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val2460, i32 0, i32 2
%ePtr2462 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val2460, i32 0, i32 1
%f2463 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr2461
%e2464 = load i8*, i8** %ePtr2462
%tzone2465 = load i8*, i8** %_impzPtr
%zone2466 = bitcast i8* %tzone2465 to %mzone*
%z2467 = bitcast %mzone* %zone2466 to i8*
tail call fastcc void %f2463(i8* %z2467, i8* %e2464)
; do set!
%val2469 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val2470 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2469, i64 0, i32 2
%val2471 = load i8*, i8** %val2470
%val2472 = bitcast i8* %val2471 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val2472, {i64,i8*,i8*}** %hookPtr
%val2474 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val2475 = icmp eq {i64,i8*,i8*}* %val2474, null
br i1 %val2475, label %then2473, label %else2473

then2473:
%res2476 = call ccc i1 @impc_false()
store i1 %res2476, i1* %ifptr2473
br label %ifcont2473

else2473:
%res2477 = call ccc i1 @impc_true()
store i1 %res2477, i1* %ifptr2473
br label %ifcont2473

ifcont2473:
%ifres2478 = load i1, i1* %ifptr2473

br i1 %ifres2478, label %loop2448, label %after2448

after2448:
%val2480 = load %mzone*, %mzone** %zone4Ptr
call ccc void @llvm_zone_destroy(%mzone* %val2480)
%val2482 = load %String*, %String** %rescopy4Ptr
ret %String* %val2482

else2409:
%zone2485 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone2485)
%zone_ptr2486 = bitcast %mzone* %zone2485 to i8*
store i8* %zone_ptr2486, i8** %_impzPtr
%tzone2586 = load i8*, i8** %_impzPtr
%zone2587 = bitcast i8* %tzone2586 to %mzone*

; let assign value to symbol res5
%res5Ptr = alloca %String*
%tzone2591 = load i8*, i8** %_impzPtr
%zone2592 = bitcast i8* %tzone2591 to %mzone*

; let assign value to symbol zone5
%zone5Ptr = alloca %mzone*
%tzone2594 = load i8*, i8** %_impzPtr
%zone2595 = bitcast i8* %tzone2594 to %mzone*

; let assign value to symbol newz5
%newz5Ptr = alloca %mzone*
%tzone2488 = load i8*, i8** %_impzPtr
%zone2489 = bitcast i8* %tzone2488 to %mzone*

; let assign value to symbol xx_t_mst_s_15
%xx_t_mst_s_15Ptr = alloca i8*
%dat2487 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_15 = select i1 true, i8* %dat2487, i8* %dat2487
store i8* %xx_t_mst_s_15, i8** %xx_t_mst_s_15Ptr

%val2490 = load i8*, i8** %xx_t_mst_s_15Ptr
%var2491 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var2492 = bitcast [13 x i8]* @gsxtmnanovg117 to i8*

%val2493 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2490, i8* %var2491, i8* %var2492)
%val2494 = load i8*, i8** %xx_t_mst_s_15Ptr
%res2495 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2494)
%val2496 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2497 = getelementptr %NVGtextRow, %NVGtextRow* %val2496, i64 0, i32 0
%val2498 = load i8*, i8** %val2497
%res2499 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2498)
%res2500 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2495, %String* %res2499)
%tzone2502 = load i8*, i8** %_impzPtr
%zone2503 = bitcast i8* %tzone2502 to %mzone*

; let assign value to symbol xx_t_mst_s_16
%xx_t_mst_s_16Ptr = alloca i8*
%dat2501 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_16 = select i1 true, i8* %dat2501, i8* %dat2501
store i8* %xx_t_mst_s_16, i8** %xx_t_mst_s_16Ptr

%val2504 = load i8*, i8** %xx_t_mst_s_16Ptr
%var2505 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var2506 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val2507 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2504, i8* %var2505, i8* %var2506)
%val2508 = load i8*, i8** %xx_t_mst_s_16Ptr
%res2509 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2508)
%res2510 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2500, %String* %res2509)
%val2511 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2512 = getelementptr %NVGtextRow, %NVGtextRow* %val2511, i64 0, i32 1
%val2513 = load i8*, i8** %val2512
%res2514 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2513)
%res2515 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2510, %String* %res2514)
%tzone2517 = load i8*, i8** %_impzPtr
%zone2518 = bitcast i8* %tzone2517 to %mzone*

; let assign value to symbol xx_t_mst_s_17
%xx_t_mst_s_17Ptr = alloca i8*
%dat2516 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_17 = select i1 true, i8* %dat2516, i8* %dat2516
store i8* %xx_t_mst_s_17, i8** %xx_t_mst_s_17Ptr

%val2519 = load i8*, i8** %xx_t_mst_s_17Ptr
%var2520 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var2521 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val2522 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2519, i8* %var2520, i8* %var2521)
%val2523 = load i8*, i8** %xx_t_mst_s_17Ptr
%res2524 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2523)
%res2525 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2515, %String* %res2524)
%val2526 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2527 = getelementptr %NVGtextRow, %NVGtextRow* %val2526, i64 0, i32 2
%val2528 = load i8*, i8** %val2527
%res2529 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2528)
%res2530 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2525, %String* %res2529)
%tzone2532 = load i8*, i8** %_impzPtr
%zone2533 = bitcast i8* %tzone2532 to %mzone*

; let assign value to symbol xx_t_mst_s_18
%xx_t_mst_s_18Ptr = alloca i8*
%dat2531 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_18 = select i1 true, i8* %dat2531, i8* %dat2531
store i8* %xx_t_mst_s_18, i8** %xx_t_mst_s_18Ptr

%val2534 = load i8*, i8** %xx_t_mst_s_18Ptr
%var2535 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var2536 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val2537 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2534, i8* %var2535, i8* %var2536)
%val2538 = load i8*, i8** %xx_t_mst_s_18Ptr
%res2539 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2538)
%res2540 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2530, %String* %res2539)
%val2541 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2542 = getelementptr %NVGtextRow, %NVGtextRow* %val2541, i64 0, i32 3
%val2543 = load float, float* %val2542
%res2544 = call fastcc %String* @toString_adhoc_W1N0cmluZyosZmxvYXRd(float %val2543)
%res2545 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2540, %String* %res2544)
%tzone2547 = load i8*, i8** %_impzPtr
%zone2548 = bitcast i8* %tzone2547 to %mzone*

; let assign value to symbol xx_t_mst_s_19
%xx_t_mst_s_19Ptr = alloca i8*
%dat2546 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_19 = select i1 true, i8* %dat2546, i8* %dat2546
store i8* %xx_t_mst_s_19, i8** %xx_t_mst_s_19Ptr

%val2549 = load i8*, i8** %xx_t_mst_s_19Ptr
%var2550 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var2551 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val2552 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2549, i8* %var2550, i8* %var2551)
%val2553 = load i8*, i8** %xx_t_mst_s_19Ptr
%res2554 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2553)
%res2555 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2545, %String* %res2554)
%val2556 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2557 = getelementptr %NVGtextRow, %NVGtextRow* %val2556, i64 0, i32 4
%val2558 = load float, float* %val2557
%res2559 = call fastcc %String* @toString_adhoc_W1N0cmluZyosZmxvYXRd(float %val2558)
%res2560 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2555, %String* %res2559)
%tzone2562 = load i8*, i8** %_impzPtr
%zone2563 = bitcast i8* %tzone2562 to %mzone*

; let assign value to symbol xx_t_mst_s_20
%xx_t_mst_s_20Ptr = alloca i8*
%dat2561 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_20 = select i1 true, i8* %dat2561, i8* %dat2561
store i8* %xx_t_mst_s_20, i8** %xx_t_mst_s_20Ptr

%val2564 = load i8*, i8** %xx_t_mst_s_20Ptr
%var2565 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var2566 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val2567 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2564, i8* %var2565, i8* %var2566)
%val2568 = load i8*, i8** %xx_t_mst_s_20Ptr
%res2569 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2568)
%res2570 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2560, %String* %res2569)
%val2571 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2572 = getelementptr %NVGtextRow, %NVGtextRow* %val2571, i64 0, i32 5
%val2573 = load float, float* %val2572
%res2574 = call fastcc %String* @toString_adhoc_W1N0cmluZyosZmxvYXRd(float %val2573)
%res2575 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2570, %String* %res2574)
%tzone2577 = load i8*, i8** %_impzPtr
%zone2578 = bitcast i8* %tzone2577 to %mzone*

; let assign value to symbol xx_t_mst_s_21
%xx_t_mst_s_21Ptr = alloca i8*
%dat2576 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_21 = select i1 true, i8* %dat2576, i8* %dat2576
store i8* %xx_t_mst_s_21, i8** %xx_t_mst_s_21Ptr

%val2579 = load i8*, i8** %xx_t_mst_s_21Ptr
%var2580 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var2581 = bitcast [2 x i8]* @gsxtmnanovg65 to i8*

%val2582 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2579, i8* %var2580, i8* %var2581)
%val2583 = load i8*, i8** %xx_t_mst_s_21Ptr
%res2584 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2583)
%res2585 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2575, %String* %res2584)

; let value assignment
%res5 = select i1 true, %String* %res2585, %String* %res2585
store %String* %res5, %String** %res5Ptr

%oldzone2588 = call %mzone* @llvm_pop_zone_stack()
%newzone2589 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr2590 = bitcast %mzone* %newzone2589 to i8*
store i8* %zone_ptr2590, i8** %_impzPtr

; let value assignment
%zone5 = select i1 true, %mzone* %oldzone2588, %mzone* %oldzone2588
store %mzone* %zone5, %mzone** %zone5Ptr

%res2593 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz5 = select i1 true, %mzone* %res2593, %mzone* %res2593
store %mzone* %newz5, %mzone** %newz5Ptr

%tzone2600 = load i8*, i8** %_impzPtr
%zone2601 = bitcast i8* %tzone2600 to %mzone*

; let assign value to symbol rescopy5
%rescopy5Ptr = alloca %String*
%tzone2606 = load i8*, i8** %_impzPtr
%zone2607 = bitcast i8* %tzone2606 to %mzone*

; let assign value to symbol hook_s_22
%hook_s_22Ptr = alloca {i64,i8*,i8*}*
%tzone2609 = load i8*, i8** %_impzPtr
%zone2610 = bitcast i8* %tzone2609 to %mzone*

; let assign value to symbol f_s_23
%f_s_23Ptr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val2596 = load %String*, %String** %res5Ptr
%val2597 = load %mzone*, %mzone** %zone5Ptr
%val2598 = load %mzone*, %mzone** %newz5Ptr
%res2599 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val2596, %mzone* %val2597, %mzone* %val2598)

; let value assignment
%rescopy5 = select i1 true, %String* %res2599, %String* %res2599
store %String* %rescopy5, %String** %rescopy5Ptr

%val2602 = load %mzone*, %mzone** %zone5Ptr
; tuple ref
%val2603 = getelementptr %mzone, %mzone* %val2602, i64 0, i32 4
%val2604 = load i8*, i8** %val2603
%val2605 = bitcast i8* %val2604 to {i64,i8*,i8*}*

; let value assignment
%hook_s_22 = select i1 true, {i64,i8*,i8*}* %val2605, {i64,i8*,i8*}* %val2605
store {i64,i8*,i8*}* %hook_s_22, {i64,i8*,i8*}** %hook_s_22Ptr

%null2608 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f_s_23 = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null2608, {i8*, i8*, void (i8*, i8*)*}** %null2608
store {i8*, i8*, void (i8*, i8*)*}** %f_s_23, {i8*, i8*, void (i8*, i8*)*}*** %f_s_23Ptr

; promote local stack var allocations
%tzone2646 = load i8*, i8** %_impzPtr
%zone2647 = bitcast i8* %tzone2646 to %mzone*
%ifptr2636 = alloca i1
%ifptr2612 = alloca i1
; while loop
%val2613 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_22Ptr
%val2614 = icmp eq {i64,i8*,i8*}* %val2613, null
br i1 %val2614, label %then2612, label %else2612

then2612:
%res2615 = call ccc i1 @impc_false()
store i1 %res2615, i1* %ifptr2612
br label %ifcont2612

else2612:
%res2616 = call ccc i1 @impc_true()
store i1 %res2616, i1* %ifptr2612
br label %ifcont2612

ifcont2612:
%ifres2617 = load i1, i1* %ifptr2612

br i1 %ifres2617, label %loop2611, label %after2611

loop2611:
; do set!
%val2618 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_22Ptr
; tuple ref
%val2619 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2618, i64 0, i32 1
%val2620 = load i8*, i8** %val2619
%val2621 = bitcast i8* %val2620 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val2621, {i8*, i8*, void (i8*, i8*)*}*** %f_s_23Ptr

; apply closure 
%vval2622 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %f_s_23Ptr
%val2623 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval2622
%fPtr2624 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val2623, i32 0, i32 2
%ePtr2625 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val2623, i32 0, i32 1
%f2626 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr2624
%e2627 = load i8*, i8** %ePtr2625
%tzone2628 = load i8*, i8** %_impzPtr
%zone2629 = bitcast i8* %tzone2628 to %mzone*
%z2630 = bitcast %mzone* %zone2629 to i8*
tail call fastcc void %f2626(i8* %z2630, i8* %e2627)
; do set!
%val2632 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_22Ptr
; tuple ref
%val2633 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2632, i64 0, i32 2
%val2634 = load i8*, i8** %val2633
%val2635 = bitcast i8* %val2634 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val2635, {i64,i8*,i8*}** %hook_s_22Ptr
%val2637 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_22Ptr
%val2638 = icmp eq {i64,i8*,i8*}* %val2637, null
br i1 %val2638, label %then2636, label %else2636

then2636:
%res2639 = call ccc i1 @impc_false()
store i1 %res2639, i1* %ifptr2636
br label %ifcont2636

else2636:
%res2640 = call ccc i1 @impc_true()
store i1 %res2640, i1* %ifptr2636
br label %ifcont2636

ifcont2636:
%ifres2641 = load i1, i1* %ifptr2636

br i1 %ifres2641, label %loop2611, label %after2611

after2611:
%val2643 = load %mzone*, %mzone** %zone5Ptr
call ccc void @llvm_zone_destroy(%mzone* %val2643)
%val2645 = load %String*, %String** %rescopy5Ptr
ret %String* %val2645
}
@gsxtmnanovg120 = hidden constant [97 x i8] c"toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}** @toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2667 = load i8*, i8** %_impzPtr
%zone2668 = bitcast i8* %tzone2667 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd
%dat_toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd = call i8* @llvm_zone_malloc(%mzone* %zone2668, i64 8)
%toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypdPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd to { i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}***
%tzone2648 = load i8*, i8** %_impzPtr
%zone2649 = bitcast i8* %tzone2648 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2649)
; malloc closure structure
%clsptr2650 = call i8* @llvm_zone_malloc(%mzone* %zone2649, i64 24)
%closure2651 = bitcast i8* %clsptr2650 to { i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}*

; malloc environment structure
%envptr2652 = call i8* @llvm_zone_malloc(%mzone* %zone2649, i64 8)
%environment2653 = bitcast i8* %envptr2652 to {{i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}***}*

; malloc closure address table
%addytable2654 = call %clsvar* @new_address_table()
%var2655 = bitcast [44 x i8]* @gsxtmnanovg118 to i8*
%var2656 = bitcast [49 x i8]* @gsxtmnanovg119 to i8*
%addytable2657 = call %clsvar* @add_address_table(%mzone* %zone2649, i8* %var2655, i32 0, i8* %var2656, i32 3, %clsvar* %addytable2654)
%address-table2658 = bitcast %clsvar* %addytable2657 to i8*

; insert table, function and environment into closure struct
%closure.table2661 = getelementptr { i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}, { i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}* %closure2651, i32 0, i32 0
store i8* %address-table2658, i8** %closure.table2661
%closure.env2662 = getelementptr { i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}, { i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}* %closure2651, i32 0, i32 1
store i8* %envptr2652, i8** %closure.env2662
%closure.func2663 = getelementptr { i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}, { i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}* %closure2651, i32 0, i32 2
store %String* (i8*, i8*, %NVGtextRow*)* @toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd__2407, %String* (i8*, i8*, %NVGtextRow*)** %closure.func2663
%closure_size2664 = call i64 @llvm_zone_mark_size(%mzone* %zone2649)
call void @llvm_zone_ptr_set_size(i8* %clsptr2650, i64 %closure_size2664)
%wrapper_ptr2665 = call i8* @llvm_zone_malloc(%mzone* %zone2649, i64 8)
%closure_wrapper2666 = bitcast i8* %wrapper_ptr2665 to { i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}**
store { i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}* %closure2651, { i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}** %closure_wrapper2666

; let value assignment
%toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd = select i1 true, { i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}** %closure_wrapper2666, { i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}** %closure_wrapper2666
store { i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}** %toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd, { i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}*** %toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypdPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd
%tmp_envptr2660 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}***}* %environment2653, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}*** %toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypdPtr, {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}**** %tmp_envptr2660


%val2669 = load {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}**, {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}*** %toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypdPtr
ret {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}** %val2669
}


@toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}** @toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd(%NVGtextRow* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGtextRow*)*,  %String* (i8*, i8*, %NVGtextRow*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGtextRow* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd_native(%NVGtextRow* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGtextRow*)*,  %String* (i8*, i8*, %NVGtextRow*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGtextRow* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2670 = bitcast [97 x i8]* @gsxtmnanovg120 to i8*
call i32 (i8*, ...) @printf(i8* %var2670)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGtextRow*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGtextRow*)*,  %String* (i8*, i8*, %NVGtextRow*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGtextRow* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGtextRow*}*
%arg_p_0 = getelementptr {%NVGtextRow*}, {%NVGtextRow*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGtextRow*, %NVGtextRow** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHdGV4dFJvdypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGtextRow*)*,  %String* (i8*, i8*, %NVGtextRow*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGtextRow* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg121 = hidden constant [37 x i8] c"print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd\00"
@gsxtmnanovg122 = hidden constant [45 x i8] c"{i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd__2671(i8* %_impz,i8* %_impenv, %NVGtextRow* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2672 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}***}*
%print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypdPtr = load {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}***, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}**** %print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypdPtr_

; setup arguments
%xPtr = alloca %NVGtextRow*
store %NVGtextRow* %x, %NVGtextRow** %xPtr


%val2674 = load %NVGtextRow*, %NVGtextRow** %xPtr
%val2675 = icmp eq %NVGtextRow* %val2674, null
br i1 %val2675, label %then2673, label %else2673

then2673:
%var2676 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var2677 = bitcast [18 x i8]* @gsxtmnanovg116 to i8*

%val2678 = call i32 (i8*, ...) @printf(i8* %var2676, i8* %var2677)
br label %ifcont2673

else2673:
%var2680 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var2681 = bitcast [13 x i8]* @gsxtmnanovg117 to i8*

%val2682 = call i32 (i8*, ...) @printf(i8* %var2680, i8* %var2681)
%val2683 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2684 = getelementptr %NVGtextRow, %NVGtextRow* %val2683, i64 0, i32 0
%val2685 = load i8*, i8** %val2684
call fastcc void @print_adhoc_W3ZvaWQsaTgqXQ(i8* %val2685)
%var2687 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var2688 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val2689 = call i32 (i8*, ...) @printf(i8* %var2687, i8* %var2688)
%val2690 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2691 = getelementptr %NVGtextRow, %NVGtextRow* %val2690, i64 0, i32 1
%val2692 = load i8*, i8** %val2691
call fastcc void @print_adhoc_W3ZvaWQsaTgqXQ(i8* %val2692)
%var2694 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var2695 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val2696 = call i32 (i8*, ...) @printf(i8* %var2694, i8* %var2695)
%val2697 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2698 = getelementptr %NVGtextRow, %NVGtextRow* %val2697, i64 0, i32 2
%val2699 = load i8*, i8** %val2698
call fastcc void @print_adhoc_W3ZvaWQsaTgqXQ(i8* %val2699)
%var2701 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var2702 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val2703 = call i32 (i8*, ...) @printf(i8* %var2701, i8* %var2702)
%val2704 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2705 = getelementptr %NVGtextRow, %NVGtextRow* %val2704, i64 0, i32 3
%val2706 = load float, float* %val2705
call fastcc void @print_adhoc_W3ZvaWQsZmxvYXRd(float %val2706)
%var2708 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var2709 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val2710 = call i32 (i8*, ...) @printf(i8* %var2708, i8* %var2709)
%val2711 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2712 = getelementptr %NVGtextRow, %NVGtextRow* %val2711, i64 0, i32 4
%val2713 = load float, float* %val2712
call fastcc void @print_adhoc_W3ZvaWQsZmxvYXRd(float %val2713)
%var2715 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var2716 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val2717 = call i32 (i8*, ...) @printf(i8* %var2715, i8* %var2716)
%val2718 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2719 = getelementptr %NVGtextRow, %NVGtextRow* %val2718, i64 0, i32 5
%val2720 = load float, float* %val2719
call fastcc void @print_adhoc_W3ZvaWQsZmxvYXRd(float %val2720)
%var2722 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var2723 = bitcast [2 x i8]* @gsxtmnanovg65 to i8*

%val2724 = call i32 (i8*, ...) @printf(i8* %var2722, i8* %var2723)
br label %ifcont2673

ifcont2673:
ret void
}
@gsxtmnanovg123 = hidden constant [90 x i8] c"print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** @print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2746 = load i8*, i8** %_impzPtr
%zone2747 = bitcast i8* %tzone2746 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd
%dat_print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd = call i8* @llvm_zone_malloc(%mzone* %zone2747, i64 8)
%print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd to { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}***
%tzone2727 = load i8*, i8** %_impzPtr
%zone2728 = bitcast i8* %tzone2727 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2728)
; malloc closure structure
%clsptr2729 = call i8* @llvm_zone_malloc(%mzone* %zone2728, i64 24)
%closure2730 = bitcast i8* %clsptr2729 to { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}*

; malloc environment structure
%envptr2731 = call i8* @llvm_zone_malloc(%mzone* %zone2728, i64 8)
%environment2732 = bitcast i8* %envptr2731 to {{i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}***}*

; malloc closure address table
%addytable2733 = call %clsvar* @new_address_table()
%var2734 = bitcast [37 x i8]* @gsxtmnanovg121 to i8*
%var2735 = bitcast [45 x i8]* @gsxtmnanovg122 to i8*
%addytable2736 = call %clsvar* @add_address_table(%mzone* %zone2728, i8* %var2734, i32 0, i8* %var2735, i32 3, %clsvar* %addytable2733)
%address-table2737 = bitcast %clsvar* %addytable2736 to i8*

; insert table, function and environment into closure struct
%closure.table2740 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure2730, i32 0, i32 0
store i8* %address-table2737, i8** %closure.table2740
%closure.env2741 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure2730, i32 0, i32 1
store i8* %envptr2731, i8** %closure.env2741
%closure.func2742 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure2730, i32 0, i32 2
store void (i8*, i8*, %NVGtextRow*)* @print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd__2671, void (i8*, i8*, %NVGtextRow*)** %closure.func2742
%closure_size2743 = call i64 @llvm_zone_mark_size(%mzone* %zone2728)
call void @llvm_zone_ptr_set_size(i8* %clsptr2729, i64 %closure_size2743)
%wrapper_ptr2744 = call i8* @llvm_zone_malloc(%mzone* %zone2728, i64 8)
%closure_wrapper2745 = bitcast i8* %wrapper_ptr2744 to { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}**
store { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure2730, { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** %closure_wrapper2745

; let value assignment
%print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd = select i1 true, { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** %closure_wrapper2745, { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** %closure_wrapper2745
store { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** %print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd, { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}*** %print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd
%tmp_envptr2739 = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}***}* %environment2732, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}*** %print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypdPtr, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}**** %tmp_envptr2739


%val2748 = load {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}**, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}*** %print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypdPtr
ret {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** %val2748
}


@print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** @print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd(%NVGtextRow* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}*, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGtextRow*)*,  void (i8*, i8*, %NVGtextRow*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGtextRow* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_native(%NVGtextRow* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}*, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGtextRow*)*,  void (i8*, i8*, %NVGtextRow*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGtextRow* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2749 = bitcast [90 x i8]* @gsxtmnanovg123 to i8*
call i32 (i8*, ...) @printf(i8* %var2749)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGtextRow*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}*, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGtextRow*)*,  void (i8*, i8*, %NVGtextRow*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGtextRow* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGtextRow*}*
%arg_p_0 = getelementptr {%NVGtextRow*}, {%NVGtextRow*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGtextRow*, %NVGtextRow** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}*, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGtextRow*)*,  void (i8*, i8*, %NVGtextRow*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGtextRow* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg124 = hidden constant [78 x i8] c"NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd\00"
@gsxtmnanovg125 = hidden constant [74 x i8] c"{i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**\00"
define dllexport fastcc %NVGtextRow @NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd__2750(i8* %_impz,i8* %_impenv, i8* %arg_0, i8* %arg_1, i8* %arg_2, float %arg_3, float %arg_4, float %arg_5) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2751 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}*
%NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}, {{i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}* %impenv, i32 0, i32 0
%NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRdPtr = load {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***, {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**** %NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRdPtr_

; setup arguments
%arg_0Ptr = alloca i8*
store i8* %arg_0, i8** %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr
%arg_2Ptr = alloca i8*
store i8* %arg_2, i8** %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr
%arg_4Ptr = alloca float
store float %arg_4, float* %arg_4Ptr
%arg_5Ptr = alloca float
store float %arg_5, float* %arg_5Ptr


%tzone2753 = load i8*, i8** %_impzPtr
%zone2754 = bitcast i8* %tzone2753 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGtextRow*
%dat2752 = alloca %NVGtextRow, align 16

; let value assignment
%obj = select i1 true, %NVGtextRow* %dat2752, %NVGtextRow* %dat2752
store %NVGtextRow* %obj, %NVGtextRow** %objPtr

%val2755 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2756 = load i8*, i8** %arg_0Ptr
; set tuple
%val2757 = getelementptr %NVGtextRow, %NVGtextRow* %val2755, i64 0, i32 0
store i8* %val2756, i8** %val2757
%val2758 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2759 = load i8*, i8** %arg_1Ptr
; set tuple
%val2760 = getelementptr %NVGtextRow, %NVGtextRow* %val2758, i64 0, i32 1
store i8* %val2759, i8** %val2760
%val2761 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2762 = load i8*, i8** %arg_2Ptr
; set tuple
%val2763 = getelementptr %NVGtextRow, %NVGtextRow* %val2761, i64 0, i32 2
store i8* %val2762, i8** %val2763
%val2764 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2765 = load float, float* %arg_3Ptr
; set tuple
%val2766 = getelementptr %NVGtextRow, %NVGtextRow* %val2764, i64 0, i32 3
store float %val2765, float* %val2766
%val2767 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2768 = load float, float* %arg_4Ptr
; set tuple
%val2769 = getelementptr %NVGtextRow, %NVGtextRow* %val2767, i64 0, i32 4
store float %val2768, float* %val2769
%val2770 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2771 = load float, float* %arg_5Ptr
; set tuple
%val2772 = getelementptr %NVGtextRow, %NVGtextRow* %val2770, i64 0, i32 5
store float %val2771, float* %val2772
%val2773 = load %NVGtextRow*, %NVGtextRow** %objPtr
; pointer ref
%val2774 = getelementptr %NVGtextRow, %NVGtextRow* %val2773, i64 0
%val2775 = load %NVGtextRow, %NVGtextRow* %val2774
ret %NVGtextRow %val2775
}
@gsxtmnanovg126 = hidden constant [131 x i8] c"NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** @NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2795 = load i8*, i8** %_impzPtr
%zone2796 = bitcast i8* %tzone2795 to %mzone*

; let assign value to symbol NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd
%dat_NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone2796, i64 8)
%NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRdPtr = bitcast i8* %dat_NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd to { i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***
%tzone2776 = load i8*, i8** %_impzPtr
%zone2777 = bitcast i8* %tzone2776 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2777)
; malloc closure structure
%clsptr2778 = call i8* @llvm_zone_malloc(%mzone* %zone2777, i64 24)
%closure2779 = bitcast i8* %clsptr2778 to { i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*

; malloc environment structure
%envptr2780 = call i8* @llvm_zone_malloc(%mzone* %zone2777, i64 8)
%environment2781 = bitcast i8* %envptr2780 to {{i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}*

; malloc closure address table
%addytable2782 = call %clsvar* @new_address_table()
%var2783 = bitcast [78 x i8]* @gsxtmnanovg124 to i8*
%var2784 = bitcast [74 x i8]* @gsxtmnanovg125 to i8*
%addytable2785 = call %clsvar* @add_address_table(%mzone* %zone2777, i8* %var2783, i32 0, i8* %var2784, i32 3, %clsvar* %addytable2782)
%address-table2786 = bitcast %clsvar* %addytable2785 to i8*

; insert table, function and environment into closure struct
%closure.table2789 = getelementptr { i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure2779, i32 0, i32 0
store i8* %address-table2786, i8** %closure.table2789
%closure.env2790 = getelementptr { i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure2779, i32 0, i32 1
store i8* %envptr2780, i8** %closure.env2790
%closure.func2791 = getelementptr { i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, { i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure2779, i32 0, i32 2
store %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)* @NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd__2750, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)** %closure.func2791
%closure_size2792 = call i64 @llvm_zone_mark_size(%mzone* %zone2777)
call void @llvm_zone_ptr_set_size(i8* %clsptr2778, i64 %closure_size2792)
%wrapper_ptr2793 = call i8* @llvm_zone_malloc(%mzone* %zone2777, i64 8)
%closure_wrapper2794 = bitcast i8* %wrapper_ptr2793 to { i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**
store { i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure2779, { i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_wrapper2794

; let value assignment
%NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd = select i1 true, { i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_wrapper2794, { i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_wrapper2794
store { i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd, { i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*** %NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd
%tmp_envptr2788 = getelementptr {{i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}, {{i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}***}* %environment2781, i32 0, i32 0
store {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*** %NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRdPtr, {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**** %tmp_envptr2788


%val2797 = load {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**, {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*** %NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRdPtr
ret {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %val2797
}


@NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** @NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGtextRow @NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd(i8* %arg_0,i8* %arg_1,i8* %arg_2,float %arg_3,float %arg_4,float %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*,  %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2, float %arg_3, float %arg_4, float %arg_5)
ret %NVGtextRow %result
}


define dllexport ccc %NVGtextRow @NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd_native(i8* %arg_0,i8* %arg_1,i8* %arg_2,float %arg_3,float %arg_4,float %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*,  %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2, float %arg_3, float %arg_4, float %arg_5)
ret %NVGtextRow %result
}


define dllexport ccc void @NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i8*, i8*, float, float, float}*
%arg_p_0 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
%arg_p_3 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
%arg_p_5 = getelementptr {i8*, i8*, i8*, float, float, float}, {i8*, i8*, i8*, float, float, float}* %fstruct, i32 0, i32 5
%arg_5 = load float, float* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGtextRow_val_adhoc_W05WR3RleHRSb3csaTgqLGk4KixpOCosZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}*, {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}, {i8*, i8*, %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)*,  %NVGtextRow (i8*, i8*, i8*, i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2, float %arg_3, float %arg_4, float %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg127 = hidden constant [47 x i8] c"hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ\00"
@gsxtmnanovg128 = hidden constant [53 x i8] c"{i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}**\00"
define dllexport fastcc %NVGtextRow* @hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ__2804(i8* %_impz,i8* %_impenv, %NVGtextRow* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2805 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}***}*
%hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQPtr_ = getelementptr {{i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}***}, {{i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQPtr = load {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}***, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}**** %hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQPtr_

; setup arguments
%xPtr = alloca %NVGtextRow*
store %NVGtextRow* %x, %NVGtextRow** %xPtr


%tzone2808 = load i8*, i8** %_impzPtr
%zone2809 = bitcast i8* %tzone2808 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGtextRow*
%dat2806 = call i8* @malloc(i64 40)
call i8* @memset(i8* %dat2806, i32 0, i64 40)
%val2807 = bitcast i8* %dat2806 to %NVGtextRow*

; let value assignment
%obj = select i1 true, %NVGtextRow* %val2807, %NVGtextRow* %val2807
store %NVGtextRow* %obj, %NVGtextRow** %objPtr

%val2810 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2811 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2812 = getelementptr %NVGtextRow, %NVGtextRow* %val2811, i64 0, i32 0
%val2813 = load i8*, i8** %val2812
; set tuple
%val2814 = getelementptr %NVGtextRow, %NVGtextRow* %val2810, i64 0, i32 0
store i8* %val2813, i8** %val2814
%val2815 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2816 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2817 = getelementptr %NVGtextRow, %NVGtextRow* %val2816, i64 0, i32 1
%val2818 = load i8*, i8** %val2817
; set tuple
%val2819 = getelementptr %NVGtextRow, %NVGtextRow* %val2815, i64 0, i32 1
store i8* %val2818, i8** %val2819
%val2820 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2821 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2822 = getelementptr %NVGtextRow, %NVGtextRow* %val2821, i64 0, i32 2
%val2823 = load i8*, i8** %val2822
; set tuple
%val2824 = getelementptr %NVGtextRow, %NVGtextRow* %val2820, i64 0, i32 2
store i8* %val2823, i8** %val2824
%val2825 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2826 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2827 = getelementptr %NVGtextRow, %NVGtextRow* %val2826, i64 0, i32 3
%val2828 = load float, float* %val2827
; set tuple
%val2829 = getelementptr %NVGtextRow, %NVGtextRow* %val2825, i64 0, i32 3
store float %val2828, float* %val2829
%val2830 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2831 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2832 = getelementptr %NVGtextRow, %NVGtextRow* %val2831, i64 0, i32 4
%val2833 = load float, float* %val2832
; set tuple
%val2834 = getelementptr %NVGtextRow, %NVGtextRow* %val2830, i64 0, i32 4
store float %val2833, float* %val2834
%val2835 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2836 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2837 = getelementptr %NVGtextRow, %NVGtextRow* %val2836, i64 0, i32 5
%val2838 = load float, float* %val2837
; set tuple
%val2839 = getelementptr %NVGtextRow, %NVGtextRow* %val2835, i64 0, i32 5
store float %val2838, float* %val2839
%val2840 = load %NVGtextRow*, %NVGtextRow** %objPtr
ret %NVGtextRow* %val2840
}
@gsxtmnanovg129 = hidden constant [100 x i8] c"hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}** @hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2860 = load i8*, i8** %_impzPtr
%zone2861 = bitcast i8* %tzone2860 to %mzone*

; let assign value to symbol hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ
%dat_hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2861, i64 8)
%hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQPtr = bitcast i8* %dat_hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ to { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}***
%tzone2841 = load i8*, i8** %_impzPtr
%zone2842 = bitcast i8* %tzone2841 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2842)
; malloc closure structure
%clsptr2843 = call i8* @llvm_zone_malloc(%mzone* %zone2842, i64 24)
%closure2844 = bitcast i8* %clsptr2843 to { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}*

; malloc environment structure
%envptr2845 = call i8* @llvm_zone_malloc(%mzone* %zone2842, i64 8)
%environment2846 = bitcast i8* %envptr2845 to {{i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}***}*

; malloc closure address table
%addytable2847 = call %clsvar* @new_address_table()
%var2848 = bitcast [47 x i8]* @gsxtmnanovg127 to i8*
%var2849 = bitcast [53 x i8]* @gsxtmnanovg128 to i8*
%addytable2850 = call %clsvar* @add_address_table(%mzone* %zone2842, i8* %var2848, i32 0, i8* %var2849, i32 3, %clsvar* %addytable2847)
%address-table2851 = bitcast %clsvar* %addytable2850 to i8*

; insert table, function and environment into closure struct
%closure.table2854 = getelementptr { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}, { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}* %closure2844, i32 0, i32 0
store i8* %address-table2851, i8** %closure.table2854
%closure.env2855 = getelementptr { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}, { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}* %closure2844, i32 0, i32 1
store i8* %envptr2845, i8** %closure.env2855
%closure.func2856 = getelementptr { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}, { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}* %closure2844, i32 0, i32 2
store %NVGtextRow* (i8*, i8*, %NVGtextRow*)* @hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ__2804, %NVGtextRow* (i8*, i8*, %NVGtextRow*)** %closure.func2856
%closure_size2857 = call i64 @llvm_zone_mark_size(%mzone* %zone2842)
call void @llvm_zone_ptr_set_size(i8* %clsptr2843, i64 %closure_size2857)
%wrapper_ptr2858 = call i8* @llvm_zone_malloc(%mzone* %zone2842, i64 8)
%closure_wrapper2859 = bitcast i8* %wrapper_ptr2858 to { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}**
store { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}* %closure2844, { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}** %closure_wrapper2859

; let value assignment
%hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ = select i1 true, { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}** %closure_wrapper2859, { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}** %closure_wrapper2859
store { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}** %hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ, { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}*** %hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ
%tmp_envptr2853 = getelementptr {{i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}***}, {{i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}***}* %environment2846, i32 0, i32 0
store {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}*** %hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQPtr, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}**** %tmp_envptr2853


%val2862 = load {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}**, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}*** %hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQPtr
ret {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}** %val2862
}


@hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}** @hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGtextRow* @hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ(%NVGtextRow* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}**
%closure = load {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}*, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow* (i8*, i8*, %NVGtextRow*)*,  %NVGtextRow* (i8*, i8*, %NVGtextRow*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow* %ff(i8* %_impz, i8* %ee, %NVGtextRow* %arg_0)
ret %NVGtextRow* %result
}


define dllexport ccc %NVGtextRow* @hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ_native(%NVGtextRow* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}**
%closure = load {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}*, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow* (i8*, i8*, %NVGtextRow*)*,  %NVGtextRow* (i8*, i8*, %NVGtextRow*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow* %ff(i8* %_impz, i8* %ee, %NVGtextRow* %arg_0)
ret %NVGtextRow* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2863 = bitcast [100 x i8]* @gsxtmnanovg129 to i8*
call i32 (i8*, ...) @printf(i8* %var2863)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGtextRow*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}**
%closure = load {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}*, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow* (i8*, i8*, %NVGtextRow*)*,  %NVGtextRow* (i8*, i8*, %NVGtextRow*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow* %ff(i8* %_impz, i8* %ee, %NVGtextRow* %arg_0)
%tmpres = bitcast %NVGtextRow* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGtextRow*}*
%arg_p_0 = getelementptr {%NVGtextRow*}, {%NVGtextRow*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGtextRow*, %NVGtextRow** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}**
%closure = load {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}*, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow* (i8*, i8*, %NVGtextRow*)*,  %NVGtextRow* (i8*, i8*, %NVGtextRow*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow* %ff(i8* %_impz, i8* %ee, %NVGtextRow* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg130 = hidden constant [37 x i8] c"hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd__2864(i8* %_impz,i8* %_impenv, %NVGtextRow* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2865 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}***}*
%hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypdPtr = load {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}***, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}**** %hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypdPtr_

; setup arguments
%xPtr = alloca %NVGtextRow*
store %NVGtextRow* %x, %NVGtextRow** %xPtr


%val2866 = load %NVGtextRow*, %NVGtextRow** %xPtr
%val2867 = bitcast %NVGtextRow* %val2866 to i8*
call ccc void @free(i8* %val2867)
ret void
}
@gsxtmnanovg131 = hidden constant [90 x i8] c"hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** @hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2889 = load i8*, i8** %_impzPtr
%zone2890 = bitcast i8* %tzone2889 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd
%dat_hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd = call i8* @llvm_zone_malloc(%mzone* %zone2890, i64 8)
%hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypdPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd to { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}***
%tzone2870 = load i8*, i8** %_impzPtr
%zone2871 = bitcast i8* %tzone2870 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2871)
; malloc closure structure
%clsptr2872 = call i8* @llvm_zone_malloc(%mzone* %zone2871, i64 24)
%closure2873 = bitcast i8* %clsptr2872 to { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}*

; malloc environment structure
%envptr2874 = call i8* @llvm_zone_malloc(%mzone* %zone2871, i64 8)
%environment2875 = bitcast i8* %envptr2874 to {{i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}***}*

; malloc closure address table
%addytable2876 = call %clsvar* @new_address_table()
%var2877 = bitcast [37 x i8]* @gsxtmnanovg130 to i8*
%var2878 = bitcast [45 x i8]* @gsxtmnanovg122 to i8*
%addytable2879 = call %clsvar* @add_address_table(%mzone* %zone2871, i8* %var2877, i32 0, i8* %var2878, i32 3, %clsvar* %addytable2876)
%address-table2880 = bitcast %clsvar* %addytable2879 to i8*

; insert table, function and environment into closure struct
%closure.table2883 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure2873, i32 0, i32 0
store i8* %address-table2880, i8** %closure.table2883
%closure.env2884 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure2873, i32 0, i32 1
store i8* %envptr2874, i8** %closure.env2884
%closure.func2885 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure2873, i32 0, i32 2
store void (i8*, i8*, %NVGtextRow*)* @hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd__2864, void (i8*, i8*, %NVGtextRow*)** %closure.func2885
%closure_size2886 = call i64 @llvm_zone_mark_size(%mzone* %zone2871)
call void @llvm_zone_ptr_set_size(i8* %clsptr2872, i64 %closure_size2886)
%wrapper_ptr2887 = call i8* @llvm_zone_malloc(%mzone* %zone2871, i64 8)
%closure_wrapper2888 = bitcast i8* %wrapper_ptr2887 to { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}**
store { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure2873, { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** %closure_wrapper2888

; let value assignment
%hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd = select i1 true, { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** %closure_wrapper2888, { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** %closure_wrapper2888
store { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** %hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd, { i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}*** %hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypdPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd
%tmp_envptr2882 = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}***}* %environment2875, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}*** %hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypdPtr, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}**** %tmp_envptr2882


%val2891 = load {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}**, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}*** %hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypdPtr
ret {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** %val2891
}


@hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** @hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd(%NVGtextRow* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}*, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGtextRow*)*,  void (i8*, i8*, %NVGtextRow*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGtextRow* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_native(%NVGtextRow* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}*, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGtextRow*)*,  void (i8*, i8*, %NVGtextRow*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGtextRow* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2892 = bitcast [90 x i8]* @gsxtmnanovg131 to i8*
call i32 (i8*, ...) @printf(i8* %var2892)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGtextRow*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}*, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGtextRow*)*,  void (i8*, i8*, %NVGtextRow*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGtextRow* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGtextRow*}*
%arg_p_0 = getelementptr {%NVGtextRow*}, {%NVGtextRow*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGtextRow*, %NVGtextRow** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHdGV4dFJvdypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}*, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}, {i8*, i8*, void (i8*, i8*, %NVGtextRow*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGtextRow*)*,  void (i8*, i8*, %NVGtextRow*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGtextRow* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg132 = hidden constant [65 x i8] c"zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd\00"
@gsxtmnanovg133 = hidden constant [71 x i8] c"{i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %NVGtextRow* @zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd__2893(i8* %_impz,i8* %_impenv, %NVGtextRow* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2894 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpdPtr = load {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}***, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpdPtr_

; setup arguments
%xPtr = alloca %NVGtextRow*
store %NVGtextRow* %x, %NVGtextRow** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val2896 = load %mzone*, %mzone** %fromzPtr
%val2897 = load %NVGtextRow*, %NVGtextRow** %xPtr
%val2898 = bitcast %NVGtextRow* %val2897 to i8*
%res2899 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val2896, i8* %val2898)
br i1 %res2899, label %then2895, label %else2895

then2895:
%val2900 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val2900)
%zone_ptr2901 = bitcast %mzone* %val2900 to i8*
store i8* %zone_ptr2901, i8** %_impzPtr
%tzone2907 = load i8*, i8** %_impzPtr
%zone2908 = bitcast i8* %tzone2907 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGtextRow*
%tzone2903 = load i8*, i8** %_impzPtr
%zone2904 = bitcast i8* %tzone2903 to %mzone*
%dat2905 = call i8* @llvm_zone_malloc(%mzone* %zone2904, i64 40)
call i8* @memset(i8* %dat2905, i32 0, i64 40)
%val2906 = bitcast i8* %dat2905 to %NVGtextRow*

; let value assignment
%obj = select i1 true, %NVGtextRow* %val2906, %NVGtextRow* %val2906
store %NVGtextRow* %obj, %NVGtextRow** %objPtr

; promote local stack var allocations
%tzone3015 = load i8*, i8** %_impzPtr
%zone3016 = bitcast i8* %tzone3015 to %mzone*
%ifptr2967 = alloca i8*
%ifptr2938 = alloca i8*
%ifptr2909 = alloca i8*
%val2910 = load %mzone*, %mzone** %fromzPtr
%val2911 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2912 = getelementptr %NVGtextRow, %NVGtextRow* %val2911, i64 0, i32 0
%val2913 = load i8*, i8** %val2912
%val2914 = bitcast i8* %val2913 to i8*
%res2915 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val2910, i8* %val2914)
br i1 %res2915, label %then2909, label %else2909

then2909:
%tzone2920 = load i8*, i8** %_impzPtr
%zone2921 = bitcast i8* %tzone2920 to %mzone*

; let assign value to symbol newptr
%newptrPtr = alloca i8*
%tzone2916 = load i8*, i8** %_impzPtr
%zone2917 = bitcast i8* %tzone2916 to %mzone*
%dat2918 = call i8* @llvm_zone_malloc(%mzone* %zone2917, i64 1)
call i8* @memset(i8* %dat2918, i32 0, i64 1)
%val2919 = bitcast i8* %dat2918 to i8*

; let value assignment
%newptr = select i1 true, i8* %val2919, i8* %val2919
store i8* %newptr, i8** %newptrPtr

%val2922 = load i8*, i8** %newptrPtr
%val2923 = bitcast i8* %val2922 to i8*
%val2924 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2925 = getelementptr %NVGtextRow, %NVGtextRow* %val2924, i64 0, i32 0
%val2926 = load i8*, i8** %val2925
%val2927 = bitcast i8* %val2926 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val2923, i8* %val2927, i64 1, i32 1, i1 0)
%val2929 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2930 = load i8*, i8** %newptrPtr
; set tuple
%val2931 = getelementptr %NVGtextRow, %NVGtextRow* %val2929, i64 0, i32 0
store i8* %val2930, i8** %val2931
store i8* %val2930, i8** %ifptr2909
br label %ifcont2909

else2909:
%val2932 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2933 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2934 = getelementptr %NVGtextRow, %NVGtextRow* %val2933, i64 0, i32 0
%val2935 = load i8*, i8** %val2934
; set tuple
%val2936 = getelementptr %NVGtextRow, %NVGtextRow* %val2932, i64 0, i32 0
store i8* %val2935, i8** %val2936
store i8* %val2935, i8** %ifptr2909
br label %ifcont2909

ifcont2909:
%ifres2937 = load i8*, i8** %ifptr2909

%val2939 = load %mzone*, %mzone** %fromzPtr
%val2940 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2941 = getelementptr %NVGtextRow, %NVGtextRow* %val2940, i64 0, i32 1
%val2942 = load i8*, i8** %val2941
%val2943 = bitcast i8* %val2942 to i8*
%res2944 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val2939, i8* %val2943)
br i1 %res2944, label %then2938, label %else2938

then2938:
%tzone2949 = load i8*, i8** %_impzPtr
%zone2950 = bitcast i8* %tzone2949 to %mzone*

; let assign value to symbol newptr_s_24
%newptr_s_24Ptr = alloca i8*
%tzone2945 = load i8*, i8** %_impzPtr
%zone2946 = bitcast i8* %tzone2945 to %mzone*
%dat2947 = call i8* @llvm_zone_malloc(%mzone* %zone2946, i64 1)
call i8* @memset(i8* %dat2947, i32 0, i64 1)
%val2948 = bitcast i8* %dat2947 to i8*

; let value assignment
%newptr_s_24 = select i1 true, i8* %val2948, i8* %val2948
store i8* %newptr_s_24, i8** %newptr_s_24Ptr

%val2951 = load i8*, i8** %newptr_s_24Ptr
%val2952 = bitcast i8* %val2951 to i8*
%val2953 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2954 = getelementptr %NVGtextRow, %NVGtextRow* %val2953, i64 0, i32 1
%val2955 = load i8*, i8** %val2954
%val2956 = bitcast i8* %val2955 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val2952, i8* %val2956, i64 1, i32 1, i1 0)
%val2958 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2959 = load i8*, i8** %newptr_s_24Ptr
; set tuple
%val2960 = getelementptr %NVGtextRow, %NVGtextRow* %val2958, i64 0, i32 1
store i8* %val2959, i8** %val2960
store i8* %val2959, i8** %ifptr2938
br label %ifcont2938

else2938:
%val2961 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2962 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2963 = getelementptr %NVGtextRow, %NVGtextRow* %val2962, i64 0, i32 1
%val2964 = load i8*, i8** %val2963
; set tuple
%val2965 = getelementptr %NVGtextRow, %NVGtextRow* %val2961, i64 0, i32 1
store i8* %val2964, i8** %val2965
store i8* %val2964, i8** %ifptr2938
br label %ifcont2938

ifcont2938:
%ifres2966 = load i8*, i8** %ifptr2938

%val2968 = load %mzone*, %mzone** %fromzPtr
%val2969 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2970 = getelementptr %NVGtextRow, %NVGtextRow* %val2969, i64 0, i32 2
%val2971 = load i8*, i8** %val2970
%val2972 = bitcast i8* %val2971 to i8*
%res2973 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val2968, i8* %val2972)
br i1 %res2973, label %then2967, label %else2967

then2967:
%tzone2978 = load i8*, i8** %_impzPtr
%zone2979 = bitcast i8* %tzone2978 to %mzone*

; let assign value to symbol newptr_s_25
%newptr_s_25Ptr = alloca i8*
%tzone2974 = load i8*, i8** %_impzPtr
%zone2975 = bitcast i8* %tzone2974 to %mzone*
%dat2976 = call i8* @llvm_zone_malloc(%mzone* %zone2975, i64 1)
call i8* @memset(i8* %dat2976, i32 0, i64 1)
%val2977 = bitcast i8* %dat2976 to i8*

; let value assignment
%newptr_s_25 = select i1 true, i8* %val2977, i8* %val2977
store i8* %newptr_s_25, i8** %newptr_s_25Ptr

%val2980 = load i8*, i8** %newptr_s_25Ptr
%val2981 = bitcast i8* %val2980 to i8*
%val2982 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2983 = getelementptr %NVGtextRow, %NVGtextRow* %val2982, i64 0, i32 2
%val2984 = load i8*, i8** %val2983
%val2985 = bitcast i8* %val2984 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val2981, i8* %val2985, i64 1, i32 1, i1 0)
%val2987 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2988 = load i8*, i8** %newptr_s_25Ptr
; set tuple
%val2989 = getelementptr %NVGtextRow, %NVGtextRow* %val2987, i64 0, i32 2
store i8* %val2988, i8** %val2989
store i8* %val2988, i8** %ifptr2967
br label %ifcont2967

else2967:
%val2990 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2991 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2992 = getelementptr %NVGtextRow, %NVGtextRow* %val2991, i64 0, i32 2
%val2993 = load i8*, i8** %val2992
; set tuple
%val2994 = getelementptr %NVGtextRow, %NVGtextRow* %val2990, i64 0, i32 2
store i8* %val2993, i8** %val2994
store i8* %val2993, i8** %ifptr2967
br label %ifcont2967

ifcont2967:
%ifres2995 = load i8*, i8** %ifptr2967

%val2996 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val2997 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val2998 = getelementptr %NVGtextRow, %NVGtextRow* %val2997, i64 0, i32 3
%val2999 = load float, float* %val2998
; set tuple
%val3000 = getelementptr %NVGtextRow, %NVGtextRow* %val2996, i64 0, i32 3
store float %val2999, float* %val3000
%val3001 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val3002 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val3003 = getelementptr %NVGtextRow, %NVGtextRow* %val3002, i64 0, i32 4
%val3004 = load float, float* %val3003
; set tuple
%val3005 = getelementptr %NVGtextRow, %NVGtextRow* %val3001, i64 0, i32 4
store float %val3004, float* %val3005
%val3006 = load %NVGtextRow*, %NVGtextRow** %objPtr
%val3007 = load %NVGtextRow*, %NVGtextRow** %xPtr
; tuple ref
%val3008 = getelementptr %NVGtextRow, %NVGtextRow* %val3007, i64 0, i32 5
%val3009 = load float, float* %val3008
; set tuple
%val3010 = getelementptr %NVGtextRow, %NVGtextRow* %val3006, i64 0, i32 5
store float %val3009, float* %val3010
%oldzone3011 = call %mzone* @llvm_pop_zone_stack()
%newzone3012 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr3013 = bitcast %mzone* %newzone3012 to i8*
store i8* %zone_ptr3013, i8** %_impzPtr
%val3014 = load %NVGtextRow*, %NVGtextRow** %objPtr
ret %NVGtextRow* %val3014

else2895:
%val3017 = load %NVGtextRow*, %NVGtextRow** %xPtr
ret %NVGtextRow* %val3017
}
@gsxtmnanovg134 = hidden constant [118 x i8] c"zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}** @zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3037 = load i8*, i8** %_impzPtr
%zone3038 = bitcast i8* %tzone3037 to %mzone*

; let assign value to symbol zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd
%dat_zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone3038, i64 8)
%zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpdPtr = bitcast i8* %dat_zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd to { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}***
%tzone3018 = load i8*, i8** %_impzPtr
%zone3019 = bitcast i8* %tzone3018 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3019)
; malloc closure structure
%clsptr3020 = call i8* @llvm_zone_malloc(%mzone* %zone3019, i64 24)
%closure3021 = bitcast i8* %clsptr3020 to { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr3022 = call i8* @llvm_zone_malloc(%mzone* %zone3019, i64 8)
%environment3023 = bitcast i8* %envptr3022 to {{i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable3024 = call %clsvar* @new_address_table()
%var3025 = bitcast [65 x i8]* @gsxtmnanovg132 to i8*
%var3026 = bitcast [71 x i8]* @gsxtmnanovg133 to i8*
%addytable3027 = call %clsvar* @add_address_table(%mzone* %zone3019, i8* %var3025, i32 0, i8* %var3026, i32 3, %clsvar* %addytable3024)
%address-table3028 = bitcast %clsvar* %addytable3027 to i8*

; insert table, function and environment into closure struct
%closure.table3031 = getelementptr { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}* %closure3021, i32 0, i32 0
store i8* %address-table3028, i8** %closure.table3031
%closure.env3032 = getelementptr { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}* %closure3021, i32 0, i32 1
store i8* %envptr3022, i8** %closure.env3032
%closure.func3033 = getelementptr { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}* %closure3021, i32 0, i32 2
store %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)* @zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd__2893, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)** %closure.func3033
%closure_size3034 = call i64 @llvm_zone_mark_size(%mzone* %zone3019)
call void @llvm_zone_ptr_set_size(i8* %clsptr3020, i64 %closure_size3034)
%wrapper_ptr3035 = call i8* @llvm_zone_malloc(%mzone* %zone3019, i64 8)
%closure_wrapper3036 = bitcast i8* %wrapper_ptr3035 to { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}**
store { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}* %closure3021, { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}** %closure_wrapper3036

; let value assignment
%zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd = select i1 true, { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}** %closure_wrapper3036, { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}** %closure_wrapper3036
store { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}** %zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd, { i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd
%tmp_envptr3030 = getelementptr {{i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}***}* %environment3023, i32 0, i32 0
store {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpdPtr, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}**** %tmp_envptr3030


%val3039 = load {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}**, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpdPtr
ret {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}** %val3039
}


@zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}** @zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGtextRow* @zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd(%NVGtextRow* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*,  %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow* %ff(i8* %_impz, i8* %ee, %NVGtextRow* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %NVGtextRow* %result
}


define dllexport ccc %NVGtextRow* @zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd_native(%NVGtextRow* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*,  %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow* %ff(i8* %_impz, i8* %ee, %NVGtextRow* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %NVGtextRow* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3040 = bitcast [118 x i8]* @gsxtmnanovg134 to i8*
call i32 (i8*, ...) @printf(i8* %var3040)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGtextRow*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3041 = bitcast [118 x i8]* @gsxtmnanovg134 to i8*
call i32 (i8*, ...) @printf(i8* %var3041)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3042 = bitcast [118 x i8]* @gsxtmnanovg134 to i8*
call i32 (i8*, ...) @printf(i8* %var3042)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*,  %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow* %ff(i8* %_impz, i8* %ee, %NVGtextRow* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %NVGtextRow* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGtextRow*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%NVGtextRow*, %mzone*, %mzone*}, {%NVGtextRow*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGtextRow*, %NVGtextRow** %arg_p_0
%arg_p_1 = getelementptr {%NVGtextRow*, %mzone*, %mzone*}, {%NVGtextRow*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%NVGtextRow*, %mzone*, %mzone*}, {%NVGtextRow*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3RleHRSb3cqLE5WR3RleHRSb3cqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)*,  %NVGtextRow* (i8*, i8*, %NVGtextRow*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGtextRow* %ff(i8* %_impz, i8* %ee, %NVGtextRow* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@NVG_IMAGE_GENERATE_MIPMAPS = dllexport global i32 zeroinitializer
@NVG_IMAGE_REPEATX = dllexport global i32 zeroinitializer
@NVG_IMAGE_REPEATY = dllexport global i32 zeroinitializer
@NVG_IMAGE_FLIPY = dllexport global i32 zeroinitializer
@NVG_IMAGE_PREMULTIPLIED = dllexport global i32 zeroinitializer
declare cc 0 void @nvgBeginFrame(i8*,i32,i32,float) nounwind
declare cc 0 void @nvgCancelFrame(i8*) nounwind
declare cc 0 void @nvgEndFrame(i8*) nounwind
declare cc 0 %NVGcolor @nvgRGB(i8,i8,i8) nounwind
declare cc 0 %NVGcolor @nvgRGBf(float,float,float) nounwind
declare cc 0 %NVGcolor @nvgRGBA(i8,i8,i8,i8) nounwind
declare cc 0 %NVGcolor @nvgRGBAf(float,float,float,float) nounwind
declare cc 0 %NVGcolor @nvgLerpRGBA(%NVGcolor,%NVGcolor,float) nounwind
declare cc 0 %NVGcolor @nvgTransRGBA(%NVGcolor,i8) nounwind
declare cc 0 %NVGcolor @nvgTransRGBAf(%NVGcolor,float) nounwind
declare cc 0 %NVGcolor @nvgHSL(float,float,float) nounwind
declare cc 0 %NVGcolor @nvgHSLA(float,float,float,i8) nounwind
declare cc 0 void @nvgSave(i8*) nounwind
declare cc 0 void @nvgRestore(i8*) nounwind
declare cc 0 void @nvgReset(i8*) nounwind
declare cc 0 void @nvgStrokeColor(i8*,%NVGcolor*) nounwind
declare cc 0 void @nvgStrokePaint(i8*,%NVGpaint*) nounwind
declare cc 0 void @nvgFillColor(i8*,%NVGcolor*) nounwind
declare cc 0 void @nvgFillPaint(i8*,%NVGpaint*) nounwind
declare cc 0 void @nvgMiterLimit(i8*,float) nounwind
declare cc 0 void @nvgStrokeWidth(i8*,float) nounwind
declare cc 0 void @nvgLineCap(i8*,i32) nounwind
declare cc 0 void @nvgLineJoin(i8*,i32) nounwind
declare cc 0 void @nvgGlobalAlpha(i8*,float) nounwind
declare cc 0 void @nvgResetTransform(i8*) nounwind
declare cc 0 void @nvgTransform(i8*,float,float,float,float,float,float) nounwind
declare cc 0 void @nvgTranslate(i8*,float,float) nounwind
declare cc 0 void @nvgRotate(i8*,float) nounwind
declare cc 0 void @nvgSkewX(i8*,float) nounwind
declare cc 0 void @nvgSkewY(i8*,float) nounwind
declare cc 0 void @nvgScale(i8*,float,float) nounwind
declare cc 0 void @nvgCurrentTransform(i8*,float*) nounwind
declare cc 0 void @nvgTransformIdentity(float*) nounwind
declare cc 0 void @nvgTransformTranslate(float*,float,float) nounwind
declare cc 0 void @nvgTransformScale(float*,float,float) nounwind
declare cc 0 void @nvgTransformRotate(float*,float) nounwind
declare cc 0 void @nvgTransformSkewX(float*,float) nounwind
declare cc 0 void @nvgTransformSkewY(float*,float) nounwind
declare cc 0 void @nvgTransformMultiply(float*,float*) nounwind
declare cc 0 void @nvgTransformPremultiply(float*,float*) nounwind
declare cc 0 i32 @nvgTransformInverse(float*,float*) nounwind
declare cc 0 void @nvgTransformPoint(float*,float*,float*,float,float) nounwind
declare cc 0 float @nvgDegToRad(float) nounwind
declare cc 0 float @nvgRadToDeg(float) nounwind
declare cc 0 i32 @nvgCreateImage(i8*,i8*,i32) nounwind
declare cc 0 i32 @nvgCreateImageMem(i8*,i32,i8*,i32) nounwind
declare cc 0 i32 @nvgCreateImageRGBA(i8*,i32,i32,i32,i8*) nounwind
declare cc 0 void @nvgUpdateImage(i8*,i32,i8*) nounwind
declare cc 0 void @nvgImageSize(i8*,i32,i32*,i32*) nounwind
declare cc 0 void @nvgDeleteImage(i8*,i32) nounwind
declare cc 0 %NVGpaint* @nvgLinearGradient(i8*,float,float,float,float,%NVGcolor*,%NVGcolor*) nounwind
declare cc 0 %NVGpaint* @nvgBoxGradient(i8*,float,float,float,float,float,float,%NVGcolor*,%NVGcolor*) nounwind
declare cc 0 %NVGpaint* @nvgRadialGradient(i8*,float,float,float,float,%NVGcolor*,%NVGcolor*) nounwind
declare cc 0 %NVGpaint* @nvgImagePattern(i8*,float,float,float,float,float,i32,float) nounwind
declare cc 0 void @nvgScissor(i8*,float,float,float,float) nounwind
declare cc 0 void @nvgIntersectScissor(i8*,float,float,float,float) nounwind
declare cc 0 void @nvgResetScissor(i8*) nounwind
declare cc 0 void @nvgBeginPath(i8*) nounwind
declare cc 0 void @nvgMoveTo(i8*,float,float) nounwind
declare cc 0 void @nvgLineTo(i8*,float,float) nounwind
declare cc 0 void @nvgBezierTo(i8*,float,float,float,float,float,float) nounwind
declare cc 0 void @nvgQuadTo(i8*,float,float,float,float) nounwind
declare cc 0 void @nvgArcTo(i8*,float,float,float,float,float) nounwind
declare cc 0 void @nvgClosePath(i8*) nounwind
declare cc 0 void @nvgPathWinding(i8*,i32) nounwind
declare cc 0 void @nvgArc(i8*,float,float,float,float,float,i32) nounwind
declare cc 0 void @nvgRect(i8*,float,float,float,float) nounwind
declare cc 0 void @nvgRoundedRect(i8*,float,float,float,float,float) nounwind
declare cc 0 void @nvgRoundedRectVarying(i8*,float,float,float,float,float,float,float,float) nounwind
declare cc 0 void @nvgEllipse(i8*,float,float,float,float) nounwind
declare cc 0 void @nvgCircle(i8*,float,float,float) nounwind
declare cc 0 void @nvgFill(i8*) nounwind
declare cc 0 void @nvgStroke(i8*) nounwind
declare cc 0 i32 @nvgCreateFont(i8*,i8*,i8*) nounwind
declare cc 0 i32 @nvgCreateFontMem(i8*,i8*,i8*,i32,i32) nounwind
declare cc 0 i32 @nvgFindFont(i8*,i8*) nounwind
declare cc 0 void @nvgFontSize(i8*,float) nounwind
declare cc 0 void @nvgFontBlur(i8*,float) nounwind
declare cc 0 void @nvgTextLetterSpacing(i8*,float) nounwind
declare cc 0 void @nvgTextLineHeight(i8*,float) nounwind
declare cc 0 void @nvgTextAlign(i8*,i32) nounwind
declare cc 0 void @nvgFontFaceId(i8*,i32) nounwind
declare cc 0 void @nvgFontFace(i8*,i8*) nounwind
declare cc 0 i32 @nvgAddFallbackFontId(i8*,i32,i32) nounwind
declare cc 0 i32 @nvgAddFallbackFont(i8*,i8*,i8*) nounwind
declare cc 0 float @nvgText(i8*,float,float,i8*,i8*) nounwind
declare cc 0 void @nvgTextBox(i8*,float,float,float,i8*,i8*) nounwind
declare cc 0 float @nvgTextBounds(i8*,float,float,i8*,i8*,float*) nounwind
declare cc 0 void @nvgTextBoxBounds(i8*,float,float,float,i8*,i8*,float*) nounwind
declare cc 0 i32 @nvgTextGlyphPositions(i8*,float,float,i8*,i8*,%NVGglyphPosition*,i32) nounwind
declare cc 0 void @nvgTextMetrics(i8*,float*,float*,float*) nounwind
declare cc 0 i32 @nvgTextBreakLines(i8*,i8*,i8*,float,%NVGtextRow*,i32) nounwind
@NVG_TEXTURE_ALPHA = dllexport global i32 1
@NVG_TEXTURE_RGBA = dllexport global i32 2
%NVGscissor = type {float,float}
@gsxtmnanovg135 = hidden constant [52 x i8] c"NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ\00"
@gsxtmnanovg136 = hidden constant [53 x i8] c"{i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**\00"
define dllexport fastcc %NVGscissor* @NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ__3043(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3044 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***}*
%NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***}, {{i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***}* %impenv, i32 0, i32 0
%NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**** %NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr


%tzone3049 = load i8*, i8** %_impzPtr
%zone3050 = bitcast i8* %tzone3049 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGscissor*
%tzone3045 = load i8*, i8** %_impzPtr
%zone3046 = bitcast i8* %tzone3045 to %mzone*
%dat3047 = call i8* @llvm_zone_malloc(%mzone* %zone3046, i64 8)
call i8* @memset(i8* %dat3047, i32 0, i64 8)
%val3048 = bitcast i8* %dat3047 to %NVGscissor*

; let value assignment
%obj = select i1 true, %NVGscissor* %val3048, %NVGscissor* %val3048
store %NVGscissor* %obj, %NVGscissor** %objPtr

%val3051 = load %NVGscissor*, %NVGscissor** %objPtr
%val3052 = load float, float* %arg_0Ptr
; set tuple
%val3053 = getelementptr %NVGscissor, %NVGscissor* %val3051, i64 0, i32 0
store float %val3052, float* %val3053
%val3054 = load %NVGscissor*, %NVGscissor** %objPtr
%val3055 = load float, float* %arg_1Ptr
; set tuple
%val3056 = getelementptr %NVGscissor, %NVGscissor* %val3054, i64 0, i32 1
store float %val3055, float* %val3056
%val3057 = load %NVGscissor*, %NVGscissor** %objPtr
ret %NVGscissor* %val3057
}
@gsxtmnanovg137 = hidden constant [105 x i8] c"NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** @NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3077 = load i8*, i8** %_impzPtr
%zone3078 = bitcast i8* %tzone3077 to %mzone*

; let assign value to symbol NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ
%dat_NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone3078, i64 8)
%NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ to { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***
%tzone3058 = load i8*, i8** %_impzPtr
%zone3059 = bitcast i8* %tzone3058 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3059)
; malloc closure structure
%clsptr3060 = call i8* @llvm_zone_malloc(%mzone* %zone3059, i64 24)
%closure3061 = bitcast i8* %clsptr3060 to { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*

; malloc environment structure
%envptr3062 = call i8* @llvm_zone_malloc(%mzone* %zone3059, i64 8)
%environment3063 = bitcast i8* %envptr3062 to {{i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***}*

; malloc closure address table
%addytable3064 = call %clsvar* @new_address_table()
%var3065 = bitcast [52 x i8]* @gsxtmnanovg135 to i8*
%var3066 = bitcast [53 x i8]* @gsxtmnanovg136 to i8*
%addytable3067 = call %clsvar* @add_address_table(%mzone* %zone3059, i8* %var3065, i32 0, i8* %var3066, i32 3, %clsvar* %addytable3064)
%address-table3068 = bitcast %clsvar* %addytable3067 to i8*

; insert table, function and environment into closure struct
%closure.table3071 = getelementptr { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure3061, i32 0, i32 0
store i8* %address-table3068, i8** %closure.table3071
%closure.env3072 = getelementptr { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure3061, i32 0, i32 1
store i8* %envptr3062, i8** %closure.env3072
%closure.func3073 = getelementptr { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure3061, i32 0, i32 2
store %NVGscissor* (i8*, i8*, float, float)* @NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ__3043, %NVGscissor* (i8*, i8*, float, float)** %closure.func3073
%closure_size3074 = call i64 @llvm_zone_mark_size(%mzone* %zone3059)
call void @llvm_zone_ptr_set_size(i8* %clsptr3060, i64 %closure_size3074)
%wrapper_ptr3075 = call i8* @llvm_zone_malloc(%mzone* %zone3059, i64 8)
%closure_wrapper3076 = bitcast i8* %wrapper_ptr3075 to { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**
store { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure3061, { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure_wrapper3076

; let value assignment
%NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure_wrapper3076, { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure_wrapper3076
store { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ, { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*** %NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ
%tmp_envptr3070 = getelementptr {{i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***}, {{i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***}* %environment3063, i32 0, i32 0
store {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*** %NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**** %tmp_envptr3070


%val3079 = load {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*** %NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %val3079
}


@NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** @NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGscissor* @NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor* (i8*, i8*, float, float)*,  %NVGscissor* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %NVGscissor* %result
}


define dllexport ccc %NVGscissor* @NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_native(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor* (i8*, i8*, float, float)*,  %NVGscissor* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %NVGscissor* %result
}


define dllexport ccc i8*  @NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3080 = bitcast [105 x i8]* @gsxtmnanovg137 to i8*
call i32 (i8*, ...) @printf(i8* %var3080)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3081 = bitcast [105 x i8]* @gsxtmnanovg137 to i8*
call i32 (i8*, ...) @printf(i8* %var3081)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor* (i8*, i8*, float, float)*,  %NVGscissor* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%tmpres = bitcast %NVGscissor* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float}*
%arg_p_0 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor* (i8*, i8*, float, float)*,  %NVGscissor* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg138 = hidden constant [54 x i8] c"NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ\00"
define dllexport fastcc %NVGscissor* @NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ__3082(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3083 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***}*
%NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***}, {{i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***}* %impenv, i32 0, i32 0
%NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**** %NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr


%tzone3088 = load i8*, i8** %_impzPtr
%zone3089 = bitcast i8* %tzone3088 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGscissor*
%tzone3084 = load i8*, i8** %_impzPtr
%zone3085 = bitcast i8* %tzone3084 to %mzone*
%dat3086 = call i8* @llvm_zone_malloc(%mzone* %zone3085, i64 8)
call i8* @memset(i8* %dat3086, i32 0, i64 8)
%val3087 = bitcast i8* %dat3086 to %NVGscissor*

; let value assignment
%obj = select i1 true, %NVGscissor* %val3087, %NVGscissor* %val3087
store %NVGscissor* %obj, %NVGscissor** %objPtr

%val3090 = load %NVGscissor*, %NVGscissor** %objPtr
%val3091 = load float, float* %arg_0Ptr
; set tuple
%val3092 = getelementptr %NVGscissor, %NVGscissor* %val3090, i64 0, i32 0
store float %val3091, float* %val3092
%val3093 = load %NVGscissor*, %NVGscissor** %objPtr
%val3094 = load float, float* %arg_1Ptr
; set tuple
%val3095 = getelementptr %NVGscissor, %NVGscissor* %val3093, i64 0, i32 1
store float %val3094, float* %val3095
%val3096 = load %NVGscissor*, %NVGscissor** %objPtr
ret %NVGscissor* %val3096
}
@gsxtmnanovg139 = hidden constant [107 x i8] c"NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** @NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3116 = load i8*, i8** %_impzPtr
%zone3117 = bitcast i8* %tzone3116 to %mzone*

; let assign value to symbol NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ
%dat_NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone3117, i64 8)
%NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ to { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***
%tzone3097 = load i8*, i8** %_impzPtr
%zone3098 = bitcast i8* %tzone3097 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3098)
; malloc closure structure
%clsptr3099 = call i8* @llvm_zone_malloc(%mzone* %zone3098, i64 24)
%closure3100 = bitcast i8* %clsptr3099 to { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*

; malloc environment structure
%envptr3101 = call i8* @llvm_zone_malloc(%mzone* %zone3098, i64 8)
%environment3102 = bitcast i8* %envptr3101 to {{i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***}*

; malloc closure address table
%addytable3103 = call %clsvar* @new_address_table()
%var3104 = bitcast [54 x i8]* @gsxtmnanovg138 to i8*
%var3105 = bitcast [53 x i8]* @gsxtmnanovg136 to i8*
%addytable3106 = call %clsvar* @add_address_table(%mzone* %zone3098, i8* %var3104, i32 0, i8* %var3105, i32 3, %clsvar* %addytable3103)
%address-table3107 = bitcast %clsvar* %addytable3106 to i8*

; insert table, function and environment into closure struct
%closure.table3110 = getelementptr { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure3100, i32 0, i32 0
store i8* %address-table3107, i8** %closure.table3110
%closure.env3111 = getelementptr { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure3100, i32 0, i32 1
store i8* %envptr3101, i8** %closure.env3111
%closure.func3112 = getelementptr { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure3100, i32 0, i32 2
store %NVGscissor* (i8*, i8*, float, float)* @NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ__3082, %NVGscissor* (i8*, i8*, float, float)** %closure.func3112
%closure_size3113 = call i64 @llvm_zone_mark_size(%mzone* %zone3098)
call void @llvm_zone_ptr_set_size(i8* %clsptr3099, i64 %closure_size3113)
%wrapper_ptr3114 = call i8* @llvm_zone_malloc(%mzone* %zone3098, i64 8)
%closure_wrapper3115 = bitcast i8* %wrapper_ptr3114 to { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**
store { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure3100, { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure_wrapper3115

; let value assignment
%NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure_wrapper3115, { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure_wrapper3115
store { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ, { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*** %NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ
%tmp_envptr3109 = getelementptr {{i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***}, {{i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***}* %environment3102, i32 0, i32 0
store {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*** %NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**** %tmp_envptr3109


%val3118 = load {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*** %NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %val3118
}


@NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** @NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGscissor* @NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor* (i8*, i8*, float, float)*,  %NVGscissor* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %NVGscissor* %result
}


define dllexport ccc %NVGscissor* @NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_native(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor* (i8*, i8*, float, float)*,  %NVGscissor* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %NVGscissor* %result
}


define dllexport ccc i8*  @NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3119 = bitcast [107 x i8]* @gsxtmnanovg139 to i8*
call i32 (i8*, ...) @printf(i8* %var3119)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3120 = bitcast [107 x i8]* @gsxtmnanovg139 to i8*
call i32 (i8*, ...) @printf(i8* %var3120)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor* (i8*, i8*, float, float)*,  %NVGscissor* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%tmpres = bitcast %NVGscissor* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float}*
%arg_p_0 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_z_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor* (i8*, i8*, float, float)*,  %NVGscissor* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg140 = hidden constant [54 x i8] c"NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ\00"
define dllexport fastcc %NVGscissor* @NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ__3121(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3122 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***}*
%NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***}, {{i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***}* %impenv, i32 0, i32 0
%NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**** %NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr


%tzone3125 = load i8*, i8** %_impzPtr
%zone3126 = bitcast i8* %tzone3125 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGscissor*
%dat3123 = call i8* @malloc(i64 8)
call i8* @memset(i8* %dat3123, i32 0, i64 8)
%val3124 = bitcast i8* %dat3123 to %NVGscissor*

; let value assignment
%obj = select i1 true, %NVGscissor* %val3124, %NVGscissor* %val3124
store %NVGscissor* %obj, %NVGscissor** %objPtr

%val3127 = load %NVGscissor*, %NVGscissor** %objPtr
%val3128 = load float, float* %arg_0Ptr
; set tuple
%val3129 = getelementptr %NVGscissor, %NVGscissor* %val3127, i64 0, i32 0
store float %val3128, float* %val3129
%val3130 = load %NVGscissor*, %NVGscissor** %objPtr
%val3131 = load float, float* %arg_1Ptr
; set tuple
%val3132 = getelementptr %NVGscissor, %NVGscissor* %val3130, i64 0, i32 1
store float %val3131, float* %val3132
%val3133 = load %NVGscissor*, %NVGscissor** %objPtr
ret %NVGscissor* %val3133
}
@gsxtmnanovg141 = hidden constant [107 x i8] c"NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** @NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3153 = load i8*, i8** %_impzPtr
%zone3154 = bitcast i8* %tzone3153 to %mzone*

; let assign value to symbol NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ
%dat_NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone3154, i64 8)
%NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ to { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***
%tzone3134 = load i8*, i8** %_impzPtr
%zone3135 = bitcast i8* %tzone3134 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3135)
; malloc closure structure
%clsptr3136 = call i8* @llvm_zone_malloc(%mzone* %zone3135, i64 24)
%closure3137 = bitcast i8* %clsptr3136 to { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*

; malloc environment structure
%envptr3138 = call i8* @llvm_zone_malloc(%mzone* %zone3135, i64 8)
%environment3139 = bitcast i8* %envptr3138 to {{i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***}*

; malloc closure address table
%addytable3140 = call %clsvar* @new_address_table()
%var3141 = bitcast [54 x i8]* @gsxtmnanovg140 to i8*
%var3142 = bitcast [53 x i8]* @gsxtmnanovg136 to i8*
%addytable3143 = call %clsvar* @add_address_table(%mzone* %zone3135, i8* %var3141, i32 0, i8* %var3142, i32 3, %clsvar* %addytable3140)
%address-table3144 = bitcast %clsvar* %addytable3143 to i8*

; insert table, function and environment into closure struct
%closure.table3147 = getelementptr { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure3137, i32 0, i32 0
store i8* %address-table3144, i8** %closure.table3147
%closure.env3148 = getelementptr { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure3137, i32 0, i32 1
store i8* %envptr3138, i8** %closure.env3148
%closure.func3149 = getelementptr { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure3137, i32 0, i32 2
store %NVGscissor* (i8*, i8*, float, float)* @NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ__3121, %NVGscissor* (i8*, i8*, float, float)** %closure.func3149
%closure_size3150 = call i64 @llvm_zone_mark_size(%mzone* %zone3135)
call void @llvm_zone_ptr_set_size(i8* %clsptr3136, i64 %closure_size3150)
%wrapper_ptr3151 = call i8* @llvm_zone_malloc(%mzone* %zone3135, i64 8)
%closure_wrapper3152 = bitcast i8* %wrapper_ptr3151 to { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**
store { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure3137, { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure_wrapper3152

; let value assignment
%NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure_wrapper3152, { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure_wrapper3152
store { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ, { i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*** %NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ
%tmp_envptr3146 = getelementptr {{i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***}, {{i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}***}* %environment3139, i32 0, i32 0
store {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*** %NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**** %tmp_envptr3146


%val3155 = load {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*** %NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %val3155
}


@NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** @NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGscissor* @NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor* (i8*, i8*, float, float)*,  %NVGscissor* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %NVGscissor* %result
}


define dllexport ccc %NVGscissor* @NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_native(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor* (i8*, i8*, float, float)*,  %NVGscissor* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %NVGscissor* %result
}


define dllexport ccc i8*  @NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3156 = bitcast [107 x i8]* @gsxtmnanovg141 to i8*
call i32 (i8*, ...) @printf(i8* %var3156)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3157 = bitcast [107 x i8]* @gsxtmnanovg141 to i8*
call i32 (i8*, ...) @printf(i8* %var3157)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor* (i8*, i8*, float, float)*,  %NVGscissor* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%tmpres = bitcast %NVGscissor* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float}*
%arg_p_0 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_h_adhoc_W05WR3NjaXNzb3IqLGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}*, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor* (i8*, i8*, float, float)*,  %NVGscissor* (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg142 = hidden constant [18 x i8] c"<NVGscissor:null>\00"
@gsxtmnanovg143 = hidden constant [13 x i8] c"<NVGscissor:\00"
@gsxtmnanovg144 = hidden constant [44 x i8] c"toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd\00"
@gsxtmnanovg145 = hidden constant [49 x i8] c"{i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd__3158(i8* %_impz,i8* %_impenv, %NVGscissor* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3159 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}***}*
%toString_adhoc_W1N0cmluZyosTlZHc2Npc3NvcipdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosTlZHc2Npc3NvcipdPtr = load {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}***, {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}**** %toString_adhoc_W1N0cmluZyosTlZHc2Npc3NvcipdPtr_

; setup arguments
%xPtr = alloca %NVGscissor*
store %NVGscissor* %x, %NVGscissor** %xPtr


%val3161 = load %NVGscissor*, %NVGscissor** %xPtr
%val3162 = icmp eq %NVGscissor* %val3161, null
br i1 %val3162, label %then3160, label %else3160

then3160:
%zone3163 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone3163)
%zone_ptr3164 = bitcast %mzone* %zone3163 to i8*
store i8* %zone_ptr3164, i8** %_impzPtr
%tzone3174 = load i8*, i8** %_impzPtr
%zone3175 = bitcast i8* %tzone3174 to %mzone*

; let assign value to symbol res6
%res6Ptr = alloca %String*
%tzone3179 = load i8*, i8** %_impzPtr
%zone3180 = bitcast i8* %tzone3179 to %mzone*

; let assign value to symbol zone6
%zone6Ptr = alloca %mzone*
%tzone3182 = load i8*, i8** %_impzPtr
%zone3183 = bitcast i8* %tzone3182 to %mzone*

; let assign value to symbol newz6
%newz6Ptr = alloca %mzone*
%tzone3166 = load i8*, i8** %_impzPtr
%zone3167 = bitcast i8* %tzone3166 to %mzone*

; let assign value to symbol xx_t_mst
%xx_t_mstPtr = alloca i8*
%dat3165 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst = select i1 true, i8* %dat3165, i8* %dat3165
store i8* %xx_t_mst, i8** %xx_t_mstPtr

%val3168 = load i8*, i8** %xx_t_mstPtr
%var3169 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var3170 = bitcast [18 x i8]* @gsxtmnanovg142 to i8*

%val3171 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3168, i8* %var3169, i8* %var3170)
%val3172 = load i8*, i8** %xx_t_mstPtr
%res3173 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3172)

; let value assignment
%res6 = select i1 true, %String* %res3173, %String* %res3173
store %String* %res6, %String** %res6Ptr

%oldzone3176 = call %mzone* @llvm_pop_zone_stack()
%newzone3177 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr3178 = bitcast %mzone* %newzone3177 to i8*
store i8* %zone_ptr3178, i8** %_impzPtr

; let value assignment
%zone6 = select i1 true, %mzone* %oldzone3176, %mzone* %oldzone3176
store %mzone* %zone6, %mzone** %zone6Ptr

%res3181 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz6 = select i1 true, %mzone* %res3181, %mzone* %res3181
store %mzone* %newz6, %mzone** %newz6Ptr

%tzone3188 = load i8*, i8** %_impzPtr
%zone3189 = bitcast i8* %tzone3188 to %mzone*

; let assign value to symbol rescopy6
%rescopy6Ptr = alloca %String*
%tzone3194 = load i8*, i8** %_impzPtr
%zone3195 = bitcast i8* %tzone3194 to %mzone*

; let assign value to symbol hook
%hookPtr = alloca {i64,i8*,i8*}*
%tzone3197 = load i8*, i8** %_impzPtr
%zone3198 = bitcast i8* %tzone3197 to %mzone*

; let assign value to symbol f
%fPtr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val3184 = load %String*, %String** %res6Ptr
%val3185 = load %mzone*, %mzone** %zone6Ptr
%val3186 = load %mzone*, %mzone** %newz6Ptr
%res3187 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val3184, %mzone* %val3185, %mzone* %val3186)

; let value assignment
%rescopy6 = select i1 true, %String* %res3187, %String* %res3187
store %String* %rescopy6, %String** %rescopy6Ptr

%val3190 = load %mzone*, %mzone** %zone6Ptr
; tuple ref
%val3191 = getelementptr %mzone, %mzone* %val3190, i64 0, i32 4
%val3192 = load i8*, i8** %val3191
%val3193 = bitcast i8* %val3192 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val3193, {i64,i8*,i8*}* %val3193
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%null3196 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null3196, {i8*, i8*, void (i8*, i8*)*}** %null3196
store {i8*, i8*, void (i8*, i8*)*}** %f, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; promote local stack var allocations
%tzone3234 = load i8*, i8** %_impzPtr
%zone3235 = bitcast i8* %tzone3234 to %mzone*
%ifptr3224 = alloca i1
%ifptr3200 = alloca i1
; while loop
%val3201 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val3202 = icmp eq {i64,i8*,i8*}* %val3201, null
br i1 %val3202, label %then3200, label %else3200

then3200:
%res3203 = call ccc i1 @impc_false()
store i1 %res3203, i1* %ifptr3200
br label %ifcont3200

else3200:
%res3204 = call ccc i1 @impc_true()
store i1 %res3204, i1* %ifptr3200
br label %ifcont3200

ifcont3200:
%ifres3205 = load i1, i1* %ifptr3200

br i1 %ifres3205, label %loop3199, label %after3199

loop3199:
; do set!
%val3206 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val3207 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val3206, i64 0, i32 1
%val3208 = load i8*, i8** %val3207
%val3209 = bitcast i8* %val3208 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val3209, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; apply closure 
%vval3210 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val3211 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval3210
%fPtr3212 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val3211, i32 0, i32 2
%ePtr3213 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val3211, i32 0, i32 1
%f3214 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr3212
%e3215 = load i8*, i8** %ePtr3213
%tzone3216 = load i8*, i8** %_impzPtr
%zone3217 = bitcast i8* %tzone3216 to %mzone*
%z3218 = bitcast %mzone* %zone3217 to i8*
tail call fastcc void %f3214(i8* %z3218, i8* %e3215)
; do set!
%val3220 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val3221 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val3220, i64 0, i32 2
%val3222 = load i8*, i8** %val3221
%val3223 = bitcast i8* %val3222 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val3223, {i64,i8*,i8*}** %hookPtr
%val3225 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val3226 = icmp eq {i64,i8*,i8*}* %val3225, null
br i1 %val3226, label %then3224, label %else3224

then3224:
%res3227 = call ccc i1 @impc_false()
store i1 %res3227, i1* %ifptr3224
br label %ifcont3224

else3224:
%res3228 = call ccc i1 @impc_true()
store i1 %res3228, i1* %ifptr3224
br label %ifcont3224

ifcont3224:
%ifres3229 = load i1, i1* %ifptr3224

br i1 %ifres3229, label %loop3199, label %after3199

after3199:
%val3231 = load %mzone*, %mzone** %zone6Ptr
call ccc void @llvm_zone_destroy(%mzone* %val3231)
%val3233 = load %String*, %String** %rescopy6Ptr
ret %String* %val3233

else3160:
%zone3236 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone3236)
%zone_ptr3237 = bitcast %mzone* %zone3236 to i8*
store i8* %zone_ptr3237, i8** %_impzPtr
%tzone3277 = load i8*, i8** %_impzPtr
%zone3278 = bitcast i8* %tzone3277 to %mzone*

; let assign value to symbol res7
%res7Ptr = alloca %String*
%tzone3282 = load i8*, i8** %_impzPtr
%zone3283 = bitcast i8* %tzone3282 to %mzone*

; let assign value to symbol zone7
%zone7Ptr = alloca %mzone*
%tzone3285 = load i8*, i8** %_impzPtr
%zone3286 = bitcast i8* %tzone3285 to %mzone*

; let assign value to symbol newz7
%newz7Ptr = alloca %mzone*
%tzone3239 = load i8*, i8** %_impzPtr
%zone3240 = bitcast i8* %tzone3239 to %mzone*

; let assign value to symbol xx_t_mst_s_26
%xx_t_mst_s_26Ptr = alloca i8*
%dat3238 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_26 = select i1 true, i8* %dat3238, i8* %dat3238
store i8* %xx_t_mst_s_26, i8** %xx_t_mst_s_26Ptr

%val3241 = load i8*, i8** %xx_t_mst_s_26Ptr
%var3242 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var3243 = bitcast [13 x i8]* @gsxtmnanovg143 to i8*

%val3244 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3241, i8* %var3242, i8* %var3243)
%val3245 = load i8*, i8** %xx_t_mst_s_26Ptr
%res3246 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3245)
%val3247 = load %NVGscissor*, %NVGscissor** %xPtr
; tuple ref
%val3248 = getelementptr %NVGscissor, %NVGscissor* %val3247, i64 0, i32 0
%val3249 = load float, float* %val3248
%res3250 = call fastcc %String* @toString_adhoc_W1N0cmluZyosZmxvYXRd(float %val3249)
%res3251 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3246, %String* %res3250)
%tzone3253 = load i8*, i8** %_impzPtr
%zone3254 = bitcast i8* %tzone3253 to %mzone*

; let assign value to symbol xx_t_mst_s_27
%xx_t_mst_s_27Ptr = alloca i8*
%dat3252 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_27 = select i1 true, i8* %dat3252, i8* %dat3252
store i8* %xx_t_mst_s_27, i8** %xx_t_mst_s_27Ptr

%val3255 = load i8*, i8** %xx_t_mst_s_27Ptr
%var3256 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var3257 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val3258 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3255, i8* %var3256, i8* %var3257)
%val3259 = load i8*, i8** %xx_t_mst_s_27Ptr
%res3260 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3259)
%res3261 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3251, %String* %res3260)
%val3262 = load %NVGscissor*, %NVGscissor** %xPtr
; tuple ref
%val3263 = getelementptr %NVGscissor, %NVGscissor* %val3262, i64 0, i32 1
%val3264 = load float, float* %val3263
%res3265 = call fastcc %String* @toString_adhoc_W1N0cmluZyosZmxvYXRd(float %val3264)
%res3266 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3261, %String* %res3265)
%tzone3268 = load i8*, i8** %_impzPtr
%zone3269 = bitcast i8* %tzone3268 to %mzone*

; let assign value to symbol xx_t_mst_s_28
%xx_t_mst_s_28Ptr = alloca i8*
%dat3267 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_28 = select i1 true, i8* %dat3267, i8* %dat3267
store i8* %xx_t_mst_s_28, i8** %xx_t_mst_s_28Ptr

%val3270 = load i8*, i8** %xx_t_mst_s_28Ptr
%var3271 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var3272 = bitcast [2 x i8]* @gsxtmnanovg65 to i8*

%val3273 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3270, i8* %var3271, i8* %var3272)
%val3274 = load i8*, i8** %xx_t_mst_s_28Ptr
%res3275 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3274)
%res3276 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3266, %String* %res3275)

; let value assignment
%res7 = select i1 true, %String* %res3276, %String* %res3276
store %String* %res7, %String** %res7Ptr

%oldzone3279 = call %mzone* @llvm_pop_zone_stack()
%newzone3280 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr3281 = bitcast %mzone* %newzone3280 to i8*
store i8* %zone_ptr3281, i8** %_impzPtr

; let value assignment
%zone7 = select i1 true, %mzone* %oldzone3279, %mzone* %oldzone3279
store %mzone* %zone7, %mzone** %zone7Ptr

%res3284 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz7 = select i1 true, %mzone* %res3284, %mzone* %res3284
store %mzone* %newz7, %mzone** %newz7Ptr

%tzone3291 = load i8*, i8** %_impzPtr
%zone3292 = bitcast i8* %tzone3291 to %mzone*

; let assign value to symbol rescopy7
%rescopy7Ptr = alloca %String*
%tzone3297 = load i8*, i8** %_impzPtr
%zone3298 = bitcast i8* %tzone3297 to %mzone*

; let assign value to symbol hook_s_29
%hook_s_29Ptr = alloca {i64,i8*,i8*}*
%tzone3300 = load i8*, i8** %_impzPtr
%zone3301 = bitcast i8* %tzone3300 to %mzone*

; let assign value to symbol f_s_30
%f_s_30Ptr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val3287 = load %String*, %String** %res7Ptr
%val3288 = load %mzone*, %mzone** %zone7Ptr
%val3289 = load %mzone*, %mzone** %newz7Ptr
%res3290 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val3287, %mzone* %val3288, %mzone* %val3289)

; let value assignment
%rescopy7 = select i1 true, %String* %res3290, %String* %res3290
store %String* %rescopy7, %String** %rescopy7Ptr

%val3293 = load %mzone*, %mzone** %zone7Ptr
; tuple ref
%val3294 = getelementptr %mzone, %mzone* %val3293, i64 0, i32 4
%val3295 = load i8*, i8** %val3294
%val3296 = bitcast i8* %val3295 to {i64,i8*,i8*}*

; let value assignment
%hook_s_29 = select i1 true, {i64,i8*,i8*}* %val3296, {i64,i8*,i8*}* %val3296
store {i64,i8*,i8*}* %hook_s_29, {i64,i8*,i8*}** %hook_s_29Ptr

%null3299 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f_s_30 = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null3299, {i8*, i8*, void (i8*, i8*)*}** %null3299
store {i8*, i8*, void (i8*, i8*)*}** %f_s_30, {i8*, i8*, void (i8*, i8*)*}*** %f_s_30Ptr

; promote local stack var allocations
%tzone3337 = load i8*, i8** %_impzPtr
%zone3338 = bitcast i8* %tzone3337 to %mzone*
%ifptr3327 = alloca i1
%ifptr3303 = alloca i1
; while loop
%val3304 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_29Ptr
%val3305 = icmp eq {i64,i8*,i8*}* %val3304, null
br i1 %val3305, label %then3303, label %else3303

then3303:
%res3306 = call ccc i1 @impc_false()
store i1 %res3306, i1* %ifptr3303
br label %ifcont3303

else3303:
%res3307 = call ccc i1 @impc_true()
store i1 %res3307, i1* %ifptr3303
br label %ifcont3303

ifcont3303:
%ifres3308 = load i1, i1* %ifptr3303

br i1 %ifres3308, label %loop3302, label %after3302

loop3302:
; do set!
%val3309 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_29Ptr
; tuple ref
%val3310 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val3309, i64 0, i32 1
%val3311 = load i8*, i8** %val3310
%val3312 = bitcast i8* %val3311 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val3312, {i8*, i8*, void (i8*, i8*)*}*** %f_s_30Ptr

; apply closure 
%vval3313 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %f_s_30Ptr
%val3314 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval3313
%fPtr3315 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val3314, i32 0, i32 2
%ePtr3316 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val3314, i32 0, i32 1
%f3317 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr3315
%e3318 = load i8*, i8** %ePtr3316
%tzone3319 = load i8*, i8** %_impzPtr
%zone3320 = bitcast i8* %tzone3319 to %mzone*
%z3321 = bitcast %mzone* %zone3320 to i8*
tail call fastcc void %f3317(i8* %z3321, i8* %e3318)
; do set!
%val3323 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_29Ptr
; tuple ref
%val3324 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val3323, i64 0, i32 2
%val3325 = load i8*, i8** %val3324
%val3326 = bitcast i8* %val3325 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val3326, {i64,i8*,i8*}** %hook_s_29Ptr
%val3328 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_29Ptr
%val3329 = icmp eq {i64,i8*,i8*}* %val3328, null
br i1 %val3329, label %then3327, label %else3327

then3327:
%res3330 = call ccc i1 @impc_false()
store i1 %res3330, i1* %ifptr3327
br label %ifcont3327

else3327:
%res3331 = call ccc i1 @impc_true()
store i1 %res3331, i1* %ifptr3327
br label %ifcont3327

ifcont3327:
%ifres3332 = load i1, i1* %ifptr3327

br i1 %ifres3332, label %loop3302, label %after3302

after3302:
%val3334 = load %mzone*, %mzone** %zone7Ptr
call ccc void @llvm_zone_destroy(%mzone* %val3334)
%val3336 = load %String*, %String** %rescopy7Ptr
ret %String* %val3336
}
@gsxtmnanovg146 = hidden constant [97 x i8] c"toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}** @toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3358 = load i8*, i8** %_impzPtr
%zone3359 = bitcast i8* %tzone3358 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd
%dat_toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd = call i8* @llvm_zone_malloc(%mzone* %zone3359, i64 8)
%toString_adhoc_W1N0cmluZyosTlZHc2Npc3NvcipdPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd to { i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}***
%tzone3339 = load i8*, i8** %_impzPtr
%zone3340 = bitcast i8* %tzone3339 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3340)
; malloc closure structure
%clsptr3341 = call i8* @llvm_zone_malloc(%mzone* %zone3340, i64 24)
%closure3342 = bitcast i8* %clsptr3341 to { i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}*

; malloc environment structure
%envptr3343 = call i8* @llvm_zone_malloc(%mzone* %zone3340, i64 8)
%environment3344 = bitcast i8* %envptr3343 to {{i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}***}*

; malloc closure address table
%addytable3345 = call %clsvar* @new_address_table()
%var3346 = bitcast [44 x i8]* @gsxtmnanovg144 to i8*
%var3347 = bitcast [49 x i8]* @gsxtmnanovg145 to i8*
%addytable3348 = call %clsvar* @add_address_table(%mzone* %zone3340, i8* %var3346, i32 0, i8* %var3347, i32 3, %clsvar* %addytable3345)
%address-table3349 = bitcast %clsvar* %addytable3348 to i8*

; insert table, function and environment into closure struct
%closure.table3352 = getelementptr { i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}, { i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}* %closure3342, i32 0, i32 0
store i8* %address-table3349, i8** %closure.table3352
%closure.env3353 = getelementptr { i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}, { i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}* %closure3342, i32 0, i32 1
store i8* %envptr3343, i8** %closure.env3353
%closure.func3354 = getelementptr { i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}, { i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}* %closure3342, i32 0, i32 2
store %String* (i8*, i8*, %NVGscissor*)* @toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd__3158, %String* (i8*, i8*, %NVGscissor*)** %closure.func3354
%closure_size3355 = call i64 @llvm_zone_mark_size(%mzone* %zone3340)
call void @llvm_zone_ptr_set_size(i8* %clsptr3341, i64 %closure_size3355)
%wrapper_ptr3356 = call i8* @llvm_zone_malloc(%mzone* %zone3340, i64 8)
%closure_wrapper3357 = bitcast i8* %wrapper_ptr3356 to { i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}**
store { i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}* %closure3342, { i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}** %closure_wrapper3357

; let value assignment
%toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd = select i1 true, { i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}** %closure_wrapper3357, { i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}** %closure_wrapper3357
store { i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}** %toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd, { i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}*** %toString_adhoc_W1N0cmluZyosTlZHc2Npc3NvcipdPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd
%tmp_envptr3351 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}***}* %environment3344, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}*** %toString_adhoc_W1N0cmluZyosTlZHc2Npc3NvcipdPtr, {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}**** %tmp_envptr3351


%val3360 = load {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}**, {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}*** %toString_adhoc_W1N0cmluZyosTlZHc2Npc3NvcipdPtr
ret {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}** %val3360
}


@toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}** @toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd(%NVGscissor* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGscissor*)*,  %String* (i8*, i8*, %NVGscissor*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGscissor* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd_native(%NVGscissor* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGscissor*)*,  %String* (i8*, i8*, %NVGscissor*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGscissor* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3361 = bitcast [97 x i8]* @gsxtmnanovg146 to i8*
call i32 (i8*, ...) @printf(i8* %var3361)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGscissor*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGscissor*)*,  %String* (i8*, i8*, %NVGscissor*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGscissor* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGscissor*}*
%arg_p_0 = getelementptr {%NVGscissor*}, {%NVGscissor*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGscissor*, %NVGscissor** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHc2Npc3Nvcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGscissor*)*,  %String* (i8*, i8*, %NVGscissor*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGscissor* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg147 = hidden constant [37 x i8] c"print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd\00"
@gsxtmnanovg148 = hidden constant [45 x i8] c"{i8*, i8*, void (i8*, i8*, %NVGscissor*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd__3362(i8* %_impz,i8* %_impenv, %NVGscissor* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3363 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %NVGscissor*)*}***}*
%print_adhoc_W3ZvaWQsTlZHc2Npc3NvcipdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGscissor*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGscissor*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsTlZHc2Npc3NvcipdPtr = load {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}***, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}**** %print_adhoc_W3ZvaWQsTlZHc2Npc3NvcipdPtr_

; setup arguments
%xPtr = alloca %NVGscissor*
store %NVGscissor* %x, %NVGscissor** %xPtr


%val3365 = load %NVGscissor*, %NVGscissor** %xPtr
%val3366 = icmp eq %NVGscissor* %val3365, null
br i1 %val3366, label %then3364, label %else3364

then3364:
%var3367 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var3368 = bitcast [18 x i8]* @gsxtmnanovg142 to i8*

%val3369 = call i32 (i8*, ...) @printf(i8* %var3367, i8* %var3368)
br label %ifcont3364

else3364:
%var3371 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var3372 = bitcast [13 x i8]* @gsxtmnanovg143 to i8*

%val3373 = call i32 (i8*, ...) @printf(i8* %var3371, i8* %var3372)
%val3374 = load %NVGscissor*, %NVGscissor** %xPtr
; tuple ref
%val3375 = getelementptr %NVGscissor, %NVGscissor* %val3374, i64 0, i32 0
%val3376 = load float, float* %val3375
call fastcc void @print_adhoc_W3ZvaWQsZmxvYXRd(float %val3376)
%var3378 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var3379 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val3380 = call i32 (i8*, ...) @printf(i8* %var3378, i8* %var3379)
%val3381 = load %NVGscissor*, %NVGscissor** %xPtr
; tuple ref
%val3382 = getelementptr %NVGscissor, %NVGscissor* %val3381, i64 0, i32 1
%val3383 = load float, float* %val3382
call fastcc void @print_adhoc_W3ZvaWQsZmxvYXRd(float %val3383)
%var3385 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var3386 = bitcast [2 x i8]* @gsxtmnanovg65 to i8*

%val3387 = call i32 (i8*, ...) @printf(i8* %var3385, i8* %var3386)
br label %ifcont3364

ifcont3364:
ret void
}
@gsxtmnanovg149 = hidden constant [90 x i8] c"print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** @print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3409 = load i8*, i8** %_impzPtr
%zone3410 = bitcast i8* %tzone3409 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd
%dat_print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd = call i8* @llvm_zone_malloc(%mzone* %zone3410, i64 8)
%print_adhoc_W3ZvaWQsTlZHc2Npc3NvcipdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd to { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}***
%tzone3390 = load i8*, i8** %_impzPtr
%zone3391 = bitcast i8* %tzone3390 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3391)
; malloc closure structure
%clsptr3392 = call i8* @llvm_zone_malloc(%mzone* %zone3391, i64 24)
%closure3393 = bitcast i8* %clsptr3392 to { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}*

; malloc environment structure
%envptr3394 = call i8* @llvm_zone_malloc(%mzone* %zone3391, i64 8)
%environment3395 = bitcast i8* %envptr3394 to {{i8*, i8*, void (i8*, i8*, %NVGscissor*)*}***}*

; malloc closure address table
%addytable3396 = call %clsvar* @new_address_table()
%var3397 = bitcast [37 x i8]* @gsxtmnanovg147 to i8*
%var3398 = bitcast [45 x i8]* @gsxtmnanovg148 to i8*
%addytable3399 = call %clsvar* @add_address_table(%mzone* %zone3391, i8* %var3397, i32 0, i8* %var3398, i32 3, %clsvar* %addytable3396)
%address-table3400 = bitcast %clsvar* %addytable3399 to i8*

; insert table, function and environment into closure struct
%closure.table3403 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure3393, i32 0, i32 0
store i8* %address-table3400, i8** %closure.table3403
%closure.env3404 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure3393, i32 0, i32 1
store i8* %envptr3394, i8** %closure.env3404
%closure.func3405 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure3393, i32 0, i32 2
store void (i8*, i8*, %NVGscissor*)* @print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd__3362, void (i8*, i8*, %NVGscissor*)** %closure.func3405
%closure_size3406 = call i64 @llvm_zone_mark_size(%mzone* %zone3391)
call void @llvm_zone_ptr_set_size(i8* %clsptr3392, i64 %closure_size3406)
%wrapper_ptr3407 = call i8* @llvm_zone_malloc(%mzone* %zone3391, i64 8)
%closure_wrapper3408 = bitcast i8* %wrapper_ptr3407 to { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}**
store { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure3393, { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** %closure_wrapper3408

; let value assignment
%print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd = select i1 true, { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** %closure_wrapper3408, { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** %closure_wrapper3408
store { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** %print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd, { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}*** %print_adhoc_W3ZvaWQsTlZHc2Npc3NvcipdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd
%tmp_envptr3402 = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGscissor*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGscissor*)*}***}* %environment3395, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}*** %print_adhoc_W3ZvaWQsTlZHc2Npc3NvcipdPtr, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}**** %tmp_envptr3402


%val3411 = load {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}**, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}*** %print_adhoc_W3ZvaWQsTlZHc2Npc3NvcipdPtr
ret {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** %val3411
}


@print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** @print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd(%NVGscissor* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}*, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGscissor*)*,  void (i8*, i8*, %NVGscissor*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGscissor* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_native(%NVGscissor* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}*, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGscissor*)*,  void (i8*, i8*, %NVGscissor*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGscissor* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3412 = bitcast [90 x i8]* @gsxtmnanovg149 to i8*
call i32 (i8*, ...) @printf(i8* %var3412)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGscissor*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}*, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGscissor*)*,  void (i8*, i8*, %NVGscissor*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGscissor* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGscissor*}*
%arg_p_0 = getelementptr {%NVGscissor*}, {%NVGscissor*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGscissor*, %NVGscissor** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}*, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGscissor*)*,  void (i8*, i8*, %NVGscissor*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGscissor* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg150 = hidden constant [54 x i8] c"NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd\00"
@gsxtmnanovg151 = hidden constant [52 x i8] c"{i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}**\00"
define dllexport fastcc %NVGscissor @NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd__3413(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3414 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}***}*
%NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}***}, {{i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}***}* %impenv, i32 0, i32 0
%NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRdPtr = load {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}***, {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}**** %NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRdPtr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr


%tzone3416 = load i8*, i8** %_impzPtr
%zone3417 = bitcast i8* %tzone3416 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGscissor*
%dat3415 = alloca %NVGscissor, align 16

; let value assignment
%obj = select i1 true, %NVGscissor* %dat3415, %NVGscissor* %dat3415
store %NVGscissor* %obj, %NVGscissor** %objPtr

%val3418 = load %NVGscissor*, %NVGscissor** %objPtr
%val3419 = load float, float* %arg_0Ptr
; set tuple
%val3420 = getelementptr %NVGscissor, %NVGscissor* %val3418, i64 0, i32 0
store float %val3419, float* %val3420
%val3421 = load %NVGscissor*, %NVGscissor** %objPtr
%val3422 = load float, float* %arg_1Ptr
; set tuple
%val3423 = getelementptr %NVGscissor, %NVGscissor* %val3421, i64 0, i32 1
store float %val3422, float* %val3423
%val3424 = load %NVGscissor*, %NVGscissor** %objPtr
; pointer ref
%val3425 = getelementptr %NVGscissor, %NVGscissor* %val3424, i64 0
%val3426 = load %NVGscissor, %NVGscissor* %val3425
ret %NVGscissor %val3426
}
@gsxtmnanovg152 = hidden constant [107 x i8] c"NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}** @NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3446 = load i8*, i8** %_impzPtr
%zone3447 = bitcast i8* %tzone3446 to %mzone*

; let assign value to symbol NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd
%dat_NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone3447, i64 8)
%NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRdPtr = bitcast i8* %dat_NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd to { i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}***
%tzone3427 = load i8*, i8** %_impzPtr
%zone3428 = bitcast i8* %tzone3427 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3428)
; malloc closure structure
%clsptr3429 = call i8* @llvm_zone_malloc(%mzone* %zone3428, i64 24)
%closure3430 = bitcast i8* %clsptr3429 to { i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}*

; malloc environment structure
%envptr3431 = call i8* @llvm_zone_malloc(%mzone* %zone3428, i64 8)
%environment3432 = bitcast i8* %envptr3431 to {{i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}***}*

; malloc closure address table
%addytable3433 = call %clsvar* @new_address_table()
%var3434 = bitcast [54 x i8]* @gsxtmnanovg150 to i8*
%var3435 = bitcast [52 x i8]* @gsxtmnanovg151 to i8*
%addytable3436 = call %clsvar* @add_address_table(%mzone* %zone3428, i8* %var3434, i32 0, i8* %var3435, i32 3, %clsvar* %addytable3433)
%address-table3437 = bitcast %clsvar* %addytable3436 to i8*

; insert table, function and environment into closure struct
%closure.table3440 = getelementptr { i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}, { i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}* %closure3430, i32 0, i32 0
store i8* %address-table3437, i8** %closure.table3440
%closure.env3441 = getelementptr { i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}, { i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}* %closure3430, i32 0, i32 1
store i8* %envptr3431, i8** %closure.env3441
%closure.func3442 = getelementptr { i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}, { i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}* %closure3430, i32 0, i32 2
store %NVGscissor (i8*, i8*, float, float)* @NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd__3413, %NVGscissor (i8*, i8*, float, float)** %closure.func3442
%closure_size3443 = call i64 @llvm_zone_mark_size(%mzone* %zone3428)
call void @llvm_zone_ptr_set_size(i8* %clsptr3429, i64 %closure_size3443)
%wrapper_ptr3444 = call i8* @llvm_zone_malloc(%mzone* %zone3428, i64 8)
%closure_wrapper3445 = bitcast i8* %wrapper_ptr3444 to { i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}**
store { i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}* %closure3430, { i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}** %closure_wrapper3445

; let value assignment
%NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd = select i1 true, { i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}** %closure_wrapper3445, { i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}** %closure_wrapper3445
store { i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}** %NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd, { i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}*** %NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd
%tmp_envptr3439 = getelementptr {{i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}***}, {{i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}***}* %environment3432, i32 0, i32 0
store {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}*** %NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRdPtr, {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}**** %tmp_envptr3439


%val3448 = load {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}**, {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}*** %NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRdPtr
ret {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}** %val3448
}


@NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}** @NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGscissor @NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}*, {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor (i8*, i8*, float, float)*,  %NVGscissor (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %NVGscissor %result
}


define dllexport ccc %NVGscissor @NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd_native(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}*, {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor (i8*, i8*, float, float)*,  %NVGscissor (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret %NVGscissor %result
}


define dllexport ccc void @NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float}*
%arg_p_0 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGscissor_val_adhoc_W05WR3NjaXNzb3IsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}*, {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}, {i8*, i8*, %NVGscissor (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor (i8*, i8*, float, float)*,  %NVGscissor (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg153 = hidden constant [47 x i8] c"hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ\00"
@gsxtmnanovg154 = hidden constant [53 x i8] c"{i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}**\00"
define dllexport fastcc %NVGscissor* @hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ__3451(i8* %_impz,i8* %_impenv, %NVGscissor* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3452 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}***}*
%hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQPtr_ = getelementptr {{i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}***}, {{i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQPtr = load {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}***, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}**** %hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQPtr_

; setup arguments
%xPtr = alloca %NVGscissor*
store %NVGscissor* %x, %NVGscissor** %xPtr


%tzone3455 = load i8*, i8** %_impzPtr
%zone3456 = bitcast i8* %tzone3455 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGscissor*
%dat3453 = call i8* @malloc(i64 8)
call i8* @memset(i8* %dat3453, i32 0, i64 8)
%val3454 = bitcast i8* %dat3453 to %NVGscissor*

; let value assignment
%obj = select i1 true, %NVGscissor* %val3454, %NVGscissor* %val3454
store %NVGscissor* %obj, %NVGscissor** %objPtr

%val3457 = load %NVGscissor*, %NVGscissor** %objPtr
%val3458 = load %NVGscissor*, %NVGscissor** %xPtr
; tuple ref
%val3459 = getelementptr %NVGscissor, %NVGscissor* %val3458, i64 0, i32 0
%val3460 = load float, float* %val3459
; set tuple
%val3461 = getelementptr %NVGscissor, %NVGscissor* %val3457, i64 0, i32 0
store float %val3460, float* %val3461
%val3462 = load %NVGscissor*, %NVGscissor** %objPtr
%val3463 = load %NVGscissor*, %NVGscissor** %xPtr
; tuple ref
%val3464 = getelementptr %NVGscissor, %NVGscissor* %val3463, i64 0, i32 1
%val3465 = load float, float* %val3464
; set tuple
%val3466 = getelementptr %NVGscissor, %NVGscissor* %val3462, i64 0, i32 1
store float %val3465, float* %val3466
%val3467 = load %NVGscissor*, %NVGscissor** %objPtr
ret %NVGscissor* %val3467
}
@gsxtmnanovg155 = hidden constant [100 x i8] c"hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}** @hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3487 = load i8*, i8** %_impzPtr
%zone3488 = bitcast i8* %tzone3487 to %mzone*

; let assign value to symbol hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ
%dat_hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3488, i64 8)
%hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQPtr = bitcast i8* %dat_hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ to { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}***
%tzone3468 = load i8*, i8** %_impzPtr
%zone3469 = bitcast i8* %tzone3468 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3469)
; malloc closure structure
%clsptr3470 = call i8* @llvm_zone_malloc(%mzone* %zone3469, i64 24)
%closure3471 = bitcast i8* %clsptr3470 to { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}*

; malloc environment structure
%envptr3472 = call i8* @llvm_zone_malloc(%mzone* %zone3469, i64 8)
%environment3473 = bitcast i8* %envptr3472 to {{i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}***}*

; malloc closure address table
%addytable3474 = call %clsvar* @new_address_table()
%var3475 = bitcast [47 x i8]* @gsxtmnanovg153 to i8*
%var3476 = bitcast [53 x i8]* @gsxtmnanovg154 to i8*
%addytable3477 = call %clsvar* @add_address_table(%mzone* %zone3469, i8* %var3475, i32 0, i8* %var3476, i32 3, %clsvar* %addytable3474)
%address-table3478 = bitcast %clsvar* %addytable3477 to i8*

; insert table, function and environment into closure struct
%closure.table3481 = getelementptr { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}, { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}* %closure3471, i32 0, i32 0
store i8* %address-table3478, i8** %closure.table3481
%closure.env3482 = getelementptr { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}, { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}* %closure3471, i32 0, i32 1
store i8* %envptr3472, i8** %closure.env3482
%closure.func3483 = getelementptr { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}, { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}* %closure3471, i32 0, i32 2
store %NVGscissor* (i8*, i8*, %NVGscissor*)* @hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ__3451, %NVGscissor* (i8*, i8*, %NVGscissor*)** %closure.func3483
%closure_size3484 = call i64 @llvm_zone_mark_size(%mzone* %zone3469)
call void @llvm_zone_ptr_set_size(i8* %clsptr3470, i64 %closure_size3484)
%wrapper_ptr3485 = call i8* @llvm_zone_malloc(%mzone* %zone3469, i64 8)
%closure_wrapper3486 = bitcast i8* %wrapper_ptr3485 to { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}**
store { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}* %closure3471, { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}** %closure_wrapper3486

; let value assignment
%hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ = select i1 true, { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}** %closure_wrapper3486, { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}** %closure_wrapper3486
store { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}** %hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ, { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}*** %hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ
%tmp_envptr3480 = getelementptr {{i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}***}, {{i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}***}* %environment3473, i32 0, i32 0
store {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}*** %hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQPtr, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}**** %tmp_envptr3480


%val3489 = load {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}**, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}*** %hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQPtr
ret {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}** %val3489
}


@hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}** @hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGscissor* @hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ(%NVGscissor* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}**
%closure = load {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}*, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor* (i8*, i8*, %NVGscissor*)*,  %NVGscissor* (i8*, i8*, %NVGscissor*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor* %ff(i8* %_impz, i8* %ee, %NVGscissor* %arg_0)
ret %NVGscissor* %result
}


define dllexport ccc %NVGscissor* @hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ_native(%NVGscissor* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}**
%closure = load {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}*, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor* (i8*, i8*, %NVGscissor*)*,  %NVGscissor* (i8*, i8*, %NVGscissor*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor* %ff(i8* %_impz, i8* %ee, %NVGscissor* %arg_0)
ret %NVGscissor* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3490 = bitcast [100 x i8]* @gsxtmnanovg155 to i8*
call i32 (i8*, ...) @printf(i8* %var3490)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGscissor*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}**
%closure = load {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}*, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor* (i8*, i8*, %NVGscissor*)*,  %NVGscissor* (i8*, i8*, %NVGscissor*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor* %ff(i8* %_impz, i8* %ee, %NVGscissor* %arg_0)
%tmpres = bitcast %NVGscissor* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGscissor*}*
%arg_p_0 = getelementptr {%NVGscissor*}, {%NVGscissor*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGscissor*, %NVGscissor** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}**
%closure = load {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}*, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor* (i8*, i8*, %NVGscissor*)*,  %NVGscissor* (i8*, i8*, %NVGscissor*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor* %ff(i8* %_impz, i8* %ee, %NVGscissor* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg156 = hidden constant [37 x i8] c"hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd__3491(i8* %_impz,i8* %_impenv, %NVGscissor* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3492 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %NVGscissor*)*}***}*
%hfree_adhoc_W3ZvaWQsTlZHc2Npc3NvcipdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGscissor*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGscissor*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsTlZHc2Npc3NvcipdPtr = load {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}***, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}**** %hfree_adhoc_W3ZvaWQsTlZHc2Npc3NvcipdPtr_

; setup arguments
%xPtr = alloca %NVGscissor*
store %NVGscissor* %x, %NVGscissor** %xPtr


%val3493 = load %NVGscissor*, %NVGscissor** %xPtr
%val3494 = bitcast %NVGscissor* %val3493 to i8*
call ccc void @free(i8* %val3494)
ret void
}
@gsxtmnanovg157 = hidden constant [90 x i8] c"hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** @hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3516 = load i8*, i8** %_impzPtr
%zone3517 = bitcast i8* %tzone3516 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd
%dat_hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd = call i8* @llvm_zone_malloc(%mzone* %zone3517, i64 8)
%hfree_adhoc_W3ZvaWQsTlZHc2Npc3NvcipdPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd to { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}***
%tzone3497 = load i8*, i8** %_impzPtr
%zone3498 = bitcast i8* %tzone3497 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3498)
; malloc closure structure
%clsptr3499 = call i8* @llvm_zone_malloc(%mzone* %zone3498, i64 24)
%closure3500 = bitcast i8* %clsptr3499 to { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}*

; malloc environment structure
%envptr3501 = call i8* @llvm_zone_malloc(%mzone* %zone3498, i64 8)
%environment3502 = bitcast i8* %envptr3501 to {{i8*, i8*, void (i8*, i8*, %NVGscissor*)*}***}*

; malloc closure address table
%addytable3503 = call %clsvar* @new_address_table()
%var3504 = bitcast [37 x i8]* @gsxtmnanovg156 to i8*
%var3505 = bitcast [45 x i8]* @gsxtmnanovg148 to i8*
%addytable3506 = call %clsvar* @add_address_table(%mzone* %zone3498, i8* %var3504, i32 0, i8* %var3505, i32 3, %clsvar* %addytable3503)
%address-table3507 = bitcast %clsvar* %addytable3506 to i8*

; insert table, function and environment into closure struct
%closure.table3510 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure3500, i32 0, i32 0
store i8* %address-table3507, i8** %closure.table3510
%closure.env3511 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure3500, i32 0, i32 1
store i8* %envptr3501, i8** %closure.env3511
%closure.func3512 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure3500, i32 0, i32 2
store void (i8*, i8*, %NVGscissor*)* @hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd__3491, void (i8*, i8*, %NVGscissor*)** %closure.func3512
%closure_size3513 = call i64 @llvm_zone_mark_size(%mzone* %zone3498)
call void @llvm_zone_ptr_set_size(i8* %clsptr3499, i64 %closure_size3513)
%wrapper_ptr3514 = call i8* @llvm_zone_malloc(%mzone* %zone3498, i64 8)
%closure_wrapper3515 = bitcast i8* %wrapper_ptr3514 to { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}**
store { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure3500, { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** %closure_wrapper3515

; let value assignment
%hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd = select i1 true, { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** %closure_wrapper3515, { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** %closure_wrapper3515
store { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** %hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd, { i8*, i8*, void (i8*, i8*, %NVGscissor*)*}*** %hfree_adhoc_W3ZvaWQsTlZHc2Npc3NvcipdPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd
%tmp_envptr3509 = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGscissor*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGscissor*)*}***}* %environment3502, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}*** %hfree_adhoc_W3ZvaWQsTlZHc2Npc3NvcipdPtr, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}**** %tmp_envptr3509


%val3518 = load {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}**, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}*** %hfree_adhoc_W3ZvaWQsTlZHc2Npc3NvcipdPtr
ret {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** %val3518
}


@hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** @hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd(%NVGscissor* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}*, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGscissor*)*,  void (i8*, i8*, %NVGscissor*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGscissor* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_native(%NVGscissor* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}*, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGscissor*)*,  void (i8*, i8*, %NVGscissor*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGscissor* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3519 = bitcast [90 x i8]* @gsxtmnanovg157 to i8*
call i32 (i8*, ...) @printf(i8* %var3519)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGscissor*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}*, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGscissor*)*,  void (i8*, i8*, %NVGscissor*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGscissor* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGscissor*}*
%arg_p_0 = getelementptr {%NVGscissor*}, {%NVGscissor*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGscissor*, %NVGscissor** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHc2Npc3Nvcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}*, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}, {i8*, i8*, void (i8*, i8*, %NVGscissor*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGscissor*)*,  void (i8*, i8*, %NVGscissor*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGscissor* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg158 = hidden constant [65 x i8] c"zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd\00"
@gsxtmnanovg159 = hidden constant [71 x i8] c"{i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %NVGscissor* @zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd__3520(i8* %_impz,i8* %_impenv, %NVGscissor* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3521 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpdPtr = load {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}***, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpdPtr_

; setup arguments
%xPtr = alloca %NVGscissor*
store %NVGscissor* %x, %NVGscissor** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val3523 = load %mzone*, %mzone** %fromzPtr
%val3524 = load %NVGscissor*, %NVGscissor** %xPtr
%val3525 = bitcast %NVGscissor* %val3524 to i8*
%res3526 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val3523, i8* %val3525)
br i1 %res3526, label %then3522, label %else3522

then3522:
%val3527 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val3527)
%zone_ptr3528 = bitcast %mzone* %val3527 to i8*
store i8* %zone_ptr3528, i8** %_impzPtr
%tzone3534 = load i8*, i8** %_impzPtr
%zone3535 = bitcast i8* %tzone3534 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGscissor*
%tzone3530 = load i8*, i8** %_impzPtr
%zone3531 = bitcast i8* %tzone3530 to %mzone*
%dat3532 = call i8* @llvm_zone_malloc(%mzone* %zone3531, i64 8)
call i8* @memset(i8* %dat3532, i32 0, i64 8)
%val3533 = bitcast i8* %dat3532 to %NVGscissor*

; let value assignment
%obj = select i1 true, %NVGscissor* %val3533, %NVGscissor* %val3533
store %NVGscissor* %obj, %NVGscissor** %objPtr

%val3536 = load %NVGscissor*, %NVGscissor** %objPtr
%val3537 = load %NVGscissor*, %NVGscissor** %xPtr
; tuple ref
%val3538 = getelementptr %NVGscissor, %NVGscissor* %val3537, i64 0, i32 0
%val3539 = load float, float* %val3538
; set tuple
%val3540 = getelementptr %NVGscissor, %NVGscissor* %val3536, i64 0, i32 0
store float %val3539, float* %val3540
%val3541 = load %NVGscissor*, %NVGscissor** %objPtr
%val3542 = load %NVGscissor*, %NVGscissor** %xPtr
; tuple ref
%val3543 = getelementptr %NVGscissor, %NVGscissor* %val3542, i64 0, i32 1
%val3544 = load float, float* %val3543
; set tuple
%val3545 = getelementptr %NVGscissor, %NVGscissor* %val3541, i64 0, i32 1
store float %val3544, float* %val3545
%oldzone3546 = call %mzone* @llvm_pop_zone_stack()
%newzone3547 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr3548 = bitcast %mzone* %newzone3547 to i8*
store i8* %zone_ptr3548, i8** %_impzPtr
%val3549 = load %NVGscissor*, %NVGscissor** %objPtr
ret %NVGscissor* %val3549

else3522:
%val3550 = load %NVGscissor*, %NVGscissor** %xPtr
ret %NVGscissor* %val3550
}
@gsxtmnanovg160 = hidden constant [118 x i8] c"zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}** @zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3570 = load i8*, i8** %_impzPtr
%zone3571 = bitcast i8* %tzone3570 to %mzone*

; let assign value to symbol zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd
%dat_zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone3571, i64 8)
%zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpdPtr = bitcast i8* %dat_zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd to { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}***
%tzone3551 = load i8*, i8** %_impzPtr
%zone3552 = bitcast i8* %tzone3551 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3552)
; malloc closure structure
%clsptr3553 = call i8* @llvm_zone_malloc(%mzone* %zone3552, i64 24)
%closure3554 = bitcast i8* %clsptr3553 to { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr3555 = call i8* @llvm_zone_malloc(%mzone* %zone3552, i64 8)
%environment3556 = bitcast i8* %envptr3555 to {{i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable3557 = call %clsvar* @new_address_table()
%var3558 = bitcast [65 x i8]* @gsxtmnanovg158 to i8*
%var3559 = bitcast [71 x i8]* @gsxtmnanovg159 to i8*
%addytable3560 = call %clsvar* @add_address_table(%mzone* %zone3552, i8* %var3558, i32 0, i8* %var3559, i32 3, %clsvar* %addytable3557)
%address-table3561 = bitcast %clsvar* %addytable3560 to i8*

; insert table, function and environment into closure struct
%closure.table3564 = getelementptr { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}* %closure3554, i32 0, i32 0
store i8* %address-table3561, i8** %closure.table3564
%closure.env3565 = getelementptr { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}* %closure3554, i32 0, i32 1
store i8* %envptr3555, i8** %closure.env3565
%closure.func3566 = getelementptr { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}* %closure3554, i32 0, i32 2
store %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)* @zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd__3520, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)** %closure.func3566
%closure_size3567 = call i64 @llvm_zone_mark_size(%mzone* %zone3552)
call void @llvm_zone_ptr_set_size(i8* %clsptr3553, i64 %closure_size3567)
%wrapper_ptr3568 = call i8* @llvm_zone_malloc(%mzone* %zone3552, i64 8)
%closure_wrapper3569 = bitcast i8* %wrapper_ptr3568 to { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}**
store { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}* %closure3554, { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}** %closure_wrapper3569

; let value assignment
%zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd = select i1 true, { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}** %closure_wrapper3569, { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}** %closure_wrapper3569
store { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}** %zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd, { i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd
%tmp_envptr3563 = getelementptr {{i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}***}* %environment3556, i32 0, i32 0
store {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpdPtr, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}**** %tmp_envptr3563


%val3572 = load {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}**, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpdPtr
ret {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}** %val3572
}


@zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}** @zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGscissor* @zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd(%NVGscissor* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*,  %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor* %ff(i8* %_impz, i8* %ee, %NVGscissor* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %NVGscissor* %result
}


define dllexport ccc %NVGscissor* @zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd_native(%NVGscissor* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*,  %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor* %ff(i8* %_impz, i8* %ee, %NVGscissor* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %NVGscissor* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3573 = bitcast [118 x i8]* @gsxtmnanovg160 to i8*
call i32 (i8*, ...) @printf(i8* %var3573)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGscissor*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3574 = bitcast [118 x i8]* @gsxtmnanovg160 to i8*
call i32 (i8*, ...) @printf(i8* %var3574)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3575 = bitcast [118 x i8]* @gsxtmnanovg160 to i8*
call i32 (i8*, ...) @printf(i8* %var3575)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*,  %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor* %ff(i8* %_impz, i8* %ee, %NVGscissor* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %NVGscissor* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGscissor*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%NVGscissor*, %mzone*, %mzone*}, {%NVGscissor*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGscissor*, %NVGscissor** %arg_p_0
%arg_p_1 = getelementptr {%NVGscissor*, %mzone*, %mzone*}, {%NVGscissor*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%NVGscissor*, %mzone*, %mzone*}, {%NVGscissor*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3NjaXNzb3IqLE5WR3NjaXNzb3IqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)*,  %NVGscissor* (i8*, i8*, %NVGscissor*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGscissor* %ff(i8* %_impz, i8* %ee, %NVGscissor* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%NVGvertex = type {float,float,float,float}
@gsxtmnanovg161 = hidden constant [65 x i8] c"NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd\00"
@gsxtmnanovg162 = hidden constant [66 x i8] c"{i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**\00"
define dllexport fastcc %NVGvertex* @NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd__3576(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1, float %arg_2, float %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3577 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***}*
%NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = load {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**** %NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr
%arg_2Ptr = alloca float
store float %arg_2, float* %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr


%tzone3582 = load i8*, i8** %_impzPtr
%zone3583 = bitcast i8* %tzone3582 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGvertex*
%tzone3578 = load i8*, i8** %_impzPtr
%zone3579 = bitcast i8* %tzone3578 to %mzone*
%dat3580 = call i8* @llvm_zone_malloc(%mzone* %zone3579, i64 16)
call i8* @memset(i8* %dat3580, i32 0, i64 16)
%val3581 = bitcast i8* %dat3580 to %NVGvertex*

; let value assignment
%obj = select i1 true, %NVGvertex* %val3581, %NVGvertex* %val3581
store %NVGvertex* %obj, %NVGvertex** %objPtr

%val3584 = load %NVGvertex*, %NVGvertex** %objPtr
%val3585 = load float, float* %arg_0Ptr
; set tuple
%val3586 = getelementptr %NVGvertex, %NVGvertex* %val3584, i64 0, i32 0
store float %val3585, float* %val3586
%val3587 = load %NVGvertex*, %NVGvertex** %objPtr
%val3588 = load float, float* %arg_1Ptr
; set tuple
%val3589 = getelementptr %NVGvertex, %NVGvertex* %val3587, i64 0, i32 1
store float %val3588, float* %val3589
%val3590 = load %NVGvertex*, %NVGvertex** %objPtr
%val3591 = load float, float* %arg_2Ptr
; set tuple
%val3592 = getelementptr %NVGvertex, %NVGvertex* %val3590, i64 0, i32 2
store float %val3591, float* %val3592
%val3593 = load %NVGvertex*, %NVGvertex** %objPtr
%val3594 = load float, float* %arg_3Ptr
; set tuple
%val3595 = getelementptr %NVGvertex, %NVGvertex* %val3593, i64 0, i32 3
store float %val3594, float* %val3595
%val3596 = load %NVGvertex*, %NVGvertex** %objPtr
ret %NVGvertex* %val3596
}
@gsxtmnanovg163 = hidden constant [118 x i8] c"NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** @NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3616 = load i8*, i8** %_impzPtr
%zone3617 = bitcast i8* %tzone3616 to %mzone*

; let assign value to symbol NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd
%dat_NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone3617, i64 8)
%NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = bitcast i8* %dat_NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd to { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***
%tzone3597 = load i8*, i8** %_impzPtr
%zone3598 = bitcast i8* %tzone3597 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3598)
; malloc closure structure
%clsptr3599 = call i8* @llvm_zone_malloc(%mzone* %zone3598, i64 24)
%closure3600 = bitcast i8* %clsptr3599 to { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*

; malloc environment structure
%envptr3601 = call i8* @llvm_zone_malloc(%mzone* %zone3598, i64 8)
%environment3602 = bitcast i8* %envptr3601 to {{i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***}*

; malloc closure address table
%addytable3603 = call %clsvar* @new_address_table()
%var3604 = bitcast [65 x i8]* @gsxtmnanovg161 to i8*
%var3605 = bitcast [66 x i8]* @gsxtmnanovg162 to i8*
%addytable3606 = call %clsvar* @add_address_table(%mzone* %zone3598, i8* %var3604, i32 0, i8* %var3605, i32 3, %clsvar* %addytable3603)
%address-table3607 = bitcast %clsvar* %addytable3606 to i8*

; insert table, function and environment into closure struct
%closure.table3610 = getelementptr { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure3600, i32 0, i32 0
store i8* %address-table3607, i8** %closure.table3610
%closure.env3611 = getelementptr { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure3600, i32 0, i32 1
store i8* %envptr3601, i8** %closure.env3611
%closure.func3612 = getelementptr { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure3600, i32 0, i32 2
store %NVGvertex* (i8*, i8*, float, float, float, float)* @NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd__3576, %NVGvertex* (i8*, i8*, float, float, float, float)** %closure.func3612
%closure_size3613 = call i64 @llvm_zone_mark_size(%mzone* %zone3598)
call void @llvm_zone_ptr_set_size(i8* %clsptr3599, i64 %closure_size3613)
%wrapper_ptr3614 = call i8* @llvm_zone_malloc(%mzone* %zone3598, i64 8)
%closure_wrapper3615 = bitcast i8* %wrapper_ptr3614 to { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**
store { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure3600, { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure_wrapper3615

; let value assignment
%NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd = select i1 true, { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure_wrapper3615, { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure_wrapper3615
store { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd, { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*** %NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd
%tmp_envptr3609 = getelementptr {{i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***}* %environment3602, i32 0, i32 0
store {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*** %NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**** %tmp_envptr3609


%val3618 = load {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*** %NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr
ret {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %val3618
}


@NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** @NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGvertex* @NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex* (i8*, i8*, float, float, float, float)*,  %NVGvertex* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGvertex* %result
}


define dllexport ccc %NVGvertex* @NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_native(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex* (i8*, i8*, float, float, float, float)*,  %NVGvertex* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGvertex* %result
}


define dllexport ccc i8*  @NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3619 = bitcast [118 x i8]* @gsxtmnanovg163 to i8*
call i32 (i8*, ...) @printf(i8* %var3619)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3620 = bitcast [118 x i8]* @gsxtmnanovg163 to i8*
call i32 (i8*, ...) @printf(i8* %var3620)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3621 = bitcast [118 x i8]* @gsxtmnanovg163 to i8*
call i32 (i8*, ...) @printf(i8* %var3621)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var3622 = bitcast [118 x i8]* @gsxtmnanovg163 to i8*
call i32 (i8*, ...) @printf(i8* %var3622)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex* (i8*, i8*, float, float, float, float)*,  %NVGvertex* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%tmpres = bitcast %NVGvertex* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float, float, float}*
%arg_p_0 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex* (i8*, i8*, float, float, float, float)*,  %NVGvertex* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg164 = hidden constant [67 x i8] c"NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd\00"
define dllexport fastcc %NVGvertex* @NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd__3623(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1, float %arg_2, float %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3624 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***}*
%NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = load {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**** %NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr
%arg_2Ptr = alloca float
store float %arg_2, float* %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr


%tzone3629 = load i8*, i8** %_impzPtr
%zone3630 = bitcast i8* %tzone3629 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGvertex*
%tzone3625 = load i8*, i8** %_impzPtr
%zone3626 = bitcast i8* %tzone3625 to %mzone*
%dat3627 = call i8* @llvm_zone_malloc(%mzone* %zone3626, i64 16)
call i8* @memset(i8* %dat3627, i32 0, i64 16)
%val3628 = bitcast i8* %dat3627 to %NVGvertex*

; let value assignment
%obj = select i1 true, %NVGvertex* %val3628, %NVGvertex* %val3628
store %NVGvertex* %obj, %NVGvertex** %objPtr

%val3631 = load %NVGvertex*, %NVGvertex** %objPtr
%val3632 = load float, float* %arg_0Ptr
; set tuple
%val3633 = getelementptr %NVGvertex, %NVGvertex* %val3631, i64 0, i32 0
store float %val3632, float* %val3633
%val3634 = load %NVGvertex*, %NVGvertex** %objPtr
%val3635 = load float, float* %arg_1Ptr
; set tuple
%val3636 = getelementptr %NVGvertex, %NVGvertex* %val3634, i64 0, i32 1
store float %val3635, float* %val3636
%val3637 = load %NVGvertex*, %NVGvertex** %objPtr
%val3638 = load float, float* %arg_2Ptr
; set tuple
%val3639 = getelementptr %NVGvertex, %NVGvertex* %val3637, i64 0, i32 2
store float %val3638, float* %val3639
%val3640 = load %NVGvertex*, %NVGvertex** %objPtr
%val3641 = load float, float* %arg_3Ptr
; set tuple
%val3642 = getelementptr %NVGvertex, %NVGvertex* %val3640, i64 0, i32 3
store float %val3641, float* %val3642
%val3643 = load %NVGvertex*, %NVGvertex** %objPtr
ret %NVGvertex* %val3643
}
@gsxtmnanovg165 = hidden constant [120 x i8] c"NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** @NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3663 = load i8*, i8** %_impzPtr
%zone3664 = bitcast i8* %tzone3663 to %mzone*

; let assign value to symbol NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd
%dat_NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone3664, i64 8)
%NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = bitcast i8* %dat_NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd to { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***
%tzone3644 = load i8*, i8** %_impzPtr
%zone3645 = bitcast i8* %tzone3644 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3645)
; malloc closure structure
%clsptr3646 = call i8* @llvm_zone_malloc(%mzone* %zone3645, i64 24)
%closure3647 = bitcast i8* %clsptr3646 to { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*

; malloc environment structure
%envptr3648 = call i8* @llvm_zone_malloc(%mzone* %zone3645, i64 8)
%environment3649 = bitcast i8* %envptr3648 to {{i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***}*

; malloc closure address table
%addytable3650 = call %clsvar* @new_address_table()
%var3651 = bitcast [67 x i8]* @gsxtmnanovg164 to i8*
%var3652 = bitcast [66 x i8]* @gsxtmnanovg162 to i8*
%addytable3653 = call %clsvar* @add_address_table(%mzone* %zone3645, i8* %var3651, i32 0, i8* %var3652, i32 3, %clsvar* %addytable3650)
%address-table3654 = bitcast %clsvar* %addytable3653 to i8*

; insert table, function and environment into closure struct
%closure.table3657 = getelementptr { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure3647, i32 0, i32 0
store i8* %address-table3654, i8** %closure.table3657
%closure.env3658 = getelementptr { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure3647, i32 0, i32 1
store i8* %envptr3648, i8** %closure.env3658
%closure.func3659 = getelementptr { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure3647, i32 0, i32 2
store %NVGvertex* (i8*, i8*, float, float, float, float)* @NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd__3623, %NVGvertex* (i8*, i8*, float, float, float, float)** %closure.func3659
%closure_size3660 = call i64 @llvm_zone_mark_size(%mzone* %zone3645)
call void @llvm_zone_ptr_set_size(i8* %clsptr3646, i64 %closure_size3660)
%wrapper_ptr3661 = call i8* @llvm_zone_malloc(%mzone* %zone3645, i64 8)
%closure_wrapper3662 = bitcast i8* %wrapper_ptr3661 to { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**
store { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure3647, { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure_wrapper3662

; let value assignment
%NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd = select i1 true, { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure_wrapper3662, { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure_wrapper3662
store { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd, { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*** %NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd
%tmp_envptr3656 = getelementptr {{i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***}* %environment3649, i32 0, i32 0
store {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*** %NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**** %tmp_envptr3656


%val3665 = load {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*** %NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr
ret {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %val3665
}


@NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** @NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGvertex* @NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex* (i8*, i8*, float, float, float, float)*,  %NVGvertex* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGvertex* %result
}


define dllexport ccc %NVGvertex* @NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_native(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex* (i8*, i8*, float, float, float, float)*,  %NVGvertex* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGvertex* %result
}


define dllexport ccc i8*  @NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3666 = bitcast [120 x i8]* @gsxtmnanovg165 to i8*
call i32 (i8*, ...) @printf(i8* %var3666)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3667 = bitcast [120 x i8]* @gsxtmnanovg165 to i8*
call i32 (i8*, ...) @printf(i8* %var3667)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3668 = bitcast [120 x i8]* @gsxtmnanovg165 to i8*
call i32 (i8*, ...) @printf(i8* %var3668)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var3669 = bitcast [120 x i8]* @gsxtmnanovg165 to i8*
call i32 (i8*, ...) @printf(i8* %var3669)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex* (i8*, i8*, float, float, float, float)*,  %NVGvertex* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%tmpres = bitcast %NVGvertex* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float, float, float}*
%arg_p_0 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_z_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex* (i8*, i8*, float, float, float, float)*,  %NVGvertex* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg166 = hidden constant [67 x i8] c"NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd\00"
define dllexport fastcc %NVGvertex* @NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd__3670(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1, float %arg_2, float %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3671 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***}*
%NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = load {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**** %NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr
%arg_2Ptr = alloca float
store float %arg_2, float* %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr


%tzone3674 = load i8*, i8** %_impzPtr
%zone3675 = bitcast i8* %tzone3674 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGvertex*
%dat3672 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat3672, i32 0, i64 16)
%val3673 = bitcast i8* %dat3672 to %NVGvertex*

; let value assignment
%obj = select i1 true, %NVGvertex* %val3673, %NVGvertex* %val3673
store %NVGvertex* %obj, %NVGvertex** %objPtr

%val3676 = load %NVGvertex*, %NVGvertex** %objPtr
%val3677 = load float, float* %arg_0Ptr
; set tuple
%val3678 = getelementptr %NVGvertex, %NVGvertex* %val3676, i64 0, i32 0
store float %val3677, float* %val3678
%val3679 = load %NVGvertex*, %NVGvertex** %objPtr
%val3680 = load float, float* %arg_1Ptr
; set tuple
%val3681 = getelementptr %NVGvertex, %NVGvertex* %val3679, i64 0, i32 1
store float %val3680, float* %val3681
%val3682 = load %NVGvertex*, %NVGvertex** %objPtr
%val3683 = load float, float* %arg_2Ptr
; set tuple
%val3684 = getelementptr %NVGvertex, %NVGvertex* %val3682, i64 0, i32 2
store float %val3683, float* %val3684
%val3685 = load %NVGvertex*, %NVGvertex** %objPtr
%val3686 = load float, float* %arg_3Ptr
; set tuple
%val3687 = getelementptr %NVGvertex, %NVGvertex* %val3685, i64 0, i32 3
store float %val3686, float* %val3687
%val3688 = load %NVGvertex*, %NVGvertex** %objPtr
ret %NVGvertex* %val3688
}
@gsxtmnanovg167 = hidden constant [120 x i8] c"NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** @NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3708 = load i8*, i8** %_impzPtr
%zone3709 = bitcast i8* %tzone3708 to %mzone*

; let assign value to symbol NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd
%dat_NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone3709, i64 8)
%NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = bitcast i8* %dat_NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd to { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***
%tzone3689 = load i8*, i8** %_impzPtr
%zone3690 = bitcast i8* %tzone3689 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3690)
; malloc closure structure
%clsptr3691 = call i8* @llvm_zone_malloc(%mzone* %zone3690, i64 24)
%closure3692 = bitcast i8* %clsptr3691 to { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*

; malloc environment structure
%envptr3693 = call i8* @llvm_zone_malloc(%mzone* %zone3690, i64 8)
%environment3694 = bitcast i8* %envptr3693 to {{i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***}*

; malloc closure address table
%addytable3695 = call %clsvar* @new_address_table()
%var3696 = bitcast [67 x i8]* @gsxtmnanovg166 to i8*
%var3697 = bitcast [66 x i8]* @gsxtmnanovg162 to i8*
%addytable3698 = call %clsvar* @add_address_table(%mzone* %zone3690, i8* %var3696, i32 0, i8* %var3697, i32 3, %clsvar* %addytable3695)
%address-table3699 = bitcast %clsvar* %addytable3698 to i8*

; insert table, function and environment into closure struct
%closure.table3702 = getelementptr { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure3692, i32 0, i32 0
store i8* %address-table3699, i8** %closure.table3702
%closure.env3703 = getelementptr { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure3692, i32 0, i32 1
store i8* %envptr3693, i8** %closure.env3703
%closure.func3704 = getelementptr { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure3692, i32 0, i32 2
store %NVGvertex* (i8*, i8*, float, float, float, float)* @NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd__3670, %NVGvertex* (i8*, i8*, float, float, float, float)** %closure.func3704
%closure_size3705 = call i64 @llvm_zone_mark_size(%mzone* %zone3690)
call void @llvm_zone_ptr_set_size(i8* %clsptr3691, i64 %closure_size3705)
%wrapper_ptr3706 = call i8* @llvm_zone_malloc(%mzone* %zone3690, i64 8)
%closure_wrapper3707 = bitcast i8* %wrapper_ptr3706 to { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**
store { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure3692, { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure_wrapper3707

; let value assignment
%NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd = select i1 true, { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure_wrapper3707, { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure_wrapper3707
store { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd, { i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*** %NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd
%tmp_envptr3701 = getelementptr {{i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}***}* %environment3694, i32 0, i32 0
store {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*** %NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**** %tmp_envptr3701


%val3710 = load {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*** %NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr
ret {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %val3710
}


@NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** @NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGvertex* @NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex* (i8*, i8*, float, float, float, float)*,  %NVGvertex* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGvertex* %result
}


define dllexport ccc %NVGvertex* @NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_native(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex* (i8*, i8*, float, float, float, float)*,  %NVGvertex* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGvertex* %result
}


define dllexport ccc i8*  @NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3711 = bitcast [120 x i8]* @gsxtmnanovg167 to i8*
call i32 (i8*, ...) @printf(i8* %var3711)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3712 = bitcast [120 x i8]* @gsxtmnanovg167 to i8*
call i32 (i8*, ...) @printf(i8* %var3712)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3713 = bitcast [120 x i8]* @gsxtmnanovg167 to i8*
call i32 (i8*, ...) @printf(i8* %var3713)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var3714 = bitcast [120 x i8]* @gsxtmnanovg167 to i8*
call i32 (i8*, ...) @printf(i8* %var3714)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex* (i8*, i8*, float, float, float, float)*,  %NVGvertex* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%tmpres = bitcast %NVGvertex* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float, float, float}*
%arg_p_0 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_h_adhoc_W05WR3ZlcnRleCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex* (i8*, i8*, float, float, float, float)*,  %NVGvertex* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg168 = hidden constant [17 x i8] c"<NVGvertex:null>\00"
@gsxtmnanovg169 = hidden constant [12 x i8] c"<NVGvertex:\00"
@gsxtmnanovg170 = hidden constant [43 x i8] c"toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0\00"
@gsxtmnanovg171 = hidden constant [48 x i8] c"{i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0__3715(i8* %_impz,i8* %_impenv, %NVGvertex* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3716 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}***}*
%toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}***, {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}**** %toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0Ptr_

; setup arguments
%xPtr = alloca %NVGvertex*
store %NVGvertex* %x, %NVGvertex** %xPtr


%val3718 = load %NVGvertex*, %NVGvertex** %xPtr
%val3719 = icmp eq %NVGvertex* %val3718, null
br i1 %val3719, label %then3717, label %else3717

then3717:
%zone3720 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone3720)
%zone_ptr3721 = bitcast %mzone* %zone3720 to i8*
store i8* %zone_ptr3721, i8** %_impzPtr
%tzone3731 = load i8*, i8** %_impzPtr
%zone3732 = bitcast i8* %tzone3731 to %mzone*

; let assign value to symbol res8
%res8Ptr = alloca %String*
%tzone3736 = load i8*, i8** %_impzPtr
%zone3737 = bitcast i8* %tzone3736 to %mzone*

; let assign value to symbol zone8
%zone8Ptr = alloca %mzone*
%tzone3739 = load i8*, i8** %_impzPtr
%zone3740 = bitcast i8* %tzone3739 to %mzone*

; let assign value to symbol newz8
%newz8Ptr = alloca %mzone*
%tzone3723 = load i8*, i8** %_impzPtr
%zone3724 = bitcast i8* %tzone3723 to %mzone*

; let assign value to symbol xx_t_mst
%xx_t_mstPtr = alloca i8*
%dat3722 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst = select i1 true, i8* %dat3722, i8* %dat3722
store i8* %xx_t_mst, i8** %xx_t_mstPtr

%val3725 = load i8*, i8** %xx_t_mstPtr
%var3726 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var3727 = bitcast [17 x i8]* @gsxtmnanovg168 to i8*

%val3728 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3725, i8* %var3726, i8* %var3727)
%val3729 = load i8*, i8** %xx_t_mstPtr
%res3730 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3729)

; let value assignment
%res8 = select i1 true, %String* %res3730, %String* %res3730
store %String* %res8, %String** %res8Ptr

%oldzone3733 = call %mzone* @llvm_pop_zone_stack()
%newzone3734 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr3735 = bitcast %mzone* %newzone3734 to i8*
store i8* %zone_ptr3735, i8** %_impzPtr

; let value assignment
%zone8 = select i1 true, %mzone* %oldzone3733, %mzone* %oldzone3733
store %mzone* %zone8, %mzone** %zone8Ptr

%res3738 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz8 = select i1 true, %mzone* %res3738, %mzone* %res3738
store %mzone* %newz8, %mzone** %newz8Ptr

%tzone3745 = load i8*, i8** %_impzPtr
%zone3746 = bitcast i8* %tzone3745 to %mzone*

; let assign value to symbol rescopy8
%rescopy8Ptr = alloca %String*
%tzone3751 = load i8*, i8** %_impzPtr
%zone3752 = bitcast i8* %tzone3751 to %mzone*

; let assign value to symbol hook
%hookPtr = alloca {i64,i8*,i8*}*
%tzone3754 = load i8*, i8** %_impzPtr
%zone3755 = bitcast i8* %tzone3754 to %mzone*

; let assign value to symbol f
%fPtr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val3741 = load %String*, %String** %res8Ptr
%val3742 = load %mzone*, %mzone** %zone8Ptr
%val3743 = load %mzone*, %mzone** %newz8Ptr
%res3744 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val3741, %mzone* %val3742, %mzone* %val3743)

; let value assignment
%rescopy8 = select i1 true, %String* %res3744, %String* %res3744
store %String* %rescopy8, %String** %rescopy8Ptr

%val3747 = load %mzone*, %mzone** %zone8Ptr
; tuple ref
%val3748 = getelementptr %mzone, %mzone* %val3747, i64 0, i32 4
%val3749 = load i8*, i8** %val3748
%val3750 = bitcast i8* %val3749 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val3750, {i64,i8*,i8*}* %val3750
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%null3753 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null3753, {i8*, i8*, void (i8*, i8*)*}** %null3753
store {i8*, i8*, void (i8*, i8*)*}** %f, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; promote local stack var allocations
%tzone3791 = load i8*, i8** %_impzPtr
%zone3792 = bitcast i8* %tzone3791 to %mzone*
%ifptr3781 = alloca i1
%ifptr3757 = alloca i1
; while loop
%val3758 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val3759 = icmp eq {i64,i8*,i8*}* %val3758, null
br i1 %val3759, label %then3757, label %else3757

then3757:
%res3760 = call ccc i1 @impc_false()
store i1 %res3760, i1* %ifptr3757
br label %ifcont3757

else3757:
%res3761 = call ccc i1 @impc_true()
store i1 %res3761, i1* %ifptr3757
br label %ifcont3757

ifcont3757:
%ifres3762 = load i1, i1* %ifptr3757

br i1 %ifres3762, label %loop3756, label %after3756

loop3756:
; do set!
%val3763 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val3764 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val3763, i64 0, i32 1
%val3765 = load i8*, i8** %val3764
%val3766 = bitcast i8* %val3765 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val3766, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; apply closure 
%vval3767 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val3768 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval3767
%fPtr3769 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val3768, i32 0, i32 2
%ePtr3770 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val3768, i32 0, i32 1
%f3771 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr3769
%e3772 = load i8*, i8** %ePtr3770
%tzone3773 = load i8*, i8** %_impzPtr
%zone3774 = bitcast i8* %tzone3773 to %mzone*
%z3775 = bitcast %mzone* %zone3774 to i8*
tail call fastcc void %f3771(i8* %z3775, i8* %e3772)
; do set!
%val3777 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val3778 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val3777, i64 0, i32 2
%val3779 = load i8*, i8** %val3778
%val3780 = bitcast i8* %val3779 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val3780, {i64,i8*,i8*}** %hookPtr
%val3782 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val3783 = icmp eq {i64,i8*,i8*}* %val3782, null
br i1 %val3783, label %then3781, label %else3781

then3781:
%res3784 = call ccc i1 @impc_false()
store i1 %res3784, i1* %ifptr3781
br label %ifcont3781

else3781:
%res3785 = call ccc i1 @impc_true()
store i1 %res3785, i1* %ifptr3781
br label %ifcont3781

ifcont3781:
%ifres3786 = load i1, i1* %ifptr3781

br i1 %ifres3786, label %loop3756, label %after3756

after3756:
%val3788 = load %mzone*, %mzone** %zone8Ptr
call ccc void @llvm_zone_destroy(%mzone* %val3788)
%val3790 = load %String*, %String** %rescopy8Ptr
ret %String* %val3790

else3717:
%zone3793 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone3793)
%zone_ptr3794 = bitcast %mzone* %zone3793 to i8*
store i8* %zone_ptr3794, i8** %_impzPtr
%tzone3864 = load i8*, i8** %_impzPtr
%zone3865 = bitcast i8* %tzone3864 to %mzone*

; let assign value to symbol res9
%res9Ptr = alloca %String*
%tzone3869 = load i8*, i8** %_impzPtr
%zone3870 = bitcast i8* %tzone3869 to %mzone*

; let assign value to symbol zone9
%zone9Ptr = alloca %mzone*
%tzone3872 = load i8*, i8** %_impzPtr
%zone3873 = bitcast i8* %tzone3872 to %mzone*

; let assign value to symbol newz9
%newz9Ptr = alloca %mzone*
%tzone3796 = load i8*, i8** %_impzPtr
%zone3797 = bitcast i8* %tzone3796 to %mzone*

; let assign value to symbol xx_t_mst_s_31
%xx_t_mst_s_31Ptr = alloca i8*
%dat3795 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_31 = select i1 true, i8* %dat3795, i8* %dat3795
store i8* %xx_t_mst_s_31, i8** %xx_t_mst_s_31Ptr

%val3798 = load i8*, i8** %xx_t_mst_s_31Ptr
%var3799 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var3800 = bitcast [12 x i8]* @gsxtmnanovg169 to i8*

%val3801 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3798, i8* %var3799, i8* %var3800)
%val3802 = load i8*, i8** %xx_t_mst_s_31Ptr
%res3803 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3802)
%val3804 = load %NVGvertex*, %NVGvertex** %xPtr
; tuple ref
%val3805 = getelementptr %NVGvertex, %NVGvertex* %val3804, i64 0, i32 0
%val3806 = load float, float* %val3805
%res3807 = call fastcc %String* @toString_adhoc_W1N0cmluZyosZmxvYXRd(float %val3806)
%res3808 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3803, %String* %res3807)
%tzone3810 = load i8*, i8** %_impzPtr
%zone3811 = bitcast i8* %tzone3810 to %mzone*

; let assign value to symbol xx_t_mst_s_32
%xx_t_mst_s_32Ptr = alloca i8*
%dat3809 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_32 = select i1 true, i8* %dat3809, i8* %dat3809
store i8* %xx_t_mst_s_32, i8** %xx_t_mst_s_32Ptr

%val3812 = load i8*, i8** %xx_t_mst_s_32Ptr
%var3813 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var3814 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val3815 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3812, i8* %var3813, i8* %var3814)
%val3816 = load i8*, i8** %xx_t_mst_s_32Ptr
%res3817 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3816)
%res3818 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3808, %String* %res3817)
%val3819 = load %NVGvertex*, %NVGvertex** %xPtr
; tuple ref
%val3820 = getelementptr %NVGvertex, %NVGvertex* %val3819, i64 0, i32 1
%val3821 = load float, float* %val3820
%res3822 = call fastcc %String* @toString_adhoc_W1N0cmluZyosZmxvYXRd(float %val3821)
%res3823 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3818, %String* %res3822)
%tzone3825 = load i8*, i8** %_impzPtr
%zone3826 = bitcast i8* %tzone3825 to %mzone*

; let assign value to symbol xx_t_mst_s_33
%xx_t_mst_s_33Ptr = alloca i8*
%dat3824 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_33 = select i1 true, i8* %dat3824, i8* %dat3824
store i8* %xx_t_mst_s_33, i8** %xx_t_mst_s_33Ptr

%val3827 = load i8*, i8** %xx_t_mst_s_33Ptr
%var3828 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var3829 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val3830 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3827, i8* %var3828, i8* %var3829)
%val3831 = load i8*, i8** %xx_t_mst_s_33Ptr
%res3832 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3831)
%res3833 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3823, %String* %res3832)
%val3834 = load %NVGvertex*, %NVGvertex** %xPtr
; tuple ref
%val3835 = getelementptr %NVGvertex, %NVGvertex* %val3834, i64 0, i32 2
%val3836 = load float, float* %val3835
%res3837 = call fastcc %String* @toString_adhoc_W1N0cmluZyosZmxvYXRd(float %val3836)
%res3838 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3833, %String* %res3837)
%tzone3840 = load i8*, i8** %_impzPtr
%zone3841 = bitcast i8* %tzone3840 to %mzone*

; let assign value to symbol xx_t_mst_s_34
%xx_t_mst_s_34Ptr = alloca i8*
%dat3839 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_34 = select i1 true, i8* %dat3839, i8* %dat3839
store i8* %xx_t_mst_s_34, i8** %xx_t_mst_s_34Ptr

%val3842 = load i8*, i8** %xx_t_mst_s_34Ptr
%var3843 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var3844 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val3845 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3842, i8* %var3843, i8* %var3844)
%val3846 = load i8*, i8** %xx_t_mst_s_34Ptr
%res3847 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3846)
%res3848 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3838, %String* %res3847)
%val3849 = load %NVGvertex*, %NVGvertex** %xPtr
; tuple ref
%val3850 = getelementptr %NVGvertex, %NVGvertex* %val3849, i64 0, i32 3
%val3851 = load float, float* %val3850
%res3852 = call fastcc %String* @toString_adhoc_W1N0cmluZyosZmxvYXRd(float %val3851)
%res3853 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3848, %String* %res3852)
%tzone3855 = load i8*, i8** %_impzPtr
%zone3856 = bitcast i8* %tzone3855 to %mzone*

; let assign value to symbol xx_t_mst_s_35
%xx_t_mst_s_35Ptr = alloca i8*
%dat3854 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_35 = select i1 true, i8* %dat3854, i8* %dat3854
store i8* %xx_t_mst_s_35, i8** %xx_t_mst_s_35Ptr

%val3857 = load i8*, i8** %xx_t_mst_s_35Ptr
%var3858 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var3859 = bitcast [2 x i8]* @gsxtmnanovg65 to i8*

%val3860 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3857, i8* %var3858, i8* %var3859)
%val3861 = load i8*, i8** %xx_t_mst_s_35Ptr
%res3862 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3861)
%res3863 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3853, %String* %res3862)

; let value assignment
%res9 = select i1 true, %String* %res3863, %String* %res3863
store %String* %res9, %String** %res9Ptr

%oldzone3866 = call %mzone* @llvm_pop_zone_stack()
%newzone3867 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr3868 = bitcast %mzone* %newzone3867 to i8*
store i8* %zone_ptr3868, i8** %_impzPtr

; let value assignment
%zone9 = select i1 true, %mzone* %oldzone3866, %mzone* %oldzone3866
store %mzone* %zone9, %mzone** %zone9Ptr

%res3871 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz9 = select i1 true, %mzone* %res3871, %mzone* %res3871
store %mzone* %newz9, %mzone** %newz9Ptr

%tzone3878 = load i8*, i8** %_impzPtr
%zone3879 = bitcast i8* %tzone3878 to %mzone*

; let assign value to symbol rescopy9
%rescopy9Ptr = alloca %String*
%tzone3884 = load i8*, i8** %_impzPtr
%zone3885 = bitcast i8* %tzone3884 to %mzone*

; let assign value to symbol hook_s_36
%hook_s_36Ptr = alloca {i64,i8*,i8*}*
%tzone3887 = load i8*, i8** %_impzPtr
%zone3888 = bitcast i8* %tzone3887 to %mzone*

; let assign value to symbol f_s_37
%f_s_37Ptr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val3874 = load %String*, %String** %res9Ptr
%val3875 = load %mzone*, %mzone** %zone9Ptr
%val3876 = load %mzone*, %mzone** %newz9Ptr
%res3877 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val3874, %mzone* %val3875, %mzone* %val3876)

; let value assignment
%rescopy9 = select i1 true, %String* %res3877, %String* %res3877
store %String* %rescopy9, %String** %rescopy9Ptr

%val3880 = load %mzone*, %mzone** %zone9Ptr
; tuple ref
%val3881 = getelementptr %mzone, %mzone* %val3880, i64 0, i32 4
%val3882 = load i8*, i8** %val3881
%val3883 = bitcast i8* %val3882 to {i64,i8*,i8*}*

; let value assignment
%hook_s_36 = select i1 true, {i64,i8*,i8*}* %val3883, {i64,i8*,i8*}* %val3883
store {i64,i8*,i8*}* %hook_s_36, {i64,i8*,i8*}** %hook_s_36Ptr

%null3886 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f_s_37 = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null3886, {i8*, i8*, void (i8*, i8*)*}** %null3886
store {i8*, i8*, void (i8*, i8*)*}** %f_s_37, {i8*, i8*, void (i8*, i8*)*}*** %f_s_37Ptr

; promote local stack var allocations
%tzone3924 = load i8*, i8** %_impzPtr
%zone3925 = bitcast i8* %tzone3924 to %mzone*
%ifptr3914 = alloca i1
%ifptr3890 = alloca i1
; while loop
%val3891 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_36Ptr
%val3892 = icmp eq {i64,i8*,i8*}* %val3891, null
br i1 %val3892, label %then3890, label %else3890

then3890:
%res3893 = call ccc i1 @impc_false()
store i1 %res3893, i1* %ifptr3890
br label %ifcont3890

else3890:
%res3894 = call ccc i1 @impc_true()
store i1 %res3894, i1* %ifptr3890
br label %ifcont3890

ifcont3890:
%ifres3895 = load i1, i1* %ifptr3890

br i1 %ifres3895, label %loop3889, label %after3889

loop3889:
; do set!
%val3896 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_36Ptr
; tuple ref
%val3897 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val3896, i64 0, i32 1
%val3898 = load i8*, i8** %val3897
%val3899 = bitcast i8* %val3898 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val3899, {i8*, i8*, void (i8*, i8*)*}*** %f_s_37Ptr

; apply closure 
%vval3900 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %f_s_37Ptr
%val3901 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval3900
%fPtr3902 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val3901, i32 0, i32 2
%ePtr3903 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val3901, i32 0, i32 1
%f3904 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr3902
%e3905 = load i8*, i8** %ePtr3903
%tzone3906 = load i8*, i8** %_impzPtr
%zone3907 = bitcast i8* %tzone3906 to %mzone*
%z3908 = bitcast %mzone* %zone3907 to i8*
tail call fastcc void %f3904(i8* %z3908, i8* %e3905)
; do set!
%val3910 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_36Ptr
; tuple ref
%val3911 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val3910, i64 0, i32 2
%val3912 = load i8*, i8** %val3911
%val3913 = bitcast i8* %val3912 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val3913, {i64,i8*,i8*}** %hook_s_36Ptr
%val3915 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_36Ptr
%val3916 = icmp eq {i64,i8*,i8*}* %val3915, null
br i1 %val3916, label %then3914, label %else3914

then3914:
%res3917 = call ccc i1 @impc_false()
store i1 %res3917, i1* %ifptr3914
br label %ifcont3914

else3914:
%res3918 = call ccc i1 @impc_true()
store i1 %res3918, i1* %ifptr3914
br label %ifcont3914

ifcont3914:
%ifres3919 = load i1, i1* %ifptr3914

br i1 %ifres3919, label %loop3889, label %after3889

after3889:
%val3921 = load %mzone*, %mzone** %zone9Ptr
call ccc void @llvm_zone_destroy(%mzone* %val3921)
%val3923 = load %String*, %String** %rescopy9Ptr
ret %String* %val3923
}
@gsxtmnanovg172 = hidden constant [96 x i8] c"toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}** @toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3945 = load i8*, i8** %_impzPtr
%zone3946 = bitcast i8* %tzone3945 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0
%dat_toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone3946, i64 8)
%toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0Ptr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0 to { i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}***
%tzone3926 = load i8*, i8** %_impzPtr
%zone3927 = bitcast i8* %tzone3926 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3927)
; malloc closure structure
%clsptr3928 = call i8* @llvm_zone_malloc(%mzone* %zone3927, i64 24)
%closure3929 = bitcast i8* %clsptr3928 to { i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}*

; malloc environment structure
%envptr3930 = call i8* @llvm_zone_malloc(%mzone* %zone3927, i64 8)
%environment3931 = bitcast i8* %envptr3930 to {{i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}***}*

; malloc closure address table
%addytable3932 = call %clsvar* @new_address_table()
%var3933 = bitcast [43 x i8]* @gsxtmnanovg170 to i8*
%var3934 = bitcast [48 x i8]* @gsxtmnanovg171 to i8*
%addytable3935 = call %clsvar* @add_address_table(%mzone* %zone3927, i8* %var3933, i32 0, i8* %var3934, i32 3, %clsvar* %addytable3932)
%address-table3936 = bitcast %clsvar* %addytable3935 to i8*

; insert table, function and environment into closure struct
%closure.table3939 = getelementptr { i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}, { i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}* %closure3929, i32 0, i32 0
store i8* %address-table3936, i8** %closure.table3939
%closure.env3940 = getelementptr { i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}, { i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}* %closure3929, i32 0, i32 1
store i8* %envptr3930, i8** %closure.env3940
%closure.func3941 = getelementptr { i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}, { i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}* %closure3929, i32 0, i32 2
store %String* (i8*, i8*, %NVGvertex*)* @toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0__3715, %String* (i8*, i8*, %NVGvertex*)** %closure.func3941
%closure_size3942 = call i64 @llvm_zone_mark_size(%mzone* %zone3927)
call void @llvm_zone_ptr_set_size(i8* %clsptr3928, i64 %closure_size3942)
%wrapper_ptr3943 = call i8* @llvm_zone_malloc(%mzone* %zone3927, i64 8)
%closure_wrapper3944 = bitcast i8* %wrapper_ptr3943 to { i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}**
store { i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}* %closure3929, { i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}** %closure_wrapper3944

; let value assignment
%toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}** %closure_wrapper3944, { i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}** %closure_wrapper3944
store { i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}** %toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0, { i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}*** %toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0Ptr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0
%tmp_envptr3938 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}***}* %environment3931, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}*** %toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0Ptr, {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}**** %tmp_envptr3938


%val3947 = load {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}**, {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}*** %toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}** %val3947
}


@toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}** @toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0(%NVGvertex* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGvertex*)*,  %String* (i8*, i8*, %NVGvertex*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGvertex* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0_native(%NVGvertex* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGvertex*)*,  %String* (i8*, i8*, %NVGvertex*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGvertex* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3948 = bitcast [96 x i8]* @gsxtmnanovg172 to i8*
call i32 (i8*, ...) @printf(i8* %var3948)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGvertex*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGvertex*)*,  %String* (i8*, i8*, %NVGvertex*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGvertex* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGvertex*}*
%arg_p_0 = getelementptr {%NVGvertex*}, {%NVGvertex*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGvertex*, %NVGvertex** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGvertex*)*,  %String* (i8*, i8*, %NVGvertex*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGvertex* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg173 = hidden constant [36 x i8] c"print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0\00"
@gsxtmnanovg174 = hidden constant [44 x i8] c"{i8*, i8*, void (i8*, i8*, %NVGvertex*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0__3949(i8* %_impz,i8* %_impenv, %NVGvertex* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3950 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %NVGvertex*)*}***}*
%print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGvertex*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGvertex*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0Ptr = load {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}***, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}**** %print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0Ptr_

; setup arguments
%xPtr = alloca %NVGvertex*
store %NVGvertex* %x, %NVGvertex** %xPtr


%val3952 = load %NVGvertex*, %NVGvertex** %xPtr
%val3953 = icmp eq %NVGvertex* %val3952, null
br i1 %val3953, label %then3951, label %else3951

then3951:
%var3954 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var3955 = bitcast [17 x i8]* @gsxtmnanovg168 to i8*

%val3956 = call i32 (i8*, ...) @printf(i8* %var3954, i8* %var3955)
br label %ifcont3951

else3951:
%var3958 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var3959 = bitcast [12 x i8]* @gsxtmnanovg169 to i8*

%val3960 = call i32 (i8*, ...) @printf(i8* %var3958, i8* %var3959)
%val3961 = load %NVGvertex*, %NVGvertex** %xPtr
; tuple ref
%val3962 = getelementptr %NVGvertex, %NVGvertex* %val3961, i64 0, i32 0
%val3963 = load float, float* %val3962
call fastcc void @print_adhoc_W3ZvaWQsZmxvYXRd(float %val3963)
%var3965 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var3966 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val3967 = call i32 (i8*, ...) @printf(i8* %var3965, i8* %var3966)
%val3968 = load %NVGvertex*, %NVGvertex** %xPtr
; tuple ref
%val3969 = getelementptr %NVGvertex, %NVGvertex* %val3968, i64 0, i32 1
%val3970 = load float, float* %val3969
call fastcc void @print_adhoc_W3ZvaWQsZmxvYXRd(float %val3970)
%var3972 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var3973 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val3974 = call i32 (i8*, ...) @printf(i8* %var3972, i8* %var3973)
%val3975 = load %NVGvertex*, %NVGvertex** %xPtr
; tuple ref
%val3976 = getelementptr %NVGvertex, %NVGvertex* %val3975, i64 0, i32 2
%val3977 = load float, float* %val3976
call fastcc void @print_adhoc_W3ZvaWQsZmxvYXRd(float %val3977)
%var3979 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var3980 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val3981 = call i32 (i8*, ...) @printf(i8* %var3979, i8* %var3980)
%val3982 = load %NVGvertex*, %NVGvertex** %xPtr
; tuple ref
%val3983 = getelementptr %NVGvertex, %NVGvertex* %val3982, i64 0, i32 3
%val3984 = load float, float* %val3983
call fastcc void @print_adhoc_W3ZvaWQsZmxvYXRd(float %val3984)
%var3986 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var3987 = bitcast [2 x i8]* @gsxtmnanovg65 to i8*

%val3988 = call i32 (i8*, ...) @printf(i8* %var3986, i8* %var3987)
br label %ifcont3951

ifcont3951:
ret void
}
@gsxtmnanovg175 = hidden constant [89 x i8] c"print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** @print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4010 = load i8*, i8** %_impzPtr
%zone4011 = bitcast i8* %tzone4010 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0
%dat_print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone4011, i64 8)
%print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0Ptr = bitcast i8* %dat_print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0 to { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}***
%tzone3991 = load i8*, i8** %_impzPtr
%zone3992 = bitcast i8* %tzone3991 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3992)
; malloc closure structure
%clsptr3993 = call i8* @llvm_zone_malloc(%mzone* %zone3992, i64 24)
%closure3994 = bitcast i8* %clsptr3993 to { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}*

; malloc environment structure
%envptr3995 = call i8* @llvm_zone_malloc(%mzone* %zone3992, i64 8)
%environment3996 = bitcast i8* %envptr3995 to {{i8*, i8*, void (i8*, i8*, %NVGvertex*)*}***}*

; malloc closure address table
%addytable3997 = call %clsvar* @new_address_table()
%var3998 = bitcast [36 x i8]* @gsxtmnanovg173 to i8*
%var3999 = bitcast [44 x i8]* @gsxtmnanovg174 to i8*
%addytable4000 = call %clsvar* @add_address_table(%mzone* %zone3992, i8* %var3998, i32 0, i8* %var3999, i32 3, %clsvar* %addytable3997)
%address-table4001 = bitcast %clsvar* %addytable4000 to i8*

; insert table, function and environment into closure struct
%closure.table4004 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure3994, i32 0, i32 0
store i8* %address-table4001, i8** %closure.table4004
%closure.env4005 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure3994, i32 0, i32 1
store i8* %envptr3995, i8** %closure.env4005
%closure.func4006 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure3994, i32 0, i32 2
store void (i8*, i8*, %NVGvertex*)* @print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0__3949, void (i8*, i8*, %NVGvertex*)** %closure.func4006
%closure_size4007 = call i64 @llvm_zone_mark_size(%mzone* %zone3992)
call void @llvm_zone_ptr_set_size(i8* %clsptr3993, i64 %closure_size4007)
%wrapper_ptr4008 = call i8* @llvm_zone_malloc(%mzone* %zone3992, i64 8)
%closure_wrapper4009 = bitcast i8* %wrapper_ptr4008 to { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}**
store { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure3994, { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** %closure_wrapper4009

; let value assignment
%print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** %closure_wrapper4009, { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** %closure_wrapper4009
store { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** %print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0, { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}*** %print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0Ptr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0
%tmp_envptr4003 = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGvertex*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGvertex*)*}***}* %environment3996, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}*** %print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0Ptr, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}**** %tmp_envptr4003


%val4012 = load {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}**, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}*** %print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** %val4012
}


@print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** @print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0(%NVGvertex* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}*, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGvertex*)*,  void (i8*, i8*, %NVGvertex*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGvertex* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_native(%NVGvertex* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}*, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGvertex*)*,  void (i8*, i8*, %NVGvertex*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGvertex* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4013 = bitcast [89 x i8]* @gsxtmnanovg175 to i8*
call i32 (i8*, ...) @printf(i8* %var4013)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGvertex*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}*, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGvertex*)*,  void (i8*, i8*, %NVGvertex*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGvertex* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGvertex*}*
%arg_p_0 = getelementptr {%NVGvertex*}, {%NVGvertex*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGvertex*, %NVGvertex** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}*, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGvertex*)*,  void (i8*, i8*, %NVGvertex*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGvertex* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg176 = hidden constant [68 x i8] c"NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0\00"
@gsxtmnanovg177 = hidden constant [65 x i8] c"{i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}**\00"
define dllexport fastcc %NVGvertex @NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0__4014(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1, float %arg_2, float %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4015 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}***}*
%NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr_ = getelementptr {{i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr = load {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}***, {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}**** %NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr
%arg_2Ptr = alloca float
store float %arg_2, float* %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr


%tzone4017 = load i8*, i8** %_impzPtr
%zone4018 = bitcast i8* %tzone4017 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGvertex*
%dat4016 = alloca %NVGvertex, align 16

; let value assignment
%obj = select i1 true, %NVGvertex* %dat4016, %NVGvertex* %dat4016
store %NVGvertex* %obj, %NVGvertex** %objPtr

%val4019 = load %NVGvertex*, %NVGvertex** %objPtr
%val4020 = load float, float* %arg_0Ptr
; set tuple
%val4021 = getelementptr %NVGvertex, %NVGvertex* %val4019, i64 0, i32 0
store float %val4020, float* %val4021
%val4022 = load %NVGvertex*, %NVGvertex** %objPtr
%val4023 = load float, float* %arg_1Ptr
; set tuple
%val4024 = getelementptr %NVGvertex, %NVGvertex* %val4022, i64 0, i32 1
store float %val4023, float* %val4024
%val4025 = load %NVGvertex*, %NVGvertex** %objPtr
%val4026 = load float, float* %arg_2Ptr
; set tuple
%val4027 = getelementptr %NVGvertex, %NVGvertex* %val4025, i64 0, i32 2
store float %val4026, float* %val4027
%val4028 = load %NVGvertex*, %NVGvertex** %objPtr
%val4029 = load float, float* %arg_3Ptr
; set tuple
%val4030 = getelementptr %NVGvertex, %NVGvertex* %val4028, i64 0, i32 3
store float %val4029, float* %val4030
%val4031 = load %NVGvertex*, %NVGvertex** %objPtr
; pointer ref
%val4032 = getelementptr %NVGvertex, %NVGvertex* %val4031, i64 0
%val4033 = load %NVGvertex, %NVGvertex* %val4032
ret %NVGvertex %val4033
}
@gsxtmnanovg178 = hidden constant [121 x i8] c"NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}** @NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4053 = load i8*, i8** %_impzPtr
%zone4054 = bitcast i8* %tzone4053 to %mzone*

; let assign value to symbol NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0
%dat_NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0 = call i8* @llvm_zone_malloc(%mzone* %zone4054, i64 8)
%NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr = bitcast i8* %dat_NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0 to { i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}***
%tzone4034 = load i8*, i8** %_impzPtr
%zone4035 = bitcast i8* %tzone4034 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4035)
; malloc closure structure
%clsptr4036 = call i8* @llvm_zone_malloc(%mzone* %zone4035, i64 24)
%closure4037 = bitcast i8* %clsptr4036 to { i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}*

; malloc environment structure
%envptr4038 = call i8* @llvm_zone_malloc(%mzone* %zone4035, i64 8)
%environment4039 = bitcast i8* %envptr4038 to {{i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}***}*

; malloc closure address table
%addytable4040 = call %clsvar* @new_address_table()
%var4041 = bitcast [68 x i8]* @gsxtmnanovg176 to i8*
%var4042 = bitcast [65 x i8]* @gsxtmnanovg177 to i8*
%addytable4043 = call %clsvar* @add_address_table(%mzone* %zone4035, i8* %var4041, i32 0, i8* %var4042, i32 3, %clsvar* %addytable4040)
%address-table4044 = bitcast %clsvar* %addytable4043 to i8*

; insert table, function and environment into closure struct
%closure.table4047 = getelementptr { i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}* %closure4037, i32 0, i32 0
store i8* %address-table4044, i8** %closure.table4047
%closure.env4048 = getelementptr { i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}* %closure4037, i32 0, i32 1
store i8* %envptr4038, i8** %closure.env4048
%closure.func4049 = getelementptr { i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}* %closure4037, i32 0, i32 2
store %NVGvertex (i8*, i8*, float, float, float, float)* @NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0__4014, %NVGvertex (i8*, i8*, float, float, float, float)** %closure.func4049
%closure_size4050 = call i64 @llvm_zone_mark_size(%mzone* %zone4035)
call void @llvm_zone_ptr_set_size(i8* %clsptr4036, i64 %closure_size4050)
%wrapper_ptr4051 = call i8* @llvm_zone_malloc(%mzone* %zone4035, i64 8)
%closure_wrapper4052 = bitcast i8* %wrapper_ptr4051 to { i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}**
store { i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}* %closure4037, { i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}** %closure_wrapper4052

; let value assignment
%NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0 = select i1 true, { i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}** %closure_wrapper4052, { i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}** %closure_wrapper4052
store { i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}** %NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0, { i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}*** %NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr

; add data to environment
; don't need to alloc for env var NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0
%tmp_envptr4046 = getelementptr {{i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}***}* %environment4039, i32 0, i32 0
store {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}*** %NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr, {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}**** %tmp_envptr4046


%val4055 = load {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}**, {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}*** %NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0Ptr
ret {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}** %val4055
}


@NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var = dllexport global [1 x i8*] [ i8* null ]

@NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}** @NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGvertex @NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex (i8*, i8*, float, float, float, float)*,  %NVGvertex (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGvertex %result
}


define dllexport ccc %NVGvertex @NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_native(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex (i8*, i8*, float, float, float, float)*,  %NVGvertex (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %NVGvertex %result
}


define dllexport ccc void @NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float, float, float}*
%arg_p_0 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGvertex_val_adhoc_W05WR3ZlcnRleCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %NVGvertex (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex (i8*, i8*, float, float, float, float)*,  %NVGvertex (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg179 = hidden constant [44 x i8] c"hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0\00"
@gsxtmnanovg180 = hidden constant [51 x i8] c"{i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}**\00"
define dllexport fastcc %NVGvertex* @hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0__4060(i8* %_impz,i8* %_impenv, %NVGvertex* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4061 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}***}*
%hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0Ptr_ = getelementptr {{i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}***}, {{i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0Ptr = load {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}***, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}**** %hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0Ptr_

; setup arguments
%xPtr = alloca %NVGvertex*
store %NVGvertex* %x, %NVGvertex** %xPtr


%tzone4064 = load i8*, i8** %_impzPtr
%zone4065 = bitcast i8* %tzone4064 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGvertex*
%dat4062 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat4062, i32 0, i64 16)
%val4063 = bitcast i8* %dat4062 to %NVGvertex*

; let value assignment
%obj = select i1 true, %NVGvertex* %val4063, %NVGvertex* %val4063
store %NVGvertex* %obj, %NVGvertex** %objPtr

%val4066 = load %NVGvertex*, %NVGvertex** %objPtr
%val4067 = load %NVGvertex*, %NVGvertex** %xPtr
; tuple ref
%val4068 = getelementptr %NVGvertex, %NVGvertex* %val4067, i64 0, i32 0
%val4069 = load float, float* %val4068
; set tuple
%val4070 = getelementptr %NVGvertex, %NVGvertex* %val4066, i64 0, i32 0
store float %val4069, float* %val4070
%val4071 = load %NVGvertex*, %NVGvertex** %objPtr
%val4072 = load %NVGvertex*, %NVGvertex** %xPtr
; tuple ref
%val4073 = getelementptr %NVGvertex, %NVGvertex* %val4072, i64 0, i32 1
%val4074 = load float, float* %val4073
; set tuple
%val4075 = getelementptr %NVGvertex, %NVGvertex* %val4071, i64 0, i32 1
store float %val4074, float* %val4075
%val4076 = load %NVGvertex*, %NVGvertex** %objPtr
%val4077 = load %NVGvertex*, %NVGvertex** %xPtr
; tuple ref
%val4078 = getelementptr %NVGvertex, %NVGvertex* %val4077, i64 0, i32 2
%val4079 = load float, float* %val4078
; set tuple
%val4080 = getelementptr %NVGvertex, %NVGvertex* %val4076, i64 0, i32 2
store float %val4079, float* %val4080
%val4081 = load %NVGvertex*, %NVGvertex** %objPtr
%val4082 = load %NVGvertex*, %NVGvertex** %xPtr
; tuple ref
%val4083 = getelementptr %NVGvertex, %NVGvertex* %val4082, i64 0, i32 3
%val4084 = load float, float* %val4083
; set tuple
%val4085 = getelementptr %NVGvertex, %NVGvertex* %val4081, i64 0, i32 3
store float %val4084, float* %val4085
%val4086 = load %NVGvertex*, %NVGvertex** %objPtr
ret %NVGvertex* %val4086
}
@gsxtmnanovg181 = hidden constant [97 x i8] c"hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}** @hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4106 = load i8*, i8** %_impzPtr
%zone4107 = bitcast i8* %tzone4106 to %mzone*

; let assign value to symbol hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0
%dat_hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone4107, i64 8)
%hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0Ptr = bitcast i8* %dat_hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0 to { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}***
%tzone4087 = load i8*, i8** %_impzPtr
%zone4088 = bitcast i8* %tzone4087 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4088)
; malloc closure structure
%clsptr4089 = call i8* @llvm_zone_malloc(%mzone* %zone4088, i64 24)
%closure4090 = bitcast i8* %clsptr4089 to { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}*

; malloc environment structure
%envptr4091 = call i8* @llvm_zone_malloc(%mzone* %zone4088, i64 8)
%environment4092 = bitcast i8* %envptr4091 to {{i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}***}*

; malloc closure address table
%addytable4093 = call %clsvar* @new_address_table()
%var4094 = bitcast [44 x i8]* @gsxtmnanovg179 to i8*
%var4095 = bitcast [51 x i8]* @gsxtmnanovg180 to i8*
%addytable4096 = call %clsvar* @add_address_table(%mzone* %zone4088, i8* %var4094, i32 0, i8* %var4095, i32 3, %clsvar* %addytable4093)
%address-table4097 = bitcast %clsvar* %addytable4096 to i8*

; insert table, function and environment into closure struct
%closure.table4100 = getelementptr { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}, { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}* %closure4090, i32 0, i32 0
store i8* %address-table4097, i8** %closure.table4100
%closure.env4101 = getelementptr { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}, { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}* %closure4090, i32 0, i32 1
store i8* %envptr4091, i8** %closure.env4101
%closure.func4102 = getelementptr { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}, { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}* %closure4090, i32 0, i32 2
store %NVGvertex* (i8*, i8*, %NVGvertex*)* @hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0__4060, %NVGvertex* (i8*, i8*, %NVGvertex*)** %closure.func4102
%closure_size4103 = call i64 @llvm_zone_mark_size(%mzone* %zone4088)
call void @llvm_zone_ptr_set_size(i8* %clsptr4089, i64 %closure_size4103)
%wrapper_ptr4104 = call i8* @llvm_zone_malloc(%mzone* %zone4088, i64 8)
%closure_wrapper4105 = bitcast i8* %wrapper_ptr4104 to { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}**
store { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}* %closure4090, { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}** %closure_wrapper4105

; let value assignment
%hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0 = select i1 true, { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}** %closure_wrapper4105, { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}** %closure_wrapper4105
store { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}** %hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0, { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}*** %hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0Ptr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0
%tmp_envptr4099 = getelementptr {{i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}***}, {{i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}***}* %environment4092, i32 0, i32 0
store {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}*** %hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0Ptr, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}**** %tmp_envptr4099


%val4108 = load {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}**, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}*** %hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0Ptr
ret {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}** %val4108
}


@hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}** @hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGvertex* @hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0(%NVGvertex* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}**
%closure = load {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}*, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex* (i8*, i8*, %NVGvertex*)*,  %NVGvertex* (i8*, i8*, %NVGvertex*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex* %ff(i8* %_impz, i8* %ee, %NVGvertex* %arg_0)
ret %NVGvertex* %result
}


define dllexport ccc %NVGvertex* @hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0_native(%NVGvertex* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}**
%closure = load {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}*, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex* (i8*, i8*, %NVGvertex*)*,  %NVGvertex* (i8*, i8*, %NVGvertex*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex* %ff(i8* %_impz, i8* %ee, %NVGvertex* %arg_0)
ret %NVGvertex* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4109 = bitcast [97 x i8]* @gsxtmnanovg181 to i8*
call i32 (i8*, ...) @printf(i8* %var4109)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGvertex*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}**
%closure = load {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}*, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex* (i8*, i8*, %NVGvertex*)*,  %NVGvertex* (i8*, i8*, %NVGvertex*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex* %ff(i8* %_impz, i8* %ee, %NVGvertex* %arg_0)
%tmpres = bitcast %NVGvertex* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGvertex*}*
%arg_p_0 = getelementptr {%NVGvertex*}, {%NVGvertex*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGvertex*, %NVGvertex** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}**
%closure = load {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}*, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex* (i8*, i8*, %NVGvertex*)*,  %NVGvertex* (i8*, i8*, %NVGvertex*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex* %ff(i8* %_impz, i8* %ee, %NVGvertex* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg182 = hidden constant [36 x i8] c"hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0__4110(i8* %_impz,i8* %_impenv, %NVGvertex* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4111 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %NVGvertex*)*}***}*
%hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGvertex*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGvertex*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0Ptr = load {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}***, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}**** %hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0Ptr_

; setup arguments
%xPtr = alloca %NVGvertex*
store %NVGvertex* %x, %NVGvertex** %xPtr


%val4112 = load %NVGvertex*, %NVGvertex** %xPtr
%val4113 = bitcast %NVGvertex* %val4112 to i8*
call ccc void @free(i8* %val4113)
ret void
}
@gsxtmnanovg183 = hidden constant [89 x i8] c"hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** @hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4135 = load i8*, i8** %_impzPtr
%zone4136 = bitcast i8* %tzone4135 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0
%dat_hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone4136, i64 8)
%hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0Ptr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0 to { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}***
%tzone4116 = load i8*, i8** %_impzPtr
%zone4117 = bitcast i8* %tzone4116 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4117)
; malloc closure structure
%clsptr4118 = call i8* @llvm_zone_malloc(%mzone* %zone4117, i64 24)
%closure4119 = bitcast i8* %clsptr4118 to { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}*

; malloc environment structure
%envptr4120 = call i8* @llvm_zone_malloc(%mzone* %zone4117, i64 8)
%environment4121 = bitcast i8* %envptr4120 to {{i8*, i8*, void (i8*, i8*, %NVGvertex*)*}***}*

; malloc closure address table
%addytable4122 = call %clsvar* @new_address_table()
%var4123 = bitcast [36 x i8]* @gsxtmnanovg182 to i8*
%var4124 = bitcast [44 x i8]* @gsxtmnanovg174 to i8*
%addytable4125 = call %clsvar* @add_address_table(%mzone* %zone4117, i8* %var4123, i32 0, i8* %var4124, i32 3, %clsvar* %addytable4122)
%address-table4126 = bitcast %clsvar* %addytable4125 to i8*

; insert table, function and environment into closure struct
%closure.table4129 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure4119, i32 0, i32 0
store i8* %address-table4126, i8** %closure.table4129
%closure.env4130 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure4119, i32 0, i32 1
store i8* %envptr4120, i8** %closure.env4130
%closure.func4131 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure4119, i32 0, i32 2
store void (i8*, i8*, %NVGvertex*)* @hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0__4110, void (i8*, i8*, %NVGvertex*)** %closure.func4131
%closure_size4132 = call i64 @llvm_zone_mark_size(%mzone* %zone4117)
call void @llvm_zone_ptr_set_size(i8* %clsptr4118, i64 %closure_size4132)
%wrapper_ptr4133 = call i8* @llvm_zone_malloc(%mzone* %zone4117, i64 8)
%closure_wrapper4134 = bitcast i8* %wrapper_ptr4133 to { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}**
store { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure4119, { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** %closure_wrapper4134

; let value assignment
%hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** %closure_wrapper4134, { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** %closure_wrapper4134
store { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** %hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0, { i8*, i8*, void (i8*, i8*, %NVGvertex*)*}*** %hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0Ptr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0
%tmp_envptr4128 = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGvertex*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGvertex*)*}***}* %environment4121, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}*** %hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0Ptr, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}**** %tmp_envptr4128


%val4137 = load {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}**, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}*** %hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** %val4137
}


@hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** @hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0(%NVGvertex* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}*, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGvertex*)*,  void (i8*, i8*, %NVGvertex*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGvertex* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_native(%NVGvertex* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}*, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGvertex*)*,  void (i8*, i8*, %NVGvertex*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGvertex* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4138 = bitcast [89 x i8]* @gsxtmnanovg183 to i8*
call i32 (i8*, ...) @printf(i8* %var4138)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGvertex*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}*, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGvertex*)*,  void (i8*, i8*, %NVGvertex*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGvertex* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGvertex*}*
%arg_p_0 = getelementptr {%NVGvertex*}, {%NVGvertex*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGvertex*, %NVGvertex** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}*, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}, {i8*, i8*, void (i8*, i8*, %NVGvertex*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGvertex*)*,  void (i8*, i8*, %NVGvertex*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGvertex* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg184 = hidden constant [63 x i8] c"zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ\00"
@gsxtmnanovg185 = hidden constant [69 x i8] c"{i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %NVGvertex* @zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ__4139(i8* %_impz,i8* %_impenv, %NVGvertex* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4140 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQPtr_ = getelementptr {{i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQPtr = load {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}***, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQPtr_

; setup arguments
%xPtr = alloca %NVGvertex*
store %NVGvertex* %x, %NVGvertex** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val4142 = load %mzone*, %mzone** %fromzPtr
%val4143 = load %NVGvertex*, %NVGvertex** %xPtr
%val4144 = bitcast %NVGvertex* %val4143 to i8*
%res4145 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val4142, i8* %val4144)
br i1 %res4145, label %then4141, label %else4141

then4141:
%val4146 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val4146)
%zone_ptr4147 = bitcast %mzone* %val4146 to i8*
store i8* %zone_ptr4147, i8** %_impzPtr
%tzone4153 = load i8*, i8** %_impzPtr
%zone4154 = bitcast i8* %tzone4153 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGvertex*
%tzone4149 = load i8*, i8** %_impzPtr
%zone4150 = bitcast i8* %tzone4149 to %mzone*
%dat4151 = call i8* @llvm_zone_malloc(%mzone* %zone4150, i64 16)
call i8* @memset(i8* %dat4151, i32 0, i64 16)
%val4152 = bitcast i8* %dat4151 to %NVGvertex*

; let value assignment
%obj = select i1 true, %NVGvertex* %val4152, %NVGvertex* %val4152
store %NVGvertex* %obj, %NVGvertex** %objPtr

%val4155 = load %NVGvertex*, %NVGvertex** %objPtr
%val4156 = load %NVGvertex*, %NVGvertex** %xPtr
; tuple ref
%val4157 = getelementptr %NVGvertex, %NVGvertex* %val4156, i64 0, i32 0
%val4158 = load float, float* %val4157
; set tuple
%val4159 = getelementptr %NVGvertex, %NVGvertex* %val4155, i64 0, i32 0
store float %val4158, float* %val4159
%val4160 = load %NVGvertex*, %NVGvertex** %objPtr
%val4161 = load %NVGvertex*, %NVGvertex** %xPtr
; tuple ref
%val4162 = getelementptr %NVGvertex, %NVGvertex* %val4161, i64 0, i32 1
%val4163 = load float, float* %val4162
; set tuple
%val4164 = getelementptr %NVGvertex, %NVGvertex* %val4160, i64 0, i32 1
store float %val4163, float* %val4164
%val4165 = load %NVGvertex*, %NVGvertex** %objPtr
%val4166 = load %NVGvertex*, %NVGvertex** %xPtr
; tuple ref
%val4167 = getelementptr %NVGvertex, %NVGvertex* %val4166, i64 0, i32 2
%val4168 = load float, float* %val4167
; set tuple
%val4169 = getelementptr %NVGvertex, %NVGvertex* %val4165, i64 0, i32 2
store float %val4168, float* %val4169
%val4170 = load %NVGvertex*, %NVGvertex** %objPtr
%val4171 = load %NVGvertex*, %NVGvertex** %xPtr
; tuple ref
%val4172 = getelementptr %NVGvertex, %NVGvertex* %val4171, i64 0, i32 3
%val4173 = load float, float* %val4172
; set tuple
%val4174 = getelementptr %NVGvertex, %NVGvertex* %val4170, i64 0, i32 3
store float %val4173, float* %val4174
%oldzone4175 = call %mzone* @llvm_pop_zone_stack()
%newzone4176 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr4177 = bitcast %mzone* %newzone4176 to i8*
store i8* %zone_ptr4177, i8** %_impzPtr
%val4178 = load %NVGvertex*, %NVGvertex** %objPtr
ret %NVGvertex* %val4178

else4141:
%val4179 = load %NVGvertex*, %NVGvertex** %xPtr
ret %NVGvertex* %val4179
}
@gsxtmnanovg186 = hidden constant [116 x i8] c"zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}** @zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4199 = load i8*, i8** %_impzPtr
%zone4200 = bitcast i8* %tzone4199 to %mzone*

; let assign value to symbol zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ
%dat_zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone4200, i64 8)
%zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQPtr = bitcast i8* %dat_zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ to { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}***
%tzone4180 = load i8*, i8** %_impzPtr
%zone4181 = bitcast i8* %tzone4180 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4181)
; malloc closure structure
%clsptr4182 = call i8* @llvm_zone_malloc(%mzone* %zone4181, i64 24)
%closure4183 = bitcast i8* %clsptr4182 to { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr4184 = call i8* @llvm_zone_malloc(%mzone* %zone4181, i64 8)
%environment4185 = bitcast i8* %envptr4184 to {{i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable4186 = call %clsvar* @new_address_table()
%var4187 = bitcast [63 x i8]* @gsxtmnanovg184 to i8*
%var4188 = bitcast [69 x i8]* @gsxtmnanovg185 to i8*
%addytable4189 = call %clsvar* @add_address_table(%mzone* %zone4181, i8* %var4187, i32 0, i8* %var4188, i32 3, %clsvar* %addytable4186)
%address-table4190 = bitcast %clsvar* %addytable4189 to i8*

; insert table, function and environment into closure struct
%closure.table4193 = getelementptr { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}* %closure4183, i32 0, i32 0
store i8* %address-table4190, i8** %closure.table4193
%closure.env4194 = getelementptr { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}* %closure4183, i32 0, i32 1
store i8* %envptr4184, i8** %closure.env4194
%closure.func4195 = getelementptr { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}* %closure4183, i32 0, i32 2
store %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)* @zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ__4139, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)** %closure.func4195
%closure_size4196 = call i64 @llvm_zone_mark_size(%mzone* %zone4181)
call void @llvm_zone_ptr_set_size(i8* %clsptr4182, i64 %closure_size4196)
%wrapper_ptr4197 = call i8* @llvm_zone_malloc(%mzone* %zone4181, i64 8)
%closure_wrapper4198 = bitcast i8* %wrapper_ptr4197 to { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}**
store { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}* %closure4183, { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}** %closure_wrapper4198

; let value assignment
%zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ = select i1 true, { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}** %closure_wrapper4198, { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}** %closure_wrapper4198
store { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}** %zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ, { i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ
%tmp_envptr4192 = getelementptr {{i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}***}* %environment4185, i32 0, i32 0
store {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQPtr, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}**** %tmp_envptr4192


%val4201 = load {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}**, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQPtr
ret {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}** %val4201
}


@zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}** @zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGvertex* @zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ(%NVGvertex* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*,  %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex* %ff(i8* %_impz, i8* %ee, %NVGvertex* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %NVGvertex* %result
}


define dllexport ccc %NVGvertex* @zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ_native(%NVGvertex* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*,  %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex* %ff(i8* %_impz, i8* %ee, %NVGvertex* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %NVGvertex* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4202 = bitcast [116 x i8]* @gsxtmnanovg186 to i8*
call i32 (i8*, ...) @printf(i8* %var4202)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGvertex*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4203 = bitcast [116 x i8]* @gsxtmnanovg186 to i8*
call i32 (i8*, ...) @printf(i8* %var4203)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4204 = bitcast [116 x i8]* @gsxtmnanovg186 to i8*
call i32 (i8*, ...) @printf(i8* %var4204)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*,  %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex* %ff(i8* %_impz, i8* %ee, %NVGvertex* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %NVGvertex* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGvertex*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%NVGvertex*, %mzone*, %mzone*}, {%NVGvertex*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGvertex*, %NVGvertex** %arg_p_0
%arg_p_1 = getelementptr {%NVGvertex*, %mzone*, %mzone*}, {%NVGvertex*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%NVGvertex*, %mzone*, %mzone*}, {%NVGvertex*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)*,  %NVGvertex* (i8*, i8*, %NVGvertex*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGvertex* %ff(i8* %_impz, i8* %ee, %NVGvertex* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%NVGpath = type {i32,i32,i8,i32,%NVGvertex*,i32,%NVGvertex*,i32,i32,i32}
@gsxtmnanovg187 = hidden constant [99 x i8] c"NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd\00"
@gsxtmnanovg188 = hidden constant [101 x i8] c"{i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**\00"
define dllexport fastcc %NVGpath* @NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd__4205(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i8 %arg_2, i32 %arg_3, %NVGvertex* %arg_4, i32 %arg_5, %NVGvertex* %arg_6, i32 %arg_7, i32 %arg_8, i32 %arg_9) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4206 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}*
%NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJdPtr_ = getelementptr {{i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}, {{i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJdPtr = load {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**** %NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i8
store i8 %arg_2, i8* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca %NVGvertex*
store %NVGvertex* %arg_4, %NVGvertex** %arg_4Ptr
%arg_5Ptr = alloca i32
store i32 %arg_5, i32* %arg_5Ptr
%arg_6Ptr = alloca %NVGvertex*
store %NVGvertex* %arg_6, %NVGvertex** %arg_6Ptr
%arg_7Ptr = alloca i32
store i32 %arg_7, i32* %arg_7Ptr
%arg_8Ptr = alloca i32
store i32 %arg_8, i32* %arg_8Ptr
%arg_9Ptr = alloca i32
store i32 %arg_9, i32* %arg_9Ptr


%tzone4211 = load i8*, i8** %_impzPtr
%zone4212 = bitcast i8* %tzone4211 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGpath*
%tzone4207 = load i8*, i8** %_impzPtr
%zone4208 = bitcast i8* %tzone4207 to %mzone*
%dat4209 = call i8* @llvm_zone_malloc(%mzone* %zone4208, i64 56)
call i8* @memset(i8* %dat4209, i32 0, i64 56)
%val4210 = bitcast i8* %dat4209 to %NVGpath*

; let value assignment
%obj = select i1 true, %NVGpath* %val4210, %NVGpath* %val4210
store %NVGpath* %obj, %NVGpath** %objPtr

%val4213 = load %NVGpath*, %NVGpath** %objPtr
%val4214 = load i32, i32* %arg_0Ptr
; set tuple
%val4215 = getelementptr %NVGpath, %NVGpath* %val4213, i64 0, i32 0
store i32 %val4214, i32* %val4215
%val4216 = load %NVGpath*, %NVGpath** %objPtr
%val4217 = load i32, i32* %arg_1Ptr
; set tuple
%val4218 = getelementptr %NVGpath, %NVGpath* %val4216, i64 0, i32 1
store i32 %val4217, i32* %val4218
%val4219 = load %NVGpath*, %NVGpath** %objPtr
%val4220 = load i8, i8* %arg_2Ptr
; set tuple
%val4221 = getelementptr %NVGpath, %NVGpath* %val4219, i64 0, i32 2
store i8 %val4220, i8* %val4221
%val4222 = load %NVGpath*, %NVGpath** %objPtr
%val4223 = load i32, i32* %arg_3Ptr
; set tuple
%val4224 = getelementptr %NVGpath, %NVGpath* %val4222, i64 0, i32 3
store i32 %val4223, i32* %val4224
%val4225 = load %NVGpath*, %NVGpath** %objPtr
%val4226 = load %NVGvertex*, %NVGvertex** %arg_4Ptr
; set tuple
%val4227 = getelementptr %NVGpath, %NVGpath* %val4225, i64 0, i32 4
store %NVGvertex* %val4226, %NVGvertex** %val4227
%val4228 = load %NVGpath*, %NVGpath** %objPtr
%val4229 = load i32, i32* %arg_5Ptr
; set tuple
%val4230 = getelementptr %NVGpath, %NVGpath* %val4228, i64 0, i32 5
store i32 %val4229, i32* %val4230
%val4231 = load %NVGpath*, %NVGpath** %objPtr
%val4232 = load %NVGvertex*, %NVGvertex** %arg_6Ptr
; set tuple
%val4233 = getelementptr %NVGpath, %NVGpath* %val4231, i64 0, i32 6
store %NVGvertex* %val4232, %NVGvertex** %val4233
%val4234 = load %NVGpath*, %NVGpath** %objPtr
%val4235 = load i32, i32* %arg_7Ptr
; set tuple
%val4236 = getelementptr %NVGpath, %NVGpath* %val4234, i64 0, i32 7
store i32 %val4235, i32* %val4236
%val4237 = load %NVGpath*, %NVGpath** %objPtr
%val4238 = load i32, i32* %arg_8Ptr
; set tuple
%val4239 = getelementptr %NVGpath, %NVGpath* %val4237, i64 0, i32 8
store i32 %val4238, i32* %val4239
%val4240 = load %NVGpath*, %NVGpath** %objPtr
%val4241 = load i32, i32* %arg_9Ptr
; set tuple
%val4242 = getelementptr %NVGpath, %NVGpath* %val4240, i64 0, i32 9
store i32 %val4241, i32* %val4242
%val4243 = load %NVGpath*, %NVGpath** %objPtr
ret %NVGpath* %val4243
}
@gsxtmnanovg189 = hidden constant [152 x i8] c"NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** @NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4263 = load i8*, i8** %_impzPtr
%zone4264 = bitcast i8* %tzone4263 to %mzone*

; let assign value to symbol NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd
%dat_NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone4264, i64 8)
%NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJdPtr = bitcast i8* %dat_NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd to { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***
%tzone4244 = load i8*, i8** %_impzPtr
%zone4245 = bitcast i8* %tzone4244 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4245)
; malloc closure structure
%clsptr4246 = call i8* @llvm_zone_malloc(%mzone* %zone4245, i64 24)
%closure4247 = bitcast i8* %clsptr4246 to { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*

; malloc environment structure
%envptr4248 = call i8* @llvm_zone_malloc(%mzone* %zone4245, i64 8)
%environment4249 = bitcast i8* %envptr4248 to {{i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}*

; malloc closure address table
%addytable4250 = call %clsvar* @new_address_table()
%var4251 = bitcast [99 x i8]* @gsxtmnanovg187 to i8*
%var4252 = bitcast [101 x i8]* @gsxtmnanovg188 to i8*
%addytable4253 = call %clsvar* @add_address_table(%mzone* %zone4245, i8* %var4251, i32 0, i8* %var4252, i32 3, %clsvar* %addytable4250)
%address-table4254 = bitcast %clsvar* %addytable4253 to i8*

; insert table, function and environment into closure struct
%closure.table4257 = getelementptr { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure4247, i32 0, i32 0
store i8* %address-table4254, i8** %closure.table4257
%closure.env4258 = getelementptr { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure4247, i32 0, i32 1
store i8* %envptr4248, i8** %closure.env4258
%closure.func4259 = getelementptr { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure4247, i32 0, i32 2
store %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)* @NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd__4205, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)** %closure.func4259
%closure_size4260 = call i64 @llvm_zone_mark_size(%mzone* %zone4245)
call void @llvm_zone_ptr_set_size(i8* %clsptr4246, i64 %closure_size4260)
%wrapper_ptr4261 = call i8* @llvm_zone_malloc(%mzone* %zone4245, i64 8)
%closure_wrapper4262 = bitcast i8* %wrapper_ptr4261 to { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**
store { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure4247, { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_wrapper4262

; let value assignment
%NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd = select i1 true, { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_wrapper4262, { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_wrapper4262
store { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd, { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*** %NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJdPtr

; add data to environment
; don't need to alloc for env var NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd
%tmp_envptr4256 = getelementptr {{i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}, {{i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}* %environment4249, i32 0, i32 0
store {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*** %NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJdPtr, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**** %tmp_envptr4256


%val4265 = load {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*** %NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJdPtr
ret {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %val4265
}


@NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** @NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGpath* @NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd(i32 %arg_0,i32 %arg_1,i8 %arg_2,i32 %arg_3,%NVGvertex* %arg_4,i32 %arg_5,%NVGvertex* %arg_6,i32 %arg_7,i32 %arg_8,i32 %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*,  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8 %arg_2, i32 %arg_3, %NVGvertex* %arg_4, i32 %arg_5, %NVGvertex* %arg_6, i32 %arg_7, i32 %arg_8, i32 %arg_9)
ret %NVGpath* %result
}


define dllexport ccc %NVGpath* @NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_native(i32 %arg_0,i32 %arg_1,i8 %arg_2,i32 %arg_3,%NVGvertex* %arg_4,i32 %arg_5,%NVGvertex* %arg_6,i32 %arg_7,i32 %arg_8,i32 %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*,  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8 %arg_2, i32 %arg_3, %NVGvertex* %arg_4, i32 %arg_5, %NVGvertex* %arg_6, i32 %arg_7, i32 %arg_8, i32 %arg_9)
ret %NVGpath* %result
}


define dllexport ccc i8*  @NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4266 = bitcast [152 x i8]* @gsxtmnanovg189 to i8*
call i32 (i8*, ...) @printf(i8* %var4266)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4267 = bitcast [152 x i8]* @gsxtmnanovg189 to i8*
call i32 (i8*, ...) @printf(i8* %var4267)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4268 = bitcast [152 x i8]* @gsxtmnanovg189 to i8*
call i32 (i8*, ...) @printf(i8* %var4268)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8  @i8value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var4269 = bitcast [152 x i8]* @gsxtmnanovg189 to i8*
call i32 (i8*, ...) @printf(i8* %var4269)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var4270 = bitcast [152 x i8]* @gsxtmnanovg189 to i8*
call i32 (i8*, ...) @printf(i8* %var4270)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to %NVGvertex*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var4271 = bitcast [152 x i8]* @gsxtmnanovg189 to i8*
call i32 (i8*, ...) @printf(i8* %var4271)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var4272 = bitcast [152 x i8]* @gsxtmnanovg189 to i8*
call i32 (i8*, ...) @printf(i8* %var4272)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to %NVGvertex*
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_integer(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var4273 = bitcast [152 x i8]* @gsxtmnanovg189 to i8*
call i32 (i8*, ...) @printf(i8* %var4273)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%arg_7 = call ccc i32  @i32value(i8* %arg_7_val)
%arg_8_val = call ccc i8* @list_ref(i8* %_sc, i32 8,i8* %args)
%arg_8_rt_check = call i32 @is_integer(i8* %arg_8_val)
%arg_8_bool = icmp ne i32 %arg_8_rt_check, 0
br i1 %arg_8_bool, label %arg_8_true, label %arg_8_false

arg_8_true:
br label %arg_8_continue

arg_8_false:
%var4274 = bitcast [152 x i8]* @gsxtmnanovg189 to i8*
call i32 (i8*, ...) @printf(i8* %var4274)
%arg_8_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_8_errret

arg_8_continue:
%arg_8 = call ccc i32  @i32value(i8* %arg_8_val)
%arg_9_val = call ccc i8* @list_ref(i8* %_sc, i32 9,i8* %args)
%arg_9_rt_check = call i32 @is_integer(i8* %arg_9_val)
%arg_9_bool = icmp ne i32 %arg_9_rt_check, 0
br i1 %arg_9_bool, label %arg_9_true, label %arg_9_false

arg_9_true:
br label %arg_9_continue

arg_9_false:
%var4275 = bitcast [152 x i8]* @gsxtmnanovg189 to i8*
call i32 (i8*, ...) @printf(i8* %var4275)
%arg_9_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_9_errret

arg_9_continue:
%arg_9 = call ccc i32  @i32value(i8* %arg_9_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*,  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8 %arg_2, i32 %arg_3, %NVGvertex* %arg_4, i32 %arg_5, %NVGvertex* %arg_6, i32 %arg_7, i32 %arg_8, i32 %arg_9)
%tmpres = bitcast %NVGpath* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}*
%arg_p_0 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i8, i8* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load %NVGvertex*, %NVGvertex** %arg_p_4
%arg_p_5 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
%arg_p_6 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 6
%arg_6 = load %NVGvertex*, %NVGvertex** %arg_p_6
%arg_p_7 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 7
%arg_7 = load i32, i32* %arg_p_7
%arg_p_8 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 8
%arg_8 = load i32, i32* %arg_p_8
%arg_p_9 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 9
%arg_9 = load i32, i32* %arg_p_9
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*,  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8 %arg_2, i32 %arg_3, %NVGvertex* %arg_4, i32 %arg_5, %NVGvertex* %arg_6, i32 %arg_7, i32 %arg_8, i32 %arg_9)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg190 = hidden constant [101 x i8] c"NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd\00"
define dllexport fastcc %NVGpath* @NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd__4276(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i8 %arg_2, i32 %arg_3, %NVGvertex* %arg_4, i32 %arg_5, %NVGvertex* %arg_6, i32 %arg_7, i32 %arg_8, i32 %arg_9) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4277 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}*
%NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJdPtr_ = getelementptr {{i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}, {{i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJdPtr = load {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**** %NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i8
store i8 %arg_2, i8* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca %NVGvertex*
store %NVGvertex* %arg_4, %NVGvertex** %arg_4Ptr
%arg_5Ptr = alloca i32
store i32 %arg_5, i32* %arg_5Ptr
%arg_6Ptr = alloca %NVGvertex*
store %NVGvertex* %arg_6, %NVGvertex** %arg_6Ptr
%arg_7Ptr = alloca i32
store i32 %arg_7, i32* %arg_7Ptr
%arg_8Ptr = alloca i32
store i32 %arg_8, i32* %arg_8Ptr
%arg_9Ptr = alloca i32
store i32 %arg_9, i32* %arg_9Ptr


%tzone4282 = load i8*, i8** %_impzPtr
%zone4283 = bitcast i8* %tzone4282 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGpath*
%tzone4278 = load i8*, i8** %_impzPtr
%zone4279 = bitcast i8* %tzone4278 to %mzone*
%dat4280 = call i8* @llvm_zone_malloc(%mzone* %zone4279, i64 56)
call i8* @memset(i8* %dat4280, i32 0, i64 56)
%val4281 = bitcast i8* %dat4280 to %NVGpath*

; let value assignment
%obj = select i1 true, %NVGpath* %val4281, %NVGpath* %val4281
store %NVGpath* %obj, %NVGpath** %objPtr

%val4284 = load %NVGpath*, %NVGpath** %objPtr
%val4285 = load i32, i32* %arg_0Ptr
; set tuple
%val4286 = getelementptr %NVGpath, %NVGpath* %val4284, i64 0, i32 0
store i32 %val4285, i32* %val4286
%val4287 = load %NVGpath*, %NVGpath** %objPtr
%val4288 = load i32, i32* %arg_1Ptr
; set tuple
%val4289 = getelementptr %NVGpath, %NVGpath* %val4287, i64 0, i32 1
store i32 %val4288, i32* %val4289
%val4290 = load %NVGpath*, %NVGpath** %objPtr
%val4291 = load i8, i8* %arg_2Ptr
; set tuple
%val4292 = getelementptr %NVGpath, %NVGpath* %val4290, i64 0, i32 2
store i8 %val4291, i8* %val4292
%val4293 = load %NVGpath*, %NVGpath** %objPtr
%val4294 = load i32, i32* %arg_3Ptr
; set tuple
%val4295 = getelementptr %NVGpath, %NVGpath* %val4293, i64 0, i32 3
store i32 %val4294, i32* %val4295
%val4296 = load %NVGpath*, %NVGpath** %objPtr
%val4297 = load %NVGvertex*, %NVGvertex** %arg_4Ptr
; set tuple
%val4298 = getelementptr %NVGpath, %NVGpath* %val4296, i64 0, i32 4
store %NVGvertex* %val4297, %NVGvertex** %val4298
%val4299 = load %NVGpath*, %NVGpath** %objPtr
%val4300 = load i32, i32* %arg_5Ptr
; set tuple
%val4301 = getelementptr %NVGpath, %NVGpath* %val4299, i64 0, i32 5
store i32 %val4300, i32* %val4301
%val4302 = load %NVGpath*, %NVGpath** %objPtr
%val4303 = load %NVGvertex*, %NVGvertex** %arg_6Ptr
; set tuple
%val4304 = getelementptr %NVGpath, %NVGpath* %val4302, i64 0, i32 6
store %NVGvertex* %val4303, %NVGvertex** %val4304
%val4305 = load %NVGpath*, %NVGpath** %objPtr
%val4306 = load i32, i32* %arg_7Ptr
; set tuple
%val4307 = getelementptr %NVGpath, %NVGpath* %val4305, i64 0, i32 7
store i32 %val4306, i32* %val4307
%val4308 = load %NVGpath*, %NVGpath** %objPtr
%val4309 = load i32, i32* %arg_8Ptr
; set tuple
%val4310 = getelementptr %NVGpath, %NVGpath* %val4308, i64 0, i32 8
store i32 %val4309, i32* %val4310
%val4311 = load %NVGpath*, %NVGpath** %objPtr
%val4312 = load i32, i32* %arg_9Ptr
; set tuple
%val4313 = getelementptr %NVGpath, %NVGpath* %val4311, i64 0, i32 9
store i32 %val4312, i32* %val4313
%val4314 = load %NVGpath*, %NVGpath** %objPtr
ret %NVGpath* %val4314
}
@gsxtmnanovg191 = hidden constant [154 x i8] c"NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** @NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4334 = load i8*, i8** %_impzPtr
%zone4335 = bitcast i8* %tzone4334 to %mzone*

; let assign value to symbol NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd
%dat_NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone4335, i64 8)
%NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJdPtr = bitcast i8* %dat_NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd to { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***
%tzone4315 = load i8*, i8** %_impzPtr
%zone4316 = bitcast i8* %tzone4315 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4316)
; malloc closure structure
%clsptr4317 = call i8* @llvm_zone_malloc(%mzone* %zone4316, i64 24)
%closure4318 = bitcast i8* %clsptr4317 to { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*

; malloc environment structure
%envptr4319 = call i8* @llvm_zone_malloc(%mzone* %zone4316, i64 8)
%environment4320 = bitcast i8* %envptr4319 to {{i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}*

; malloc closure address table
%addytable4321 = call %clsvar* @new_address_table()
%var4322 = bitcast [101 x i8]* @gsxtmnanovg190 to i8*
%var4323 = bitcast [101 x i8]* @gsxtmnanovg188 to i8*
%addytable4324 = call %clsvar* @add_address_table(%mzone* %zone4316, i8* %var4322, i32 0, i8* %var4323, i32 3, %clsvar* %addytable4321)
%address-table4325 = bitcast %clsvar* %addytable4324 to i8*

; insert table, function and environment into closure struct
%closure.table4328 = getelementptr { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure4318, i32 0, i32 0
store i8* %address-table4325, i8** %closure.table4328
%closure.env4329 = getelementptr { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure4318, i32 0, i32 1
store i8* %envptr4319, i8** %closure.env4329
%closure.func4330 = getelementptr { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure4318, i32 0, i32 2
store %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)* @NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd__4276, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)** %closure.func4330
%closure_size4331 = call i64 @llvm_zone_mark_size(%mzone* %zone4316)
call void @llvm_zone_ptr_set_size(i8* %clsptr4317, i64 %closure_size4331)
%wrapper_ptr4332 = call i8* @llvm_zone_malloc(%mzone* %zone4316, i64 8)
%closure_wrapper4333 = bitcast i8* %wrapper_ptr4332 to { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**
store { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure4318, { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_wrapper4333

; let value assignment
%NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd = select i1 true, { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_wrapper4333, { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_wrapper4333
store { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd, { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*** %NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJdPtr

; add data to environment
; don't need to alloc for env var NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd
%tmp_envptr4327 = getelementptr {{i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}, {{i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}* %environment4320, i32 0, i32 0
store {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*** %NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJdPtr, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**** %tmp_envptr4327


%val4336 = load {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*** %NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJdPtr
ret {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %val4336
}


@NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** @NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGpath* @NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd(i32 %arg_0,i32 %arg_1,i8 %arg_2,i32 %arg_3,%NVGvertex* %arg_4,i32 %arg_5,%NVGvertex* %arg_6,i32 %arg_7,i32 %arg_8,i32 %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*,  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8 %arg_2, i32 %arg_3, %NVGvertex* %arg_4, i32 %arg_5, %NVGvertex* %arg_6, i32 %arg_7, i32 %arg_8, i32 %arg_9)
ret %NVGpath* %result
}


define dllexport ccc %NVGpath* @NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_native(i32 %arg_0,i32 %arg_1,i8 %arg_2,i32 %arg_3,%NVGvertex* %arg_4,i32 %arg_5,%NVGvertex* %arg_6,i32 %arg_7,i32 %arg_8,i32 %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*,  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8 %arg_2, i32 %arg_3, %NVGvertex* %arg_4, i32 %arg_5, %NVGvertex* %arg_6, i32 %arg_7, i32 %arg_8, i32 %arg_9)
ret %NVGpath* %result
}


define dllexport ccc i8*  @NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4337 = bitcast [154 x i8]* @gsxtmnanovg191 to i8*
call i32 (i8*, ...) @printf(i8* %var4337)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4338 = bitcast [154 x i8]* @gsxtmnanovg191 to i8*
call i32 (i8*, ...) @printf(i8* %var4338)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4339 = bitcast [154 x i8]* @gsxtmnanovg191 to i8*
call i32 (i8*, ...) @printf(i8* %var4339)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8  @i8value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var4340 = bitcast [154 x i8]* @gsxtmnanovg191 to i8*
call i32 (i8*, ...) @printf(i8* %var4340)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var4341 = bitcast [154 x i8]* @gsxtmnanovg191 to i8*
call i32 (i8*, ...) @printf(i8* %var4341)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to %NVGvertex*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var4342 = bitcast [154 x i8]* @gsxtmnanovg191 to i8*
call i32 (i8*, ...) @printf(i8* %var4342)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var4343 = bitcast [154 x i8]* @gsxtmnanovg191 to i8*
call i32 (i8*, ...) @printf(i8* %var4343)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to %NVGvertex*
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_integer(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var4344 = bitcast [154 x i8]* @gsxtmnanovg191 to i8*
call i32 (i8*, ...) @printf(i8* %var4344)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%arg_7 = call ccc i32  @i32value(i8* %arg_7_val)
%arg_8_val = call ccc i8* @list_ref(i8* %_sc, i32 8,i8* %args)
%arg_8_rt_check = call i32 @is_integer(i8* %arg_8_val)
%arg_8_bool = icmp ne i32 %arg_8_rt_check, 0
br i1 %arg_8_bool, label %arg_8_true, label %arg_8_false

arg_8_true:
br label %arg_8_continue

arg_8_false:
%var4345 = bitcast [154 x i8]* @gsxtmnanovg191 to i8*
call i32 (i8*, ...) @printf(i8* %var4345)
%arg_8_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_8_errret

arg_8_continue:
%arg_8 = call ccc i32  @i32value(i8* %arg_8_val)
%arg_9_val = call ccc i8* @list_ref(i8* %_sc, i32 9,i8* %args)
%arg_9_rt_check = call i32 @is_integer(i8* %arg_9_val)
%arg_9_bool = icmp ne i32 %arg_9_rt_check, 0
br i1 %arg_9_bool, label %arg_9_true, label %arg_9_false

arg_9_true:
br label %arg_9_continue

arg_9_false:
%var4346 = bitcast [154 x i8]* @gsxtmnanovg191 to i8*
call i32 (i8*, ...) @printf(i8* %var4346)
%arg_9_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_9_errret

arg_9_continue:
%arg_9 = call ccc i32  @i32value(i8* %arg_9_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*,  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8 %arg_2, i32 %arg_3, %NVGvertex* %arg_4, i32 %arg_5, %NVGvertex* %arg_6, i32 %arg_7, i32 %arg_8, i32 %arg_9)
%tmpres = bitcast %NVGpath* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}*
%arg_p_0 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i8, i8* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load %NVGvertex*, %NVGvertex** %arg_p_4
%arg_p_5 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
%arg_p_6 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 6
%arg_6 = load %NVGvertex*, %NVGvertex** %arg_p_6
%arg_p_7 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 7
%arg_7 = load i32, i32* %arg_p_7
%arg_p_8 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 8
%arg_8 = load i32, i32* %arg_p_8
%arg_p_9 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 9
%arg_9 = load i32, i32* %arg_p_9
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_z_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*,  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8 %arg_2, i32 %arg_3, %NVGvertex* %arg_4, i32 %arg_5, %NVGvertex* %arg_6, i32 %arg_7, i32 %arg_8, i32 %arg_9)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg192 = hidden constant [101 x i8] c"NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd\00"
define dllexport fastcc %NVGpath* @NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd__4347(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i8 %arg_2, i32 %arg_3, %NVGvertex* %arg_4, i32 %arg_5, %NVGvertex* %arg_6, i32 %arg_7, i32 %arg_8, i32 %arg_9) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4348 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}*
%NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJdPtr_ = getelementptr {{i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}, {{i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJdPtr = load {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**** %NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i8
store i8 %arg_2, i8* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca %NVGvertex*
store %NVGvertex* %arg_4, %NVGvertex** %arg_4Ptr
%arg_5Ptr = alloca i32
store i32 %arg_5, i32* %arg_5Ptr
%arg_6Ptr = alloca %NVGvertex*
store %NVGvertex* %arg_6, %NVGvertex** %arg_6Ptr
%arg_7Ptr = alloca i32
store i32 %arg_7, i32* %arg_7Ptr
%arg_8Ptr = alloca i32
store i32 %arg_8, i32* %arg_8Ptr
%arg_9Ptr = alloca i32
store i32 %arg_9, i32* %arg_9Ptr


%tzone4351 = load i8*, i8** %_impzPtr
%zone4352 = bitcast i8* %tzone4351 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGpath*
%dat4349 = call i8* @malloc(i64 56)
call i8* @memset(i8* %dat4349, i32 0, i64 56)
%val4350 = bitcast i8* %dat4349 to %NVGpath*

; let value assignment
%obj = select i1 true, %NVGpath* %val4350, %NVGpath* %val4350
store %NVGpath* %obj, %NVGpath** %objPtr

%val4353 = load %NVGpath*, %NVGpath** %objPtr
%val4354 = load i32, i32* %arg_0Ptr
; set tuple
%val4355 = getelementptr %NVGpath, %NVGpath* %val4353, i64 0, i32 0
store i32 %val4354, i32* %val4355
%val4356 = load %NVGpath*, %NVGpath** %objPtr
%val4357 = load i32, i32* %arg_1Ptr
; set tuple
%val4358 = getelementptr %NVGpath, %NVGpath* %val4356, i64 0, i32 1
store i32 %val4357, i32* %val4358
%val4359 = load %NVGpath*, %NVGpath** %objPtr
%val4360 = load i8, i8* %arg_2Ptr
; set tuple
%val4361 = getelementptr %NVGpath, %NVGpath* %val4359, i64 0, i32 2
store i8 %val4360, i8* %val4361
%val4362 = load %NVGpath*, %NVGpath** %objPtr
%val4363 = load i32, i32* %arg_3Ptr
; set tuple
%val4364 = getelementptr %NVGpath, %NVGpath* %val4362, i64 0, i32 3
store i32 %val4363, i32* %val4364
%val4365 = load %NVGpath*, %NVGpath** %objPtr
%val4366 = load %NVGvertex*, %NVGvertex** %arg_4Ptr
; set tuple
%val4367 = getelementptr %NVGpath, %NVGpath* %val4365, i64 0, i32 4
store %NVGvertex* %val4366, %NVGvertex** %val4367
%val4368 = load %NVGpath*, %NVGpath** %objPtr
%val4369 = load i32, i32* %arg_5Ptr
; set tuple
%val4370 = getelementptr %NVGpath, %NVGpath* %val4368, i64 0, i32 5
store i32 %val4369, i32* %val4370
%val4371 = load %NVGpath*, %NVGpath** %objPtr
%val4372 = load %NVGvertex*, %NVGvertex** %arg_6Ptr
; set tuple
%val4373 = getelementptr %NVGpath, %NVGpath* %val4371, i64 0, i32 6
store %NVGvertex* %val4372, %NVGvertex** %val4373
%val4374 = load %NVGpath*, %NVGpath** %objPtr
%val4375 = load i32, i32* %arg_7Ptr
; set tuple
%val4376 = getelementptr %NVGpath, %NVGpath* %val4374, i64 0, i32 7
store i32 %val4375, i32* %val4376
%val4377 = load %NVGpath*, %NVGpath** %objPtr
%val4378 = load i32, i32* %arg_8Ptr
; set tuple
%val4379 = getelementptr %NVGpath, %NVGpath* %val4377, i64 0, i32 8
store i32 %val4378, i32* %val4379
%val4380 = load %NVGpath*, %NVGpath** %objPtr
%val4381 = load i32, i32* %arg_9Ptr
; set tuple
%val4382 = getelementptr %NVGpath, %NVGpath* %val4380, i64 0, i32 9
store i32 %val4381, i32* %val4382
%val4383 = load %NVGpath*, %NVGpath** %objPtr
ret %NVGpath* %val4383
}
@gsxtmnanovg193 = hidden constant [154 x i8] c"NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** @NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4403 = load i8*, i8** %_impzPtr
%zone4404 = bitcast i8* %tzone4403 to %mzone*

; let assign value to symbol NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd
%dat_NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone4404, i64 8)
%NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJdPtr = bitcast i8* %dat_NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd to { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***
%tzone4384 = load i8*, i8** %_impzPtr
%zone4385 = bitcast i8* %tzone4384 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4385)
; malloc closure structure
%clsptr4386 = call i8* @llvm_zone_malloc(%mzone* %zone4385, i64 24)
%closure4387 = bitcast i8* %clsptr4386 to { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*

; malloc environment structure
%envptr4388 = call i8* @llvm_zone_malloc(%mzone* %zone4385, i64 8)
%environment4389 = bitcast i8* %envptr4388 to {{i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}*

; malloc closure address table
%addytable4390 = call %clsvar* @new_address_table()
%var4391 = bitcast [101 x i8]* @gsxtmnanovg192 to i8*
%var4392 = bitcast [101 x i8]* @gsxtmnanovg188 to i8*
%addytable4393 = call %clsvar* @add_address_table(%mzone* %zone4385, i8* %var4391, i32 0, i8* %var4392, i32 3, %clsvar* %addytable4390)
%address-table4394 = bitcast %clsvar* %addytable4393 to i8*

; insert table, function and environment into closure struct
%closure.table4397 = getelementptr { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure4387, i32 0, i32 0
store i8* %address-table4394, i8** %closure.table4397
%closure.env4398 = getelementptr { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure4387, i32 0, i32 1
store i8* %envptr4388, i8** %closure.env4398
%closure.func4399 = getelementptr { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure4387, i32 0, i32 2
store %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)* @NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd__4347, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)** %closure.func4399
%closure_size4400 = call i64 @llvm_zone_mark_size(%mzone* %zone4385)
call void @llvm_zone_ptr_set_size(i8* %clsptr4386, i64 %closure_size4400)
%wrapper_ptr4401 = call i8* @llvm_zone_malloc(%mzone* %zone4385, i64 8)
%closure_wrapper4402 = bitcast i8* %wrapper_ptr4401 to { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**
store { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure4387, { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_wrapper4402

; let value assignment
%NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd = select i1 true, { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_wrapper4402, { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_wrapper4402
store { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd, { i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*** %NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJdPtr

; add data to environment
; don't need to alloc for env var NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd
%tmp_envptr4396 = getelementptr {{i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}, {{i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}* %environment4389, i32 0, i32 0
store {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*** %NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJdPtr, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**** %tmp_envptr4396


%val4405 = load {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*** %NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJdPtr
ret {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %val4405
}


@NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** @NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGpath* @NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd(i32 %arg_0,i32 %arg_1,i8 %arg_2,i32 %arg_3,%NVGvertex* %arg_4,i32 %arg_5,%NVGvertex* %arg_6,i32 %arg_7,i32 %arg_8,i32 %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*,  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8 %arg_2, i32 %arg_3, %NVGvertex* %arg_4, i32 %arg_5, %NVGvertex* %arg_6, i32 %arg_7, i32 %arg_8, i32 %arg_9)
ret %NVGpath* %result
}


define dllexport ccc %NVGpath* @NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_native(i32 %arg_0,i32 %arg_1,i8 %arg_2,i32 %arg_3,%NVGvertex* %arg_4,i32 %arg_5,%NVGvertex* %arg_6,i32 %arg_7,i32 %arg_8,i32 %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*,  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8 %arg_2, i32 %arg_3, %NVGvertex* %arg_4, i32 %arg_5, %NVGvertex* %arg_6, i32 %arg_7, i32 %arg_8, i32 %arg_9)
ret %NVGpath* %result
}


define dllexport ccc i8*  @NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4406 = bitcast [154 x i8]* @gsxtmnanovg193 to i8*
call i32 (i8*, ...) @printf(i8* %var4406)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4407 = bitcast [154 x i8]* @gsxtmnanovg193 to i8*
call i32 (i8*, ...) @printf(i8* %var4407)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4408 = bitcast [154 x i8]* @gsxtmnanovg193 to i8*
call i32 (i8*, ...) @printf(i8* %var4408)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8  @i8value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var4409 = bitcast [154 x i8]* @gsxtmnanovg193 to i8*
call i32 (i8*, ...) @printf(i8* %var4409)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var4410 = bitcast [154 x i8]* @gsxtmnanovg193 to i8*
call i32 (i8*, ...) @printf(i8* %var4410)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to %NVGvertex*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var4411 = bitcast [154 x i8]* @gsxtmnanovg193 to i8*
call i32 (i8*, ...) @printf(i8* %var4411)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var4412 = bitcast [154 x i8]* @gsxtmnanovg193 to i8*
call i32 (i8*, ...) @printf(i8* %var4412)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to %NVGvertex*
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_integer(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var4413 = bitcast [154 x i8]* @gsxtmnanovg193 to i8*
call i32 (i8*, ...) @printf(i8* %var4413)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%arg_7 = call ccc i32  @i32value(i8* %arg_7_val)
%arg_8_val = call ccc i8* @list_ref(i8* %_sc, i32 8,i8* %args)
%arg_8_rt_check = call i32 @is_integer(i8* %arg_8_val)
%arg_8_bool = icmp ne i32 %arg_8_rt_check, 0
br i1 %arg_8_bool, label %arg_8_true, label %arg_8_false

arg_8_true:
br label %arg_8_continue

arg_8_false:
%var4414 = bitcast [154 x i8]* @gsxtmnanovg193 to i8*
call i32 (i8*, ...) @printf(i8* %var4414)
%arg_8_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_8_errret

arg_8_continue:
%arg_8 = call ccc i32  @i32value(i8* %arg_8_val)
%arg_9_val = call ccc i8* @list_ref(i8* %_sc, i32 9,i8* %args)
%arg_9_rt_check = call i32 @is_integer(i8* %arg_9_val)
%arg_9_bool = icmp ne i32 %arg_9_rt_check, 0
br i1 %arg_9_bool, label %arg_9_true, label %arg_9_false

arg_9_true:
br label %arg_9_continue

arg_9_false:
%var4415 = bitcast [154 x i8]* @gsxtmnanovg193 to i8*
call i32 (i8*, ...) @printf(i8* %var4415)
%arg_9_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_9_errret

arg_9_continue:
%arg_9 = call ccc i32  @i32value(i8* %arg_9_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*,  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8 %arg_2, i32 %arg_3, %NVGvertex* %arg_4, i32 %arg_5, %NVGvertex* %arg_6, i32 %arg_7, i32 %arg_8, i32 %arg_9)
%tmpres = bitcast %NVGpath* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}*
%arg_p_0 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i8, i8* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load %NVGvertex*, %NVGvertex** %arg_p_4
%arg_p_5 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
%arg_p_6 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 6
%arg_6 = load %NVGvertex*, %NVGvertex** %arg_p_6
%arg_p_7 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 7
%arg_7 = load i32, i32* %arg_p_7
%arg_p_8 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 8
%arg_8 = load i32, i32* %arg_p_8
%arg_p_9 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 9
%arg_9 = load i32, i32* %arg_p_9
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_h_adhoc_W05WR3BhdGgqLGkzMixpMzIsaTgsaTMyLE5WR3ZlcnRleCosaTMyLE5WR3ZlcnRleCosaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*,  %NVGpath* (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8 %arg_2, i32 %arg_3, %NVGvertex* %arg_4, i32 %arg_5, %NVGvertex* %arg_6, i32 %arg_7, i32 %arg_8, i32 %arg_9)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg194 = hidden constant [15 x i8] c"<NVGpath:null>\00"
@gsxtmnanovg195 = hidden constant [10 x i8] c"<NVGpath:\00"
@gsxtmnanovg196 = hidden constant [40 x i8] c"toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd\00"
@gsxtmnanovg197 = hidden constant [46 x i8] c"{i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd__4416(i8* %_impz,i8* %_impenv, %NVGpath* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4417 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}***}*
%toString_adhoc_W1N0cmluZyosTlZHcGF0aCpdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosTlZHcGF0aCpdPtr = load {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}***, {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}**** %toString_adhoc_W1N0cmluZyosTlZHcGF0aCpdPtr_

; setup arguments
%xPtr = alloca %NVGpath*
store %NVGpath* %x, %NVGpath** %xPtr


%val4419 = load %NVGpath*, %NVGpath** %xPtr
%val4420 = icmp eq %NVGpath* %val4419, null
br i1 %val4420, label %then4418, label %else4418

then4418:
%zone4421 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone4421)
%zone_ptr4422 = bitcast %mzone* %zone4421 to i8*
store i8* %zone_ptr4422, i8** %_impzPtr
%tzone4432 = load i8*, i8** %_impzPtr
%zone4433 = bitcast i8* %tzone4432 to %mzone*

; let assign value to symbol res10
%res10Ptr = alloca %String*
%tzone4437 = load i8*, i8** %_impzPtr
%zone4438 = bitcast i8* %tzone4437 to %mzone*

; let assign value to symbol zone10
%zone10Ptr = alloca %mzone*
%tzone4440 = load i8*, i8** %_impzPtr
%zone4441 = bitcast i8* %tzone4440 to %mzone*

; let assign value to symbol newz10
%newz10Ptr = alloca %mzone*
%tzone4424 = load i8*, i8** %_impzPtr
%zone4425 = bitcast i8* %tzone4424 to %mzone*

; let assign value to symbol xx_t_mst
%xx_t_mstPtr = alloca i8*
%dat4423 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst = select i1 true, i8* %dat4423, i8* %dat4423
store i8* %xx_t_mst, i8** %xx_t_mstPtr

%val4426 = load i8*, i8** %xx_t_mstPtr
%var4427 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4428 = bitcast [15 x i8]* @gsxtmnanovg194 to i8*

%val4429 = call i32 (i8*,i8*, ...) @sprintf(i8* %val4426, i8* %var4427, i8* %var4428)
%val4430 = load i8*, i8** %xx_t_mstPtr
%res4431 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val4430)

; let value assignment
%res10 = select i1 true, %String* %res4431, %String* %res4431
store %String* %res10, %String** %res10Ptr

%oldzone4434 = call %mzone* @llvm_pop_zone_stack()
%newzone4435 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr4436 = bitcast %mzone* %newzone4435 to i8*
store i8* %zone_ptr4436, i8** %_impzPtr

; let value assignment
%zone10 = select i1 true, %mzone* %oldzone4434, %mzone* %oldzone4434
store %mzone* %zone10, %mzone** %zone10Ptr

%res4439 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz10 = select i1 true, %mzone* %res4439, %mzone* %res4439
store %mzone* %newz10, %mzone** %newz10Ptr

%tzone4446 = load i8*, i8** %_impzPtr
%zone4447 = bitcast i8* %tzone4446 to %mzone*

; let assign value to symbol rescopy10
%rescopy10Ptr = alloca %String*
%tzone4452 = load i8*, i8** %_impzPtr
%zone4453 = bitcast i8* %tzone4452 to %mzone*

; let assign value to symbol hook
%hookPtr = alloca {i64,i8*,i8*}*
%tzone4455 = load i8*, i8** %_impzPtr
%zone4456 = bitcast i8* %tzone4455 to %mzone*

; let assign value to symbol f
%fPtr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val4442 = load %String*, %String** %res10Ptr
%val4443 = load %mzone*, %mzone** %zone10Ptr
%val4444 = load %mzone*, %mzone** %newz10Ptr
%res4445 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val4442, %mzone* %val4443, %mzone* %val4444)

; let value assignment
%rescopy10 = select i1 true, %String* %res4445, %String* %res4445
store %String* %rescopy10, %String** %rescopy10Ptr

%val4448 = load %mzone*, %mzone** %zone10Ptr
; tuple ref
%val4449 = getelementptr %mzone, %mzone* %val4448, i64 0, i32 4
%val4450 = load i8*, i8** %val4449
%val4451 = bitcast i8* %val4450 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val4451, {i64,i8*,i8*}* %val4451
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%null4454 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null4454, {i8*, i8*, void (i8*, i8*)*}** %null4454
store {i8*, i8*, void (i8*, i8*)*}** %f, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; promote local stack var allocations
%tzone4492 = load i8*, i8** %_impzPtr
%zone4493 = bitcast i8* %tzone4492 to %mzone*
%ifptr4482 = alloca i1
%ifptr4458 = alloca i1
; while loop
%val4459 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val4460 = icmp eq {i64,i8*,i8*}* %val4459, null
br i1 %val4460, label %then4458, label %else4458

then4458:
%res4461 = call ccc i1 @impc_false()
store i1 %res4461, i1* %ifptr4458
br label %ifcont4458

else4458:
%res4462 = call ccc i1 @impc_true()
store i1 %res4462, i1* %ifptr4458
br label %ifcont4458

ifcont4458:
%ifres4463 = load i1, i1* %ifptr4458

br i1 %ifres4463, label %loop4457, label %after4457

loop4457:
; do set!
%val4464 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val4465 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val4464, i64 0, i32 1
%val4466 = load i8*, i8** %val4465
%val4467 = bitcast i8* %val4466 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val4467, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; apply closure 
%vval4468 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val4469 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval4468
%fPtr4470 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val4469, i32 0, i32 2
%ePtr4471 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val4469, i32 0, i32 1
%f4472 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr4470
%e4473 = load i8*, i8** %ePtr4471
%tzone4474 = load i8*, i8** %_impzPtr
%zone4475 = bitcast i8* %tzone4474 to %mzone*
%z4476 = bitcast %mzone* %zone4475 to i8*
tail call fastcc void %f4472(i8* %z4476, i8* %e4473)
; do set!
%val4478 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val4479 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val4478, i64 0, i32 2
%val4480 = load i8*, i8** %val4479
%val4481 = bitcast i8* %val4480 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val4481, {i64,i8*,i8*}** %hookPtr
%val4483 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val4484 = icmp eq {i64,i8*,i8*}* %val4483, null
br i1 %val4484, label %then4482, label %else4482

then4482:
%res4485 = call ccc i1 @impc_false()
store i1 %res4485, i1* %ifptr4482
br label %ifcont4482

else4482:
%res4486 = call ccc i1 @impc_true()
store i1 %res4486, i1* %ifptr4482
br label %ifcont4482

ifcont4482:
%ifres4487 = load i1, i1* %ifptr4482

br i1 %ifres4487, label %loop4457, label %after4457

after4457:
%val4489 = load %mzone*, %mzone** %zone10Ptr
call ccc void @llvm_zone_destroy(%mzone* %val4489)
%val4491 = load %String*, %String** %rescopy10Ptr
ret %String* %val4491

else4418:
%zone4494 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone4494)
%zone_ptr4495 = bitcast %mzone* %zone4494 to i8*
store i8* %zone_ptr4495, i8** %_impzPtr
%tzone4655 = load i8*, i8** %_impzPtr
%zone4656 = bitcast i8* %tzone4655 to %mzone*

; let assign value to symbol res11
%res11Ptr = alloca %String*
%tzone4660 = load i8*, i8** %_impzPtr
%zone4661 = bitcast i8* %tzone4660 to %mzone*

; let assign value to symbol zone11
%zone11Ptr = alloca %mzone*
%tzone4663 = load i8*, i8** %_impzPtr
%zone4664 = bitcast i8* %tzone4663 to %mzone*

; let assign value to symbol newz11
%newz11Ptr = alloca %mzone*
%tzone4497 = load i8*, i8** %_impzPtr
%zone4498 = bitcast i8* %tzone4497 to %mzone*

; let assign value to symbol xx_t_mst_s_38
%xx_t_mst_s_38Ptr = alloca i8*
%dat4496 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_38 = select i1 true, i8* %dat4496, i8* %dat4496
store i8* %xx_t_mst_s_38, i8** %xx_t_mst_s_38Ptr

%val4499 = load i8*, i8** %xx_t_mst_s_38Ptr
%var4500 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4501 = bitcast [10 x i8]* @gsxtmnanovg195 to i8*

%val4502 = call i32 (i8*,i8*, ...) @sprintf(i8* %val4499, i8* %var4500, i8* %var4501)
%val4503 = load i8*, i8** %xx_t_mst_s_38Ptr
%res4504 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val4503)
%val4505 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4506 = getelementptr %NVGpath, %NVGpath* %val4505, i64 0, i32 0
%val4507 = load i32, i32* %val4506
%res4508 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val4507)
%res4509 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res4504, %String* %res4508)
%tzone4511 = load i8*, i8** %_impzPtr
%zone4512 = bitcast i8* %tzone4511 to %mzone*

; let assign value to symbol xx_t_mst_s_39
%xx_t_mst_s_39Ptr = alloca i8*
%dat4510 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_39 = select i1 true, i8* %dat4510, i8* %dat4510
store i8* %xx_t_mst_s_39, i8** %xx_t_mst_s_39Ptr

%val4513 = load i8*, i8** %xx_t_mst_s_39Ptr
%var4514 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4515 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val4516 = call i32 (i8*,i8*, ...) @sprintf(i8* %val4513, i8* %var4514, i8* %var4515)
%val4517 = load i8*, i8** %xx_t_mst_s_39Ptr
%res4518 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val4517)
%res4519 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res4509, %String* %res4518)
%val4520 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4521 = getelementptr %NVGpath, %NVGpath* %val4520, i64 0, i32 1
%val4522 = load i32, i32* %val4521
%res4523 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val4522)
%res4524 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res4519, %String* %res4523)
%tzone4526 = load i8*, i8** %_impzPtr
%zone4527 = bitcast i8* %tzone4526 to %mzone*

; let assign value to symbol xx_t_mst_s_40
%xx_t_mst_s_40Ptr = alloca i8*
%dat4525 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_40 = select i1 true, i8* %dat4525, i8* %dat4525
store i8* %xx_t_mst_s_40, i8** %xx_t_mst_s_40Ptr

%val4528 = load i8*, i8** %xx_t_mst_s_40Ptr
%var4529 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4530 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val4531 = call i32 (i8*,i8*, ...) @sprintf(i8* %val4528, i8* %var4529, i8* %var4530)
%val4532 = load i8*, i8** %xx_t_mst_s_40Ptr
%res4533 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val4532)
%res4534 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res4524, %String* %res4533)
%val4535 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4536 = getelementptr %NVGpath, %NVGpath* %val4535, i64 0, i32 2
%val4537 = load i8, i8* %val4536
%res4538 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaThd(i8 %val4537)
%res4539 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res4534, %String* %res4538)
%tzone4541 = load i8*, i8** %_impzPtr
%zone4542 = bitcast i8* %tzone4541 to %mzone*

; let assign value to symbol xx_t_mst_s_41
%xx_t_mst_s_41Ptr = alloca i8*
%dat4540 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_41 = select i1 true, i8* %dat4540, i8* %dat4540
store i8* %xx_t_mst_s_41, i8** %xx_t_mst_s_41Ptr

%val4543 = load i8*, i8** %xx_t_mst_s_41Ptr
%var4544 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4545 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val4546 = call i32 (i8*,i8*, ...) @sprintf(i8* %val4543, i8* %var4544, i8* %var4545)
%val4547 = load i8*, i8** %xx_t_mst_s_41Ptr
%res4548 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val4547)
%res4549 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res4539, %String* %res4548)
%val4550 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4551 = getelementptr %NVGpath, %NVGpath* %val4550, i64 0, i32 3
%val4552 = load i32, i32* %val4551
%res4553 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val4552)
%res4554 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res4549, %String* %res4553)
%tzone4556 = load i8*, i8** %_impzPtr
%zone4557 = bitcast i8* %tzone4556 to %mzone*

; let assign value to symbol xx_t_mst_s_42
%xx_t_mst_s_42Ptr = alloca i8*
%dat4555 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_42 = select i1 true, i8* %dat4555, i8* %dat4555
store i8* %xx_t_mst_s_42, i8** %xx_t_mst_s_42Ptr

%val4558 = load i8*, i8** %xx_t_mst_s_42Ptr
%var4559 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4560 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val4561 = call i32 (i8*,i8*, ...) @sprintf(i8* %val4558, i8* %var4559, i8* %var4560)
%val4562 = load i8*, i8** %xx_t_mst_s_42Ptr
%res4563 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val4562)
%res4564 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res4554, %String* %res4563)
%val4565 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4566 = getelementptr %NVGpath, %NVGpath* %val4565, i64 0, i32 4
%val4567 = load %NVGvertex*, %NVGvertex** %val4566
%res4568 = call fastcc %String* @toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0(%NVGvertex* %val4567)
%res4569 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res4564, %String* %res4568)
%tzone4571 = load i8*, i8** %_impzPtr
%zone4572 = bitcast i8* %tzone4571 to %mzone*

; let assign value to symbol xx_t_mst_s_43
%xx_t_mst_s_43Ptr = alloca i8*
%dat4570 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_43 = select i1 true, i8* %dat4570, i8* %dat4570
store i8* %xx_t_mst_s_43, i8** %xx_t_mst_s_43Ptr

%val4573 = load i8*, i8** %xx_t_mst_s_43Ptr
%var4574 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4575 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val4576 = call i32 (i8*,i8*, ...) @sprintf(i8* %val4573, i8* %var4574, i8* %var4575)
%val4577 = load i8*, i8** %xx_t_mst_s_43Ptr
%res4578 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val4577)
%res4579 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res4569, %String* %res4578)
%val4580 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4581 = getelementptr %NVGpath, %NVGpath* %val4580, i64 0, i32 5
%val4582 = load i32, i32* %val4581
%res4583 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val4582)
%res4584 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res4579, %String* %res4583)
%tzone4586 = load i8*, i8** %_impzPtr
%zone4587 = bitcast i8* %tzone4586 to %mzone*

; let assign value to symbol xx_t_mst_s_44
%xx_t_mst_s_44Ptr = alloca i8*
%dat4585 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_44 = select i1 true, i8* %dat4585, i8* %dat4585
store i8* %xx_t_mst_s_44, i8** %xx_t_mst_s_44Ptr

%val4588 = load i8*, i8** %xx_t_mst_s_44Ptr
%var4589 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4590 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val4591 = call i32 (i8*,i8*, ...) @sprintf(i8* %val4588, i8* %var4589, i8* %var4590)
%val4592 = load i8*, i8** %xx_t_mst_s_44Ptr
%res4593 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val4592)
%res4594 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res4584, %String* %res4593)
%val4595 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4596 = getelementptr %NVGpath, %NVGpath* %val4595, i64 0, i32 6
%val4597 = load %NVGvertex*, %NVGvertex** %val4596
%res4598 = call fastcc %String* @toString_adhoc_W1N0cmluZyosTlZHdmVydGV4Kl0(%NVGvertex* %val4597)
%res4599 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res4594, %String* %res4598)
%tzone4601 = load i8*, i8** %_impzPtr
%zone4602 = bitcast i8* %tzone4601 to %mzone*

; let assign value to symbol xx_t_mst_s_45
%xx_t_mst_s_45Ptr = alloca i8*
%dat4600 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_45 = select i1 true, i8* %dat4600, i8* %dat4600
store i8* %xx_t_mst_s_45, i8** %xx_t_mst_s_45Ptr

%val4603 = load i8*, i8** %xx_t_mst_s_45Ptr
%var4604 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4605 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val4606 = call i32 (i8*,i8*, ...) @sprintf(i8* %val4603, i8* %var4604, i8* %var4605)
%val4607 = load i8*, i8** %xx_t_mst_s_45Ptr
%res4608 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val4607)
%res4609 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res4599, %String* %res4608)
%val4610 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4611 = getelementptr %NVGpath, %NVGpath* %val4610, i64 0, i32 7
%val4612 = load i32, i32* %val4611
%res4613 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val4612)
%res4614 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res4609, %String* %res4613)
%tzone4616 = load i8*, i8** %_impzPtr
%zone4617 = bitcast i8* %tzone4616 to %mzone*

; let assign value to symbol xx_t_mst_s_46
%xx_t_mst_s_46Ptr = alloca i8*
%dat4615 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_46 = select i1 true, i8* %dat4615, i8* %dat4615
store i8* %xx_t_mst_s_46, i8** %xx_t_mst_s_46Ptr

%val4618 = load i8*, i8** %xx_t_mst_s_46Ptr
%var4619 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4620 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val4621 = call i32 (i8*,i8*, ...) @sprintf(i8* %val4618, i8* %var4619, i8* %var4620)
%val4622 = load i8*, i8** %xx_t_mst_s_46Ptr
%res4623 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val4622)
%res4624 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res4614, %String* %res4623)
%val4625 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4626 = getelementptr %NVGpath, %NVGpath* %val4625, i64 0, i32 8
%val4627 = load i32, i32* %val4626
%res4628 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val4627)
%res4629 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res4624, %String* %res4628)
%tzone4631 = load i8*, i8** %_impzPtr
%zone4632 = bitcast i8* %tzone4631 to %mzone*

; let assign value to symbol xx_t_mst_s_47
%xx_t_mst_s_47Ptr = alloca i8*
%dat4630 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_47 = select i1 true, i8* %dat4630, i8* %dat4630
store i8* %xx_t_mst_s_47, i8** %xx_t_mst_s_47Ptr

%val4633 = load i8*, i8** %xx_t_mst_s_47Ptr
%var4634 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4635 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val4636 = call i32 (i8*,i8*, ...) @sprintf(i8* %val4633, i8* %var4634, i8* %var4635)
%val4637 = load i8*, i8** %xx_t_mst_s_47Ptr
%res4638 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val4637)
%res4639 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res4629, %String* %res4638)
%val4640 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4641 = getelementptr %NVGpath, %NVGpath* %val4640, i64 0, i32 9
%val4642 = load i32, i32* %val4641
%res4643 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val4642)
%res4644 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res4639, %String* %res4643)
%tzone4646 = load i8*, i8** %_impzPtr
%zone4647 = bitcast i8* %tzone4646 to %mzone*

; let assign value to symbol xx_t_mst_s_48
%xx_t_mst_s_48Ptr = alloca i8*
%dat4645 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_48 = select i1 true, i8* %dat4645, i8* %dat4645
store i8* %xx_t_mst_s_48, i8** %xx_t_mst_s_48Ptr

%val4648 = load i8*, i8** %xx_t_mst_s_48Ptr
%var4649 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4650 = bitcast [2 x i8]* @gsxtmnanovg65 to i8*

%val4651 = call i32 (i8*,i8*, ...) @sprintf(i8* %val4648, i8* %var4649, i8* %var4650)
%val4652 = load i8*, i8** %xx_t_mst_s_48Ptr
%res4653 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val4652)
%res4654 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res4644, %String* %res4653)

; let value assignment
%res11 = select i1 true, %String* %res4654, %String* %res4654
store %String* %res11, %String** %res11Ptr

%oldzone4657 = call %mzone* @llvm_pop_zone_stack()
%newzone4658 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr4659 = bitcast %mzone* %newzone4658 to i8*
store i8* %zone_ptr4659, i8** %_impzPtr

; let value assignment
%zone11 = select i1 true, %mzone* %oldzone4657, %mzone* %oldzone4657
store %mzone* %zone11, %mzone** %zone11Ptr

%res4662 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz11 = select i1 true, %mzone* %res4662, %mzone* %res4662
store %mzone* %newz11, %mzone** %newz11Ptr

%tzone4669 = load i8*, i8** %_impzPtr
%zone4670 = bitcast i8* %tzone4669 to %mzone*

; let assign value to symbol rescopy11
%rescopy11Ptr = alloca %String*
%tzone4675 = load i8*, i8** %_impzPtr
%zone4676 = bitcast i8* %tzone4675 to %mzone*

; let assign value to symbol hook_s_49
%hook_s_49Ptr = alloca {i64,i8*,i8*}*
%tzone4678 = load i8*, i8** %_impzPtr
%zone4679 = bitcast i8* %tzone4678 to %mzone*

; let assign value to symbol f_s_50
%f_s_50Ptr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val4665 = load %String*, %String** %res11Ptr
%val4666 = load %mzone*, %mzone** %zone11Ptr
%val4667 = load %mzone*, %mzone** %newz11Ptr
%res4668 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val4665, %mzone* %val4666, %mzone* %val4667)

; let value assignment
%rescopy11 = select i1 true, %String* %res4668, %String* %res4668
store %String* %rescopy11, %String** %rescopy11Ptr

%val4671 = load %mzone*, %mzone** %zone11Ptr
; tuple ref
%val4672 = getelementptr %mzone, %mzone* %val4671, i64 0, i32 4
%val4673 = load i8*, i8** %val4672
%val4674 = bitcast i8* %val4673 to {i64,i8*,i8*}*

; let value assignment
%hook_s_49 = select i1 true, {i64,i8*,i8*}* %val4674, {i64,i8*,i8*}* %val4674
store {i64,i8*,i8*}* %hook_s_49, {i64,i8*,i8*}** %hook_s_49Ptr

%null4677 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f_s_50 = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null4677, {i8*, i8*, void (i8*, i8*)*}** %null4677
store {i8*, i8*, void (i8*, i8*)*}** %f_s_50, {i8*, i8*, void (i8*, i8*)*}*** %f_s_50Ptr

; promote local stack var allocations
%tzone4715 = load i8*, i8** %_impzPtr
%zone4716 = bitcast i8* %tzone4715 to %mzone*
%ifptr4705 = alloca i1
%ifptr4681 = alloca i1
; while loop
%val4682 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_49Ptr
%val4683 = icmp eq {i64,i8*,i8*}* %val4682, null
br i1 %val4683, label %then4681, label %else4681

then4681:
%res4684 = call ccc i1 @impc_false()
store i1 %res4684, i1* %ifptr4681
br label %ifcont4681

else4681:
%res4685 = call ccc i1 @impc_true()
store i1 %res4685, i1* %ifptr4681
br label %ifcont4681

ifcont4681:
%ifres4686 = load i1, i1* %ifptr4681

br i1 %ifres4686, label %loop4680, label %after4680

loop4680:
; do set!
%val4687 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_49Ptr
; tuple ref
%val4688 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val4687, i64 0, i32 1
%val4689 = load i8*, i8** %val4688
%val4690 = bitcast i8* %val4689 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val4690, {i8*, i8*, void (i8*, i8*)*}*** %f_s_50Ptr

; apply closure 
%vval4691 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %f_s_50Ptr
%val4692 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval4691
%fPtr4693 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val4692, i32 0, i32 2
%ePtr4694 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val4692, i32 0, i32 1
%f4695 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr4693
%e4696 = load i8*, i8** %ePtr4694
%tzone4697 = load i8*, i8** %_impzPtr
%zone4698 = bitcast i8* %tzone4697 to %mzone*
%z4699 = bitcast %mzone* %zone4698 to i8*
tail call fastcc void %f4695(i8* %z4699, i8* %e4696)
; do set!
%val4701 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_49Ptr
; tuple ref
%val4702 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val4701, i64 0, i32 2
%val4703 = load i8*, i8** %val4702
%val4704 = bitcast i8* %val4703 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val4704, {i64,i8*,i8*}** %hook_s_49Ptr
%val4706 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_49Ptr
%val4707 = icmp eq {i64,i8*,i8*}* %val4706, null
br i1 %val4707, label %then4705, label %else4705

then4705:
%res4708 = call ccc i1 @impc_false()
store i1 %res4708, i1* %ifptr4705
br label %ifcont4705

else4705:
%res4709 = call ccc i1 @impc_true()
store i1 %res4709, i1* %ifptr4705
br label %ifcont4705

ifcont4705:
%ifres4710 = load i1, i1* %ifptr4705

br i1 %ifres4710, label %loop4680, label %after4680

after4680:
%val4712 = load %mzone*, %mzone** %zone11Ptr
call ccc void @llvm_zone_destroy(%mzone* %val4712)
%val4714 = load %String*, %String** %rescopy11Ptr
ret %String* %val4714
}
@gsxtmnanovg198 = hidden constant [93 x i8] c"toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}** @toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4736 = load i8*, i8** %_impzPtr
%zone4737 = bitcast i8* %tzone4736 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd
%dat_toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd = call i8* @llvm_zone_malloc(%mzone* %zone4737, i64 8)
%toString_adhoc_W1N0cmluZyosTlZHcGF0aCpdPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd to { i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}***
%tzone4717 = load i8*, i8** %_impzPtr
%zone4718 = bitcast i8* %tzone4717 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4718)
; malloc closure structure
%clsptr4719 = call i8* @llvm_zone_malloc(%mzone* %zone4718, i64 24)
%closure4720 = bitcast i8* %clsptr4719 to { i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}*

; malloc environment structure
%envptr4721 = call i8* @llvm_zone_malloc(%mzone* %zone4718, i64 8)
%environment4722 = bitcast i8* %envptr4721 to {{i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}***}*

; malloc closure address table
%addytable4723 = call %clsvar* @new_address_table()
%var4724 = bitcast [40 x i8]* @gsxtmnanovg196 to i8*
%var4725 = bitcast [46 x i8]* @gsxtmnanovg197 to i8*
%addytable4726 = call %clsvar* @add_address_table(%mzone* %zone4718, i8* %var4724, i32 0, i8* %var4725, i32 3, %clsvar* %addytable4723)
%address-table4727 = bitcast %clsvar* %addytable4726 to i8*

; insert table, function and environment into closure struct
%closure.table4730 = getelementptr { i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}, { i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}* %closure4720, i32 0, i32 0
store i8* %address-table4727, i8** %closure.table4730
%closure.env4731 = getelementptr { i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}, { i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}* %closure4720, i32 0, i32 1
store i8* %envptr4721, i8** %closure.env4731
%closure.func4732 = getelementptr { i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}, { i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}* %closure4720, i32 0, i32 2
store %String* (i8*, i8*, %NVGpath*)* @toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd__4416, %String* (i8*, i8*, %NVGpath*)** %closure.func4732
%closure_size4733 = call i64 @llvm_zone_mark_size(%mzone* %zone4718)
call void @llvm_zone_ptr_set_size(i8* %clsptr4719, i64 %closure_size4733)
%wrapper_ptr4734 = call i8* @llvm_zone_malloc(%mzone* %zone4718, i64 8)
%closure_wrapper4735 = bitcast i8* %wrapper_ptr4734 to { i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}**
store { i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}* %closure4720, { i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}** %closure_wrapper4735

; let value assignment
%toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd = select i1 true, { i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}** %closure_wrapper4735, { i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}** %closure_wrapper4735
store { i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}** %toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd, { i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}*** %toString_adhoc_W1N0cmluZyosTlZHcGF0aCpdPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd
%tmp_envptr4729 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}***}* %environment4722, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}*** %toString_adhoc_W1N0cmluZyosTlZHcGF0aCpdPtr, {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}**** %tmp_envptr4729


%val4738 = load {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}**, {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}*** %toString_adhoc_W1N0cmluZyosTlZHcGF0aCpdPtr
ret {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}** %val4738
}


@toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}** @toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd(%NVGpath* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGpath*)*,  %String* (i8*, i8*, %NVGpath*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGpath* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd_native(%NVGpath* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGpath*)*,  %String* (i8*, i8*, %NVGpath*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGpath* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4739 = bitcast [93 x i8]* @gsxtmnanovg198 to i8*
call i32 (i8*, ...) @printf(i8* %var4739)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGpath*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGpath*)*,  %String* (i8*, i8*, %NVGpath*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGpath* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGpath*}*
%arg_p_0 = getelementptr {%NVGpath*}, {%NVGpath*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGpath*, %NVGpath** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosTlZHcGF0aCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}*, {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}, {i8*, i8*, %String* (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %NVGpath*)*,  %String* (i8*, i8*, %NVGpath*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %NVGpath* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg199 = hidden constant [33 x i8] c"print_adhoc_W3ZvaWQsTlZHcGF0aCpd\00"
@gsxtmnanovg200 = hidden constant [42 x i8] c"{i8*, i8*, void (i8*, i8*, %NVGpath*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsTlZHcGF0aCpd__4740(i8* %_impz,i8* %_impenv, %NVGpath* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4741 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %NVGpath*)*}***}*
%print_adhoc_W3ZvaWQsTlZHcGF0aCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGpath*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGpath*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsTlZHcGF0aCpdPtr = load {i8*, i8*, void (i8*, i8*, %NVGpath*)*}***, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}**** %print_adhoc_W3ZvaWQsTlZHcGF0aCpdPtr_

; setup arguments
%xPtr = alloca %NVGpath*
store %NVGpath* %x, %NVGpath** %xPtr


%val4743 = load %NVGpath*, %NVGpath** %xPtr
%val4744 = icmp eq %NVGpath* %val4743, null
br i1 %val4744, label %then4742, label %else4742

then4742:
%var4745 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4746 = bitcast [15 x i8]* @gsxtmnanovg194 to i8*

%val4747 = call i32 (i8*, ...) @printf(i8* %var4745, i8* %var4746)
br label %ifcont4742

else4742:
%var4749 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4750 = bitcast [10 x i8]* @gsxtmnanovg195 to i8*

%val4751 = call i32 (i8*, ...) @printf(i8* %var4749, i8* %var4750)
%val4752 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4753 = getelementptr %NVGpath, %NVGpath* %val4752, i64 0, i32 0
%val4754 = load i32, i32* %val4753
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val4754)
%var4756 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4757 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val4758 = call i32 (i8*, ...) @printf(i8* %var4756, i8* %var4757)
%val4759 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4760 = getelementptr %NVGpath, %NVGpath* %val4759, i64 0, i32 1
%val4761 = load i32, i32* %val4760
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val4761)
%var4763 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4764 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val4765 = call i32 (i8*, ...) @printf(i8* %var4763, i8* %var4764)
%val4766 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4767 = getelementptr %NVGpath, %NVGpath* %val4766, i64 0, i32 2
%val4768 = load i8, i8* %val4767
call fastcc void @print_adhoc_W3ZvaWQsaThd(i8 %val4768)
%var4770 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4771 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val4772 = call i32 (i8*, ...) @printf(i8* %var4770, i8* %var4771)
%val4773 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4774 = getelementptr %NVGpath, %NVGpath* %val4773, i64 0, i32 3
%val4775 = load i32, i32* %val4774
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val4775)
%var4777 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4778 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val4779 = call i32 (i8*, ...) @printf(i8* %var4777, i8* %var4778)
%val4780 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4781 = getelementptr %NVGpath, %NVGpath* %val4780, i64 0, i32 4
%val4782 = load %NVGvertex*, %NVGvertex** %val4781
call fastcc void @print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0(%NVGvertex* %val4782)
%var4784 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4785 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val4786 = call i32 (i8*, ...) @printf(i8* %var4784, i8* %var4785)
%val4787 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4788 = getelementptr %NVGpath, %NVGpath* %val4787, i64 0, i32 5
%val4789 = load i32, i32* %val4788
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val4789)
%var4791 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4792 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val4793 = call i32 (i8*, ...) @printf(i8* %var4791, i8* %var4792)
%val4794 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4795 = getelementptr %NVGpath, %NVGpath* %val4794, i64 0, i32 6
%val4796 = load %NVGvertex*, %NVGvertex** %val4795
call fastcc void @print_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0(%NVGvertex* %val4796)
%var4798 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4799 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val4800 = call i32 (i8*, ...) @printf(i8* %var4798, i8* %var4799)
%val4801 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4802 = getelementptr %NVGpath, %NVGpath* %val4801, i64 0, i32 7
%val4803 = load i32, i32* %val4802
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val4803)
%var4805 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4806 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val4807 = call i32 (i8*, ...) @printf(i8* %var4805, i8* %var4806)
%val4808 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4809 = getelementptr %NVGpath, %NVGpath* %val4808, i64 0, i32 8
%val4810 = load i32, i32* %val4809
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val4810)
%var4812 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4813 = bitcast [2 x i8]* @gsxtmnanovg64 to i8*

%val4814 = call i32 (i8*, ...) @printf(i8* %var4812, i8* %var4813)
%val4815 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4816 = getelementptr %NVGpath, %NVGpath* %val4815, i64 0, i32 9
%val4817 = load i32, i32* %val4816
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val4817)
%var4819 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var4820 = bitcast [2 x i8]* @gsxtmnanovg65 to i8*

%val4821 = call i32 (i8*, ...) @printf(i8* %var4819, i8* %var4820)
br label %ifcont4742

ifcont4742:
ret void
}
@gsxtmnanovg201 = hidden constant [86 x i8] c"print_adhoc_W3ZvaWQsTlZHcGF0aCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %NVGpath*)*}** @print_adhoc_W3ZvaWQsTlZHcGF0aCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4843 = load i8*, i8** %_impzPtr
%zone4844 = bitcast i8* %tzone4843 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsTlZHcGF0aCpd
%dat_print_adhoc_W3ZvaWQsTlZHcGF0aCpd = call i8* @llvm_zone_malloc(%mzone* %zone4844, i64 8)
%print_adhoc_W3ZvaWQsTlZHcGF0aCpdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsTlZHcGF0aCpd to { i8*, i8*, void (i8*, i8*, %NVGpath*)*}***
%tzone4824 = load i8*, i8** %_impzPtr
%zone4825 = bitcast i8* %tzone4824 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4825)
; malloc closure structure
%clsptr4826 = call i8* @llvm_zone_malloc(%mzone* %zone4825, i64 24)
%closure4827 = bitcast i8* %clsptr4826 to { i8*, i8*, void (i8*, i8*, %NVGpath*)*}*

; malloc environment structure
%envptr4828 = call i8* @llvm_zone_malloc(%mzone* %zone4825, i64 8)
%environment4829 = bitcast i8* %envptr4828 to {{i8*, i8*, void (i8*, i8*, %NVGpath*)*}***}*

; malloc closure address table
%addytable4830 = call %clsvar* @new_address_table()
%var4831 = bitcast [33 x i8]* @gsxtmnanovg199 to i8*
%var4832 = bitcast [42 x i8]* @gsxtmnanovg200 to i8*
%addytable4833 = call %clsvar* @add_address_table(%mzone* %zone4825, i8* %var4831, i32 0, i8* %var4832, i32 3, %clsvar* %addytable4830)
%address-table4834 = bitcast %clsvar* %addytable4833 to i8*

; insert table, function and environment into closure struct
%closure.table4837 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGpath*)*}, { i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure4827, i32 0, i32 0
store i8* %address-table4834, i8** %closure.table4837
%closure.env4838 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGpath*)*}, { i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure4827, i32 0, i32 1
store i8* %envptr4828, i8** %closure.env4838
%closure.func4839 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGpath*)*}, { i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure4827, i32 0, i32 2
store void (i8*, i8*, %NVGpath*)* @print_adhoc_W3ZvaWQsTlZHcGF0aCpd__4740, void (i8*, i8*, %NVGpath*)** %closure.func4839
%closure_size4840 = call i64 @llvm_zone_mark_size(%mzone* %zone4825)
call void @llvm_zone_ptr_set_size(i8* %clsptr4826, i64 %closure_size4840)
%wrapper_ptr4841 = call i8* @llvm_zone_malloc(%mzone* %zone4825, i64 8)
%closure_wrapper4842 = bitcast i8* %wrapper_ptr4841 to { i8*, i8*, void (i8*, i8*, %NVGpath*)*}**
store { i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure4827, { i8*, i8*, void (i8*, i8*, %NVGpath*)*}** %closure_wrapper4842

; let value assignment
%print_adhoc_W3ZvaWQsTlZHcGF0aCpd = select i1 true, { i8*, i8*, void (i8*, i8*, %NVGpath*)*}** %closure_wrapper4842, { i8*, i8*, void (i8*, i8*, %NVGpath*)*}** %closure_wrapper4842
store { i8*, i8*, void (i8*, i8*, %NVGpath*)*}** %print_adhoc_W3ZvaWQsTlZHcGF0aCpd, { i8*, i8*, void (i8*, i8*, %NVGpath*)*}*** %print_adhoc_W3ZvaWQsTlZHcGF0aCpdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsTlZHcGF0aCpd
%tmp_envptr4836 = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGpath*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGpath*)*}***}* %environment4829, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %NVGpath*)*}*** %print_adhoc_W3ZvaWQsTlZHcGF0aCpdPtr, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}**** %tmp_envptr4836


%val4845 = load {i8*, i8*, void (i8*, i8*, %NVGpath*)*}**, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}*** %print_adhoc_W3ZvaWQsTlZHcGF0aCpdPtr
ret {i8*, i8*, void (i8*, i8*, %NVGpath*)*}** %val4845
}


@print_adhoc_W3ZvaWQsTlZHcGF0aCpd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsTlZHcGF0aCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHcGF0aCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHcGF0aCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %NVGpath*)*}** @print_adhoc_W3ZvaWQsTlZHcGF0aCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %NVGpath*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHcGF0aCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsTlZHcGF0aCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHcGF0aCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsTlZHcGF0aCpd(%NVGpath* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHcGF0aCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGpath*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGpath*)*}*, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpath*)*}, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpath*)*}, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGpath*)*,  void (i8*, i8*, %NVGpath*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGpath* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHcGF0aCpd_native(%NVGpath* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHcGF0aCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGpath*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGpath*)*}*, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpath*)*}, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpath*)*}, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGpath*)*,  void (i8*, i8*, %NVGpath*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGpath* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsTlZHcGF0aCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4846 = bitcast [86 x i8]* @gsxtmnanovg201 to i8*
call i32 (i8*, ...) @printf(i8* %var4846)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGpath*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHcGF0aCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGpath*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGpath*)*}*, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpath*)*}, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpath*)*}, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGpath*)*,  void (i8*, i8*, %NVGpath*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGpath* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsTlZHcGF0aCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGpath*}*
%arg_p_0 = getelementptr {%NVGpath*}, {%NVGpath*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGpath*, %NVGpath** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsTlZHcGF0aCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGpath*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGpath*)*}*, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpath*)*}, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpath*)*}, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGpath*)*,  void (i8*, i8*, %NVGpath*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGpath* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg202 = hidden constant [102 x i8] c"NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0\00"
@gsxtmnanovg203 = hidden constant [100 x i8] c"{i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**\00"
define dllexport fastcc %NVGpath @NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0__4847(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i8 %arg_2, i32 %arg_3, %NVGvertex* %arg_4, i32 %arg_5, %NVGvertex* %arg_6, i32 %arg_7, i32 %arg_8, i32 %arg_9) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4848 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}*
%NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}, {{i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0Ptr = load {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***, {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**** %NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i8
store i8 %arg_2, i8* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca %NVGvertex*
store %NVGvertex* %arg_4, %NVGvertex** %arg_4Ptr
%arg_5Ptr = alloca i32
store i32 %arg_5, i32* %arg_5Ptr
%arg_6Ptr = alloca %NVGvertex*
store %NVGvertex* %arg_6, %NVGvertex** %arg_6Ptr
%arg_7Ptr = alloca i32
store i32 %arg_7, i32* %arg_7Ptr
%arg_8Ptr = alloca i32
store i32 %arg_8, i32* %arg_8Ptr
%arg_9Ptr = alloca i32
store i32 %arg_9, i32* %arg_9Ptr


%tzone4850 = load i8*, i8** %_impzPtr
%zone4851 = bitcast i8* %tzone4850 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGpath*
%dat4849 = alloca %NVGpath, align 16

; let value assignment
%obj = select i1 true, %NVGpath* %dat4849, %NVGpath* %dat4849
store %NVGpath* %obj, %NVGpath** %objPtr

%val4852 = load %NVGpath*, %NVGpath** %objPtr
%val4853 = load i32, i32* %arg_0Ptr
; set tuple
%val4854 = getelementptr %NVGpath, %NVGpath* %val4852, i64 0, i32 0
store i32 %val4853, i32* %val4854
%val4855 = load %NVGpath*, %NVGpath** %objPtr
%val4856 = load i32, i32* %arg_1Ptr
; set tuple
%val4857 = getelementptr %NVGpath, %NVGpath* %val4855, i64 0, i32 1
store i32 %val4856, i32* %val4857
%val4858 = load %NVGpath*, %NVGpath** %objPtr
%val4859 = load i8, i8* %arg_2Ptr
; set tuple
%val4860 = getelementptr %NVGpath, %NVGpath* %val4858, i64 0, i32 2
store i8 %val4859, i8* %val4860
%val4861 = load %NVGpath*, %NVGpath** %objPtr
%val4862 = load i32, i32* %arg_3Ptr
; set tuple
%val4863 = getelementptr %NVGpath, %NVGpath* %val4861, i64 0, i32 3
store i32 %val4862, i32* %val4863
%val4864 = load %NVGpath*, %NVGpath** %objPtr
%val4865 = load %NVGvertex*, %NVGvertex** %arg_4Ptr
; set tuple
%val4866 = getelementptr %NVGpath, %NVGpath* %val4864, i64 0, i32 4
store %NVGvertex* %val4865, %NVGvertex** %val4866
%val4867 = load %NVGpath*, %NVGpath** %objPtr
%val4868 = load i32, i32* %arg_5Ptr
; set tuple
%val4869 = getelementptr %NVGpath, %NVGpath* %val4867, i64 0, i32 5
store i32 %val4868, i32* %val4869
%val4870 = load %NVGpath*, %NVGpath** %objPtr
%val4871 = load %NVGvertex*, %NVGvertex** %arg_6Ptr
; set tuple
%val4872 = getelementptr %NVGpath, %NVGpath* %val4870, i64 0, i32 6
store %NVGvertex* %val4871, %NVGvertex** %val4872
%val4873 = load %NVGpath*, %NVGpath** %objPtr
%val4874 = load i32, i32* %arg_7Ptr
; set tuple
%val4875 = getelementptr %NVGpath, %NVGpath* %val4873, i64 0, i32 7
store i32 %val4874, i32* %val4875
%val4876 = load %NVGpath*, %NVGpath** %objPtr
%val4877 = load i32, i32* %arg_8Ptr
; set tuple
%val4878 = getelementptr %NVGpath, %NVGpath* %val4876, i64 0, i32 8
store i32 %val4877, i32* %val4878
%val4879 = load %NVGpath*, %NVGpath** %objPtr
%val4880 = load i32, i32* %arg_9Ptr
; set tuple
%val4881 = getelementptr %NVGpath, %NVGpath* %val4879, i64 0, i32 9
store i32 %val4880, i32* %val4881
%val4882 = load %NVGpath*, %NVGpath** %objPtr
; pointer ref
%val4883 = getelementptr %NVGpath, %NVGpath* %val4882, i64 0
%val4884 = load %NVGpath, %NVGpath* %val4883
ret %NVGpath %val4884
}
@gsxtmnanovg204 = hidden constant [155 x i8] c"NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** @NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4904 = load i8*, i8** %_impzPtr
%zone4905 = bitcast i8* %tzone4904 to %mzone*

; let assign value to symbol NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0
%dat_NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone4905, i64 8)
%NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0Ptr = bitcast i8* %dat_NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0 to { i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***
%tzone4885 = load i8*, i8** %_impzPtr
%zone4886 = bitcast i8* %tzone4885 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4886)
; malloc closure structure
%clsptr4887 = call i8* @llvm_zone_malloc(%mzone* %zone4886, i64 24)
%closure4888 = bitcast i8* %clsptr4887 to { i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*

; malloc environment structure
%envptr4889 = call i8* @llvm_zone_malloc(%mzone* %zone4886, i64 8)
%environment4890 = bitcast i8* %envptr4889 to {{i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}*

; malloc closure address table
%addytable4891 = call %clsvar* @new_address_table()
%var4892 = bitcast [102 x i8]* @gsxtmnanovg202 to i8*
%var4893 = bitcast [100 x i8]* @gsxtmnanovg203 to i8*
%addytable4894 = call %clsvar* @add_address_table(%mzone* %zone4886, i8* %var4892, i32 0, i8* %var4893, i32 3, %clsvar* %addytable4891)
%address-table4895 = bitcast %clsvar* %addytable4894 to i8*

; insert table, function and environment into closure struct
%closure.table4898 = getelementptr { i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, { i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure4888, i32 0, i32 0
store i8* %address-table4895, i8** %closure.table4898
%closure.env4899 = getelementptr { i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, { i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure4888, i32 0, i32 1
store i8* %envptr4889, i8** %closure.env4899
%closure.func4900 = getelementptr { i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, { i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure4888, i32 0, i32 2
store %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)* @NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0__4847, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)** %closure.func4900
%closure_size4901 = call i64 @llvm_zone_mark_size(%mzone* %zone4886)
call void @llvm_zone_ptr_set_size(i8* %clsptr4887, i64 %closure_size4901)
%wrapper_ptr4902 = call i8* @llvm_zone_malloc(%mzone* %zone4886, i64 8)
%closure_wrapper4903 = bitcast i8* %wrapper_ptr4902 to { i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**
store { i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure4888, { i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_wrapper4903

; let value assignment
%NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0 = select i1 true, { i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_wrapper4903, { i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_wrapper4903
store { i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0, { i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*** %NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0
%tmp_envptr4897 = getelementptr {{i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}, {{i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}***}* %environment4890, i32 0, i32 0
store {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*** %NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0Ptr, {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**** %tmp_envptr4897


%val4906 = load {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**, {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*** %NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0Ptr
ret {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %val4906
}


@NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** @NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGpath @NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0(i32 %arg_0,i32 %arg_1,i8 %arg_2,i32 %arg_3,%NVGvertex* %arg_4,i32 %arg_5,%NVGvertex* %arg_6,i32 %arg_7,i32 %arg_8,i32 %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*, {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*,  %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8 %arg_2, i32 %arg_3, %NVGvertex* %arg_4, i32 %arg_5, %NVGvertex* %arg_6, i32 %arg_7, i32 %arg_8, i32 %arg_9)
ret %NVGpath %result
}


define dllexport ccc %NVGpath @NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0_native(i32 %arg_0,i32 %arg_1,i8 %arg_2,i32 %arg_3,%NVGvertex* %arg_4,i32 %arg_5,%NVGvertex* %arg_6,i32 %arg_7,i32 %arg_8,i32 %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*, {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*,  %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8 %arg_2, i32 %arg_3, %NVGvertex* %arg_4, i32 %arg_5, %NVGvertex* %arg_6, i32 %arg_7, i32 %arg_8, i32 %arg_9)
ret %NVGpath %result
}


define dllexport ccc void @NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}*
%arg_p_0 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i8, i8* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load %NVGvertex*, %NVGvertex** %arg_p_4
%arg_p_5 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
%arg_p_6 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 6
%arg_6 = load %NVGvertex*, %NVGvertex** %arg_p_6
%arg_p_7 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 7
%arg_7 = load i32, i32* %arg_p_7
%arg_p_8 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 8
%arg_8 = load i32, i32* %arg_p_8
%arg_p_9 = getelementptr {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}, {i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32}* %fstruct, i32 0, i32 9
%arg_9 = load i32, i32* %arg_p_9
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @NVGpath_val_adhoc_W05WR3BhdGgsaTMyLGkzMixpOCxpMzIsTlZHdmVydGV4KixpMzIsTlZHdmVydGV4KixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}**
%closure = load {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}*, {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}, {i8*, i8*, %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)*,  %NVGpath (i8*, i8*, i32, i32, i8, i32, %NVGvertex*, i32, %NVGvertex*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8 %arg_2, i32 %arg_3, %NVGvertex* %arg_4, i32 %arg_5, %NVGvertex* %arg_6, i32 %arg_7, i32 %arg_8, i32 %arg_9)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg205 = hidden constant [39 x i8] c"hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ\00"
@gsxtmnanovg206 = hidden constant [47 x i8] c"{i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}**\00"
define dllexport fastcc %NVGpath* @hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ__4917(i8* %_impz,i8* %_impenv, %NVGpath* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4918 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}***}*
%hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQPtr_ = getelementptr {{i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}***}, {{i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQPtr = load {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}***, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}**** %hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQPtr_

; setup arguments
%xPtr = alloca %NVGpath*
store %NVGpath* %x, %NVGpath** %xPtr


%tzone4921 = load i8*, i8** %_impzPtr
%zone4922 = bitcast i8* %tzone4921 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGpath*
%dat4919 = call i8* @malloc(i64 56)
call i8* @memset(i8* %dat4919, i32 0, i64 56)
%val4920 = bitcast i8* %dat4919 to %NVGpath*

; let value assignment
%obj = select i1 true, %NVGpath* %val4920, %NVGpath* %val4920
store %NVGpath* %obj, %NVGpath** %objPtr

; promote local stack var allocations
%tzone4996 = load i8*, i8** %_impzPtr
%zone4997 = bitcast i8* %tzone4996 to %mzone*
%ifptr4964 = alloca %NVGvertex*
%ifptr4965 = alloca i1
%ifptr4943 = alloca %NVGvertex*
%ifptr4944 = alloca i1
%val4923 = load %NVGpath*, %NVGpath** %objPtr
%val4924 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4925 = getelementptr %NVGpath, %NVGpath* %val4924, i64 0, i32 0
%val4926 = load i32, i32* %val4925
; set tuple
%val4927 = getelementptr %NVGpath, %NVGpath* %val4923, i64 0, i32 0
store i32 %val4926, i32* %val4927
%val4928 = load %NVGpath*, %NVGpath** %objPtr
%val4929 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4930 = getelementptr %NVGpath, %NVGpath* %val4929, i64 0, i32 1
%val4931 = load i32, i32* %val4930
; set tuple
%val4932 = getelementptr %NVGpath, %NVGpath* %val4928, i64 0, i32 1
store i32 %val4931, i32* %val4932
%val4933 = load %NVGpath*, %NVGpath** %objPtr
%val4934 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4935 = getelementptr %NVGpath, %NVGpath* %val4934, i64 0, i32 2
%val4936 = load i8, i8* %val4935
; set tuple
%val4937 = getelementptr %NVGpath, %NVGpath* %val4933, i64 0, i32 2
store i8 %val4936, i8* %val4937
%val4938 = load %NVGpath*, %NVGpath** %objPtr
%val4939 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4940 = getelementptr %NVGpath, %NVGpath* %val4939, i64 0, i32 3
%val4941 = load i32, i32* %val4940
; set tuple
%val4942 = getelementptr %NVGpath, %NVGpath* %val4938, i64 0, i32 3
store i32 %val4941, i32* %val4942
%val4945 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4946 = getelementptr %NVGpath, %NVGpath* %val4945, i64 0, i32 4
%val4947 = load %NVGvertex*, %NVGvertex** %val4946
%val4948 = icmp eq %NVGvertex* %val4947, null
br i1 %val4948, label %then4944, label %else4944

then4944:
%res4949 = call ccc i1 @impc_false()
store i1 %res4949, i1* %ifptr4944
br label %ifcont4944

else4944:
%res4950 = call ccc i1 @impc_true()
store i1 %res4950, i1* %ifptr4944
br label %ifcont4944

ifcont4944:
%ifres4951 = load i1, i1* %ifptr4944

br i1 %ifres4951, label %then4943, label %else4943

then4943:
%val4952 = load %NVGpath*, %NVGpath** %objPtr
%val4953 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4954 = getelementptr %NVGpath, %NVGpath* %val4953, i64 0, i32 4
%val4955 = load %NVGvertex*, %NVGvertex** %val4954
%res4956 = call fastcc %NVGvertex* @hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0(%NVGvertex* %val4955)
; set tuple
%val4957 = getelementptr %NVGpath, %NVGpath* %val4952, i64 0, i32 4
store %NVGvertex* %res4956, %NVGvertex** %val4957
store %NVGvertex* %res4956, %NVGvertex** %ifptr4943
br label %ifcont4943

else4943:
br label %ifcont4943

ifcont4943:
%ifres4958 = load %NVGvertex*, %NVGvertex** %ifptr4943

%val4959 = load %NVGpath*, %NVGpath** %objPtr
%val4960 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4961 = getelementptr %NVGpath, %NVGpath* %val4960, i64 0, i32 5
%val4962 = load i32, i32* %val4961
; set tuple
%val4963 = getelementptr %NVGpath, %NVGpath* %val4959, i64 0, i32 5
store i32 %val4962, i32* %val4963
%val4966 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4967 = getelementptr %NVGpath, %NVGpath* %val4966, i64 0, i32 6
%val4968 = load %NVGvertex*, %NVGvertex** %val4967
%val4969 = icmp eq %NVGvertex* %val4968, null
br i1 %val4969, label %then4965, label %else4965

then4965:
%res4970 = call ccc i1 @impc_false()
store i1 %res4970, i1* %ifptr4965
br label %ifcont4965

else4965:
%res4971 = call ccc i1 @impc_true()
store i1 %res4971, i1* %ifptr4965
br label %ifcont4965

ifcont4965:
%ifres4972 = load i1, i1* %ifptr4965

br i1 %ifres4972, label %then4964, label %else4964

then4964:
%val4973 = load %NVGpath*, %NVGpath** %objPtr
%val4974 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4975 = getelementptr %NVGpath, %NVGpath* %val4974, i64 0, i32 6
%val4976 = load %NVGvertex*, %NVGvertex** %val4975
%res4977 = call fastcc %NVGvertex* @hcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kl0(%NVGvertex* %val4976)
; set tuple
%val4978 = getelementptr %NVGpath, %NVGpath* %val4973, i64 0, i32 6
store %NVGvertex* %res4977, %NVGvertex** %val4978
store %NVGvertex* %res4977, %NVGvertex** %ifptr4964
br label %ifcont4964

else4964:
br label %ifcont4964

ifcont4964:
%ifres4979 = load %NVGvertex*, %NVGvertex** %ifptr4964

%val4980 = load %NVGpath*, %NVGpath** %objPtr
%val4981 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4982 = getelementptr %NVGpath, %NVGpath* %val4981, i64 0, i32 7
%val4983 = load i32, i32* %val4982
; set tuple
%val4984 = getelementptr %NVGpath, %NVGpath* %val4980, i64 0, i32 7
store i32 %val4983, i32* %val4984
%val4985 = load %NVGpath*, %NVGpath** %objPtr
%val4986 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4987 = getelementptr %NVGpath, %NVGpath* %val4986, i64 0, i32 8
%val4988 = load i32, i32* %val4987
; set tuple
%val4989 = getelementptr %NVGpath, %NVGpath* %val4985, i64 0, i32 8
store i32 %val4988, i32* %val4989
%val4990 = load %NVGpath*, %NVGpath** %objPtr
%val4991 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val4992 = getelementptr %NVGpath, %NVGpath* %val4991, i64 0, i32 9
%val4993 = load i32, i32* %val4992
; set tuple
%val4994 = getelementptr %NVGpath, %NVGpath* %val4990, i64 0, i32 9
store i32 %val4993, i32* %val4994
%val4995 = load %NVGpath*, %NVGpath** %objPtr
ret %NVGpath* %val4995
}
@gsxtmnanovg207 = hidden constant [92 x i8] c"hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}** @hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5017 = load i8*, i8** %_impzPtr
%zone5018 = bitcast i8* %tzone5017 to %mzone*

; let assign value to symbol hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ
%dat_hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone5018, i64 8)
%hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQPtr = bitcast i8* %dat_hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ to { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}***
%tzone4998 = load i8*, i8** %_impzPtr
%zone4999 = bitcast i8* %tzone4998 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4999)
; malloc closure structure
%clsptr5000 = call i8* @llvm_zone_malloc(%mzone* %zone4999, i64 24)
%closure5001 = bitcast i8* %clsptr5000 to { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}*

; malloc environment structure
%envptr5002 = call i8* @llvm_zone_malloc(%mzone* %zone4999, i64 8)
%environment5003 = bitcast i8* %envptr5002 to {{i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}***}*

; malloc closure address table
%addytable5004 = call %clsvar* @new_address_table()
%var5005 = bitcast [39 x i8]* @gsxtmnanovg205 to i8*
%var5006 = bitcast [47 x i8]* @gsxtmnanovg206 to i8*
%addytable5007 = call %clsvar* @add_address_table(%mzone* %zone4999, i8* %var5005, i32 0, i8* %var5006, i32 3, %clsvar* %addytable5004)
%address-table5008 = bitcast %clsvar* %addytable5007 to i8*

; insert table, function and environment into closure struct
%closure.table5011 = getelementptr { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}, { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}* %closure5001, i32 0, i32 0
store i8* %address-table5008, i8** %closure.table5011
%closure.env5012 = getelementptr { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}, { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}* %closure5001, i32 0, i32 1
store i8* %envptr5002, i8** %closure.env5012
%closure.func5013 = getelementptr { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}, { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}* %closure5001, i32 0, i32 2
store %NVGpath* (i8*, i8*, %NVGpath*)* @hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ__4917, %NVGpath* (i8*, i8*, %NVGpath*)** %closure.func5013
%closure_size5014 = call i64 @llvm_zone_mark_size(%mzone* %zone4999)
call void @llvm_zone_ptr_set_size(i8* %clsptr5000, i64 %closure_size5014)
%wrapper_ptr5015 = call i8* @llvm_zone_malloc(%mzone* %zone4999, i64 8)
%closure_wrapper5016 = bitcast i8* %wrapper_ptr5015 to { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}**
store { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}* %closure5001, { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}** %closure_wrapper5016

; let value assignment
%hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ = select i1 true, { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}** %closure_wrapper5016, { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}** %closure_wrapper5016
store { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}** %hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ, { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}*** %hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ
%tmp_envptr5010 = getelementptr {{i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}***}, {{i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}***}* %environment5003, i32 0, i32 0
store {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}*** %hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQPtr, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}**** %tmp_envptr5010


%val5019 = load {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}**, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}*** %hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQPtr
ret {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}** %val5019
}


@hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}** @hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGpath* @hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ(%NVGpath* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}**
%closure = load {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}*, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath* (i8*, i8*, %NVGpath*)*,  %NVGpath* (i8*, i8*, %NVGpath*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath* %ff(i8* %_impz, i8* %ee, %NVGpath* %arg_0)
ret %NVGpath* %result
}


define dllexport ccc %NVGpath* @hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ_native(%NVGpath* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}**
%closure = load {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}*, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath* (i8*, i8*, %NVGpath*)*,  %NVGpath* (i8*, i8*, %NVGpath*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath* %ff(i8* %_impz, i8* %ee, %NVGpath* %arg_0)
ret %NVGpath* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5020 = bitcast [92 x i8]* @gsxtmnanovg207 to i8*
call i32 (i8*, ...) @printf(i8* %var5020)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGpath*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}**
%closure = load {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}*, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath* (i8*, i8*, %NVGpath*)*,  %NVGpath* (i8*, i8*, %NVGpath*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath* %ff(i8* %_impz, i8* %ee, %NVGpath* %arg_0)
%tmpres = bitcast %NVGpath* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGpath*}*
%arg_p_0 = getelementptr {%NVGpath*}, {%NVGpath*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGpath*, %NVGpath** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}**
%closure = load {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}*, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath* (i8*, i8*, %NVGpath*)*,  %NVGpath* (i8*, i8*, %NVGpath*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath* %ff(i8* %_impz, i8* %ee, %NVGpath* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg208 = hidden constant [33 x i8] c"hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd__5021(i8* %_impz,i8* %_impenv, %NVGpath* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5022 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %NVGpath*)*}***}*
%hfree_adhoc_W3ZvaWQsTlZHcGF0aCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGpath*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGpath*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsTlZHcGF0aCpdPtr = load {i8*, i8*, void (i8*, i8*, %NVGpath*)*}***, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}**** %hfree_adhoc_W3ZvaWQsTlZHcGF0aCpdPtr_

; setup arguments
%xPtr = alloca %NVGpath*
store %NVGpath* %x, %NVGpath** %xPtr

; promote local stack var allocations
%tzone5053 = load i8*, i8** %_impzPtr
%zone5054 = bitcast i8* %tzone5053 to %mzone*
%ifptr5037 = alloca i1
%ifptr5024 = alloca i1

%val5025 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val5026 = getelementptr %NVGpath, %NVGpath* %val5025, i64 0, i32 4
%val5027 = load %NVGvertex*, %NVGvertex** %val5026
%val5028 = icmp eq %NVGvertex* %val5027, null
br i1 %val5028, label %then5024, label %else5024

then5024:
%res5029 = call ccc i1 @impc_false()
store i1 %res5029, i1* %ifptr5024
br label %ifcont5024

else5024:
%res5030 = call ccc i1 @impc_true()
store i1 %res5030, i1* %ifptr5024
br label %ifcont5024

ifcont5024:
%ifres5031 = load i1, i1* %ifptr5024

br i1 %ifres5031, label %then5023, label %else5023

then5023:
%val5032 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val5033 = getelementptr %NVGpath, %NVGpath* %val5032, i64 0, i32 4
%val5034 = load %NVGvertex*, %NVGvertex** %val5033
call fastcc void @hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0(%NVGvertex* %val5034)
br label %ifcont5023

else5023:
br label %ifcont5023

ifcont5023:
%val5038 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val5039 = getelementptr %NVGpath, %NVGpath* %val5038, i64 0, i32 6
%val5040 = load %NVGvertex*, %NVGvertex** %val5039
%val5041 = icmp eq %NVGvertex* %val5040, null
br i1 %val5041, label %then5037, label %else5037

then5037:
%res5042 = call ccc i1 @impc_false()
store i1 %res5042, i1* %ifptr5037
br label %ifcont5037

else5037:
%res5043 = call ccc i1 @impc_true()
store i1 %res5043, i1* %ifptr5037
br label %ifcont5037

ifcont5037:
%ifres5044 = load i1, i1* %ifptr5037

br i1 %ifres5044, label %then5036, label %else5036

then5036:
%val5045 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val5046 = getelementptr %NVGpath, %NVGpath* %val5045, i64 0, i32 6
%val5047 = load %NVGvertex*, %NVGvertex** %val5046
call fastcc void @hfree_adhoc_W3ZvaWQsTlZHdmVydGV4Kl0(%NVGvertex* %val5047)
br label %ifcont5036

else5036:
br label %ifcont5036

ifcont5036:
%val5049 = load %NVGpath*, %NVGpath** %xPtr
%val5050 = bitcast %NVGpath* %val5049 to i8*
call ccc void @free(i8* %val5050)
ret void
}
@gsxtmnanovg209 = hidden constant [86 x i8] c"hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %NVGpath*)*}** @hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5074 = load i8*, i8** %_impzPtr
%zone5075 = bitcast i8* %tzone5074 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd
%dat_hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd = call i8* @llvm_zone_malloc(%mzone* %zone5075, i64 8)
%hfree_adhoc_W3ZvaWQsTlZHcGF0aCpdPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd to { i8*, i8*, void (i8*, i8*, %NVGpath*)*}***
%tzone5055 = load i8*, i8** %_impzPtr
%zone5056 = bitcast i8* %tzone5055 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5056)
; malloc closure structure
%clsptr5057 = call i8* @llvm_zone_malloc(%mzone* %zone5056, i64 24)
%closure5058 = bitcast i8* %clsptr5057 to { i8*, i8*, void (i8*, i8*, %NVGpath*)*}*

; malloc environment structure
%envptr5059 = call i8* @llvm_zone_malloc(%mzone* %zone5056, i64 8)
%environment5060 = bitcast i8* %envptr5059 to {{i8*, i8*, void (i8*, i8*, %NVGpath*)*}***}*

; malloc closure address table
%addytable5061 = call %clsvar* @new_address_table()
%var5062 = bitcast [33 x i8]* @gsxtmnanovg208 to i8*
%var5063 = bitcast [42 x i8]* @gsxtmnanovg200 to i8*
%addytable5064 = call %clsvar* @add_address_table(%mzone* %zone5056, i8* %var5062, i32 0, i8* %var5063, i32 3, %clsvar* %addytable5061)
%address-table5065 = bitcast %clsvar* %addytable5064 to i8*

; insert table, function and environment into closure struct
%closure.table5068 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGpath*)*}, { i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure5058, i32 0, i32 0
store i8* %address-table5065, i8** %closure.table5068
%closure.env5069 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGpath*)*}, { i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure5058, i32 0, i32 1
store i8* %envptr5059, i8** %closure.env5069
%closure.func5070 = getelementptr { i8*, i8*, void (i8*, i8*, %NVGpath*)*}, { i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure5058, i32 0, i32 2
store void (i8*, i8*, %NVGpath*)* @hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd__5021, void (i8*, i8*, %NVGpath*)** %closure.func5070
%closure_size5071 = call i64 @llvm_zone_mark_size(%mzone* %zone5056)
call void @llvm_zone_ptr_set_size(i8* %clsptr5057, i64 %closure_size5071)
%wrapper_ptr5072 = call i8* @llvm_zone_malloc(%mzone* %zone5056, i64 8)
%closure_wrapper5073 = bitcast i8* %wrapper_ptr5072 to { i8*, i8*, void (i8*, i8*, %NVGpath*)*}**
store { i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure5058, { i8*, i8*, void (i8*, i8*, %NVGpath*)*}** %closure_wrapper5073

; let value assignment
%hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd = select i1 true, { i8*, i8*, void (i8*, i8*, %NVGpath*)*}** %closure_wrapper5073, { i8*, i8*, void (i8*, i8*, %NVGpath*)*}** %closure_wrapper5073
store { i8*, i8*, void (i8*, i8*, %NVGpath*)*}** %hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd, { i8*, i8*, void (i8*, i8*, %NVGpath*)*}*** %hfree_adhoc_W3ZvaWQsTlZHcGF0aCpdPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd
%tmp_envptr5067 = getelementptr {{i8*, i8*, void (i8*, i8*, %NVGpath*)*}***}, {{i8*, i8*, void (i8*, i8*, %NVGpath*)*}***}* %environment5060, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %NVGpath*)*}*** %hfree_adhoc_W3ZvaWQsTlZHcGF0aCpdPtr, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}**** %tmp_envptr5067


%val5076 = load {i8*, i8*, void (i8*, i8*, %NVGpath*)*}**, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}*** %hfree_adhoc_W3ZvaWQsTlZHcGF0aCpdPtr
ret {i8*, i8*, void (i8*, i8*, %NVGpath*)*}** %val5076
}


@hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %NVGpath*)*}** @hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %NVGpath*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd(%NVGpath* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGpath*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGpath*)*}*, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpath*)*}, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpath*)*}, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGpath*)*,  void (i8*, i8*, %NVGpath*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGpath* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd_native(%NVGpath* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGpath*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGpath*)*}*, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpath*)*}, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpath*)*}, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGpath*)*,  void (i8*, i8*, %NVGpath*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGpath* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5077 = bitcast [86 x i8]* @gsxtmnanovg209 to i8*
call i32 (i8*, ...) @printf(i8* %var5077)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGpath*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGpath*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGpath*)*}*, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpath*)*}, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpath*)*}, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGpath*)*,  void (i8*, i8*, %NVGpath*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGpath* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGpath*}*
%arg_p_0 = getelementptr {%NVGpath*}, {%NVGpath*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGpath*, %NVGpath** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsTlZHcGF0aCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %NVGpath*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %NVGpath*)*}*, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpath*)*}, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %NVGpath*)*}, {i8*, i8*, void (i8*, i8*, %NVGpath*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %NVGpath*)*,  void (i8*, i8*, %NVGpath*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %NVGpath* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg210 = hidden constant [57 x i8] c"zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd\00"
@gsxtmnanovg211 = hidden constant [65 x i8] c"{i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %NVGpath* @zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd__5078(i8* %_impz,i8* %_impenv, %NVGpath* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5079 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpdPtr = load {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}***, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpdPtr_

; setup arguments
%xPtr = alloca %NVGpath*
store %NVGpath* %x, %NVGpath** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val5081 = load %mzone*, %mzone** %fromzPtr
%val5082 = load %NVGpath*, %NVGpath** %xPtr
%val5083 = bitcast %NVGpath* %val5082 to i8*
%res5084 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val5081, i8* %val5083)
br i1 %res5084, label %then5080, label %else5080

then5080:
%val5085 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val5085)
%zone_ptr5086 = bitcast %mzone* %val5085 to i8*
store i8* %zone_ptr5086, i8** %_impzPtr
%tzone5092 = load i8*, i8** %_impzPtr
%zone5093 = bitcast i8* %tzone5092 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %NVGpath*
%tzone5088 = load i8*, i8** %_impzPtr
%zone5089 = bitcast i8* %tzone5088 to %mzone*
%dat5090 = call i8* @llvm_zone_malloc(%mzone* %zone5089, i64 56)
call i8* @memset(i8* %dat5090, i32 0, i64 56)
%val5091 = bitcast i8* %dat5090 to %NVGpath*

; let value assignment
%obj = select i1 true, %NVGpath* %val5091, %NVGpath* %val5091
store %NVGpath* %obj, %NVGpath** %objPtr

; promote local stack var allocations
%tzone5174 = load i8*, i8** %_impzPtr
%zone5175 = bitcast i8* %tzone5174 to %mzone*
%ifptr5137 = alloca %NVGvertex*
%ifptr5138 = alloca i1
%ifptr5114 = alloca %NVGvertex*
%ifptr5115 = alloca i1
%val5094 = load %NVGpath*, %NVGpath** %objPtr
%val5095 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val5096 = getelementptr %NVGpath, %NVGpath* %val5095, i64 0, i32 0
%val5097 = load i32, i32* %val5096
; set tuple
%val5098 = getelementptr %NVGpath, %NVGpath* %val5094, i64 0, i32 0
store i32 %val5097, i32* %val5098
%val5099 = load %NVGpath*, %NVGpath** %objPtr
%val5100 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val5101 = getelementptr %NVGpath, %NVGpath* %val5100, i64 0, i32 1
%val5102 = load i32, i32* %val5101
; set tuple
%val5103 = getelementptr %NVGpath, %NVGpath* %val5099, i64 0, i32 1
store i32 %val5102, i32* %val5103
%val5104 = load %NVGpath*, %NVGpath** %objPtr
%val5105 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val5106 = getelementptr %NVGpath, %NVGpath* %val5105, i64 0, i32 2
%val5107 = load i8, i8* %val5106
; set tuple
%val5108 = getelementptr %NVGpath, %NVGpath* %val5104, i64 0, i32 2
store i8 %val5107, i8* %val5108
%val5109 = load %NVGpath*, %NVGpath** %objPtr
%val5110 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val5111 = getelementptr %NVGpath, %NVGpath* %val5110, i64 0, i32 3
%val5112 = load i32, i32* %val5111
; set tuple
%val5113 = getelementptr %NVGpath, %NVGpath* %val5109, i64 0, i32 3
store i32 %val5112, i32* %val5113
%val5116 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val5117 = getelementptr %NVGpath, %NVGpath* %val5116, i64 0, i32 4
%val5118 = load %NVGvertex*, %NVGvertex** %val5117
%val5119 = icmp eq %NVGvertex* %val5118, null
br i1 %val5119, label %then5115, label %else5115

then5115:
%res5120 = call ccc i1 @impc_false()
store i1 %res5120, i1* %ifptr5115
br label %ifcont5115

else5115:
%res5121 = call ccc i1 @impc_true()
store i1 %res5121, i1* %ifptr5115
br label %ifcont5115

ifcont5115:
%ifres5122 = load i1, i1* %ifptr5115

br i1 %ifres5122, label %then5114, label %else5114

then5114:
%val5123 = load %NVGpath*, %NVGpath** %objPtr
%val5124 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val5125 = getelementptr %NVGpath, %NVGpath* %val5124, i64 0, i32 4
%val5126 = load %NVGvertex*, %NVGvertex** %val5125
%val5127 = load %mzone*, %mzone** %fromzPtr
%val5128 = load %mzone*, %mzone** %tozPtr
%res5129 = call fastcc %NVGvertex* @zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ(%NVGvertex* %val5126, %mzone* %val5127, %mzone* %val5128)
; set tuple
%val5130 = getelementptr %NVGpath, %NVGpath* %val5123, i64 0, i32 4
store %NVGvertex* %res5129, %NVGvertex** %val5130
store %NVGvertex* %res5129, %NVGvertex** %ifptr5114
br label %ifcont5114

else5114:
br label %ifcont5114

ifcont5114:
%ifres5131 = load %NVGvertex*, %NVGvertex** %ifptr5114

%val5132 = load %NVGpath*, %NVGpath** %objPtr
%val5133 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val5134 = getelementptr %NVGpath, %NVGpath* %val5133, i64 0, i32 5
%val5135 = load i32, i32* %val5134
; set tuple
%val5136 = getelementptr %NVGpath, %NVGpath* %val5132, i64 0, i32 5
store i32 %val5135, i32* %val5136
%val5139 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val5140 = getelementptr %NVGpath, %NVGpath* %val5139, i64 0, i32 6
%val5141 = load %NVGvertex*, %NVGvertex** %val5140
%val5142 = icmp eq %NVGvertex* %val5141, null
br i1 %val5142, label %then5138, label %else5138

then5138:
%res5143 = call ccc i1 @impc_false()
store i1 %res5143, i1* %ifptr5138
br label %ifcont5138

else5138:
%res5144 = call ccc i1 @impc_true()
store i1 %res5144, i1* %ifptr5138
br label %ifcont5138

ifcont5138:
%ifres5145 = load i1, i1* %ifptr5138

br i1 %ifres5145, label %then5137, label %else5137

then5137:
%val5146 = load %NVGpath*, %NVGpath** %objPtr
%val5147 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val5148 = getelementptr %NVGpath, %NVGpath* %val5147, i64 0, i32 6
%val5149 = load %NVGvertex*, %NVGvertex** %val5148
%val5150 = load %mzone*, %mzone** %fromzPtr
%val5151 = load %mzone*, %mzone** %tozPtr
%res5152 = call fastcc %NVGvertex* @zcopy_adhoc_W05WR3ZlcnRleCosTlZHdmVydGV4Kixtem9uZSosbXpvbmUqXQ(%NVGvertex* %val5149, %mzone* %val5150, %mzone* %val5151)
; set tuple
%val5153 = getelementptr %NVGpath, %NVGpath* %val5146, i64 0, i32 6
store %NVGvertex* %res5152, %NVGvertex** %val5153
store %NVGvertex* %res5152, %NVGvertex** %ifptr5137
br label %ifcont5137

else5137:
br label %ifcont5137

ifcont5137:
%ifres5154 = load %NVGvertex*, %NVGvertex** %ifptr5137

%val5155 = load %NVGpath*, %NVGpath** %objPtr
%val5156 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val5157 = getelementptr %NVGpath, %NVGpath* %val5156, i64 0, i32 7
%val5158 = load i32, i32* %val5157
; set tuple
%val5159 = getelementptr %NVGpath, %NVGpath* %val5155, i64 0, i32 7
store i32 %val5158, i32* %val5159
%val5160 = load %NVGpath*, %NVGpath** %objPtr
%val5161 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val5162 = getelementptr %NVGpath, %NVGpath* %val5161, i64 0, i32 8
%val5163 = load i32, i32* %val5162
; set tuple
%val5164 = getelementptr %NVGpath, %NVGpath* %val5160, i64 0, i32 8
store i32 %val5163, i32* %val5164
%val5165 = load %NVGpath*, %NVGpath** %objPtr
%val5166 = load %NVGpath*, %NVGpath** %xPtr
; tuple ref
%val5167 = getelementptr %NVGpath, %NVGpath* %val5166, i64 0, i32 9
%val5168 = load i32, i32* %val5167
; set tuple
%val5169 = getelementptr %NVGpath, %NVGpath* %val5165, i64 0, i32 9
store i32 %val5168, i32* %val5169
%oldzone5170 = call %mzone* @llvm_pop_zone_stack()
%newzone5171 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr5172 = bitcast %mzone* %newzone5171 to i8*
store i8* %zone_ptr5172, i8** %_impzPtr
%val5173 = load %NVGpath*, %NVGpath** %objPtr
ret %NVGpath* %val5173

else5080:
%val5176 = load %NVGpath*, %NVGpath** %xPtr
ret %NVGpath* %val5176
}
@gsxtmnanovg212 = hidden constant [110 x i8] c"zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}** @zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5196 = load i8*, i8** %_impzPtr
%zone5197 = bitcast i8* %tzone5196 to %mzone*

; let assign value to symbol zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd
%dat_zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone5197, i64 8)
%zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpdPtr = bitcast i8* %dat_zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd to { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}***
%tzone5177 = load i8*, i8** %_impzPtr
%zone5178 = bitcast i8* %tzone5177 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5178)
; malloc closure structure
%clsptr5179 = call i8* @llvm_zone_malloc(%mzone* %zone5178, i64 24)
%closure5180 = bitcast i8* %clsptr5179 to { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr5181 = call i8* @llvm_zone_malloc(%mzone* %zone5178, i64 8)
%environment5182 = bitcast i8* %envptr5181 to {{i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable5183 = call %clsvar* @new_address_table()
%var5184 = bitcast [57 x i8]* @gsxtmnanovg210 to i8*
%var5185 = bitcast [65 x i8]* @gsxtmnanovg211 to i8*
%addytable5186 = call %clsvar* @add_address_table(%mzone* %zone5178, i8* %var5184, i32 0, i8* %var5185, i32 3, %clsvar* %addytable5183)
%address-table5187 = bitcast %clsvar* %addytable5186 to i8*

; insert table, function and environment into closure struct
%closure.table5190 = getelementptr { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}* %closure5180, i32 0, i32 0
store i8* %address-table5187, i8** %closure.table5190
%closure.env5191 = getelementptr { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}* %closure5180, i32 0, i32 1
store i8* %envptr5181, i8** %closure.env5191
%closure.func5192 = getelementptr { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}, { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}* %closure5180, i32 0, i32 2
store %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)* @zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd__5078, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)** %closure.func5192
%closure_size5193 = call i64 @llvm_zone_mark_size(%mzone* %zone5178)
call void @llvm_zone_ptr_set_size(i8* %clsptr5179, i64 %closure_size5193)
%wrapper_ptr5194 = call i8* @llvm_zone_malloc(%mzone* %zone5178, i64 8)
%closure_wrapper5195 = bitcast i8* %wrapper_ptr5194 to { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}**
store { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}* %closure5180, { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}** %closure_wrapper5195

; let value assignment
%zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd = select i1 true, { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}** %closure_wrapper5195, { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}** %closure_wrapper5195
store { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}** %zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd, { i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd
%tmp_envptr5189 = getelementptr {{i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}***}* %environment5182, i32 0, i32 0
store {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpdPtr, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}**** %tmp_envptr5189


%val5198 = load {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}**, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpdPtr
ret {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}** %val5198
}


@zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}** @zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %NVGpath* @zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd(%NVGpath* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*,  %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath* %ff(i8* %_impz, i8* %ee, %NVGpath* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %NVGpath* %result
}


define dllexport ccc %NVGpath* @zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd_native(%NVGpath* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*,  %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath* %ff(i8* %_impz, i8* %ee, %NVGpath* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %NVGpath* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5199 = bitcast [110 x i8]* @gsxtmnanovg212 to i8*
call i32 (i8*, ...) @printf(i8* %var5199)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %NVGpath*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5200 = bitcast [110 x i8]* @gsxtmnanovg212 to i8*
call i32 (i8*, ...) @printf(i8* %var5200)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5201 = bitcast [110 x i8]* @gsxtmnanovg212 to i8*
call i32 (i8*, ...) @printf(i8* %var5201)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*,  %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath* %ff(i8* %_impz, i8* %ee, %NVGpath* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %NVGpath* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%NVGpath*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%NVGpath*, %mzone*, %mzone*}, {%NVGpath*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %NVGpath*, %NVGpath** %arg_p_0
%arg_p_1 = getelementptr {%NVGpath*, %mzone*, %mzone*}, {%NVGpath*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%NVGpath*, %mzone*, %mzone*}, {%NVGpath*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W05WR3BhdGgqLE5WR3BhdGgqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}*, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}, {i8*, i8*, %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)*,  %NVGpath* (i8*, i8*, %NVGpath*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %NVGpath* %ff(i8* %_impz, i8* %ee, %NVGpath* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


declare cc 0 i8* @nvgCreateInternal(i8**) nounwind
declare cc 0 void @nvgDeleteInternal(i8*) nounwind
declare cc 0 i8** @nvgInternalParams(i8*) nounwind
declare cc 0 void @nvgDebugDumpPathCache(i8*) nounwind
@NVG_ANTIALIAS = dllexport global i32 zeroinitializer
@NVG_STENCIL_STROKES = dllexport global i32 zeroinitializer
@NVG_DEBUG = dllexport global i32 zeroinitializer
declare cc 0 i8* @nvgCreateGL3(i32) nounwind
declare cc 0 void @nvgDeleteGL3(i8*) nounwind
declare cc 0 i32 @nvgInit() nounwind
@gsxtmnanovg213 = hidden constant [23 x i8] c"nvg_init_adhoc_W2kzMl0\00"
@gsxtmnanovg214 = hidden constant [30 x i8] c"{i8*, i8*, i32 (i8*, i8*)*}**\00"
define dllexport fastcc i32 @nvg_init_adhoc_W2kzMl0__5202(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5203 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*)*}***}*
%nvg_init_adhoc_W2kzMl0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%nvg_init_adhoc_W2kzMl0Ptr = load {i8*, i8*, i32 (i8*, i8*)*}***, {i8*, i8*, i32 (i8*, i8*)*}**** %nvg_init_adhoc_W2kzMl0Ptr_

; setup arguments


%res5204 = call ccc i32 @nvgInit()
ret i32 %res5204
}
define dllexport ccc {i8*, i8*, i32 (i8*, i8*)*}** @nvg_init_adhoc_W2kzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5224 = load i8*, i8** %_impzPtr
%zone5225 = bitcast i8* %tzone5224 to %mzone*

; let assign value to symbol nvg_init_adhoc_W2kzMl0
%dat_nvg_init_adhoc_W2kzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone5225, i64 8)
%nvg_init_adhoc_W2kzMl0Ptr = bitcast i8* %dat_nvg_init_adhoc_W2kzMl0 to { i8*, i8*, i32 (i8*, i8*)*}***
%tzone5205 = load i8*, i8** %_impzPtr
%zone5206 = bitcast i8* %tzone5205 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5206)
; malloc closure structure
%clsptr5207 = call i8* @llvm_zone_malloc(%mzone* %zone5206, i64 24)
%closure5208 = bitcast i8* %clsptr5207 to { i8*, i8*, i32 (i8*, i8*)*}*

; malloc environment structure
%envptr5209 = call i8* @llvm_zone_malloc(%mzone* %zone5206, i64 8)
%environment5210 = bitcast i8* %envptr5209 to {{i8*, i8*, i32 (i8*, i8*)*}***}*

; malloc closure address table
%addytable5211 = call %clsvar* @new_address_table()
%var5212 = bitcast [23 x i8]* @gsxtmnanovg213 to i8*
%var5213 = bitcast [30 x i8]* @gsxtmnanovg214 to i8*
%addytable5214 = call %clsvar* @add_address_table(%mzone* %zone5206, i8* %var5212, i32 0, i8* %var5213, i32 3, %clsvar* %addytable5211)
%address-table5215 = bitcast %clsvar* %addytable5214 to i8*

; insert table, function and environment into closure struct
%closure.table5218 = getelementptr { i8*, i8*, i32 (i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*)*}* %closure5208, i32 0, i32 0
store i8* %address-table5215, i8** %closure.table5218
%closure.env5219 = getelementptr { i8*, i8*, i32 (i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*)*}* %closure5208, i32 0, i32 1
store i8* %envptr5209, i8** %closure.env5219
%closure.func5220 = getelementptr { i8*, i8*, i32 (i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*)*}* %closure5208, i32 0, i32 2
store i32 (i8*, i8*)* @nvg_init_adhoc_W2kzMl0__5202, i32 (i8*, i8*)** %closure.func5220
%closure_size5221 = call i64 @llvm_zone_mark_size(%mzone* %zone5206)
call void @llvm_zone_ptr_set_size(i8* %clsptr5207, i64 %closure_size5221)
%wrapper_ptr5222 = call i8* @llvm_zone_malloc(%mzone* %zone5206, i64 8)
%closure_wrapper5223 = bitcast i8* %wrapper_ptr5222 to { i8*, i8*, i32 (i8*, i8*)*}**
store { i8*, i8*, i32 (i8*, i8*)*}* %closure5208, { i8*, i8*, i32 (i8*, i8*)*}** %closure_wrapper5223

; let value assignment
%nvg_init_adhoc_W2kzMl0 = select i1 true, { i8*, i8*, i32 (i8*, i8*)*}** %closure_wrapper5223, { i8*, i8*, i32 (i8*, i8*)*}** %closure_wrapper5223
store { i8*, i8*, i32 (i8*, i8*)*}** %nvg_init_adhoc_W2kzMl0, { i8*, i8*, i32 (i8*, i8*)*}*** %nvg_init_adhoc_W2kzMl0Ptr

; add data to environment
; don't need to alloc for env var nvg_init_adhoc_W2kzMl0
%tmp_envptr5217 = getelementptr {{i8*, i8*, i32 (i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*)*}***}* %environment5210, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*)*}*** %nvg_init_adhoc_W2kzMl0Ptr, {i8*, i8*, i32 (i8*, i8*)*}**** %tmp_envptr5217


%val5226 = load {i8*, i8*, i32 (i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*)*}*** %nvg_init_adhoc_W2kzMl0Ptr
ret {i8*, i8*, i32 (i8*, i8*)*}** %val5226
}


@nvg_init_adhoc_W2kzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@nvg_init_adhoc_W2kzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @nvg_init_adhoc_W2kzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @nvg_init_adhoc_W2kzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*)*}** @nvg_init_adhoc_W2kzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @nvg_init_adhoc_W2kzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @nvg_init_adhoc_W2kzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_init_adhoc_W2kzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @nvg_init_adhoc_W2kzMl0() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_init_adhoc_W2kzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*)*,  i32 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee)
ret i32 %result
}


define dllexport ccc i32 @nvg_init_adhoc_W2kzMl0_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_init_adhoc_W2kzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*)*,  i32 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee)
ret i32 %result
}


define dllexport ccc i8*  @nvg_init_adhoc_W2kzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_init_adhoc_W2kzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*)*,  i32 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @nvg_init_adhoc_W2kzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_init_adhoc_W2kzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*)*,  i32 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg215 = hidden constant [46 x i8] c"nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0\00"
@gsxtmnanovg216 = hidden constant [45 x i8] c"{i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}**\00"
define dllexport fastcc i32 @nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0__5227(i8* %_impz,i8* %_impenv, i8* %vg, i8* %font_name, i8* %font_path) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5228 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}***}*
%nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0Ptr = load {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}***, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}**** %nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0Ptr_

; setup arguments
%vgPtr = alloca i8*
store i8* %vg, i8** %vgPtr
%font_namePtr = alloca i8*
store i8* %font_name, i8** %font_namePtr
%font_pathPtr = alloca i8*
store i8* %font_path, i8** %font_pathPtr


%val5229 = load i8*, i8** %vgPtr
%val5230 = load i8*, i8** %font_namePtr
%val5231 = load i8*, i8** %font_pathPtr
%res5232 = call ccc i32 @nvgCreateFont(i8* %val5229, i8* %val5230, i8* %val5231)
ret i32 %res5232
}
@gsxtmnanovg217 = hidden constant [99 x i8] c"nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** @nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5252 = load i8*, i8** %_impzPtr
%zone5253 = bitcast i8* %tzone5252 to %mzone*

; let assign value to symbol nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0
%dat_nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone5253, i64 8)
%nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0Ptr = bitcast i8* %dat_nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0 to { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}***
%tzone5233 = load i8*, i8** %_impzPtr
%zone5234 = bitcast i8* %tzone5233 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5234)
; malloc closure structure
%clsptr5235 = call i8* @llvm_zone_malloc(%mzone* %zone5234, i64 24)
%closure5236 = bitcast i8* %clsptr5235 to { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}*

; malloc environment structure
%envptr5237 = call i8* @llvm_zone_malloc(%mzone* %zone5234, i64 8)
%environment5238 = bitcast i8* %envptr5237 to {{i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable5239 = call %clsvar* @new_address_table()
%var5240 = bitcast [46 x i8]* @gsxtmnanovg215 to i8*
%var5241 = bitcast [45 x i8]* @gsxtmnanovg216 to i8*
%addytable5242 = call %clsvar* @add_address_table(%mzone* %zone5234, i8* %var5240, i32 0, i8* %var5241, i32 3, %clsvar* %addytable5239)
%address-table5243 = bitcast %clsvar* %addytable5242 to i8*

; insert table, function and environment into closure struct
%closure.table5246 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure5236, i32 0, i32 0
store i8* %address-table5243, i8** %closure.table5246
%closure.env5247 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure5236, i32 0, i32 1
store i8* %envptr5237, i8** %closure.env5247
%closure.func5248 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure5236, i32 0, i32 2
store i32 (i8*, i8*, i8*, i8*, i8*)* @nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0__5227, i32 (i8*, i8*, i8*, i8*, i8*)** %closure.func5248
%closure_size5249 = call i64 @llvm_zone_mark_size(%mzone* %zone5234)
call void @llvm_zone_ptr_set_size(i8* %clsptr5235, i64 %closure_size5249)
%wrapper_ptr5250 = call i8* @llvm_zone_malloc(%mzone* %zone5234, i64 8)
%closure_wrapper5251 = bitcast i8* %wrapper_ptr5250 to { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}**
store { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure5236, { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** %closure_wrapper5251

; let value assignment
%nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0 = select i1 true, { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** %closure_wrapper5251, { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** %closure_wrapper5251
store { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** %nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0, { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}*** %nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0
%tmp_envptr5245 = getelementptr {{i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}***}* %environment5238, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}*** %nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0Ptr, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}**** %tmp_envptr5245


%val5254 = load {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}*** %nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0Ptr
ret {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** %val5254
}


@nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** @nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0(i8* %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
ret i32 %result
}


define dllexport ccc i32 @nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0_native(i8* %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
ret i32 %result
}


define dllexport ccc i8*  @nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5255 = bitcast [99 x i8]* @gsxtmnanovg217 to i8*
call i32 (i8*, ...) @printf(i8* %var5255)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5256 = bitcast [99 x i8]* @gsxtmnanovg217 to i8*
call i32 (i8*, ...) @printf(i8* %var5256)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5257 = bitcast [99 x i8]* @gsxtmnanovg217 to i8*
call i32 (i8*, ...) @printf(i8* %var5257)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i8*, i8*}*
%arg_p_0 = getelementptr {i8*, i8*, i8*}, {i8*, i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i8*, i8*}, {i8*, i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {i8*, i8*, i8*}, {i8*, i8*, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_create_font_adhoc_W2kzMixpOCosaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg218 = hidden constant [33 x i8] c"nvg_create_context_adhoc_W2k4Kl0\00"
@gsxtmnanovg219 = hidden constant [30 x i8] c"{i8*, i8*, i8* (i8*, i8*)*}**\00"
define dllexport fastcc i8* @nvg_create_context_adhoc_W2k4Kl0__5258(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5259 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*)*}***}*
%nvg_create_context_adhoc_W2k4Kl0Ptr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%nvg_create_context_adhoc_W2k4Kl0Ptr = load {i8*, i8*, i8* (i8*, i8*)*}***, {i8*, i8*, i8* (i8*, i8*)*}**** %nvg_create_context_adhoc_W2k4Kl0Ptr_

; setup arguments


%val5260 = load i32, i32* @GL_STENCIL_TEST
call fastcc void @glEnable_adhoc_W3ZvaWQsaTMyXQ(i32 %val5260)
%val5262 = load i32, i32* @NVG_ANTIALIAS
%val5263 = load i32, i32* @NVG_STENCIL_STROKES
%val5264 = add i32 %val5262, %val5263
%val5265 = load i32, i32* @NVG_DEBUG
%val5266 = add i32 %val5264, %val5265
%res5267 = call ccc i8* @nvgCreateGL3(i32 %val5266)
ret i8* %res5267
}
define dllexport ccc {i8*, i8*, i8* (i8*, i8*)*}** @nvg_create_context_adhoc_W2k4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5287 = load i8*, i8** %_impzPtr
%zone5288 = bitcast i8* %tzone5287 to %mzone*

; let assign value to symbol nvg_create_context_adhoc_W2k4Kl0
%dat_nvg_create_context_adhoc_W2k4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone5288, i64 8)
%nvg_create_context_adhoc_W2k4Kl0Ptr = bitcast i8* %dat_nvg_create_context_adhoc_W2k4Kl0 to { i8*, i8*, i8* (i8*, i8*)*}***
%tzone5268 = load i8*, i8** %_impzPtr
%zone5269 = bitcast i8* %tzone5268 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5269)
; malloc closure structure
%clsptr5270 = call i8* @llvm_zone_malloc(%mzone* %zone5269, i64 24)
%closure5271 = bitcast i8* %clsptr5270 to { i8*, i8*, i8* (i8*, i8*)*}*

; malloc environment structure
%envptr5272 = call i8* @llvm_zone_malloc(%mzone* %zone5269, i64 8)
%environment5273 = bitcast i8* %envptr5272 to {{i8*, i8*, i8* (i8*, i8*)*}***}*

; malloc closure address table
%addytable5274 = call %clsvar* @new_address_table()
%var5275 = bitcast [33 x i8]* @gsxtmnanovg218 to i8*
%var5276 = bitcast [30 x i8]* @gsxtmnanovg219 to i8*
%addytable5277 = call %clsvar* @add_address_table(%mzone* %zone5269, i8* %var5275, i32 0, i8* %var5276, i32 3, %clsvar* %addytable5274)
%address-table5278 = bitcast %clsvar* %addytable5277 to i8*

; insert table, function and environment into closure struct
%closure.table5281 = getelementptr { i8*, i8*, i8* (i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*)*}* %closure5271, i32 0, i32 0
store i8* %address-table5278, i8** %closure.table5281
%closure.env5282 = getelementptr { i8*, i8*, i8* (i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*)*}* %closure5271, i32 0, i32 1
store i8* %envptr5272, i8** %closure.env5282
%closure.func5283 = getelementptr { i8*, i8*, i8* (i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*)*}* %closure5271, i32 0, i32 2
store i8* (i8*, i8*)* @nvg_create_context_adhoc_W2k4Kl0__5258, i8* (i8*, i8*)** %closure.func5283
%closure_size5284 = call i64 @llvm_zone_mark_size(%mzone* %zone5269)
call void @llvm_zone_ptr_set_size(i8* %clsptr5270, i64 %closure_size5284)
%wrapper_ptr5285 = call i8* @llvm_zone_malloc(%mzone* %zone5269, i64 8)
%closure_wrapper5286 = bitcast i8* %wrapper_ptr5285 to { i8*, i8*, i8* (i8*, i8*)*}**
store { i8*, i8*, i8* (i8*, i8*)*}* %closure5271, { i8*, i8*, i8* (i8*, i8*)*}** %closure_wrapper5286

; let value assignment
%nvg_create_context_adhoc_W2k4Kl0 = select i1 true, { i8*, i8*, i8* (i8*, i8*)*}** %closure_wrapper5286, { i8*, i8*, i8* (i8*, i8*)*}** %closure_wrapper5286
store { i8*, i8*, i8* (i8*, i8*)*}** %nvg_create_context_adhoc_W2k4Kl0, { i8*, i8*, i8* (i8*, i8*)*}*** %nvg_create_context_adhoc_W2k4Kl0Ptr

; add data to environment
; don't need to alloc for env var nvg_create_context_adhoc_W2k4Kl0
%tmp_envptr5280 = getelementptr {{i8*, i8*, i8* (i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*)*}***}* %environment5273, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*)*}*** %nvg_create_context_adhoc_W2k4Kl0Ptr, {i8*, i8*, i8* (i8*, i8*)*}**** %tmp_envptr5280


%val5289 = load {i8*, i8*, i8* (i8*, i8*)*}**, {i8*, i8*, i8* (i8*, i8*)*}*** %nvg_create_context_adhoc_W2k4Kl0Ptr
ret {i8*, i8*, i8* (i8*, i8*)*}** %val5289
}


@nvg_create_context_adhoc_W2k4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@nvg_create_context_adhoc_W2k4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @nvg_create_context_adhoc_W2k4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @nvg_create_context_adhoc_W2k4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*)*}** @nvg_create_context_adhoc_W2k4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @nvg_create_context_adhoc_W2k4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @nvg_create_context_adhoc_W2k4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_create_context_adhoc_W2k4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @nvg_create_context_adhoc_W2k4Kl0() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_create_context_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
ret i8* %result
}


define dllexport ccc i8* @nvg_create_context_adhoc_W2k4Kl0_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_create_context_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
ret i8* %result
}


define dllexport ccc i8*  @nvg_create_context_adhoc_W2k4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_create_context_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @nvg_create_context_adhoc_W2k4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_create_context_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg220 = hidden constant [25 x i8] c"nvg_clear_adhoc_W3ZvaWRd\00"
@gsxtmnanovg221 = hidden constant [31 x i8] c"{i8*, i8*, void (i8*, i8*)*}**\00"
define dllexport fastcc void @nvg_clear_adhoc_W3ZvaWRd__5290(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5291 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*)*}***}*
%nvg_clear_adhoc_W3ZvaWRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%nvg_clear_adhoc_W3ZvaWRdPtr = load {i8*, i8*, void (i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*)*}**** %nvg_clear_adhoc_W3ZvaWRdPtr_

; setup arguments


%val5292 = load i32, i32* @GL_COLOR_BUFFER_BIT
%val5293 = load i32, i32* @GL_DEPTH_BUFFER_BIT
%val5294 = or i32 %val5292, %val5293
%val5295 = load i32, i32* @GL_STENCIL_BUFFER_BIT
%val5296 = or i32 %val5294, %val5295
call fastcc void @glClear_adhoc_W3ZvaWQsaTMyXQ(i32 %val5296)
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*)*}** @nvg_clear_adhoc_W3ZvaWRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5317 = load i8*, i8** %_impzPtr
%zone5318 = bitcast i8* %tzone5317 to %mzone*

; let assign value to symbol nvg_clear_adhoc_W3ZvaWRd
%dat_nvg_clear_adhoc_W3ZvaWRd = call i8* @llvm_zone_malloc(%mzone* %zone5318, i64 8)
%nvg_clear_adhoc_W3ZvaWRdPtr = bitcast i8* %dat_nvg_clear_adhoc_W3ZvaWRd to { i8*, i8*, void (i8*, i8*)*}***
%tzone5298 = load i8*, i8** %_impzPtr
%zone5299 = bitcast i8* %tzone5298 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5299)
; malloc closure structure
%clsptr5300 = call i8* @llvm_zone_malloc(%mzone* %zone5299, i64 24)
%closure5301 = bitcast i8* %clsptr5300 to { i8*, i8*, void (i8*, i8*)*}*

; malloc environment structure
%envptr5302 = call i8* @llvm_zone_malloc(%mzone* %zone5299, i64 8)
%environment5303 = bitcast i8* %envptr5302 to {{i8*, i8*, void (i8*, i8*)*}***}*

; malloc closure address table
%addytable5304 = call %clsvar* @new_address_table()
%var5305 = bitcast [25 x i8]* @gsxtmnanovg220 to i8*
%var5306 = bitcast [31 x i8]* @gsxtmnanovg221 to i8*
%addytable5307 = call %clsvar* @add_address_table(%mzone* %zone5299, i8* %var5305, i32 0, i8* %var5306, i32 3, %clsvar* %addytable5304)
%address-table5308 = bitcast %clsvar* %addytable5307 to i8*

; insert table, function and environment into closure struct
%closure.table5311 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure5301, i32 0, i32 0
store i8* %address-table5308, i8** %closure.table5311
%closure.env5312 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure5301, i32 0, i32 1
store i8* %envptr5302, i8** %closure.env5312
%closure.func5313 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure5301, i32 0, i32 2
store void (i8*, i8*)* @nvg_clear_adhoc_W3ZvaWRd__5290, void (i8*, i8*)** %closure.func5313
%closure_size5314 = call i64 @llvm_zone_mark_size(%mzone* %zone5299)
call void @llvm_zone_ptr_set_size(i8* %clsptr5300, i64 %closure_size5314)
%wrapper_ptr5315 = call i8* @llvm_zone_malloc(%mzone* %zone5299, i64 8)
%closure_wrapper5316 = bitcast i8* %wrapper_ptr5315 to { i8*, i8*, void (i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*)*}* %closure5301, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper5316

; let value assignment
%nvg_clear_adhoc_W3ZvaWRd = select i1 true, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper5316, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper5316
store { i8*, i8*, void (i8*, i8*)*}** %nvg_clear_adhoc_W3ZvaWRd, { i8*, i8*, void (i8*, i8*)*}*** %nvg_clear_adhoc_W3ZvaWRdPtr

; add data to environment
; don't need to alloc for env var nvg_clear_adhoc_W3ZvaWRd
%tmp_envptr5310 = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %environment5303, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*)*}*** %nvg_clear_adhoc_W3ZvaWRdPtr, {i8*, i8*, void (i8*, i8*)*}**** %tmp_envptr5310


%val5319 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %nvg_clear_adhoc_W3ZvaWRdPtr
ret {i8*, i8*, void (i8*, i8*)*}** %val5319
}


@nvg_clear_adhoc_W3ZvaWRd_var = dllexport global [1 x i8*] [ i8* null ]

@nvg_clear_adhoc_W3ZvaWRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @nvg_clear_adhoc_W3ZvaWRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @nvg_clear_adhoc_W3ZvaWRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*)*}** @nvg_clear_adhoc_W3ZvaWRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @nvg_clear_adhoc_W3ZvaWRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @nvg_clear_adhoc_W3ZvaWRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_clear_adhoc_W3ZvaWRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @nvg_clear_adhoc_W3ZvaWRd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_clear_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc void @nvg_clear_adhoc_W3ZvaWRd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_clear_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc i8*  @nvg_clear_adhoc_W3ZvaWRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_clear_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @nvg_clear_adhoc_W3ZvaWRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_clear_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%Rect = type {float,float,float,float}
@gsxtmnanovg222 = hidden constant [54 x i8] c"Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
@gsxtmnanovg223 = hidden constant [61 x i8] c"{i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**\00"
define dllexport fastcc %Rect* @Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__5320(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1, float %arg_2, float %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5321 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***}*
%Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**** %Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr
%arg_2Ptr = alloca float
store float %arg_2, float* %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr


%tzone5326 = load i8*, i8** %_impzPtr
%zone5327 = bitcast i8* %tzone5326 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Rect*
%tzone5322 = load i8*, i8** %_impzPtr
%zone5323 = bitcast i8* %tzone5322 to %mzone*
%dat5324 = call i8* @llvm_zone_malloc(%mzone* %zone5323, i64 16)
call i8* @memset(i8* %dat5324, i32 0, i64 16)
%val5325 = bitcast i8* %dat5324 to %Rect*

; let value assignment
%obj = select i1 true, %Rect* %val5325, %Rect* %val5325
store %Rect* %obj, %Rect** %objPtr

%val5328 = load %Rect*, %Rect** %objPtr
%val5329 = load float, float* %arg_0Ptr
; set tuple
%val5330 = getelementptr %Rect, %Rect* %val5328, i64 0, i32 0
store float %val5329, float* %val5330
%val5331 = load %Rect*, %Rect** %objPtr
%val5332 = load float, float* %arg_1Ptr
; set tuple
%val5333 = getelementptr %Rect, %Rect* %val5331, i64 0, i32 1
store float %val5332, float* %val5333
%val5334 = load %Rect*, %Rect** %objPtr
%val5335 = load float, float* %arg_2Ptr
; set tuple
%val5336 = getelementptr %Rect, %Rect* %val5334, i64 0, i32 2
store float %val5335, float* %val5336
%val5337 = load %Rect*, %Rect** %objPtr
%val5338 = load float, float* %arg_3Ptr
; set tuple
%val5339 = getelementptr %Rect, %Rect* %val5337, i64 0, i32 3
store float %val5338, float* %val5339
%val5340 = load %Rect*, %Rect** %objPtr
ret %Rect* %val5340
}
@gsxtmnanovg224 = hidden constant [107 x i8] c"Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** @Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5360 = load i8*, i8** %_impzPtr
%zone5361 = bitcast i8* %tzone5360 to %mzone*

; let assign value to symbol Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone5361, i64 8)
%Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ to { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***
%tzone5341 = load i8*, i8** %_impzPtr
%zone5342 = bitcast i8* %tzone5341 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5342)
; malloc closure structure
%clsptr5343 = call i8* @llvm_zone_malloc(%mzone* %zone5342, i64 24)
%closure5344 = bitcast i8* %clsptr5343 to { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*

; malloc environment structure
%envptr5345 = call i8* @llvm_zone_malloc(%mzone* %zone5342, i64 8)
%environment5346 = bitcast i8* %envptr5345 to {{i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***}*

; malloc closure address table
%addytable5347 = call %clsvar* @new_address_table()
%var5348 = bitcast [54 x i8]* @gsxtmnanovg222 to i8*
%var5349 = bitcast [61 x i8]* @gsxtmnanovg223 to i8*
%addytable5350 = call %clsvar* @add_address_table(%mzone* %zone5342, i8* %var5348, i32 0, i8* %var5349, i32 3, %clsvar* %addytable5347)
%address-table5351 = bitcast %clsvar* %addytable5350 to i8*

; insert table, function and environment into closure struct
%closure.table5354 = getelementptr { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure5344, i32 0, i32 0
store i8* %address-table5351, i8** %closure.table5354
%closure.env5355 = getelementptr { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure5344, i32 0, i32 1
store i8* %envptr5345, i8** %closure.env5355
%closure.func5356 = getelementptr { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure5344, i32 0, i32 2
store %Rect* (i8*, i8*, float, float, float, float)* @Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__5320, %Rect* (i8*, i8*, float, float, float, float)** %closure.func5356
%closure_size5357 = call i64 @llvm_zone_mark_size(%mzone* %zone5342)
call void @llvm_zone_ptr_set_size(i8* %clsptr5343, i64 %closure_size5357)
%wrapper_ptr5358 = call i8* @llvm_zone_malloc(%mzone* %zone5342, i64 8)
%closure_wrapper5359 = bitcast i8* %wrapper_ptr5358 to { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**
store { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure5344, { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure_wrapper5359

; let value assignment
%Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure_wrapper5359, { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure_wrapper5359
store { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ, { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*** %Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr5353 = getelementptr {{i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***}* %environment5346, i32 0, i32 0
store {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*** %Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**** %tmp_envptr5353


%val5362 = load {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*** %Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %val5362
}


@Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** @Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rect* @Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Rect* (i8*, i8*, float, float, float, float)*,  %Rect* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %Rect* %result
}


define dllexport ccc %Rect* @Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_native(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Rect* (i8*, i8*, float, float, float, float)*,  %Rect* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %Rect* %result
}


define dllexport ccc i8*  @Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5363 = bitcast [107 x i8]* @gsxtmnanovg224 to i8*
call i32 (i8*, ...) @printf(i8* %var5363)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5364 = bitcast [107 x i8]* @gsxtmnanovg224 to i8*
call i32 (i8*, ...) @printf(i8* %var5364)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5365 = bitcast [107 x i8]* @gsxtmnanovg224 to i8*
call i32 (i8*, ...) @printf(i8* %var5365)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var5366 = bitcast [107 x i8]* @gsxtmnanovg224 to i8*
call i32 (i8*, ...) @printf(i8* %var5366)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Rect* (i8*, i8*, float, float, float, float)*,  %Rect* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%tmpres = bitcast %Rect* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float, float, float}*
%arg_p_0 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rect_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Rect* (i8*, i8*, float, float, float, float)*,  %Rect* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg225 = hidden constant [56 x i8] c"Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
define dllexport fastcc %Rect* @Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__5367(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1, float %arg_2, float %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5368 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***}*
%Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**** %Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr
%arg_2Ptr = alloca float
store float %arg_2, float* %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr


%tzone5373 = load i8*, i8** %_impzPtr
%zone5374 = bitcast i8* %tzone5373 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Rect*
%tzone5369 = load i8*, i8** %_impzPtr
%zone5370 = bitcast i8* %tzone5369 to %mzone*
%dat5371 = call i8* @llvm_zone_malloc(%mzone* %zone5370, i64 16)
call i8* @memset(i8* %dat5371, i32 0, i64 16)
%val5372 = bitcast i8* %dat5371 to %Rect*

; let value assignment
%obj = select i1 true, %Rect* %val5372, %Rect* %val5372
store %Rect* %obj, %Rect** %objPtr

%val5375 = load %Rect*, %Rect** %objPtr
%val5376 = load float, float* %arg_0Ptr
; set tuple
%val5377 = getelementptr %Rect, %Rect* %val5375, i64 0, i32 0
store float %val5376, float* %val5377
%val5378 = load %Rect*, %Rect** %objPtr
%val5379 = load float, float* %arg_1Ptr
; set tuple
%val5380 = getelementptr %Rect, %Rect* %val5378, i64 0, i32 1
store float %val5379, float* %val5380
%val5381 = load %Rect*, %Rect** %objPtr
%val5382 = load float, float* %arg_2Ptr
; set tuple
%val5383 = getelementptr %Rect, %Rect* %val5381, i64 0, i32 2
store float %val5382, float* %val5383
%val5384 = load %Rect*, %Rect** %objPtr
%val5385 = load float, float* %arg_3Ptr
; set tuple
%val5386 = getelementptr %Rect, %Rect* %val5384, i64 0, i32 3
store float %val5385, float* %val5386
%val5387 = load %Rect*, %Rect** %objPtr
ret %Rect* %val5387
}
@gsxtmnanovg226 = hidden constant [109 x i8] c"Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** @Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5407 = load i8*, i8** %_impzPtr
%zone5408 = bitcast i8* %tzone5407 to %mzone*

; let assign value to symbol Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone5408, i64 8)
%Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ to { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***
%tzone5388 = load i8*, i8** %_impzPtr
%zone5389 = bitcast i8* %tzone5388 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5389)
; malloc closure structure
%clsptr5390 = call i8* @llvm_zone_malloc(%mzone* %zone5389, i64 24)
%closure5391 = bitcast i8* %clsptr5390 to { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*

; malloc environment structure
%envptr5392 = call i8* @llvm_zone_malloc(%mzone* %zone5389, i64 8)
%environment5393 = bitcast i8* %envptr5392 to {{i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***}*

; malloc closure address table
%addytable5394 = call %clsvar* @new_address_table()
%var5395 = bitcast [56 x i8]* @gsxtmnanovg225 to i8*
%var5396 = bitcast [61 x i8]* @gsxtmnanovg223 to i8*
%addytable5397 = call %clsvar* @add_address_table(%mzone* %zone5389, i8* %var5395, i32 0, i8* %var5396, i32 3, %clsvar* %addytable5394)
%address-table5398 = bitcast %clsvar* %addytable5397 to i8*

; insert table, function and environment into closure struct
%closure.table5401 = getelementptr { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure5391, i32 0, i32 0
store i8* %address-table5398, i8** %closure.table5401
%closure.env5402 = getelementptr { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure5391, i32 0, i32 1
store i8* %envptr5392, i8** %closure.env5402
%closure.func5403 = getelementptr { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure5391, i32 0, i32 2
store %Rect* (i8*, i8*, float, float, float, float)* @Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__5367, %Rect* (i8*, i8*, float, float, float, float)** %closure.func5403
%closure_size5404 = call i64 @llvm_zone_mark_size(%mzone* %zone5389)
call void @llvm_zone_ptr_set_size(i8* %clsptr5390, i64 %closure_size5404)
%wrapper_ptr5405 = call i8* @llvm_zone_malloc(%mzone* %zone5389, i64 8)
%closure_wrapper5406 = bitcast i8* %wrapper_ptr5405 to { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**
store { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure5391, { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure_wrapper5406

; let value assignment
%Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure_wrapper5406, { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure_wrapper5406
store { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ, { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*** %Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr5400 = getelementptr {{i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***}* %environment5393, i32 0, i32 0
store {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*** %Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**** %tmp_envptr5400


%val5409 = load {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*** %Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %val5409
}


@Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** @Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rect* @Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Rect* (i8*, i8*, float, float, float, float)*,  %Rect* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %Rect* %result
}


define dllexport ccc %Rect* @Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_native(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Rect* (i8*, i8*, float, float, float, float)*,  %Rect* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %Rect* %result
}


define dllexport ccc i8*  @Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5410 = bitcast [109 x i8]* @gsxtmnanovg226 to i8*
call i32 (i8*, ...) @printf(i8* %var5410)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5411 = bitcast [109 x i8]* @gsxtmnanovg226 to i8*
call i32 (i8*, ...) @printf(i8* %var5411)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5412 = bitcast [109 x i8]* @gsxtmnanovg226 to i8*
call i32 (i8*, ...) @printf(i8* %var5412)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var5413 = bitcast [109 x i8]* @gsxtmnanovg226 to i8*
call i32 (i8*, ...) @printf(i8* %var5413)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Rect* (i8*, i8*, float, float, float, float)*,  %Rect* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%tmpres = bitcast %Rect* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float, float, float}*
%arg_p_0 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rect_z_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Rect* (i8*, i8*, float, float, float, float)*,  %Rect* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg227 = hidden constant [56 x i8] c"Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
define dllexport fastcc %Rect* @Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__5414(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1, float %arg_2, float %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5415 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***}*
%Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**** %Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr
%arg_2Ptr = alloca float
store float %arg_2, float* %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr


%tzone5418 = load i8*, i8** %_impzPtr
%zone5419 = bitcast i8* %tzone5418 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Rect*
%dat5416 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat5416, i32 0, i64 16)
%val5417 = bitcast i8* %dat5416 to %Rect*

; let value assignment
%obj = select i1 true, %Rect* %val5417, %Rect* %val5417
store %Rect* %obj, %Rect** %objPtr

%val5420 = load %Rect*, %Rect** %objPtr
%val5421 = load float, float* %arg_0Ptr
; set tuple
%val5422 = getelementptr %Rect, %Rect* %val5420, i64 0, i32 0
store float %val5421, float* %val5422
%val5423 = load %Rect*, %Rect** %objPtr
%val5424 = load float, float* %arg_1Ptr
; set tuple
%val5425 = getelementptr %Rect, %Rect* %val5423, i64 0, i32 1
store float %val5424, float* %val5425
%val5426 = load %Rect*, %Rect** %objPtr
%val5427 = load float, float* %arg_2Ptr
; set tuple
%val5428 = getelementptr %Rect, %Rect* %val5426, i64 0, i32 2
store float %val5427, float* %val5428
%val5429 = load %Rect*, %Rect** %objPtr
%val5430 = load float, float* %arg_3Ptr
; set tuple
%val5431 = getelementptr %Rect, %Rect* %val5429, i64 0, i32 3
store float %val5430, float* %val5431
%val5432 = load %Rect*, %Rect** %objPtr
ret %Rect* %val5432
}
@gsxtmnanovg228 = hidden constant [109 x i8] c"Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** @Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5452 = load i8*, i8** %_impzPtr
%zone5453 = bitcast i8* %tzone5452 to %mzone*

; let assign value to symbol Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone5453, i64 8)
%Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ to { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***
%tzone5433 = load i8*, i8** %_impzPtr
%zone5434 = bitcast i8* %tzone5433 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5434)
; malloc closure structure
%clsptr5435 = call i8* @llvm_zone_malloc(%mzone* %zone5434, i64 24)
%closure5436 = bitcast i8* %clsptr5435 to { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*

; malloc environment structure
%envptr5437 = call i8* @llvm_zone_malloc(%mzone* %zone5434, i64 8)
%environment5438 = bitcast i8* %envptr5437 to {{i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***}*

; malloc closure address table
%addytable5439 = call %clsvar* @new_address_table()
%var5440 = bitcast [56 x i8]* @gsxtmnanovg227 to i8*
%var5441 = bitcast [61 x i8]* @gsxtmnanovg223 to i8*
%addytable5442 = call %clsvar* @add_address_table(%mzone* %zone5434, i8* %var5440, i32 0, i8* %var5441, i32 3, %clsvar* %addytable5439)
%address-table5443 = bitcast %clsvar* %addytable5442 to i8*

; insert table, function and environment into closure struct
%closure.table5446 = getelementptr { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure5436, i32 0, i32 0
store i8* %address-table5443, i8** %closure.table5446
%closure.env5447 = getelementptr { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure5436, i32 0, i32 1
store i8* %envptr5437, i8** %closure.env5447
%closure.func5448 = getelementptr { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure5436, i32 0, i32 2
store %Rect* (i8*, i8*, float, float, float, float)* @Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__5414, %Rect* (i8*, i8*, float, float, float, float)** %closure.func5448
%closure_size5449 = call i64 @llvm_zone_mark_size(%mzone* %zone5434)
call void @llvm_zone_ptr_set_size(i8* %clsptr5435, i64 %closure_size5449)
%wrapper_ptr5450 = call i8* @llvm_zone_malloc(%mzone* %zone5434, i64 8)
%closure_wrapper5451 = bitcast i8* %wrapper_ptr5450 to { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**
store { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure5436, { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure_wrapper5451

; let value assignment
%Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure_wrapper5451, { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure_wrapper5451
store { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ, { i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*** %Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr5445 = getelementptr {{i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}***}* %environment5438, i32 0, i32 0
store {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*** %Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**** %tmp_envptr5445


%val5454 = load {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*** %Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %val5454
}


@Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** @Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rect* @Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Rect* (i8*, i8*, float, float, float, float)*,  %Rect* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %Rect* %result
}


define dllexport ccc %Rect* @Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_native(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Rect* (i8*, i8*, float, float, float, float)*,  %Rect* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %Rect* %result
}


define dllexport ccc i8*  @Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5455 = bitcast [109 x i8]* @gsxtmnanovg228 to i8*
call i32 (i8*, ...) @printf(i8* %var5455)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5456 = bitcast [109 x i8]* @gsxtmnanovg228 to i8*
call i32 (i8*, ...) @printf(i8* %var5456)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5457 = bitcast [109 x i8]* @gsxtmnanovg228 to i8*
call i32 (i8*, ...) @printf(i8* %var5457)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var5458 = bitcast [109 x i8]* @gsxtmnanovg228 to i8*
call i32 (i8*, ...) @printf(i8* %var5458)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Rect* (i8*, i8*, float, float, float, float)*,  %Rect* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%tmpres = bitcast %Rect* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float, float, float}*
%arg_p_0 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rect_h_adhoc_W1JlY3QqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect* (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Rect* (i8*, i8*, float, float, float, float)*,  %Rect* (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect* %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg229 = hidden constant [56 x i8] c"Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd\00"
@gsxtmnanovg230 = hidden constant [60 x i8] c"{i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}**\00"
define dllexport fastcc %Rect @Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd__5459(i8* %_impz,i8* %_impenv, float %arg_0, float %arg_1, float %arg_2, float %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5460 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}***}*
%Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = load {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}***, {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}**** %Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_

; setup arguments
%arg_0Ptr = alloca float
store float %arg_0, float* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr
%arg_2Ptr = alloca float
store float %arg_2, float* %arg_2Ptr
%arg_3Ptr = alloca float
store float %arg_3, float* %arg_3Ptr


%tzone5462 = load i8*, i8** %_impzPtr
%zone5463 = bitcast i8* %tzone5462 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Rect*
%dat5461 = alloca %Rect, align 16

; let value assignment
%obj = select i1 true, %Rect* %dat5461, %Rect* %dat5461
store %Rect* %obj, %Rect** %objPtr

%val5464 = load %Rect*, %Rect** %objPtr
%val5465 = load float, float* %arg_0Ptr
; set tuple
%val5466 = getelementptr %Rect, %Rect* %val5464, i64 0, i32 0
store float %val5465, float* %val5466
%val5467 = load %Rect*, %Rect** %objPtr
%val5468 = load float, float* %arg_1Ptr
; set tuple
%val5469 = getelementptr %Rect, %Rect* %val5467, i64 0, i32 1
store float %val5468, float* %val5469
%val5470 = load %Rect*, %Rect** %objPtr
%val5471 = load float, float* %arg_2Ptr
; set tuple
%val5472 = getelementptr %Rect, %Rect* %val5470, i64 0, i32 2
store float %val5471, float* %val5472
%val5473 = load %Rect*, %Rect** %objPtr
%val5474 = load float, float* %arg_3Ptr
; set tuple
%val5475 = getelementptr %Rect, %Rect* %val5473, i64 0, i32 3
store float %val5474, float* %val5475
%val5476 = load %Rect*, %Rect** %objPtr
; pointer ref
%val5477 = getelementptr %Rect, %Rect* %val5476, i64 0
%val5478 = load %Rect, %Rect* %val5477
ret %Rect %val5478
}
@gsxtmnanovg231 = hidden constant [109 x i8] c"Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}** @Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5498 = load i8*, i8** %_impzPtr
%zone5499 = bitcast i8* %tzone5498 to %mzone*

; let assign value to symbol Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd
%dat_Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone5499, i64 8)
%Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = bitcast i8* %dat_Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd to { i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}***
%tzone5479 = load i8*, i8** %_impzPtr
%zone5480 = bitcast i8* %tzone5479 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5480)
; malloc closure structure
%clsptr5481 = call i8* @llvm_zone_malloc(%mzone* %zone5480, i64 24)
%closure5482 = bitcast i8* %clsptr5481 to { i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}*

; malloc environment structure
%envptr5483 = call i8* @llvm_zone_malloc(%mzone* %zone5480, i64 8)
%environment5484 = bitcast i8* %envptr5483 to {{i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}***}*

; malloc closure address table
%addytable5485 = call %clsvar* @new_address_table()
%var5486 = bitcast [56 x i8]* @gsxtmnanovg229 to i8*
%var5487 = bitcast [60 x i8]* @gsxtmnanovg230 to i8*
%addytable5488 = call %clsvar* @add_address_table(%mzone* %zone5480, i8* %var5486, i32 0, i8* %var5487, i32 3, %clsvar* %addytable5485)
%address-table5489 = bitcast %clsvar* %addytable5488 to i8*

; insert table, function and environment into closure struct
%closure.table5492 = getelementptr { i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}* %closure5482, i32 0, i32 0
store i8* %address-table5489, i8** %closure.table5492
%closure.env5493 = getelementptr { i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}* %closure5482, i32 0, i32 1
store i8* %envptr5483, i8** %closure.env5493
%closure.func5494 = getelementptr { i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}, { i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}* %closure5482, i32 0, i32 2
store %Rect (i8*, i8*, float, float, float, float)* @Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd__5459, %Rect (i8*, i8*, float, float, float, float)** %closure.func5494
%closure_size5495 = call i64 @llvm_zone_mark_size(%mzone* %zone5480)
call void @llvm_zone_ptr_set_size(i8* %clsptr5481, i64 %closure_size5495)
%wrapper_ptr5496 = call i8* @llvm_zone_malloc(%mzone* %zone5480, i64 8)
%closure_wrapper5497 = bitcast i8* %wrapper_ptr5496 to { i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}**
store { i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}* %closure5482, { i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}** %closure_wrapper5497

; let value assignment
%Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd = select i1 true, { i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}** %closure_wrapper5497, { i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}** %closure_wrapper5497
store { i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}** %Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd, { i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}*** %Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd
%tmp_envptr5491 = getelementptr {{i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}***}* %environment5484, i32 0, i32 0
store {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}*** %Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr, {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}**** %tmp_envptr5491


%val5500 = load {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}**, {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}*** %Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr
ret {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}** %val5500
}


@Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}** @Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rect @Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Rect (i8*, i8*, float, float, float, float)*,  %Rect (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %Rect %result
}


define dllexport ccc %Rect @Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_native(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Rect (i8*, i8*, float, float, float, float)*,  %Rect (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret %Rect %result
}


define dllexport ccc void @Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float, float, float}*
%arg_p_0 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rect_val_adhoc_W1JlY3QsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}, {i8*, i8*, %Rect (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %Rect (i8*, i8*, float, float, float, float)*,  %Rect (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg232 = hidden constant [31 x i8] c"hcopy_adhoc_W1JlY3QqLFJlY3QqXQ\00"
@gsxtmnanovg233 = hidden constant [41 x i8] c"{i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}**\00"
define dllexport fastcc %Rect* @hcopy_adhoc_W1JlY3QqLFJlY3QqXQ__5505(i8* %_impz,i8* %_impenv, %Rect* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5506 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}***}*
%hcopy_adhoc_W1JlY3QqLFJlY3QqXQPtr_ = getelementptr {{i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}***}, {{i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1JlY3QqLFJlY3QqXQPtr = load {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}***, {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}**** %hcopy_adhoc_W1JlY3QqLFJlY3QqXQPtr_

; setup arguments
%xPtr = alloca %Rect*
store %Rect* %x, %Rect** %xPtr


%tzone5509 = load i8*, i8** %_impzPtr
%zone5510 = bitcast i8* %tzone5509 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Rect*
%dat5507 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat5507, i32 0, i64 16)
%val5508 = bitcast i8* %dat5507 to %Rect*

; let value assignment
%obj = select i1 true, %Rect* %val5508, %Rect* %val5508
store %Rect* %obj, %Rect** %objPtr

%val5511 = load %Rect*, %Rect** %objPtr
%val5512 = load %Rect*, %Rect** %xPtr
; tuple ref
%val5513 = getelementptr %Rect, %Rect* %val5512, i64 0, i32 0
%val5514 = load float, float* %val5513
; set tuple
%val5515 = getelementptr %Rect, %Rect* %val5511, i64 0, i32 0
store float %val5514, float* %val5515
%val5516 = load %Rect*, %Rect** %objPtr
%val5517 = load %Rect*, %Rect** %xPtr
; tuple ref
%val5518 = getelementptr %Rect, %Rect* %val5517, i64 0, i32 1
%val5519 = load float, float* %val5518
; set tuple
%val5520 = getelementptr %Rect, %Rect* %val5516, i64 0, i32 1
store float %val5519, float* %val5520
%val5521 = load %Rect*, %Rect** %objPtr
%val5522 = load %Rect*, %Rect** %xPtr
; tuple ref
%val5523 = getelementptr %Rect, %Rect* %val5522, i64 0, i32 2
%val5524 = load float, float* %val5523
; set tuple
%val5525 = getelementptr %Rect, %Rect* %val5521, i64 0, i32 2
store float %val5524, float* %val5525
%val5526 = load %Rect*, %Rect** %objPtr
%val5527 = load %Rect*, %Rect** %xPtr
; tuple ref
%val5528 = getelementptr %Rect, %Rect* %val5527, i64 0, i32 3
%val5529 = load float, float* %val5528
; set tuple
%val5530 = getelementptr %Rect, %Rect* %val5526, i64 0, i32 3
store float %val5529, float* %val5530
%val5531 = load %Rect*, %Rect** %objPtr
ret %Rect* %val5531
}
@gsxtmnanovg234 = hidden constant [84 x i8] c"hcopy_adhoc_W1JlY3QqLFJlY3QqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}** @hcopy_adhoc_W1JlY3QqLFJlY3QqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5551 = load i8*, i8** %_impzPtr
%zone5552 = bitcast i8* %tzone5551 to %mzone*

; let assign value to symbol hcopy_adhoc_W1JlY3QqLFJlY3QqXQ
%dat_hcopy_adhoc_W1JlY3QqLFJlY3QqXQ = call i8* @llvm_zone_malloc(%mzone* %zone5552, i64 8)
%hcopy_adhoc_W1JlY3QqLFJlY3QqXQPtr = bitcast i8* %dat_hcopy_adhoc_W1JlY3QqLFJlY3QqXQ to { i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}***
%tzone5532 = load i8*, i8** %_impzPtr
%zone5533 = bitcast i8* %tzone5532 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5533)
; malloc closure structure
%clsptr5534 = call i8* @llvm_zone_malloc(%mzone* %zone5533, i64 24)
%closure5535 = bitcast i8* %clsptr5534 to { i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}*

; malloc environment structure
%envptr5536 = call i8* @llvm_zone_malloc(%mzone* %zone5533, i64 8)
%environment5537 = bitcast i8* %envptr5536 to {{i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}***}*

; malloc closure address table
%addytable5538 = call %clsvar* @new_address_table()
%var5539 = bitcast [31 x i8]* @gsxtmnanovg232 to i8*
%var5540 = bitcast [41 x i8]* @gsxtmnanovg233 to i8*
%addytable5541 = call %clsvar* @add_address_table(%mzone* %zone5533, i8* %var5539, i32 0, i8* %var5540, i32 3, %clsvar* %addytable5538)
%address-table5542 = bitcast %clsvar* %addytable5541 to i8*

; insert table, function and environment into closure struct
%closure.table5545 = getelementptr { i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}, { i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}* %closure5535, i32 0, i32 0
store i8* %address-table5542, i8** %closure.table5545
%closure.env5546 = getelementptr { i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}, { i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}* %closure5535, i32 0, i32 1
store i8* %envptr5536, i8** %closure.env5546
%closure.func5547 = getelementptr { i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}, { i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}* %closure5535, i32 0, i32 2
store %Rect* (i8*, i8*, %Rect*)* @hcopy_adhoc_W1JlY3QqLFJlY3QqXQ__5505, %Rect* (i8*, i8*, %Rect*)** %closure.func5547
%closure_size5548 = call i64 @llvm_zone_mark_size(%mzone* %zone5533)
call void @llvm_zone_ptr_set_size(i8* %clsptr5534, i64 %closure_size5548)
%wrapper_ptr5549 = call i8* @llvm_zone_malloc(%mzone* %zone5533, i64 8)
%closure_wrapper5550 = bitcast i8* %wrapper_ptr5549 to { i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}**
store { i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}* %closure5535, { i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}** %closure_wrapper5550

; let value assignment
%hcopy_adhoc_W1JlY3QqLFJlY3QqXQ = select i1 true, { i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}** %closure_wrapper5550, { i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}** %closure_wrapper5550
store { i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}** %hcopy_adhoc_W1JlY3QqLFJlY3QqXQ, { i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}*** %hcopy_adhoc_W1JlY3QqLFJlY3QqXQPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1JlY3QqLFJlY3QqXQ
%tmp_envptr5544 = getelementptr {{i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}***}, {{i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}***}* %environment5537, i32 0, i32 0
store {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}*** %hcopy_adhoc_W1JlY3QqLFJlY3QqXQPtr, {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}**** %tmp_envptr5544


%val5553 = load {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}**, {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}*** %hcopy_adhoc_W1JlY3QqLFJlY3QqXQPtr
ret {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}** %val5553
}


@hcopy_adhoc_W1JlY3QqLFJlY3QqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1JlY3QqLFJlY3QqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1JlY3QqLFJlY3QqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1JlY3QqLFJlY3QqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}** @hcopy_adhoc_W1JlY3QqLFJlY3QqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1JlY3QqLFJlY3QqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1JlY3QqLFJlY3QqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1JlY3QqLFJlY3QqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rect* @hcopy_adhoc_W1JlY3QqLFJlY3QqXQ(%Rect* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1JlY3QqLFJlY3QqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}**
%closure = load {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}*, {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}, {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}, {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 1
%ff = load  %Rect* (i8*, i8*, %Rect*)*,  %Rect* (i8*, i8*, %Rect*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect* %ff(i8* %_impz, i8* %ee, %Rect* %arg_0)
ret %Rect* %result
}


define dllexport ccc %Rect* @hcopy_adhoc_W1JlY3QqLFJlY3QqXQ_native(%Rect* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1JlY3QqLFJlY3QqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}**
%closure = load {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}*, {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}, {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}, {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 1
%ff = load  %Rect* (i8*, i8*, %Rect*)*,  %Rect* (i8*, i8*, %Rect*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect* %ff(i8* %_impz, i8* %ee, %Rect* %arg_0)
ret %Rect* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1JlY3QqLFJlY3QqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5554 = bitcast [84 x i8]* @gsxtmnanovg234 to i8*
call i32 (i8*, ...) @printf(i8* %var5554)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Rect*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1JlY3QqLFJlY3QqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}**
%closure = load {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}*, {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}, {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}, {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 1
%ff = load  %Rect* (i8*, i8*, %Rect*)*,  %Rect* (i8*, i8*, %Rect*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect* %ff(i8* %_impz, i8* %ee, %Rect* %arg_0)
%tmpres = bitcast %Rect* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1JlY3QqLFJlY3QqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rect*}*
%arg_p_0 = getelementptr {%Rect*}, {%Rect*}* %fstruct, i32 0, i32 0
%arg_0 = load %Rect*, %Rect** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1JlY3QqLFJlY3QqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}**
%closure = load {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}*, {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}, {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}, {i8*, i8*, %Rect* (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 1
%ff = load  %Rect* (i8*, i8*, %Rect*)*,  %Rect* (i8*, i8*, %Rect*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect* %ff(i8* %_impz, i8* %ee, %Rect* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg235 = hidden constant [29 x i8] c"hfree_adhoc_W3ZvaWQsUmVjdCpd\00"
@gsxtmnanovg236 = hidden constant [39 x i8] c"{i8*, i8*, void (i8*, i8*, %Rect*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsUmVjdCpd__5555(i8* %_impz,i8* %_impenv, %Rect* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5556 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Rect*)*}***}*
%hfree_adhoc_W3ZvaWQsUmVjdCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Rect*)*}***}, {{i8*, i8*, void (i8*, i8*, %Rect*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsUmVjdCpdPtr = load {i8*, i8*, void (i8*, i8*, %Rect*)*}***, {i8*, i8*, void (i8*, i8*, %Rect*)*}**** %hfree_adhoc_W3ZvaWQsUmVjdCpdPtr_

; setup arguments
%xPtr = alloca %Rect*
store %Rect* %x, %Rect** %xPtr


%val5557 = load %Rect*, %Rect** %xPtr
%val5558 = bitcast %Rect* %val5557 to i8*
call ccc void @free(i8* %val5558)
ret void
}
@gsxtmnanovg237 = hidden constant [82 x i8] c"hfree_adhoc_W3ZvaWQsUmVjdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Rect*)*}** @hfree_adhoc_W3ZvaWQsUmVjdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5580 = load i8*, i8** %_impzPtr
%zone5581 = bitcast i8* %tzone5580 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsUmVjdCpd
%dat_hfree_adhoc_W3ZvaWQsUmVjdCpd = call i8* @llvm_zone_malloc(%mzone* %zone5581, i64 8)
%hfree_adhoc_W3ZvaWQsUmVjdCpdPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsUmVjdCpd to { i8*, i8*, void (i8*, i8*, %Rect*)*}***
%tzone5561 = load i8*, i8** %_impzPtr
%zone5562 = bitcast i8* %tzone5561 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5562)
; malloc closure structure
%clsptr5563 = call i8* @llvm_zone_malloc(%mzone* %zone5562, i64 24)
%closure5564 = bitcast i8* %clsptr5563 to { i8*, i8*, void (i8*, i8*, %Rect*)*}*

; malloc environment structure
%envptr5565 = call i8* @llvm_zone_malloc(%mzone* %zone5562, i64 8)
%environment5566 = bitcast i8* %envptr5565 to {{i8*, i8*, void (i8*, i8*, %Rect*)*}***}*

; malloc closure address table
%addytable5567 = call %clsvar* @new_address_table()
%var5568 = bitcast [29 x i8]* @gsxtmnanovg235 to i8*
%var5569 = bitcast [39 x i8]* @gsxtmnanovg236 to i8*
%addytable5570 = call %clsvar* @add_address_table(%mzone* %zone5562, i8* %var5568, i32 0, i8* %var5569, i32 3, %clsvar* %addytable5567)
%address-table5571 = bitcast %clsvar* %addytable5570 to i8*

; insert table, function and environment into closure struct
%closure.table5574 = getelementptr { i8*, i8*, void (i8*, i8*, %Rect*)*}, { i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure5564, i32 0, i32 0
store i8* %address-table5571, i8** %closure.table5574
%closure.env5575 = getelementptr { i8*, i8*, void (i8*, i8*, %Rect*)*}, { i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure5564, i32 0, i32 1
store i8* %envptr5565, i8** %closure.env5575
%closure.func5576 = getelementptr { i8*, i8*, void (i8*, i8*, %Rect*)*}, { i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure5564, i32 0, i32 2
store void (i8*, i8*, %Rect*)* @hfree_adhoc_W3ZvaWQsUmVjdCpd__5555, void (i8*, i8*, %Rect*)** %closure.func5576
%closure_size5577 = call i64 @llvm_zone_mark_size(%mzone* %zone5562)
call void @llvm_zone_ptr_set_size(i8* %clsptr5563, i64 %closure_size5577)
%wrapper_ptr5578 = call i8* @llvm_zone_malloc(%mzone* %zone5562, i64 8)
%closure_wrapper5579 = bitcast i8* %wrapper_ptr5578 to { i8*, i8*, void (i8*, i8*, %Rect*)*}**
store { i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure5564, { i8*, i8*, void (i8*, i8*, %Rect*)*}** %closure_wrapper5579

; let value assignment
%hfree_adhoc_W3ZvaWQsUmVjdCpd = select i1 true, { i8*, i8*, void (i8*, i8*, %Rect*)*}** %closure_wrapper5579, { i8*, i8*, void (i8*, i8*, %Rect*)*}** %closure_wrapper5579
store { i8*, i8*, void (i8*, i8*, %Rect*)*}** %hfree_adhoc_W3ZvaWQsUmVjdCpd, { i8*, i8*, void (i8*, i8*, %Rect*)*}*** %hfree_adhoc_W3ZvaWQsUmVjdCpdPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsUmVjdCpd
%tmp_envptr5573 = getelementptr {{i8*, i8*, void (i8*, i8*, %Rect*)*}***}, {{i8*, i8*, void (i8*, i8*, %Rect*)*}***}* %environment5566, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Rect*)*}*** %hfree_adhoc_W3ZvaWQsUmVjdCpdPtr, {i8*, i8*, void (i8*, i8*, %Rect*)*}**** %tmp_envptr5573


%val5582 = load {i8*, i8*, void (i8*, i8*, %Rect*)*}**, {i8*, i8*, void (i8*, i8*, %Rect*)*}*** %hfree_adhoc_W3ZvaWQsUmVjdCpdPtr
ret {i8*, i8*, void (i8*, i8*, %Rect*)*}** %val5582
}


@hfree_adhoc_W3ZvaWQsUmVjdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsUmVjdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsUmVjdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsUmVjdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Rect*)*}** @hfree_adhoc_W3ZvaWQsUmVjdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Rect*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsUmVjdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsUmVjdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsUmVjdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsUmVjdCpd(%Rect* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsUmVjdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Rect*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Rect*)*}*, {i8*, i8*, void (i8*, i8*, %Rect*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rect*)*}, {i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rect*)*}, {i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Rect*)*,  void (i8*, i8*, %Rect*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Rect* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsUmVjdCpd_native(%Rect* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsUmVjdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Rect*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Rect*)*}*, {i8*, i8*, void (i8*, i8*, %Rect*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rect*)*}, {i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rect*)*}, {i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Rect*)*,  void (i8*, i8*, %Rect*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Rect* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsUmVjdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5583 = bitcast [82 x i8]* @gsxtmnanovg237 to i8*
call i32 (i8*, ...) @printf(i8* %var5583)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Rect*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsUmVjdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Rect*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Rect*)*}*, {i8*, i8*, void (i8*, i8*, %Rect*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rect*)*}, {i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rect*)*}, {i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Rect*)*,  void (i8*, i8*, %Rect*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Rect* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsUmVjdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rect*}*
%arg_p_0 = getelementptr {%Rect*}, {%Rect*}* %fstruct, i32 0, i32 0
%arg_0 = load %Rect*, %Rect** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsUmVjdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Rect*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Rect*)*}*, {i8*, i8*, void (i8*, i8*, %Rect*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rect*)*}, {i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rect*)*}, {i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Rect*)*,  void (i8*, i8*, %Rect*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Rect* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg238 = hidden constant [49 x i8] c"zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd\00"
@gsxtmnanovg239 = hidden constant [59 x i8] c"{i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %Rect* @zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd__5584(i8* %_impz,i8* %_impenv, %Rect* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5585 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpdPtr = load {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}***, {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpdPtr_

; setup arguments
%xPtr = alloca %Rect*
store %Rect* %x, %Rect** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val5587 = load %mzone*, %mzone** %fromzPtr
%val5588 = load %Rect*, %Rect** %xPtr
%val5589 = bitcast %Rect* %val5588 to i8*
%res5590 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val5587, i8* %val5589)
br i1 %res5590, label %then5586, label %else5586

then5586:
%val5591 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val5591)
%zone_ptr5592 = bitcast %mzone* %val5591 to i8*
store i8* %zone_ptr5592, i8** %_impzPtr
%tzone5598 = load i8*, i8** %_impzPtr
%zone5599 = bitcast i8* %tzone5598 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Rect*
%tzone5594 = load i8*, i8** %_impzPtr
%zone5595 = bitcast i8* %tzone5594 to %mzone*
%dat5596 = call i8* @llvm_zone_malloc(%mzone* %zone5595, i64 16)
call i8* @memset(i8* %dat5596, i32 0, i64 16)
%val5597 = bitcast i8* %dat5596 to %Rect*

; let value assignment
%obj = select i1 true, %Rect* %val5597, %Rect* %val5597
store %Rect* %obj, %Rect** %objPtr

%val5600 = load %Rect*, %Rect** %objPtr
%val5601 = load %Rect*, %Rect** %xPtr
; tuple ref
%val5602 = getelementptr %Rect, %Rect* %val5601, i64 0, i32 0
%val5603 = load float, float* %val5602
; set tuple
%val5604 = getelementptr %Rect, %Rect* %val5600, i64 0, i32 0
store float %val5603, float* %val5604
%val5605 = load %Rect*, %Rect** %objPtr
%val5606 = load %Rect*, %Rect** %xPtr
; tuple ref
%val5607 = getelementptr %Rect, %Rect* %val5606, i64 0, i32 1
%val5608 = load float, float* %val5607
; set tuple
%val5609 = getelementptr %Rect, %Rect* %val5605, i64 0, i32 1
store float %val5608, float* %val5609
%val5610 = load %Rect*, %Rect** %objPtr
%val5611 = load %Rect*, %Rect** %xPtr
; tuple ref
%val5612 = getelementptr %Rect, %Rect* %val5611, i64 0, i32 2
%val5613 = load float, float* %val5612
; set tuple
%val5614 = getelementptr %Rect, %Rect* %val5610, i64 0, i32 2
store float %val5613, float* %val5614
%val5615 = load %Rect*, %Rect** %objPtr
%val5616 = load %Rect*, %Rect** %xPtr
; tuple ref
%val5617 = getelementptr %Rect, %Rect* %val5616, i64 0, i32 3
%val5618 = load float, float* %val5617
; set tuple
%val5619 = getelementptr %Rect, %Rect* %val5615, i64 0, i32 3
store float %val5618, float* %val5619
%oldzone5620 = call %mzone* @llvm_pop_zone_stack()
%newzone5621 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr5622 = bitcast %mzone* %newzone5621 to i8*
store i8* %zone_ptr5622, i8** %_impzPtr
%val5623 = load %Rect*, %Rect** %objPtr
ret %Rect* %val5623

else5586:
%val5624 = load %Rect*, %Rect** %xPtr
ret %Rect* %val5624
}
@gsxtmnanovg240 = hidden constant [102 x i8] c"zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5644 = load i8*, i8** %_impzPtr
%zone5645 = bitcast i8* %tzone5644 to %mzone*

; let assign value to symbol zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd
%dat_zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone5645, i64 8)
%zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpdPtr = bitcast i8* %dat_zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd to { i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}***
%tzone5625 = load i8*, i8** %_impzPtr
%zone5626 = bitcast i8* %tzone5625 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5626)
; malloc closure structure
%clsptr5627 = call i8* @llvm_zone_malloc(%mzone* %zone5626, i64 24)
%closure5628 = bitcast i8* %clsptr5627 to { i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr5629 = call i8* @llvm_zone_malloc(%mzone* %zone5626, i64 8)
%environment5630 = bitcast i8* %envptr5629 to {{i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable5631 = call %clsvar* @new_address_table()
%var5632 = bitcast [49 x i8]* @gsxtmnanovg238 to i8*
%var5633 = bitcast [59 x i8]* @gsxtmnanovg239 to i8*
%addytable5634 = call %clsvar* @add_address_table(%mzone* %zone5626, i8* %var5632, i32 0, i8* %var5633, i32 3, %clsvar* %addytable5631)
%address-table5635 = bitcast %clsvar* %addytable5634 to i8*

; insert table, function and environment into closure struct
%closure.table5638 = getelementptr { i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}, { i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}* %closure5628, i32 0, i32 0
store i8* %address-table5635, i8** %closure.table5638
%closure.env5639 = getelementptr { i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}, { i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}* %closure5628, i32 0, i32 1
store i8* %envptr5629, i8** %closure.env5639
%closure.func5640 = getelementptr { i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}, { i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}* %closure5628, i32 0, i32 2
store %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)* @zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd__5584, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)** %closure.func5640
%closure_size5641 = call i64 @llvm_zone_mark_size(%mzone* %zone5626)
call void @llvm_zone_ptr_set_size(i8* %clsptr5627, i64 %closure_size5641)
%wrapper_ptr5642 = call i8* @llvm_zone_malloc(%mzone* %zone5626, i64 8)
%closure_wrapper5643 = bitcast i8* %wrapper_ptr5642 to { i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}**
store { i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}* %closure5628, { i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}** %closure_wrapper5643

; let value assignment
%zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd = select i1 true, { i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}** %closure_wrapper5643, { i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}** %closure_wrapper5643
store { i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd, { i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd
%tmp_envptr5637 = getelementptr {{i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}***}* %environment5630, i32 0, i32 0
store {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpdPtr, {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}**** %tmp_envptr5637


%val5646 = load {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}**, {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpdPtr
ret {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}** %val5646
}


@zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rect* @zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd(%Rect* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}*, {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}, {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}, {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*,  %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect* %ff(i8* %_impz, i8* %ee, %Rect* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %Rect* %result
}


define dllexport ccc %Rect* @zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd_native(%Rect* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}*, {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}, {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}, {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*,  %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect* %ff(i8* %_impz, i8* %ee, %Rect* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %Rect* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5647 = bitcast [102 x i8]* @gsxtmnanovg240 to i8*
call i32 (i8*, ...) @printf(i8* %var5647)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Rect*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5648 = bitcast [102 x i8]* @gsxtmnanovg240 to i8*
call i32 (i8*, ...) @printf(i8* %var5648)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5649 = bitcast [102 x i8]* @gsxtmnanovg240 to i8*
call i32 (i8*, ...) @printf(i8* %var5649)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}*, {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}, {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}, {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*,  %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect* %ff(i8* %_impz, i8* %ee, %Rect* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %Rect* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rect*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%Rect*, %mzone*, %mzone*}, {%Rect*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %Rect*, %Rect** %arg_p_0
%arg_p_1 = getelementptr {%Rect*, %mzone*, %mzone*}, {%Rect*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%Rect*, %mzone*, %mzone*}, {%Rect*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1JlY3QqLFJlY3QqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}*, {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}, {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}, {i8*, i8*, %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)*,  %Rect* (i8*, i8*, %Rect*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rect* %ff(i8* %_impz, i8* %ee, %Rect* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg241 = hidden constant [11 x i8] c"<Rect 0x0>\00"
@gsxtmnanovg242 = hidden constant [36 x i8] c"<Rect: x=%.3f y=%.3f w=%.3f h=%.3f>\00"
@gsxtmnanovg243 = hidden constant [29 x i8] c"print_adhoc_W3ZvaWQsUmVjdCpd\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsUmVjdCpd__5650(i8* %_impz,i8* %_impenv, %Rect* %rct) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5651 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Rect*)*}***}*
%print_adhoc_W3ZvaWQsUmVjdCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Rect*)*}***}, {{i8*, i8*, void (i8*, i8*, %Rect*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsUmVjdCpdPtr = load {i8*, i8*, void (i8*, i8*, %Rect*)*}***, {i8*, i8*, void (i8*, i8*, %Rect*)*}**** %print_adhoc_W3ZvaWQsUmVjdCpdPtr_

; setup arguments
%rctPtr = alloca %Rect*
store %Rect* %rct, %Rect** %rctPtr

; promote local stack var allocations
%tzone5677 = load i8*, i8** %_impzPtr
%zone5678 = bitcast i8* %tzone5677 to %mzone*
%ifptr5652 = alloca i32

%val5653 = load %Rect*, %Rect** %rctPtr
%val5654 = icmp eq %Rect* %val5653, null
br i1 %val5654, label %then5652, label %else5652

then5652:
%var5655 = bitcast [11 x i8]* @gsxtmnanovg241 to i8*

%val5656 = call i32 (i8*, ...) @printf(i8* %var5655)
store i32 %val5656, i32* %ifptr5652
br label %ifcont5652

else5652:
%var5657 = bitcast [36 x i8]* @gsxtmnanovg242 to i8*
%val5658 = load %Rect*, %Rect** %rctPtr
; tuple ref
%val5659 = getelementptr %Rect, %Rect* %val5658, i64 0, i32 0
%val5660 = load float, float* %val5659
%val5661 = fpext float %val5660 to double
%val5662 = load %Rect*, %Rect** %rctPtr
; tuple ref
%val5663 = getelementptr %Rect, %Rect* %val5662, i64 0, i32 1
%val5664 = load float, float* %val5663
%val5665 = fpext float %val5664 to double
%val5666 = load %Rect*, %Rect** %rctPtr
; tuple ref
%val5667 = getelementptr %Rect, %Rect* %val5666, i64 0, i32 2
%val5668 = load float, float* %val5667
%val5669 = fpext float %val5668 to double
%val5670 = load %Rect*, %Rect** %rctPtr
; tuple ref
%val5671 = getelementptr %Rect, %Rect* %val5670, i64 0, i32 3
%val5672 = load float, float* %val5671
%val5673 = fpext float %val5672 to double

%val5674 = call i32 (i8*, ...) @printf(i8* %var5657, double %val5661, double %val5665, double %val5669, double %val5673)
store i32 %val5674, i32* %ifptr5652
br label %ifcont5652

ifcont5652:
%ifres5675 = load i32, i32* %ifptr5652

ret void
}
@gsxtmnanovg244 = hidden constant [82 x i8] c"print_adhoc_W3ZvaWQsUmVjdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Rect*)*}** @print_adhoc_W3ZvaWQsUmVjdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5698 = load i8*, i8** %_impzPtr
%zone5699 = bitcast i8* %tzone5698 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsUmVjdCpd
%dat_print_adhoc_W3ZvaWQsUmVjdCpd = call i8* @llvm_zone_malloc(%mzone* %zone5699, i64 8)
%print_adhoc_W3ZvaWQsUmVjdCpdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsUmVjdCpd to { i8*, i8*, void (i8*, i8*, %Rect*)*}***
%tzone5679 = load i8*, i8** %_impzPtr
%zone5680 = bitcast i8* %tzone5679 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5680)
; malloc closure structure
%clsptr5681 = call i8* @llvm_zone_malloc(%mzone* %zone5680, i64 24)
%closure5682 = bitcast i8* %clsptr5681 to { i8*, i8*, void (i8*, i8*, %Rect*)*}*

; malloc environment structure
%envptr5683 = call i8* @llvm_zone_malloc(%mzone* %zone5680, i64 8)
%environment5684 = bitcast i8* %envptr5683 to {{i8*, i8*, void (i8*, i8*, %Rect*)*}***}*

; malloc closure address table
%addytable5685 = call %clsvar* @new_address_table()
%var5686 = bitcast [29 x i8]* @gsxtmnanovg243 to i8*
%var5687 = bitcast [39 x i8]* @gsxtmnanovg236 to i8*
%addytable5688 = call %clsvar* @add_address_table(%mzone* %zone5680, i8* %var5686, i32 0, i8* %var5687, i32 3, %clsvar* %addytable5685)
%address-table5689 = bitcast %clsvar* %addytable5688 to i8*

; insert table, function and environment into closure struct
%closure.table5692 = getelementptr { i8*, i8*, void (i8*, i8*, %Rect*)*}, { i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure5682, i32 0, i32 0
store i8* %address-table5689, i8** %closure.table5692
%closure.env5693 = getelementptr { i8*, i8*, void (i8*, i8*, %Rect*)*}, { i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure5682, i32 0, i32 1
store i8* %envptr5683, i8** %closure.env5693
%closure.func5694 = getelementptr { i8*, i8*, void (i8*, i8*, %Rect*)*}, { i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure5682, i32 0, i32 2
store void (i8*, i8*, %Rect*)* @print_adhoc_W3ZvaWQsUmVjdCpd__5650, void (i8*, i8*, %Rect*)** %closure.func5694
%closure_size5695 = call i64 @llvm_zone_mark_size(%mzone* %zone5680)
call void @llvm_zone_ptr_set_size(i8* %clsptr5681, i64 %closure_size5695)
%wrapper_ptr5696 = call i8* @llvm_zone_malloc(%mzone* %zone5680, i64 8)
%closure_wrapper5697 = bitcast i8* %wrapper_ptr5696 to { i8*, i8*, void (i8*, i8*, %Rect*)*}**
store { i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure5682, { i8*, i8*, void (i8*, i8*, %Rect*)*}** %closure_wrapper5697

; let value assignment
%print_adhoc_W3ZvaWQsUmVjdCpd = select i1 true, { i8*, i8*, void (i8*, i8*, %Rect*)*}** %closure_wrapper5697, { i8*, i8*, void (i8*, i8*, %Rect*)*}** %closure_wrapper5697
store { i8*, i8*, void (i8*, i8*, %Rect*)*}** %print_adhoc_W3ZvaWQsUmVjdCpd, { i8*, i8*, void (i8*, i8*, %Rect*)*}*** %print_adhoc_W3ZvaWQsUmVjdCpdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsUmVjdCpd
%tmp_envptr5691 = getelementptr {{i8*, i8*, void (i8*, i8*, %Rect*)*}***}, {{i8*, i8*, void (i8*, i8*, %Rect*)*}***}* %environment5684, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Rect*)*}*** %print_adhoc_W3ZvaWQsUmVjdCpdPtr, {i8*, i8*, void (i8*, i8*, %Rect*)*}**** %tmp_envptr5691


%val5700 = load {i8*, i8*, void (i8*, i8*, %Rect*)*}**, {i8*, i8*, void (i8*, i8*, %Rect*)*}*** %print_adhoc_W3ZvaWQsUmVjdCpdPtr
ret {i8*, i8*, void (i8*, i8*, %Rect*)*}** %val5700
}


@print_adhoc_W3ZvaWQsUmVjdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsUmVjdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsUmVjdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsUmVjdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Rect*)*}** @print_adhoc_W3ZvaWQsUmVjdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Rect*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsUmVjdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsUmVjdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsUmVjdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsUmVjdCpd(%Rect* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsUmVjdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Rect*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Rect*)*}*, {i8*, i8*, void (i8*, i8*, %Rect*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rect*)*}, {i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rect*)*}, {i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Rect*)*,  void (i8*, i8*, %Rect*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Rect* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsUmVjdCpd_native(%Rect* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsUmVjdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Rect*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Rect*)*}*, {i8*, i8*, void (i8*, i8*, %Rect*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rect*)*}, {i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rect*)*}, {i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Rect*)*,  void (i8*, i8*, %Rect*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Rect* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsUmVjdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5701 = bitcast [82 x i8]* @gsxtmnanovg244 to i8*
call i32 (i8*, ...) @printf(i8* %var5701)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Rect*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsUmVjdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Rect*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Rect*)*}*, {i8*, i8*, void (i8*, i8*, %Rect*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rect*)*}, {i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rect*)*}, {i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Rect*)*,  void (i8*, i8*, %Rect*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Rect* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsUmVjdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rect*}*
%arg_p_0 = getelementptr {%Rect*}, {%Rect*}* %fstruct, i32 0, i32 0
%arg_0 = load %Rect*, %Rect** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsUmVjdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Rect*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Rect*)*}*, {i8*, i8*, void (i8*, i8*, %Rect*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rect*)*}, {i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rect*)*}, {i8*, i8*, void (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Rect*)*,  void (i8*, i8*, %Rect*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Rect* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg245 = hidden constant [36 x i8] c"toString_adhoc_W1N0cmluZyosUmVjdCpd\00"
@gsxtmnanovg246 = hidden constant [43 x i8] c"{i8*, i8*, %String* (i8*, i8*, %Rect*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosUmVjdCpd__5702(i8* %_impz,i8* %_impenv, %Rect* %rct) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5703 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %Rect*)*}***}*
%toString_adhoc_W1N0cmluZyosUmVjdCpdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %Rect*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %Rect*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosUmVjdCpdPtr = load {i8*, i8*, %String* (i8*, i8*, %Rect*)*}***, {i8*, i8*, %String* (i8*, i8*, %Rect*)*}**** %toString_adhoc_W1N0cmluZyosUmVjdCpdPtr_

; setup arguments
%rctPtr = alloca %Rect*
store %Rect* %rct, %Rect** %rctPtr


%tzone5705 = load i8*, i8** %_impzPtr
%zone5706 = bitcast i8* %tzone5705 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat5704 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat5704, i8* %dat5704
store i8* %str, i8** %strPtr

; promote local stack var allocations
%tzone5735 = load i8*, i8** %_impzPtr
%zone5736 = bitcast i8* %tzone5735 to %mzone*
%ifptr5707 = alloca i32
%val5708 = load %Rect*, %Rect** %rctPtr
%val5709 = icmp eq %Rect* %val5708, null
br i1 %val5709, label %then5707, label %else5707

then5707:
%val5710 = load i8*, i8** %strPtr
%var5711 = bitcast [11 x i8]* @gsxtmnanovg241 to i8*

%val5712 = call i32 (i8*,i8*, ...) @sprintf(i8* %val5710, i8* %var5711)
store i32 %val5712, i32* %ifptr5707
br label %ifcont5707

else5707:
%val5713 = load i8*, i8** %strPtr
%var5714 = bitcast [36 x i8]* @gsxtmnanovg242 to i8*
%val5715 = load %Rect*, %Rect** %rctPtr
; tuple ref
%val5716 = getelementptr %Rect, %Rect* %val5715, i64 0, i32 0
%val5717 = load float, float* %val5716
%val5718 = fpext float %val5717 to double
%val5719 = load %Rect*, %Rect** %rctPtr
; tuple ref
%val5720 = getelementptr %Rect, %Rect* %val5719, i64 0, i32 1
%val5721 = load float, float* %val5720
%val5722 = fpext float %val5721 to double
%val5723 = load %Rect*, %Rect** %rctPtr
; tuple ref
%val5724 = getelementptr %Rect, %Rect* %val5723, i64 0, i32 2
%val5725 = load float, float* %val5724
%val5726 = fpext float %val5725 to double
%val5727 = load %Rect*, %Rect** %rctPtr
; tuple ref
%val5728 = getelementptr %Rect, %Rect* %val5727, i64 0, i32 3
%val5729 = load float, float* %val5728
%val5730 = fpext float %val5729 to double

%val5731 = call i32 (i8*,i8*, ...) @sprintf(i8* %val5713, i8* %var5714, double %val5718, double %val5722, double %val5726, double %val5730)
store i32 %val5731, i32* %ifptr5707
br label %ifcont5707

ifcont5707:
%ifres5732 = load i32, i32* %ifptr5707

%val5733 = load i8*, i8** %strPtr
%res5734 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val5733)
ret %String* %res5734
}
@gsxtmnanovg247 = hidden constant [89 x i8] c"toString_adhoc_W1N0cmluZyosUmVjdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %Rect*)*}** @toString_adhoc_W1N0cmluZyosUmVjdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5756 = load i8*, i8** %_impzPtr
%zone5757 = bitcast i8* %tzone5756 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosUmVjdCpd
%dat_toString_adhoc_W1N0cmluZyosUmVjdCpd = call i8* @llvm_zone_malloc(%mzone* %zone5757, i64 8)
%toString_adhoc_W1N0cmluZyosUmVjdCpdPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosUmVjdCpd to { i8*, i8*, %String* (i8*, i8*, %Rect*)*}***
%tzone5737 = load i8*, i8** %_impzPtr
%zone5738 = bitcast i8* %tzone5737 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5738)
; malloc closure structure
%clsptr5739 = call i8* @llvm_zone_malloc(%mzone* %zone5738, i64 24)
%closure5740 = bitcast i8* %clsptr5739 to { i8*, i8*, %String* (i8*, i8*, %Rect*)*}*

; malloc environment structure
%envptr5741 = call i8* @llvm_zone_malloc(%mzone* %zone5738, i64 8)
%environment5742 = bitcast i8* %envptr5741 to {{i8*, i8*, %String* (i8*, i8*, %Rect*)*}***}*

; malloc closure address table
%addytable5743 = call %clsvar* @new_address_table()
%var5744 = bitcast [36 x i8]* @gsxtmnanovg245 to i8*
%var5745 = bitcast [43 x i8]* @gsxtmnanovg246 to i8*
%addytable5746 = call %clsvar* @add_address_table(%mzone* %zone5738, i8* %var5744, i32 0, i8* %var5745, i32 3, %clsvar* %addytable5743)
%address-table5747 = bitcast %clsvar* %addytable5746 to i8*

; insert table, function and environment into closure struct
%closure.table5750 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Rect*)*}, { i8*, i8*, %String* (i8*, i8*, %Rect*)*}* %closure5740, i32 0, i32 0
store i8* %address-table5747, i8** %closure.table5750
%closure.env5751 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Rect*)*}, { i8*, i8*, %String* (i8*, i8*, %Rect*)*}* %closure5740, i32 0, i32 1
store i8* %envptr5741, i8** %closure.env5751
%closure.func5752 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Rect*)*}, { i8*, i8*, %String* (i8*, i8*, %Rect*)*}* %closure5740, i32 0, i32 2
store %String* (i8*, i8*, %Rect*)* @toString_adhoc_W1N0cmluZyosUmVjdCpd__5702, %String* (i8*, i8*, %Rect*)** %closure.func5752
%closure_size5753 = call i64 @llvm_zone_mark_size(%mzone* %zone5738)
call void @llvm_zone_ptr_set_size(i8* %clsptr5739, i64 %closure_size5753)
%wrapper_ptr5754 = call i8* @llvm_zone_malloc(%mzone* %zone5738, i64 8)
%closure_wrapper5755 = bitcast i8* %wrapper_ptr5754 to { i8*, i8*, %String* (i8*, i8*, %Rect*)*}**
store { i8*, i8*, %String* (i8*, i8*, %Rect*)*}* %closure5740, { i8*, i8*, %String* (i8*, i8*, %Rect*)*}** %closure_wrapper5755

; let value assignment
%toString_adhoc_W1N0cmluZyosUmVjdCpd = select i1 true, { i8*, i8*, %String* (i8*, i8*, %Rect*)*}** %closure_wrapper5755, { i8*, i8*, %String* (i8*, i8*, %Rect*)*}** %closure_wrapper5755
store { i8*, i8*, %String* (i8*, i8*, %Rect*)*}** %toString_adhoc_W1N0cmluZyosUmVjdCpd, { i8*, i8*, %String* (i8*, i8*, %Rect*)*}*** %toString_adhoc_W1N0cmluZyosUmVjdCpdPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosUmVjdCpd
%tmp_envptr5749 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %Rect*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %Rect*)*}***}* %environment5742, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %Rect*)*}*** %toString_adhoc_W1N0cmluZyosUmVjdCpdPtr, {i8*, i8*, %String* (i8*, i8*, %Rect*)*}**** %tmp_envptr5749


%val5758 = load {i8*, i8*, %String* (i8*, i8*, %Rect*)*}**, {i8*, i8*, %String* (i8*, i8*, %Rect*)*}*** %toString_adhoc_W1N0cmluZyosUmVjdCpdPtr
ret {i8*, i8*, %String* (i8*, i8*, %Rect*)*}** %val5758
}


@toString_adhoc_W1N0cmluZyosUmVjdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosUmVjdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosUmVjdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosUmVjdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %Rect*)*}** @toString_adhoc_W1N0cmluZyosUmVjdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %Rect*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosUmVjdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosUmVjdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosUmVjdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosUmVjdCpd(%Rect* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosUmVjdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Rect*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Rect*)*}*, {i8*, i8*, %String* (i8*, i8*, %Rect*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Rect*)*}, {i8*, i8*, %String* (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Rect*)*}, {i8*, i8*, %String* (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Rect*)*,  %String* (i8*, i8*, %Rect*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Rect* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosUmVjdCpd_native(%Rect* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosUmVjdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Rect*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Rect*)*}*, {i8*, i8*, %String* (i8*, i8*, %Rect*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Rect*)*}, {i8*, i8*, %String* (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Rect*)*}, {i8*, i8*, %String* (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Rect*)*,  %String* (i8*, i8*, %Rect*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Rect* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosUmVjdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5759 = bitcast [89 x i8]* @gsxtmnanovg247 to i8*
call i32 (i8*, ...) @printf(i8* %var5759)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Rect*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosUmVjdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Rect*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Rect*)*}*, {i8*, i8*, %String* (i8*, i8*, %Rect*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Rect*)*}, {i8*, i8*, %String* (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Rect*)*}, {i8*, i8*, %String* (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Rect*)*,  %String* (i8*, i8*, %Rect*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Rect* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosUmVjdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rect*}*
%arg_p_0 = getelementptr {%Rect*}, {%Rect*}* %fstruct, i32 0, i32 0
%arg_0 = load %Rect*, %Rect** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosUmVjdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Rect*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Rect*)*}*, {i8*, i8*, %String* (i8*, i8*, %Rect*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Rect*)*}, {i8*, i8*, %String* (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Rect*)*}, {i8*, i8*, %String* (i8*, i8*, %Rect*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Rect*)*,  %String* (i8*, i8*, %Rect*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Rect* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg248 = hidden constant [19 x i8] c"%s/OpenSans-%s.ttf\00"
@gsxtmnanovg249 = hidden constant [47 x i8] c"nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd\00"
@gsxtmnanovg250 = hidden constant [39 x i8] c"{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}**\00"
@gsxtmnanovg251 = hidden constant [13 x i8] c"opensans_dir\00"
@gsxtmnanovg252 = hidden constant [4 x i8] c"i8*\00"
@gsxtmnanovg253 = hidden constant [3 x i8] c"vg\00"
@gsxtmnanovg254 = hidden constant [12 x i8] c"create_font\00"
@gsxtmnanovg255 = hidden constant [35 x i8] c"{i8*, i8*, i32 (i8*, i8*, i8*)*}**\00"
@gsxtmnanovg256 = hidden constant [5 x i8] c"path\00"
define dllexport fastcc i32 @nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd__5761(i8* %_impz,i8* %_impenv, i8* %name) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5771 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}*
%nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpdPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}, {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}* %impenv, i32 0, i32 0
%nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpdPtr = load {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}**** %nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpdPtr_
%opensans_dirPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}, {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}* %impenv, i32 0, i32 1
%opensans_dirPtr = load i8**, i8*** %opensans_dirPtr_
%vgPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}, {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}* %impenv, i32 0, i32 2
%vgPtr = load i8**, i8*** %vgPtr_
%create_fontPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}, {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}* %impenv, i32 0, i32 3
%create_fontPtr = load {i8*, i8*, i32 (i8*, i8*, i8*)*}***, {i8*, i8*, i32 (i8*, i8*, i8*)*}**** %create_fontPtr_
%pathPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}, {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}* %impenv, i32 0, i32 4
%pathPtr = load i8**, i8*** %pathPtr_

; setup arguments
%namePtr = alloca i8*
store i8* %name, i8** %namePtr


%val5772 = load i8*, i8** %pathPtr
%var5773 = bitcast [19 x i8]* @gsxtmnanovg248 to i8*
%val5774 = load i8*, i8** %opensans_dirPtr
%val5775 = load i8*, i8** %namePtr

%val5776 = call i32 (i8*,i8*, ...) @sprintf(i8* %val5772, i8* %var5773, i8* %val5774, i8* %val5775)
%val5777 = load i8*, i8** %vgPtr
%val5778 = load i8*, i8** %namePtr
%val5779 = load i8*, i8** %pathPtr
%res5780 = call ccc i32 @nvgCreateFont(i8* %val5777, i8* %val5778, i8* %val5779)
ret i32 %res5780
}
@gsxtmnanovg257 = hidden constant [5 x i8] c"Bold\00"
@gsxtmnanovg258 = hidden constant [37 x i8] c"couldn't load font OpenSans-Bold.ttf\00"
@gsxtmnanovg259 = hidden constant [11 x i8] c"BoldItalic\00"
@gsxtmnanovg260 = hidden constant [43 x i8] c"couldn't load font OpenSans-BoldItalic.ttf\00"
@gsxtmnanovg261 = hidden constant [10 x i8] c"ExtraBold\00"
@gsxtmnanovg262 = hidden constant [42 x i8] c"couldn't load font OpenSans-ExtraBold.ttf\00"
@gsxtmnanovg263 = hidden constant [16 x i8] c"ExtraBoldItalic\00"
@gsxtmnanovg264 = hidden constant [48 x i8] c"couldn't load font OpenSans-ExtraBoldItalic.ttf\00"
@gsxtmnanovg265 = hidden constant [7 x i8] c"Italic\00"
@gsxtmnanovg266 = hidden constant [39 x i8] c"couldn't load font OpenSans-Italic.ttf\00"
@gsxtmnanovg267 = hidden constant [6 x i8] c"Light\00"
@gsxtmnanovg268 = hidden constant [38 x i8] c"couldn't load font OpenSans-Light.ttf\00"
@gsxtmnanovg269 = hidden constant [12 x i8] c"LightItalic\00"
@gsxtmnanovg270 = hidden constant [44 x i8] c"couldn't load font OpenSans-LightItalic.ttf\00"
@gsxtmnanovg271 = hidden constant [8 x i8] c"Regular\00"
@gsxtmnanovg272 = hidden constant [40 x i8] c"couldn't load font OpenSans-Regular.ttf\00"
@gsxtmnanovg273 = hidden constant [9 x i8] c"Semibold\00"
@gsxtmnanovg274 = hidden constant [41 x i8] c"couldn't load font OpenSans-Semibold.ttf\00"
@gsxtmnanovg275 = hidden constant [15 x i8] c"SemiboldItalic\00"
@gsxtmnanovg276 = hidden constant [47 x i8] c"couldn't load font OpenSans-SemiboldItalic.ttf\00"
@gsxtmnanovg277 = hidden constant [35 x i8] c"OpenSans fonts successfully loaded\00"
define dllexport fastcc i1 @nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd__5760(i8* %_impz,i8* %_impenv, i8* %vg, i8* %opensans_dir) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5762 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***}*
%nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpdPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpdPtr = load {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}**** %nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpdPtr_

; setup arguments
%dat_vg = call i8* @llvm_zone_malloc(%mzone* %zone5762, i64 8)
%vgPtr = bitcast i8* %dat_vg to i8**
store i8* %vg, i8** %vgPtr
%dat_opensans_dir = call i8* @llvm_zone_malloc(%mzone* %zone5762, i64 8)
%opensans_dirPtr = bitcast i8* %dat_opensans_dir to i8**
store i8* %opensans_dir, i8** %opensans_dirPtr


%tzone5769 = load i8*, i8** %_impzPtr
%zone5770 = bitcast i8* %tzone5769 to %mzone*

; let assign value to symbol path
%dat_path = call i8* @llvm_zone_malloc(%mzone* %zone5770, i64 8)
%pathPtr = bitcast i8* %dat_path to i8**
%tzone5820 = load i8*, i8** %_impzPtr
%zone5821 = bitcast i8* %tzone5820 to %mzone*

; let assign value to symbol create_font
%dat_create_font = call i8* @llvm_zone_malloc(%mzone* %zone5821, i64 8)
%create_fontPtr = bitcast i8* %dat_create_font to { i8*, i8*, i32 (i8*, i8*, i8*)*}***
%val5763 = getelementptr i64, i64* null, i32 1
%zonesize5764 = mul i64 1, 256
%tzone5765 = load i8*, i8** %_impzPtr
%zone5766 = bitcast i8* %tzone5765 to %mzone*
%dat5767 = call i8* @llvm_zone_malloc(%mzone* %zone5766, i64 %zonesize5764)
call i8* @memset(i8* %dat5767, i32 0, i64 %zonesize5764)
%val5768 = bitcast i8* %dat5767 to i8*

; let value assignment
%path = select i1 true, i8* %val5768, i8* %val5768
store i8* %path, i8** %pathPtr

%tzone5781 = load i8*, i8** %_impzPtr
%zone5782 = bitcast i8* %tzone5781 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5782)
; malloc closure structure
%clsptr5783 = call i8* @llvm_zone_malloc(%mzone* %zone5782, i64 24)
%closure5784 = bitcast i8* %clsptr5783 to { i8*, i8*, i32 (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr5785 = call i8* @llvm_zone_malloc(%mzone* %zone5782, i64 40)
%environment5786 = bitcast i8* %envptr5785 to {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}*

; malloc closure address table
%addytable5787 = call %clsvar* @new_address_table()
%var5788 = bitcast [47 x i8]* @gsxtmnanovg249 to i8*
%var5789 = bitcast [39 x i8]* @gsxtmnanovg250 to i8*
%addytable5790 = call %clsvar* @add_address_table(%mzone* %zone5782, i8* %var5788, i32 0, i8* %var5789, i32 3, %clsvar* %addytable5787)
%var5791 = bitcast [13 x i8]* @gsxtmnanovg251 to i8*
%var5792 = bitcast [4 x i8]* @gsxtmnanovg252 to i8*
%addytable5793 = call %clsvar* @add_address_table(%mzone* %zone5782, i8* %var5791, i32 8, i8* %var5792, i32 3, %clsvar* %addytable5790)
%var5794 = bitcast [3 x i8]* @gsxtmnanovg253 to i8*
%var5795 = bitcast [4 x i8]* @gsxtmnanovg252 to i8*
%addytable5796 = call %clsvar* @add_address_table(%mzone* %zone5782, i8* %var5794, i32 16, i8* %var5795, i32 3, %clsvar* %addytable5793)
%var5797 = bitcast [12 x i8]* @gsxtmnanovg254 to i8*
%var5798 = bitcast [35 x i8]* @gsxtmnanovg255 to i8*
%addytable5799 = call %clsvar* @add_address_table(%mzone* %zone5782, i8* %var5797, i32 24, i8* %var5798, i32 3, %clsvar* %addytable5796)
%var5800 = bitcast [5 x i8]* @gsxtmnanovg256 to i8*
%var5801 = bitcast [4 x i8]* @gsxtmnanovg252 to i8*
%addytable5802 = call %clsvar* @add_address_table(%mzone* %zone5782, i8* %var5800, i32 32, i8* %var5801, i32 3, %clsvar* %addytable5799)
%address-table5803 = bitcast %clsvar* %addytable5802 to i8*

; insert table, function and environment into closure struct
%closure.table5814 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure5784, i32 0, i32 0
store i8* %address-table5803, i8** %closure.table5814
%closure.env5815 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure5784, i32 0, i32 1
store i8* %envptr5785, i8** %closure.env5815
%closure.func5816 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure5784, i32 0, i32 2
store i32 (i8*, i8*, i8*)* @nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd__5761, i32 (i8*, i8*, i8*)** %closure.func5816
%closure_size5817 = call i64 @llvm_zone_mark_size(%mzone* %zone5782)
call void @llvm_zone_ptr_set_size(i8* %clsptr5783, i64 %closure_size5817)
%wrapper_ptr5818 = call i8* @llvm_zone_malloc(%mzone* %zone5782, i64 8)
%closure_wrapper5819 = bitcast i8* %wrapper_ptr5818 to { i8*, i8*, i32 (i8*, i8*, i8*)*}**
store { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure5784, { i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_wrapper5819

; let value assignment
%create_font = select i1 true, { i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_wrapper5819, { i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_wrapper5819
store { i8*, i8*, i32 (i8*, i8*, i8*)*}** %create_font, { i8*, i8*, i32 (i8*, i8*, i8*)*}*** %create_fontPtr

; add data to environment
; don't need to alloc for env var nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd
%tmp_envptr5805 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}, {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}* %environment5786, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}*** %nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpdPtr, {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}**** %tmp_envptr5805

; don't need to alloc for env var opensans_dir
%tmp_envptr5807 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}, {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}* %environment5786, i32 0, i32 1
store i8** %opensans_dirPtr, i8*** %tmp_envptr5807

; don't need to alloc for env var vg
%tmp_envptr5809 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}, {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}* %environment5786, i32 0, i32 2
store i8** %vgPtr, i8*** %tmp_envptr5809

; don't need to alloc for env var create_font
%tmp_envptr5811 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}, {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}* %environment5786, i32 0, i32 3
store {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %create_fontPtr, {i8*, i8*, i32 (i8*, i8*, i8*)*}**** %tmp_envptr5811

; don't need to alloc for env var path
%tmp_envptr5813 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}, {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***, i8**, i8**, {i8*, i8*, i32 (i8*, i8*, i8*)*}***, i8**}* %environment5786, i32 0, i32 4
store i8** %pathPtr, i8*** %tmp_envptr5813


%var5823 = bitcast [5 x i8]* @gsxtmnanovg257 to i8*

; apply closure 
%vval5824 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %create_fontPtr
%val5825 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*,{i8*, i8*, i32 (i8*, i8*, i8*)*}** %vval5824
%fPtr5826 = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %val5825, i32 0, i32 2
%ePtr5827 = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %val5825, i32 0, i32 1
%f5828 = load i32 (i8*, i8*, i8*)*, i32 (i8*, i8*, i8*)** %fPtr5826
%e5829 = load i8*, i8** %ePtr5827
%tzone5830 = load i8*, i8** %_impzPtr
%zone5831 = bitcast i8* %tzone5830 to %mzone*
%z5832 = bitcast %mzone* %zone5831 to i8*
%result5833 = tail call fastcc i32 %f5828(i8* %z5832, i8* %e5829, i8* %var5823)
%cmp5834 = icmp slt i32 %result5833, 0
br i1 %cmp5834, label %then5822, label %else5822

then5822:
%var5835 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var5836 = bitcast [37 x i8]* @gsxtmnanovg258 to i8*

%val5837 = call i32 (i8*, ...) @printf(i8* %var5835, i8* %var5836)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val5839 = trunc i64 0 to i1
ret i1 %val5839

else5822:
%var5841 = bitcast [11 x i8]* @gsxtmnanovg259 to i8*

; apply closure 
%vval5842 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %create_fontPtr
%val5843 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*,{i8*, i8*, i32 (i8*, i8*, i8*)*}** %vval5842
%fPtr5844 = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %val5843, i32 0, i32 2
%ePtr5845 = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %val5843, i32 0, i32 1
%f5846 = load i32 (i8*, i8*, i8*)*, i32 (i8*, i8*, i8*)** %fPtr5844
%e5847 = load i8*, i8** %ePtr5845
%tzone5848 = load i8*, i8** %_impzPtr
%zone5849 = bitcast i8* %tzone5848 to %mzone*
%z5850 = bitcast %mzone* %zone5849 to i8*
%result5851 = tail call fastcc i32 %f5846(i8* %z5850, i8* %e5847, i8* %var5841)
%cmp5852 = icmp slt i32 %result5851, 0
br i1 %cmp5852, label %then5840, label %else5840

then5840:
%var5853 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var5854 = bitcast [43 x i8]* @gsxtmnanovg260 to i8*

%val5855 = call i32 (i8*, ...) @printf(i8* %var5853, i8* %var5854)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val5857 = trunc i64 0 to i1
ret i1 %val5857

else5840:
%var5859 = bitcast [10 x i8]* @gsxtmnanovg261 to i8*

; apply closure 
%vval5860 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %create_fontPtr
%val5861 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*,{i8*, i8*, i32 (i8*, i8*, i8*)*}** %vval5860
%fPtr5862 = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %val5861, i32 0, i32 2
%ePtr5863 = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %val5861, i32 0, i32 1
%f5864 = load i32 (i8*, i8*, i8*)*, i32 (i8*, i8*, i8*)** %fPtr5862
%e5865 = load i8*, i8** %ePtr5863
%tzone5866 = load i8*, i8** %_impzPtr
%zone5867 = bitcast i8* %tzone5866 to %mzone*
%z5868 = bitcast %mzone* %zone5867 to i8*
%result5869 = tail call fastcc i32 %f5864(i8* %z5868, i8* %e5865, i8* %var5859)
%cmp5870 = icmp slt i32 %result5869, 0
br i1 %cmp5870, label %then5858, label %else5858

then5858:
%var5871 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var5872 = bitcast [42 x i8]* @gsxtmnanovg262 to i8*

%val5873 = call i32 (i8*, ...) @printf(i8* %var5871, i8* %var5872)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val5875 = trunc i64 0 to i1
ret i1 %val5875

else5858:
%var5877 = bitcast [16 x i8]* @gsxtmnanovg263 to i8*

; apply closure 
%vval5878 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %create_fontPtr
%val5879 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*,{i8*, i8*, i32 (i8*, i8*, i8*)*}** %vval5878
%fPtr5880 = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %val5879, i32 0, i32 2
%ePtr5881 = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %val5879, i32 0, i32 1
%f5882 = load i32 (i8*, i8*, i8*)*, i32 (i8*, i8*, i8*)** %fPtr5880
%e5883 = load i8*, i8** %ePtr5881
%tzone5884 = load i8*, i8** %_impzPtr
%zone5885 = bitcast i8* %tzone5884 to %mzone*
%z5886 = bitcast %mzone* %zone5885 to i8*
%result5887 = tail call fastcc i32 %f5882(i8* %z5886, i8* %e5883, i8* %var5877)
%cmp5888 = icmp slt i32 %result5887, 0
br i1 %cmp5888, label %then5876, label %else5876

then5876:
%var5889 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var5890 = bitcast [48 x i8]* @gsxtmnanovg264 to i8*

%val5891 = call i32 (i8*, ...) @printf(i8* %var5889, i8* %var5890)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val5893 = trunc i64 0 to i1
ret i1 %val5893

else5876:
%var5895 = bitcast [7 x i8]* @gsxtmnanovg265 to i8*

; apply closure 
%vval5896 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %create_fontPtr
%val5897 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*,{i8*, i8*, i32 (i8*, i8*, i8*)*}** %vval5896
%fPtr5898 = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %val5897, i32 0, i32 2
%ePtr5899 = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %val5897, i32 0, i32 1
%f5900 = load i32 (i8*, i8*, i8*)*, i32 (i8*, i8*, i8*)** %fPtr5898
%e5901 = load i8*, i8** %ePtr5899
%tzone5902 = load i8*, i8** %_impzPtr
%zone5903 = bitcast i8* %tzone5902 to %mzone*
%z5904 = bitcast %mzone* %zone5903 to i8*
%result5905 = tail call fastcc i32 %f5900(i8* %z5904, i8* %e5901, i8* %var5895)
%cmp5906 = icmp slt i32 %result5905, 0
br i1 %cmp5906, label %then5894, label %else5894

then5894:
%var5907 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var5908 = bitcast [39 x i8]* @gsxtmnanovg266 to i8*

%val5909 = call i32 (i8*, ...) @printf(i8* %var5907, i8* %var5908)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val5911 = trunc i64 0 to i1
ret i1 %val5911

else5894:
%var5913 = bitcast [6 x i8]* @gsxtmnanovg267 to i8*

; apply closure 
%vval5914 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %create_fontPtr
%val5915 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*,{i8*, i8*, i32 (i8*, i8*, i8*)*}** %vval5914
%fPtr5916 = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %val5915, i32 0, i32 2
%ePtr5917 = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %val5915, i32 0, i32 1
%f5918 = load i32 (i8*, i8*, i8*)*, i32 (i8*, i8*, i8*)** %fPtr5916
%e5919 = load i8*, i8** %ePtr5917
%tzone5920 = load i8*, i8** %_impzPtr
%zone5921 = bitcast i8* %tzone5920 to %mzone*
%z5922 = bitcast %mzone* %zone5921 to i8*
%result5923 = tail call fastcc i32 %f5918(i8* %z5922, i8* %e5919, i8* %var5913)
%cmp5924 = icmp slt i32 %result5923, 0
br i1 %cmp5924, label %then5912, label %else5912

then5912:
%var5925 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var5926 = bitcast [38 x i8]* @gsxtmnanovg268 to i8*

%val5927 = call i32 (i8*, ...) @printf(i8* %var5925, i8* %var5926)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val5929 = trunc i64 0 to i1
ret i1 %val5929

else5912:
%var5931 = bitcast [12 x i8]* @gsxtmnanovg269 to i8*

; apply closure 
%vval5932 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %create_fontPtr
%val5933 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*,{i8*, i8*, i32 (i8*, i8*, i8*)*}** %vval5932
%fPtr5934 = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %val5933, i32 0, i32 2
%ePtr5935 = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %val5933, i32 0, i32 1
%f5936 = load i32 (i8*, i8*, i8*)*, i32 (i8*, i8*, i8*)** %fPtr5934
%e5937 = load i8*, i8** %ePtr5935
%tzone5938 = load i8*, i8** %_impzPtr
%zone5939 = bitcast i8* %tzone5938 to %mzone*
%z5940 = bitcast %mzone* %zone5939 to i8*
%result5941 = tail call fastcc i32 %f5936(i8* %z5940, i8* %e5937, i8* %var5931)
%cmp5942 = icmp slt i32 %result5941, 0
br i1 %cmp5942, label %then5930, label %else5930

then5930:
%var5943 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var5944 = bitcast [44 x i8]* @gsxtmnanovg270 to i8*

%val5945 = call i32 (i8*, ...) @printf(i8* %var5943, i8* %var5944)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val5947 = trunc i64 0 to i1
ret i1 %val5947

else5930:
%var5949 = bitcast [8 x i8]* @gsxtmnanovg271 to i8*

; apply closure 
%vval5950 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %create_fontPtr
%val5951 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*,{i8*, i8*, i32 (i8*, i8*, i8*)*}** %vval5950
%fPtr5952 = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %val5951, i32 0, i32 2
%ePtr5953 = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %val5951, i32 0, i32 1
%f5954 = load i32 (i8*, i8*, i8*)*, i32 (i8*, i8*, i8*)** %fPtr5952
%e5955 = load i8*, i8** %ePtr5953
%tzone5956 = load i8*, i8** %_impzPtr
%zone5957 = bitcast i8* %tzone5956 to %mzone*
%z5958 = bitcast %mzone* %zone5957 to i8*
%result5959 = tail call fastcc i32 %f5954(i8* %z5958, i8* %e5955, i8* %var5949)
%cmp5960 = icmp slt i32 %result5959, 0
br i1 %cmp5960, label %then5948, label %else5948

then5948:
%var5961 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var5962 = bitcast [40 x i8]* @gsxtmnanovg272 to i8*

%val5963 = call i32 (i8*, ...) @printf(i8* %var5961, i8* %var5962)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val5965 = trunc i64 0 to i1
ret i1 %val5965

else5948:
%var5967 = bitcast [9 x i8]* @gsxtmnanovg273 to i8*

; apply closure 
%vval5968 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %create_fontPtr
%val5969 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*,{i8*, i8*, i32 (i8*, i8*, i8*)*}** %vval5968
%fPtr5970 = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %val5969, i32 0, i32 2
%ePtr5971 = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %val5969, i32 0, i32 1
%f5972 = load i32 (i8*, i8*, i8*)*, i32 (i8*, i8*, i8*)** %fPtr5970
%e5973 = load i8*, i8** %ePtr5971
%tzone5974 = load i8*, i8** %_impzPtr
%zone5975 = bitcast i8* %tzone5974 to %mzone*
%z5976 = bitcast %mzone* %zone5975 to i8*
%result5977 = tail call fastcc i32 %f5972(i8* %z5976, i8* %e5973, i8* %var5967)
%cmp5978 = icmp slt i32 %result5977, 0
br i1 %cmp5978, label %then5966, label %else5966

then5966:
%var5979 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var5980 = bitcast [41 x i8]* @gsxtmnanovg274 to i8*

%val5981 = call i32 (i8*, ...) @printf(i8* %var5979, i8* %var5980)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val5983 = trunc i64 0 to i1
ret i1 %val5983

else5966:
%var5985 = bitcast [15 x i8]* @gsxtmnanovg275 to i8*

; apply closure 
%vval5986 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %create_fontPtr
%val5987 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*,{i8*, i8*, i32 (i8*, i8*, i8*)*}** %vval5986
%fPtr5988 = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %val5987, i32 0, i32 2
%ePtr5989 = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %val5987, i32 0, i32 1
%f5990 = load i32 (i8*, i8*, i8*)*, i32 (i8*, i8*, i8*)** %fPtr5988
%e5991 = load i8*, i8** %ePtr5989
%tzone5992 = load i8*, i8** %_impzPtr
%zone5993 = bitcast i8* %tzone5992 to %mzone*
%z5994 = bitcast %mzone* %zone5993 to i8*
%result5995 = tail call fastcc i32 %f5990(i8* %z5994, i8* %e5991, i8* %var5985)
%cmp5996 = icmp slt i32 %result5995, 0
br i1 %cmp5996, label %then5984, label %else5984

then5984:
%var5997 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var5998 = bitcast [47 x i8]* @gsxtmnanovg276 to i8*

%val5999 = call i32 (i8*, ...) @printf(i8* %var5997, i8* %var5998)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val6001 = trunc i64 0 to i1
ret i1 %val6001

else5984:
%var6002 = bitcast [3 x i8]* @gsxtmnanovg61 to i8*
%var6003 = bitcast [35 x i8]* @gsxtmnanovg277 to i8*

%val6004 = call i32 (i8*, ...) @printf(i8* %var6002, i8* %var6003)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val6006 = trunc i64 1 to i1
ret i1 %val6006
}
@gsxtmnanovg278 = hidden constant [100 x i8] c"nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}** @nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6026 = load i8*, i8** %_impzPtr
%zone6027 = bitcast i8* %tzone6026 to %mzone*

; let assign value to symbol nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd
%dat_nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone6027, i64 8)
%nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpdPtr = bitcast i8* %dat_nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd to { i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***
%tzone6007 = load i8*, i8** %_impzPtr
%zone6008 = bitcast i8* %tzone6007 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6008)
; malloc closure structure
%clsptr6009 = call i8* @llvm_zone_malloc(%mzone* %zone6008, i64 24)
%closure6010 = bitcast i8* %clsptr6009 to { i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}*

; malloc environment structure
%envptr6011 = call i8* @llvm_zone_malloc(%mzone* %zone6008, i64 8)
%environment6012 = bitcast i8* %envptr6011 to {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable6013 = call %clsvar* @new_address_table()
%var6014 = bitcast [47 x i8]* @gsxtmnanovg249 to i8*
%var6015 = bitcast [39 x i8]* @gsxtmnanovg250 to i8*
%addytable6016 = call %clsvar* @add_address_table(%mzone* %zone6008, i8* %var6014, i32 0, i8* %var6015, i32 3, %clsvar* %addytable6013)
%address-table6017 = bitcast %clsvar* %addytable6016 to i8*

; insert table, function and environment into closure struct
%closure.table6020 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}, { i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}* %closure6010, i32 0, i32 0
store i8* %address-table6017, i8** %closure.table6020
%closure.env6021 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}, { i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}* %closure6010, i32 0, i32 1
store i8* %envptr6011, i8** %closure.env6021
%closure.func6022 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}, { i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}* %closure6010, i32 0, i32 2
store i1 (i8*, i8*, i8*, i8*)* @nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd__5760, i1 (i8*, i8*, i8*, i8*)** %closure.func6022
%closure_size6023 = call i64 @llvm_zone_mark_size(%mzone* %zone6008)
call void @llvm_zone_ptr_set_size(i8* %clsptr6009, i64 %closure_size6023)
%wrapper_ptr6024 = call i8* @llvm_zone_malloc(%mzone* %zone6008, i64 8)
%closure_wrapper6025 = bitcast i8* %wrapper_ptr6024 to { i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}**
store { i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}* %closure6010, { i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}** %closure_wrapper6025

; let value assignment
%nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd = select i1 true, { i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}** %closure_wrapper6025, { i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}** %closure_wrapper6025
store { i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}** %nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd, { i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}*** %nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpdPtr

; add data to environment
; don't need to alloc for env var nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd
%tmp_envptr6019 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}***}* %environment6012, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}*** %nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpdPtr, {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}**** %tmp_envptr6019


%val6028 = load {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}**, {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}*** %nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpdPtr
ret {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}** %val6028
}


@nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}** @nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd(i8* %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*, i8*)*,  i1 (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
ret i1 %result
}


define dllexport ccc i1 @nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd_native(i8* %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*, i8*)*,  i1 (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
ret i1 %result
}


define dllexport ccc i8*  @nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6029 = bitcast [100 x i8]* @gsxtmnanovg278 to i8*
call i32 (i8*, ...) @printf(i8* %var6029)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6030 = bitcast [100 x i8]* @gsxtmnanovg278 to i8*
call i32 (i8*, ...) @printf(i8* %var6030)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*, i8*)*,  i1 (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i8*}*
%arg_p_0 = getelementptr {i8*, i8*}, {i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i8*}, {i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_load_opensans_fonts_adhoc_W2kxLGk4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*, i8*)*,  i1 (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmnanovg279 = hidden constant [72 x i8] c"nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0\00"
@gsxtmnanovg280 = hidden constant [71 x i8] c"{i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}**\00"
define dllexport fastcc void @nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0__6031(i8* %_impz,i8* %_impenv, i8* %vg, %String* %text, %Rect* %bounds, %String* %face, float %font_size) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6032 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}***}*
%nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}***}* %impenv, i32 0, i32 0
%nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0Ptr = load {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}***, {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}**** %nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0Ptr_

; setup arguments
%vgPtr = alloca i8*
store i8* %vg, i8** %vgPtr
%textPtr = alloca %String*
store %String* %text, %String** %textPtr
%boundsPtr = alloca %Rect*
store %Rect* %bounds, %Rect** %boundsPtr
%facePtr = alloca %String*
store %String* %face, %String** %facePtr
%font_sizePtr = alloca float
store float %font_size, float* %font_sizePtr


%tzone6036 = load i8*, i8** %_impzPtr
%zone6037 = bitcast i8* %tzone6036 to %mzone*

; let assign value to symbol h
%hPtr = alloca float
%tzone6039 = load i8*, i8** %_impzPtr
%zone6040 = bitcast i8* %tzone6039 to %mzone*

; let assign value to symbol textbox_height
%textbox_heightPtr = alloca float
%tzone6042 = load i8*, i8** %_impzPtr
%zone6043 = bitcast i8* %tzone6042 to %mzone*

; let assign value to symbol b_ptr
%b_ptrPtr = alloca float*
%val6033 = load %Rect*, %Rect** %boundsPtr
; tuple ref
%val6034 = getelementptr %Rect, %Rect* %val6033, i64 0, i32 3
%val6035 = load float, float* %val6034

; let value assignment
%h = select i1 true, float %val6035, float %val6035
store float %h, float* %hPtr

%val6038 = load float, float* %font_sizePtr

; let value assignment
%textbox_height = select i1 true, float %val6038, float %val6038
store float %textbox_height, float* %textbox_heightPtr

%dat6041 = alloca float, i64 4, align 16

; let value assignment
%b_ptr = select i1 true, float* %dat6041, float* %dat6041
store float* %b_ptr, float** %b_ptrPtr

%val6044 = load i8*, i8** %vgPtr
%val6045 = load i32, i32* @NVG_ALIGN_BOTTOM
%val6046 = load i32, i32* @NVG_ALIGN_CENTER
%val6047 = or i32 %val6045, %val6046
call ccc void @nvgTextAlign(i8* %val6044, i32 %val6047)
%val6049 = load i8*, i8** %vgPtr
%val6050 = load %String*, %String** %facePtr
%res6051 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val6050)
call ccc void @nvgFontFace(i8* %val6049, i8* %res6051)
%val6053 = load i8*, i8** %vgPtr
%val6054 = load float, float* %font_sizePtr
call ccc void @nvgFontSize(i8* %val6053, float %val6054)
%val6056 = load i8*, i8** %vgPtr
%val6057 = load %Rect*, %Rect** %boundsPtr
; tuple ref
%val6058 = getelementptr %Rect, %Rect* %val6057, i64 0, i32 0
%val6059 = load float, float* %val6058
%val6060 = load %Rect*, %Rect** %boundsPtr
; tuple ref
%val6061 = getelementptr %Rect, %Rect* %val6060, i64 0, i32 1
%val6062 = load float, float* %val6061
%val6063 = load %Rect*, %Rect** %boundsPtr
; tuple ref
%val6064 = getelementptr %Rect, %Rect* %val6063, i64 0, i32 2
%val6065 = load float, float* %val6064
%val6066 = load %String*, %String** %textPtr
%res6067 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val6066)
%null6068 = bitcast i8* null to i8*
%val6069 = load float*, float** %b_ptrPtr
call ccc void @nvgTextBoxBounds(i8* %val6056, float %val6059, float %val6062, float %val6065, i8* %res6067, i8* %null6068, float* %val6069)
; do set!
%val6071 = load float*, float** %b_ptrPtr
; pointer ref
%val6072 = getelementptr float, float* %val6071, i64 3
%val6073 = load float, float* %val6072
%val6074 = load float*, float** %b_ptrPtr
; pointer ref
%val6075 = getelementptr float, float* %val6074, i64 1
%val6076 = load float, float* %val6075
%val6077 = fsub float %val6073, %val6076
store float %val6077, float* %textbox_heightPtr
%val6078 = load i8*, i8** %vgPtr
%val6079 = load %Rect*, %Rect** %boundsPtr
; tuple ref
%val6080 = getelementptr %Rect, %Rect* %val6079, i64 0, i32 0
%val6081 = load float, float* %val6080
%val6082 = load %Rect*, %Rect** %boundsPtr
; tuple ref
%val6083 = getelementptr %Rect, %Rect* %val6082, i64 0, i32 1
%val6084 = load float, float* %val6083
%val6085 = load %Rect*, %Rect** %boundsPtr
; tuple ref
%val6086 = getelementptr %Rect, %Rect* %val6085, i64 0, i32 3
%val6087 = load float, float* %val6086
%val6088 = load float, float* %textbox_heightPtr
%val6089 = fadd float %val6087, %val6088
%val6090 = fdiv float %val6089, 0x4000000000000000
%val6091 = fadd float %val6084, %val6090
%val6092 = load %Rect*, %Rect** %boundsPtr
; tuple ref
%val6093 = getelementptr %Rect, %Rect* %val6092, i64 0, i32 2
%val6094 = load float, float* %val6093
%val6095 = load %String*, %String** %textPtr
%res6096 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val6095)
%null6097 = bitcast i8* null to i8*
call ccc void @nvgTextBox(i8* %val6078, float %val6081, float %val6091, float %val6094, i8* %res6096, i8* %null6097)
ret void
}
@gsxtmnanovg281 = hidden constant [125 x i8] c"nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}** @nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6118 = load i8*, i8** %_impzPtr
%zone6119 = bitcast i8* %tzone6118 to %mzone*

; let assign value to symbol nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0
%dat_nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0 = call i8* @llvm_zone_malloc(%mzone* %zone6119, i64 8)
%nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0Ptr = bitcast i8* %dat_nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0 to { i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}***
%tzone6099 = load i8*, i8** %_impzPtr
%zone6100 = bitcast i8* %tzone6099 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6100)
; malloc closure structure
%clsptr6101 = call i8* @llvm_zone_malloc(%mzone* %zone6100, i64 24)
%closure6102 = bitcast i8* %clsptr6101 to { i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}*

; malloc environment structure
%envptr6103 = call i8* @llvm_zone_malloc(%mzone* %zone6100, i64 8)
%environment6104 = bitcast i8* %envptr6103 to {{i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}***}*

; malloc closure address table
%addytable6105 = call %clsvar* @new_address_table()
%var6106 = bitcast [72 x i8]* @gsxtmnanovg279 to i8*
%var6107 = bitcast [71 x i8]* @gsxtmnanovg280 to i8*
%addytable6108 = call %clsvar* @add_address_table(%mzone* %zone6100, i8* %var6106, i32 0, i8* %var6107, i32 3, %clsvar* %addytable6105)
%address-table6109 = bitcast %clsvar* %addytable6108 to i8*

; insert table, function and environment into closure struct
%closure.table6112 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}, { i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}* %closure6102, i32 0, i32 0
store i8* %address-table6109, i8** %closure.table6112
%closure.env6113 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}, { i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}* %closure6102, i32 0, i32 1
store i8* %envptr6103, i8** %closure.env6113
%closure.func6114 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}, { i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}* %closure6102, i32 0, i32 2
store void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)* @nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0__6031, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)** %closure.func6114
%closure_size6115 = call i64 @llvm_zone_mark_size(%mzone* %zone6100)
call void @llvm_zone_ptr_set_size(i8* %clsptr6101, i64 %closure_size6115)
%wrapper_ptr6116 = call i8* @llvm_zone_malloc(%mzone* %zone6100, i64 8)
%closure_wrapper6117 = bitcast i8* %wrapper_ptr6116 to { i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}**
store { i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}* %closure6102, { i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}** %closure_wrapper6117

; let value assignment
%nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0 = select i1 true, { i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}** %closure_wrapper6117, { i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}** %closure_wrapper6117
store { i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}** %nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0, { i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}*** %nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0Ptr

; add data to environment
; don't need to alloc for env var nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0
%tmp_envptr6111 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}***}* %environment6104, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}*** %nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0Ptr, {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}**** %tmp_envptr6111


%val6120 = load {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}**, {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}*** %nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0Ptr
ret {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}** %val6120
}


@nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0_var = dllexport global [1 x i8*] [ i8* null ]

@nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}** @nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0(i8* %arg_0,%String* %arg_1,%Rect* %arg_2,%String* %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}*, {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}, {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}, {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*,  void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, %String* %arg_1, %Rect* %arg_2, %String* %arg_3, float %arg_4)
ret void
}


define dllexport ccc void @nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0_native(i8* %arg_0,%String* %arg_1,%Rect* %arg_2,%String* %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}*, {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}, {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}, {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*,  void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, %String* %arg_1, %Rect* %arg_2, %String* %arg_3, float %arg_4)
ret void
}


define dllexport ccc i8*  @nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6121 = bitcast [125 x i8]* @gsxtmnanovg281 to i8*
call i32 (i8*, ...) @printf(i8* %var6121)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6122 = bitcast [125 x i8]* @gsxtmnanovg281 to i8*
call i32 (i8*, ...) @printf(i8* %var6122)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %String*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var6123 = bitcast [125 x i8]* @gsxtmnanovg281 to i8*
call i32 (i8*, ...) @printf(i8* %var6123)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Rect*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var6124 = bitcast [125 x i8]* @gsxtmnanovg281 to i8*
call i32 (i8*, ...) @printf(i8* %var6124)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to %String*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var6125 = bitcast [125 x i8]* @gsxtmnanovg281 to i8*
call i32 (i8*, ...) @printf(i8* %var6125)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}*, {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}, {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}, {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*,  void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, %String* %arg_1, %Rect* %arg_2, %String* %arg_3, float %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, %String*, %Rect*, %String*, float}*
%arg_p_0 = getelementptr {i8*, %String*, %Rect*, %String*, float}, {i8*, %String*, %Rect*, %String*, float}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, %String*, %Rect*, %String*, float}, {i8*, %String*, %Rect*, %String*, float}* %fstruct, i32 0, i32 1
%arg_1 = load %String*, %String** %arg_p_1
%arg_p_2 = getelementptr {i8*, %String*, %Rect*, %String*, float}, {i8*, %String*, %Rect*, %String*, float}* %fstruct, i32 0, i32 2
%arg_2 = load %Rect*, %Rect** %arg_p_2
%arg_p_3 = getelementptr {i8*, %String*, %Rect*, %String*, float}, {i8*, %String*, %Rect*, %String*, float}* %fstruct, i32 0, i32 3
%arg_3 = load %String*, %String** %arg_p_3
%arg_p_4 = getelementptr {i8*, %String*, %Rect*, %String*, float}, {i8*, %String*, %Rect*, %String*, float}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @nvg_draw_text_adhoc_W3ZvaWQsaTgqLFN0cmluZyosUmVjdCosU3RyaW5nKixmbG9hdF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}*, {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}, {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}, {i8*, i8*, void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)*,  void (i8*, i8*, i8*, %String*, %Rect*, %String*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, %String* %arg_1, %Rect* %arg_2, %String* %arg_3, float %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


