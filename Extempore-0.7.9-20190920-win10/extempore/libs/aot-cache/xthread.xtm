(sys:load "libs/base/base.xtm" 'quiet)
(sys:load-preload-check 'xthread)
(define *xtmlib-xthread-loaded* #t)
(define *xtmlib-xthread-loaded-timer* (clock:clock))
(set! *impc:aot:prev-compiler-message-level* *impc:compiler:message:level*)
(set! *impc:compiler:message:level* 'low)

(print "Loading ")
(print-with-colors 'blue 'default #t (print 'xtmxthread))
(print " library... ")
(llvm:compile-ir (sys:slurp-file "libs/aot-cache/xtmxthread.ll"));; flush the JIT-compilation queue, so we only get this file's code in the module
(impc:compiler:flush-jit-compilation-queue)
(register-lib-func xtmxthread thread_native_call_adhoc_W2k4KixpOCpd [i8*,i8*]* 0 "" '(let ((thread_native_call_adhoc_1 (lambda (f:i8*) (let ((f2:[void]* (cast f))) (f2) (cast null i8*))))) thread_native_call_adhoc_1))
(bind-poly thread_native_call thread_native_call_adhoc_W2k4KixpOCpd "")
(register-lib-func xtmxthread thread_native_call_with_zone_adhoc_W2k4KixpOCpd [i8*,i8*]* 0 "" '(let ((thread_native_call_with_zone_adhoc_2 (lambda (arg:i8*) (let ((t:<[void]*,mzone*>* (cast arg)) (f (tref t 0)) (z (tref t 1))) (f) (llvm_zone_destroy z) (cast null i8*))))) thread_native_call_with_zone_adhoc_2))
(bind-poly thread_native_call_with_zone thread_native_call_with_zone_adhoc_W2k4KixpOCpd "")
(bind-func async:[[!a]*,[!a]*]* (lambda (f) (let ((z1 (push_new_zone 4096)) (res (convert null)) (running:i1 #t) (finished:i1 #f) (ff (lambda () (push_zone z1) (set! res (f)) (set! finished #t) (pop_zone) void)) (thread null)) (pop_zone) (set! thread (thread_fork (get_native_fptr thread_native_call) (cast ff i8*))) (lambda () (thread_join thread) (let ((r2 (zcopy res z1 (llvm_peek_zone_stack)))) (llvm_zone_destroy z1) (thread_destroy thread) r2)))))
(bind-func async:[[!a]*,[!a,!b]*,!b]* (lambda (f arg) (let ((z1 (push_new_zone 4096)) (res (convert null)) (running:i1 #t) (finished:i1 #f) (ff (lambda () (push_zone z1) (set! res (f arg)) (set! finished #t) (pop_zone) void)) (thread null)) (pop_zone) (set! thread (thread_fork (get_native_fptr thread_native_call) (cast ff i8*))) (lambda () (thread_join thread) (let ((r2 (zcopy res z1 (llvm_peek_zone_stack)))) (llvm_zone_destroy z1) (thread_destroy thread) r2)))))
(bind-func async_done:[i1,[!a]*]* (lambda (f) (cref (cast f [void]*) finished i1)))
(bind-func async_kill:[i1,[!a]*]* (lambda (f) (cset! (cast f [void]*) running #f i1)))
(bind-macro (spawn f) "spawn a new thread" (let* ((sym (symbol->string (gensym))) (s (string-append sym ":[void]*"))) `(let ((z1 (push_new_zone 2048)) (,(string->symbol s) ,f) (k2:i8* (zalloc 10)) (t:<[void]*,mzone*>* (zalloc))) (tset! t 0 ,(string->symbol sym)) (tset! t 1 z1) (pop_zone) (thread_fork (get_native_fptr thread_native_call_with_zone) (cast t i8*)))))
(bind-macro (syncspawn f) "spawn a new thread (sync)" (let* ((sym (symbol->string (gensym))) (s (string-append sym ":[void]*"))) `(let ((,(string->symbol s) ,f)) (pset! spawnz numspawn (thread_fork (get_native_fptr thread_native_call) (cast ,(string->symbol sym) i8*))) (set! numspawn (+ numspawn 1)))))
(bind-macro (sync . expr) "synchronize threads" (begin (define final '(cast null i8*)) (if (not (string-contains? (sexpr->string (car (reverse expr))) "spawn")) (begin (set! final (car (reverse expr))) (set! expr (reverse (cdr (reverse expr)))))) (set! expr (cons 'begin expr)) (set! expr (replace-all expr '((spawn . syncspawn)))) (let ((ijk (gensym))) `(letz (* 1024 1024) ((numspawn 0) (,ijk 0) (spawnz:i8** (alloc 10000))) ,expr (dotimes (,ijk numspawn) (thread_join (pref spawnz ,ijk))) ,final))))
(print-with-colors 'green 'default #t (print "done"))(print " in" (- (clock:clock) *xtmlib-xthread-loaded-timer*) "seconds\n")
(define *xtmlib-xthread-loaded-timer* (clock:clock))
(set! *impc:compiler:message:level* *impc:aot:prev-compiler-message-level*)
