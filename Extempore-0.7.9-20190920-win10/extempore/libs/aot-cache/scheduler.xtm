(sys:load "libs/core/rational.xtm")
(sys:load "libs/core/xthread.xtm")
(sys:load-preload-check 'scheduler)
(define *xtmlib-scheduler-loaded* #t)
(define *xtmlib-scheduler-loaded-timer* (clock:clock))
(set! *impc:aot:prev-compiler-message-level* *impc:compiler:message:level*)
(set! *impc:compiler:message:level* 'low)

(print "Loading ")
(print-with-colors 'blue 'default #t (print 'xtmscheduler))
(print " library... ")
(llvm:compile-ir (sys:slurp-file "libs/aot-cache/xtmscheduler.ll"));; flush the JIT-compilation queue, so we only get this file's code in the module
(impc:compiler:flush-jit-compilation-queue)
(bind-type SchedEvt <!a,i8*,SchedEvt*,SchedEvt*>)
(bind-func SchedEvt:[SchedEvt{!ga_33}*,!ga_33,i8*,SchedEvt:<!ga_33,i8*,SchedEvt*,SchedEvt*>*,SchedEvt:<!ga_33,i8*,SchedEvt*,SchedEvt*>*]* (lambda (arg_0 arg_1 arg_2 arg_3) (let ((obj (zalloc))) (tset! obj 0 arg_0) (tset! obj 1 arg_1) (tset! obj 2 arg_2) (tset! obj 3 arg_3) obj)))
(bind-func SchedEvt_z:[SchedEvt{!ga_33}*,!ga_33,i8*,SchedEvt:<!ga_33,i8*,SchedEvt*,SchedEvt*>*,SchedEvt:<!ga_33,i8*,SchedEvt*,SchedEvt*>*]* (lambda (arg_0 arg_1 arg_2 arg_3) (let ((obj (zalloc))) (tset! obj 0 arg_0) (tset! obj 1 arg_1) (tset! obj 2 arg_2) (tset! obj 3 arg_3) obj)))
(bind-func SchedEvt_h:[SchedEvt{!ga_33}*,!ga_33,i8*,SchedEvt:<!ga_33,i8*,SchedEvt*,SchedEvt*>*,SchedEvt:<!ga_33,i8*,SchedEvt*,SchedEvt*>*]* (lambda (arg_0 arg_1 arg_2 arg_3) (let ((obj (halloc))) (tset! obj 0 arg_0) (tset! obj 1 arg_1) (tset! obj 2 arg_2) (tset! obj 3 arg_3) obj)))
(bind-func toString:[String*,SchedEvt:<!ga_33,i8*,SchedEvt*,SchedEvt*>*]* (lambda (x) (if (null? x) (sprintout "<SchedEvt:null") (sprintout "<SchedEvt:" (tref x 0) "," (tref x 1) "," (tref x 2) "," (tref x 3) ">"))))
(bind-func print:[void,SchedEvt:<!ga_33,i8*,SchedEvt*,SchedEvt*>*]* (lambda (x) (if (null? x) (printout "<SchedEvt:null") (printout "<SchedEvt:" (tref x 0) "," (tref x 1) "," (tref x 2) "," (tref x 3) ">")) void))
(bind-func scheduler_init:[[i64,!a]*,SchedEvt{!a}*,[void,!a]*]* (lambda (el f) (let ((mutex:i8* (mutex_create)) (thread:i8* (thread_self)) (cnt 0) (evtlist:SchedEvt* el) (fp:[void,!a]* f) (element:SchedEvt* null) (next:SchedEvt* null) (prev:SchedEvt* null)) (lambda (time) (set! cnt 0) (mutex_lock mutex) (set! element evtlist) (while (and (not (null? element)) (<= (tref element 0) time)) (set! cnt (+ cnt 1)) (set! fp (cast (llvm_get_function_ptr (tref element 1)))) (fptrcall fp (tref element 0)) (set! next (tref element 3)) (set! prev (tref element 2)) (if (null? prev) (set! evtlist next) (tset! prev 3 next)) (if (not (null? next)) (tset! next 2 prev)) (free element) (set! element next)) (mutex_unlock mutex) cnt))))
(bind-func scheduler_at:[SchedEvt:<!ga_33,i8*,SchedEvt*,SchedEvt*>*,SchedEvt:<!ga_33,i8*,SchedEvt*,SchedEvt*>*,!a]* (let ((prev:SchedEvt* null)) (lambda (evtlist time) (set! prev null) (while (and (not (null? evtlist)) (<= (tref evtlist 0) time)) (set! prev evtlist) (set! evtlist (tref evtlist 3))) prev)))
(bind-func scheduler_evt:[void,[i64,!a]*,!a,i8*]* (let ((evtlist:SchedEvt* null) (next:SchedEvt* null) (new:SchedEvt* null)) (lambda (scheduler time fname) (if (= (thread_equal_self (scheduler.thread)) 0) (mutex_lock (scheduler.mutex))) (set! evtlist (scheduler_at (scheduler.evtlist) time)) (if (null? evtlist) (begin (set! next (scheduler.evtlist)) (set! new (SchedEvt_h time fname null next)) (scheduler.evtlist new) void) (begin (set! next (tref evtlist 3)) (set! new (SchedEvt_h time fname evtlist next)) (tset! evtlist 3 new) (if (not (null? next)) (tset! next 2 new)) void)) (if (= (thread_equal_self (scheduler.thread)) 0) (mutex_unlock (scheduler.mutex))) void)))
(bind-alias SCHED [void]* "")
(bind-macro (sched sname time fname) "" `(scheduler_evt (,(string->symbol (string-append (symbol->string sname) ".scheduler"))) ,time (get_native_name ,fname)))
(bind-alias CLOCKEVT [void,double]* "")
(register-lib-type xtmscheduler SchedEvt_poly_PGRvdWJsZT4 <double,i8*,SchedEvt{double}*,SchedEvt{double}*> "")
(register-lib-func xtmscheduler scheduler_init_poly_W1tpNjQsZG91YmxlXSosU2NoZWRFdnR7ZG91YmxlfSosW3ZvaWQsZG91YmxlXSpdKg [[i64,double]*,SchedEvt{double}*,[void,double]*]* 0 "" '(lambda (el f) (let ((mutex:i8* (mutex_create)) (thread:i8* (thread_self)) (cnt 0) (evtlist:SchedEvt* el) (fp:[void,!a]* f) (element:SchedEvt* null) (next:SchedEvt* null) (prev:SchedEvt* null)) (lambda (time) (set! cnt 0) (mutex_lock mutex) (set! element evtlist) (while (and (not (null? element)) (<= (tref element 0) time)) (set! cnt (+ cnt 1)) (set! fp (cast (llvm_get_function_ptr (tref element 1)))) (fptrcall fp (tref element 0)) (set! next (tref element 3)) (set! prev (tref element 2)) (if (null? prev) (set! evtlist next) (tset! prev 3 next)) (if (not (null? next)) (tset! next 2 prev)) (free element) (set! element next)) (mutex_unlock mutex) cnt))))
(bind-poly scheduler_init scheduler_init_poly_W1tpNjQsZG91YmxlXSosU2NoZWRFdnR7ZG91YmxlfSosW3ZvaWQsZG91YmxlXSpdKg "")
(register-lib-func xtmscheduler clock_scheduler_adhoc_W1t2b2lkXSosZG91YmxlXQ [[void]*,double]* 0 "" '(let ((clock_scheduler_adhoc_1 (lambda (hz:double) (let ((evtlist:SchedEvt{double}* null) (ft:[void,double]* null) (scheduler:[i64,double]* null) (running:i64 1) (time 0.00000000000000000000) (err 0) (i (/ 1.0000000000000000000 hz)) (f (lambda () (spawn (lambda () (set! scheduler (scheduler_init evtlist ft)) (set! time (clock_clock)) (while (> running 0) (scheduler time) (while (< (clock_clock) time) (thread_sleep 0 100000)) (set! time (+ time i)) void) (println "exiting scheduler"))) void))) (f) f)))) clock_scheduler_adhoc_1))
(bind-poly clock_scheduler clock_scheduler_adhoc_W1t2b2lkXSosZG91YmxlXQ "")
(bind-alias BEATEVT [void,Rational]* "")
(register-lib-type xtmscheduler SchedEvt_poly_PFJhdGlvbmFsPg <Rational,i8*,SchedEvt{Rational}*,SchedEvt{Rational}*> "")
(register-lib-func xtmscheduler scheduler_init_poly_W1tpNjQsUmF0aW9uYWxdKixTY2hlZEV2dHtSYXRpb25hbH0qLFt2b2lkLFJhdGlvbmFsXSpdKg [[i64,Rational]*,SchedEvt{Rational}*,[void,Rational]*]* 0 "" '(lambda (el f) (let ((mutex:i8* (mutex_create)) (thread:i8* (thread_self)) (cnt 0) (evtlist:SchedEvt* el) (fp:[void,!a]* f) (element:SchedEvt* null) (next:SchedEvt* null) (prev:SchedEvt* null)) (lambda (time) (set! cnt 0) (mutex_lock mutex) (set! element evtlist) (while (and (not (null? element)) (<= (tref element 0) time)) (set! cnt (+ cnt 1)) (set! fp (cast (llvm_get_function_ptr (tref element 1)))) (fptrcall fp (tref element 0)) (set! next (tref element 3)) (set! prev (tref element 2)) (if (null? prev) (set! evtlist next) (tset! prev 3 next)) (if (not (null? next)) (tset! next 2 prev)) (free element) (set! element next)) (mutex_unlock mutex) cnt))))
(bind-poly scheduler_init scheduler_init_poly_W1tpNjQsUmF0aW9uYWxdKixTY2hlZEV2dHtSYXRpb25hbH0qLFt2b2lkLFJhdGlvbmFsXSpdKg "")
(register-lib-func xtmscheduler beat_scheduler_adhoc_W1t2b2lkXSosZG91YmxlLGRvdWJsZV0 [[void]*,double,double]* 0 "" '(let ((beat_scheduler_adhoc_3 (lambda (bpm:double hz:double) (let ((evtlist:SchedEvt{Rational}* null) (ft:[void,Rational]* null) (scheduler:[i64,Rational]* null) (beat:Rational 1/1) (running:i64 1) (offset:i64 0) (time 0.00000000000000000000) (i (Rat 1 (dtoi64 hz))) (f (lambda () (spawn (lambda () (set! scheduler (scheduler_init evtlist ft)) (set! time (clock_clock)) (while (> running 0) (scheduler beat) (set! beat (+ beat (* i (Rat (dtoi64 bpm) 60)))) (while (< (clock_clock) time) (thread_sleep 0 100000)) (set! time (+ time (rtod i))) void) (println "exiting scheduler"))) void))) (f) f)))) beat_scheduler_adhoc_3))
(bind-poly beat_scheduler beat_scheduler_adhoc_W1t2b2lkXSosZG91YmxlLGRvdWJsZV0 "")
(register-lib-val xtmscheduler MAIN [void]* "")
(call-as-xtlang (set! MAIN (cast (malloc 8) [void]*)) void)
(bind-alias MAINEVT [void,double]* "")
(register-lib-func xtmscheduler clock_scheduler_main_callback_adhoc_W3ZvaWRd [void]* 0 "" '(let ((clock_scheduler_main_callback_adhoc_5 (let ((hz:double 500.00000000000000000) (evtlist:SchedEvt{double}* null) (ft:[void,double]* null) (scheduler:[i64,double]* null) (running:i64 1) (time 0.00000000000000000000) (err 0) (i (/ 1.0000000000000000000 hz))) (lambda () (set! scheduler (scheduler_init evtlist ft)) (set! time (clock_clock)) (while (> running 0) (scheduler time) (while (< (clock_clock) time) (thread_sleep 0 100000)) (set! time (+ time i)) void) void)))) clock_scheduler_main_callback_adhoc_5))
(bind-poly clock_scheduler_main_callback clock_scheduler_main_callback_adhoc_W3ZvaWRd "")
(register-lib-func xtmscheduler run_main_event_loop_adhoc_W3ZvaWRd [void]* 0 "" '(let ((run_main_event_loop_adhoc_6 (lambda () (clock_scheduler_main_callback.hz:double 500.00000000000000000) (xtm_set_main_callback (get_native_fptr clock_scheduler_main_callback)) (set! MAIN clock_scheduler_main_callback) void))) run_main_event_loop_adhoc_6))
(bind-poly run_main_event_loop run_main_event_loop_adhoc_W3ZvaWRd "")
(bind-macro (sched_main . args) "" (if (= (length args) 1) `(scheduler_evt (,(string->symbol (string-append "MAIN" ".scheduler"))) (clock_clock) (get_native_name ,(car args)) null) `(scheduler_evt (,(string->symbol (string-append "MAIN" ".scheduler"))) ,(car args) (get_native_name ,(cadr args)) null)))
(print-with-colors 'green 'default #t (print "done"))(print " in" (- (clock:clock) *xtmlib-scheduler-loaded-timer*) "seconds\n")
(define *xtmlib-scheduler-loaded-timer* (clock:clock))
(set! *impc:compiler:message:level* *impc:aot:prev-compiler-message-level*)
