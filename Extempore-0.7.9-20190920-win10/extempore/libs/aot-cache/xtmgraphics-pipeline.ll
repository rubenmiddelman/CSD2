@gsxtmgraphics-pipeline0 = hidden constant [47 x i8] c"mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0\00"
@gsxtmgraphics-pipeline1 = hidden constant [47 x i8] c"{i8*, i8*, void (i8*, i8*, float*, float*)*}**\00"
define dllexport fastcc void @mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0__1(i8* %_impz,i8* %_impenv, float* %mat4, float* %mat3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float*)*}***}*
%mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*)*}***}* %impenv, i32 0, i32 0
%mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0Ptr = load {i8*, i8*, void (i8*, i8*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, float*)*}**** %mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0Ptr_

; setup arguments
%mat4Ptr = alloca float*
store float* %mat4, float** %mat4Ptr
%mat3Ptr = alloca float*
store float* %mat3, float** %mat3Ptr


%val3 = load float*, float** %mat3Ptr
%val4 = load float*, float** %mat4Ptr
; pointer ref
%val5 = getelementptr float, float* %val4, i64 0
%val6 = load float, float* %val5
; set pointer
%val7 = getelementptr float, float* %val3, i64 0
store float %val6, float* %val7
%val8 = load float*, float** %mat3Ptr
%val9 = load float*, float** %mat4Ptr
; pointer ref
%val10 = getelementptr float, float* %val9, i64 1
%val11 = load float, float* %val10
; set pointer
%val12 = getelementptr float, float* %val8, i64 1
store float %val11, float* %val12
%val13 = load float*, float** %mat3Ptr
%val14 = load float*, float** %mat4Ptr
; pointer ref
%val15 = getelementptr float, float* %val14, i64 2
%val16 = load float, float* %val15
; set pointer
%val17 = getelementptr float, float* %val13, i64 2
store float %val16, float* %val17
%val18 = load float*, float** %mat3Ptr
%val19 = load float*, float** %mat4Ptr
; pointer ref
%val20 = getelementptr float, float* %val19, i64 4
%val21 = load float, float* %val20
; set pointer
%val22 = getelementptr float, float* %val18, i64 3
store float %val21, float* %val22
%val23 = load float*, float** %mat3Ptr
%val24 = load float*, float** %mat4Ptr
; pointer ref
%val25 = getelementptr float, float* %val24, i64 5
%val26 = load float, float* %val25
; set pointer
%val27 = getelementptr float, float* %val23, i64 4
store float %val26, float* %val27
%val28 = load float*, float** %mat3Ptr
%val29 = load float*, float** %mat4Ptr
; pointer ref
%val30 = getelementptr float, float* %val29, i64 6
%val31 = load float, float* %val30
; set pointer
%val32 = getelementptr float, float* %val28, i64 5
store float %val31, float* %val32
%val33 = load float*, float** %mat3Ptr
%val34 = load float*, float** %mat4Ptr
; pointer ref
%val35 = getelementptr float, float* %val34, i64 8
%val36 = load float, float* %val35
; set pointer
%val37 = getelementptr float, float* %val33, i64 6
store float %val36, float* %val37
%val38 = load float*, float** %mat3Ptr
%val39 = load float*, float** %mat4Ptr
; pointer ref
%val40 = getelementptr float, float* %val39, i64 9
%val41 = load float, float* %val40
; set pointer
%val42 = getelementptr float, float* %val38, i64 7
store float %val41, float* %val42
%val43 = load float*, float** %mat3Ptr
%val44 = load float*, float** %mat4Ptr
; pointer ref
%val45 = getelementptr float, float* %val44, i64 10
%val46 = load float, float* %val45
; set pointer
%val47 = getelementptr float, float* %val43, i64 8
store float %val46, float* %val47
ret void
}
@gsxtmgraphics-pipeline2 = hidden constant [100 x i8] c"mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float*)*}** @mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone68 = load i8*, i8** %_impzPtr
%zone69 = bitcast i8* %tzone68 to %mzone*

; let assign value to symbol mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0
%dat_mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone69, i64 8)
%mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0Ptr = bitcast i8* %dat_mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0 to { i8*, i8*, void (i8*, i8*, float*, float*)*}***
%tzone49 = load i8*, i8** %_impzPtr
%zone50 = bitcast i8* %tzone49 to %mzone*
call void @llvm_zone_mark(%mzone* %zone50)
; malloc closure structure
%clsptr51 = call i8* @llvm_zone_malloc(%mzone* %zone50, i64 24)
%closure52 = bitcast i8* %clsptr51 to { i8*, i8*, void (i8*, i8*, float*, float*)*}*

; malloc environment structure
%envptr53 = call i8* @llvm_zone_malloc(%mzone* %zone50, i64 8)
%environment54 = bitcast i8* %envptr53 to {{i8*, i8*, void (i8*, i8*, float*, float*)*}***}*

; malloc closure address table
%addytable55 = call %clsvar* @new_address_table()
%var56 = bitcast [47 x i8]* @gsxtmgraphics-pipeline0 to i8*
%var57 = bitcast [47 x i8]* @gsxtmgraphics-pipeline1 to i8*
%addytable58 = call %clsvar* @add_address_table(%mzone* %zone50, i8* %var56, i32 0, i8* %var57, i32 3, %clsvar* %addytable55)
%address-table59 = bitcast %clsvar* %addytable58 to i8*

; insert table, function and environment into closure struct
%closure.table62 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*)*}* %closure52, i32 0, i32 0
store i8* %address-table59, i8** %closure.table62
%closure.env63 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*)*}* %closure52, i32 0, i32 1
store i8* %envptr53, i8** %closure.env63
%closure.func64 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*)*}* %closure52, i32 0, i32 2
store void (i8*, i8*, float*, float*)* @mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0__1, void (i8*, i8*, float*, float*)** %closure.func64
%closure_size65 = call i64 @llvm_zone_mark_size(%mzone* %zone50)
call void @llvm_zone_ptr_set_size(i8* %clsptr51, i64 %closure_size65)
%wrapper_ptr66 = call i8* @llvm_zone_malloc(%mzone* %zone50, i64 8)
%closure_wrapper67 = bitcast i8* %wrapper_ptr66 to { i8*, i8*, void (i8*, i8*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*, float*)*}* %closure52, { i8*, i8*, void (i8*, i8*, float*, float*)*}** %closure_wrapper67

; let value assignment
%mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float*)*}** %closure_wrapper67, { i8*, i8*, void (i8*, i8*, float*, float*)*}** %closure_wrapper67
store { i8*, i8*, void (i8*, i8*, float*, float*)*}** %mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0, { i8*, i8*, void (i8*, i8*, float*, float*)*}*** %mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0Ptr

; add data to environment
; don't need to alloc for env var mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0
%tmp_envptr61 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*)*}***}* %environment54, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float*)*}*** %mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0Ptr, {i8*, i8*, void (i8*, i8*, float*, float*)*}**** %tmp_envptr61


%val70 = load {i8*, i8*, void (i8*, i8*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, float*)*}*** %mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, float*, float*)*}** %val70
}


@mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float*)*}** @mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0(float* %arg_0,float* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*)*,  void (i8*, i8*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1)
ret void
}


define dllexport ccc void @mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0_native(float* %arg_0,float* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*)*,  void (i8*, i8*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1)
ret void
}


define dllexport ccc i8*  @mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var71 = bitcast [100 x i8]* @gsxtmgraphics-pipeline2 to i8*
call i32 (i8*, ...) @printf(i8* %var71)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var72 = bitcast [100 x i8]* @gsxtmgraphics-pipeline2 to i8*
call i32 (i8*, ...) @printf(i8* %var72)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*)*,  void (i8*, i8*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*}*
%arg_p_0 = getelementptr {float*, float*}, {float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*}, {float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*)*,  void (i8*, i8*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline3 = hidden constant [69 x i8] c"plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0\00"
@gsxtmgraphics-pipeline4 = hidden constant [61 x i8] c"{i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}**\00"
define dllexport fastcc i1 @plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0__73(i8* %_impz,i8* %_impenv, float* %ray_origin, float* %ray_dir, float* %plane_centre, float* %plane_normal) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone74 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}***}*
%plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr = load {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}***, {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}**** %plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr_

; setup arguments
%ray_originPtr = alloca float*
store float* %ray_origin, float** %ray_originPtr
%ray_dirPtr = alloca float*
store float* %ray_dir, float** %ray_dirPtr
%plane_centrePtr = alloca float*
store float* %plane_centre, float** %plane_centrePtr
%plane_normalPtr = alloca float*
store float* %plane_normal, float** %plane_normalPtr


%tzone78 = load i8*, i8** %_impzPtr
%zone79 = bitcast i8* %tzone78 to %mzone*

; let assign value to symbol denom
%denomPtr = alloca float
%tzone80 = load i8*, i8** %_impzPtr
%zone81 = bitcast i8* %tzone80 to %mzone*

; let assign value to symbol t
%tPtr = alloca float
%val75 = load float*, float** %plane_normalPtr
%val76 = load float*, float** %ray_dirPtr
%res77 = call fastcc float @vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ(float* %val75, float* %val76, i64 3)

; let value assignment
%denom = select i1 true, float %res77, float %res77
store float %denom, float* %denomPtr


; let value assignment
%t = select i1 true, float 0xbff0000000000000, float 0xbff0000000000000
store float %t, float* %tPtr

; promote local stack var allocations
%tzone113 = load i8*, i8** %_impzPtr
%zone114 = bitcast i8* %tzone113 to %mzone*
%ifptr98 = alloca i1
%ifptr103 = alloca i1
%ifptr82 = alloca float
%val83 = load float, float* %denomPtr
%val84 = call float @llvm.fabs.f32(float %val83)
%val85 = fptrunc double 0.00010000000000000000479 to float
%cmp86 = fcmp ugt float %val84, %val85
br i1 %cmp86, label %then82, label %else82

then82:
%val87 = load float*, float** %plane_centrePtr
%val88 = load float*, float** %ray_originPtr
%val89 = load float*, float** %plane_centrePtr
call fastcc void @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ(float* %val87, float* %val88, i64 3, float* %val89)
; do set!
%val91 = load float*, float** %plane_centrePtr
%val92 = load float*, float** %plane_normalPtr
%res93 = call fastcc float @vvdot_adhoc_W2Zsb2F0LGZsb2F0KixmbG9hdCosaTY0XQ(float* %val91, float* %val92, i64 3)
%val94 = load float, float* %denomPtr
%val95 = fdiv float %res93, %val94
store float %val95, float* %tPtr
store float %val95, float* %ifptr82
br label %ifcont82

else82:
br label %ifcont82

ifcont82:
%ifres96 = load float, float* %ifptr82

%val99 = load float, float* %tPtr
%cmp100 = fcmp ugt float %val99, 0x0
br i1 %cmp100, label %then98, label %else98

then98:
%val101 = load float, float* %tPtr
%cmp102 = fcmp ugt float %val101, 0x0
store i1 %cmp102, i1* %ifptr98
br label %ifcont98

else98:
%val104 = load float, float* %tPtr
%cmp105 = fcmp ueq float %val104, 0x0
br i1 %cmp105, label %then103, label %else103

then103:
%val106 = load float, float* %tPtr
%cmp107 = fcmp ueq float %val106, 0x0
store i1 %cmp107, i1* %ifptr103
br label %ifcont103

else103:
%res108 = call ccc i1 @impc_false()
store i1 %res108, i1* %ifptr103
br label %ifcont103

ifcont103:
%ifres109 = load i1, i1* %ifptr103

store i1 %ifres109, i1* %ifptr98
br label %ifcont98

ifcont98:
%ifres110 = load i1, i1* %ifptr98

br i1 %ifres110, label %then97, label %else97

then97:
%res111 = call ccc i1 @impc_true()
ret i1 %res111

else97:
%res112 = call ccc i1 @impc_false()
ret i1 %res112
}
@gsxtmgraphics-pipeline5 = hidden constant [122 x i8] c"plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}** @plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone134 = load i8*, i8** %_impzPtr
%zone135 = bitcast i8* %tzone134 to %mzone*

; let assign value to symbol plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0
%dat_plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone135, i64 8)
%plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr = bitcast i8* %dat_plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 to { i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}***
%tzone115 = load i8*, i8** %_impzPtr
%zone116 = bitcast i8* %tzone115 to %mzone*
call void @llvm_zone_mark(%mzone* %zone116)
; malloc closure structure
%clsptr117 = call i8* @llvm_zone_malloc(%mzone* %zone116, i64 24)
%closure118 = bitcast i8* %clsptr117 to { i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}*

; malloc environment structure
%envptr119 = call i8* @llvm_zone_malloc(%mzone* %zone116, i64 8)
%environment120 = bitcast i8* %envptr119 to {{i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}***}*

; malloc closure address table
%addytable121 = call %clsvar* @new_address_table()
%var122 = bitcast [69 x i8]* @gsxtmgraphics-pipeline3 to i8*
%var123 = bitcast [61 x i8]* @gsxtmgraphics-pipeline4 to i8*
%addytable124 = call %clsvar* @add_address_table(%mzone* %zone116, i8* %var122, i32 0, i8* %var123, i32 3, %clsvar* %addytable121)
%address-table125 = bitcast %clsvar* %addytable124 to i8*

; insert table, function and environment into closure struct
%closure.table128 = getelementptr { i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}, { i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}* %closure118, i32 0, i32 0
store i8* %address-table125, i8** %closure.table128
%closure.env129 = getelementptr { i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}, { i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}* %closure118, i32 0, i32 1
store i8* %envptr119, i8** %closure.env129
%closure.func130 = getelementptr { i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}, { i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}* %closure118, i32 0, i32 2
store i1 (i8*, i8*, float*, float*, float*, float*)* @plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0__73, i1 (i8*, i8*, float*, float*, float*, float*)** %closure.func130
%closure_size131 = call i64 @llvm_zone_mark_size(%mzone* %zone116)
call void @llvm_zone_ptr_set_size(i8* %clsptr117, i64 %closure_size131)
%wrapper_ptr132 = call i8* @llvm_zone_malloc(%mzone* %zone116, i64 8)
%closure_wrapper133 = bitcast i8* %wrapper_ptr132 to { i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}**
store { i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}* %closure118, { i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}** %closure_wrapper133

; let value assignment
%plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}** %closure_wrapper133, { i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}** %closure_wrapper133
store { i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}** %plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0, { i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}*** %plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr

; add data to environment
; don't need to alloc for env var plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0
%tmp_envptr127 = getelementptr {{i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}***}* %environment120, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}*** %plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr, {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}**** %tmp_envptr127


%val136 = load {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}**, {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}*** %plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr
ret {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}** %val136
}


@plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}** @plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}*, {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, float*, float*, float*, float*)*,  i1 (i8*, i8*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
ret i1 %result
}


define dllexport ccc i1 @plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_native(float* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}*, {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, float*, float*, float*, float*)*,  i1 (i8*, i8*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
ret i1 %result
}


define dllexport ccc i8*  @plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var137 = bitcast [122 x i8]* @gsxtmgraphics-pipeline5 to i8*
call i32 (i8*, ...) @printf(i8* %var137)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var138 = bitcast [122 x i8]* @gsxtmgraphics-pipeline5 to i8*
call i32 (i8*, ...) @printf(i8* %var138)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var139 = bitcast [122 x i8]* @gsxtmgraphics-pipeline5 to i8*
call i32 (i8*, ...) @printf(i8* %var139)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var140 = bitcast [122 x i8]* @gsxtmgraphics-pipeline5 to i8*
call i32 (i8*, ...) @printf(i8* %var140)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}*, {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, float*, float*, float*, float*)*,  i1 (i8*, i8*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, float*, float*}*
%arg_p_0 = getelementptr {float*, float*, float*, float*}, {float*, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, float*, float*}, {float*, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, float*, float*}, {float*, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {float*, float*, float*, float*}, {float*, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @plane_intersection_adhoc_W2kxLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}*, {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, i1 (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, float*, float*, float*, float*)*,  i1 (i8*, i8*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline6 = hidden constant [66 x i8] c"translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
@gsxtmgraphics-pipeline7 = hidden constant [60 x i8] c"{i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**\00"
define dllexport fastcc void @translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ__141(i8* %_impz,i8* %_impenv, float* %mat, float %x, float %y, float %z) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone142 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***}*
%translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***}* %impenv, i32 0, i32 0
%translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**** %translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%matPtr = alloca float*
store float* %mat, float** %matPtr
%xPtr = alloca float
store float %x, float* %xPtr
%yPtr = alloca float
store float %y, float* %yPtr
%zPtr = alloca float
store float %z, float* %zPtr


%tzone144 = load i8*, i8** %_impzPtr
%zone145 = bitcast i8* %tzone144 to %mzone*

; let assign value to symbol mat2
%mat2Ptr = alloca float*
%tzone148 = load i8*, i8** %_impzPtr
%zone149 = bitcast i8* %tzone148 to %mzone*

; let assign value to symbol mat3
%mat3Ptr = alloca float*
%dat143 = alloca float, i64 32, align 16

; let value assignment
%mat2 = select i1 true, float* %dat143, float* %dat143
store float* %mat2, float** %mat2Ptr

%val146 = load float*, float** %mat2Ptr
; pointer ref
%val147 = getelementptr float, float* %val146, i64 16

; let value assignment
%mat3 = select i1 true, float* %val147, float* %val147
store float* %mat3, float** %mat3Ptr

%val150 = load float*, float** %mat2Ptr
; set pointer
%val151 = getelementptr float, float* %val150, i64 0
store float 0x3ff0000000000000, float* %val151
%val152 = load float*, float** %mat2Ptr
; set pointer
%val153 = getelementptr float, float* %val152, i64 1
store float 0x0, float* %val153
%val154 = load float*, float** %mat2Ptr
; set pointer
%val155 = getelementptr float, float* %val154, i64 2
store float 0x0, float* %val155
%val156 = load float*, float** %mat2Ptr
; set pointer
%val157 = getelementptr float, float* %val156, i64 3
store float 0x0, float* %val157
%val158 = load float*, float** %mat2Ptr
; set pointer
%val159 = getelementptr float, float* %val158, i64 4
store float 0x0, float* %val159
%val160 = load float*, float** %mat2Ptr
; set pointer
%val161 = getelementptr float, float* %val160, i64 5
store float 0x3ff0000000000000, float* %val161
%val162 = load float*, float** %mat2Ptr
; set pointer
%val163 = getelementptr float, float* %val162, i64 6
store float 0x0, float* %val163
%val164 = load float*, float** %mat2Ptr
; set pointer
%val165 = getelementptr float, float* %val164, i64 7
store float 0x0, float* %val165
%val166 = load float*, float** %mat2Ptr
; set pointer
%val167 = getelementptr float, float* %val166, i64 8
store float 0x0, float* %val167
%val168 = load float*, float** %mat2Ptr
; set pointer
%val169 = getelementptr float, float* %val168, i64 9
store float 0x0, float* %val169
%val170 = load float*, float** %mat2Ptr
; set pointer
%val171 = getelementptr float, float* %val170, i64 10
store float 0x3ff0000000000000, float* %val171
%val172 = load float*, float** %mat2Ptr
; set pointer
%val173 = getelementptr float, float* %val172, i64 11
store float 0x0, float* %val173
%val174 = load float*, float** %mat2Ptr
%val175 = load float, float* %xPtr
; set pointer
%val176 = getelementptr float, float* %val174, i64 12
store float %val175, float* %val176
%val177 = load float*, float** %mat2Ptr
%val178 = load float, float* %yPtr
; set pointer
%val179 = getelementptr float, float* %val177, i64 13
store float %val178, float* %val179
%val180 = load float*, float** %mat2Ptr
%val181 = load float, float* %zPtr
; set pointer
%val182 = getelementptr float, float* %val180, i64 14
store float %val181, float* %val182
%val183 = load float*, float** %mat2Ptr
; set pointer
%val184 = getelementptr float, float* %val183, i64 15
store float 0x3ff0000000000000, float* %val184
%val185 = load float*, float** %matPtr
%val186 = load float*, float** %mat2Ptr
%val187 = load float*, float** %mat3Ptr
%res188 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val185, float* %val186, float* %val187)
%val189 = load float*, float** %matPtr
%val190 = bitcast float* %val189 to i8*
%val191 = load float*, float** %mat3Ptr
%val192 = bitcast float* %val191 to i8*
%val193 = mul i64 16, 4
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val190, i8* %val192, i64 %val193, i32 1, i1 0)
ret void
}
@gsxtmgraphics-pipeline8 = hidden constant [119 x i8] c"translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** @translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone215 = load i8*, i8** %_impzPtr
%zone216 = bitcast i8* %tzone215 to %mzone*

; let assign value to symbol translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone216, i64 8)
%translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ to { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***
%tzone196 = load i8*, i8** %_impzPtr
%zone197 = bitcast i8* %tzone196 to %mzone*
call void @llvm_zone_mark(%mzone* %zone197)
; malloc closure structure
%clsptr198 = call i8* @llvm_zone_malloc(%mzone* %zone197, i64 24)
%closure199 = bitcast i8* %clsptr198 to { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*

; malloc environment structure
%envptr200 = call i8* @llvm_zone_malloc(%mzone* %zone197, i64 8)
%environment201 = bitcast i8* %envptr200 to {{i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***}*

; malloc closure address table
%addytable202 = call %clsvar* @new_address_table()
%var203 = bitcast [66 x i8]* @gsxtmgraphics-pipeline6 to i8*
%var204 = bitcast [60 x i8]* @gsxtmgraphics-pipeline7 to i8*
%addytable205 = call %clsvar* @add_address_table(%mzone* %zone197, i8* %var203, i32 0, i8* %var204, i32 3, %clsvar* %addytable202)
%address-table206 = bitcast %clsvar* %addytable205 to i8*

; insert table, function and environment into closure struct
%closure.table209 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure199, i32 0, i32 0
store i8* %address-table206, i8** %closure.table209
%closure.env210 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure199, i32 0, i32 1
store i8* %envptr200, i8** %closure.env210
%closure.func211 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure199, i32 0, i32 2
store void (i8*, i8*, float*, float, float, float)* @translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ__141, void (i8*, i8*, float*, float, float, float)** %closure.func211
%closure_size212 = call i64 @llvm_zone_mark_size(%mzone* %zone197)
call void @llvm_zone_ptr_set_size(i8* %clsptr198, i64 %closure_size212)
%wrapper_ptr213 = call i8* @llvm_zone_malloc(%mzone* %zone197, i64 8)
%closure_wrapper214 = bitcast i8* %wrapper_ptr213 to { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure199, { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure_wrapper214

; let value assignment
%translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure_wrapper214, { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure_wrapper214
store { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ, { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*** %translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr208 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***}* %environment201, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*** %translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**** %tmp_envptr208


%val217 = load {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*** %translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %val217
}


@translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** @translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ(float* %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float)*,  void (i8*, i8*, float*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret void
}


define dllexport ccc void @translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_native(float* %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float)*,  void (i8*, i8*, float*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret void
}


define dllexport ccc i8*  @translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var218 = bitcast [119 x i8]* @gsxtmgraphics-pipeline8 to i8*
call i32 (i8*, ...) @printf(i8* %var218)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var219 = bitcast [119 x i8]* @gsxtmgraphics-pipeline8 to i8*
call i32 (i8*, ...) @printf(i8* %var219)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var220 = bitcast [119 x i8]* @gsxtmgraphics-pipeline8 to i8*
call i32 (i8*, ...) @printf(i8* %var220)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var221 = bitcast [119 x i8]* @gsxtmgraphics-pipeline8 to i8*
call i32 (i8*, ...) @printf(i8* %var221)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float)*,  void (i8*, i8*, float*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float, float, float}*
%arg_p_0 = getelementptr {float*, float, float, float}, {float*, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float, float, float}, {float*, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float*, float, float, float}, {float*, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float*, float, float, float}, {float*, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float)*,  void (i8*, i8*, float*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline9 = hidden constant [62 x i8] c"scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
define dllexport fastcc void @scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ__222(i8* %_impz,i8* %_impenv, float* %mat, float %x, float %y, float %z) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone223 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***}*
%scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***}* %impenv, i32 0, i32 0
%scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**** %scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%matPtr = alloca float*
store float* %mat, float** %matPtr
%xPtr = alloca float
store float %x, float* %xPtr
%yPtr = alloca float
store float %y, float* %yPtr
%zPtr = alloca float
store float %z, float* %zPtr


%tzone225 = load i8*, i8** %_impzPtr
%zone226 = bitcast i8* %tzone225 to %mzone*

; let assign value to symbol mat2
%mat2Ptr = alloca float*
%tzone229 = load i8*, i8** %_impzPtr
%zone230 = bitcast i8* %tzone229 to %mzone*

; let assign value to symbol mat3
%mat3Ptr = alloca float*
%dat224 = alloca float, i64 32, align 16

; let value assignment
%mat2 = select i1 true, float* %dat224, float* %dat224
store float* %mat2, float** %mat2Ptr

%val227 = load float*, float** %mat2Ptr
; pointer ref
%val228 = getelementptr float, float* %val227, i64 16

; let value assignment
%mat3 = select i1 true, float* %val228, float* %val228
store float* %mat3, float** %mat3Ptr

%val231 = load float*, float** %mat2Ptr
%val232 = load float, float* %xPtr
; set pointer
%val233 = getelementptr float, float* %val231, i64 0
store float %val232, float* %val233
%val234 = load float*, float** %mat2Ptr
; set pointer
%val235 = getelementptr float, float* %val234, i64 1
store float 0x0, float* %val235
%val236 = load float*, float** %mat2Ptr
; set pointer
%val237 = getelementptr float, float* %val236, i64 2
store float 0x0, float* %val237
%val238 = load float*, float** %mat2Ptr
; set pointer
%val239 = getelementptr float, float* %val238, i64 3
store float 0x0, float* %val239
%val240 = load float*, float** %mat2Ptr
; set pointer
%val241 = getelementptr float, float* %val240, i64 4
store float 0x0, float* %val241
%val242 = load float*, float** %mat2Ptr
%val243 = load float, float* %yPtr
; set pointer
%val244 = getelementptr float, float* %val242, i64 5
store float %val243, float* %val244
%val245 = load float*, float** %mat2Ptr
; set pointer
%val246 = getelementptr float, float* %val245, i64 6
store float 0x0, float* %val246
%val247 = load float*, float** %mat2Ptr
; set pointer
%val248 = getelementptr float, float* %val247, i64 7
store float 0x0, float* %val248
%val249 = load float*, float** %mat2Ptr
; set pointer
%val250 = getelementptr float, float* %val249, i64 8
store float 0x0, float* %val250
%val251 = load float*, float** %mat2Ptr
; set pointer
%val252 = getelementptr float, float* %val251, i64 9
store float 0x0, float* %val252
%val253 = load float*, float** %mat2Ptr
%val254 = load float, float* %zPtr
; set pointer
%val255 = getelementptr float, float* %val253, i64 10
store float %val254, float* %val255
%val256 = load float*, float** %mat2Ptr
; set pointer
%val257 = getelementptr float, float* %val256, i64 11
store float 0x0, float* %val257
%val258 = load float*, float** %mat2Ptr
; set pointer
%val259 = getelementptr float, float* %val258, i64 12
store float 0x0, float* %val259
%val260 = load float*, float** %mat2Ptr
; set pointer
%val261 = getelementptr float, float* %val260, i64 13
store float 0x0, float* %val261
%val262 = load float*, float** %mat2Ptr
; set pointer
%val263 = getelementptr float, float* %val262, i64 14
store float 0x0, float* %val263
%val264 = load float*, float** %mat2Ptr
; set pointer
%val265 = getelementptr float, float* %val264, i64 15
store float 0x3ff0000000000000, float* %val265
%val266 = load float*, float** %matPtr
%val267 = load float*, float** %mat2Ptr
%val268 = load float*, float** %mat3Ptr
%res269 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val266, float* %val267, float* %val268)
%val270 = load float*, float** %matPtr
%val271 = bitcast float* %val270 to i8*
%val272 = load float*, float** %mat3Ptr
%val273 = bitcast float* %val272 to i8*
%val274 = mul i64 16, 4
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val271, i8* %val273, i64 %val274, i32 1, i1 0)
ret void
}
@gsxtmgraphics-pipeline10 = hidden constant [115 x i8] c"scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** @scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone296 = load i8*, i8** %_impzPtr
%zone297 = bitcast i8* %tzone296 to %mzone*

; let assign value to symbol scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone297, i64 8)
%scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ to { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***
%tzone277 = load i8*, i8** %_impzPtr
%zone278 = bitcast i8* %tzone277 to %mzone*
call void @llvm_zone_mark(%mzone* %zone278)
; malloc closure structure
%clsptr279 = call i8* @llvm_zone_malloc(%mzone* %zone278, i64 24)
%closure280 = bitcast i8* %clsptr279 to { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*

; malloc environment structure
%envptr281 = call i8* @llvm_zone_malloc(%mzone* %zone278, i64 8)
%environment282 = bitcast i8* %envptr281 to {{i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***}*

; malloc closure address table
%addytable283 = call %clsvar* @new_address_table()
%var284 = bitcast [62 x i8]* @gsxtmgraphics-pipeline9 to i8*
%var285 = bitcast [60 x i8]* @gsxtmgraphics-pipeline7 to i8*
%addytable286 = call %clsvar* @add_address_table(%mzone* %zone278, i8* %var284, i32 0, i8* %var285, i32 3, %clsvar* %addytable283)
%address-table287 = bitcast %clsvar* %addytable286 to i8*

; insert table, function and environment into closure struct
%closure.table290 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure280, i32 0, i32 0
store i8* %address-table287, i8** %closure.table290
%closure.env291 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure280, i32 0, i32 1
store i8* %envptr281, i8** %closure.env291
%closure.func292 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure280, i32 0, i32 2
store void (i8*, i8*, float*, float, float, float)* @scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ__222, void (i8*, i8*, float*, float, float, float)** %closure.func292
%closure_size293 = call i64 @llvm_zone_mark_size(%mzone* %zone278)
call void @llvm_zone_ptr_set_size(i8* %clsptr279, i64 %closure_size293)
%wrapper_ptr294 = call i8* @llvm_zone_malloc(%mzone* %zone278, i64 8)
%closure_wrapper295 = bitcast i8* %wrapper_ptr294 to { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure280, { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure_wrapper295

; let value assignment
%scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure_wrapper295, { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure_wrapper295
store { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ, { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*** %scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr289 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***}* %environment282, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*** %scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**** %tmp_envptr289


%val298 = load {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*** %scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %val298
}


@scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** @scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ(float* %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float)*,  void (i8*, i8*, float*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret void
}


define dllexport ccc void @scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_native(float* %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float)*,  void (i8*, i8*, float*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret void
}


define dllexport ccc i8*  @scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var299 = bitcast [115 x i8]* @gsxtmgraphics-pipeline10 to i8*
call i32 (i8*, ...) @printf(i8* %var299)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var300 = bitcast [115 x i8]* @gsxtmgraphics-pipeline10 to i8*
call i32 (i8*, ...) @printf(i8* %var300)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var301 = bitcast [115 x i8]* @gsxtmgraphics-pipeline10 to i8*
call i32 (i8*, ...) @printf(i8* %var301)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var302 = bitcast [115 x i8]* @gsxtmgraphics-pipeline10 to i8*
call i32 (i8*, ...) @printf(i8* %var302)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float)*,  void (i8*, i8*, float*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float, float, float}*
%arg_p_0 = getelementptr {float*, float, float, float}, {float*, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float, float, float}, {float*, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float*, float, float, float}, {float*, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float*, float, float, float}, {float*, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float)*,  void (i8*, i8*, float*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline11 = hidden constant [39 x i8] c"invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ\00"
@gsxtmgraphics-pipeline12 = hidden constant [39 x i8] c"{i8*, i8*, void (i8*, i8*, float*)*}**\00"
define dllexport fastcc void @invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ__303(i8* %_impz,i8* %_impenv, float* %mat) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone304 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*)*}***}*
%invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*)*}***}* %impenv, i32 0, i32 0
%invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQPtr = load {i8*, i8*, void (i8*, i8*, float*)*}***, {i8*, i8*, void (i8*, i8*, float*)*}**** %invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQPtr_

; setup arguments
%matPtr = alloca float*
store float* %mat, float** %matPtr


%tzone306 = load i8*, i8** %_impzPtr
%zone307 = bitcast i8* %tzone306 to %mzone*

; let assign value to symbol mat2
%mat2Ptr = alloca float*
%dat305 = alloca float, i64 16, align 16

; let value assignment
%mat2 = select i1 true, float* %dat305, float* %dat305
store float* %mat2, float** %mat2Ptr

%val308 = load float*, float** %matPtr
%val309 = load float*, float** %mat2Ptr
call fastcc void @minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd(float* %val308, i64 4, float* %val309)
%val311 = load float*, float** %matPtr
%val312 = bitcast float* %val311 to i8*
%val313 = load float*, float** %mat2Ptr
%val314 = bitcast float* %val313 to i8*
%val315 = mul i64 16, 4
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val312, i8* %val314, i64 %val315, i32 1, i1 0)
ret void
}
@gsxtmgraphics-pipeline13 = hidden constant [92 x i8] c"invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*)*}** @invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone337 = load i8*, i8** %_impzPtr
%zone338 = bitcast i8* %tzone337 to %mzone*

; let assign value to symbol invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ
%dat_invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone338, i64 8)
%invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQPtr = bitcast i8* %dat_invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ to { i8*, i8*, void (i8*, i8*, float*)*}***
%tzone318 = load i8*, i8** %_impzPtr
%zone319 = bitcast i8* %tzone318 to %mzone*
call void @llvm_zone_mark(%mzone* %zone319)
; malloc closure structure
%clsptr320 = call i8* @llvm_zone_malloc(%mzone* %zone319, i64 24)
%closure321 = bitcast i8* %clsptr320 to { i8*, i8*, void (i8*, i8*, float*)*}*

; malloc environment structure
%envptr322 = call i8* @llvm_zone_malloc(%mzone* %zone319, i64 8)
%environment323 = bitcast i8* %envptr322 to {{i8*, i8*, void (i8*, i8*, float*)*}***}*

; malloc closure address table
%addytable324 = call %clsvar* @new_address_table()
%var325 = bitcast [39 x i8]* @gsxtmgraphics-pipeline11 to i8*
%var326 = bitcast [39 x i8]* @gsxtmgraphics-pipeline12 to i8*
%addytable327 = call %clsvar* @add_address_table(%mzone* %zone319, i8* %var325, i32 0, i8* %var326, i32 3, %clsvar* %addytable324)
%address-table328 = bitcast %clsvar* %addytable327 to i8*

; insert table, function and environment into closure struct
%closure.table331 = getelementptr { i8*, i8*, void (i8*, i8*, float*)*}, { i8*, i8*, void (i8*, i8*, float*)*}* %closure321, i32 0, i32 0
store i8* %address-table328, i8** %closure.table331
%closure.env332 = getelementptr { i8*, i8*, void (i8*, i8*, float*)*}, { i8*, i8*, void (i8*, i8*, float*)*}* %closure321, i32 0, i32 1
store i8* %envptr322, i8** %closure.env332
%closure.func333 = getelementptr { i8*, i8*, void (i8*, i8*, float*)*}, { i8*, i8*, void (i8*, i8*, float*)*}* %closure321, i32 0, i32 2
store void (i8*, i8*, float*)* @invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ__303, void (i8*, i8*, float*)** %closure.func333
%closure_size334 = call i64 @llvm_zone_mark_size(%mzone* %zone319)
call void @llvm_zone_ptr_set_size(i8* %clsptr320, i64 %closure_size334)
%wrapper_ptr335 = call i8* @llvm_zone_malloc(%mzone* %zone319, i64 8)
%closure_wrapper336 = bitcast i8* %wrapper_ptr335 to { i8*, i8*, void (i8*, i8*, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*)*}* %closure321, { i8*, i8*, void (i8*, i8*, float*)*}** %closure_wrapper336

; let value assignment
%invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, float*)*}** %closure_wrapper336, { i8*, i8*, void (i8*, i8*, float*)*}** %closure_wrapper336
store { i8*, i8*, void (i8*, i8*, float*)*}** %invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ, { i8*, i8*, void (i8*, i8*, float*)*}*** %invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQPtr

; add data to environment
; don't need to alloc for env var invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ
%tmp_envptr330 = getelementptr {{i8*, i8*, void (i8*, i8*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*)*}***}* %environment323, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*)*}*** %invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQPtr, {i8*, i8*, void (i8*, i8*, float*)*}**** %tmp_envptr330


%val339 = load {i8*, i8*, void (i8*, i8*, float*)*}**, {i8*, i8*, void (i8*, i8*, float*)*}*** %invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQPtr
ret {i8*, i8*, void (i8*, i8*, float*)*}** %val339
}


@invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*)*}** @invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*)*,  void (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0)
ret void
}


define dllexport ccc void @invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_native(float* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*)*,  void (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0)
ret void
}


define dllexport ccc i8*  @invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var340 = bitcast [92 x i8]* @gsxtmgraphics-pipeline13 to i8*
call i32 (i8*, ...) @printf(i8* %var340)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*)*,  void (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*}*
%arg_p_0 = getelementptr {float*}, {float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*)*,  void (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline14 = hidden constant [71 x i8] c"rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
@gsxtmgraphics-pipeline15 = hidden constant [67 x i8] c"{i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}**\00"
define dllexport fastcc void @rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__341(i8* %_impz,i8* %_impenv, float* %mat, float %alpha, float %x, float %y, float %z) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone342 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}***}*
%rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}**** %rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%matPtr = alloca float*
store float* %mat, float** %matPtr
%alphaPtr = alloca float
store float %alpha, float* %alphaPtr
%xPtr = alloca float
store float %x, float* %xPtr
%yPtr = alloca float
store float %y, float* %yPtr
%zPtr = alloca float
store float %z, float* %zPtr


%tzone345 = load i8*, i8** %_impzPtr
%zone346 = bitcast i8* %tzone345 to %mzone*

; let assign value to symbol c
%cPtr = alloca float
%tzone349 = load i8*, i8** %_impzPtr
%zone350 = bitcast i8* %tzone349 to %mzone*

; let assign value to symbol c-1
%c-1Ptr = alloca float
%tzone353 = load i8*, i8** %_impzPtr
%zone354 = bitcast i8* %tzone353 to %mzone*

; let assign value to symbol s
%sPtr = alloca float
%tzone356 = load i8*, i8** %_impzPtr
%zone357 = bitcast i8* %tzone356 to %mzone*

; let assign value to symbol mat2
%mat2Ptr = alloca float*
%tzone359 = load i8*, i8** %_impzPtr
%zone360 = bitcast i8* %tzone359 to %mzone*

; let assign value to symbol mat3
%mat3Ptr = alloca float*
%tzone362 = load i8*, i8** %_impzPtr
%zone363 = bitcast i8* %tzone362 to %mzone*

; let assign value to symbol vec1
%vec1Ptr = alloca float*
%tzone365 = load i8*, i8** %_impzPtr
%zone366 = bitcast i8* %tzone365 to %mzone*

; let assign value to symbol vec2
%vec2Ptr = alloca float*
%val343 = load float, float* %alphaPtr
%val344 = call float @llvm.cos.f32(float %val343)

; let value assignment
%c = select i1 true, float %val344, float %val344
store float %c, float* %cPtr

%val347 = load float, float* %cPtr
%val348 = fsub float 0x3ff0000000000000, %val347

; let value assignment
%c-1 = select i1 true, float %val348, float %val348
store float %c-1, float* %c-1Ptr

%val351 = load float, float* %alphaPtr
%val352 = call float @llvm.sin.f32(float %val351)

; let value assignment
%s = select i1 true, float %val352, float %val352
store float %s, float* %sPtr

%dat355 = alloca float, i64 16, align 16

; let value assignment
%mat2 = select i1 true, float* %dat355, float* %dat355
store float* %mat2, float** %mat2Ptr

%dat358 = alloca float, i64 16, align 16

; let value assignment
%mat3 = select i1 true, float* %dat358, float* %dat358
store float* %mat3, float** %mat3Ptr

%dat361 = alloca float, i64 3, align 16

; let value assignment
%vec1 = select i1 true, float* %dat361, float* %dat361
store float* %vec1, float** %vec1Ptr

%dat364 = alloca float, i64 3, align 16

; let value assignment
%vec2 = select i1 true, float* %dat364, float* %dat364
store float* %vec2, float** %vec2Ptr

%val367 = load float*, float** %vec1Ptr
%val368 = load float, float* %xPtr
; set pointer
%val369 = getelementptr float, float* %val367, i64 0
store float %val368, float* %val369
%val370 = load float*, float** %vec1Ptr
%val371 = load float, float* %yPtr
; set pointer
%val372 = getelementptr float, float* %val370, i64 1
store float %val371, float* %val372
%val373 = load float*, float** %vec1Ptr
%val374 = load float, float* %zPtr
; set pointer
%val375 = getelementptr float, float* %val373, i64 2
store float %val374, float* %val375
%val376 = load float*, float** %vec1Ptr
%val377 = load float*, float** %vec2Ptr
call fastcc void @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd(float* %val376, i64 3, float* %val377)
; do set!
%val379 = load float*, float** %vec2Ptr
; pointer ref
%val380 = getelementptr float, float* %val379, i64 0
%val381 = load float, float* %val380
store float %val381, float* %xPtr
; do set!
%val382 = load float*, float** %vec2Ptr
; pointer ref
%val383 = getelementptr float, float* %val382, i64 1
%val384 = load float, float* %val383
store float %val384, float* %yPtr
; do set!
%val385 = load float*, float** %vec2Ptr
; pointer ref
%val386 = getelementptr float, float* %val385, i64 2
%val387 = load float, float* %val386
store float %val387, float* %zPtr
%val388 = load float*, float** %mat2Ptr
%val389 = load float, float* %xPtr
%val390 = load float, float* %xPtr
%val391 = fmul float %val389, %val390
%val392 = load float, float* %c-1Ptr
%val393 = fmul float %val391, %val392
%val394 = load float, float* %cPtr
%val395 = fadd float %val393, %val394
; set pointer
%val396 = getelementptr float, float* %val388, i64 0
store float %val395, float* %val396
%val397 = load float*, float** %mat2Ptr
%val398 = load float, float* %xPtr
%val399 = load float, float* %yPtr
%val400 = fmul float %val398, %val399
%val401 = load float, float* %c-1Ptr
%val402 = fmul float %val400, %val401
%val403 = load float, float* %zPtr
%val404 = load float, float* %sPtr
%val405 = fmul float %val403, %val404
%val406 = fsub float %val402, %val405
; set pointer
%val407 = getelementptr float, float* %val397, i64 1
store float %val406, float* %val407
%val408 = load float*, float** %mat2Ptr
%val409 = load float, float* %xPtr
%val410 = load float, float* %zPtr
%val411 = fmul float %val409, %val410
%val412 = load float, float* %c-1Ptr
%val413 = fmul float %val411, %val412
%val414 = load float, float* %yPtr
%val415 = load float, float* %sPtr
%val416 = fmul float %val414, %val415
%val417 = fadd float %val413, %val416
; set pointer
%val418 = getelementptr float, float* %val408, i64 2
store float %val417, float* %val418
%val419 = load float*, float** %mat2Ptr
; set pointer
%val420 = getelementptr float, float* %val419, i64 3
store float 0x0, float* %val420
%val421 = load float*, float** %mat2Ptr
%val422 = load float, float* %yPtr
%val423 = load float, float* %xPtr
%val424 = fmul float %val422, %val423
%val425 = load float, float* %c-1Ptr
%val426 = fmul float %val424, %val425
%val427 = load float, float* %zPtr
%val428 = load float, float* %sPtr
%val429 = fmul float %val427, %val428
%val430 = fadd float %val426, %val429
; set pointer
%val431 = getelementptr float, float* %val421, i64 4
store float %val430, float* %val431
%val432 = load float*, float** %mat2Ptr
%val433 = load float, float* %yPtr
%val434 = load float, float* %yPtr
%val435 = fmul float %val433, %val434
%val436 = load float, float* %c-1Ptr
%val437 = fmul float %val435, %val436
%val438 = load float, float* %cPtr
%val439 = fadd float %val437, %val438
; set pointer
%val440 = getelementptr float, float* %val432, i64 5
store float %val439, float* %val440
%val441 = load float*, float** %mat2Ptr
%val442 = load float, float* %yPtr
%val443 = load float, float* %zPtr
%val444 = fmul float %val442, %val443
%val445 = load float, float* %c-1Ptr
%val446 = fmul float %val444, %val445
%val447 = load float, float* %xPtr
%val448 = load float, float* %sPtr
%val449 = fmul float %val447, %val448
%val450 = fsub float %val446, %val449
; set pointer
%val451 = getelementptr float, float* %val441, i64 6
store float %val450, float* %val451
%val452 = load float*, float** %mat2Ptr
; set pointer
%val453 = getelementptr float, float* %val452, i64 7
store float 0x0, float* %val453
%val454 = load float*, float** %mat2Ptr
%val455 = load float, float* %xPtr
%val456 = load float, float* %zPtr
%val457 = fmul float %val455, %val456
%val458 = load float, float* %c-1Ptr
%val459 = fmul float %val457, %val458
%val460 = load float, float* %yPtr
%val461 = load float, float* %sPtr
%val462 = fmul float %val460, %val461
%val463 = fsub float %val459, %val462
; set pointer
%val464 = getelementptr float, float* %val454, i64 8
store float %val463, float* %val464
%val465 = load float*, float** %mat2Ptr
%val466 = load float, float* %yPtr
%val467 = load float, float* %zPtr
%val468 = fmul float %val466, %val467
%val469 = load float, float* %c-1Ptr
%val470 = fmul float %val468, %val469
%val471 = load float, float* %xPtr
%val472 = load float, float* %sPtr
%val473 = fmul float %val471, %val472
%val474 = fadd float %val470, %val473
; set pointer
%val475 = getelementptr float, float* %val465, i64 9
store float %val474, float* %val475
%val476 = load float*, float** %mat2Ptr
%val477 = load float, float* %zPtr
%val478 = load float, float* %zPtr
%val479 = fmul float %val477, %val478
%val480 = load float, float* %c-1Ptr
%val481 = fmul float %val479, %val480
%val482 = load float, float* %cPtr
%val483 = fadd float %val481, %val482
; set pointer
%val484 = getelementptr float, float* %val476, i64 10
store float %val483, float* %val484
%val485 = load float*, float** %mat2Ptr
; set pointer
%val486 = getelementptr float, float* %val485, i64 11
store float 0x0, float* %val486
%val487 = load float*, float** %mat2Ptr
; set pointer
%val488 = getelementptr float, float* %val487, i64 12
store float 0x0, float* %val488
%val489 = load float*, float** %mat2Ptr
; set pointer
%val490 = getelementptr float, float* %val489, i64 13
store float 0x0, float* %val490
%val491 = load float*, float** %mat2Ptr
; set pointer
%val492 = getelementptr float, float* %val491, i64 14
store float 0x0, float* %val492
%val493 = load float*, float** %mat2Ptr
; set pointer
%val494 = getelementptr float, float* %val493, i64 15
store float 0x3ff0000000000000, float* %val494
%val495 = load float*, float** %matPtr
%val496 = load float*, float** %mat2Ptr
%val497 = load float*, float** %mat3Ptr
%res498 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val495, float* %val496, float* %val497)
%val499 = load float*, float** %matPtr
%val500 = bitcast float* %val499 to i8*
%val501 = load float*, float** %mat3Ptr
%val502 = bitcast float* %val501 to i8*
%val503 = mul i64 16, 4
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val500, i8* %val502, i64 %val503, i32 1, i1 0)
ret void
}
@gsxtmgraphics-pipeline16 = hidden constant [124 x i8] c"rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** @rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone525 = load i8*, i8** %_impzPtr
%zone526 = bitcast i8* %tzone525 to %mzone*

; let assign value to symbol rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone526, i64 8)
%rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ to { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}***
%tzone506 = load i8*, i8** %_impzPtr
%zone507 = bitcast i8* %tzone506 to %mzone*
call void @llvm_zone_mark(%mzone* %zone507)
; malloc closure structure
%clsptr508 = call i8* @llvm_zone_malloc(%mzone* %zone507, i64 24)
%closure509 = bitcast i8* %clsptr508 to { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}*

; malloc environment structure
%envptr510 = call i8* @llvm_zone_malloc(%mzone* %zone507, i64 8)
%environment511 = bitcast i8* %envptr510 to {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}***}*

; malloc closure address table
%addytable512 = call %clsvar* @new_address_table()
%var513 = bitcast [71 x i8]* @gsxtmgraphics-pipeline14 to i8*
%var514 = bitcast [67 x i8]* @gsxtmgraphics-pipeline15 to i8*
%addytable515 = call %clsvar* @add_address_table(%mzone* %zone507, i8* %var513, i32 0, i8* %var514, i32 3, %clsvar* %addytable512)
%address-table516 = bitcast %clsvar* %addytable515 to i8*

; insert table, function and environment into closure struct
%closure.table519 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure509, i32 0, i32 0
store i8* %address-table516, i8** %closure.table519
%closure.env520 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure509, i32 0, i32 1
store i8* %envptr510, i8** %closure.env520
%closure.func521 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure509, i32 0, i32 2
store void (i8*, i8*, float*, float, float, float, float)* @rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__341, void (i8*, i8*, float*, float, float, float, float)** %closure.func521
%closure_size522 = call i64 @llvm_zone_mark_size(%mzone* %zone507)
call void @llvm_zone_ptr_set_size(i8* %clsptr508, i64 %closure_size522)
%wrapper_ptr523 = call i8* @llvm_zone_malloc(%mzone* %zone507, i64 8)
%closure_wrapper524 = bitcast i8* %wrapper_ptr523 to { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure509, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** %closure_wrapper524

; let value assignment
%rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** %closure_wrapper524, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** %closure_wrapper524
store { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** %rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}*** %rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr518 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}***}* %environment511, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}*** %rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}**** %tmp_envptr518


%val527 = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}*** %rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** %val527
}


@rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** @rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ(float* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float, float)*,  void (i8*, i8*, float*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
ret void
}


define dllexport ccc void @rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_native(float* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float, float)*,  void (i8*, i8*, float*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
ret void
}


define dllexport ccc i8*  @rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var528 = bitcast [124 x i8]* @gsxtmgraphics-pipeline16 to i8*
call i32 (i8*, ...) @printf(i8* %var528)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var529 = bitcast [124 x i8]* @gsxtmgraphics-pipeline16 to i8*
call i32 (i8*, ...) @printf(i8* %var529)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var530 = bitcast [124 x i8]* @gsxtmgraphics-pipeline16 to i8*
call i32 (i8*, ...) @printf(i8* %var530)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var531 = bitcast [124 x i8]* @gsxtmgraphics-pipeline16 to i8*
call i32 (i8*, ...) @printf(i8* %var531)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var532 = bitcast [124 x i8]* @gsxtmgraphics-pipeline16 to i8*
call i32 (i8*, ...) @printf(i8* %var532)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float, float)*,  void (i8*, i8*, float*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float, float, float, float}*
%arg_p_0 = getelementptr {float*, float, float, float, float}, {float*, float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float, float, float, float}, {float*, float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float*, float, float, float, float}, {float*, float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float*, float, float, float, float}, {float*, float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {float*, float, float, float, float}, {float*, float, float, float, float}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float, float)*,  void (i8*, i8*, float*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline17 = hidden constant [46 x i8] c"fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ\00"
define dllexport fastcc void @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ__533(i8* %_impz,i8* %_impenv, float* %mat) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone534 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*)*}***}*
%fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*)*}***}* %impenv, i32 0, i32 0
%fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQPtr = load {i8*, i8*, void (i8*, i8*, float*)*}***, {i8*, i8*, void (i8*, i8*, float*)*}**** %fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQPtr_

; setup arguments
%matPtr = alloca float*
store float* %mat, float** %matPtr


%val535 = load float*, float** %matPtr
; set pointer
%val536 = getelementptr float, float* %val535, i64 0
store float 0x3ff0000000000000, float* %val536
%val537 = load float*, float** %matPtr
; set pointer
%val538 = getelementptr float, float* %val537, i64 1
store float 0x0, float* %val538
%val539 = load float*, float** %matPtr
; set pointer
%val540 = getelementptr float, float* %val539, i64 2
store float 0x0, float* %val540
%val541 = load float*, float** %matPtr
; set pointer
%val542 = getelementptr float, float* %val541, i64 3
store float 0x0, float* %val542
%val543 = load float*, float** %matPtr
; set pointer
%val544 = getelementptr float, float* %val543, i64 4
store float 0x0, float* %val544
%val545 = load float*, float** %matPtr
; set pointer
%val546 = getelementptr float, float* %val545, i64 5
store float 0x3ff0000000000000, float* %val546
%val547 = load float*, float** %matPtr
; set pointer
%val548 = getelementptr float, float* %val547, i64 6
store float 0x0, float* %val548
%val549 = load float*, float** %matPtr
; set pointer
%val550 = getelementptr float, float* %val549, i64 7
store float 0x0, float* %val550
%val551 = load float*, float** %matPtr
; set pointer
%val552 = getelementptr float, float* %val551, i64 8
store float 0x0, float* %val552
%val553 = load float*, float** %matPtr
; set pointer
%val554 = getelementptr float, float* %val553, i64 9
store float 0x0, float* %val554
%val555 = load float*, float** %matPtr
; set pointer
%val556 = getelementptr float, float* %val555, i64 10
store float 0x3ff0000000000000, float* %val556
%val557 = load float*, float** %matPtr
; set pointer
%val558 = getelementptr float, float* %val557, i64 11
store float 0x0, float* %val558
%val559 = load float*, float** %matPtr
; set pointer
%val560 = getelementptr float, float* %val559, i64 12
store float 0x0, float* %val560
%val561 = load float*, float** %matPtr
; set pointer
%val562 = getelementptr float, float* %val561, i64 13
store float 0x0, float* %val562
%val563 = load float*, float** %matPtr
; set pointer
%val564 = getelementptr float, float* %val563, i64 14
store float 0x0, float* %val564
%val565 = load float*, float** %matPtr
; set pointer
%val566 = getelementptr float, float* %val565, i64 15
store float 0x3ff0000000000000, float* %val566
ret void
}
@gsxtmgraphics-pipeline18 = hidden constant [99 x i8] c"fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*)*}** @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone587 = load i8*, i8** %_impzPtr
%zone588 = bitcast i8* %tzone587 to %mzone*

; let assign value to symbol fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ
%dat_fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone588, i64 8)
%fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQPtr = bitcast i8* %dat_fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ to { i8*, i8*, void (i8*, i8*, float*)*}***
%tzone568 = load i8*, i8** %_impzPtr
%zone569 = bitcast i8* %tzone568 to %mzone*
call void @llvm_zone_mark(%mzone* %zone569)
; malloc closure structure
%clsptr570 = call i8* @llvm_zone_malloc(%mzone* %zone569, i64 24)
%closure571 = bitcast i8* %clsptr570 to { i8*, i8*, void (i8*, i8*, float*)*}*

; malloc environment structure
%envptr572 = call i8* @llvm_zone_malloc(%mzone* %zone569, i64 8)
%environment573 = bitcast i8* %envptr572 to {{i8*, i8*, void (i8*, i8*, float*)*}***}*

; malloc closure address table
%addytable574 = call %clsvar* @new_address_table()
%var575 = bitcast [46 x i8]* @gsxtmgraphics-pipeline17 to i8*
%var576 = bitcast [39 x i8]* @gsxtmgraphics-pipeline12 to i8*
%addytable577 = call %clsvar* @add_address_table(%mzone* %zone569, i8* %var575, i32 0, i8* %var576, i32 3, %clsvar* %addytable574)
%address-table578 = bitcast %clsvar* %addytable577 to i8*

; insert table, function and environment into closure struct
%closure.table581 = getelementptr { i8*, i8*, void (i8*, i8*, float*)*}, { i8*, i8*, void (i8*, i8*, float*)*}* %closure571, i32 0, i32 0
store i8* %address-table578, i8** %closure.table581
%closure.env582 = getelementptr { i8*, i8*, void (i8*, i8*, float*)*}, { i8*, i8*, void (i8*, i8*, float*)*}* %closure571, i32 0, i32 1
store i8* %envptr572, i8** %closure.env582
%closure.func583 = getelementptr { i8*, i8*, void (i8*, i8*, float*)*}, { i8*, i8*, void (i8*, i8*, float*)*}* %closure571, i32 0, i32 2
store void (i8*, i8*, float*)* @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ__533, void (i8*, i8*, float*)** %closure.func583
%closure_size584 = call i64 @llvm_zone_mark_size(%mzone* %zone569)
call void @llvm_zone_ptr_set_size(i8* %clsptr570, i64 %closure_size584)
%wrapper_ptr585 = call i8* @llvm_zone_malloc(%mzone* %zone569, i64 8)
%closure_wrapper586 = bitcast i8* %wrapper_ptr585 to { i8*, i8*, void (i8*, i8*, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*)*}* %closure571, { i8*, i8*, void (i8*, i8*, float*)*}** %closure_wrapper586

; let value assignment
%fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, float*)*}** %closure_wrapper586, { i8*, i8*, void (i8*, i8*, float*)*}** %closure_wrapper586
store { i8*, i8*, void (i8*, i8*, float*)*}** %fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ, { i8*, i8*, void (i8*, i8*, float*)*}*** %fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQPtr

; add data to environment
; don't need to alloc for env var fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ
%tmp_envptr580 = getelementptr {{i8*, i8*, void (i8*, i8*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*)*}***}* %environment573, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*)*}*** %fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQPtr, {i8*, i8*, void (i8*, i8*, float*)*}**** %tmp_envptr580


%val589 = load {i8*, i8*, void (i8*, i8*, float*)*}**, {i8*, i8*, void (i8*, i8*, float*)*}*** %fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQPtr
ret {i8*, i8*, void (i8*, i8*, float*)*}** %val589
}


@fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*)*}** @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*)*,  void (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0)
ret void
}


define dllexport ccc void @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_native(float* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*)*,  void (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0)
ret void
}


define dllexport ccc i8*  @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var590 = bitcast [99 x i8]* @gsxtmgraphics-pipeline18 to i8*
call i32 (i8*, ...) @printf(i8* %var590)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*)*,  void (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*}*
%arg_p_0 = getelementptr {float*}, {float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*)*,  void (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline19 = hidden constant [95 x i8] c"fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
@gsxtmgraphics-pipeline20 = hidden constant [81 x i8] c"{i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**\00"
define dllexport fastcc void @fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__591(i8* %_impz,i8* %_impenv, float* %mat, float %posx, float %posy, float %posz, float %scalex, float %scaley, float %scalez) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone592 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***}*
%fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**** %fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%matPtr = alloca float*
store float* %mat, float** %matPtr
%posxPtr = alloca float
store float %posx, float* %posxPtr
%posyPtr = alloca float
store float %posy, float* %posyPtr
%poszPtr = alloca float
store float %posz, float* %poszPtr
%scalexPtr = alloca float
store float %scalex, float* %scalexPtr
%scaleyPtr = alloca float
store float %scaley, float* %scaleyPtr
%scalezPtr = alloca float
store float %scalez, float* %scalezPtr


%val593 = load float*, float** %matPtr
%val594 = load float, float* %scalexPtr
; set pointer
%val595 = getelementptr float, float* %val593, i64 0
store float %val594, float* %val595
%val596 = load float*, float** %matPtr
; set pointer
%val597 = getelementptr float, float* %val596, i64 1
store float 0x0, float* %val597
%val598 = load float*, float** %matPtr
; set pointer
%val599 = getelementptr float, float* %val598, i64 2
store float 0x0, float* %val599
%val600 = load float*, float** %matPtr
; set pointer
%val601 = getelementptr float, float* %val600, i64 3
store float 0x0, float* %val601
%val602 = load float*, float** %matPtr
; set pointer
%val603 = getelementptr float, float* %val602, i64 4
store float 0x0, float* %val603
%val604 = load float*, float** %matPtr
%val605 = load float, float* %scaleyPtr
; set pointer
%val606 = getelementptr float, float* %val604, i64 5
store float %val605, float* %val606
%val607 = load float*, float** %matPtr
; set pointer
%val608 = getelementptr float, float* %val607, i64 6
store float 0x0, float* %val608
%val609 = load float*, float** %matPtr
; set pointer
%val610 = getelementptr float, float* %val609, i64 7
store float 0x0, float* %val610
%val611 = load float*, float** %matPtr
; set pointer
%val612 = getelementptr float, float* %val611, i64 8
store float 0x0, float* %val612
%val613 = load float*, float** %matPtr
; set pointer
%val614 = getelementptr float, float* %val613, i64 9
store float 0x0, float* %val614
%val615 = load float*, float** %matPtr
%val616 = load float, float* %scalezPtr
; set pointer
%val617 = getelementptr float, float* %val615, i64 10
store float %val616, float* %val617
%val618 = load float*, float** %matPtr
; set pointer
%val619 = getelementptr float, float* %val618, i64 11
store float 0x0, float* %val619
%val620 = load float*, float** %matPtr
%val621 = load float, float* %posxPtr
; set pointer
%val622 = getelementptr float, float* %val620, i64 12
store float %val621, float* %val622
%val623 = load float*, float** %matPtr
%val624 = load float, float* %posyPtr
; set pointer
%val625 = getelementptr float, float* %val623, i64 13
store float %val624, float* %val625
%val626 = load float*, float** %matPtr
%val627 = load float, float* %poszPtr
; set pointer
%val628 = getelementptr float, float* %val626, i64 14
store float %val627, float* %val628
%val629 = load float*, float** %matPtr
; set pointer
%val630 = getelementptr float, float* %val629, i64 15
store float 0x3ff0000000000000, float* %val630
ret void
}
@gsxtmgraphics-pipeline21 = hidden constant [148 x i8] c"fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** @fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone651 = load i8*, i8** %_impzPtr
%zone652 = bitcast i8* %tzone651 to %mzone*

; let assign value to symbol fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone652, i64 8)
%fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ to { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***
%tzone632 = load i8*, i8** %_impzPtr
%zone633 = bitcast i8* %tzone632 to %mzone*
call void @llvm_zone_mark(%mzone* %zone633)
; malloc closure structure
%clsptr634 = call i8* @llvm_zone_malloc(%mzone* %zone633, i64 24)
%closure635 = bitcast i8* %clsptr634 to { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*

; malloc environment structure
%envptr636 = call i8* @llvm_zone_malloc(%mzone* %zone633, i64 8)
%environment637 = bitcast i8* %envptr636 to {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***}*

; malloc closure address table
%addytable638 = call %clsvar* @new_address_table()
%var639 = bitcast [95 x i8]* @gsxtmgraphics-pipeline19 to i8*
%var640 = bitcast [81 x i8]* @gsxtmgraphics-pipeline20 to i8*
%addytable641 = call %clsvar* @add_address_table(%mzone* %zone633, i8* %var639, i32 0, i8* %var640, i32 3, %clsvar* %addytable638)
%address-table642 = bitcast %clsvar* %addytable641 to i8*

; insert table, function and environment into closure struct
%closure.table645 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure635, i32 0, i32 0
store i8* %address-table642, i8** %closure.table645
%closure.env646 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure635, i32 0, i32 1
store i8* %envptr636, i8** %closure.env646
%closure.func647 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure635, i32 0, i32 2
store void (i8*, i8*, float*, float, float, float, float, float, float)* @fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__591, void (i8*, i8*, float*, float, float, float, float, float, float)** %closure.func647
%closure_size648 = call i64 @llvm_zone_mark_size(%mzone* %zone633)
call void @llvm_zone_ptr_set_size(i8* %clsptr634, i64 %closure_size648)
%wrapper_ptr649 = call i8* @llvm_zone_malloc(%mzone* %zone633, i64 8)
%closure_wrapper650 = bitcast i8* %wrapper_ptr649 to { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure635, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure_wrapper650

; let value assignment
%fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure_wrapper650, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure_wrapper650
store { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*** %fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr644 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***}* %environment637, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*** %fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**** %tmp_envptr644


%val653 = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*** %fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %val653
}


@fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** @fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ(float* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4,float %arg_5,float %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float, float, float, float)*,  void (i8*, i8*, float*, float, float, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4, float %arg_5, float %arg_6)
ret void
}


define dllexport ccc void @fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_native(float* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4,float %arg_5,float %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float, float, float, float)*,  void (i8*, i8*, float*, float, float, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4, float %arg_5, float %arg_6)
ret void
}


define dllexport ccc i8*  @fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var654 = bitcast [148 x i8]* @gsxtmgraphics-pipeline21 to i8*
call i32 (i8*, ...) @printf(i8* %var654)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var655 = bitcast [148 x i8]* @gsxtmgraphics-pipeline21 to i8*
call i32 (i8*, ...) @printf(i8* %var655)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var656 = bitcast [148 x i8]* @gsxtmgraphics-pipeline21 to i8*
call i32 (i8*, ...) @printf(i8* %var656)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var657 = bitcast [148 x i8]* @gsxtmgraphics-pipeline21 to i8*
call i32 (i8*, ...) @printf(i8* %var657)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var658 = bitcast [148 x i8]* @gsxtmgraphics-pipeline21 to i8*
call i32 (i8*, ...) @printf(i8* %var658)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_real(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var659 = bitcast [148 x i8]* @gsxtmgraphics-pipeline21 to i8*
call i32 (i8*, ...) @printf(i8* %var659)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc float  @r32value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_real(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var660 = bitcast [148 x i8]* @gsxtmgraphics-pipeline21 to i8*
call i32 (i8*, ...) @printf(i8* %var660)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%arg_6 = call ccc float  @r32value(i8* %arg_6_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float, float, float, float)*,  void (i8*, i8*, float*, float, float, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4, float %arg_5, float %arg_6)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float, float, float, float, float, float}*
%arg_p_0 = getelementptr {float*, float, float, float, float, float, float}, {float*, float, float, float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float, float, float, float, float, float}, {float*, float, float, float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float*, float, float, float, float, float, float}, {float*, float, float, float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float*, float, float, float, float, float, float}, {float*, float, float, float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {float*, float, float, float, float, float, float}, {float*, float, float, float, float, float, float}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
%arg_p_5 = getelementptr {float*, float, float, float, float, float, float}, {float*, float, float, float, float, float, float}* %fstruct, i32 0, i32 5
%arg_5 = load float, float* %arg_p_5
%arg_p_6 = getelementptr {float*, float, float, float, float, float, float}, {float*, float, float, float, float, float, float}* %fstruct, i32 0, i32 6
%arg_6 = load float, float* %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float, float, float, float)*,  void (i8*, i8*, float*, float, float, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4, float %arg_5, float %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline22 = hidden constant [80 x i8] c"fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
define dllexport fastcc void @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__661(i8* %_impz,i8* %_impenv, float* %mat, float %fovy, float %aspect, float %near, float %far) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone662 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}***}*
%fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}**** %fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%matPtr = alloca float*
store float* %mat, float** %matPtr
%fovyPtr = alloca float
store float %fovy, float* %fovyPtr
%aspectPtr = alloca float
store float %aspect, float* %aspectPtr
%nearPtr = alloca float
store float %near, float* %nearPtr
%farPtr = alloca float
store float %far, float* %farPtr


%tzone667 = load i8*, i8** %_impzPtr
%zone668 = bitcast i8* %tzone667 to %mzone*

; let assign value to symbol a
%aPtr = alloca float
%tzone676 = load i8*, i8** %_impzPtr
%zone677 = bitcast i8* %tzone676 to %mzone*

; let assign value to symbol c
%cPtr = alloca float
%val663 = load float, float* %fovyPtr
%val664 = load float, float* @PIf
%val665 = fdiv float %val664, 0x4066800000000000
%val666 = fmul float %val663, %val665

; let value assignment
%a = select i1 true, float %val666, float %val666
store float %a, float* %aPtr

%val669 = load float, float* %aPtr
%val670 = fmul float %val669, 0x3fe0000000000000
%val671 = call float @llvm.cos.f32(float %val670)
%val672 = load float, float* %aPtr
%val673 = fmul float %val672, 0x3fe0000000000000
%val674 = call float @llvm.sin.f32(float %val673)
%val675 = fdiv float %val671, %val674

; let value assignment
%c = select i1 true, float %val675, float %val675
store float %c, float* %cPtr

%val678 = load float*, float** %matPtr
%val679 = load float, float* %cPtr
%val680 = load float, float* %aspectPtr
%val681 = fdiv float %val679, %val680
; set pointer
%val682 = getelementptr float, float* %val678, i64 0
store float %val681, float* %val682
%val683 = load float*, float** %matPtr
; set pointer
%val684 = getelementptr float, float* %val683, i64 1
store float 0x0, float* %val684
%val685 = load float*, float** %matPtr
; set pointer
%val686 = getelementptr float, float* %val685, i64 2
store float 0x0, float* %val686
%val687 = load float*, float** %matPtr
; set pointer
%val688 = getelementptr float, float* %val687, i64 3
store float 0x0, float* %val688
%val689 = load float*, float** %matPtr
; set pointer
%val690 = getelementptr float, float* %val689, i64 4
store float 0x0, float* %val690
%val691 = load float*, float** %matPtr
%val692 = load float, float* %cPtr
; set pointer
%val693 = getelementptr float, float* %val691, i64 5
store float %val692, float* %val693
%val694 = load float*, float** %matPtr
; set pointer
%val695 = getelementptr float, float* %val694, i64 6
store float 0x0, float* %val695
%val696 = load float*, float** %matPtr
; set pointer
%val697 = getelementptr float, float* %val696, i64 7
store float 0x0, float* %val697
%val698 = load float*, float** %matPtr
; set pointer
%val699 = getelementptr float, float* %val698, i64 8
store float 0x0, float* %val699
%val700 = load float*, float** %matPtr
; set pointer
%val701 = getelementptr float, float* %val700, i64 9
store float 0x0, float* %val701
%val702 = load float*, float** %matPtr
%val703 = load float, float* %farPtr
%val704 = load float, float* %nearPtr
%val705 = fadd float %val703, %val704
%val706 = load float, float* %farPtr
%val707 = load float, float* %nearPtr
%val708 = fsub float %val706, %val707
%val709 = fdiv float %val705, %val708
%val710 = fmul float 0xbff0000000000000, %val709
; set pointer
%val711 = getelementptr float, float* %val702, i64 10
store float %val710, float* %val711
%val712 = load float*, float** %matPtr
; set pointer
%val713 = getelementptr float, float* %val712, i64 11
store float 0xbff0000000000000, float* %val713
%val714 = load float*, float** %matPtr
; set pointer
%val715 = getelementptr float, float* %val714, i64 12
store float 0x0, float* %val715
%val716 = load float*, float** %matPtr
; set pointer
%val717 = getelementptr float, float* %val716, i64 13
store float 0x0, float* %val717
%val718 = load float*, float** %matPtr
%val719 = load float, float* %farPtr
%val720 = fmul float 0x4000000000000000, %val719
%val721 = load float, float* %nearPtr
%val722 = fmul float %val720, %val721
%val723 = load float, float* %farPtr
%val724 = load float, float* %nearPtr
%val725 = fsub float %val723, %val724
%val726 = fdiv float %val722, %val725
%val727 = fmul float 0xbff0000000000000, %val726
; set pointer
%val728 = getelementptr float, float* %val718, i64 14
store float %val727, float* %val728
%val729 = load float*, float** %matPtr
; set pointer
%val730 = getelementptr float, float* %val729, i64 15
store float 0x0, float* %val730
ret void
}
@gsxtmgraphics-pipeline23 = hidden constant [133 x i8] c"fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone751 = load i8*, i8** %_impzPtr
%zone752 = bitcast i8* %tzone751 to %mzone*

; let assign value to symbol fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone752, i64 8)
%fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ to { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}***
%tzone732 = load i8*, i8** %_impzPtr
%zone733 = bitcast i8* %tzone732 to %mzone*
call void @llvm_zone_mark(%mzone* %zone733)
; malloc closure structure
%clsptr734 = call i8* @llvm_zone_malloc(%mzone* %zone733, i64 24)
%closure735 = bitcast i8* %clsptr734 to { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}*

; malloc environment structure
%envptr736 = call i8* @llvm_zone_malloc(%mzone* %zone733, i64 8)
%environment737 = bitcast i8* %envptr736 to {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}***}*

; malloc closure address table
%addytable738 = call %clsvar* @new_address_table()
%var739 = bitcast [80 x i8]* @gsxtmgraphics-pipeline22 to i8*
%var740 = bitcast [67 x i8]* @gsxtmgraphics-pipeline15 to i8*
%addytable741 = call %clsvar* @add_address_table(%mzone* %zone733, i8* %var739, i32 0, i8* %var740, i32 3, %clsvar* %addytable738)
%address-table742 = bitcast %clsvar* %addytable741 to i8*

; insert table, function and environment into closure struct
%closure.table745 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure735, i32 0, i32 0
store i8* %address-table742, i8** %closure.table745
%closure.env746 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure735, i32 0, i32 1
store i8* %envptr736, i8** %closure.env746
%closure.func747 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure735, i32 0, i32 2
store void (i8*, i8*, float*, float, float, float, float)* @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__661, void (i8*, i8*, float*, float, float, float, float)** %closure.func747
%closure_size748 = call i64 @llvm_zone_mark_size(%mzone* %zone733)
call void @llvm_zone_ptr_set_size(i8* %clsptr734, i64 %closure_size748)
%wrapper_ptr749 = call i8* @llvm_zone_malloc(%mzone* %zone733, i64 8)
%closure_wrapper750 = bitcast i8* %wrapper_ptr749 to { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure735, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** %closure_wrapper750

; let value assignment
%fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** %closure_wrapper750, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** %closure_wrapper750
store { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** %fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}*** %fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr744 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}***}* %environment737, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}*** %fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}**** %tmp_envptr744


%val753 = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}*** %fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** %val753
}


@fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ(float* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float, float)*,  void (i8*, i8*, float*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
ret void
}


define dllexport ccc void @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_native(float* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float, float)*,  void (i8*, i8*, float*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
ret void
}


define dllexport ccc i8*  @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var754 = bitcast [133 x i8]* @gsxtmgraphics-pipeline23 to i8*
call i32 (i8*, ...) @printf(i8* %var754)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var755 = bitcast [133 x i8]* @gsxtmgraphics-pipeline23 to i8*
call i32 (i8*, ...) @printf(i8* %var755)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var756 = bitcast [133 x i8]* @gsxtmgraphics-pipeline23 to i8*
call i32 (i8*, ...) @printf(i8* %var756)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var757 = bitcast [133 x i8]* @gsxtmgraphics-pipeline23 to i8*
call i32 (i8*, ...) @printf(i8* %var757)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var758 = bitcast [133 x i8]* @gsxtmgraphics-pipeline23 to i8*
call i32 (i8*, ...) @printf(i8* %var758)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float, float)*,  void (i8*, i8*, float*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float, float, float, float}*
%arg_p_0 = getelementptr {float*, float, float, float, float}, {float*, float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float, float, float, float}, {float*, float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float*, float, float, float, float}, {float*, float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float*, float, float, float, float}, {float*, float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {float*, float, float, float, float}, {float*, float, float, float, float}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float, float)*,  void (i8*, i8*, float*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline24 = hidden constant [96 x i8] c"fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
define dllexport fastcc void @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__759(i8* %_impz,i8* %_impenv, float* %mat, float %l, float %r, float %b, float %t, float %n, float %f) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone760 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***}*
%fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**** %fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%matPtr = alloca float*
store float* %mat, float** %matPtr
%lPtr = alloca float
store float %l, float* %lPtr
%rPtr = alloca float
store float %r, float* %rPtr
%bPtr = alloca float
store float %b, float* %bPtr
%tPtr = alloca float
store float %t, float* %tPtr
%nPtr = alloca float
store float %n, float* %nPtr
%fPtr = alloca float
store float %f, float* %fPtr


%val761 = load float*, float** %matPtr
%val762 = load float, float* %rPtr
%val763 = load float, float* %lPtr
%val764 = fsub float %val762, %val763
%val765 = fdiv float 0x4000000000000000, %val764
; set pointer
%val766 = getelementptr float, float* %val761, i64 0
store float %val765, float* %val766
%val767 = load float*, float** %matPtr
; set pointer
%val768 = getelementptr float, float* %val767, i64 1
store float 0x0, float* %val768
%val769 = load float*, float** %matPtr
; set pointer
%val770 = getelementptr float, float* %val769, i64 2
store float 0x0, float* %val770
%val771 = load float*, float** %matPtr
; set pointer
%val772 = getelementptr float, float* %val771, i64 3
store float 0x0, float* %val772
%val773 = load float*, float** %matPtr
; set pointer
%val774 = getelementptr float, float* %val773, i64 4
store float 0x0, float* %val774
%val775 = load float*, float** %matPtr
%val776 = load float, float* %nPtr
%val777 = fmul float 0x4000000000000000, %val776
%val778 = load float, float* %tPtr
%val779 = load float, float* %bPtr
%val780 = fsub float %val778, %val779
%val781 = fdiv float %val777, %val780
; set pointer
%val782 = getelementptr float, float* %val775, i64 5
store float %val781, float* %val782
%val783 = load float*, float** %matPtr
; set pointer
%val784 = getelementptr float, float* %val783, i64 6
store float 0x0, float* %val784
%val785 = load float*, float** %matPtr
; set pointer
%val786 = getelementptr float, float* %val785, i64 7
store float 0x0, float* %val786
%val787 = load float*, float** %matPtr
%val788 = load float, float* %rPtr
%val789 = load float, float* %lPtr
%val790 = fadd float %val788, %val789
%val791 = load float, float* %rPtr
%val792 = load float, float* %lPtr
%val793 = fsub float %val791, %val792
%val794 = fdiv float %val790, %val793
; set pointer
%val795 = getelementptr float, float* %val787, i64 8
store float %val794, float* %val795
%val796 = load float*, float** %matPtr
%val797 = load float, float* %tPtr
%val798 = load float, float* %bPtr
%val799 = fadd float %val797, %val798
%val800 = load float, float* %tPtr
%val801 = load float, float* %bPtr
%val802 = fsub float %val800, %val801
%val803 = fdiv float %val799, %val802
; set pointer
%val804 = getelementptr float, float* %val796, i64 9
store float %val803, float* %val804
%val805 = load float*, float** %matPtr
%val806 = load float, float* %fPtr
%val807 = load float, float* %nPtr
%val808 = fadd float %val806, %val807
%val809 = load float, float* %fPtr
%val810 = load float, float* %nPtr
%val811 = fsub float %val809, %val810
%val812 = fdiv float %val808, %val811
%val813 = fmul float 0xbff0000000000000, %val812
; set pointer
%val814 = getelementptr float, float* %val805, i64 10
store float %val813, float* %val814
%val815 = load float*, float** %matPtr
; set pointer
%val816 = getelementptr float, float* %val815, i64 11
store float 0xbff0000000000000, float* %val816
%val817 = load float*, float** %matPtr
; set pointer
%val818 = getelementptr float, float* %val817, i64 12
store float 0x0, float* %val818
%val819 = load float*, float** %matPtr
; set pointer
%val820 = getelementptr float, float* %val819, i64 13
store float 0x0, float* %val820
%val821 = load float*, float** %matPtr
%val822 = load float, float* %fPtr
%val823 = fmul float 0x4000000000000000, %val822
%val824 = load float, float* %nPtr
%val825 = fmul float %val823, %val824
%val826 = fmul float 0xbff0000000000000, %val825
%val827 = load float, float* %fPtr
%val828 = load float, float* %nPtr
%val829 = fsub float %val827, %val828
%val830 = fmul float %val826, %val829
; set pointer
%val831 = getelementptr float, float* %val821, i64 14
store float %val830, float* %val831
%val832 = load float*, float** %matPtr
; set pointer
%val833 = getelementptr float, float* %val832, i64 15
store float 0x0, float* %val833
ret void
}
@gsxtmgraphics-pipeline25 = hidden constant [149 x i8] c"fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone854 = load i8*, i8** %_impzPtr
%zone855 = bitcast i8* %tzone854 to %mzone*

; let assign value to symbol fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone855, i64 8)
%fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ to { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***
%tzone835 = load i8*, i8** %_impzPtr
%zone836 = bitcast i8* %tzone835 to %mzone*
call void @llvm_zone_mark(%mzone* %zone836)
; malloc closure structure
%clsptr837 = call i8* @llvm_zone_malloc(%mzone* %zone836, i64 24)
%closure838 = bitcast i8* %clsptr837 to { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*

; malloc environment structure
%envptr839 = call i8* @llvm_zone_malloc(%mzone* %zone836, i64 8)
%environment840 = bitcast i8* %envptr839 to {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***}*

; malloc closure address table
%addytable841 = call %clsvar* @new_address_table()
%var842 = bitcast [96 x i8]* @gsxtmgraphics-pipeline24 to i8*
%var843 = bitcast [81 x i8]* @gsxtmgraphics-pipeline20 to i8*
%addytable844 = call %clsvar* @add_address_table(%mzone* %zone836, i8* %var842, i32 0, i8* %var843, i32 3, %clsvar* %addytable841)
%address-table845 = bitcast %clsvar* %addytable844 to i8*

; insert table, function and environment into closure struct
%closure.table848 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure838, i32 0, i32 0
store i8* %address-table845, i8** %closure.table848
%closure.env849 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure838, i32 0, i32 1
store i8* %envptr839, i8** %closure.env849
%closure.func850 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure838, i32 0, i32 2
store void (i8*, i8*, float*, float, float, float, float, float, float)* @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__759, void (i8*, i8*, float*, float, float, float, float, float, float)** %closure.func850
%closure_size851 = call i64 @llvm_zone_mark_size(%mzone* %zone836)
call void @llvm_zone_ptr_set_size(i8* %clsptr837, i64 %closure_size851)
%wrapper_ptr852 = call i8* @llvm_zone_malloc(%mzone* %zone836, i64 8)
%closure_wrapper853 = bitcast i8* %wrapper_ptr852 to { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure838, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure_wrapper853

; let value assignment
%fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure_wrapper853, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure_wrapper853
store { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*** %fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr847 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***}* %environment840, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*** %fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**** %tmp_envptr847


%val856 = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*** %fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %val856
}


@fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ(float* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4,float %arg_5,float %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float, float, float, float)*,  void (i8*, i8*, float*, float, float, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4, float %arg_5, float %arg_6)
ret void
}


define dllexport ccc void @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_native(float* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4,float %arg_5,float %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float, float, float, float)*,  void (i8*, i8*, float*, float, float, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4, float %arg_5, float %arg_6)
ret void
}


define dllexport ccc i8*  @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var857 = bitcast [149 x i8]* @gsxtmgraphics-pipeline25 to i8*
call i32 (i8*, ...) @printf(i8* %var857)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var858 = bitcast [149 x i8]* @gsxtmgraphics-pipeline25 to i8*
call i32 (i8*, ...) @printf(i8* %var858)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var859 = bitcast [149 x i8]* @gsxtmgraphics-pipeline25 to i8*
call i32 (i8*, ...) @printf(i8* %var859)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var860 = bitcast [149 x i8]* @gsxtmgraphics-pipeline25 to i8*
call i32 (i8*, ...) @printf(i8* %var860)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var861 = bitcast [149 x i8]* @gsxtmgraphics-pipeline25 to i8*
call i32 (i8*, ...) @printf(i8* %var861)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_real(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var862 = bitcast [149 x i8]* @gsxtmgraphics-pipeline25 to i8*
call i32 (i8*, ...) @printf(i8* %var862)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc float  @r32value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_real(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var863 = bitcast [149 x i8]* @gsxtmgraphics-pipeline25 to i8*
call i32 (i8*, ...) @printf(i8* %var863)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%arg_6 = call ccc float  @r32value(i8* %arg_6_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float, float, float, float)*,  void (i8*, i8*, float*, float, float, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4, float %arg_5, float %arg_6)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float, float, float, float, float, float}*
%arg_p_0 = getelementptr {float*, float, float, float, float, float, float}, {float*, float, float, float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float, float, float, float, float, float}, {float*, float, float, float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float*, float, float, float, float, float, float}, {float*, float, float, float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float*, float, float, float, float, float, float}, {float*, float, float, float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {float*, float, float, float, float, float, float}, {float*, float, float, float, float, float, float}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
%arg_p_5 = getelementptr {float*, float, float, float, float, float, float}, {float*, float, float, float, float, float, float}* %fstruct, i32 0, i32 5
%arg_5 = load float, float* %arg_p_5
%arg_p_6 = getelementptr {float*, float, float, float, float, float, float}, {float*, float, float, float, float, float, float}* %fstruct, i32 0, i32 6
%arg_6 = load float, float* %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float, float, float, float)*,  void (i8*, i8*, float*, float, float, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4, float %arg_5, float %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline26 = hidden constant [98 x i8] c"fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
define dllexport fastcc void @fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__864(i8* %_impz,i8* %_impenv, float* %mat, float %left, float %right, float %bottom, float %top, float %near, float %far) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone865 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***}*
%fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**** %fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%matPtr = alloca float*
store float* %mat, float** %matPtr
%leftPtr = alloca float
store float %left, float* %leftPtr
%rightPtr = alloca float
store float %right, float* %rightPtr
%bottomPtr = alloca float
store float %bottom, float* %bottomPtr
%topPtr = alloca float
store float %top, float* %topPtr
%nearPtr = alloca float
store float %near, float* %nearPtr
%farPtr = alloca float
store float %far, float* %farPtr


%val866 = load float*, float** %matPtr
%val867 = load float, float* %rightPtr
%val868 = load float, float* %leftPtr
%val869 = fsub float %val867, %val868
%val870 = fdiv float 0x4000000000000000, %val869
; set pointer
%val871 = getelementptr float, float* %val866, i64 0
store float %val870, float* %val871
%val872 = load float*, float** %matPtr
; set pointer
%val873 = getelementptr float, float* %val872, i64 1
store float 0x0, float* %val873
%val874 = load float*, float** %matPtr
; set pointer
%val875 = getelementptr float, float* %val874, i64 2
store float 0x0, float* %val875
%val876 = load float*, float** %matPtr
; set pointer
%val877 = getelementptr float, float* %val876, i64 3
store float 0x0, float* %val877
%val878 = load float*, float** %matPtr
; set pointer
%val879 = getelementptr float, float* %val878, i64 4
store float 0x0, float* %val879
%val880 = load float*, float** %matPtr
%val881 = load float, float* %topPtr
%val882 = load float, float* %bottomPtr
%val883 = fsub float %val881, %val882
%val884 = fdiv float 0x4000000000000000, %val883
; set pointer
%val885 = getelementptr float, float* %val880, i64 5
store float %val884, float* %val885
%val886 = load float*, float** %matPtr
; set pointer
%val887 = getelementptr float, float* %val886, i64 6
store float 0x0, float* %val887
%val888 = load float*, float** %matPtr
; set pointer
%val889 = getelementptr float, float* %val888, i64 7
store float 0x0, float* %val889
%val890 = load float*, float** %matPtr
; set pointer
%val891 = getelementptr float, float* %val890, i64 8
store float 0x0, float* %val891
%val892 = load float*, float** %matPtr
; set pointer
%val893 = getelementptr float, float* %val892, i64 9
store float 0x0, float* %val893
%val894 = load float*, float** %matPtr
%val895 = load float, float* %farPtr
%val896 = load float, float* %nearPtr
%val897 = fsub float %val895, %val896
%val898 = fdiv float 0x4000000000000000, %val897
%val899 = fmul float 0xbff0000000000000, %val898
; set pointer
%val900 = getelementptr float, float* %val894, i64 10
store float %val899, float* %val900
%val901 = load float*, float** %matPtr
; set pointer
%val902 = getelementptr float, float* %val901, i64 11
store float 0x0, float* %val902
%val903 = load float*, float** %matPtr
%val904 = load float, float* %leftPtr
%val905 = load float, float* %rightPtr
%val906 = fadd float %val904, %val905
%val907 = load float, float* %rightPtr
%val908 = load float, float* %leftPtr
%val909 = fsub float %val907, %val908
%val910 = fdiv float %val906, %val909
%val911 = fmul float 0xbff0000000000000, %val910
; set pointer
%val912 = getelementptr float, float* %val903, i64 12
store float %val911, float* %val912
%val913 = load float*, float** %matPtr
%val914 = load float, float* %topPtr
%val915 = load float, float* %bottomPtr
%val916 = fadd float %val914, %val915
%val917 = load float, float* %topPtr
%val918 = load float, float* %bottomPtr
%val919 = fsub float %val917, %val918
%val920 = fdiv float %val916, %val919
%val921 = fmul float 0xbff0000000000000, %val920
; set pointer
%val922 = getelementptr float, float* %val913, i64 13
store float %val921, float* %val922
%val923 = load float*, float** %matPtr
%val924 = load float, float* %farPtr
%val925 = load float, float* %nearPtr
%val926 = fadd float %val924, %val925
%val927 = load float, float* %farPtr
%val928 = load float, float* %nearPtr
%val929 = fsub float %val927, %val928
%val930 = fdiv float %val926, %val929
%val931 = fmul float 0xbff0000000000000, %val930
; set pointer
%val932 = getelementptr float, float* %val923, i64 14
store float %val931, float* %val932
%val933 = load float*, float** %matPtr
; set pointer
%val934 = getelementptr float, float* %val933, i64 15
store float 0x3ff0000000000000, float* %val934
ret void
}
@gsxtmgraphics-pipeline27 = hidden constant [151 x i8] c"fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** @fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone955 = load i8*, i8** %_impzPtr
%zone956 = bitcast i8* %tzone955 to %mzone*

; let assign value to symbol fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone956, i64 8)
%fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ to { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***
%tzone936 = load i8*, i8** %_impzPtr
%zone937 = bitcast i8* %tzone936 to %mzone*
call void @llvm_zone_mark(%mzone* %zone937)
; malloc closure structure
%clsptr938 = call i8* @llvm_zone_malloc(%mzone* %zone937, i64 24)
%closure939 = bitcast i8* %clsptr938 to { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*

; malloc environment structure
%envptr940 = call i8* @llvm_zone_malloc(%mzone* %zone937, i64 8)
%environment941 = bitcast i8* %envptr940 to {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***}*

; malloc closure address table
%addytable942 = call %clsvar* @new_address_table()
%var943 = bitcast [98 x i8]* @gsxtmgraphics-pipeline26 to i8*
%var944 = bitcast [81 x i8]* @gsxtmgraphics-pipeline20 to i8*
%addytable945 = call %clsvar* @add_address_table(%mzone* %zone937, i8* %var943, i32 0, i8* %var944, i32 3, %clsvar* %addytable942)
%address-table946 = bitcast %clsvar* %addytable945 to i8*

; insert table, function and environment into closure struct
%closure.table949 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure939, i32 0, i32 0
store i8* %address-table946, i8** %closure.table949
%closure.env950 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure939, i32 0, i32 1
store i8* %envptr940, i8** %closure.env950
%closure.func951 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure939, i32 0, i32 2
store void (i8*, i8*, float*, float, float, float, float, float, float)* @fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__864, void (i8*, i8*, float*, float, float, float, float, float, float)** %closure.func951
%closure_size952 = call i64 @llvm_zone_mark_size(%mzone* %zone937)
call void @llvm_zone_ptr_set_size(i8* %clsptr938, i64 %closure_size952)
%wrapper_ptr953 = call i8* @llvm_zone_malloc(%mzone* %zone937, i64 8)
%closure_wrapper954 = bitcast i8* %wrapper_ptr953 to { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure939, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure_wrapper954

; let value assignment
%fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure_wrapper954, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure_wrapper954
store { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ, { i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*** %fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr948 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}***}* %environment941, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*** %fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**** %tmp_envptr948


%val957 = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*** %fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %val957
}


@fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** @fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ(float* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4,float %arg_5,float %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float, float, float, float)*,  void (i8*, i8*, float*, float, float, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4, float %arg_5, float %arg_6)
ret void
}


define dllexport ccc void @fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_native(float* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4,float %arg_5,float %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float, float, float, float)*,  void (i8*, i8*, float*, float, float, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4, float %arg_5, float %arg_6)
ret void
}


define dllexport ccc i8*  @fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var958 = bitcast [151 x i8]* @gsxtmgraphics-pipeline27 to i8*
call i32 (i8*, ...) @printf(i8* %var958)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var959 = bitcast [151 x i8]* @gsxtmgraphics-pipeline27 to i8*
call i32 (i8*, ...) @printf(i8* %var959)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var960 = bitcast [151 x i8]* @gsxtmgraphics-pipeline27 to i8*
call i32 (i8*, ...) @printf(i8* %var960)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var961 = bitcast [151 x i8]* @gsxtmgraphics-pipeline27 to i8*
call i32 (i8*, ...) @printf(i8* %var961)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var962 = bitcast [151 x i8]* @gsxtmgraphics-pipeline27 to i8*
call i32 (i8*, ...) @printf(i8* %var962)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_real(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var963 = bitcast [151 x i8]* @gsxtmgraphics-pipeline27 to i8*
call i32 (i8*, ...) @printf(i8* %var963)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc float  @r32value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_real(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var964 = bitcast [151 x i8]* @gsxtmgraphics-pipeline27 to i8*
call i32 (i8*, ...) @printf(i8* %var964)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%arg_6 = call ccc float  @r32value(i8* %arg_6_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float, float, float, float)*,  void (i8*, i8*, float*, float, float, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4, float %arg_5, float %arg_6)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float, float, float, float, float, float}*
%arg_p_0 = getelementptr {float*, float, float, float, float, float, float}, {float*, float, float, float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float, float, float, float, float, float}, {float*, float, float, float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float*, float, float, float, float, float, float}, {float*, float, float, float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float*, float, float, float, float, float, float}, {float*, float, float, float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {float*, float, float, float, float, float, float}, {float*, float, float, float, float, float, float}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
%arg_p_5 = getelementptr {float*, float, float, float, float, float, float}, {float*, float, float, float, float, float, float}* %fstruct, i32 0, i32 5
%arg_5 = load float, float* %arg_p_5
%arg_p_6 = getelementptr {float*, float, float, float, float, float, float}, {float*, float, float, float, float, float, float}* %fstruct, i32 0, i32 6
%arg_6 = load float, float* %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float, float, float, float)*,  void (i8*, i8*, float*, float, float, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4, float %arg_5, float %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline28 = hidden constant [65 x i8] c"fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd\00"
@gsxtmgraphics-pipeline29 = hidden constant [55 x i8] c"{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}**\00"
define dllexport fastcc void @fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd__965(i8* %_impz,i8* %_impenv, float* %v1, float* %v2, float* %v3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone966 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***}*
%fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr = load {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}**** %fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr_

; setup arguments
%v1Ptr = alloca float*
store float* %v1, float** %v1Ptr
%v2Ptr = alloca float*
store float* %v2, float** %v2Ptr
%v3Ptr = alloca float*
store float* %v3, float** %v3Ptr


%tzone968 = load i8*, i8** %_impzPtr
%zone969 = bitcast i8* %tzone968 to %mzone*

; let assign value to symbol tmp
%tmpPtr = alloca float*
%dat967 = alloca float, i64 4, align 16

; let value assignment
%tmp = select i1 true, float* %dat967, float* %dat967
store float* %tmp, float** %tmpPtr

%val970 = load float*, float** %v1Ptr
%val971 = load float*, float** %v2Ptr
%val972 = load float*, float** %tmpPtr
call fastcc void @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ(float* %val970, float* %val971, i64 3, float* %val972)
%val974 = load float*, float** %tmpPtr
%val975 = load float*, float** %v3Ptr
call fastcc void @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd(float* %val974, i64 3, float* %val975)
%val977 = load float*, float** %v3Ptr
; set pointer
%val978 = getelementptr float, float* %val977, i64 3
store float 0x0, float* %val978
ret void
}
@gsxtmgraphics-pipeline30 = hidden constant [118 x i8] c"fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** @fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone999 = load i8*, i8** %_impzPtr
%zone1000 = bitcast i8* %tzone999 to %mzone*

; let assign value to symbol fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd
%dat_fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd = call i8* @llvm_zone_malloc(%mzone* %zone1000, i64 8)
%fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr = bitcast i8* %dat_fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd to { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***
%tzone980 = load i8*, i8** %_impzPtr
%zone981 = bitcast i8* %tzone980 to %mzone*
call void @llvm_zone_mark(%mzone* %zone981)
; malloc closure structure
%clsptr982 = call i8* @llvm_zone_malloc(%mzone* %zone981, i64 24)
%closure983 = bitcast i8* %clsptr982 to { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}*

; malloc environment structure
%envptr984 = call i8* @llvm_zone_malloc(%mzone* %zone981, i64 8)
%environment985 = bitcast i8* %envptr984 to {{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***}*

; malloc closure address table
%addytable986 = call %clsvar* @new_address_table()
%var987 = bitcast [65 x i8]* @gsxtmgraphics-pipeline28 to i8*
%var988 = bitcast [55 x i8]* @gsxtmgraphics-pipeline29 to i8*
%addytable989 = call %clsvar* @add_address_table(%mzone* %zone981, i8* %var987, i32 0, i8* %var988, i32 3, %clsvar* %addytable986)
%address-table990 = bitcast %clsvar* %addytable989 to i8*

; insert table, function and environment into closure struct
%closure.table993 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure983, i32 0, i32 0
store i8* %address-table990, i8** %closure.table993
%closure.env994 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure983, i32 0, i32 1
store i8* %envptr984, i8** %closure.env994
%closure.func995 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure983, i32 0, i32 2
store void (i8*, i8*, float*, float*, float*)* @fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd__965, void (i8*, i8*, float*, float*, float*)** %closure.func995
%closure_size996 = call i64 @llvm_zone_mark_size(%mzone* %zone981)
call void @llvm_zone_ptr_set_size(i8* %clsptr982, i64 %closure_size996)
%wrapper_ptr997 = call i8* @llvm_zone_malloc(%mzone* %zone981, i64 8)
%closure_wrapper998 = bitcast i8* %wrapper_ptr997 to { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure983, { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %closure_wrapper998

; let value assignment
%fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %closure_wrapper998, { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %closure_wrapper998
store { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd, { i8*, i8*, void (i8*, i8*, float*, float*, float*)*}*** %fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr

; add data to environment
; don't need to alloc for env var fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd
%tmp_envptr992 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*)*}***}* %environment985, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}*** %fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}**** %tmp_envptr992


%val1001 = load {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}*** %fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr
ret {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %val1001
}


@fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** @fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd(float* %arg_0,float* %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
ret void
}


define dllexport ccc void @fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_native(float* %arg_0,float* %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
ret void
}


define dllexport ccc i8*  @fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1002 = bitcast [118 x i8]* @gsxtmgraphics-pipeline30 to i8*
call i32 (i8*, ...) @printf(i8* %var1002)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1003 = bitcast [118 x i8]* @gsxtmgraphics-pipeline30 to i8*
call i32 (i8*, ...) @printf(i8* %var1003)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1004 = bitcast [118 x i8]* @gsxtmgraphics-pipeline30 to i8*
call i32 (i8*, ...) @printf(i8* %var1004)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, float*}*
%arg_p_0 = getelementptr {float*, float*, float*}, {float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, float*}, {float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, float*}, {float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_direction_vector_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline31 = hidden constant [70 x i8] c"fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ\00"
@gsxtmgraphics-pipeline32 = hidden constant [63 x i8] c"{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**\00"
@gsxtmgraphics-pipeline33 = hidden constant [5 x i8] c"vtmp\00"
@gsxtmgraphics-pipeline34 = hidden constant [7 x i8] c"float*\00"
@gsxtmgraphics-pipeline35 = hidden constant [3 x i8] c"vx\00"
@gsxtmgraphics-pipeline36 = hidden constant [3 x i8] c"vy\00"
@gsxtmgraphics-pipeline37 = hidden constant [3 x i8] c"vz\00"
@gsxtmgraphics-pipeline38 = hidden constant [19 x i8] c"translation_matrix\00"
@gsxtmgraphics-pipeline39 = hidden constant [19 x i8] c"orientation_matrix\00"
@gsxtmgraphics-pipeline40 = hidden constant [15 x i8] c"_anon_lambda_1\00"
define dllexport fastcc void @fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ__1005(i8* %_impz,i8* %_impenv, float* %matrix, float* %vEye, float* %vTarget, float* %vUp) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1054 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}*
%fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**** %fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_
%vtmpPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 1
%vtmpPtr = load float**, float*** %vtmpPtr_
%vxPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 2
%vxPtr = load float**, float*** %vxPtr_
%vyPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 3
%vyPtr = load float**, float*** %vyPtr_
%vzPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 4
%vzPtr = load float**, float*** %vzPtr_
%translation_matrixPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 5
%translation_matrixPtr = load float**, float*** %translation_matrixPtr_
%orientation_matrixPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 6
%orientation_matrixPtr = load float**, float*** %orientation_matrixPtr_
%_anon_lambda_1Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 7
%_anon_lambda_1Ptr = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**** %_anon_lambda_1Ptr_

; setup arguments
%matrixPtr = alloca float*
store float* %matrix, float** %matrixPtr
%vEyePtr = alloca float*
store float* %vEye, float** %vEyePtr
%vTargetPtr = alloca float*
store float* %vTarget, float** %vTargetPtr
%vUpPtr = alloca float*
store float* %vUp, float** %vUpPtr


%tzone1055 = load i8*, i8** %_impzPtr
%zone1056 = bitcast i8* %tzone1055 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

%val1057 = load float*, float** %vEyePtr
%val1058 = load float*, float** %vTargetPtr
%val1059 = load float*, float** %vtmpPtr
call fastcc void @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ(float* %val1057, float* %val1058, i64 3, float* %val1059)
%val1061 = load float*, float** %vtmpPtr
%val1062 = load float*, float** %vzPtr
call fastcc void @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd(float* %val1061, i64 3, float* %val1062)
%val1064 = load float*, float** %vUpPtr
%val1065 = load float*, float** %vzPtr
%val1066 = load float*, float** %vtmpPtr
call fastcc void @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd(float* %val1064, float* %val1065, float* %val1066)
%val1068 = load float*, float** %vtmpPtr
%val1069 = load float*, float** %vxPtr
call fastcc void @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd(float* %val1068, i64 3, float* %val1069)
%val1071 = load float*, float** %vzPtr
%val1072 = load float*, float** %vxPtr
%val1073 = load float*, float** %vyPtr
call fastcc void @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd(float* %val1071, float* %val1072, float* %val1073)
%val1075 = load float*, float** %orientation_matrixPtr
%val1076 = load float*, float** %vxPtr
; pointer ref
%val1077 = getelementptr float, float* %val1076, i64 0
%val1078 = load float, float* %val1077
; set pointer
%val1079 = getelementptr float, float* %val1075, i64 0
store float %val1078, float* %val1079
%val1080 = load float*, float** %orientation_matrixPtr
%val1081 = load float*, float** %vyPtr
; pointer ref
%val1082 = getelementptr float, float* %val1081, i64 0
%val1083 = load float, float* %val1082
; set pointer
%val1084 = getelementptr float, float* %val1080, i64 1
store float %val1083, float* %val1084
%val1085 = load float*, float** %orientation_matrixPtr
%val1086 = load float*, float** %vzPtr
; pointer ref
%val1087 = getelementptr float, float* %val1086, i64 0
%val1088 = load float, float* %val1087
; set pointer
%val1089 = getelementptr float, float* %val1085, i64 2
store float %val1088, float* %val1089
%val1090 = load float*, float** %orientation_matrixPtr
; set pointer
%val1091 = getelementptr float, float* %val1090, i64 3
store float 0x0, float* %val1091
%val1092 = load float*, float** %orientation_matrixPtr
%val1093 = load float*, float** %vxPtr
; pointer ref
%val1094 = getelementptr float, float* %val1093, i64 1
%val1095 = load float, float* %val1094
; set pointer
%val1096 = getelementptr float, float* %val1092, i64 4
store float %val1095, float* %val1096
%val1097 = load float*, float** %orientation_matrixPtr
%val1098 = load float*, float** %vyPtr
; pointer ref
%val1099 = getelementptr float, float* %val1098, i64 1
%val1100 = load float, float* %val1099
; set pointer
%val1101 = getelementptr float, float* %val1097, i64 5
store float %val1100, float* %val1101
%val1102 = load float*, float** %orientation_matrixPtr
%val1103 = load float*, float** %vzPtr
; pointer ref
%val1104 = getelementptr float, float* %val1103, i64 1
%val1105 = load float, float* %val1104
; set pointer
%val1106 = getelementptr float, float* %val1102, i64 6
store float %val1105, float* %val1106
%val1107 = load float*, float** %orientation_matrixPtr
; set pointer
%val1108 = getelementptr float, float* %val1107, i64 7
store float 0x0, float* %val1108
%val1109 = load float*, float** %orientation_matrixPtr
%val1110 = load float*, float** %vxPtr
; pointer ref
%val1111 = getelementptr float, float* %val1110, i64 2
%val1112 = load float, float* %val1111
; set pointer
%val1113 = getelementptr float, float* %val1109, i64 8
store float %val1112, float* %val1113
%val1114 = load float*, float** %orientation_matrixPtr
%val1115 = load float*, float** %vyPtr
; pointer ref
%val1116 = getelementptr float, float* %val1115, i64 2
%val1117 = load float, float* %val1116
; set pointer
%val1118 = getelementptr float, float* %val1114, i64 9
store float %val1117, float* %val1118
%val1119 = load float*, float** %orientation_matrixPtr
%val1120 = load float*, float** %vzPtr
; pointer ref
%val1121 = getelementptr float, float* %val1120, i64 2
%val1122 = load float, float* %val1121
; set pointer
%val1123 = getelementptr float, float* %val1119, i64 10
store float %val1122, float* %val1123
%val1124 = load float*, float** %orientation_matrixPtr
; set pointer
%val1125 = getelementptr float, float* %val1124, i64 11
store float 0x0, float* %val1125
%val1126 = load float*, float** %orientation_matrixPtr
; set pointer
%val1127 = getelementptr float, float* %val1126, i64 12
store float 0x0, float* %val1127
%val1128 = load float*, float** %orientation_matrixPtr
; set pointer
%val1129 = getelementptr float, float* %val1128, i64 13
store float 0x0, float* %val1129
%val1130 = load float*, float** %orientation_matrixPtr
; set pointer
%val1131 = getelementptr float, float* %val1130, i64 14
store float 0x0, float* %val1131
%val1132 = load float*, float** %orientation_matrixPtr
; set pointer
%val1133 = getelementptr float, float* %val1132, i64 15
store float 0x3ff0000000000000, float* %val1133
%val1134 = load float*, float** %translation_matrixPtr
; set pointer
%val1135 = getelementptr float, float* %val1134, i64 0
store float 0x3ff0000000000000, float* %val1135
%val1136 = load float*, float** %translation_matrixPtr
; set pointer
%val1137 = getelementptr float, float* %val1136, i64 1
store float 0x0, float* %val1137
%val1138 = load float*, float** %translation_matrixPtr
; set pointer
%val1139 = getelementptr float, float* %val1138, i64 2
store float 0x0, float* %val1139
%val1140 = load float*, float** %translation_matrixPtr
; set pointer
%val1141 = getelementptr float, float* %val1140, i64 3
store float 0x0, float* %val1141
%val1142 = load float*, float** %translation_matrixPtr
; set pointer
%val1143 = getelementptr float, float* %val1142, i64 4
store float 0x0, float* %val1143
%val1144 = load float*, float** %translation_matrixPtr
; set pointer
%val1145 = getelementptr float, float* %val1144, i64 5
store float 0x3ff0000000000000, float* %val1145
%val1146 = load float*, float** %translation_matrixPtr
; set pointer
%val1147 = getelementptr float, float* %val1146, i64 6
store float 0x0, float* %val1147
%val1148 = load float*, float** %translation_matrixPtr
; set pointer
%val1149 = getelementptr float, float* %val1148, i64 7
store float 0x0, float* %val1149
%val1150 = load float*, float** %translation_matrixPtr
; set pointer
%val1151 = getelementptr float, float* %val1150, i64 8
store float 0x0, float* %val1151
%val1152 = load float*, float** %translation_matrixPtr
; set pointer
%val1153 = getelementptr float, float* %val1152, i64 9
store float 0x0, float* %val1153
%val1154 = load float*, float** %translation_matrixPtr
; set pointer
%val1155 = getelementptr float, float* %val1154, i64 10
store float 0x3ff0000000000000, float* %val1155
%val1156 = load float*, float** %translation_matrixPtr
; set pointer
%val1157 = getelementptr float, float* %val1156, i64 11
store float 0x0, float* %val1157
%val1158 = load float*, float** %translation_matrixPtr
%val1159 = load float*, float** %vEyePtr
; pointer ref
%val1160 = getelementptr float, float* %val1159, i64 0
%val1161 = load float, float* %val1160
%val1162 = fmul float 0xbff0000000000000, %val1161
; set pointer
%val1163 = getelementptr float, float* %val1158, i64 12
store float %val1162, float* %val1163
%val1164 = load float*, float** %translation_matrixPtr
%val1165 = load float*, float** %vEyePtr
; pointer ref
%val1166 = getelementptr float, float* %val1165, i64 1
%val1167 = load float, float* %val1166
%val1168 = fmul float 0xbff0000000000000, %val1167
; set pointer
%val1169 = getelementptr float, float* %val1164, i64 13
store float %val1168, float* %val1169
%val1170 = load float*, float** %translation_matrixPtr
%val1171 = load float*, float** %vEyePtr
; pointer ref
%val1172 = getelementptr float, float* %val1171, i64 2
%val1173 = load float, float* %val1172
%val1174 = fmul float 0xbff0000000000000, %val1173
; set pointer
%val1175 = getelementptr float, float* %val1170, i64 14
store float %val1174, float* %val1175
%val1176 = load float*, float** %translation_matrixPtr
; set pointer
%val1177 = getelementptr float, float* %val1176, i64 15
store float 0x3ff0000000000000, float* %val1177
%val1178 = load float*, float** %translation_matrixPtr
%val1179 = load float*, float** %orientation_matrixPtr
%val1180 = load float*, float** %matrixPtr
%res1181 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val1178, float* %val1179, float* %val1180)
ret void
}
@gsxtmgraphics-pipeline41 = hidden constant [123 x i8] c"fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** @fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1240 = load i8*, i8** %_impzPtr
%zone1241 = bitcast i8* %tzone1240 to %mzone*

; let assign value to symbol fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%dat_fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone1241, i64 8)
%fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = bitcast i8* %dat_fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ to {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***
%tzone1012 = load i8*, i8** %_impzPtr
%zone1013 = bitcast i8* %tzone1012 to %mzone*

; let assign value to symbol orientation_matrix
%dat_orientation_matrix = call i8* @llvm_zone_malloc(%mzone* %zone1013, i64 8)
%orientation_matrixPtr = bitcast i8* %dat_orientation_matrix to float**
%tzone1020 = load i8*, i8** %_impzPtr
%zone1021 = bitcast i8* %tzone1020 to %mzone*

; let assign value to symbol translation_matrix
%dat_translation_matrix = call i8* @llvm_zone_malloc(%mzone* %zone1021, i64 8)
%translation_matrixPtr = bitcast i8* %dat_translation_matrix to float**
%tzone1028 = load i8*, i8** %_impzPtr
%zone1029 = bitcast i8* %tzone1028 to %mzone*

; let assign value to symbol vz
%dat_vz = call i8* @llvm_zone_malloc(%mzone* %zone1029, i64 8)
%vzPtr = bitcast i8* %dat_vz to float**
%tzone1036 = load i8*, i8** %_impzPtr
%zone1037 = bitcast i8* %tzone1036 to %mzone*

; let assign value to symbol vy
%dat_vy = call i8* @llvm_zone_malloc(%mzone* %zone1037, i64 8)
%vyPtr = bitcast i8* %dat_vy to float**
%tzone1044 = load i8*, i8** %_impzPtr
%zone1045 = bitcast i8* %tzone1044 to %mzone*

; let assign value to symbol vx
%dat_vx = call i8* @llvm_zone_malloc(%mzone* %zone1045, i64 8)
%vxPtr = bitcast i8* %dat_vx to float**
%tzone1052 = load i8*, i8** %_impzPtr
%zone1053 = bitcast i8* %tzone1052 to %mzone*

; let assign value to symbol vtmp
%dat_vtmp = call i8* @llvm_zone_malloc(%mzone* %zone1053, i64 8)
%vtmpPtr = bitcast i8* %dat_vtmp to float**
%val1006 = getelementptr i64, i64* null, i32 1
%zonesize1007 = mul i64 4, 16
%tzone1008 = load i8*, i8** %_impzPtr
%zone1009 = bitcast i8* %tzone1008 to %mzone*
%dat1010 = call i8* @llvm_zone_malloc(%mzone* %zone1009, i64 %zonesize1007)
call i8* @memset(i8* %dat1010, i32 0, i64 %zonesize1007)
%val1011 = bitcast i8* %dat1010 to float*

; let value assignment
%orientation_matrix = select i1 true, float* %val1011, float* %val1011
store float* %orientation_matrix, float** %orientation_matrixPtr

%val1014 = getelementptr i64, i64* null, i32 1
%zonesize1015 = mul i64 4, 16
%tzone1016 = load i8*, i8** %_impzPtr
%zone1017 = bitcast i8* %tzone1016 to %mzone*
%dat1018 = call i8* @llvm_zone_malloc(%mzone* %zone1017, i64 %zonesize1015)
call i8* @memset(i8* %dat1018, i32 0, i64 %zonesize1015)
%val1019 = bitcast i8* %dat1018 to float*

; let value assignment
%translation_matrix = select i1 true, float* %val1019, float* %val1019
store float* %translation_matrix, float** %translation_matrixPtr

%val1022 = getelementptr i64, i64* null, i32 1
%zonesize1023 = mul i64 4, 3
%tzone1024 = load i8*, i8** %_impzPtr
%zone1025 = bitcast i8* %tzone1024 to %mzone*
%dat1026 = call i8* @llvm_zone_malloc(%mzone* %zone1025, i64 %zonesize1023)
call i8* @memset(i8* %dat1026, i32 0, i64 %zonesize1023)
%val1027 = bitcast i8* %dat1026 to float*

; let value assignment
%vz = select i1 true, float* %val1027, float* %val1027
store float* %vz, float** %vzPtr

%val1030 = getelementptr i64, i64* null, i32 1
%zonesize1031 = mul i64 4, 3
%tzone1032 = load i8*, i8** %_impzPtr
%zone1033 = bitcast i8* %tzone1032 to %mzone*
%dat1034 = call i8* @llvm_zone_malloc(%mzone* %zone1033, i64 %zonesize1031)
call i8* @memset(i8* %dat1034, i32 0, i64 %zonesize1031)
%val1035 = bitcast i8* %dat1034 to float*

; let value assignment
%vy = select i1 true, float* %val1035, float* %val1035
store float* %vy, float** %vyPtr

%val1038 = getelementptr i64, i64* null, i32 1
%zonesize1039 = mul i64 4, 3
%tzone1040 = load i8*, i8** %_impzPtr
%zone1041 = bitcast i8* %tzone1040 to %mzone*
%dat1042 = call i8* @llvm_zone_malloc(%mzone* %zone1041, i64 %zonesize1039)
call i8* @memset(i8* %dat1042, i32 0, i64 %zonesize1039)
%val1043 = bitcast i8* %dat1042 to float*

; let value assignment
%vx = select i1 true, float* %val1043, float* %val1043
store float* %vx, float** %vxPtr

%val1046 = getelementptr i64, i64* null, i32 1
%zonesize1047 = mul i64 4, 3
%tzone1048 = load i8*, i8** %_impzPtr
%zone1049 = bitcast i8* %tzone1048 to %mzone*
%dat1050 = call i8* @llvm_zone_malloc(%mzone* %zone1049, i64 %zonesize1047)
call i8* @memset(i8* %dat1050, i32 0, i64 %zonesize1047)
%val1051 = bitcast i8* %dat1050 to float*

; let value assignment
%vtmp = select i1 true, float* %val1051, float* %val1051
store float* %vtmp, float** %vtmpPtr

%tzone1237 = load i8*, i8** %_impzPtr
%zone1238 = bitcast i8* %tzone1237 to %mzone*

; let assign value to symbol _anon_lambda_1
%dat__anon_lambda_1 = call i8* @llvm_zone_malloc(%mzone* %zone1238, i64 8)
%_anon_lambda_1Ptr = bitcast i8* %dat__anon_lambda_1 to { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***
%tzone1183 = load i8*, i8** %_impzPtr
%zone1184 = bitcast i8* %tzone1183 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1184)
; malloc closure structure
%clsptr1185 = call i8* @llvm_zone_malloc(%mzone* %zone1184, i64 24)
%closure1186 = bitcast i8* %clsptr1185 to { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*

; malloc environment structure
%envptr1187 = call i8* @llvm_zone_malloc(%mzone* %zone1184, i64 64)
%environment1188 = bitcast i8* %envptr1187 to {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}*

; malloc closure address table
%addytable1189 = call %clsvar* @new_address_table()
%var1190 = bitcast [70 x i8]* @gsxtmgraphics-pipeline31 to i8*
%var1191 = bitcast [63 x i8]* @gsxtmgraphics-pipeline32 to i8*
%addytable1192 = call %clsvar* @add_address_table(%mzone* %zone1184, i8* %var1190, i32 0, i8* %var1191, i32 3, %clsvar* %addytable1189)
%var1193 = bitcast [5 x i8]* @gsxtmgraphics-pipeline33 to i8*
%var1194 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable1195 = call %clsvar* @add_address_table(%mzone* %zone1184, i8* %var1193, i32 8, i8* %var1194, i32 3, %clsvar* %addytable1192)
%var1196 = bitcast [3 x i8]* @gsxtmgraphics-pipeline35 to i8*
%var1197 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable1198 = call %clsvar* @add_address_table(%mzone* %zone1184, i8* %var1196, i32 16, i8* %var1197, i32 3, %clsvar* %addytable1195)
%var1199 = bitcast [3 x i8]* @gsxtmgraphics-pipeline36 to i8*
%var1200 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable1201 = call %clsvar* @add_address_table(%mzone* %zone1184, i8* %var1199, i32 24, i8* %var1200, i32 3, %clsvar* %addytable1198)
%var1202 = bitcast [3 x i8]* @gsxtmgraphics-pipeline37 to i8*
%var1203 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable1204 = call %clsvar* @add_address_table(%mzone* %zone1184, i8* %var1202, i32 32, i8* %var1203, i32 3, %clsvar* %addytable1201)
%var1205 = bitcast [19 x i8]* @gsxtmgraphics-pipeline38 to i8*
%var1206 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable1207 = call %clsvar* @add_address_table(%mzone* %zone1184, i8* %var1205, i32 40, i8* %var1206, i32 3, %clsvar* %addytable1204)
%var1208 = bitcast [19 x i8]* @gsxtmgraphics-pipeline39 to i8*
%var1209 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable1210 = call %clsvar* @add_address_table(%mzone* %zone1184, i8* %var1208, i32 48, i8* %var1209, i32 3, %clsvar* %addytable1207)
%var1211 = bitcast [15 x i8]* @gsxtmgraphics-pipeline40 to i8*
%var1212 = bitcast [63 x i8]* @gsxtmgraphics-pipeline32 to i8*
%addytable1213 = call %clsvar* @add_address_table(%mzone* %zone1184, i8* %var1211, i32 56, i8* %var1212, i32 3, %clsvar* %addytable1210)
%address-table1214 = bitcast %clsvar* %addytable1213 to i8*

; insert table, function and environment into closure struct
%closure.table1231 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure1186, i32 0, i32 0
store i8* %address-table1214, i8** %closure.table1231
%closure.env1232 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure1186, i32 0, i32 1
store i8* %envptr1187, i8** %closure.env1232
%closure.func1233 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure1186, i32 0, i32 2
store void (i8*, i8*, float*, float*, float*, float*)* @fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ__1005, void (i8*, i8*, float*, float*, float*, float*)** %closure.func1233
%closure_size1234 = call i64 @llvm_zone_mark_size(%mzone* %zone1184)
call void @llvm_zone_ptr_set_size(i8* %clsptr1185, i64 %closure_size1234)
%wrapper_ptr1235 = call i8* @llvm_zone_malloc(%mzone* %zone1184, i64 8)
%closure_wrapper1236 = bitcast i8* %wrapper_ptr1235 to { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure1186, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %closure_wrapper1236

; let value assignment
%_anon_lambda_1 = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %closure_wrapper1236, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %closure_wrapper1236
store { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %_anon_lambda_1, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*** %_anon_lambda_1Ptr

; add data to environment
; don't need to alloc for env var fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%tmp_envptr1216 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %environment1188, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*** %fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**** %tmp_envptr1216

; don't need to alloc for env var vtmp
%tmp_envptr1218 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %environment1188, i32 0, i32 1
store float** %vtmpPtr, float*** %tmp_envptr1218

; don't need to alloc for env var vx
%tmp_envptr1220 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %environment1188, i32 0, i32 2
store float** %vxPtr, float*** %tmp_envptr1220

; don't need to alloc for env var vy
%tmp_envptr1222 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %environment1188, i32 0, i32 3
store float** %vyPtr, float*** %tmp_envptr1222

; don't need to alloc for env var vz
%tmp_envptr1224 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %environment1188, i32 0, i32 4
store float** %vzPtr, float*** %tmp_envptr1224

; don't need to alloc for env var translation_matrix
%tmp_envptr1226 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %environment1188, i32 0, i32 5
store float** %translation_matrixPtr, float*** %tmp_envptr1226

; don't need to alloc for env var orientation_matrix
%tmp_envptr1228 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %environment1188, i32 0, i32 6
store float** %orientation_matrixPtr, float*** %tmp_envptr1228

; don't need to alloc for env var _anon_lambda_1
%tmp_envptr1230 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %environment1188, i32 0, i32 7
store {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*** %_anon_lambda_1Ptr, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**** %tmp_envptr1230


%val1239 = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*** %_anon_lambda_1Ptr

; let value assignment
%fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ = select i1 true, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %val1239, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %val1239
store {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*** %fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr

%val1242 = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*** %fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr
ret {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %val1242
}


@fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** @fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ(float* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
ret void
}


define dllexport ccc void @fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_native(float* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
ret void
}


define dllexport ccc i8*  @fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1243 = bitcast [123 x i8]* @gsxtmgraphics-pipeline41 to i8*
call i32 (i8*, ...) @printf(i8* %var1243)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1244 = bitcast [123 x i8]* @gsxtmgraphics-pipeline41 to i8*
call i32 (i8*, ...) @printf(i8* %var1244)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1245 = bitcast [123 x i8]* @gsxtmgraphics-pipeline41 to i8*
call i32 (i8*, ...) @printf(i8* %var1245)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var1246 = bitcast [123 x i8]* @gsxtmgraphics-pipeline41 to i8*
call i32 (i8*, ...) @printf(i8* %var1246)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, float*, float*}*
%arg_p_0 = getelementptr {float*, float*, float*, float*}, {float*, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, float*, float*}, {float*, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, float*, float*}, {float*, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {float*, float*, float*, float*}, {float*, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline42 = hidden constant [74 x i8] c"fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ\00"
@gsxtmgraphics-pipeline43 = hidden constant [15 x i8] c"_anon_lambda_2\00"
define dllexport fastcc void @fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ__1247(i8* %_impz,i8* %_impenv, float* %matrix, float* %vEye, float* %vDir, float* %vUp) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1296 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}*
%fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**** %fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_
%vtmpPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 1
%vtmpPtr = load float**, float*** %vtmpPtr_
%vxPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 2
%vxPtr = load float**, float*** %vxPtr_
%vyPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 3
%vyPtr = load float**, float*** %vyPtr_
%vzPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 4
%vzPtr = load float**, float*** %vzPtr_
%translation_matrixPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 5
%translation_matrixPtr = load float**, float*** %translation_matrixPtr_
%orientation_matrixPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 6
%orientation_matrixPtr = load float**, float*** %orientation_matrixPtr_
%_anon_lambda_2Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 7
%_anon_lambda_2Ptr = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**** %_anon_lambda_2Ptr_

; setup arguments
%matrixPtr = alloca float*
store float* %matrix, float** %matrixPtr
%vEyePtr = alloca float*
store float* %vEye, float** %vEyePtr
%vDirPtr = alloca float*
store float* %vDir, float** %vDirPtr
%vUpPtr = alloca float*
store float* %vUp, float** %vUpPtr


%tzone1297 = load i8*, i8** %_impzPtr
%zone1298 = bitcast i8* %tzone1297 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

%val1299 = load float*, float** %vDirPtr
%val1300 = load float*, float** %vzPtr
call fastcc void @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd(float* %val1299, i64 3, float* %val1300)
%val1302 = load float*, float** %vUpPtr
%val1303 = load float*, float** %vtmpPtr
call fastcc void @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd(float* %val1302, i64 3, float* %val1303)
%val1305 = load float*, float** %vtmpPtr
%val1306 = load float*, float** %vzPtr
%val1307 = load float*, float** %vyPtr
call fastcc void @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd(float* %val1305, float* %val1306, float* %val1307)
%val1309 = load float*, float** %vyPtr
%val1310 = load float*, float** %vxPtr
call fastcc void @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd(float* %val1309, i64 3, float* %val1310)
%val1312 = load float*, float** %vzPtr
%val1313 = load float*, float** %vxPtr
%val1314 = load float*, float** %vyPtr
call fastcc void @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd(float* %val1312, float* %val1313, float* %val1314)
%val1316 = load float*, float** %orientation_matrixPtr
%val1317 = load float*, float** %vxPtr
; pointer ref
%val1318 = getelementptr float, float* %val1317, i64 0
%val1319 = load float, float* %val1318
; set pointer
%val1320 = getelementptr float, float* %val1316, i64 0
store float %val1319, float* %val1320
%val1321 = load float*, float** %orientation_matrixPtr
%val1322 = load float*, float** %vyPtr
; pointer ref
%val1323 = getelementptr float, float* %val1322, i64 0
%val1324 = load float, float* %val1323
; set pointer
%val1325 = getelementptr float, float* %val1321, i64 1
store float %val1324, float* %val1325
%val1326 = load float*, float** %orientation_matrixPtr
%val1327 = load float*, float** %vzPtr
; pointer ref
%val1328 = getelementptr float, float* %val1327, i64 0
%val1329 = load float, float* %val1328
; set pointer
%val1330 = getelementptr float, float* %val1326, i64 2
store float %val1329, float* %val1330
%val1331 = load float*, float** %orientation_matrixPtr
; set pointer
%val1332 = getelementptr float, float* %val1331, i64 3
store float 0x0, float* %val1332
%val1333 = load float*, float** %orientation_matrixPtr
%val1334 = load float*, float** %vxPtr
; pointer ref
%val1335 = getelementptr float, float* %val1334, i64 1
%val1336 = load float, float* %val1335
; set pointer
%val1337 = getelementptr float, float* %val1333, i64 4
store float %val1336, float* %val1337
%val1338 = load float*, float** %orientation_matrixPtr
%val1339 = load float*, float** %vyPtr
; pointer ref
%val1340 = getelementptr float, float* %val1339, i64 1
%val1341 = load float, float* %val1340
; set pointer
%val1342 = getelementptr float, float* %val1338, i64 5
store float %val1341, float* %val1342
%val1343 = load float*, float** %orientation_matrixPtr
%val1344 = load float*, float** %vzPtr
; pointer ref
%val1345 = getelementptr float, float* %val1344, i64 1
%val1346 = load float, float* %val1345
; set pointer
%val1347 = getelementptr float, float* %val1343, i64 6
store float %val1346, float* %val1347
%val1348 = load float*, float** %orientation_matrixPtr
; set pointer
%val1349 = getelementptr float, float* %val1348, i64 7
store float 0x0, float* %val1349
%val1350 = load float*, float** %orientation_matrixPtr
%val1351 = load float*, float** %vxPtr
; pointer ref
%val1352 = getelementptr float, float* %val1351, i64 2
%val1353 = load float, float* %val1352
; set pointer
%val1354 = getelementptr float, float* %val1350, i64 8
store float %val1353, float* %val1354
%val1355 = load float*, float** %orientation_matrixPtr
%val1356 = load float*, float** %vyPtr
; pointer ref
%val1357 = getelementptr float, float* %val1356, i64 2
%val1358 = load float, float* %val1357
; set pointer
%val1359 = getelementptr float, float* %val1355, i64 9
store float %val1358, float* %val1359
%val1360 = load float*, float** %orientation_matrixPtr
%val1361 = load float*, float** %vzPtr
; pointer ref
%val1362 = getelementptr float, float* %val1361, i64 2
%val1363 = load float, float* %val1362
; set pointer
%val1364 = getelementptr float, float* %val1360, i64 10
store float %val1363, float* %val1364
%val1365 = load float*, float** %orientation_matrixPtr
; set pointer
%val1366 = getelementptr float, float* %val1365, i64 11
store float 0x0, float* %val1366
%val1367 = load float*, float** %orientation_matrixPtr
; set pointer
%val1368 = getelementptr float, float* %val1367, i64 12
store float 0x0, float* %val1368
%val1369 = load float*, float** %orientation_matrixPtr
; set pointer
%val1370 = getelementptr float, float* %val1369, i64 13
store float 0x0, float* %val1370
%val1371 = load float*, float** %orientation_matrixPtr
; set pointer
%val1372 = getelementptr float, float* %val1371, i64 14
store float 0x0, float* %val1372
%val1373 = load float*, float** %orientation_matrixPtr
; set pointer
%val1374 = getelementptr float, float* %val1373, i64 15
store float 0x3ff0000000000000, float* %val1374
%val1375 = load float*, float** %translation_matrixPtr
; set pointer
%val1376 = getelementptr float, float* %val1375, i64 0
store float 0x3ff0000000000000, float* %val1376
%val1377 = load float*, float** %translation_matrixPtr
; set pointer
%val1378 = getelementptr float, float* %val1377, i64 1
store float 0x0, float* %val1378
%val1379 = load float*, float** %translation_matrixPtr
; set pointer
%val1380 = getelementptr float, float* %val1379, i64 2
store float 0x0, float* %val1380
%val1381 = load float*, float** %translation_matrixPtr
; set pointer
%val1382 = getelementptr float, float* %val1381, i64 3
store float 0x0, float* %val1382
%val1383 = load float*, float** %translation_matrixPtr
; set pointer
%val1384 = getelementptr float, float* %val1383, i64 4
store float 0x0, float* %val1384
%val1385 = load float*, float** %translation_matrixPtr
; set pointer
%val1386 = getelementptr float, float* %val1385, i64 5
store float 0x3ff0000000000000, float* %val1386
%val1387 = load float*, float** %translation_matrixPtr
; set pointer
%val1388 = getelementptr float, float* %val1387, i64 6
store float 0x0, float* %val1388
%val1389 = load float*, float** %translation_matrixPtr
; set pointer
%val1390 = getelementptr float, float* %val1389, i64 7
store float 0x0, float* %val1390
%val1391 = load float*, float** %translation_matrixPtr
; set pointer
%val1392 = getelementptr float, float* %val1391, i64 8
store float 0x0, float* %val1392
%val1393 = load float*, float** %translation_matrixPtr
; set pointer
%val1394 = getelementptr float, float* %val1393, i64 9
store float 0x0, float* %val1394
%val1395 = load float*, float** %translation_matrixPtr
; set pointer
%val1396 = getelementptr float, float* %val1395, i64 10
store float 0x3ff0000000000000, float* %val1396
%val1397 = load float*, float** %translation_matrixPtr
; set pointer
%val1398 = getelementptr float, float* %val1397, i64 11
store float 0x0, float* %val1398
%val1399 = load float*, float** %translation_matrixPtr
%val1400 = load float*, float** %vEyePtr
; pointer ref
%val1401 = getelementptr float, float* %val1400, i64 0
%val1402 = load float, float* %val1401
%val1403 = fmul float 0xbff0000000000000, %val1402
; set pointer
%val1404 = getelementptr float, float* %val1399, i64 12
store float %val1403, float* %val1404
%val1405 = load float*, float** %translation_matrixPtr
%val1406 = load float*, float** %vEyePtr
; pointer ref
%val1407 = getelementptr float, float* %val1406, i64 1
%val1408 = load float, float* %val1407
%val1409 = fmul float 0xbff0000000000000, %val1408
; set pointer
%val1410 = getelementptr float, float* %val1405, i64 13
store float %val1409, float* %val1410
%val1411 = load float*, float** %translation_matrixPtr
%val1412 = load float*, float** %vEyePtr
; pointer ref
%val1413 = getelementptr float, float* %val1412, i64 2
%val1414 = load float, float* %val1413
%val1415 = fmul float 0xbff0000000000000, %val1414
; set pointer
%val1416 = getelementptr float, float* %val1411, i64 14
store float %val1415, float* %val1416
%val1417 = load float*, float** %translation_matrixPtr
; set pointer
%val1418 = getelementptr float, float* %val1417, i64 15
store float 0x3ff0000000000000, float* %val1418
%val1419 = load float*, float** %translation_matrixPtr
%val1420 = load float*, float** %orientation_matrixPtr
%val1421 = load float*, float** %matrixPtr
%res1422 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val1419, float* %val1420, float* %val1421)
ret void
}
@gsxtmgraphics-pipeline44 = hidden constant [127 x i8] c"fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** @fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1481 = load i8*, i8** %_impzPtr
%zone1482 = bitcast i8* %tzone1481 to %mzone*

; let assign value to symbol fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%dat_fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone1482, i64 8)
%fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = bitcast i8* %dat_fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ to {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***
%tzone1254 = load i8*, i8** %_impzPtr
%zone1255 = bitcast i8* %tzone1254 to %mzone*

; let assign value to symbol orientation_matrix
%dat_orientation_matrix = call i8* @llvm_zone_malloc(%mzone* %zone1255, i64 8)
%orientation_matrixPtr = bitcast i8* %dat_orientation_matrix to float**
%tzone1262 = load i8*, i8** %_impzPtr
%zone1263 = bitcast i8* %tzone1262 to %mzone*

; let assign value to symbol translation_matrix
%dat_translation_matrix = call i8* @llvm_zone_malloc(%mzone* %zone1263, i64 8)
%translation_matrixPtr = bitcast i8* %dat_translation_matrix to float**
%tzone1270 = load i8*, i8** %_impzPtr
%zone1271 = bitcast i8* %tzone1270 to %mzone*

; let assign value to symbol vz
%dat_vz = call i8* @llvm_zone_malloc(%mzone* %zone1271, i64 8)
%vzPtr = bitcast i8* %dat_vz to float**
%tzone1278 = load i8*, i8** %_impzPtr
%zone1279 = bitcast i8* %tzone1278 to %mzone*

; let assign value to symbol vy
%dat_vy = call i8* @llvm_zone_malloc(%mzone* %zone1279, i64 8)
%vyPtr = bitcast i8* %dat_vy to float**
%tzone1286 = load i8*, i8** %_impzPtr
%zone1287 = bitcast i8* %tzone1286 to %mzone*

; let assign value to symbol vx
%dat_vx = call i8* @llvm_zone_malloc(%mzone* %zone1287, i64 8)
%vxPtr = bitcast i8* %dat_vx to float**
%tzone1294 = load i8*, i8** %_impzPtr
%zone1295 = bitcast i8* %tzone1294 to %mzone*

; let assign value to symbol vtmp
%dat_vtmp = call i8* @llvm_zone_malloc(%mzone* %zone1295, i64 8)
%vtmpPtr = bitcast i8* %dat_vtmp to float**
%val1248 = getelementptr i64, i64* null, i32 1
%zonesize1249 = mul i64 4, 16
%tzone1250 = load i8*, i8** %_impzPtr
%zone1251 = bitcast i8* %tzone1250 to %mzone*
%dat1252 = call i8* @llvm_zone_malloc(%mzone* %zone1251, i64 %zonesize1249)
call i8* @memset(i8* %dat1252, i32 0, i64 %zonesize1249)
%val1253 = bitcast i8* %dat1252 to float*

; let value assignment
%orientation_matrix = select i1 true, float* %val1253, float* %val1253
store float* %orientation_matrix, float** %orientation_matrixPtr

%val1256 = getelementptr i64, i64* null, i32 1
%zonesize1257 = mul i64 4, 16
%tzone1258 = load i8*, i8** %_impzPtr
%zone1259 = bitcast i8* %tzone1258 to %mzone*
%dat1260 = call i8* @llvm_zone_malloc(%mzone* %zone1259, i64 %zonesize1257)
call i8* @memset(i8* %dat1260, i32 0, i64 %zonesize1257)
%val1261 = bitcast i8* %dat1260 to float*

; let value assignment
%translation_matrix = select i1 true, float* %val1261, float* %val1261
store float* %translation_matrix, float** %translation_matrixPtr

%val1264 = getelementptr i64, i64* null, i32 1
%zonesize1265 = mul i64 4, 3
%tzone1266 = load i8*, i8** %_impzPtr
%zone1267 = bitcast i8* %tzone1266 to %mzone*
%dat1268 = call i8* @llvm_zone_malloc(%mzone* %zone1267, i64 %zonesize1265)
call i8* @memset(i8* %dat1268, i32 0, i64 %zonesize1265)
%val1269 = bitcast i8* %dat1268 to float*

; let value assignment
%vz = select i1 true, float* %val1269, float* %val1269
store float* %vz, float** %vzPtr

%val1272 = getelementptr i64, i64* null, i32 1
%zonesize1273 = mul i64 4, 3
%tzone1274 = load i8*, i8** %_impzPtr
%zone1275 = bitcast i8* %tzone1274 to %mzone*
%dat1276 = call i8* @llvm_zone_malloc(%mzone* %zone1275, i64 %zonesize1273)
call i8* @memset(i8* %dat1276, i32 0, i64 %zonesize1273)
%val1277 = bitcast i8* %dat1276 to float*

; let value assignment
%vy = select i1 true, float* %val1277, float* %val1277
store float* %vy, float** %vyPtr

%val1280 = getelementptr i64, i64* null, i32 1
%zonesize1281 = mul i64 4, 3
%tzone1282 = load i8*, i8** %_impzPtr
%zone1283 = bitcast i8* %tzone1282 to %mzone*
%dat1284 = call i8* @llvm_zone_malloc(%mzone* %zone1283, i64 %zonesize1281)
call i8* @memset(i8* %dat1284, i32 0, i64 %zonesize1281)
%val1285 = bitcast i8* %dat1284 to float*

; let value assignment
%vx = select i1 true, float* %val1285, float* %val1285
store float* %vx, float** %vxPtr

%val1288 = getelementptr i64, i64* null, i32 1
%zonesize1289 = mul i64 4, 3
%tzone1290 = load i8*, i8** %_impzPtr
%zone1291 = bitcast i8* %tzone1290 to %mzone*
%dat1292 = call i8* @llvm_zone_malloc(%mzone* %zone1291, i64 %zonesize1289)
call i8* @memset(i8* %dat1292, i32 0, i64 %zonesize1289)
%val1293 = bitcast i8* %dat1292 to float*

; let value assignment
%vtmp = select i1 true, float* %val1293, float* %val1293
store float* %vtmp, float** %vtmpPtr

%tzone1478 = load i8*, i8** %_impzPtr
%zone1479 = bitcast i8* %tzone1478 to %mzone*

; let assign value to symbol _anon_lambda_2
%dat__anon_lambda_2 = call i8* @llvm_zone_malloc(%mzone* %zone1479, i64 8)
%_anon_lambda_2Ptr = bitcast i8* %dat__anon_lambda_2 to { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***
%tzone1424 = load i8*, i8** %_impzPtr
%zone1425 = bitcast i8* %tzone1424 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1425)
; malloc closure structure
%clsptr1426 = call i8* @llvm_zone_malloc(%mzone* %zone1425, i64 24)
%closure1427 = bitcast i8* %clsptr1426 to { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*

; malloc environment structure
%envptr1428 = call i8* @llvm_zone_malloc(%mzone* %zone1425, i64 64)
%environment1429 = bitcast i8* %envptr1428 to {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}*

; malloc closure address table
%addytable1430 = call %clsvar* @new_address_table()
%var1431 = bitcast [74 x i8]* @gsxtmgraphics-pipeline42 to i8*
%var1432 = bitcast [63 x i8]* @gsxtmgraphics-pipeline32 to i8*
%addytable1433 = call %clsvar* @add_address_table(%mzone* %zone1425, i8* %var1431, i32 0, i8* %var1432, i32 3, %clsvar* %addytable1430)
%var1434 = bitcast [5 x i8]* @gsxtmgraphics-pipeline33 to i8*
%var1435 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable1436 = call %clsvar* @add_address_table(%mzone* %zone1425, i8* %var1434, i32 8, i8* %var1435, i32 3, %clsvar* %addytable1433)
%var1437 = bitcast [3 x i8]* @gsxtmgraphics-pipeline35 to i8*
%var1438 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable1439 = call %clsvar* @add_address_table(%mzone* %zone1425, i8* %var1437, i32 16, i8* %var1438, i32 3, %clsvar* %addytable1436)
%var1440 = bitcast [3 x i8]* @gsxtmgraphics-pipeline36 to i8*
%var1441 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable1442 = call %clsvar* @add_address_table(%mzone* %zone1425, i8* %var1440, i32 24, i8* %var1441, i32 3, %clsvar* %addytable1439)
%var1443 = bitcast [3 x i8]* @gsxtmgraphics-pipeline37 to i8*
%var1444 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable1445 = call %clsvar* @add_address_table(%mzone* %zone1425, i8* %var1443, i32 32, i8* %var1444, i32 3, %clsvar* %addytable1442)
%var1446 = bitcast [19 x i8]* @gsxtmgraphics-pipeline38 to i8*
%var1447 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable1448 = call %clsvar* @add_address_table(%mzone* %zone1425, i8* %var1446, i32 40, i8* %var1447, i32 3, %clsvar* %addytable1445)
%var1449 = bitcast [19 x i8]* @gsxtmgraphics-pipeline39 to i8*
%var1450 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable1451 = call %clsvar* @add_address_table(%mzone* %zone1425, i8* %var1449, i32 48, i8* %var1450, i32 3, %clsvar* %addytable1448)
%var1452 = bitcast [15 x i8]* @gsxtmgraphics-pipeline43 to i8*
%var1453 = bitcast [63 x i8]* @gsxtmgraphics-pipeline32 to i8*
%addytable1454 = call %clsvar* @add_address_table(%mzone* %zone1425, i8* %var1452, i32 56, i8* %var1453, i32 3, %clsvar* %addytable1451)
%address-table1455 = bitcast %clsvar* %addytable1454 to i8*

; insert table, function and environment into closure struct
%closure.table1472 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure1427, i32 0, i32 0
store i8* %address-table1455, i8** %closure.table1472
%closure.env1473 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure1427, i32 0, i32 1
store i8* %envptr1428, i8** %closure.env1473
%closure.func1474 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure1427, i32 0, i32 2
store void (i8*, i8*, float*, float*, float*, float*)* @fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ__1247, void (i8*, i8*, float*, float*, float*, float*)** %closure.func1474
%closure_size1475 = call i64 @llvm_zone_mark_size(%mzone* %zone1425)
call void @llvm_zone_ptr_set_size(i8* %clsptr1426, i64 %closure_size1475)
%wrapper_ptr1476 = call i8* @llvm_zone_malloc(%mzone* %zone1425, i64 8)
%closure_wrapper1477 = bitcast i8* %wrapper_ptr1476 to { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure1427, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %closure_wrapper1477

; let value assignment
%_anon_lambda_2 = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %closure_wrapper1477, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %closure_wrapper1477
store { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %_anon_lambda_2, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*** %_anon_lambda_2Ptr

; add data to environment
; don't need to alloc for env var fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%tmp_envptr1457 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %environment1429, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*** %fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**** %tmp_envptr1457

; don't need to alloc for env var vtmp
%tmp_envptr1459 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %environment1429, i32 0, i32 1
store float** %vtmpPtr, float*** %tmp_envptr1459

; don't need to alloc for env var vx
%tmp_envptr1461 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %environment1429, i32 0, i32 2
store float** %vxPtr, float*** %tmp_envptr1461

; don't need to alloc for env var vy
%tmp_envptr1463 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %environment1429, i32 0, i32 3
store float** %vyPtr, float*** %tmp_envptr1463

; don't need to alloc for env var vz
%tmp_envptr1465 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %environment1429, i32 0, i32 4
store float** %vzPtr, float*** %tmp_envptr1465

; don't need to alloc for env var translation_matrix
%tmp_envptr1467 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %environment1429, i32 0, i32 5
store float** %translation_matrixPtr, float*** %tmp_envptr1467

; don't need to alloc for env var orientation_matrix
%tmp_envptr1469 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %environment1429, i32 0, i32 6
store float** %orientation_matrixPtr, float*** %tmp_envptr1469

; don't need to alloc for env var _anon_lambda_2
%tmp_envptr1471 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}***}* %environment1429, i32 0, i32 7
store {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*** %_anon_lambda_2Ptr, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**** %tmp_envptr1471


%val1480 = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*** %_anon_lambda_2Ptr

; let value assignment
%fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ = select i1 true, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %val1480, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %val1480
store {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*** %fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr

%val1483 = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*** %fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr
ret {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %val1483
}


@fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** @fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ(float* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
ret void
}


define dllexport ccc void @fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_native(float* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
ret void
}


define dllexport ccc i8*  @fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1484 = bitcast [127 x i8]* @gsxtmgraphics-pipeline44 to i8*
call i32 (i8*, ...) @printf(i8* %var1484)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1485 = bitcast [127 x i8]* @gsxtmgraphics-pipeline44 to i8*
call i32 (i8*, ...) @printf(i8* %var1485)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1486 = bitcast [127 x i8]* @gsxtmgraphics-pipeline44 to i8*
call i32 (i8*, ...) @printf(i8* %var1486)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var1487 = bitcast [127 x i8]* @gsxtmgraphics-pipeline44 to i8*
call i32 (i8*, ...) @printf(i8* %var1487)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, float*, float*}*
%arg_p_0 = getelementptr {float*, float*, float*, float*}, {float*, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, float*, float*}, {float*, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, float*, float*}, {float*, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {float*, float*, float*, float*}, {float*, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @fill_view_matrix_dir_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%XTMVertexWeight = type {i32,float}
@gsxtmgraphics-pipeline45 = hidden constant [61 x i8] c"XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ\00"
@gsxtmgraphics-pipeline46 = hidden constant [56 x i8] c"{i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**\00"
define dllexport fastcc %XTMVertexWeight* @XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ__1488(i8* %_impz,i8* %_impenv, i32 %arg_0, float %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1489 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***}*
%XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***}, {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***}* %impenv, i32 0, i32 0
%XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQPtr = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**** %XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr


%tzone1494 = load i8*, i8** %_impzPtr
%zone1495 = bitcast i8* %tzone1494 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMVertexWeight*
%tzone1490 = load i8*, i8** %_impzPtr
%zone1491 = bitcast i8* %tzone1490 to %mzone*
%dat1492 = call i8* @llvm_zone_malloc(%mzone* %zone1491, i64 8)
call i8* @memset(i8* %dat1492, i32 0, i64 8)
%val1493 = bitcast i8* %dat1492 to %XTMVertexWeight*

; let value assignment
%obj = select i1 true, %XTMVertexWeight* %val1493, %XTMVertexWeight* %val1493
store %XTMVertexWeight* %obj, %XTMVertexWeight** %objPtr

%val1496 = load %XTMVertexWeight*, %XTMVertexWeight** %objPtr
%val1497 = load i32, i32* %arg_0Ptr
; set tuple
%val1498 = getelementptr %XTMVertexWeight, %XTMVertexWeight* %val1496, i64 0, i32 0
store i32 %val1497, i32* %val1498
%val1499 = load %XTMVertexWeight*, %XTMVertexWeight** %objPtr
%val1500 = load float, float* %arg_1Ptr
; set tuple
%val1501 = getelementptr %XTMVertexWeight, %XTMVertexWeight* %val1499, i64 0, i32 1
store float %val1500, float* %val1501
%val1502 = load %XTMVertexWeight*, %XTMVertexWeight** %objPtr
ret %XTMVertexWeight* %val1502
}
@gsxtmgraphics-pipeline47 = hidden constant [114 x i8] c"XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** @XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1522 = load i8*, i8** %_impzPtr
%zone1523 = bitcast i8* %tzone1522 to %mzone*

; let assign value to symbol XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ
%dat_XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone1523, i64 8)
%XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQPtr = bitcast i8* %dat_XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ to { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***
%tzone1503 = load i8*, i8** %_impzPtr
%zone1504 = bitcast i8* %tzone1503 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1504)
; malloc closure structure
%clsptr1505 = call i8* @llvm_zone_malloc(%mzone* %zone1504, i64 24)
%closure1506 = bitcast i8* %clsptr1505 to { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*

; malloc environment structure
%envptr1507 = call i8* @llvm_zone_malloc(%mzone* %zone1504, i64 8)
%environment1508 = bitcast i8* %envptr1507 to {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***}*

; malloc closure address table
%addytable1509 = call %clsvar* @new_address_table()
%var1510 = bitcast [61 x i8]* @gsxtmgraphics-pipeline45 to i8*
%var1511 = bitcast [56 x i8]* @gsxtmgraphics-pipeline46 to i8*
%addytable1512 = call %clsvar* @add_address_table(%mzone* %zone1504, i8* %var1510, i32 0, i8* %var1511, i32 3, %clsvar* %addytable1509)
%address-table1513 = bitcast %clsvar* %addytable1512 to i8*

; insert table, function and environment into closure struct
%closure.table1516 = getelementptr { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure1506, i32 0, i32 0
store i8* %address-table1513, i8** %closure.table1516
%closure.env1517 = getelementptr { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure1506, i32 0, i32 1
store i8* %envptr1507, i8** %closure.env1517
%closure.func1518 = getelementptr { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure1506, i32 0, i32 2
store %XTMVertexWeight* (i8*, i8*, i32, float)* @XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ__1488, %XTMVertexWeight* (i8*, i8*, i32, float)** %closure.func1518
%closure_size1519 = call i64 @llvm_zone_mark_size(%mzone* %zone1504)
call void @llvm_zone_ptr_set_size(i8* %clsptr1505, i64 %closure_size1519)
%wrapper_ptr1520 = call i8* @llvm_zone_malloc(%mzone* %zone1504, i64 8)
%closure_wrapper1521 = bitcast i8* %wrapper_ptr1520 to { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**
store { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure1506, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure_wrapper1521

; let value assignment
%XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ = select i1 true, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure_wrapper1521, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure_wrapper1521
store { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*** %XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ
%tmp_envptr1515 = getelementptr {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***}, {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***}* %environment1508, i32 0, i32 0
store {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*** %XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQPtr, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**** %tmp_envptr1515


%val1524 = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*** %XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQPtr
ret {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %val1524
}


@XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** @XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMVertexWeight* @XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ(i32 %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight* (i8*, i8*, i32, float)*,  %XTMVertexWeight* (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight* %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
ret %XTMVertexWeight* %result
}


define dllexport ccc %XTMVertexWeight* @XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_native(i32 %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight* (i8*, i8*, i32, float)*,  %XTMVertexWeight* (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight* %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
ret %XTMVertexWeight* %result
}


define dllexport ccc i8*  @XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1525 = bitcast [114 x i8]* @gsxtmgraphics-pipeline47 to i8*
call i32 (i8*, ...) @printf(i8* %var1525)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1526 = bitcast [114 x i8]* @gsxtmgraphics-pipeline47 to i8*
call i32 (i8*, ...) @printf(i8* %var1526)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight* (i8*, i8*, i32, float)*,  %XTMVertexWeight* (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight* %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
%tmpres = bitcast %XTMVertexWeight* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, float}*
%arg_p_0 = getelementptr {i32, float}, {i32, float}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, float}, {i32, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight* (i8*, i8*, i32, float)*,  %XTMVertexWeight* (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight* %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline48 = hidden constant [63 x i8] c"XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ\00"
define dllexport fastcc %XTMVertexWeight* @XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ__1527(i8* %_impz,i8* %_impenv, i32 %arg_0, float %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1528 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***}*
%XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***}, {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***}* %impenv, i32 0, i32 0
%XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQPtr = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**** %XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr


%tzone1533 = load i8*, i8** %_impzPtr
%zone1534 = bitcast i8* %tzone1533 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMVertexWeight*
%tzone1529 = load i8*, i8** %_impzPtr
%zone1530 = bitcast i8* %tzone1529 to %mzone*
%dat1531 = call i8* @llvm_zone_malloc(%mzone* %zone1530, i64 8)
call i8* @memset(i8* %dat1531, i32 0, i64 8)
%val1532 = bitcast i8* %dat1531 to %XTMVertexWeight*

; let value assignment
%obj = select i1 true, %XTMVertexWeight* %val1532, %XTMVertexWeight* %val1532
store %XTMVertexWeight* %obj, %XTMVertexWeight** %objPtr

%val1535 = load %XTMVertexWeight*, %XTMVertexWeight** %objPtr
%val1536 = load i32, i32* %arg_0Ptr
; set tuple
%val1537 = getelementptr %XTMVertexWeight, %XTMVertexWeight* %val1535, i64 0, i32 0
store i32 %val1536, i32* %val1537
%val1538 = load %XTMVertexWeight*, %XTMVertexWeight** %objPtr
%val1539 = load float, float* %arg_1Ptr
; set tuple
%val1540 = getelementptr %XTMVertexWeight, %XTMVertexWeight* %val1538, i64 0, i32 1
store float %val1539, float* %val1540
%val1541 = load %XTMVertexWeight*, %XTMVertexWeight** %objPtr
ret %XTMVertexWeight* %val1541
}
@gsxtmgraphics-pipeline49 = hidden constant [116 x i8] c"XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** @XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1561 = load i8*, i8** %_impzPtr
%zone1562 = bitcast i8* %tzone1561 to %mzone*

; let assign value to symbol XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ
%dat_XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone1562, i64 8)
%XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQPtr = bitcast i8* %dat_XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ to { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***
%tzone1542 = load i8*, i8** %_impzPtr
%zone1543 = bitcast i8* %tzone1542 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1543)
; malloc closure structure
%clsptr1544 = call i8* @llvm_zone_malloc(%mzone* %zone1543, i64 24)
%closure1545 = bitcast i8* %clsptr1544 to { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*

; malloc environment structure
%envptr1546 = call i8* @llvm_zone_malloc(%mzone* %zone1543, i64 8)
%environment1547 = bitcast i8* %envptr1546 to {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***}*

; malloc closure address table
%addytable1548 = call %clsvar* @new_address_table()
%var1549 = bitcast [63 x i8]* @gsxtmgraphics-pipeline48 to i8*
%var1550 = bitcast [56 x i8]* @gsxtmgraphics-pipeline46 to i8*
%addytable1551 = call %clsvar* @add_address_table(%mzone* %zone1543, i8* %var1549, i32 0, i8* %var1550, i32 3, %clsvar* %addytable1548)
%address-table1552 = bitcast %clsvar* %addytable1551 to i8*

; insert table, function and environment into closure struct
%closure.table1555 = getelementptr { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure1545, i32 0, i32 0
store i8* %address-table1552, i8** %closure.table1555
%closure.env1556 = getelementptr { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure1545, i32 0, i32 1
store i8* %envptr1546, i8** %closure.env1556
%closure.func1557 = getelementptr { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure1545, i32 0, i32 2
store %XTMVertexWeight* (i8*, i8*, i32, float)* @XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ__1527, %XTMVertexWeight* (i8*, i8*, i32, float)** %closure.func1557
%closure_size1558 = call i64 @llvm_zone_mark_size(%mzone* %zone1543)
call void @llvm_zone_ptr_set_size(i8* %clsptr1544, i64 %closure_size1558)
%wrapper_ptr1559 = call i8* @llvm_zone_malloc(%mzone* %zone1543, i64 8)
%closure_wrapper1560 = bitcast i8* %wrapper_ptr1559 to { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**
store { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure1545, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure_wrapper1560

; let value assignment
%XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ = select i1 true, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure_wrapper1560, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure_wrapper1560
store { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*** %XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ
%tmp_envptr1554 = getelementptr {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***}, {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***}* %environment1547, i32 0, i32 0
store {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*** %XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQPtr, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**** %tmp_envptr1554


%val1563 = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*** %XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQPtr
ret {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %val1563
}


@XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** @XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMVertexWeight* @XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ(i32 %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight* (i8*, i8*, i32, float)*,  %XTMVertexWeight* (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight* %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
ret %XTMVertexWeight* %result
}


define dllexport ccc %XTMVertexWeight* @XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_native(i32 %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight* (i8*, i8*, i32, float)*,  %XTMVertexWeight* (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight* %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
ret %XTMVertexWeight* %result
}


define dllexport ccc i8*  @XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1564 = bitcast [116 x i8]* @gsxtmgraphics-pipeline49 to i8*
call i32 (i8*, ...) @printf(i8* %var1564)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1565 = bitcast [116 x i8]* @gsxtmgraphics-pipeline49 to i8*
call i32 (i8*, ...) @printf(i8* %var1565)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight* (i8*, i8*, i32, float)*,  %XTMVertexWeight* (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight* %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
%tmpres = bitcast %XTMVertexWeight* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, float}*
%arg_p_0 = getelementptr {i32, float}, {i32, float}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, float}, {i32, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_z_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight* (i8*, i8*, i32, float)*,  %XTMVertexWeight* (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight* %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline50 = hidden constant [63 x i8] c"XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ\00"
define dllexport fastcc %XTMVertexWeight* @XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ__1566(i8* %_impz,i8* %_impenv, i32 %arg_0, float %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1567 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***}*
%XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***}, {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***}* %impenv, i32 0, i32 0
%XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQPtr = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**** %XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr


%tzone1570 = load i8*, i8** %_impzPtr
%zone1571 = bitcast i8* %tzone1570 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMVertexWeight*
%dat1568 = call i8* @malloc(i64 8)
call i8* @memset(i8* %dat1568, i32 0, i64 8)
%val1569 = bitcast i8* %dat1568 to %XTMVertexWeight*

; let value assignment
%obj = select i1 true, %XTMVertexWeight* %val1569, %XTMVertexWeight* %val1569
store %XTMVertexWeight* %obj, %XTMVertexWeight** %objPtr

%val1572 = load %XTMVertexWeight*, %XTMVertexWeight** %objPtr
%val1573 = load i32, i32* %arg_0Ptr
; set tuple
%val1574 = getelementptr %XTMVertexWeight, %XTMVertexWeight* %val1572, i64 0, i32 0
store i32 %val1573, i32* %val1574
%val1575 = load %XTMVertexWeight*, %XTMVertexWeight** %objPtr
%val1576 = load float, float* %arg_1Ptr
; set tuple
%val1577 = getelementptr %XTMVertexWeight, %XTMVertexWeight* %val1575, i64 0, i32 1
store float %val1576, float* %val1577
%val1578 = load %XTMVertexWeight*, %XTMVertexWeight** %objPtr
ret %XTMVertexWeight* %val1578
}
@gsxtmgraphics-pipeline51 = hidden constant [116 x i8] c"XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** @XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1598 = load i8*, i8** %_impzPtr
%zone1599 = bitcast i8* %tzone1598 to %mzone*

; let assign value to symbol XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ
%dat_XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone1599, i64 8)
%XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQPtr = bitcast i8* %dat_XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ to { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***
%tzone1579 = load i8*, i8** %_impzPtr
%zone1580 = bitcast i8* %tzone1579 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1580)
; malloc closure structure
%clsptr1581 = call i8* @llvm_zone_malloc(%mzone* %zone1580, i64 24)
%closure1582 = bitcast i8* %clsptr1581 to { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*

; malloc environment structure
%envptr1583 = call i8* @llvm_zone_malloc(%mzone* %zone1580, i64 8)
%environment1584 = bitcast i8* %envptr1583 to {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***}*

; malloc closure address table
%addytable1585 = call %clsvar* @new_address_table()
%var1586 = bitcast [63 x i8]* @gsxtmgraphics-pipeline50 to i8*
%var1587 = bitcast [56 x i8]* @gsxtmgraphics-pipeline46 to i8*
%addytable1588 = call %clsvar* @add_address_table(%mzone* %zone1580, i8* %var1586, i32 0, i8* %var1587, i32 3, %clsvar* %addytable1585)
%address-table1589 = bitcast %clsvar* %addytable1588 to i8*

; insert table, function and environment into closure struct
%closure.table1592 = getelementptr { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure1582, i32 0, i32 0
store i8* %address-table1589, i8** %closure.table1592
%closure.env1593 = getelementptr { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure1582, i32 0, i32 1
store i8* %envptr1583, i8** %closure.env1593
%closure.func1594 = getelementptr { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure1582, i32 0, i32 2
store %XTMVertexWeight* (i8*, i8*, i32, float)* @XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ__1566, %XTMVertexWeight* (i8*, i8*, i32, float)** %closure.func1594
%closure_size1595 = call i64 @llvm_zone_mark_size(%mzone* %zone1580)
call void @llvm_zone_ptr_set_size(i8* %clsptr1581, i64 %closure_size1595)
%wrapper_ptr1596 = call i8* @llvm_zone_malloc(%mzone* %zone1580, i64 8)
%closure_wrapper1597 = bitcast i8* %wrapper_ptr1596 to { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**
store { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure1582, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure_wrapper1597

; let value assignment
%XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ = select i1 true, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure_wrapper1597, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure_wrapper1597
store { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*** %XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ
%tmp_envptr1591 = getelementptr {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***}, {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}***}* %environment1584, i32 0, i32 0
store {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*** %XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQPtr, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**** %tmp_envptr1591


%val1600 = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*** %XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQPtr
ret {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %val1600
}


@XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** @XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMVertexWeight* @XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ(i32 %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight* (i8*, i8*, i32, float)*,  %XTMVertexWeight* (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight* %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
ret %XTMVertexWeight* %result
}


define dllexport ccc %XTMVertexWeight* @XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_native(i32 %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight* (i8*, i8*, i32, float)*,  %XTMVertexWeight* (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight* %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
ret %XTMVertexWeight* %result
}


define dllexport ccc i8*  @XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1601 = bitcast [116 x i8]* @gsxtmgraphics-pipeline51 to i8*
call i32 (i8*, ...) @printf(i8* %var1601)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1602 = bitcast [116 x i8]* @gsxtmgraphics-pipeline51 to i8*
call i32 (i8*, ...) @printf(i8* %var1602)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight* (i8*, i8*, i32, float)*,  %XTMVertexWeight* (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight* %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
%tmpres = bitcast %XTMVertexWeight* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, float}*
%arg_p_0 = getelementptr {i32, float}, {i32, float}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, float}, {i32, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_h_adhoc_W1hUTVZlcnRleFdlaWdodCosaTMyLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}*, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight* (i8*, i8*, i32, float)*,  %XTMVertexWeight* (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight* %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline52 = hidden constant [3 x i8] c"%s\00"
@gsxtmgraphics-pipeline53 = hidden constant [23 x i8] c"<XTMVertexWeight:null>\00"
@gsxtmgraphics-pipeline54 = hidden constant [18 x i8] c"<XTMVertexWeight:\00"
@gsxtmgraphics-pipeline55 = hidden constant [2 x i8] c",\00"
@gsxtmgraphics-pipeline56 = hidden constant [2 x i8] c">\00"
@gsxtmgraphics-pipeline57 = hidden constant [51 x i8] c"toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0\00"
@gsxtmgraphics-pipeline58 = hidden constant [54 x i8] c"{i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0__1603(i8* %_impz,i8* %_impenv, %XTMVertexWeight* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1604 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}***}*
%toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}***, {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}**** %toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0Ptr_

; setup arguments
%xPtr = alloca %XTMVertexWeight*
store %XTMVertexWeight* %x, %XTMVertexWeight** %xPtr


%val1606 = load %XTMVertexWeight*, %XTMVertexWeight** %xPtr
%val1607 = icmp eq %XTMVertexWeight* %val1606, null
br i1 %val1607, label %then1605, label %else1605

then1605:
%zone1608 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone1608)
%zone_ptr1609 = bitcast %mzone* %zone1608 to i8*
store i8* %zone_ptr1609, i8** %_impzPtr
%tzone1619 = load i8*, i8** %_impzPtr
%zone1620 = bitcast i8* %tzone1619 to %mzone*

; let assign value to symbol res0
%res0Ptr = alloca %String*
%tzone1624 = load i8*, i8** %_impzPtr
%zone1625 = bitcast i8* %tzone1624 to %mzone*

; let assign value to symbol zone0
%zone0Ptr = alloca %mzone*
%tzone1627 = load i8*, i8** %_impzPtr
%zone1628 = bitcast i8* %tzone1627 to %mzone*

; let assign value to symbol newz0
%newz0Ptr = alloca %mzone*
%tzone1611 = load i8*, i8** %_impzPtr
%zone1612 = bitcast i8* %tzone1611 to %mzone*

; let assign value to symbol xx_t_mst
%xx_t_mstPtr = alloca i8*
%dat1610 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst = select i1 true, i8* %dat1610, i8* %dat1610
store i8* %xx_t_mst, i8** %xx_t_mstPtr

%val1613 = load i8*, i8** %xx_t_mstPtr
%var1614 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var1615 = bitcast [23 x i8]* @gsxtmgraphics-pipeline53 to i8*

%val1616 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1613, i8* %var1614, i8* %var1615)
%val1617 = load i8*, i8** %xx_t_mstPtr
%res1618 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1617)

; let value assignment
%res0 = select i1 true, %String* %res1618, %String* %res1618
store %String* %res0, %String** %res0Ptr

%oldzone1621 = call %mzone* @llvm_pop_zone_stack()
%newzone1622 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr1623 = bitcast %mzone* %newzone1622 to i8*
store i8* %zone_ptr1623, i8** %_impzPtr

; let value assignment
%zone0 = select i1 true, %mzone* %oldzone1621, %mzone* %oldzone1621
store %mzone* %zone0, %mzone** %zone0Ptr

%res1626 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz0 = select i1 true, %mzone* %res1626, %mzone* %res1626
store %mzone* %newz0, %mzone** %newz0Ptr

%tzone1633 = load i8*, i8** %_impzPtr
%zone1634 = bitcast i8* %tzone1633 to %mzone*

; let assign value to symbol rescopy0
%rescopy0Ptr = alloca %String*
%tzone1639 = load i8*, i8** %_impzPtr
%zone1640 = bitcast i8* %tzone1639 to %mzone*

; let assign value to symbol hook
%hookPtr = alloca {i64,i8*,i8*}*
%tzone1642 = load i8*, i8** %_impzPtr
%zone1643 = bitcast i8* %tzone1642 to %mzone*

; let assign value to symbol f
%fPtr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val1629 = load %String*, %String** %res0Ptr
%val1630 = load %mzone*, %mzone** %zone0Ptr
%val1631 = load %mzone*, %mzone** %newz0Ptr
%res1632 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val1629, %mzone* %val1630, %mzone* %val1631)

; let value assignment
%rescopy0 = select i1 true, %String* %res1632, %String* %res1632
store %String* %rescopy0, %String** %rescopy0Ptr

%val1635 = load %mzone*, %mzone** %zone0Ptr
; tuple ref
%val1636 = getelementptr %mzone, %mzone* %val1635, i64 0, i32 4
%val1637 = load i8*, i8** %val1636
%val1638 = bitcast i8* %val1637 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val1638, {i64,i8*,i8*}* %val1638
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%null1641 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null1641, {i8*, i8*, void (i8*, i8*)*}** %null1641
store {i8*, i8*, void (i8*, i8*)*}** %f, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; promote local stack var allocations
%tzone1679 = load i8*, i8** %_impzPtr
%zone1680 = bitcast i8* %tzone1679 to %mzone*
%ifptr1669 = alloca i1
%ifptr1645 = alloca i1
; while loop
%val1646 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val1647 = icmp eq {i64,i8*,i8*}* %val1646, null
br i1 %val1647, label %then1645, label %else1645

then1645:
%res1648 = call ccc i1 @impc_false()
store i1 %res1648, i1* %ifptr1645
br label %ifcont1645

else1645:
%res1649 = call ccc i1 @impc_true()
store i1 %res1649, i1* %ifptr1645
br label %ifcont1645

ifcont1645:
%ifres1650 = load i1, i1* %ifptr1645

br i1 %ifres1650, label %loop1644, label %after1644

loop1644:
; do set!
%val1651 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val1652 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1651, i64 0, i32 1
%val1653 = load i8*, i8** %val1652
%val1654 = bitcast i8* %val1653 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val1654, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; apply closure 
%vval1655 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val1656 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval1655
%fPtr1657 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1656, i32 0, i32 2
%ePtr1658 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1656, i32 0, i32 1
%f1659 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr1657
%e1660 = load i8*, i8** %ePtr1658
%tzone1661 = load i8*, i8** %_impzPtr
%zone1662 = bitcast i8* %tzone1661 to %mzone*
%z1663 = bitcast %mzone* %zone1662 to i8*
tail call fastcc void %f1659(i8* %z1663, i8* %e1660)
; do set!
%val1665 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val1666 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1665, i64 0, i32 2
%val1667 = load i8*, i8** %val1666
%val1668 = bitcast i8* %val1667 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val1668, {i64,i8*,i8*}** %hookPtr
%val1670 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val1671 = icmp eq {i64,i8*,i8*}* %val1670, null
br i1 %val1671, label %then1669, label %else1669

then1669:
%res1672 = call ccc i1 @impc_false()
store i1 %res1672, i1* %ifptr1669
br label %ifcont1669

else1669:
%res1673 = call ccc i1 @impc_true()
store i1 %res1673, i1* %ifptr1669
br label %ifcont1669

ifcont1669:
%ifres1674 = load i1, i1* %ifptr1669

br i1 %ifres1674, label %loop1644, label %after1644

after1644:
%val1676 = load %mzone*, %mzone** %zone0Ptr
call ccc void @llvm_zone_destroy(%mzone* %val1676)
%val1678 = load %String*, %String** %rescopy0Ptr
ret %String* %val1678

else1605:
%zone1681 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone1681)
%zone_ptr1682 = bitcast %mzone* %zone1681 to i8*
store i8* %zone_ptr1682, i8** %_impzPtr
%tzone1722 = load i8*, i8** %_impzPtr
%zone1723 = bitcast i8* %tzone1722 to %mzone*

; let assign value to symbol res1
%res1Ptr = alloca %String*
%tzone1727 = load i8*, i8** %_impzPtr
%zone1728 = bitcast i8* %tzone1727 to %mzone*

; let assign value to symbol zone1
%zone1Ptr = alloca %mzone*
%tzone1730 = load i8*, i8** %_impzPtr
%zone1731 = bitcast i8* %tzone1730 to %mzone*

; let assign value to symbol newz1
%newz1Ptr = alloca %mzone*
%tzone1684 = load i8*, i8** %_impzPtr
%zone1685 = bitcast i8* %tzone1684 to %mzone*

; let assign value to symbol xx_t_mst_s_1
%xx_t_mst_s_1Ptr = alloca i8*
%dat1683 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_1 = select i1 true, i8* %dat1683, i8* %dat1683
store i8* %xx_t_mst_s_1, i8** %xx_t_mst_s_1Ptr

%val1686 = load i8*, i8** %xx_t_mst_s_1Ptr
%var1687 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var1688 = bitcast [18 x i8]* @gsxtmgraphics-pipeline54 to i8*

%val1689 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1686, i8* %var1687, i8* %var1688)
%val1690 = load i8*, i8** %xx_t_mst_s_1Ptr
%res1691 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1690)
%val1692 = load %XTMVertexWeight*, %XTMVertexWeight** %xPtr
; tuple ref
%val1693 = getelementptr %XTMVertexWeight, %XTMVertexWeight* %val1692, i64 0, i32 0
%val1694 = load i32, i32* %val1693
%res1695 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val1694)
%res1696 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1691, %String* %res1695)
%tzone1698 = load i8*, i8** %_impzPtr
%zone1699 = bitcast i8* %tzone1698 to %mzone*

; let assign value to symbol xx_t_mst_s_2
%xx_t_mst_s_2Ptr = alloca i8*
%dat1697 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_2 = select i1 true, i8* %dat1697, i8* %dat1697
store i8* %xx_t_mst_s_2, i8** %xx_t_mst_s_2Ptr

%val1700 = load i8*, i8** %xx_t_mst_s_2Ptr
%var1701 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var1702 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val1703 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1700, i8* %var1701, i8* %var1702)
%val1704 = load i8*, i8** %xx_t_mst_s_2Ptr
%res1705 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1704)
%res1706 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1696, %String* %res1705)
%val1707 = load %XTMVertexWeight*, %XTMVertexWeight** %xPtr
; tuple ref
%val1708 = getelementptr %XTMVertexWeight, %XTMVertexWeight* %val1707, i64 0, i32 1
%val1709 = load float, float* %val1708
%res1710 = call fastcc %String* @toString_adhoc_W1N0cmluZyosZmxvYXRd(float %val1709)
%res1711 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1706, %String* %res1710)
%tzone1713 = load i8*, i8** %_impzPtr
%zone1714 = bitcast i8* %tzone1713 to %mzone*

; let assign value to symbol xx_t_mst_s_3
%xx_t_mst_s_3Ptr = alloca i8*
%dat1712 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_3 = select i1 true, i8* %dat1712, i8* %dat1712
store i8* %xx_t_mst_s_3, i8** %xx_t_mst_s_3Ptr

%val1715 = load i8*, i8** %xx_t_mst_s_3Ptr
%var1716 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var1717 = bitcast [2 x i8]* @gsxtmgraphics-pipeline56 to i8*

%val1718 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1715, i8* %var1716, i8* %var1717)
%val1719 = load i8*, i8** %xx_t_mst_s_3Ptr
%res1720 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1719)
%res1721 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1711, %String* %res1720)

; let value assignment
%res1 = select i1 true, %String* %res1721, %String* %res1721
store %String* %res1, %String** %res1Ptr

%oldzone1724 = call %mzone* @llvm_pop_zone_stack()
%newzone1725 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr1726 = bitcast %mzone* %newzone1725 to i8*
store i8* %zone_ptr1726, i8** %_impzPtr

; let value assignment
%zone1 = select i1 true, %mzone* %oldzone1724, %mzone* %oldzone1724
store %mzone* %zone1, %mzone** %zone1Ptr

%res1729 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz1 = select i1 true, %mzone* %res1729, %mzone* %res1729
store %mzone* %newz1, %mzone** %newz1Ptr

%tzone1736 = load i8*, i8** %_impzPtr
%zone1737 = bitcast i8* %tzone1736 to %mzone*

; let assign value to symbol rescopy1
%rescopy1Ptr = alloca %String*
%tzone1742 = load i8*, i8** %_impzPtr
%zone1743 = bitcast i8* %tzone1742 to %mzone*

; let assign value to symbol hook_s_4
%hook_s_4Ptr = alloca {i64,i8*,i8*}*
%tzone1745 = load i8*, i8** %_impzPtr
%zone1746 = bitcast i8* %tzone1745 to %mzone*

; let assign value to symbol f_s_5
%f_s_5Ptr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val1732 = load %String*, %String** %res1Ptr
%val1733 = load %mzone*, %mzone** %zone1Ptr
%val1734 = load %mzone*, %mzone** %newz1Ptr
%res1735 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val1732, %mzone* %val1733, %mzone* %val1734)

; let value assignment
%rescopy1 = select i1 true, %String* %res1735, %String* %res1735
store %String* %rescopy1, %String** %rescopy1Ptr

%val1738 = load %mzone*, %mzone** %zone1Ptr
; tuple ref
%val1739 = getelementptr %mzone, %mzone* %val1738, i64 0, i32 4
%val1740 = load i8*, i8** %val1739
%val1741 = bitcast i8* %val1740 to {i64,i8*,i8*}*

; let value assignment
%hook_s_4 = select i1 true, {i64,i8*,i8*}* %val1741, {i64,i8*,i8*}* %val1741
store {i64,i8*,i8*}* %hook_s_4, {i64,i8*,i8*}** %hook_s_4Ptr

%null1744 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f_s_5 = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null1744, {i8*, i8*, void (i8*, i8*)*}** %null1744
store {i8*, i8*, void (i8*, i8*)*}** %f_s_5, {i8*, i8*, void (i8*, i8*)*}*** %f_s_5Ptr

; promote local stack var allocations
%tzone1782 = load i8*, i8** %_impzPtr
%zone1783 = bitcast i8* %tzone1782 to %mzone*
%ifptr1772 = alloca i1
%ifptr1748 = alloca i1
; while loop
%val1749 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_4Ptr
%val1750 = icmp eq {i64,i8*,i8*}* %val1749, null
br i1 %val1750, label %then1748, label %else1748

then1748:
%res1751 = call ccc i1 @impc_false()
store i1 %res1751, i1* %ifptr1748
br label %ifcont1748

else1748:
%res1752 = call ccc i1 @impc_true()
store i1 %res1752, i1* %ifptr1748
br label %ifcont1748

ifcont1748:
%ifres1753 = load i1, i1* %ifptr1748

br i1 %ifres1753, label %loop1747, label %after1747

loop1747:
; do set!
%val1754 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_4Ptr
; tuple ref
%val1755 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1754, i64 0, i32 1
%val1756 = load i8*, i8** %val1755
%val1757 = bitcast i8* %val1756 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val1757, {i8*, i8*, void (i8*, i8*)*}*** %f_s_5Ptr

; apply closure 
%vval1758 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %f_s_5Ptr
%val1759 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval1758
%fPtr1760 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1759, i32 0, i32 2
%ePtr1761 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1759, i32 0, i32 1
%f1762 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr1760
%e1763 = load i8*, i8** %ePtr1761
%tzone1764 = load i8*, i8** %_impzPtr
%zone1765 = bitcast i8* %tzone1764 to %mzone*
%z1766 = bitcast %mzone* %zone1765 to i8*
tail call fastcc void %f1762(i8* %z1766, i8* %e1763)
; do set!
%val1768 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_4Ptr
; tuple ref
%val1769 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1768, i64 0, i32 2
%val1770 = load i8*, i8** %val1769
%val1771 = bitcast i8* %val1770 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val1771, {i64,i8*,i8*}** %hook_s_4Ptr
%val1773 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_4Ptr
%val1774 = icmp eq {i64,i8*,i8*}* %val1773, null
br i1 %val1774, label %then1772, label %else1772

then1772:
%res1775 = call ccc i1 @impc_false()
store i1 %res1775, i1* %ifptr1772
br label %ifcont1772

else1772:
%res1776 = call ccc i1 @impc_true()
store i1 %res1776, i1* %ifptr1772
br label %ifcont1772

ifcont1772:
%ifres1777 = load i1, i1* %ifptr1772

br i1 %ifres1777, label %loop1747, label %after1747

after1747:
%val1779 = load %mzone*, %mzone** %zone1Ptr
call ccc void @llvm_zone_destroy(%mzone* %val1779)
%val1781 = load %String*, %String** %rescopy1Ptr
ret %String* %val1781
}
@gsxtmgraphics-pipeline59 = hidden constant [104 x i8] c"toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}** @toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1803 = load i8*, i8** %_impzPtr
%zone1804 = bitcast i8* %tzone1803 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0
%dat_toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone1804, i64 8)
%toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0Ptr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0 to { i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}***
%tzone1784 = load i8*, i8** %_impzPtr
%zone1785 = bitcast i8* %tzone1784 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1785)
; malloc closure structure
%clsptr1786 = call i8* @llvm_zone_malloc(%mzone* %zone1785, i64 24)
%closure1787 = bitcast i8* %clsptr1786 to { i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}*

; malloc environment structure
%envptr1788 = call i8* @llvm_zone_malloc(%mzone* %zone1785, i64 8)
%environment1789 = bitcast i8* %envptr1788 to {{i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}***}*

; malloc closure address table
%addytable1790 = call %clsvar* @new_address_table()
%var1791 = bitcast [51 x i8]* @gsxtmgraphics-pipeline57 to i8*
%var1792 = bitcast [54 x i8]* @gsxtmgraphics-pipeline58 to i8*
%addytable1793 = call %clsvar* @add_address_table(%mzone* %zone1785, i8* %var1791, i32 0, i8* %var1792, i32 3, %clsvar* %addytable1790)
%address-table1794 = bitcast %clsvar* %addytable1793 to i8*

; insert table, function and environment into closure struct
%closure.table1797 = getelementptr { i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}, { i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}* %closure1787, i32 0, i32 0
store i8* %address-table1794, i8** %closure.table1797
%closure.env1798 = getelementptr { i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}, { i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}* %closure1787, i32 0, i32 1
store i8* %envptr1788, i8** %closure.env1798
%closure.func1799 = getelementptr { i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}, { i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}* %closure1787, i32 0, i32 2
store %String* (i8*, i8*, %XTMVertexWeight*)* @toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0__1603, %String* (i8*, i8*, %XTMVertexWeight*)** %closure.func1799
%closure_size1800 = call i64 @llvm_zone_mark_size(%mzone* %zone1785)
call void @llvm_zone_ptr_set_size(i8* %clsptr1786, i64 %closure_size1800)
%wrapper_ptr1801 = call i8* @llvm_zone_malloc(%mzone* %zone1785, i64 8)
%closure_wrapper1802 = bitcast i8* %wrapper_ptr1801 to { i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}**
store { i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}* %closure1787, { i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}** %closure_wrapper1802

; let value assignment
%toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}** %closure_wrapper1802, { i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}** %closure_wrapper1802
store { i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}** %toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0, { i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}*** %toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0Ptr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0
%tmp_envptr1796 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}***}* %environment1789, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}*** %toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0Ptr, {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}**** %tmp_envptr1796


%val1805 = load {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}**, {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}*** %toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}** %val1805
}


@toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}** @toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0(%XTMVertexWeight* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}*, {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %XTMVertexWeight*)*,  %String* (i8*, i8*, %XTMVertexWeight*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %XTMVertexWeight* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0_native(%XTMVertexWeight* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}*, {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %XTMVertexWeight*)*,  %String* (i8*, i8*, %XTMVertexWeight*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %XTMVertexWeight* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1806 = bitcast [104 x i8]* @gsxtmgraphics-pipeline59 to i8*
call i32 (i8*, ...) @printf(i8* %var1806)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMVertexWeight*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}*, {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %XTMVertexWeight*)*,  %String* (i8*, i8*, %XTMVertexWeight*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %XTMVertexWeight* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMVertexWeight*}*
%arg_p_0 = getelementptr {%XTMVertexWeight*}, {%XTMVertexWeight*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMVertexWeight*, %XTMVertexWeight** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosWFRNVmVydGV4V2VpZ2h0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}*, {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %XTMVertexWeight*)*,  %String* (i8*, i8*, %XTMVertexWeight*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %XTMVertexWeight* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline60 = hidden constant [44 x i8] c"print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0\00"
@gsxtmgraphics-pipeline61 = hidden constant [50 x i8] c"{i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0__1807(i8* %_impz,i8* %_impenv, %XTMVertexWeight* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1808 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}***}*
%print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0Ptr = load {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}***, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}**** %print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0Ptr_

; setup arguments
%xPtr = alloca %XTMVertexWeight*
store %XTMVertexWeight* %x, %XTMVertexWeight** %xPtr


%val1810 = load %XTMVertexWeight*, %XTMVertexWeight** %xPtr
%val1811 = icmp eq %XTMVertexWeight* %val1810, null
br i1 %val1811, label %then1809, label %else1809

then1809:
%var1812 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var1813 = bitcast [23 x i8]* @gsxtmgraphics-pipeline53 to i8*

%val1814 = call i32 (i8*, ...) @printf(i8* %var1812, i8* %var1813)
br label %ifcont1809

else1809:
%var1816 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var1817 = bitcast [18 x i8]* @gsxtmgraphics-pipeline54 to i8*

%val1818 = call i32 (i8*, ...) @printf(i8* %var1816, i8* %var1817)
%val1819 = load %XTMVertexWeight*, %XTMVertexWeight** %xPtr
; tuple ref
%val1820 = getelementptr %XTMVertexWeight, %XTMVertexWeight* %val1819, i64 0, i32 0
%val1821 = load i32, i32* %val1820
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val1821)
%var1823 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var1824 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val1825 = call i32 (i8*, ...) @printf(i8* %var1823, i8* %var1824)
%val1826 = load %XTMVertexWeight*, %XTMVertexWeight** %xPtr
; tuple ref
%val1827 = getelementptr %XTMVertexWeight, %XTMVertexWeight* %val1826, i64 0, i32 1
%val1828 = load float, float* %val1827
call fastcc void @print_adhoc_W3ZvaWQsZmxvYXRd(float %val1828)
%var1830 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var1831 = bitcast [2 x i8]* @gsxtmgraphics-pipeline56 to i8*

%val1832 = call i32 (i8*, ...) @printf(i8* %var1830, i8* %var1831)
br label %ifcont1809

ifcont1809:
ret void
}
@gsxtmgraphics-pipeline62 = hidden constant [97 x i8] c"print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** @print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1854 = load i8*, i8** %_impzPtr
%zone1855 = bitcast i8* %tzone1854 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0
%dat_print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone1855, i64 8)
%print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0Ptr = bitcast i8* %dat_print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0 to { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}***
%tzone1835 = load i8*, i8** %_impzPtr
%zone1836 = bitcast i8* %tzone1835 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1836)
; malloc closure structure
%clsptr1837 = call i8* @llvm_zone_malloc(%mzone* %zone1836, i64 24)
%closure1838 = bitcast i8* %clsptr1837 to { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}*

; malloc environment structure
%envptr1839 = call i8* @llvm_zone_malloc(%mzone* %zone1836, i64 8)
%environment1840 = bitcast i8* %envptr1839 to {{i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}***}*

; malloc closure address table
%addytable1841 = call %clsvar* @new_address_table()
%var1842 = bitcast [44 x i8]* @gsxtmgraphics-pipeline60 to i8*
%var1843 = bitcast [50 x i8]* @gsxtmgraphics-pipeline61 to i8*
%addytable1844 = call %clsvar* @add_address_table(%mzone* %zone1836, i8* %var1842, i32 0, i8* %var1843, i32 3, %clsvar* %addytable1841)
%address-table1845 = bitcast %clsvar* %addytable1844 to i8*

; insert table, function and environment into closure struct
%closure.table1848 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure1838, i32 0, i32 0
store i8* %address-table1845, i8** %closure.table1848
%closure.env1849 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure1838, i32 0, i32 1
store i8* %envptr1839, i8** %closure.env1849
%closure.func1850 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure1838, i32 0, i32 2
store void (i8*, i8*, %XTMVertexWeight*)* @print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0__1807, void (i8*, i8*, %XTMVertexWeight*)** %closure.func1850
%closure_size1851 = call i64 @llvm_zone_mark_size(%mzone* %zone1836)
call void @llvm_zone_ptr_set_size(i8* %clsptr1837, i64 %closure_size1851)
%wrapper_ptr1852 = call i8* @llvm_zone_malloc(%mzone* %zone1836, i64 8)
%closure_wrapper1853 = bitcast i8* %wrapper_ptr1852 to { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}**
store { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure1838, { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** %closure_wrapper1853

; let value assignment
%print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** %closure_wrapper1853, { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** %closure_wrapper1853
store { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** %print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0, { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}*** %print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0Ptr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0
%tmp_envptr1847 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}***}* %environment1840, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}*** %print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0Ptr, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}**** %tmp_envptr1847


%val1856 = load {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}**, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}*** %print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** %val1856
}


@print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** @print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0(%XTMVertexWeight* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}*, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMVertexWeight*)*,  void (i8*, i8*, %XTMVertexWeight*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMVertexWeight* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_native(%XTMVertexWeight* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}*, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMVertexWeight*)*,  void (i8*, i8*, %XTMVertexWeight*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMVertexWeight* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1857 = bitcast [97 x i8]* @gsxtmgraphics-pipeline62 to i8*
call i32 (i8*, ...) @printf(i8* %var1857)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMVertexWeight*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}*, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMVertexWeight*)*,  void (i8*, i8*, %XTMVertexWeight*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMVertexWeight* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMVertexWeight*}*
%arg_p_0 = getelementptr {%XTMVertexWeight*}, {%XTMVertexWeight*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMVertexWeight*, %XTMVertexWeight** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}*, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMVertexWeight*)*,  void (i8*, i8*, %XTMVertexWeight*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMVertexWeight* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline63 = hidden constant [63 x i8] c"XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd\00"
@gsxtmgraphics-pipeline64 = hidden constant [55 x i8] c"{i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}**\00"
define dllexport fastcc %XTMVertexWeight @XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd__1858(i8* %_impz,i8* %_impenv, i32 %arg_0, float %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1859 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}***}*
%XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}***}, {{i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}***}* %impenv, i32 0, i32 0
%XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRdPtr = load {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}***, {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}**** %XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca float
store float %arg_1, float* %arg_1Ptr


%tzone1861 = load i8*, i8** %_impzPtr
%zone1862 = bitcast i8* %tzone1861 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMVertexWeight*
%dat1860 = alloca %XTMVertexWeight, align 16

; let value assignment
%obj = select i1 true, %XTMVertexWeight* %dat1860, %XTMVertexWeight* %dat1860
store %XTMVertexWeight* %obj, %XTMVertexWeight** %objPtr

%val1863 = load %XTMVertexWeight*, %XTMVertexWeight** %objPtr
%val1864 = load i32, i32* %arg_0Ptr
; set tuple
%val1865 = getelementptr %XTMVertexWeight, %XTMVertexWeight* %val1863, i64 0, i32 0
store i32 %val1864, i32* %val1865
%val1866 = load %XTMVertexWeight*, %XTMVertexWeight** %objPtr
%val1867 = load float, float* %arg_1Ptr
; set tuple
%val1868 = getelementptr %XTMVertexWeight, %XTMVertexWeight* %val1866, i64 0, i32 1
store float %val1867, float* %val1868
%val1869 = load %XTMVertexWeight*, %XTMVertexWeight** %objPtr
; pointer ref
%val1870 = getelementptr %XTMVertexWeight, %XTMVertexWeight* %val1869, i64 0
%val1871 = load %XTMVertexWeight, %XTMVertexWeight* %val1870
ret %XTMVertexWeight %val1871
}
@gsxtmgraphics-pipeline65 = hidden constant [116 x i8] c"XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}** @XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1891 = load i8*, i8** %_impzPtr
%zone1892 = bitcast i8* %tzone1891 to %mzone*

; let assign value to symbol XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd
%dat_XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone1892, i64 8)
%XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRdPtr = bitcast i8* %dat_XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd to { i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}***
%tzone1872 = load i8*, i8** %_impzPtr
%zone1873 = bitcast i8* %tzone1872 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1873)
; malloc closure structure
%clsptr1874 = call i8* @llvm_zone_malloc(%mzone* %zone1873, i64 24)
%closure1875 = bitcast i8* %clsptr1874 to { i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}*

; malloc environment structure
%envptr1876 = call i8* @llvm_zone_malloc(%mzone* %zone1873, i64 8)
%environment1877 = bitcast i8* %envptr1876 to {{i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}***}*

; malloc closure address table
%addytable1878 = call %clsvar* @new_address_table()
%var1879 = bitcast [63 x i8]* @gsxtmgraphics-pipeline63 to i8*
%var1880 = bitcast [55 x i8]* @gsxtmgraphics-pipeline64 to i8*
%addytable1881 = call %clsvar* @add_address_table(%mzone* %zone1873, i8* %var1879, i32 0, i8* %var1880, i32 3, %clsvar* %addytable1878)
%address-table1882 = bitcast %clsvar* %addytable1881 to i8*

; insert table, function and environment into closure struct
%closure.table1885 = getelementptr { i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}, { i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}* %closure1875, i32 0, i32 0
store i8* %address-table1882, i8** %closure.table1885
%closure.env1886 = getelementptr { i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}, { i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}* %closure1875, i32 0, i32 1
store i8* %envptr1876, i8** %closure.env1886
%closure.func1887 = getelementptr { i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}, { i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}* %closure1875, i32 0, i32 2
store %XTMVertexWeight (i8*, i8*, i32, float)* @XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd__1858, %XTMVertexWeight (i8*, i8*, i32, float)** %closure.func1887
%closure_size1888 = call i64 @llvm_zone_mark_size(%mzone* %zone1873)
call void @llvm_zone_ptr_set_size(i8* %clsptr1874, i64 %closure_size1888)
%wrapper_ptr1889 = call i8* @llvm_zone_malloc(%mzone* %zone1873, i64 8)
%closure_wrapper1890 = bitcast i8* %wrapper_ptr1889 to { i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}**
store { i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}* %closure1875, { i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}** %closure_wrapper1890

; let value assignment
%XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd = select i1 true, { i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}** %closure_wrapper1890, { i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}** %closure_wrapper1890
store { i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}** %XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd, { i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}*** %XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd
%tmp_envptr1884 = getelementptr {{i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}***}, {{i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}***}* %environment1877, i32 0, i32 0
store {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}*** %XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRdPtr, {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}**** %tmp_envptr1884


%val1893 = load {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}**, {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}*** %XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRdPtr
ret {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}** %val1893
}


@XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}** @XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMVertexWeight @XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd(i32 %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}*, {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight (i8*, i8*, i32, float)*,  %XTMVertexWeight (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
ret %XTMVertexWeight %result
}


define dllexport ccc %XTMVertexWeight @XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd_native(i32 %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}*, {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight (i8*, i8*, i32, float)*,  %XTMVertexWeight (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
ret %XTMVertexWeight %result
}


define dllexport ccc void @XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, float}*
%arg_p_0 = getelementptr {i32, float}, {i32, float}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, float}, {i32, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMVertexWeight_val_adhoc_W1hUTVZlcnRleFdlaWdodCxpMzIsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}*, {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}, {i8*, i8*, %XTMVertexWeight (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight (i8*, i8*, i32, float)*,  %XTMVertexWeight (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline66 = hidden constant [60 x i8] c"hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0\00"
@gsxtmgraphics-pipeline67 = hidden constant [63 x i8] c"{i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}**\00"
define dllexport fastcc %XTMVertexWeight* @hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0__1896(i8* %_impz,i8* %_impenv, %XTMVertexWeight* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1897 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}***}*
%hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0Ptr_ = getelementptr {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}***}, {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0Ptr = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}***, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}**** %hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0Ptr_

; setup arguments
%xPtr = alloca %XTMVertexWeight*
store %XTMVertexWeight* %x, %XTMVertexWeight** %xPtr


%tzone1900 = load i8*, i8** %_impzPtr
%zone1901 = bitcast i8* %tzone1900 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMVertexWeight*
%dat1898 = call i8* @malloc(i64 8)
call i8* @memset(i8* %dat1898, i32 0, i64 8)
%val1899 = bitcast i8* %dat1898 to %XTMVertexWeight*

; let value assignment
%obj = select i1 true, %XTMVertexWeight* %val1899, %XTMVertexWeight* %val1899
store %XTMVertexWeight* %obj, %XTMVertexWeight** %objPtr

%val1902 = load %XTMVertexWeight*, %XTMVertexWeight** %objPtr
%val1903 = load %XTMVertexWeight*, %XTMVertexWeight** %xPtr
; tuple ref
%val1904 = getelementptr %XTMVertexWeight, %XTMVertexWeight* %val1903, i64 0, i32 0
%val1905 = load i32, i32* %val1904
; set tuple
%val1906 = getelementptr %XTMVertexWeight, %XTMVertexWeight* %val1902, i64 0, i32 0
store i32 %val1905, i32* %val1906
%val1907 = load %XTMVertexWeight*, %XTMVertexWeight** %objPtr
%val1908 = load %XTMVertexWeight*, %XTMVertexWeight** %xPtr
; tuple ref
%val1909 = getelementptr %XTMVertexWeight, %XTMVertexWeight* %val1908, i64 0, i32 1
%val1910 = load float, float* %val1909
; set tuple
%val1911 = getelementptr %XTMVertexWeight, %XTMVertexWeight* %val1907, i64 0, i32 1
store float %val1910, float* %val1911
%val1912 = load %XTMVertexWeight*, %XTMVertexWeight** %objPtr
ret %XTMVertexWeight* %val1912
}
@gsxtmgraphics-pipeline68 = hidden constant [113 x i8] c"hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}** @hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1932 = load i8*, i8** %_impzPtr
%zone1933 = bitcast i8* %tzone1932 to %mzone*

; let assign value to symbol hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0
%dat_hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone1933, i64 8)
%hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0Ptr = bitcast i8* %dat_hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0 to { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}***
%tzone1913 = load i8*, i8** %_impzPtr
%zone1914 = bitcast i8* %tzone1913 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1914)
; malloc closure structure
%clsptr1915 = call i8* @llvm_zone_malloc(%mzone* %zone1914, i64 24)
%closure1916 = bitcast i8* %clsptr1915 to { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}*

; malloc environment structure
%envptr1917 = call i8* @llvm_zone_malloc(%mzone* %zone1914, i64 8)
%environment1918 = bitcast i8* %envptr1917 to {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}***}*

; malloc closure address table
%addytable1919 = call %clsvar* @new_address_table()
%var1920 = bitcast [60 x i8]* @gsxtmgraphics-pipeline66 to i8*
%var1921 = bitcast [63 x i8]* @gsxtmgraphics-pipeline67 to i8*
%addytable1922 = call %clsvar* @add_address_table(%mzone* %zone1914, i8* %var1920, i32 0, i8* %var1921, i32 3, %clsvar* %addytable1919)
%address-table1923 = bitcast %clsvar* %addytable1922 to i8*

; insert table, function and environment into closure struct
%closure.table1926 = getelementptr { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}* %closure1916, i32 0, i32 0
store i8* %address-table1923, i8** %closure.table1926
%closure.env1927 = getelementptr { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}* %closure1916, i32 0, i32 1
store i8* %envptr1917, i8** %closure.env1927
%closure.func1928 = getelementptr { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}* %closure1916, i32 0, i32 2
store %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)* @hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0__1896, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)** %closure.func1928
%closure_size1929 = call i64 @llvm_zone_mark_size(%mzone* %zone1914)
call void @llvm_zone_ptr_set_size(i8* %clsptr1915, i64 %closure_size1929)
%wrapper_ptr1930 = call i8* @llvm_zone_malloc(%mzone* %zone1914, i64 8)
%closure_wrapper1931 = bitcast i8* %wrapper_ptr1930 to { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}**
store { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}* %closure1916, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}** %closure_wrapper1931

; let value assignment
%hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0 = select i1 true, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}** %closure_wrapper1931, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}** %closure_wrapper1931
store { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}** %hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}*** %hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0Ptr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0
%tmp_envptr1925 = getelementptr {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}***}, {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}***}* %environment1918, i32 0, i32 0
store {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}*** %hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0Ptr, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}**** %tmp_envptr1925


%val1934 = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}**, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}*** %hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0Ptr
ret {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}** %val1934
}


@hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}** @hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMVertexWeight* @hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0(%XTMVertexWeight* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}**
%closure = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}*, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*,  %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight* %ff(i8* %_impz, i8* %ee, %XTMVertexWeight* %arg_0)
ret %XTMVertexWeight* %result
}


define dllexport ccc %XTMVertexWeight* @hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0_native(%XTMVertexWeight* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}**
%closure = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}*, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*,  %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight* %ff(i8* %_impz, i8* %ee, %XTMVertexWeight* %arg_0)
ret %XTMVertexWeight* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1935 = bitcast [113 x i8]* @gsxtmgraphics-pipeline68 to i8*
call i32 (i8*, ...) @printf(i8* %var1935)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMVertexWeight*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}**
%closure = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}*, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*,  %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight* %ff(i8* %_impz, i8* %ee, %XTMVertexWeight* %arg_0)
%tmpres = bitcast %XTMVertexWeight* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMVertexWeight*}*
%arg_p_0 = getelementptr {%XTMVertexWeight*}, {%XTMVertexWeight*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMVertexWeight*, %XTMVertexWeight** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}**
%closure = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}*, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)*,  %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight* %ff(i8* %_impz, i8* %ee, %XTMVertexWeight* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline69 = hidden constant [44 x i8] c"hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0__1936(i8* %_impz,i8* %_impenv, %XTMVertexWeight* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1937 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}***}*
%hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0Ptr = load {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}***, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}**** %hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0Ptr_

; setup arguments
%xPtr = alloca %XTMVertexWeight*
store %XTMVertexWeight* %x, %XTMVertexWeight** %xPtr


%val1938 = load %XTMVertexWeight*, %XTMVertexWeight** %xPtr
%val1939 = bitcast %XTMVertexWeight* %val1938 to i8*
call ccc void @free(i8* %val1939)
ret void
}
@gsxtmgraphics-pipeline70 = hidden constant [97 x i8] c"hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** @hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1961 = load i8*, i8** %_impzPtr
%zone1962 = bitcast i8* %tzone1961 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0
%dat_hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone1962, i64 8)
%hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0Ptr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0 to { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}***
%tzone1942 = load i8*, i8** %_impzPtr
%zone1943 = bitcast i8* %tzone1942 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1943)
; malloc closure structure
%clsptr1944 = call i8* @llvm_zone_malloc(%mzone* %zone1943, i64 24)
%closure1945 = bitcast i8* %clsptr1944 to { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}*

; malloc environment structure
%envptr1946 = call i8* @llvm_zone_malloc(%mzone* %zone1943, i64 8)
%environment1947 = bitcast i8* %envptr1946 to {{i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}***}*

; malloc closure address table
%addytable1948 = call %clsvar* @new_address_table()
%var1949 = bitcast [44 x i8]* @gsxtmgraphics-pipeline69 to i8*
%var1950 = bitcast [50 x i8]* @gsxtmgraphics-pipeline61 to i8*
%addytable1951 = call %clsvar* @add_address_table(%mzone* %zone1943, i8* %var1949, i32 0, i8* %var1950, i32 3, %clsvar* %addytable1948)
%address-table1952 = bitcast %clsvar* %addytable1951 to i8*

; insert table, function and environment into closure struct
%closure.table1955 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure1945, i32 0, i32 0
store i8* %address-table1952, i8** %closure.table1955
%closure.env1956 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure1945, i32 0, i32 1
store i8* %envptr1946, i8** %closure.env1956
%closure.func1957 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure1945, i32 0, i32 2
store void (i8*, i8*, %XTMVertexWeight*)* @hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0__1936, void (i8*, i8*, %XTMVertexWeight*)** %closure.func1957
%closure_size1958 = call i64 @llvm_zone_mark_size(%mzone* %zone1943)
call void @llvm_zone_ptr_set_size(i8* %clsptr1944, i64 %closure_size1958)
%wrapper_ptr1959 = call i8* @llvm_zone_malloc(%mzone* %zone1943, i64 8)
%closure_wrapper1960 = bitcast i8* %wrapper_ptr1959 to { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}**
store { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure1945, { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** %closure_wrapper1960

; let value assignment
%hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** %closure_wrapper1960, { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** %closure_wrapper1960
store { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** %hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0, { i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}*** %hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0Ptr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0
%tmp_envptr1954 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}***}* %environment1947, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}*** %hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0Ptr, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}**** %tmp_envptr1954


%val1963 = load {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}**, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}*** %hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** %val1963
}


@hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** @hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0(%XTMVertexWeight* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}*, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMVertexWeight*)*,  void (i8*, i8*, %XTMVertexWeight*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMVertexWeight* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_native(%XTMVertexWeight* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}*, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMVertexWeight*)*,  void (i8*, i8*, %XTMVertexWeight*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMVertexWeight* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1964 = bitcast [97 x i8]* @gsxtmgraphics-pipeline70 to i8*
call i32 (i8*, ...) @printf(i8* %var1964)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMVertexWeight*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}*, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMVertexWeight*)*,  void (i8*, i8*, %XTMVertexWeight*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMVertexWeight* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMVertexWeight*}*
%arg_p_0 = getelementptr {%XTMVertexWeight*}, {%XTMVertexWeight*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMVertexWeight*, %XTMVertexWeight** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNVmVydGV4V2VpZ2h0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}*, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}, {i8*, i8*, void (i8*, i8*, %XTMVertexWeight*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMVertexWeight*)*,  void (i8*, i8*, %XTMVertexWeight*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMVertexWeight* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline71 = hidden constant [79 x i8] c"zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ\00"
@gsxtmgraphics-pipeline72 = hidden constant [81 x i8] c"{i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %XTMVertexWeight* @zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ__1965(i8* %_impz,i8* %_impenv, %XTMVertexWeight* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1966 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQPtr_ = getelementptr {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQPtr = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}***, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQPtr_

; setup arguments
%xPtr = alloca %XTMVertexWeight*
store %XTMVertexWeight* %x, %XTMVertexWeight** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val1968 = load %mzone*, %mzone** %fromzPtr
%val1969 = load %XTMVertexWeight*, %XTMVertexWeight** %xPtr
%val1970 = bitcast %XTMVertexWeight* %val1969 to i8*
%res1971 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val1968, i8* %val1970)
br i1 %res1971, label %then1967, label %else1967

then1967:
%val1972 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val1972)
%zone_ptr1973 = bitcast %mzone* %val1972 to i8*
store i8* %zone_ptr1973, i8** %_impzPtr
%tzone1979 = load i8*, i8** %_impzPtr
%zone1980 = bitcast i8* %tzone1979 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMVertexWeight*
%tzone1975 = load i8*, i8** %_impzPtr
%zone1976 = bitcast i8* %tzone1975 to %mzone*
%dat1977 = call i8* @llvm_zone_malloc(%mzone* %zone1976, i64 8)
call i8* @memset(i8* %dat1977, i32 0, i64 8)
%val1978 = bitcast i8* %dat1977 to %XTMVertexWeight*

; let value assignment
%obj = select i1 true, %XTMVertexWeight* %val1978, %XTMVertexWeight* %val1978
store %XTMVertexWeight* %obj, %XTMVertexWeight** %objPtr

%val1981 = load %XTMVertexWeight*, %XTMVertexWeight** %objPtr
%val1982 = load %XTMVertexWeight*, %XTMVertexWeight** %xPtr
; tuple ref
%val1983 = getelementptr %XTMVertexWeight, %XTMVertexWeight* %val1982, i64 0, i32 0
%val1984 = load i32, i32* %val1983
; set tuple
%val1985 = getelementptr %XTMVertexWeight, %XTMVertexWeight* %val1981, i64 0, i32 0
store i32 %val1984, i32* %val1985
%val1986 = load %XTMVertexWeight*, %XTMVertexWeight** %objPtr
%val1987 = load %XTMVertexWeight*, %XTMVertexWeight** %xPtr
; tuple ref
%val1988 = getelementptr %XTMVertexWeight, %XTMVertexWeight* %val1987, i64 0, i32 1
%val1989 = load float, float* %val1988
; set tuple
%val1990 = getelementptr %XTMVertexWeight, %XTMVertexWeight* %val1986, i64 0, i32 1
store float %val1989, float* %val1990
%oldzone1991 = call %mzone* @llvm_pop_zone_stack()
%newzone1992 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr1993 = bitcast %mzone* %newzone1992 to i8*
store i8* %zone_ptr1993, i8** %_impzPtr
%val1994 = load %XTMVertexWeight*, %XTMVertexWeight** %objPtr
ret %XTMVertexWeight* %val1994

else1967:
%val1995 = load %XTMVertexWeight*, %XTMVertexWeight** %xPtr
ret %XTMVertexWeight* %val1995
}
@gsxtmgraphics-pipeline73 = hidden constant [132 x i8] c"zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2015 = load i8*, i8** %_impzPtr
%zone2016 = bitcast i8* %tzone2015 to %mzone*

; let assign value to symbol zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ
%dat_zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2016, i64 8)
%zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQPtr = bitcast i8* %dat_zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ to { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}***
%tzone1996 = load i8*, i8** %_impzPtr
%zone1997 = bitcast i8* %tzone1996 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1997)
; malloc closure structure
%clsptr1998 = call i8* @llvm_zone_malloc(%mzone* %zone1997, i64 24)
%closure1999 = bitcast i8* %clsptr1998 to { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr2000 = call i8* @llvm_zone_malloc(%mzone* %zone1997, i64 8)
%environment2001 = bitcast i8* %envptr2000 to {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable2002 = call %clsvar* @new_address_table()
%var2003 = bitcast [79 x i8]* @gsxtmgraphics-pipeline71 to i8*
%var2004 = bitcast [81 x i8]* @gsxtmgraphics-pipeline72 to i8*
%addytable2005 = call %clsvar* @add_address_table(%mzone* %zone1997, i8* %var2003, i32 0, i8* %var2004, i32 3, %clsvar* %addytable2002)
%address-table2006 = bitcast %clsvar* %addytable2005 to i8*

; insert table, function and environment into closure struct
%closure.table2009 = getelementptr { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}* %closure1999, i32 0, i32 0
store i8* %address-table2006, i8** %closure.table2009
%closure.env2010 = getelementptr { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}* %closure1999, i32 0, i32 1
store i8* %envptr2000, i8** %closure.env2010
%closure.func2011 = getelementptr { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}* %closure1999, i32 0, i32 2
store %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)* @zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ__1965, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)** %closure.func2011
%closure_size2012 = call i64 @llvm_zone_mark_size(%mzone* %zone1997)
call void @llvm_zone_ptr_set_size(i8* %clsptr1998, i64 %closure_size2012)
%wrapper_ptr2013 = call i8* @llvm_zone_malloc(%mzone* %zone1997, i64 8)
%closure_wrapper2014 = bitcast i8* %wrapper_ptr2013 to { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}**
store { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}* %closure1999, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}** %closure_wrapper2014

; let value assignment
%zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ = select i1 true, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}** %closure_wrapper2014, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}** %closure_wrapper2014
store { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ, { i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ
%tmp_envptr2008 = getelementptr {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}***}* %environment2001, i32 0, i32 0
store {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQPtr, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}**** %tmp_envptr2008


%val2017 = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}**, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQPtr
ret {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}** %val2017
}


@zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMVertexWeight* @zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ(%XTMVertexWeight* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}*, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*,  %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight* %ff(i8* %_impz, i8* %ee, %XTMVertexWeight* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %XTMVertexWeight* %result
}


define dllexport ccc %XTMVertexWeight* @zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ_native(%XTMVertexWeight* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}*, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*,  %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight* %ff(i8* %_impz, i8* %ee, %XTMVertexWeight* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %XTMVertexWeight* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2018 = bitcast [132 x i8]* @gsxtmgraphics-pipeline73 to i8*
call i32 (i8*, ...) @printf(i8* %var2018)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMVertexWeight*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2019 = bitcast [132 x i8]* @gsxtmgraphics-pipeline73 to i8*
call i32 (i8*, ...) @printf(i8* %var2019)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2020 = bitcast [132 x i8]* @gsxtmgraphics-pipeline73 to i8*
call i32 (i8*, ...) @printf(i8* %var2020)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}*, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*,  %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight* %ff(i8* %_impz, i8* %ee, %XTMVertexWeight* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %XTMVertexWeight* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMVertexWeight*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%XTMVertexWeight*, %mzone*, %mzone*}, {%XTMVertexWeight*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMVertexWeight*, %XTMVertexWeight** %arg_p_0
%arg_p_1 = getelementptr {%XTMVertexWeight*, %mzone*, %mzone*}, {%XTMVertexWeight*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%XTMVertexWeight*, %mzone*, %mzone*}, {%XTMVertexWeight*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTVZlcnRleFdlaWdodCosWFRNVmVydGV4V2VpZ2h0Kixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}*, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)*,  %XTMVertexWeight* (i8*, i8*, %XTMVertexWeight*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMVertexWeight* %ff(i8* %_impz, i8* %ee, %XTMVertexWeight* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%XTMBone = type {%String*,i32,float*,float*,i32,%XTMBone**,%XTMBone*}
@gsxtmgraphics-pipeline74 = hidden constant [94 x i8] c"XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0\00"
@gsxtmgraphics-pipeline75 = hidden constant [95 x i8] c"{i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**\00"
define dllexport fastcc %XTMBone* @XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0__2021(i8* %_impz,i8* %_impenv, %String* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, %XTMBone** %arg_5, %XTMBone* %arg_6) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2022 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}*
%XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0Ptr_ = getelementptr {{i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}, {{i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}* %impenv, i32 0, i32 0
%XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0Ptr = load {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**** %XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0Ptr_

; setup arguments
%arg_0Ptr = alloca %String*
store %String* %arg_0, %String** %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca float*
store float* %arg_2, float** %arg_2Ptr
%arg_3Ptr = alloca float*
store float* %arg_3, float** %arg_3Ptr
%arg_4Ptr = alloca i32
store i32 %arg_4, i32* %arg_4Ptr
%arg_5Ptr = alloca %XTMBone**
store %XTMBone** %arg_5, %XTMBone*** %arg_5Ptr
%arg_6Ptr = alloca %XTMBone*
store %XTMBone* %arg_6, %XTMBone** %arg_6Ptr


%tzone2027 = load i8*, i8** %_impzPtr
%zone2028 = bitcast i8* %tzone2027 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMBone*
%tzone2023 = load i8*, i8** %_impzPtr
%zone2024 = bitcast i8* %tzone2023 to %mzone*
%dat2025 = call i8* @llvm_zone_malloc(%mzone* %zone2024, i64 56)
call i8* @memset(i8* %dat2025, i32 0, i64 56)
%val2026 = bitcast i8* %dat2025 to %XTMBone*

; let value assignment
%obj = select i1 true, %XTMBone* %val2026, %XTMBone* %val2026
store %XTMBone* %obj, %XTMBone** %objPtr

%val2029 = load %XTMBone*, %XTMBone** %objPtr
%val2030 = load %String*, %String** %arg_0Ptr
; set tuple
%val2031 = getelementptr %XTMBone, %XTMBone* %val2029, i64 0, i32 0
store %String* %val2030, %String** %val2031
%val2032 = load %XTMBone*, %XTMBone** %objPtr
%val2033 = load i32, i32* %arg_1Ptr
; set tuple
%val2034 = getelementptr %XTMBone, %XTMBone* %val2032, i64 0, i32 1
store i32 %val2033, i32* %val2034
%val2035 = load %XTMBone*, %XTMBone** %objPtr
%val2036 = load float*, float** %arg_2Ptr
; set tuple
%val2037 = getelementptr %XTMBone, %XTMBone* %val2035, i64 0, i32 2
store float* %val2036, float** %val2037
%val2038 = load %XTMBone*, %XTMBone** %objPtr
%val2039 = load float*, float** %arg_3Ptr
; set tuple
%val2040 = getelementptr %XTMBone, %XTMBone* %val2038, i64 0, i32 3
store float* %val2039, float** %val2040
%val2041 = load %XTMBone*, %XTMBone** %objPtr
%val2042 = load i32, i32* %arg_4Ptr
; set tuple
%val2043 = getelementptr %XTMBone, %XTMBone* %val2041, i64 0, i32 4
store i32 %val2042, i32* %val2043
%val2044 = load %XTMBone*, %XTMBone** %objPtr
%val2045 = load %XTMBone**, %XTMBone*** %arg_5Ptr
; set tuple
%val2046 = getelementptr %XTMBone, %XTMBone* %val2044, i64 0, i32 5
store %XTMBone** %val2045, %XTMBone*** %val2046
%val2047 = load %XTMBone*, %XTMBone** %objPtr
%val2048 = load %XTMBone*, %XTMBone** %arg_6Ptr
; set tuple
%val2049 = getelementptr %XTMBone, %XTMBone* %val2047, i64 0, i32 6
store %XTMBone* %val2048, %XTMBone** %val2049
%val2050 = load %XTMBone*, %XTMBone** %objPtr
ret %XTMBone* %val2050
}
@gsxtmgraphics-pipeline76 = hidden constant [147 x i8] c"XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** @XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2070 = load i8*, i8** %_impzPtr
%zone2071 = bitcast i8* %tzone2070 to %mzone*

; let assign value to symbol XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0
%dat_XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone2071, i64 8)
%XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0Ptr = bitcast i8* %dat_XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0 to { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***
%tzone2051 = load i8*, i8** %_impzPtr
%zone2052 = bitcast i8* %tzone2051 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2052)
; malloc closure structure
%clsptr2053 = call i8* @llvm_zone_malloc(%mzone* %zone2052, i64 24)
%closure2054 = bitcast i8* %clsptr2053 to { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*

; malloc environment structure
%envptr2055 = call i8* @llvm_zone_malloc(%mzone* %zone2052, i64 8)
%environment2056 = bitcast i8* %envptr2055 to {{i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}*

; malloc closure address table
%addytable2057 = call %clsvar* @new_address_table()
%var2058 = bitcast [94 x i8]* @gsxtmgraphics-pipeline74 to i8*
%var2059 = bitcast [95 x i8]* @gsxtmgraphics-pipeline75 to i8*
%addytable2060 = call %clsvar* @add_address_table(%mzone* %zone2052, i8* %var2058, i32 0, i8* %var2059, i32 3, %clsvar* %addytable2057)
%address-table2061 = bitcast %clsvar* %addytable2060 to i8*

; insert table, function and environment into closure struct
%closure.table2064 = getelementptr { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure2054, i32 0, i32 0
store i8* %address-table2061, i8** %closure.table2064
%closure.env2065 = getelementptr { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure2054, i32 0, i32 1
store i8* %envptr2055, i8** %closure.env2065
%closure.func2066 = getelementptr { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure2054, i32 0, i32 2
store %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)* @XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0__2021, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)** %closure.func2066
%closure_size2067 = call i64 @llvm_zone_mark_size(%mzone* %zone2052)
call void @llvm_zone_ptr_set_size(i8* %clsptr2053, i64 %closure_size2067)
%wrapper_ptr2068 = call i8* @llvm_zone_malloc(%mzone* %zone2052, i64 8)
%closure_wrapper2069 = bitcast i8* %wrapper_ptr2068 to { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**
store { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure2054, { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_wrapper2069

; let value assignment
%XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0 = select i1 true, { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_wrapper2069, { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_wrapper2069
store { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0, { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*** %XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0Ptr

; add data to environment
; don't need to alloc for env var XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0
%tmp_envptr2063 = getelementptr {{i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}, {{i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}* %environment2056, i32 0, i32 0
store {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*** %XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0Ptr, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**** %tmp_envptr2063


%val2072 = load {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*** %XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0Ptr
ret {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %val2072
}


@XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** @XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMBone* @XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0(%String* %arg_0,i32 %arg_1,float* %arg_2,float* %arg_3,i32 %arg_4,%XTMBone** %arg_5,%XTMBone* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**
%closure = load {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*,  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, %XTMBone** %arg_5, %XTMBone* %arg_6)
ret %XTMBone* %result
}


define dllexport ccc %XTMBone* @XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_native(%String* %arg_0,i32 %arg_1,float* %arg_2,float* %arg_3,i32 %arg_4,%XTMBone** %arg_5,%XTMBone* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**
%closure = load {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*,  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, %XTMBone** %arg_5, %XTMBone* %arg_6)
ret %XTMBone* %result
}


define dllexport ccc i8*  @XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2073 = bitcast [147 x i8]* @gsxtmgraphics-pipeline76 to i8*
call i32 (i8*, ...) @printf(i8* %var2073)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2074 = bitcast [147 x i8]* @gsxtmgraphics-pipeline76 to i8*
call i32 (i8*, ...) @printf(i8* %var2074)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2075 = bitcast [147 x i8]* @gsxtmgraphics-pipeline76 to i8*
call i32 (i8*, ...) @printf(i8* %var2075)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2076 = bitcast [147 x i8]* @gsxtmgraphics-pipeline76 to i8*
call i32 (i8*, ...) @printf(i8* %var2076)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var2077 = bitcast [147 x i8]* @gsxtmgraphics-pipeline76 to i8*
call i32 (i8*, ...) @printf(i8* %var2077)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var2078 = bitcast [147 x i8]* @gsxtmgraphics-pipeline76 to i8*
call i32 (i8*, ...) @printf(i8* %var2078)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to %XTMBone**
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var2079 = bitcast [147 x i8]* @gsxtmgraphics-pipeline76 to i8*
call i32 (i8*, ...) @printf(i8* %var2079)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to %XTMBone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**
%closure = load {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*,  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, %XTMBone** %arg_5, %XTMBone* %arg_6)
%tmpres = bitcast %XTMBone* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}*
%arg_p_0 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
%arg_p_5 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 5
%arg_5 = load %XTMBone**, %XTMBone*** %arg_p_5
%arg_p_6 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 6
%arg_6 = load %XTMBone*, %XTMBone** %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**
%closure = load {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*,  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, %XTMBone** %arg_5, %XTMBone* %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline77 = hidden constant [96 x i8] c"XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0\00"
define dllexport fastcc %XTMBone* @XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0__2080(i8* %_impz,i8* %_impenv, %String* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, %XTMBone** %arg_5, %XTMBone* %arg_6) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2081 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}*
%XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0Ptr_ = getelementptr {{i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}, {{i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}* %impenv, i32 0, i32 0
%XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0Ptr = load {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**** %XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0Ptr_

; setup arguments
%arg_0Ptr = alloca %String*
store %String* %arg_0, %String** %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca float*
store float* %arg_2, float** %arg_2Ptr
%arg_3Ptr = alloca float*
store float* %arg_3, float** %arg_3Ptr
%arg_4Ptr = alloca i32
store i32 %arg_4, i32* %arg_4Ptr
%arg_5Ptr = alloca %XTMBone**
store %XTMBone** %arg_5, %XTMBone*** %arg_5Ptr
%arg_6Ptr = alloca %XTMBone*
store %XTMBone* %arg_6, %XTMBone** %arg_6Ptr


%tzone2086 = load i8*, i8** %_impzPtr
%zone2087 = bitcast i8* %tzone2086 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMBone*
%tzone2082 = load i8*, i8** %_impzPtr
%zone2083 = bitcast i8* %tzone2082 to %mzone*
%dat2084 = call i8* @llvm_zone_malloc(%mzone* %zone2083, i64 56)
call i8* @memset(i8* %dat2084, i32 0, i64 56)
%val2085 = bitcast i8* %dat2084 to %XTMBone*

; let value assignment
%obj = select i1 true, %XTMBone* %val2085, %XTMBone* %val2085
store %XTMBone* %obj, %XTMBone** %objPtr

%val2088 = load %XTMBone*, %XTMBone** %objPtr
%val2089 = load %String*, %String** %arg_0Ptr
; set tuple
%val2090 = getelementptr %XTMBone, %XTMBone* %val2088, i64 0, i32 0
store %String* %val2089, %String** %val2090
%val2091 = load %XTMBone*, %XTMBone** %objPtr
%val2092 = load i32, i32* %arg_1Ptr
; set tuple
%val2093 = getelementptr %XTMBone, %XTMBone* %val2091, i64 0, i32 1
store i32 %val2092, i32* %val2093
%val2094 = load %XTMBone*, %XTMBone** %objPtr
%val2095 = load float*, float** %arg_2Ptr
; set tuple
%val2096 = getelementptr %XTMBone, %XTMBone* %val2094, i64 0, i32 2
store float* %val2095, float** %val2096
%val2097 = load %XTMBone*, %XTMBone** %objPtr
%val2098 = load float*, float** %arg_3Ptr
; set tuple
%val2099 = getelementptr %XTMBone, %XTMBone* %val2097, i64 0, i32 3
store float* %val2098, float** %val2099
%val2100 = load %XTMBone*, %XTMBone** %objPtr
%val2101 = load i32, i32* %arg_4Ptr
; set tuple
%val2102 = getelementptr %XTMBone, %XTMBone* %val2100, i64 0, i32 4
store i32 %val2101, i32* %val2102
%val2103 = load %XTMBone*, %XTMBone** %objPtr
%val2104 = load %XTMBone**, %XTMBone*** %arg_5Ptr
; set tuple
%val2105 = getelementptr %XTMBone, %XTMBone* %val2103, i64 0, i32 5
store %XTMBone** %val2104, %XTMBone*** %val2105
%val2106 = load %XTMBone*, %XTMBone** %objPtr
%val2107 = load %XTMBone*, %XTMBone** %arg_6Ptr
; set tuple
%val2108 = getelementptr %XTMBone, %XTMBone* %val2106, i64 0, i32 6
store %XTMBone* %val2107, %XTMBone** %val2108
%val2109 = load %XTMBone*, %XTMBone** %objPtr
ret %XTMBone* %val2109
}
@gsxtmgraphics-pipeline78 = hidden constant [149 x i8] c"XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** @XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2129 = load i8*, i8** %_impzPtr
%zone2130 = bitcast i8* %tzone2129 to %mzone*

; let assign value to symbol XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0
%dat_XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone2130, i64 8)
%XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0Ptr = bitcast i8* %dat_XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0 to { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***
%tzone2110 = load i8*, i8** %_impzPtr
%zone2111 = bitcast i8* %tzone2110 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2111)
; malloc closure structure
%clsptr2112 = call i8* @llvm_zone_malloc(%mzone* %zone2111, i64 24)
%closure2113 = bitcast i8* %clsptr2112 to { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*

; malloc environment structure
%envptr2114 = call i8* @llvm_zone_malloc(%mzone* %zone2111, i64 8)
%environment2115 = bitcast i8* %envptr2114 to {{i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}*

; malloc closure address table
%addytable2116 = call %clsvar* @new_address_table()
%var2117 = bitcast [96 x i8]* @gsxtmgraphics-pipeline77 to i8*
%var2118 = bitcast [95 x i8]* @gsxtmgraphics-pipeline75 to i8*
%addytable2119 = call %clsvar* @add_address_table(%mzone* %zone2111, i8* %var2117, i32 0, i8* %var2118, i32 3, %clsvar* %addytable2116)
%address-table2120 = bitcast %clsvar* %addytable2119 to i8*

; insert table, function and environment into closure struct
%closure.table2123 = getelementptr { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure2113, i32 0, i32 0
store i8* %address-table2120, i8** %closure.table2123
%closure.env2124 = getelementptr { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure2113, i32 0, i32 1
store i8* %envptr2114, i8** %closure.env2124
%closure.func2125 = getelementptr { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure2113, i32 0, i32 2
store %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)* @XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0__2080, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)** %closure.func2125
%closure_size2126 = call i64 @llvm_zone_mark_size(%mzone* %zone2111)
call void @llvm_zone_ptr_set_size(i8* %clsptr2112, i64 %closure_size2126)
%wrapper_ptr2127 = call i8* @llvm_zone_malloc(%mzone* %zone2111, i64 8)
%closure_wrapper2128 = bitcast i8* %wrapper_ptr2127 to { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**
store { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure2113, { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_wrapper2128

; let value assignment
%XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0 = select i1 true, { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_wrapper2128, { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_wrapper2128
store { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0, { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*** %XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0Ptr

; add data to environment
; don't need to alloc for env var XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0
%tmp_envptr2122 = getelementptr {{i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}, {{i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}* %environment2115, i32 0, i32 0
store {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*** %XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0Ptr, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**** %tmp_envptr2122


%val2131 = load {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*** %XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0Ptr
ret {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %val2131
}


@XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** @XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMBone* @XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0(%String* %arg_0,i32 %arg_1,float* %arg_2,float* %arg_3,i32 %arg_4,%XTMBone** %arg_5,%XTMBone* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**
%closure = load {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*,  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, %XTMBone** %arg_5, %XTMBone* %arg_6)
ret %XTMBone* %result
}


define dllexport ccc %XTMBone* @XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_native(%String* %arg_0,i32 %arg_1,float* %arg_2,float* %arg_3,i32 %arg_4,%XTMBone** %arg_5,%XTMBone* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**
%closure = load {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*,  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, %XTMBone** %arg_5, %XTMBone* %arg_6)
ret %XTMBone* %result
}


define dllexport ccc i8*  @XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2132 = bitcast [149 x i8]* @gsxtmgraphics-pipeline78 to i8*
call i32 (i8*, ...) @printf(i8* %var2132)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2133 = bitcast [149 x i8]* @gsxtmgraphics-pipeline78 to i8*
call i32 (i8*, ...) @printf(i8* %var2133)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2134 = bitcast [149 x i8]* @gsxtmgraphics-pipeline78 to i8*
call i32 (i8*, ...) @printf(i8* %var2134)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2135 = bitcast [149 x i8]* @gsxtmgraphics-pipeline78 to i8*
call i32 (i8*, ...) @printf(i8* %var2135)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var2136 = bitcast [149 x i8]* @gsxtmgraphics-pipeline78 to i8*
call i32 (i8*, ...) @printf(i8* %var2136)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var2137 = bitcast [149 x i8]* @gsxtmgraphics-pipeline78 to i8*
call i32 (i8*, ...) @printf(i8* %var2137)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to %XTMBone**
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var2138 = bitcast [149 x i8]* @gsxtmgraphics-pipeline78 to i8*
call i32 (i8*, ...) @printf(i8* %var2138)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to %XTMBone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**
%closure = load {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*,  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, %XTMBone** %arg_5, %XTMBone* %arg_6)
%tmpres = bitcast %XTMBone* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}*
%arg_p_0 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
%arg_p_5 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 5
%arg_5 = load %XTMBone**, %XTMBone*** %arg_p_5
%arg_p_6 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 6
%arg_6 = load %XTMBone*, %XTMBone** %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_z_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**
%closure = load {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*,  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, %XTMBone** %arg_5, %XTMBone* %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline79 = hidden constant [96 x i8] c"XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0\00"
define dllexport fastcc %XTMBone* @XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0__2139(i8* %_impz,i8* %_impenv, %String* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, %XTMBone** %arg_5, %XTMBone* %arg_6) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2140 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}*
%XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0Ptr_ = getelementptr {{i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}, {{i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}* %impenv, i32 0, i32 0
%XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0Ptr = load {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**** %XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0Ptr_

; setup arguments
%arg_0Ptr = alloca %String*
store %String* %arg_0, %String** %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca float*
store float* %arg_2, float** %arg_2Ptr
%arg_3Ptr = alloca float*
store float* %arg_3, float** %arg_3Ptr
%arg_4Ptr = alloca i32
store i32 %arg_4, i32* %arg_4Ptr
%arg_5Ptr = alloca %XTMBone**
store %XTMBone** %arg_5, %XTMBone*** %arg_5Ptr
%arg_6Ptr = alloca %XTMBone*
store %XTMBone* %arg_6, %XTMBone** %arg_6Ptr


%tzone2143 = load i8*, i8** %_impzPtr
%zone2144 = bitcast i8* %tzone2143 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMBone*
%dat2141 = call i8* @malloc(i64 56)
call i8* @memset(i8* %dat2141, i32 0, i64 56)
%val2142 = bitcast i8* %dat2141 to %XTMBone*

; let value assignment
%obj = select i1 true, %XTMBone* %val2142, %XTMBone* %val2142
store %XTMBone* %obj, %XTMBone** %objPtr

%val2145 = load %XTMBone*, %XTMBone** %objPtr
%val2146 = load %String*, %String** %arg_0Ptr
; set tuple
%val2147 = getelementptr %XTMBone, %XTMBone* %val2145, i64 0, i32 0
store %String* %val2146, %String** %val2147
%val2148 = load %XTMBone*, %XTMBone** %objPtr
%val2149 = load i32, i32* %arg_1Ptr
; set tuple
%val2150 = getelementptr %XTMBone, %XTMBone* %val2148, i64 0, i32 1
store i32 %val2149, i32* %val2150
%val2151 = load %XTMBone*, %XTMBone** %objPtr
%val2152 = load float*, float** %arg_2Ptr
; set tuple
%val2153 = getelementptr %XTMBone, %XTMBone* %val2151, i64 0, i32 2
store float* %val2152, float** %val2153
%val2154 = load %XTMBone*, %XTMBone** %objPtr
%val2155 = load float*, float** %arg_3Ptr
; set tuple
%val2156 = getelementptr %XTMBone, %XTMBone* %val2154, i64 0, i32 3
store float* %val2155, float** %val2156
%val2157 = load %XTMBone*, %XTMBone** %objPtr
%val2158 = load i32, i32* %arg_4Ptr
; set tuple
%val2159 = getelementptr %XTMBone, %XTMBone* %val2157, i64 0, i32 4
store i32 %val2158, i32* %val2159
%val2160 = load %XTMBone*, %XTMBone** %objPtr
%val2161 = load %XTMBone**, %XTMBone*** %arg_5Ptr
; set tuple
%val2162 = getelementptr %XTMBone, %XTMBone* %val2160, i64 0, i32 5
store %XTMBone** %val2161, %XTMBone*** %val2162
%val2163 = load %XTMBone*, %XTMBone** %objPtr
%val2164 = load %XTMBone*, %XTMBone** %arg_6Ptr
; set tuple
%val2165 = getelementptr %XTMBone, %XTMBone* %val2163, i64 0, i32 6
store %XTMBone* %val2164, %XTMBone** %val2165
%val2166 = load %XTMBone*, %XTMBone** %objPtr
ret %XTMBone* %val2166
}
@gsxtmgraphics-pipeline80 = hidden constant [149 x i8] c"XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** @XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2186 = load i8*, i8** %_impzPtr
%zone2187 = bitcast i8* %tzone2186 to %mzone*

; let assign value to symbol XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0
%dat_XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone2187, i64 8)
%XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0Ptr = bitcast i8* %dat_XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0 to { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***
%tzone2167 = load i8*, i8** %_impzPtr
%zone2168 = bitcast i8* %tzone2167 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2168)
; malloc closure structure
%clsptr2169 = call i8* @llvm_zone_malloc(%mzone* %zone2168, i64 24)
%closure2170 = bitcast i8* %clsptr2169 to { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*

; malloc environment structure
%envptr2171 = call i8* @llvm_zone_malloc(%mzone* %zone2168, i64 8)
%environment2172 = bitcast i8* %envptr2171 to {{i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}*

; malloc closure address table
%addytable2173 = call %clsvar* @new_address_table()
%var2174 = bitcast [96 x i8]* @gsxtmgraphics-pipeline79 to i8*
%var2175 = bitcast [95 x i8]* @gsxtmgraphics-pipeline75 to i8*
%addytable2176 = call %clsvar* @add_address_table(%mzone* %zone2168, i8* %var2174, i32 0, i8* %var2175, i32 3, %clsvar* %addytable2173)
%address-table2177 = bitcast %clsvar* %addytable2176 to i8*

; insert table, function and environment into closure struct
%closure.table2180 = getelementptr { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure2170, i32 0, i32 0
store i8* %address-table2177, i8** %closure.table2180
%closure.env2181 = getelementptr { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure2170, i32 0, i32 1
store i8* %envptr2171, i8** %closure.env2181
%closure.func2182 = getelementptr { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure2170, i32 0, i32 2
store %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)* @XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0__2139, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)** %closure.func2182
%closure_size2183 = call i64 @llvm_zone_mark_size(%mzone* %zone2168)
call void @llvm_zone_ptr_set_size(i8* %clsptr2169, i64 %closure_size2183)
%wrapper_ptr2184 = call i8* @llvm_zone_malloc(%mzone* %zone2168, i64 8)
%closure_wrapper2185 = bitcast i8* %wrapper_ptr2184 to { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**
store { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure2170, { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_wrapper2185

; let value assignment
%XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0 = select i1 true, { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_wrapper2185, { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_wrapper2185
store { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0, { i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*** %XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0Ptr

; add data to environment
; don't need to alloc for env var XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0
%tmp_envptr2179 = getelementptr {{i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}, {{i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}* %environment2172, i32 0, i32 0
store {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*** %XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0Ptr, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**** %tmp_envptr2179


%val2188 = load {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*** %XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0Ptr
ret {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %val2188
}


@XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** @XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMBone* @XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0(%String* %arg_0,i32 %arg_1,float* %arg_2,float* %arg_3,i32 %arg_4,%XTMBone** %arg_5,%XTMBone* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**
%closure = load {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*,  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, %XTMBone** %arg_5, %XTMBone* %arg_6)
ret %XTMBone* %result
}


define dllexport ccc %XTMBone* @XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_native(%String* %arg_0,i32 %arg_1,float* %arg_2,float* %arg_3,i32 %arg_4,%XTMBone** %arg_5,%XTMBone* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**
%closure = load {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*,  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, %XTMBone** %arg_5, %XTMBone* %arg_6)
ret %XTMBone* %result
}


define dllexport ccc i8*  @XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2189 = bitcast [149 x i8]* @gsxtmgraphics-pipeline80 to i8*
call i32 (i8*, ...) @printf(i8* %var2189)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2190 = bitcast [149 x i8]* @gsxtmgraphics-pipeline80 to i8*
call i32 (i8*, ...) @printf(i8* %var2190)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2191 = bitcast [149 x i8]* @gsxtmgraphics-pipeline80 to i8*
call i32 (i8*, ...) @printf(i8* %var2191)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2192 = bitcast [149 x i8]* @gsxtmgraphics-pipeline80 to i8*
call i32 (i8*, ...) @printf(i8* %var2192)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var2193 = bitcast [149 x i8]* @gsxtmgraphics-pipeline80 to i8*
call i32 (i8*, ...) @printf(i8* %var2193)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var2194 = bitcast [149 x i8]* @gsxtmgraphics-pipeline80 to i8*
call i32 (i8*, ...) @printf(i8* %var2194)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to %XTMBone**
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var2195 = bitcast [149 x i8]* @gsxtmgraphics-pipeline80 to i8*
call i32 (i8*, ...) @printf(i8* %var2195)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to %XTMBone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**
%closure = load {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*,  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, %XTMBone** %arg_5, %XTMBone* %arg_6)
%tmpres = bitcast %XTMBone* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}*
%arg_p_0 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
%arg_p_5 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 5
%arg_5 = load %XTMBone**, %XTMBone*** %arg_p_5
%arg_p_6 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 6
%arg_6 = load %XTMBone*, %XTMBone** %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_h_adhoc_W1hUTUJvbmUqLFN0cmluZyosaTMyLGZsb2F0KixmbG9hdCosaTMyLFhUTUJvbmUqKixYVE1Cb25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**
%closure = load {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*,  %XTMBone* (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, %XTMBone** %arg_5, %XTMBone* %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline81 = hidden constant [2 x i8] c"_\00"
@gsxtmgraphics-pipeline82 = hidden constant [38 x i8] c"toString_poly_W1N0cmluZyosZmxvYXQqXSo\00"
@gsxtmgraphics-pipeline83 = hidden constant [43 x i8] c"{i8*, i8*, %String* (i8*, i8*, float*)*}**\00"
define dllexport fastcc %String* @toString_poly_W1N0cmluZyosZmxvYXQqXSo__2197(i8* %_impz,i8* %_impenv, float* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2198 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, float*)*}***}*
%toString_poly_W1N0cmluZyosZmxvYXQqXSoPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, float*)*}***}, {{i8*, i8*, %String* (i8*, i8*, float*)*}***}* %impenv, i32 0, i32 0
%toString_poly_W1N0cmluZyosZmxvYXQqXSoPtr = load {i8*, i8*, %String* (i8*, i8*, float*)*}***, {i8*, i8*, %String* (i8*, i8*, float*)*}**** %toString_poly_W1N0cmluZyosZmxvYXQqXSoPtr_

; setup arguments
%xPtr = alloca float*
store float* %x, float** %xPtr


%var2199 = bitcast [2 x i8]* @gsxtmgraphics-pipeline81 to i8*
%res2200 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %var2199)
ret %String* %res2200
}
@gsxtmgraphics-pipeline84 = hidden constant [91 x i8] c"toString_poly_W1N0cmluZyosZmxvYXQqXSo Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, float*)*}** @toString_poly_W1N0cmluZyosZmxvYXQqXSo_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2220 = load i8*, i8** %_impzPtr
%zone2221 = bitcast i8* %tzone2220 to %mzone*

; let assign value to symbol toString_poly_W1N0cmluZyosZmxvYXQqXSo
%dat_toString_poly_W1N0cmluZyosZmxvYXQqXSo = call i8* @llvm_zone_malloc(%mzone* %zone2221, i64 8)
%toString_poly_W1N0cmluZyosZmxvYXQqXSoPtr = bitcast i8* %dat_toString_poly_W1N0cmluZyosZmxvYXQqXSo to { i8*, i8*, %String* (i8*, i8*, float*)*}***
%tzone2201 = load i8*, i8** %_impzPtr
%zone2202 = bitcast i8* %tzone2201 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2202)
; malloc closure structure
%clsptr2203 = call i8* @llvm_zone_malloc(%mzone* %zone2202, i64 24)
%closure2204 = bitcast i8* %clsptr2203 to { i8*, i8*, %String* (i8*, i8*, float*)*}*

; malloc environment structure
%envptr2205 = call i8* @llvm_zone_malloc(%mzone* %zone2202, i64 8)
%environment2206 = bitcast i8* %envptr2205 to {{i8*, i8*, %String* (i8*, i8*, float*)*}***}*

; malloc closure address table
%addytable2207 = call %clsvar* @new_address_table()
%var2208 = bitcast [38 x i8]* @gsxtmgraphics-pipeline82 to i8*
%var2209 = bitcast [43 x i8]* @gsxtmgraphics-pipeline83 to i8*
%addytable2210 = call %clsvar* @add_address_table(%mzone* %zone2202, i8* %var2208, i32 0, i8* %var2209, i32 3, %clsvar* %addytable2207)
%address-table2211 = bitcast %clsvar* %addytable2210 to i8*

; insert table, function and environment into closure struct
%closure.table2214 = getelementptr { i8*, i8*, %String* (i8*, i8*, float*)*}, { i8*, i8*, %String* (i8*, i8*, float*)*}* %closure2204, i32 0, i32 0
store i8* %address-table2211, i8** %closure.table2214
%closure.env2215 = getelementptr { i8*, i8*, %String* (i8*, i8*, float*)*}, { i8*, i8*, %String* (i8*, i8*, float*)*}* %closure2204, i32 0, i32 1
store i8* %envptr2205, i8** %closure.env2215
%closure.func2216 = getelementptr { i8*, i8*, %String* (i8*, i8*, float*)*}, { i8*, i8*, %String* (i8*, i8*, float*)*}* %closure2204, i32 0, i32 2
store %String* (i8*, i8*, float*)* @toString_poly_W1N0cmluZyosZmxvYXQqXSo__2197, %String* (i8*, i8*, float*)** %closure.func2216
%closure_size2217 = call i64 @llvm_zone_mark_size(%mzone* %zone2202)
call void @llvm_zone_ptr_set_size(i8* %clsptr2203, i64 %closure_size2217)
%wrapper_ptr2218 = call i8* @llvm_zone_malloc(%mzone* %zone2202, i64 8)
%closure_wrapper2219 = bitcast i8* %wrapper_ptr2218 to { i8*, i8*, %String* (i8*, i8*, float*)*}**
store { i8*, i8*, %String* (i8*, i8*, float*)*}* %closure2204, { i8*, i8*, %String* (i8*, i8*, float*)*}** %closure_wrapper2219

; let value assignment
%toString_poly_W1N0cmluZyosZmxvYXQqXSo = select i1 true, { i8*, i8*, %String* (i8*, i8*, float*)*}** %closure_wrapper2219, { i8*, i8*, %String* (i8*, i8*, float*)*}** %closure_wrapper2219
store { i8*, i8*, %String* (i8*, i8*, float*)*}** %toString_poly_W1N0cmluZyosZmxvYXQqXSo, { i8*, i8*, %String* (i8*, i8*, float*)*}*** %toString_poly_W1N0cmluZyosZmxvYXQqXSoPtr

; add data to environment
; don't need to alloc for env var toString_poly_W1N0cmluZyosZmxvYXQqXSo
%tmp_envptr2213 = getelementptr {{i8*, i8*, %String* (i8*, i8*, float*)*}***}, {{i8*, i8*, %String* (i8*, i8*, float*)*}***}* %environment2206, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, float*)*}*** %toString_poly_W1N0cmluZyosZmxvYXQqXSoPtr, {i8*, i8*, %String* (i8*, i8*, float*)*}**** %tmp_envptr2213


%val2222 = load {i8*, i8*, %String* (i8*, i8*, float*)*}**, {i8*, i8*, %String* (i8*, i8*, float*)*}*** %toString_poly_W1N0cmluZyosZmxvYXQqXSoPtr
ret {i8*, i8*, %String* (i8*, i8*, float*)*}** %val2222
}


@toString_poly_W1N0cmluZyosZmxvYXQqXSo_var = dllexport global [1 x i8*] [ i8* null ]

@toString_poly_W1N0cmluZyosZmxvYXQqXSo_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_poly_W1N0cmluZyosZmxvYXQqXSo_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosZmxvYXQqXSo_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, float*)*}** @toString_poly_W1N0cmluZyosZmxvYXQqXSo_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_poly_W1N0cmluZyosZmxvYXQqXSo_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_poly_W1N0cmluZyosZmxvYXQqXSo_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosZmxvYXQqXSo_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_poly_W1N0cmluZyosZmxvYXQqXSo(float* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosZmxvYXQqXSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, float*)*}*, {i8*, i8*, %String* (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float*)*}, {i8*, i8*, %String* (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float*)*}, {i8*, i8*, %String* (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, float*)*,  %String* (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, float* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_poly_W1N0cmluZyosZmxvYXQqXSo_native(float* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosZmxvYXQqXSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, float*)*}*, {i8*, i8*, %String* (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float*)*}, {i8*, i8*, %String* (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float*)*}, {i8*, i8*, %String* (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, float*)*,  %String* (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, float* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_poly_W1N0cmluZyosZmxvYXQqXSo_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2223 = bitcast [91 x i8]* @gsxtmgraphics-pipeline84 to i8*
call i32 (i8*, ...) @printf(i8* %var2223)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosZmxvYXQqXSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, float*)*}*, {i8*, i8*, %String* (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float*)*}, {i8*, i8*, %String* (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float*)*}, {i8*, i8*, %String* (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, float*)*,  %String* (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, float* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_poly_W1N0cmluZyosZmxvYXQqXSo_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*}*
%arg_p_0 = getelementptr {float*}, {float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosZmxvYXQqXSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, float*)*}*, {i8*, i8*, %String* (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float*)*}, {i8*, i8*, %String* (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float*)*}, {i8*, i8*, %String* (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, float*)*,  %String* (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, float* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline85 = hidden constant [42 x i8] c"toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo\00"
@gsxtmgraphics-pipeline86 = hidden constant [47 x i8] c"{i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}**\00"
define dllexport fastcc %String* @toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo__2224(i8* %_impz,i8* %_impenv, %XTMBone** %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2225 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}***}*
%toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSoPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}***}, {{i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}***}* %impenv, i32 0, i32 0
%toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSoPtr = load {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}***, {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}**** %toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSoPtr_

; setup arguments
%xPtr = alloca %XTMBone**
store %XTMBone** %x, %XTMBone*** %xPtr


%var2226 = bitcast [2 x i8]* @gsxtmgraphics-pipeline81 to i8*
%res2227 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %var2226)
ret %String* %res2227
}
@gsxtmgraphics-pipeline87 = hidden constant [95 x i8] c"toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}** @toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2247 = load i8*, i8** %_impzPtr
%zone2248 = bitcast i8* %tzone2247 to %mzone*

; let assign value to symbol toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo
%dat_toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo = call i8* @llvm_zone_malloc(%mzone* %zone2248, i64 8)
%toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSoPtr = bitcast i8* %dat_toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo to { i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}***
%tzone2228 = load i8*, i8** %_impzPtr
%zone2229 = bitcast i8* %tzone2228 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2229)
; malloc closure structure
%clsptr2230 = call i8* @llvm_zone_malloc(%mzone* %zone2229, i64 24)
%closure2231 = bitcast i8* %clsptr2230 to { i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}*

; malloc environment structure
%envptr2232 = call i8* @llvm_zone_malloc(%mzone* %zone2229, i64 8)
%environment2233 = bitcast i8* %envptr2232 to {{i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}***}*

; malloc closure address table
%addytable2234 = call %clsvar* @new_address_table()
%var2235 = bitcast [42 x i8]* @gsxtmgraphics-pipeline85 to i8*
%var2236 = bitcast [47 x i8]* @gsxtmgraphics-pipeline86 to i8*
%addytable2237 = call %clsvar* @add_address_table(%mzone* %zone2229, i8* %var2235, i32 0, i8* %var2236, i32 3, %clsvar* %addytable2234)
%address-table2238 = bitcast %clsvar* %addytable2237 to i8*

; insert table, function and environment into closure struct
%closure.table2241 = getelementptr { i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}, { i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}* %closure2231, i32 0, i32 0
store i8* %address-table2238, i8** %closure.table2241
%closure.env2242 = getelementptr { i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}, { i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}* %closure2231, i32 0, i32 1
store i8* %envptr2232, i8** %closure.env2242
%closure.func2243 = getelementptr { i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}, { i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}* %closure2231, i32 0, i32 2
store %String* (i8*, i8*, %XTMBone**)* @toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo__2224, %String* (i8*, i8*, %XTMBone**)** %closure.func2243
%closure_size2244 = call i64 @llvm_zone_mark_size(%mzone* %zone2229)
call void @llvm_zone_ptr_set_size(i8* %clsptr2230, i64 %closure_size2244)
%wrapper_ptr2245 = call i8* @llvm_zone_malloc(%mzone* %zone2229, i64 8)
%closure_wrapper2246 = bitcast i8* %wrapper_ptr2245 to { i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}**
store { i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}* %closure2231, { i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}** %closure_wrapper2246

; let value assignment
%toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo = select i1 true, { i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}** %closure_wrapper2246, { i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}** %closure_wrapper2246
store { i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}** %toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo, { i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}*** %toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSoPtr

; add data to environment
; don't need to alloc for env var toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo
%tmp_envptr2240 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}***}, {{i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}***}* %environment2233, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}*** %toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSoPtr, {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}**** %tmp_envptr2240


%val2249 = load {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}**, {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}*** %toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSoPtr
ret {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}** %val2249
}


@toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo_var = dllexport global [1 x i8*] [ i8* null ]

@toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}** @toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo(%XTMBone** %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}*, {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %XTMBone**)*,  %String* (i8*, i8*, %XTMBone**)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %XTMBone** %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo_native(%XTMBone** %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}*, {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %XTMBone**)*,  %String* (i8*, i8*, %XTMBone**)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %XTMBone** %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2250 = bitcast [95 x i8]* @gsxtmgraphics-pipeline87 to i8*
call i32 (i8*, ...) @printf(i8* %var2250)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMBone**
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}*, {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %XTMBone**)*,  %String* (i8*, i8*, %XTMBone**)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %XTMBone** %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMBone**}*
%arg_p_0 = getelementptr {%XTMBone**}, {%XTMBone**}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMBone**, %XTMBone*** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}*, {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone**)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %XTMBone**)*,  %String* (i8*, i8*, %XTMBone**)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %XTMBone** %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline88 = hidden constant [41 x i8] c"toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg\00"
@gsxtmgraphics-pipeline89 = hidden constant [46 x i8] c"{i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}**\00"
define dllexport fastcc %String* @toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg__2251(i8* %_impz,i8* %_impenv, %XTMBone* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2252 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}***}*
%toString_poly_W1N0cmluZyosWFRNQm9uZSpdKgPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}***}* %impenv, i32 0, i32 0
%toString_poly_W1N0cmluZyosWFRNQm9uZSpdKgPtr = load {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}***, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}**** %toString_poly_W1N0cmluZyosWFRNQm9uZSpdKgPtr_

; setup arguments
%xPtr = alloca %XTMBone*
store %XTMBone* %x, %XTMBone** %xPtr


%var2253 = bitcast [2 x i8]* @gsxtmgraphics-pipeline81 to i8*
%res2254 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %var2253)
ret %String* %res2254
}
@gsxtmgraphics-pipeline90 = hidden constant [94 x i8] c"toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** @toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2274 = load i8*, i8** %_impzPtr
%zone2275 = bitcast i8* %tzone2274 to %mzone*

; let assign value to symbol toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg
%dat_toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg = call i8* @llvm_zone_malloc(%mzone* %zone2275, i64 8)
%toString_poly_W1N0cmluZyosWFRNQm9uZSpdKgPtr = bitcast i8* %dat_toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg to { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}***
%tzone2255 = load i8*, i8** %_impzPtr
%zone2256 = bitcast i8* %tzone2255 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2256)
; malloc closure structure
%clsptr2257 = call i8* @llvm_zone_malloc(%mzone* %zone2256, i64 24)
%closure2258 = bitcast i8* %clsptr2257 to { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}*

; malloc environment structure
%envptr2259 = call i8* @llvm_zone_malloc(%mzone* %zone2256, i64 8)
%environment2260 = bitcast i8* %envptr2259 to {{i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}***}*

; malloc closure address table
%addytable2261 = call %clsvar* @new_address_table()
%var2262 = bitcast [41 x i8]* @gsxtmgraphics-pipeline88 to i8*
%var2263 = bitcast [46 x i8]* @gsxtmgraphics-pipeline89 to i8*
%addytable2264 = call %clsvar* @add_address_table(%mzone* %zone2256, i8* %var2262, i32 0, i8* %var2263, i32 3, %clsvar* %addytable2261)
%address-table2265 = bitcast %clsvar* %addytable2264 to i8*

; insert table, function and environment into closure struct
%closure.table2268 = getelementptr { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure2258, i32 0, i32 0
store i8* %address-table2265, i8** %closure.table2268
%closure.env2269 = getelementptr { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure2258, i32 0, i32 1
store i8* %envptr2259, i8** %closure.env2269
%closure.func2270 = getelementptr { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure2258, i32 0, i32 2
store %String* (i8*, i8*, %XTMBone*)* @toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg__2251, %String* (i8*, i8*, %XTMBone*)** %closure.func2270
%closure_size2271 = call i64 @llvm_zone_mark_size(%mzone* %zone2256)
call void @llvm_zone_ptr_set_size(i8* %clsptr2257, i64 %closure_size2271)
%wrapper_ptr2272 = call i8* @llvm_zone_malloc(%mzone* %zone2256, i64 8)
%closure_wrapper2273 = bitcast i8* %wrapper_ptr2272 to { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}**
store { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure2258, { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** %closure_wrapper2273

; let value assignment
%toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg = select i1 true, { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** %closure_wrapper2273, { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** %closure_wrapper2273
store { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** %toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg, { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}*** %toString_poly_W1N0cmluZyosWFRNQm9uZSpdKgPtr

; add data to environment
; don't need to alloc for env var toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg
%tmp_envptr2267 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}***}* %environment2260, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}*** %toString_poly_W1N0cmluZyosWFRNQm9uZSpdKgPtr, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}**** %tmp_envptr2267


%val2276 = load {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}**, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}*** %toString_poly_W1N0cmluZyosWFRNQm9uZSpdKgPtr
ret {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** %val2276
}


@toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg_var = dllexport global [1 x i8*] [ i8* null ]

@toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** @toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg(%XTMBone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %XTMBone*)*,  %String* (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg_native(%XTMBone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %XTMBone*)*,  %String* (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2277 = bitcast [94 x i8]* @gsxtmgraphics-pipeline90 to i8*
call i32 (i8*, ...) @printf(i8* %var2277)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMBone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %XTMBone*)*,  %String* (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMBone*}*
%arg_p_0 = getelementptr {%XTMBone*}, {%XTMBone*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMBone*, %XTMBone** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %XTMBone*)*,  %String* (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline91 = hidden constant [15 x i8] c"<XTMBone:null>\00"
@gsxtmgraphics-pipeline92 = hidden constant [10 x i8] c"<XTMBone:\00"
@gsxtmgraphics-pipeline93 = hidden constant [40 x i8] c"toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd__2196(i8* %_impz,i8* %_impenv, %XTMBone* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2278 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}***}*
%toString_adhoc_W1N0cmluZyosWFRNQm9uZSpdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosWFRNQm9uZSpdPtr = load {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}***, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}**** %toString_adhoc_W1N0cmluZyosWFRNQm9uZSpdPtr_

; setup arguments
%xPtr = alloca %XTMBone*
store %XTMBone* %x, %XTMBone** %xPtr


%val2280 = load %XTMBone*, %XTMBone** %xPtr
%val2281 = icmp eq %XTMBone* %val2280, null
br i1 %val2281, label %then2279, label %else2279

then2279:
%zone2282 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone2282)
%zone_ptr2283 = bitcast %mzone* %zone2282 to i8*
store i8* %zone_ptr2283, i8** %_impzPtr
%tzone2293 = load i8*, i8** %_impzPtr
%zone2294 = bitcast i8* %tzone2293 to %mzone*

; let assign value to symbol res2
%res2Ptr = alloca %String*
%tzone2298 = load i8*, i8** %_impzPtr
%zone2299 = bitcast i8* %tzone2298 to %mzone*

; let assign value to symbol zone2
%zone2Ptr = alloca %mzone*
%tzone2301 = load i8*, i8** %_impzPtr
%zone2302 = bitcast i8* %tzone2301 to %mzone*

; let assign value to symbol newz2
%newz2Ptr = alloca %mzone*
%tzone2285 = load i8*, i8** %_impzPtr
%zone2286 = bitcast i8* %tzone2285 to %mzone*

; let assign value to symbol xx_t_mst
%xx_t_mstPtr = alloca i8*
%dat2284 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst = select i1 true, i8* %dat2284, i8* %dat2284
store i8* %xx_t_mst, i8** %xx_t_mstPtr

%val2287 = load i8*, i8** %xx_t_mstPtr
%var2288 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var2289 = bitcast [15 x i8]* @gsxtmgraphics-pipeline91 to i8*

%val2290 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2287, i8* %var2288, i8* %var2289)
%val2291 = load i8*, i8** %xx_t_mstPtr
%res2292 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2291)

; let value assignment
%res2 = select i1 true, %String* %res2292, %String* %res2292
store %String* %res2, %String** %res2Ptr

%oldzone2295 = call %mzone* @llvm_pop_zone_stack()
%newzone2296 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr2297 = bitcast %mzone* %newzone2296 to i8*
store i8* %zone_ptr2297, i8** %_impzPtr

; let value assignment
%zone2 = select i1 true, %mzone* %oldzone2295, %mzone* %oldzone2295
store %mzone* %zone2, %mzone** %zone2Ptr

%res2300 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz2 = select i1 true, %mzone* %res2300, %mzone* %res2300
store %mzone* %newz2, %mzone** %newz2Ptr

%tzone2307 = load i8*, i8** %_impzPtr
%zone2308 = bitcast i8* %tzone2307 to %mzone*

; let assign value to symbol rescopy2
%rescopy2Ptr = alloca %String*
%tzone2313 = load i8*, i8** %_impzPtr
%zone2314 = bitcast i8* %tzone2313 to %mzone*

; let assign value to symbol hook
%hookPtr = alloca {i64,i8*,i8*}*
%tzone2316 = load i8*, i8** %_impzPtr
%zone2317 = bitcast i8* %tzone2316 to %mzone*

; let assign value to symbol f
%fPtr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val2303 = load %String*, %String** %res2Ptr
%val2304 = load %mzone*, %mzone** %zone2Ptr
%val2305 = load %mzone*, %mzone** %newz2Ptr
%res2306 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val2303, %mzone* %val2304, %mzone* %val2305)

; let value assignment
%rescopy2 = select i1 true, %String* %res2306, %String* %res2306
store %String* %rescopy2, %String** %rescopy2Ptr

%val2309 = load %mzone*, %mzone** %zone2Ptr
; tuple ref
%val2310 = getelementptr %mzone, %mzone* %val2309, i64 0, i32 4
%val2311 = load i8*, i8** %val2310
%val2312 = bitcast i8* %val2311 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val2312, {i64,i8*,i8*}* %val2312
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%null2315 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null2315, {i8*, i8*, void (i8*, i8*)*}** %null2315
store {i8*, i8*, void (i8*, i8*)*}** %f, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; promote local stack var allocations
%tzone2353 = load i8*, i8** %_impzPtr
%zone2354 = bitcast i8* %tzone2353 to %mzone*
%ifptr2343 = alloca i1
%ifptr2319 = alloca i1
; while loop
%val2320 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val2321 = icmp eq {i64,i8*,i8*}* %val2320, null
br i1 %val2321, label %then2319, label %else2319

then2319:
%res2322 = call ccc i1 @impc_false()
store i1 %res2322, i1* %ifptr2319
br label %ifcont2319

else2319:
%res2323 = call ccc i1 @impc_true()
store i1 %res2323, i1* %ifptr2319
br label %ifcont2319

ifcont2319:
%ifres2324 = load i1, i1* %ifptr2319

br i1 %ifres2324, label %loop2318, label %after2318

loop2318:
; do set!
%val2325 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val2326 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2325, i64 0, i32 1
%val2327 = load i8*, i8** %val2326
%val2328 = bitcast i8* %val2327 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val2328, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; apply closure 
%vval2329 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val2330 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval2329
%fPtr2331 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val2330, i32 0, i32 2
%ePtr2332 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val2330, i32 0, i32 1
%f2333 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr2331
%e2334 = load i8*, i8** %ePtr2332
%tzone2335 = load i8*, i8** %_impzPtr
%zone2336 = bitcast i8* %tzone2335 to %mzone*
%z2337 = bitcast %mzone* %zone2336 to i8*
tail call fastcc void %f2333(i8* %z2337, i8* %e2334)
; do set!
%val2339 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val2340 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2339, i64 0, i32 2
%val2341 = load i8*, i8** %val2340
%val2342 = bitcast i8* %val2341 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val2342, {i64,i8*,i8*}** %hookPtr
%val2344 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val2345 = icmp eq {i64,i8*,i8*}* %val2344, null
br i1 %val2345, label %then2343, label %else2343

then2343:
%res2346 = call ccc i1 @impc_false()
store i1 %res2346, i1* %ifptr2343
br label %ifcont2343

else2343:
%res2347 = call ccc i1 @impc_true()
store i1 %res2347, i1* %ifptr2343
br label %ifcont2343

ifcont2343:
%ifres2348 = load i1, i1* %ifptr2343

br i1 %ifres2348, label %loop2318, label %after2318

after2318:
%val2350 = load %mzone*, %mzone** %zone2Ptr
call ccc void @llvm_zone_destroy(%mzone* %val2350)
%val2352 = load %String*, %String** %rescopy2Ptr
ret %String* %val2352

else2279:
%zone2355 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone2355)
%zone_ptr2356 = bitcast %mzone* %zone2355 to i8*
store i8* %zone_ptr2356, i8** %_impzPtr
%tzone2471 = load i8*, i8** %_impzPtr
%zone2472 = bitcast i8* %tzone2471 to %mzone*

; let assign value to symbol res3
%res3Ptr = alloca %String*
%tzone2476 = load i8*, i8** %_impzPtr
%zone2477 = bitcast i8* %tzone2476 to %mzone*

; let assign value to symbol zone3
%zone3Ptr = alloca %mzone*
%tzone2479 = load i8*, i8** %_impzPtr
%zone2480 = bitcast i8* %tzone2479 to %mzone*

; let assign value to symbol newz3
%newz3Ptr = alloca %mzone*
%tzone2358 = load i8*, i8** %_impzPtr
%zone2359 = bitcast i8* %tzone2358 to %mzone*

; let assign value to symbol xx_t_mst_s_6
%xx_t_mst_s_6Ptr = alloca i8*
%dat2357 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_6 = select i1 true, i8* %dat2357, i8* %dat2357
store i8* %xx_t_mst_s_6, i8** %xx_t_mst_s_6Ptr

%val2360 = load i8*, i8** %xx_t_mst_s_6Ptr
%var2361 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var2362 = bitcast [10 x i8]* @gsxtmgraphics-pipeline92 to i8*

%val2363 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2360, i8* %var2361, i8* %var2362)
%val2364 = load i8*, i8** %xx_t_mst_s_6Ptr
%res2365 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2364)
%val2366 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2367 = getelementptr %XTMBone, %XTMBone* %val2366, i64 0, i32 0
%val2368 = load %String*, %String** %val2367
%res2369 = call fastcc %String* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0(%String* %val2368)
%res2370 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2365, %String* %res2369)
%tzone2372 = load i8*, i8** %_impzPtr
%zone2373 = bitcast i8* %tzone2372 to %mzone*

; let assign value to symbol xx_t_mst_s_7
%xx_t_mst_s_7Ptr = alloca i8*
%dat2371 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_7 = select i1 true, i8* %dat2371, i8* %dat2371
store i8* %xx_t_mst_s_7, i8** %xx_t_mst_s_7Ptr

%val2374 = load i8*, i8** %xx_t_mst_s_7Ptr
%var2375 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var2376 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val2377 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2374, i8* %var2375, i8* %var2376)
%val2378 = load i8*, i8** %xx_t_mst_s_7Ptr
%res2379 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2378)
%res2380 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2370, %String* %res2379)
%val2381 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2382 = getelementptr %XTMBone, %XTMBone* %val2381, i64 0, i32 1
%val2383 = load i32, i32* %val2382
%res2384 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val2383)
%res2385 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2380, %String* %res2384)
%tzone2387 = load i8*, i8** %_impzPtr
%zone2388 = bitcast i8* %tzone2387 to %mzone*

; let assign value to symbol xx_t_mst_s_8
%xx_t_mst_s_8Ptr = alloca i8*
%dat2386 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_8 = select i1 true, i8* %dat2386, i8* %dat2386
store i8* %xx_t_mst_s_8, i8** %xx_t_mst_s_8Ptr

%val2389 = load i8*, i8** %xx_t_mst_s_8Ptr
%var2390 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var2391 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val2392 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2389, i8* %var2390, i8* %var2391)
%val2393 = load i8*, i8** %xx_t_mst_s_8Ptr
%res2394 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2393)
%res2395 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2385, %String* %res2394)
%val2396 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2397 = getelementptr %XTMBone, %XTMBone* %val2396, i64 0, i32 2
%val2398 = load float*, float** %val2397
%res2399 = call fastcc %String* @toString_poly_W1N0cmluZyosZmxvYXQqXSo(float* %val2398)
%res2400 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2395, %String* %res2399)
%tzone2402 = load i8*, i8** %_impzPtr
%zone2403 = bitcast i8* %tzone2402 to %mzone*

; let assign value to symbol xx_t_mst_s_9
%xx_t_mst_s_9Ptr = alloca i8*
%dat2401 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_9 = select i1 true, i8* %dat2401, i8* %dat2401
store i8* %xx_t_mst_s_9, i8** %xx_t_mst_s_9Ptr

%val2404 = load i8*, i8** %xx_t_mst_s_9Ptr
%var2405 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var2406 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val2407 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2404, i8* %var2405, i8* %var2406)
%val2408 = load i8*, i8** %xx_t_mst_s_9Ptr
%res2409 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2408)
%res2410 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2400, %String* %res2409)
%val2411 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2412 = getelementptr %XTMBone, %XTMBone* %val2411, i64 0, i32 3
%val2413 = load float*, float** %val2412
%res2414 = call fastcc %String* @toString_poly_W1N0cmluZyosZmxvYXQqXSo(float* %val2413)
%res2415 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2410, %String* %res2414)
%tzone2417 = load i8*, i8** %_impzPtr
%zone2418 = bitcast i8* %tzone2417 to %mzone*

; let assign value to symbol xx_t_mst_s_10
%xx_t_mst_s_10Ptr = alloca i8*
%dat2416 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_10 = select i1 true, i8* %dat2416, i8* %dat2416
store i8* %xx_t_mst_s_10, i8** %xx_t_mst_s_10Ptr

%val2419 = load i8*, i8** %xx_t_mst_s_10Ptr
%var2420 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var2421 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val2422 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2419, i8* %var2420, i8* %var2421)
%val2423 = load i8*, i8** %xx_t_mst_s_10Ptr
%res2424 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2423)
%res2425 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2415, %String* %res2424)
%val2426 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2427 = getelementptr %XTMBone, %XTMBone* %val2426, i64 0, i32 4
%val2428 = load i32, i32* %val2427
%res2429 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val2428)
%res2430 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2425, %String* %res2429)
%tzone2432 = load i8*, i8** %_impzPtr
%zone2433 = bitcast i8* %tzone2432 to %mzone*

; let assign value to symbol xx_t_mst_s_11
%xx_t_mst_s_11Ptr = alloca i8*
%dat2431 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_11 = select i1 true, i8* %dat2431, i8* %dat2431
store i8* %xx_t_mst_s_11, i8** %xx_t_mst_s_11Ptr

%val2434 = load i8*, i8** %xx_t_mst_s_11Ptr
%var2435 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var2436 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val2437 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2434, i8* %var2435, i8* %var2436)
%val2438 = load i8*, i8** %xx_t_mst_s_11Ptr
%res2439 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2438)
%res2440 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2430, %String* %res2439)
%val2441 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2442 = getelementptr %XTMBone, %XTMBone* %val2441, i64 0, i32 5
%val2443 = load %XTMBone**, %XTMBone*** %val2442
%res2444 = call fastcc %String* @toString_poly_W1N0cmluZyosWFRNQm9uZSoqXSo(%XTMBone** %val2443)
%res2445 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2440, %String* %res2444)
%tzone2447 = load i8*, i8** %_impzPtr
%zone2448 = bitcast i8* %tzone2447 to %mzone*

; let assign value to symbol xx_t_mst_s_12
%xx_t_mst_s_12Ptr = alloca i8*
%dat2446 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_12 = select i1 true, i8* %dat2446, i8* %dat2446
store i8* %xx_t_mst_s_12, i8** %xx_t_mst_s_12Ptr

%val2449 = load i8*, i8** %xx_t_mst_s_12Ptr
%var2450 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var2451 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val2452 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2449, i8* %var2450, i8* %var2451)
%val2453 = load i8*, i8** %xx_t_mst_s_12Ptr
%res2454 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2453)
%res2455 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2445, %String* %res2454)
%val2456 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2457 = getelementptr %XTMBone, %XTMBone* %val2456, i64 0, i32 6
%val2458 = load %XTMBone*, %XTMBone** %val2457
%res2459 = call fastcc %String* @toString_poly_W1N0cmluZyosWFRNQm9uZSpdKg(%XTMBone* %val2458)
%res2460 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2455, %String* %res2459)
%tzone2462 = load i8*, i8** %_impzPtr
%zone2463 = bitcast i8* %tzone2462 to %mzone*

; let assign value to symbol xx_t_mst_s_13
%xx_t_mst_s_13Ptr = alloca i8*
%dat2461 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_13 = select i1 true, i8* %dat2461, i8* %dat2461
store i8* %xx_t_mst_s_13, i8** %xx_t_mst_s_13Ptr

%val2464 = load i8*, i8** %xx_t_mst_s_13Ptr
%var2465 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var2466 = bitcast [2 x i8]* @gsxtmgraphics-pipeline56 to i8*

%val2467 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2464, i8* %var2465, i8* %var2466)
%val2468 = load i8*, i8** %xx_t_mst_s_13Ptr
%res2469 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2468)
%res2470 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2460, %String* %res2469)

; let value assignment
%res3 = select i1 true, %String* %res2470, %String* %res2470
store %String* %res3, %String** %res3Ptr

%oldzone2473 = call %mzone* @llvm_pop_zone_stack()
%newzone2474 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr2475 = bitcast %mzone* %newzone2474 to i8*
store i8* %zone_ptr2475, i8** %_impzPtr

; let value assignment
%zone3 = select i1 true, %mzone* %oldzone2473, %mzone* %oldzone2473
store %mzone* %zone3, %mzone** %zone3Ptr

%res2478 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz3 = select i1 true, %mzone* %res2478, %mzone* %res2478
store %mzone* %newz3, %mzone** %newz3Ptr

%tzone2485 = load i8*, i8** %_impzPtr
%zone2486 = bitcast i8* %tzone2485 to %mzone*

; let assign value to symbol rescopy3
%rescopy3Ptr = alloca %String*
%tzone2491 = load i8*, i8** %_impzPtr
%zone2492 = bitcast i8* %tzone2491 to %mzone*

; let assign value to symbol hook_s_14
%hook_s_14Ptr = alloca {i64,i8*,i8*}*
%tzone2494 = load i8*, i8** %_impzPtr
%zone2495 = bitcast i8* %tzone2494 to %mzone*

; let assign value to symbol f_s_15
%f_s_15Ptr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val2481 = load %String*, %String** %res3Ptr
%val2482 = load %mzone*, %mzone** %zone3Ptr
%val2483 = load %mzone*, %mzone** %newz3Ptr
%res2484 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val2481, %mzone* %val2482, %mzone* %val2483)

; let value assignment
%rescopy3 = select i1 true, %String* %res2484, %String* %res2484
store %String* %rescopy3, %String** %rescopy3Ptr

%val2487 = load %mzone*, %mzone** %zone3Ptr
; tuple ref
%val2488 = getelementptr %mzone, %mzone* %val2487, i64 0, i32 4
%val2489 = load i8*, i8** %val2488
%val2490 = bitcast i8* %val2489 to {i64,i8*,i8*}*

; let value assignment
%hook_s_14 = select i1 true, {i64,i8*,i8*}* %val2490, {i64,i8*,i8*}* %val2490
store {i64,i8*,i8*}* %hook_s_14, {i64,i8*,i8*}** %hook_s_14Ptr

%null2493 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f_s_15 = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null2493, {i8*, i8*, void (i8*, i8*)*}** %null2493
store {i8*, i8*, void (i8*, i8*)*}** %f_s_15, {i8*, i8*, void (i8*, i8*)*}*** %f_s_15Ptr

; promote local stack var allocations
%tzone2531 = load i8*, i8** %_impzPtr
%zone2532 = bitcast i8* %tzone2531 to %mzone*
%ifptr2521 = alloca i1
%ifptr2497 = alloca i1
; while loop
%val2498 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_14Ptr
%val2499 = icmp eq {i64,i8*,i8*}* %val2498, null
br i1 %val2499, label %then2497, label %else2497

then2497:
%res2500 = call ccc i1 @impc_false()
store i1 %res2500, i1* %ifptr2497
br label %ifcont2497

else2497:
%res2501 = call ccc i1 @impc_true()
store i1 %res2501, i1* %ifptr2497
br label %ifcont2497

ifcont2497:
%ifres2502 = load i1, i1* %ifptr2497

br i1 %ifres2502, label %loop2496, label %after2496

loop2496:
; do set!
%val2503 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_14Ptr
; tuple ref
%val2504 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2503, i64 0, i32 1
%val2505 = load i8*, i8** %val2504
%val2506 = bitcast i8* %val2505 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val2506, {i8*, i8*, void (i8*, i8*)*}*** %f_s_15Ptr

; apply closure 
%vval2507 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %f_s_15Ptr
%val2508 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval2507
%fPtr2509 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val2508, i32 0, i32 2
%ePtr2510 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val2508, i32 0, i32 1
%f2511 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr2509
%e2512 = load i8*, i8** %ePtr2510
%tzone2513 = load i8*, i8** %_impzPtr
%zone2514 = bitcast i8* %tzone2513 to %mzone*
%z2515 = bitcast %mzone* %zone2514 to i8*
tail call fastcc void %f2511(i8* %z2515, i8* %e2512)
; do set!
%val2517 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_14Ptr
; tuple ref
%val2518 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2517, i64 0, i32 2
%val2519 = load i8*, i8** %val2518
%val2520 = bitcast i8* %val2519 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val2520, {i64,i8*,i8*}** %hook_s_14Ptr
%val2522 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_14Ptr
%val2523 = icmp eq {i64,i8*,i8*}* %val2522, null
br i1 %val2523, label %then2521, label %else2521

then2521:
%res2524 = call ccc i1 @impc_false()
store i1 %res2524, i1* %ifptr2521
br label %ifcont2521

else2521:
%res2525 = call ccc i1 @impc_true()
store i1 %res2525, i1* %ifptr2521
br label %ifcont2521

ifcont2521:
%ifres2526 = load i1, i1* %ifptr2521

br i1 %ifres2526, label %loop2496, label %after2496

after2496:
%val2528 = load %mzone*, %mzone** %zone3Ptr
call ccc void @llvm_zone_destroy(%mzone* %val2528)
%val2530 = load %String*, %String** %rescopy3Ptr
ret %String* %val2530
}
@gsxtmgraphics-pipeline94 = hidden constant [93 x i8] c"toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** @toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2552 = load i8*, i8** %_impzPtr
%zone2553 = bitcast i8* %tzone2552 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd
%dat_toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone2553, i64 8)
%toString_adhoc_W1N0cmluZyosWFRNQm9uZSpdPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd to { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}***
%tzone2533 = load i8*, i8** %_impzPtr
%zone2534 = bitcast i8* %tzone2533 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2534)
; malloc closure structure
%clsptr2535 = call i8* @llvm_zone_malloc(%mzone* %zone2534, i64 24)
%closure2536 = bitcast i8* %clsptr2535 to { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}*

; malloc environment structure
%envptr2537 = call i8* @llvm_zone_malloc(%mzone* %zone2534, i64 8)
%environment2538 = bitcast i8* %envptr2537 to {{i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}***}*

; malloc closure address table
%addytable2539 = call %clsvar* @new_address_table()
%var2540 = bitcast [40 x i8]* @gsxtmgraphics-pipeline93 to i8*
%var2541 = bitcast [46 x i8]* @gsxtmgraphics-pipeline89 to i8*
%addytable2542 = call %clsvar* @add_address_table(%mzone* %zone2534, i8* %var2540, i32 0, i8* %var2541, i32 3, %clsvar* %addytable2539)
%address-table2543 = bitcast %clsvar* %addytable2542 to i8*

; insert table, function and environment into closure struct
%closure.table2546 = getelementptr { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure2536, i32 0, i32 0
store i8* %address-table2543, i8** %closure.table2546
%closure.env2547 = getelementptr { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure2536, i32 0, i32 1
store i8* %envptr2537, i8** %closure.env2547
%closure.func2548 = getelementptr { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure2536, i32 0, i32 2
store %String* (i8*, i8*, %XTMBone*)* @toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd__2196, %String* (i8*, i8*, %XTMBone*)** %closure.func2548
%closure_size2549 = call i64 @llvm_zone_mark_size(%mzone* %zone2534)
call void @llvm_zone_ptr_set_size(i8* %clsptr2535, i64 %closure_size2549)
%wrapper_ptr2550 = call i8* @llvm_zone_malloc(%mzone* %zone2534, i64 8)
%closure_wrapper2551 = bitcast i8* %wrapper_ptr2550 to { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}**
store { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure2536, { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** %closure_wrapper2551

; let value assignment
%toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd = select i1 true, { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** %closure_wrapper2551, { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** %closure_wrapper2551
store { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** %toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd, { i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}*** %toString_adhoc_W1N0cmluZyosWFRNQm9uZSpdPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd
%tmp_envptr2545 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}***}* %environment2538, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}*** %toString_adhoc_W1N0cmluZyosWFRNQm9uZSpdPtr, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}**** %tmp_envptr2545


%val2554 = load {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}**, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}*** %toString_adhoc_W1N0cmluZyosWFRNQm9uZSpdPtr
ret {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** %val2554
}


@toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** @toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd(%XTMBone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %XTMBone*)*,  %String* (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd_native(%XTMBone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %XTMBone*)*,  %String* (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2555 = bitcast [93 x i8]* @gsxtmgraphics-pipeline94 to i8*
call i32 (i8*, ...) @printf(i8* %var2555)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMBone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %XTMBone*)*,  %String* (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMBone*}*
%arg_p_0 = getelementptr {%XTMBone*}, {%XTMBone*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMBone*, %XTMBone** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosWFRNQm9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %String* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %XTMBone*)*,  %String* (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline95 = hidden constant [31 x i8] c"print_poly_W3ZvaWQsZmxvYXQqXSo\00"
define dllexport fastcc void @print_poly_W3ZvaWQsZmxvYXQqXSo__2557(i8* %_impz,i8* %_impenv, float* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2558 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*)*}***}*
%print_poly_W3ZvaWQsZmxvYXQqXSoPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*)*}***}* %impenv, i32 0, i32 0
%print_poly_W3ZvaWQsZmxvYXQqXSoPtr = load {i8*, i8*, void (i8*, i8*, float*)*}***, {i8*, i8*, void (i8*, i8*, float*)*}**** %print_poly_W3ZvaWQsZmxvYXQqXSoPtr_

; setup arguments
%xPtr = alloca float*
store float* %x, float** %xPtr


%var2559 = bitcast [2 x i8]* @gsxtmgraphics-pipeline81 to i8*

%val2560 = call i32 (i8*, ...) @printf(i8* %var2559)
ret void
}
@gsxtmgraphics-pipeline96 = hidden constant [84 x i8] c"print_poly_W3ZvaWQsZmxvYXQqXSo Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*)*}** @print_poly_W3ZvaWQsZmxvYXQqXSo_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2581 = load i8*, i8** %_impzPtr
%zone2582 = bitcast i8* %tzone2581 to %mzone*

; let assign value to symbol print_poly_W3ZvaWQsZmxvYXQqXSo
%dat_print_poly_W3ZvaWQsZmxvYXQqXSo = call i8* @llvm_zone_malloc(%mzone* %zone2582, i64 8)
%print_poly_W3ZvaWQsZmxvYXQqXSoPtr = bitcast i8* %dat_print_poly_W3ZvaWQsZmxvYXQqXSo to { i8*, i8*, void (i8*, i8*, float*)*}***
%tzone2562 = load i8*, i8** %_impzPtr
%zone2563 = bitcast i8* %tzone2562 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2563)
; malloc closure structure
%clsptr2564 = call i8* @llvm_zone_malloc(%mzone* %zone2563, i64 24)
%closure2565 = bitcast i8* %clsptr2564 to { i8*, i8*, void (i8*, i8*, float*)*}*

; malloc environment structure
%envptr2566 = call i8* @llvm_zone_malloc(%mzone* %zone2563, i64 8)
%environment2567 = bitcast i8* %envptr2566 to {{i8*, i8*, void (i8*, i8*, float*)*}***}*

; malloc closure address table
%addytable2568 = call %clsvar* @new_address_table()
%var2569 = bitcast [31 x i8]* @gsxtmgraphics-pipeline95 to i8*
%var2570 = bitcast [39 x i8]* @gsxtmgraphics-pipeline12 to i8*
%addytable2571 = call %clsvar* @add_address_table(%mzone* %zone2563, i8* %var2569, i32 0, i8* %var2570, i32 3, %clsvar* %addytable2568)
%address-table2572 = bitcast %clsvar* %addytable2571 to i8*

; insert table, function and environment into closure struct
%closure.table2575 = getelementptr { i8*, i8*, void (i8*, i8*, float*)*}, { i8*, i8*, void (i8*, i8*, float*)*}* %closure2565, i32 0, i32 0
store i8* %address-table2572, i8** %closure.table2575
%closure.env2576 = getelementptr { i8*, i8*, void (i8*, i8*, float*)*}, { i8*, i8*, void (i8*, i8*, float*)*}* %closure2565, i32 0, i32 1
store i8* %envptr2566, i8** %closure.env2576
%closure.func2577 = getelementptr { i8*, i8*, void (i8*, i8*, float*)*}, { i8*, i8*, void (i8*, i8*, float*)*}* %closure2565, i32 0, i32 2
store void (i8*, i8*, float*)* @print_poly_W3ZvaWQsZmxvYXQqXSo__2557, void (i8*, i8*, float*)** %closure.func2577
%closure_size2578 = call i64 @llvm_zone_mark_size(%mzone* %zone2563)
call void @llvm_zone_ptr_set_size(i8* %clsptr2564, i64 %closure_size2578)
%wrapper_ptr2579 = call i8* @llvm_zone_malloc(%mzone* %zone2563, i64 8)
%closure_wrapper2580 = bitcast i8* %wrapper_ptr2579 to { i8*, i8*, void (i8*, i8*, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*)*}* %closure2565, { i8*, i8*, void (i8*, i8*, float*)*}** %closure_wrapper2580

; let value assignment
%print_poly_W3ZvaWQsZmxvYXQqXSo = select i1 true, { i8*, i8*, void (i8*, i8*, float*)*}** %closure_wrapper2580, { i8*, i8*, void (i8*, i8*, float*)*}** %closure_wrapper2580
store { i8*, i8*, void (i8*, i8*, float*)*}** %print_poly_W3ZvaWQsZmxvYXQqXSo, { i8*, i8*, void (i8*, i8*, float*)*}*** %print_poly_W3ZvaWQsZmxvYXQqXSoPtr

; add data to environment
; don't need to alloc for env var print_poly_W3ZvaWQsZmxvYXQqXSo
%tmp_envptr2574 = getelementptr {{i8*, i8*, void (i8*, i8*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*)*}***}* %environment2567, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*)*}*** %print_poly_W3ZvaWQsZmxvYXQqXSoPtr, {i8*, i8*, void (i8*, i8*, float*)*}**** %tmp_envptr2574


%val2583 = load {i8*, i8*, void (i8*, i8*, float*)*}**, {i8*, i8*, void (i8*, i8*, float*)*}*** %print_poly_W3ZvaWQsZmxvYXQqXSoPtr
ret {i8*, i8*, void (i8*, i8*, float*)*}** %val2583
}


@print_poly_W3ZvaWQsZmxvYXQqXSo_var = dllexport global [1 x i8*] [ i8* null ]

@print_poly_W3ZvaWQsZmxvYXQqXSo_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_poly_W3ZvaWQsZmxvYXQqXSo_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsZmxvYXQqXSo_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*)*}** @print_poly_W3ZvaWQsZmxvYXQqXSo_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_poly_W3ZvaWQsZmxvYXQqXSo_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_poly_W3ZvaWQsZmxvYXQqXSo_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsZmxvYXQqXSo_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_poly_W3ZvaWQsZmxvYXQqXSo(float* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsZmxvYXQqXSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*)*,  void (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0)
ret void
}


define dllexport ccc void @print_poly_W3ZvaWQsZmxvYXQqXSo_native(float* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsZmxvYXQqXSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*)*,  void (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0)
ret void
}


define dllexport ccc i8*  @print_poly_W3ZvaWQsZmxvYXQqXSo_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2584 = bitcast [84 x i8]* @gsxtmgraphics-pipeline96 to i8*
call i32 (i8*, ...) @printf(i8* %var2584)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsZmxvYXQqXSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*)*,  void (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_poly_W3ZvaWQsZmxvYXQqXSo_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*}*
%arg_p_0 = getelementptr {float*}, {float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsZmxvYXQqXSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*)*,  void (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline97 = hidden constant [35 x i8] c"print_poly_W3ZvaWQsWFRNQm9uZSoqXSo\00"
@gsxtmgraphics-pipeline98 = hidden constant [43 x i8] c"{i8*, i8*, void (i8*, i8*, %XTMBone**)*}**\00"
define dllexport fastcc void @print_poly_W3ZvaWQsWFRNQm9uZSoqXSo__2585(i8* %_impz,i8* %_impenv, %XTMBone** %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2586 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %XTMBone**)*}***}*
%print_poly_W3ZvaWQsWFRNQm9uZSoqXSoPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMBone**)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMBone**)*}***}* %impenv, i32 0, i32 0
%print_poly_W3ZvaWQsWFRNQm9uZSoqXSoPtr = load {i8*, i8*, void (i8*, i8*, %XTMBone**)*}***, {i8*, i8*, void (i8*, i8*, %XTMBone**)*}**** %print_poly_W3ZvaWQsWFRNQm9uZSoqXSoPtr_

; setup arguments
%xPtr = alloca %XTMBone**
store %XTMBone** %x, %XTMBone*** %xPtr


%var2587 = bitcast [2 x i8]* @gsxtmgraphics-pipeline81 to i8*

%val2588 = call i32 (i8*, ...) @printf(i8* %var2587)
ret void
}
@gsxtmgraphics-pipeline99 = hidden constant [88 x i8] c"print_poly_W3ZvaWQsWFRNQm9uZSoqXSo Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %XTMBone**)*}** @print_poly_W3ZvaWQsWFRNQm9uZSoqXSo_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2609 = load i8*, i8** %_impzPtr
%zone2610 = bitcast i8* %tzone2609 to %mzone*

; let assign value to symbol print_poly_W3ZvaWQsWFRNQm9uZSoqXSo
%dat_print_poly_W3ZvaWQsWFRNQm9uZSoqXSo = call i8* @llvm_zone_malloc(%mzone* %zone2610, i64 8)
%print_poly_W3ZvaWQsWFRNQm9uZSoqXSoPtr = bitcast i8* %dat_print_poly_W3ZvaWQsWFRNQm9uZSoqXSo to { i8*, i8*, void (i8*, i8*, %XTMBone**)*}***
%tzone2590 = load i8*, i8** %_impzPtr
%zone2591 = bitcast i8* %tzone2590 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2591)
; malloc closure structure
%clsptr2592 = call i8* @llvm_zone_malloc(%mzone* %zone2591, i64 24)
%closure2593 = bitcast i8* %clsptr2592 to { i8*, i8*, void (i8*, i8*, %XTMBone**)*}*

; malloc environment structure
%envptr2594 = call i8* @llvm_zone_malloc(%mzone* %zone2591, i64 8)
%environment2595 = bitcast i8* %envptr2594 to {{i8*, i8*, void (i8*, i8*, %XTMBone**)*}***}*

; malloc closure address table
%addytable2596 = call %clsvar* @new_address_table()
%var2597 = bitcast [35 x i8]* @gsxtmgraphics-pipeline97 to i8*
%var2598 = bitcast [43 x i8]* @gsxtmgraphics-pipeline98 to i8*
%addytable2599 = call %clsvar* @add_address_table(%mzone* %zone2591, i8* %var2597, i32 0, i8* %var2598, i32 3, %clsvar* %addytable2596)
%address-table2600 = bitcast %clsvar* %addytable2599 to i8*

; insert table, function and environment into closure struct
%closure.table2603 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMBone**)*}, { i8*, i8*, void (i8*, i8*, %XTMBone**)*}* %closure2593, i32 0, i32 0
store i8* %address-table2600, i8** %closure.table2603
%closure.env2604 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMBone**)*}, { i8*, i8*, void (i8*, i8*, %XTMBone**)*}* %closure2593, i32 0, i32 1
store i8* %envptr2594, i8** %closure.env2604
%closure.func2605 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMBone**)*}, { i8*, i8*, void (i8*, i8*, %XTMBone**)*}* %closure2593, i32 0, i32 2
store void (i8*, i8*, %XTMBone**)* @print_poly_W3ZvaWQsWFRNQm9uZSoqXSo__2585, void (i8*, i8*, %XTMBone**)** %closure.func2605
%closure_size2606 = call i64 @llvm_zone_mark_size(%mzone* %zone2591)
call void @llvm_zone_ptr_set_size(i8* %clsptr2592, i64 %closure_size2606)
%wrapper_ptr2607 = call i8* @llvm_zone_malloc(%mzone* %zone2591, i64 8)
%closure_wrapper2608 = bitcast i8* %wrapper_ptr2607 to { i8*, i8*, void (i8*, i8*, %XTMBone**)*}**
store { i8*, i8*, void (i8*, i8*, %XTMBone**)*}* %closure2593, { i8*, i8*, void (i8*, i8*, %XTMBone**)*}** %closure_wrapper2608

; let value assignment
%print_poly_W3ZvaWQsWFRNQm9uZSoqXSo = select i1 true, { i8*, i8*, void (i8*, i8*, %XTMBone**)*}** %closure_wrapper2608, { i8*, i8*, void (i8*, i8*, %XTMBone**)*}** %closure_wrapper2608
store { i8*, i8*, void (i8*, i8*, %XTMBone**)*}** %print_poly_W3ZvaWQsWFRNQm9uZSoqXSo, { i8*, i8*, void (i8*, i8*, %XTMBone**)*}*** %print_poly_W3ZvaWQsWFRNQm9uZSoqXSoPtr

; add data to environment
; don't need to alloc for env var print_poly_W3ZvaWQsWFRNQm9uZSoqXSo
%tmp_envptr2602 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMBone**)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMBone**)*}***}* %environment2595, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %XTMBone**)*}*** %print_poly_W3ZvaWQsWFRNQm9uZSoqXSoPtr, {i8*, i8*, void (i8*, i8*, %XTMBone**)*}**** %tmp_envptr2602


%val2611 = load {i8*, i8*, void (i8*, i8*, %XTMBone**)*}**, {i8*, i8*, void (i8*, i8*, %XTMBone**)*}*** %print_poly_W3ZvaWQsWFRNQm9uZSoqXSoPtr
ret {i8*, i8*, void (i8*, i8*, %XTMBone**)*}** %val2611
}


@print_poly_W3ZvaWQsWFRNQm9uZSoqXSo_var = dllexport global [1 x i8*] [ i8* null ]

@print_poly_W3ZvaWQsWFRNQm9uZSoqXSo_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_poly_W3ZvaWQsWFRNQm9uZSoqXSo_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsWFRNQm9uZSoqXSo_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %XTMBone**)*}** @print_poly_W3ZvaWQsWFRNQm9uZSoqXSo_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %XTMBone**)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_poly_W3ZvaWQsWFRNQm9uZSoqXSo_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_poly_W3ZvaWQsWFRNQm9uZSoqXSo_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsWFRNQm9uZSoqXSo_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_poly_W3ZvaWQsWFRNQm9uZSoqXSo(%XTMBone** %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsWFRNQm9uZSoqXSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMBone**)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMBone**)*}*, {i8*, i8*, void (i8*, i8*, %XTMBone**)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone**)*}, {i8*, i8*, void (i8*, i8*, %XTMBone**)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone**)*}, {i8*, i8*, void (i8*, i8*, %XTMBone**)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMBone**)*,  void (i8*, i8*, %XTMBone**)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMBone** %arg_0)
ret void
}


define dllexport ccc void @print_poly_W3ZvaWQsWFRNQm9uZSoqXSo_native(%XTMBone** %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsWFRNQm9uZSoqXSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMBone**)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMBone**)*}*, {i8*, i8*, void (i8*, i8*, %XTMBone**)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone**)*}, {i8*, i8*, void (i8*, i8*, %XTMBone**)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone**)*}, {i8*, i8*, void (i8*, i8*, %XTMBone**)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMBone**)*,  void (i8*, i8*, %XTMBone**)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMBone** %arg_0)
ret void
}


define dllexport ccc i8*  @print_poly_W3ZvaWQsWFRNQm9uZSoqXSo_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2612 = bitcast [88 x i8]* @gsxtmgraphics-pipeline99 to i8*
call i32 (i8*, ...) @printf(i8* %var2612)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMBone**
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsWFRNQm9uZSoqXSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMBone**)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMBone**)*}*, {i8*, i8*, void (i8*, i8*, %XTMBone**)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone**)*}, {i8*, i8*, void (i8*, i8*, %XTMBone**)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone**)*}, {i8*, i8*, void (i8*, i8*, %XTMBone**)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMBone**)*,  void (i8*, i8*, %XTMBone**)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMBone** %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_poly_W3ZvaWQsWFRNQm9uZSoqXSo_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMBone**}*
%arg_p_0 = getelementptr {%XTMBone**}, {%XTMBone**}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMBone**, %XTMBone*** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsWFRNQm9uZSoqXSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMBone**)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMBone**)*}*, {i8*, i8*, void (i8*, i8*, %XTMBone**)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone**)*}, {i8*, i8*, void (i8*, i8*, %XTMBone**)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone**)*}, {i8*, i8*, void (i8*, i8*, %XTMBone**)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMBone**)*,  void (i8*, i8*, %XTMBone**)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMBone** %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline100 = hidden constant [34 x i8] c"print_poly_W3ZvaWQsWFRNQm9uZSpdKg\00"
@gsxtmgraphics-pipeline101 = hidden constant [42 x i8] c"{i8*, i8*, void (i8*, i8*, %XTMBone*)*}**\00"
define dllexport fastcc void @print_poly_W3ZvaWQsWFRNQm9uZSpdKg__2613(i8* %_impz,i8* %_impenv, %XTMBone* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2614 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %XTMBone*)*}***}*
%print_poly_W3ZvaWQsWFRNQm9uZSpdKgPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMBone*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMBone*)*}***}* %impenv, i32 0, i32 0
%print_poly_W3ZvaWQsWFRNQm9uZSpdKgPtr = load {i8*, i8*, void (i8*, i8*, %XTMBone*)*}***, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**** %print_poly_W3ZvaWQsWFRNQm9uZSpdKgPtr_

; setup arguments
%xPtr = alloca %XTMBone*
store %XTMBone* %x, %XTMBone** %xPtr


%var2615 = bitcast [2 x i8]* @gsxtmgraphics-pipeline81 to i8*

%val2616 = call i32 (i8*, ...) @printf(i8* %var2615)
ret void
}
@gsxtmgraphics-pipeline102 = hidden constant [87 x i8] c"print_poly_W3ZvaWQsWFRNQm9uZSpdKg Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** @print_poly_W3ZvaWQsWFRNQm9uZSpdKg_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2637 = load i8*, i8** %_impzPtr
%zone2638 = bitcast i8* %tzone2637 to %mzone*

; let assign value to symbol print_poly_W3ZvaWQsWFRNQm9uZSpdKg
%dat_print_poly_W3ZvaWQsWFRNQm9uZSpdKg = call i8* @llvm_zone_malloc(%mzone* %zone2638, i64 8)
%print_poly_W3ZvaWQsWFRNQm9uZSpdKgPtr = bitcast i8* %dat_print_poly_W3ZvaWQsWFRNQm9uZSpdKg to { i8*, i8*, void (i8*, i8*, %XTMBone*)*}***
%tzone2618 = load i8*, i8** %_impzPtr
%zone2619 = bitcast i8* %tzone2618 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2619)
; malloc closure structure
%clsptr2620 = call i8* @llvm_zone_malloc(%mzone* %zone2619, i64 24)
%closure2621 = bitcast i8* %clsptr2620 to { i8*, i8*, void (i8*, i8*, %XTMBone*)*}*

; malloc environment structure
%envptr2622 = call i8* @llvm_zone_malloc(%mzone* %zone2619, i64 8)
%environment2623 = bitcast i8* %envptr2622 to {{i8*, i8*, void (i8*, i8*, %XTMBone*)*}***}*

; malloc closure address table
%addytable2624 = call %clsvar* @new_address_table()
%var2625 = bitcast [34 x i8]* @gsxtmgraphics-pipeline100 to i8*
%var2626 = bitcast [42 x i8]* @gsxtmgraphics-pipeline101 to i8*
%addytable2627 = call %clsvar* @add_address_table(%mzone* %zone2619, i8* %var2625, i32 0, i8* %var2626, i32 3, %clsvar* %addytable2624)
%address-table2628 = bitcast %clsvar* %addytable2627 to i8*

; insert table, function and environment into closure struct
%closure.table2631 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMBone*)*}, { i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure2621, i32 0, i32 0
store i8* %address-table2628, i8** %closure.table2631
%closure.env2632 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMBone*)*}, { i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure2621, i32 0, i32 1
store i8* %envptr2622, i8** %closure.env2632
%closure.func2633 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMBone*)*}, { i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure2621, i32 0, i32 2
store void (i8*, i8*, %XTMBone*)* @print_poly_W3ZvaWQsWFRNQm9uZSpdKg__2613, void (i8*, i8*, %XTMBone*)** %closure.func2633
%closure_size2634 = call i64 @llvm_zone_mark_size(%mzone* %zone2619)
call void @llvm_zone_ptr_set_size(i8* %clsptr2620, i64 %closure_size2634)
%wrapper_ptr2635 = call i8* @llvm_zone_malloc(%mzone* %zone2619, i64 8)
%closure_wrapper2636 = bitcast i8* %wrapper_ptr2635 to { i8*, i8*, void (i8*, i8*, %XTMBone*)*}**
store { i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure2621, { i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure_wrapper2636

; let value assignment
%print_poly_W3ZvaWQsWFRNQm9uZSpdKg = select i1 true, { i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure_wrapper2636, { i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure_wrapper2636
store { i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %print_poly_W3ZvaWQsWFRNQm9uZSpdKg, { i8*, i8*, void (i8*, i8*, %XTMBone*)*}*** %print_poly_W3ZvaWQsWFRNQm9uZSpdKgPtr

; add data to environment
; don't need to alloc for env var print_poly_W3ZvaWQsWFRNQm9uZSpdKg
%tmp_envptr2630 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMBone*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMBone*)*}***}* %environment2623, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %XTMBone*)*}*** %print_poly_W3ZvaWQsWFRNQm9uZSpdKgPtr, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**** %tmp_envptr2630


%val2639 = load {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}*** %print_poly_W3ZvaWQsWFRNQm9uZSpdKgPtr
ret {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %val2639
}


@print_poly_W3ZvaWQsWFRNQm9uZSpdKg_var = dllexport global [1 x i8*] [ i8* null ]

@print_poly_W3ZvaWQsWFRNQm9uZSpdKg_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_poly_W3ZvaWQsWFRNQm9uZSpdKg_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsWFRNQm9uZSpdKg_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** @print_poly_W3ZvaWQsWFRNQm9uZSpdKg_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_poly_W3ZvaWQsWFRNQm9uZSpdKg_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_poly_W3ZvaWQsWFRNQm9uZSpdKg_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsWFRNQm9uZSpdKg_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_poly_W3ZvaWQsWFRNQm9uZSpdKg(%XTMBone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsWFRNQm9uZSpdKg_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMBone*)*,  void (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
ret void
}


define dllexport ccc void @print_poly_W3ZvaWQsWFRNQm9uZSpdKg_native(%XTMBone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsWFRNQm9uZSpdKg_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMBone*)*,  void (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
ret void
}


define dllexport ccc i8*  @print_poly_W3ZvaWQsWFRNQm9uZSpdKg_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2640 = bitcast [87 x i8]* @gsxtmgraphics-pipeline102 to i8*
call i32 (i8*, ...) @printf(i8* %var2640)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMBone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsWFRNQm9uZSpdKg_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMBone*)*,  void (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_poly_W3ZvaWQsWFRNQm9uZSpdKg_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMBone*}*
%arg_p_0 = getelementptr {%XTMBone*}, {%XTMBone*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMBone*, %XTMBone** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsWFRNQm9uZSpdKg_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMBone*)*,  void (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline103 = hidden constant [33 x i8] c"print_adhoc_W3ZvaWQsWFRNQm9uZSpd\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsWFRNQm9uZSpd__2556(i8* %_impz,i8* %_impenv, %XTMBone* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2641 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %XTMBone*)*}***}*
%print_adhoc_W3ZvaWQsWFRNQm9uZSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMBone*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMBone*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsWFRNQm9uZSpdPtr = load {i8*, i8*, void (i8*, i8*, %XTMBone*)*}***, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**** %print_adhoc_W3ZvaWQsWFRNQm9uZSpdPtr_

; setup arguments
%xPtr = alloca %XTMBone*
store %XTMBone* %x, %XTMBone** %xPtr


%val2643 = load %XTMBone*, %XTMBone** %xPtr
%val2644 = icmp eq %XTMBone* %val2643, null
br i1 %val2644, label %then2642, label %else2642

then2642:
%var2645 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var2646 = bitcast [15 x i8]* @gsxtmgraphics-pipeline91 to i8*

%val2647 = call i32 (i8*, ...) @printf(i8* %var2645, i8* %var2646)
br label %ifcont2642

else2642:
%var2649 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var2650 = bitcast [10 x i8]* @gsxtmgraphics-pipeline92 to i8*

%val2651 = call i32 (i8*, ...) @printf(i8* %var2649, i8* %var2650)
%val2652 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2653 = getelementptr %XTMBone, %XTMBone* %val2652, i64 0, i32 0
%val2654 = load %String*, %String** %val2653
call fastcc void @print_adhoc_W3ZvaWQsU3RyaW5nKl0(%String* %val2654)
%var2656 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var2657 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val2658 = call i32 (i8*, ...) @printf(i8* %var2656, i8* %var2657)
%val2659 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2660 = getelementptr %XTMBone, %XTMBone* %val2659, i64 0, i32 1
%val2661 = load i32, i32* %val2660
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val2661)
%var2663 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var2664 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val2665 = call i32 (i8*, ...) @printf(i8* %var2663, i8* %var2664)
%val2666 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2667 = getelementptr %XTMBone, %XTMBone* %val2666, i64 0, i32 2
%val2668 = load float*, float** %val2667
call fastcc void @print_poly_W3ZvaWQsZmxvYXQqXSo(float* %val2668)
%var2670 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var2671 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val2672 = call i32 (i8*, ...) @printf(i8* %var2670, i8* %var2671)
%val2673 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2674 = getelementptr %XTMBone, %XTMBone* %val2673, i64 0, i32 3
%val2675 = load float*, float** %val2674
call fastcc void @print_poly_W3ZvaWQsZmxvYXQqXSo(float* %val2675)
%var2677 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var2678 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val2679 = call i32 (i8*, ...) @printf(i8* %var2677, i8* %var2678)
%val2680 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2681 = getelementptr %XTMBone, %XTMBone* %val2680, i64 0, i32 4
%val2682 = load i32, i32* %val2681
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val2682)
%var2684 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var2685 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val2686 = call i32 (i8*, ...) @printf(i8* %var2684, i8* %var2685)
%val2687 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2688 = getelementptr %XTMBone, %XTMBone* %val2687, i64 0, i32 5
%val2689 = load %XTMBone**, %XTMBone*** %val2688
call fastcc void @print_poly_W3ZvaWQsWFRNQm9uZSoqXSo(%XTMBone** %val2689)
%var2691 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var2692 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val2693 = call i32 (i8*, ...) @printf(i8* %var2691, i8* %var2692)
%val2694 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2695 = getelementptr %XTMBone, %XTMBone* %val2694, i64 0, i32 6
%val2696 = load %XTMBone*, %XTMBone** %val2695
call fastcc void @print_poly_W3ZvaWQsWFRNQm9uZSpdKg(%XTMBone* %val2696)
%var2698 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var2699 = bitcast [2 x i8]* @gsxtmgraphics-pipeline56 to i8*

%val2700 = call i32 (i8*, ...) @printf(i8* %var2698, i8* %var2699)
br label %ifcont2642

ifcont2642:
ret void
}
@gsxtmgraphics-pipeline104 = hidden constant [86 x i8] c"print_adhoc_W3ZvaWQsWFRNQm9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** @print_adhoc_W3ZvaWQsWFRNQm9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2722 = load i8*, i8** %_impzPtr
%zone2723 = bitcast i8* %tzone2722 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsWFRNQm9uZSpd
%dat_print_adhoc_W3ZvaWQsWFRNQm9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone2723, i64 8)
%print_adhoc_W3ZvaWQsWFRNQm9uZSpdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsWFRNQm9uZSpd to { i8*, i8*, void (i8*, i8*, %XTMBone*)*}***
%tzone2703 = load i8*, i8** %_impzPtr
%zone2704 = bitcast i8* %tzone2703 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2704)
; malloc closure structure
%clsptr2705 = call i8* @llvm_zone_malloc(%mzone* %zone2704, i64 24)
%closure2706 = bitcast i8* %clsptr2705 to { i8*, i8*, void (i8*, i8*, %XTMBone*)*}*

; malloc environment structure
%envptr2707 = call i8* @llvm_zone_malloc(%mzone* %zone2704, i64 8)
%environment2708 = bitcast i8* %envptr2707 to {{i8*, i8*, void (i8*, i8*, %XTMBone*)*}***}*

; malloc closure address table
%addytable2709 = call %clsvar* @new_address_table()
%var2710 = bitcast [33 x i8]* @gsxtmgraphics-pipeline103 to i8*
%var2711 = bitcast [42 x i8]* @gsxtmgraphics-pipeline101 to i8*
%addytable2712 = call %clsvar* @add_address_table(%mzone* %zone2704, i8* %var2710, i32 0, i8* %var2711, i32 3, %clsvar* %addytable2709)
%address-table2713 = bitcast %clsvar* %addytable2712 to i8*

; insert table, function and environment into closure struct
%closure.table2716 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMBone*)*}, { i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure2706, i32 0, i32 0
store i8* %address-table2713, i8** %closure.table2716
%closure.env2717 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMBone*)*}, { i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure2706, i32 0, i32 1
store i8* %envptr2707, i8** %closure.env2717
%closure.func2718 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMBone*)*}, { i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure2706, i32 0, i32 2
store void (i8*, i8*, %XTMBone*)* @print_adhoc_W3ZvaWQsWFRNQm9uZSpd__2556, void (i8*, i8*, %XTMBone*)** %closure.func2718
%closure_size2719 = call i64 @llvm_zone_mark_size(%mzone* %zone2704)
call void @llvm_zone_ptr_set_size(i8* %clsptr2705, i64 %closure_size2719)
%wrapper_ptr2720 = call i8* @llvm_zone_malloc(%mzone* %zone2704, i64 8)
%closure_wrapper2721 = bitcast i8* %wrapper_ptr2720 to { i8*, i8*, void (i8*, i8*, %XTMBone*)*}**
store { i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure2706, { i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure_wrapper2721

; let value assignment
%print_adhoc_W3ZvaWQsWFRNQm9uZSpd = select i1 true, { i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure_wrapper2721, { i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure_wrapper2721
store { i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %print_adhoc_W3ZvaWQsWFRNQm9uZSpd, { i8*, i8*, void (i8*, i8*, %XTMBone*)*}*** %print_adhoc_W3ZvaWQsWFRNQm9uZSpdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsWFRNQm9uZSpd
%tmp_envptr2715 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMBone*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMBone*)*}***}* %environment2708, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %XTMBone*)*}*** %print_adhoc_W3ZvaWQsWFRNQm9uZSpdPtr, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**** %tmp_envptr2715


%val2724 = load {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}*** %print_adhoc_W3ZvaWQsWFRNQm9uZSpdPtr
ret {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %val2724
}


@print_adhoc_W3ZvaWQsWFRNQm9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsWFRNQm9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsWFRNQm9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNQm9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** @print_adhoc_W3ZvaWQsWFRNQm9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNQm9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsWFRNQm9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNQm9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsWFRNQm9uZSpd(%XTMBone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNQm9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMBone*)*,  void (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsWFRNQm9uZSpd_native(%XTMBone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNQm9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMBone*)*,  void (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsWFRNQm9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2725 = bitcast [86 x i8]* @gsxtmgraphics-pipeline104 to i8*
call i32 (i8*, ...) @printf(i8* %var2725)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMBone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNQm9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMBone*)*,  void (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsWFRNQm9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMBone*}*
%arg_p_0 = getelementptr {%XTMBone*}, {%XTMBone*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMBone*, %XTMBone** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNQm9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMBone*)*,  void (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline105 = hidden constant [97 x i8] c"XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ\00"
@gsxtmgraphics-pipeline106 = hidden constant [94 x i8] c"{i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**\00"
define dllexport fastcc %XTMBone @XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ__2726(i8* %_impz,i8* %_impenv, %String* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, %XTMBone** %arg_5, %XTMBone* %arg_6) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2727 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}*
%XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQPtr_ = getelementptr {{i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}, {{i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}* %impenv, i32 0, i32 0
%XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQPtr = load {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***, {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**** %XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQPtr_

; setup arguments
%arg_0Ptr = alloca %String*
store %String* %arg_0, %String** %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca float*
store float* %arg_2, float** %arg_2Ptr
%arg_3Ptr = alloca float*
store float* %arg_3, float** %arg_3Ptr
%arg_4Ptr = alloca i32
store i32 %arg_4, i32* %arg_4Ptr
%arg_5Ptr = alloca %XTMBone**
store %XTMBone** %arg_5, %XTMBone*** %arg_5Ptr
%arg_6Ptr = alloca %XTMBone*
store %XTMBone* %arg_6, %XTMBone** %arg_6Ptr


%tzone2729 = load i8*, i8** %_impzPtr
%zone2730 = bitcast i8* %tzone2729 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMBone*
%dat2728 = alloca %XTMBone, align 16

; let value assignment
%obj = select i1 true, %XTMBone* %dat2728, %XTMBone* %dat2728
store %XTMBone* %obj, %XTMBone** %objPtr

%val2731 = load %XTMBone*, %XTMBone** %objPtr
%val2732 = load %String*, %String** %arg_0Ptr
; set tuple
%val2733 = getelementptr %XTMBone, %XTMBone* %val2731, i64 0, i32 0
store %String* %val2732, %String** %val2733
%val2734 = load %XTMBone*, %XTMBone** %objPtr
%val2735 = load i32, i32* %arg_1Ptr
; set tuple
%val2736 = getelementptr %XTMBone, %XTMBone* %val2734, i64 0, i32 1
store i32 %val2735, i32* %val2736
%val2737 = load %XTMBone*, %XTMBone** %objPtr
%val2738 = load float*, float** %arg_2Ptr
; set tuple
%val2739 = getelementptr %XTMBone, %XTMBone* %val2737, i64 0, i32 2
store float* %val2738, float** %val2739
%val2740 = load %XTMBone*, %XTMBone** %objPtr
%val2741 = load float*, float** %arg_3Ptr
; set tuple
%val2742 = getelementptr %XTMBone, %XTMBone* %val2740, i64 0, i32 3
store float* %val2741, float** %val2742
%val2743 = load %XTMBone*, %XTMBone** %objPtr
%val2744 = load i32, i32* %arg_4Ptr
; set tuple
%val2745 = getelementptr %XTMBone, %XTMBone* %val2743, i64 0, i32 4
store i32 %val2744, i32* %val2745
%val2746 = load %XTMBone*, %XTMBone** %objPtr
%val2747 = load %XTMBone**, %XTMBone*** %arg_5Ptr
; set tuple
%val2748 = getelementptr %XTMBone, %XTMBone* %val2746, i64 0, i32 5
store %XTMBone** %val2747, %XTMBone*** %val2748
%val2749 = load %XTMBone*, %XTMBone** %objPtr
%val2750 = load %XTMBone*, %XTMBone** %arg_6Ptr
; set tuple
%val2751 = getelementptr %XTMBone, %XTMBone* %val2749, i64 0, i32 6
store %XTMBone* %val2750, %XTMBone** %val2751
%val2752 = load %XTMBone*, %XTMBone** %objPtr
; pointer ref
%val2753 = getelementptr %XTMBone, %XTMBone* %val2752, i64 0
%val2754 = load %XTMBone, %XTMBone* %val2753
ret %XTMBone %val2754
}
@gsxtmgraphics-pipeline107 = hidden constant [150 x i8] c"XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** @XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2774 = load i8*, i8** %_impzPtr
%zone2775 = bitcast i8* %tzone2774 to %mzone*

; let assign value to symbol XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ
%dat_XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2775, i64 8)
%XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQPtr = bitcast i8* %dat_XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ to { i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***
%tzone2755 = load i8*, i8** %_impzPtr
%zone2756 = bitcast i8* %tzone2755 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2756)
; malloc closure structure
%clsptr2757 = call i8* @llvm_zone_malloc(%mzone* %zone2756, i64 24)
%closure2758 = bitcast i8* %clsptr2757 to { i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*

; malloc environment structure
%envptr2759 = call i8* @llvm_zone_malloc(%mzone* %zone2756, i64 8)
%environment2760 = bitcast i8* %envptr2759 to {{i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}*

; malloc closure address table
%addytable2761 = call %clsvar* @new_address_table()
%var2762 = bitcast [97 x i8]* @gsxtmgraphics-pipeline105 to i8*
%var2763 = bitcast [94 x i8]* @gsxtmgraphics-pipeline106 to i8*
%addytable2764 = call %clsvar* @add_address_table(%mzone* %zone2756, i8* %var2762, i32 0, i8* %var2763, i32 3, %clsvar* %addytable2761)
%address-table2765 = bitcast %clsvar* %addytable2764 to i8*

; insert table, function and environment into closure struct
%closure.table2768 = getelementptr { i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, { i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure2758, i32 0, i32 0
store i8* %address-table2765, i8** %closure.table2768
%closure.env2769 = getelementptr { i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, { i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure2758, i32 0, i32 1
store i8* %envptr2759, i8** %closure.env2769
%closure.func2770 = getelementptr { i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, { i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure2758, i32 0, i32 2
store %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)* @XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ__2726, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)** %closure.func2770
%closure_size2771 = call i64 @llvm_zone_mark_size(%mzone* %zone2756)
call void @llvm_zone_ptr_set_size(i8* %clsptr2757, i64 %closure_size2771)
%wrapper_ptr2772 = call i8* @llvm_zone_malloc(%mzone* %zone2756, i64 8)
%closure_wrapper2773 = bitcast i8* %wrapper_ptr2772 to { i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**
store { i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure2758, { i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_wrapper2773

; let value assignment
%XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ = select i1 true, { i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_wrapper2773, { i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_wrapper2773
store { i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ, { i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*** %XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQPtr

; add data to environment
; don't need to alloc for env var XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ
%tmp_envptr2767 = getelementptr {{i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}, {{i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}***}* %environment2760, i32 0, i32 0
store {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*** %XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQPtr, {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**** %tmp_envptr2767


%val2776 = load {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**, {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*** %XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQPtr
ret {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %val2776
}


@XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** @XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMBone @XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ(%String* %arg_0,i32 %arg_1,float* %arg_2,float* %arg_3,i32 %arg_4,%XTMBone** %arg_5,%XTMBone* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**
%closure = load {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*, {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*,  %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, %XTMBone** %arg_5, %XTMBone* %arg_6)
ret %XTMBone %result
}


define dllexport ccc %XTMBone @XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ_native(%String* %arg_0,i32 %arg_1,float* %arg_2,float* %arg_3,i32 %arg_4,%XTMBone** %arg_5,%XTMBone* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**
%closure = load {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*, {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*,  %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, %XTMBone** %arg_5, %XTMBone* %arg_6)
ret %XTMBone %result
}


define dllexport ccc void @XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}*
%arg_p_0 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
%arg_p_5 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 5
%arg_5 = load %XTMBone**, %XTMBone*** %arg_p_5
%arg_p_6 = getelementptr {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}, {%String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*}* %fstruct, i32 0, i32 6
%arg_6 = load %XTMBone*, %XTMBone** %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMBone_val_adhoc_W1hUTUJvbmUsU3RyaW5nKixpMzIsZmxvYXQqLGZsb2F0KixpMzIsWFRNQm9uZSoqLFhUTUJvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}**
%closure = load {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}*, {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}, {i8*, i8*, %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)*,  %XTMBone (i8*, i8*, %String*, i32, float*, float*, i32, %XTMBone**, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, %XTMBone** %arg_5, %XTMBone* %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline108 = hidden constant [39 x i8] c"hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ\00"
@gsxtmgraphics-pipeline109 = hidden constant [47 x i8] c"{i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}**\00"
define dllexport fastcc %XTMBone* @hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ__2784(i8* %_impz,i8* %_impenv, %XTMBone* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2785 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}***}*
%hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQPtr_ = getelementptr {{i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}***}, {{i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQPtr = load {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}***, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}**** %hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQPtr_

; setup arguments
%xPtr = alloca %XTMBone*
store %XTMBone* %x, %XTMBone** %xPtr


%tzone2788 = load i8*, i8** %_impzPtr
%zone2789 = bitcast i8* %tzone2788 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMBone*
%dat2786 = call i8* @malloc(i64 56)
call i8* @memset(i8* %dat2786, i32 0, i64 56)
%val2787 = bitcast i8* %dat2786 to %XTMBone*

; let value assignment
%obj = select i1 true, %XTMBone* %val2787, %XTMBone* %val2787
store %XTMBone* %obj, %XTMBone** %objPtr

; promote local stack var allocations
%tzone2857 = load i8*, i8** %_impzPtr
%zone2858 = bitcast i8* %tzone2857 to %mzone*
%ifptr2831 = alloca %XTMBone*
%ifptr2832 = alloca i1
%ifptr2790 = alloca %String*
%ifptr2791 = alloca i1
%val2792 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2793 = getelementptr %XTMBone, %XTMBone* %val2792, i64 0, i32 0
%val2794 = load %String*, %String** %val2793
%val2795 = icmp eq %String* %val2794, null
br i1 %val2795, label %then2791, label %else2791

then2791:
%res2796 = call ccc i1 @impc_false()
store i1 %res2796, i1* %ifptr2791
br label %ifcont2791

else2791:
%res2797 = call ccc i1 @impc_true()
store i1 %res2797, i1* %ifptr2791
br label %ifcont2791

ifcont2791:
%ifres2798 = load i1, i1* %ifptr2791

br i1 %ifres2798, label %then2790, label %else2790

then2790:
%val2799 = load %XTMBone*, %XTMBone** %objPtr
%val2800 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2801 = getelementptr %XTMBone, %XTMBone* %val2800, i64 0, i32 0
%val2802 = load %String*, %String** %val2801
%res2803 = call fastcc %String* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0(%String* %val2802)
; set tuple
%val2804 = getelementptr %XTMBone, %XTMBone* %val2799, i64 0, i32 0
store %String* %res2803, %String** %val2804
store %String* %res2803, %String** %ifptr2790
br label %ifcont2790

else2790:
br label %ifcont2790

ifcont2790:
%ifres2805 = load %String*, %String** %ifptr2790

%val2806 = load %XTMBone*, %XTMBone** %objPtr
%val2807 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2808 = getelementptr %XTMBone, %XTMBone* %val2807, i64 0, i32 1
%val2809 = load i32, i32* %val2808
; set tuple
%val2810 = getelementptr %XTMBone, %XTMBone* %val2806, i64 0, i32 1
store i32 %val2809, i32* %val2810
%val2811 = load %XTMBone*, %XTMBone** %objPtr
%val2812 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2813 = getelementptr %XTMBone, %XTMBone* %val2812, i64 0, i32 2
%val2814 = load float*, float** %val2813
; set tuple
%val2815 = getelementptr %XTMBone, %XTMBone* %val2811, i64 0, i32 2
store float* %val2814, float** %val2815
%val2816 = load %XTMBone*, %XTMBone** %objPtr
%val2817 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2818 = getelementptr %XTMBone, %XTMBone* %val2817, i64 0, i32 3
%val2819 = load float*, float** %val2818
; set tuple
%val2820 = getelementptr %XTMBone, %XTMBone* %val2816, i64 0, i32 3
store float* %val2819, float** %val2820
%val2821 = load %XTMBone*, %XTMBone** %objPtr
%val2822 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2823 = getelementptr %XTMBone, %XTMBone* %val2822, i64 0, i32 4
%val2824 = load i32, i32* %val2823
; set tuple
%val2825 = getelementptr %XTMBone, %XTMBone* %val2821, i64 0, i32 4
store i32 %val2824, i32* %val2825
%val2826 = load %XTMBone*, %XTMBone** %objPtr
%val2827 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2828 = getelementptr %XTMBone, %XTMBone* %val2827, i64 0, i32 5
%val2829 = load %XTMBone**, %XTMBone*** %val2828
; set tuple
%val2830 = getelementptr %XTMBone, %XTMBone* %val2826, i64 0, i32 5
store %XTMBone** %val2829, %XTMBone*** %val2830
%val2833 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2834 = getelementptr %XTMBone, %XTMBone* %val2833, i64 0, i32 6
%val2835 = load %XTMBone*, %XTMBone** %val2834
%val2836 = icmp eq %XTMBone* %val2835, null
br i1 %val2836, label %then2832, label %else2832

then2832:
%res2837 = call ccc i1 @impc_false()
store i1 %res2837, i1* %ifptr2832
br label %ifcont2832

else2832:
%res2838 = call ccc i1 @impc_true()
store i1 %res2838, i1* %ifptr2832
br label %ifcont2832

ifcont2832:
%ifres2839 = load i1, i1* %ifptr2832

br i1 %ifres2839, label %then2831, label %else2831

then2831:
%val2840 = load %XTMBone*, %XTMBone** %objPtr
%val2841 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2842 = getelementptr %XTMBone, %XTMBone* %val2841, i64 0, i32 6
%val2843 = load %XTMBone*, %XTMBone** %val2842

; apply closure 
%vval2844 = load {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}**, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}*** %hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQPtr
%val2845 = load {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}*,{i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}** %vval2844
%fPtr2846 = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}* %val2845, i32 0, i32 2
%ePtr2847 = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}* %val2845, i32 0, i32 1
%f2848 = load %XTMBone* (i8*, i8*, %XTMBone*)*, %XTMBone* (i8*, i8*, %XTMBone*)** %fPtr2846
%e2849 = load i8*, i8** %ePtr2847
%tzone2850 = load i8*, i8** %_impzPtr
%zone2851 = bitcast i8* %tzone2850 to %mzone*
%z2852 = bitcast %mzone* %zone2851 to i8*
%result2853 = tail call fastcc %XTMBone* %f2848(i8* %z2852, i8* %e2849, %XTMBone* %val2843)
; set tuple
%val2854 = getelementptr %XTMBone, %XTMBone* %val2840, i64 0, i32 6
store %XTMBone* %result2853, %XTMBone** %val2854
store %XTMBone* %result2853, %XTMBone** %ifptr2831
br label %ifcont2831

else2831:
br label %ifcont2831

ifcont2831:
%ifres2855 = load %XTMBone*, %XTMBone** %ifptr2831

%val2856 = load %XTMBone*, %XTMBone** %objPtr
ret %XTMBone* %val2856
}
@gsxtmgraphics-pipeline110 = hidden constant [92 x i8] c"hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}** @hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2878 = load i8*, i8** %_impzPtr
%zone2879 = bitcast i8* %tzone2878 to %mzone*

; let assign value to symbol hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ
%dat_hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2879, i64 8)
%hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQPtr = bitcast i8* %dat_hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ to { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}***
%tzone2859 = load i8*, i8** %_impzPtr
%zone2860 = bitcast i8* %tzone2859 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2860)
; malloc closure structure
%clsptr2861 = call i8* @llvm_zone_malloc(%mzone* %zone2860, i64 24)
%closure2862 = bitcast i8* %clsptr2861 to { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}*

; malloc environment structure
%envptr2863 = call i8* @llvm_zone_malloc(%mzone* %zone2860, i64 8)
%environment2864 = bitcast i8* %envptr2863 to {{i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}***}*

; malloc closure address table
%addytable2865 = call %clsvar* @new_address_table()
%var2866 = bitcast [39 x i8]* @gsxtmgraphics-pipeline108 to i8*
%var2867 = bitcast [47 x i8]* @gsxtmgraphics-pipeline109 to i8*
%addytable2868 = call %clsvar* @add_address_table(%mzone* %zone2860, i8* %var2866, i32 0, i8* %var2867, i32 3, %clsvar* %addytable2865)
%address-table2869 = bitcast %clsvar* %addytable2868 to i8*

; insert table, function and environment into closure struct
%closure.table2872 = getelementptr { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}, { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}* %closure2862, i32 0, i32 0
store i8* %address-table2869, i8** %closure.table2872
%closure.env2873 = getelementptr { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}, { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}* %closure2862, i32 0, i32 1
store i8* %envptr2863, i8** %closure.env2873
%closure.func2874 = getelementptr { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}, { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}* %closure2862, i32 0, i32 2
store %XTMBone* (i8*, i8*, %XTMBone*)* @hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ__2784, %XTMBone* (i8*, i8*, %XTMBone*)** %closure.func2874
%closure_size2875 = call i64 @llvm_zone_mark_size(%mzone* %zone2860)
call void @llvm_zone_ptr_set_size(i8* %clsptr2861, i64 %closure_size2875)
%wrapper_ptr2876 = call i8* @llvm_zone_malloc(%mzone* %zone2860, i64 8)
%closure_wrapper2877 = bitcast i8* %wrapper_ptr2876 to { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}**
store { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}* %closure2862, { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}** %closure_wrapper2877

; let value assignment
%hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ = select i1 true, { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}** %closure_wrapper2877, { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}** %closure_wrapper2877
store { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}** %hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ, { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}*** %hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ
%tmp_envptr2871 = getelementptr {{i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}***}, {{i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}***}* %environment2864, i32 0, i32 0
store {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}*** %hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQPtr, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}**** %tmp_envptr2871


%val2880 = load {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}**, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}*** %hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQPtr
ret {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}** %val2880
}


@hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}** @hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMBone* @hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ(%XTMBone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone* (i8*, i8*, %XTMBone*)*,  %XTMBone* (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone* %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
ret %XTMBone* %result
}


define dllexport ccc %XTMBone* @hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ_native(%XTMBone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone* (i8*, i8*, %XTMBone*)*,  %XTMBone* (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone* %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
ret %XTMBone* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2881 = bitcast [92 x i8]* @gsxtmgraphics-pipeline110 to i8*
call i32 (i8*, ...) @printf(i8* %var2881)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMBone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone* (i8*, i8*, %XTMBone*)*,  %XTMBone* (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone* %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
%tmpres = bitcast %XTMBone* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMBone*}*
%arg_p_0 = getelementptr {%XTMBone*}, {%XTMBone*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMBone*, %XTMBone** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone* (i8*, i8*, %XTMBone*)*,  %XTMBone* (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone* %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline111 = hidden constant [33 x i8] c"hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd__2882(i8* %_impz,i8* %_impenv, %XTMBone* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2883 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %XTMBone*)*}***}*
%hfree_adhoc_W3ZvaWQsWFRNQm9uZSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMBone*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMBone*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsWFRNQm9uZSpdPtr = load {i8*, i8*, void (i8*, i8*, %XTMBone*)*}***, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**** %hfree_adhoc_W3ZvaWQsWFRNQm9uZSpdPtr_

; setup arguments
%xPtr = alloca %XTMBone*
store %XTMBone* %x, %XTMBone** %xPtr

; promote local stack var allocations
%tzone2923 = load i8*, i8** %_impzPtr
%zone2924 = bitcast i8* %tzone2923 to %mzone*
%ifptr2898 = alloca i1
%ifptr2885 = alloca i1

%val2886 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2887 = getelementptr %XTMBone, %XTMBone* %val2886, i64 0, i32 0
%val2888 = load %String*, %String** %val2887
%val2889 = icmp eq %String* %val2888, null
br i1 %val2889, label %then2885, label %else2885

then2885:
%res2890 = call ccc i1 @impc_false()
store i1 %res2890, i1* %ifptr2885
br label %ifcont2885

else2885:
%res2891 = call ccc i1 @impc_true()
store i1 %res2891, i1* %ifptr2885
br label %ifcont2885

ifcont2885:
%ifres2892 = load i1, i1* %ifptr2885

br i1 %ifres2892, label %then2884, label %else2884

then2884:
%val2893 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2894 = getelementptr %XTMBone, %XTMBone* %val2893, i64 0, i32 0
%val2895 = load %String*, %String** %val2894
call fastcc void @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0(%String* %val2895)
br label %ifcont2884

else2884:
br label %ifcont2884

ifcont2884:
%val2899 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2900 = getelementptr %XTMBone, %XTMBone* %val2899, i64 0, i32 6
%val2901 = load %XTMBone*, %XTMBone** %val2900
%val2902 = icmp eq %XTMBone* %val2901, null
br i1 %val2902, label %then2898, label %else2898

then2898:
%res2903 = call ccc i1 @impc_false()
store i1 %res2903, i1* %ifptr2898
br label %ifcont2898

else2898:
%res2904 = call ccc i1 @impc_true()
store i1 %res2904, i1* %ifptr2898
br label %ifcont2898

ifcont2898:
%ifres2905 = load i1, i1* %ifptr2898

br i1 %ifres2905, label %then2897, label %else2897

then2897:
%val2906 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2907 = getelementptr %XTMBone, %XTMBone* %val2906, i64 0, i32 6
%val2908 = load %XTMBone*, %XTMBone** %val2907

; apply closure 
%vval2909 = load {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}*** %hfree_adhoc_W3ZvaWQsWFRNQm9uZSpdPtr
%val2910 = load {i8*, i8*, void (i8*, i8*, %XTMBone*)*}*,{i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %vval2909
%fPtr2911 = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %val2910, i32 0, i32 2
%ePtr2912 = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %val2910, i32 0, i32 1
%f2913 = load void (i8*, i8*, %XTMBone*)*, void (i8*, i8*, %XTMBone*)** %fPtr2911
%e2914 = load i8*, i8** %ePtr2912
%tzone2915 = load i8*, i8** %_impzPtr
%zone2916 = bitcast i8* %tzone2915 to %mzone*
%z2917 = bitcast %mzone* %zone2916 to i8*
tail call fastcc void %f2913(i8* %z2917, i8* %e2914, %XTMBone* %val2908)
br label %ifcont2897

else2897:
br label %ifcont2897

ifcont2897:
%val2919 = load %XTMBone*, %XTMBone** %xPtr
%val2920 = bitcast %XTMBone* %val2919 to i8*
call ccc void @free(i8* %val2920)
ret void
}
@gsxtmgraphics-pipeline112 = hidden constant [86 x i8] c"hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** @hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2944 = load i8*, i8** %_impzPtr
%zone2945 = bitcast i8* %tzone2944 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd
%dat_hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone2945, i64 8)
%hfree_adhoc_W3ZvaWQsWFRNQm9uZSpdPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd to { i8*, i8*, void (i8*, i8*, %XTMBone*)*}***
%tzone2925 = load i8*, i8** %_impzPtr
%zone2926 = bitcast i8* %tzone2925 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2926)
; malloc closure structure
%clsptr2927 = call i8* @llvm_zone_malloc(%mzone* %zone2926, i64 24)
%closure2928 = bitcast i8* %clsptr2927 to { i8*, i8*, void (i8*, i8*, %XTMBone*)*}*

; malloc environment structure
%envptr2929 = call i8* @llvm_zone_malloc(%mzone* %zone2926, i64 8)
%environment2930 = bitcast i8* %envptr2929 to {{i8*, i8*, void (i8*, i8*, %XTMBone*)*}***}*

; malloc closure address table
%addytable2931 = call %clsvar* @new_address_table()
%var2932 = bitcast [33 x i8]* @gsxtmgraphics-pipeline111 to i8*
%var2933 = bitcast [42 x i8]* @gsxtmgraphics-pipeline101 to i8*
%addytable2934 = call %clsvar* @add_address_table(%mzone* %zone2926, i8* %var2932, i32 0, i8* %var2933, i32 3, %clsvar* %addytable2931)
%address-table2935 = bitcast %clsvar* %addytable2934 to i8*

; insert table, function and environment into closure struct
%closure.table2938 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMBone*)*}, { i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure2928, i32 0, i32 0
store i8* %address-table2935, i8** %closure.table2938
%closure.env2939 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMBone*)*}, { i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure2928, i32 0, i32 1
store i8* %envptr2929, i8** %closure.env2939
%closure.func2940 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMBone*)*}, { i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure2928, i32 0, i32 2
store void (i8*, i8*, %XTMBone*)* @hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd__2882, void (i8*, i8*, %XTMBone*)** %closure.func2940
%closure_size2941 = call i64 @llvm_zone_mark_size(%mzone* %zone2926)
call void @llvm_zone_ptr_set_size(i8* %clsptr2927, i64 %closure_size2941)
%wrapper_ptr2942 = call i8* @llvm_zone_malloc(%mzone* %zone2926, i64 8)
%closure_wrapper2943 = bitcast i8* %wrapper_ptr2942 to { i8*, i8*, void (i8*, i8*, %XTMBone*)*}**
store { i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure2928, { i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure_wrapper2943

; let value assignment
%hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd = select i1 true, { i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure_wrapper2943, { i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure_wrapper2943
store { i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd, { i8*, i8*, void (i8*, i8*, %XTMBone*)*}*** %hfree_adhoc_W3ZvaWQsWFRNQm9uZSpdPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd
%tmp_envptr2937 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMBone*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMBone*)*}***}* %environment2930, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %XTMBone*)*}*** %hfree_adhoc_W3ZvaWQsWFRNQm9uZSpdPtr, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**** %tmp_envptr2937


%val2946 = load {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}*** %hfree_adhoc_W3ZvaWQsWFRNQm9uZSpdPtr
ret {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %val2946
}


@hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** @hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd(%XTMBone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMBone*)*,  void (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd_native(%XTMBone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMBone*)*,  void (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2947 = bitcast [86 x i8]* @gsxtmgraphics-pipeline112 to i8*
call i32 (i8*, ...) @printf(i8* %var2947)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMBone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMBone*)*,  void (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMBone*}*
%arg_p_0 = getelementptr {%XTMBone*}, {%XTMBone*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMBone*, %XTMBone** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMBone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMBone*)*}*, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMBone*)*}, {i8*, i8*, void (i8*, i8*, %XTMBone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMBone*)*,  void (i8*, i8*, %XTMBone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline113 = hidden constant [57 x i8] c"zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd\00"
@gsxtmgraphics-pipeline114 = hidden constant [65 x i8] c"{i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %XTMBone* @zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd__2948(i8* %_impz,i8* %_impenv, %XTMBone* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2949 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpdPtr = load {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}***, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpdPtr_

; setup arguments
%xPtr = alloca %XTMBone*
store %XTMBone* %x, %XTMBone** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val2951 = load %mzone*, %mzone** %fromzPtr
%val2952 = load %XTMBone*, %XTMBone** %xPtr
%val2953 = bitcast %XTMBone* %val2952 to i8*
%res2954 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val2951, i8* %val2953)
br i1 %res2954, label %then2950, label %else2950

then2950:
%val2955 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val2955)
%zone_ptr2956 = bitcast %mzone* %val2955 to i8*
store i8* %zone_ptr2956, i8** %_impzPtr
%tzone2962 = load i8*, i8** %_impzPtr
%zone2963 = bitcast i8* %tzone2962 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMBone*
%tzone2958 = load i8*, i8** %_impzPtr
%zone2959 = bitcast i8* %tzone2958 to %mzone*
%dat2960 = call i8* @llvm_zone_malloc(%mzone* %zone2959, i64 56)
call i8* @memset(i8* %dat2960, i32 0, i64 56)
%val2961 = bitcast i8* %dat2960 to %XTMBone*

; let value assignment
%obj = select i1 true, %XTMBone* %val2961, %XTMBone* %val2961
store %XTMBone* %obj, %XTMBone** %objPtr

; promote local stack var allocations
%tzone3086 = load i8*, i8** %_impzPtr
%zone3087 = bitcast i8* %tzone3086 to %mzone*
%ifptr3055 = alloca %XTMBone*
%ifptr3056 = alloca i1
%ifptr3016 = alloca float*
%ifptr2987 = alloca float*
%ifptr2964 = alloca %String*
%ifptr2965 = alloca i1
%val2966 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2967 = getelementptr %XTMBone, %XTMBone* %val2966, i64 0, i32 0
%val2968 = load %String*, %String** %val2967
%val2969 = icmp eq %String* %val2968, null
br i1 %val2969, label %then2965, label %else2965

then2965:
%res2970 = call ccc i1 @impc_false()
store i1 %res2970, i1* %ifptr2965
br label %ifcont2965

else2965:
%res2971 = call ccc i1 @impc_true()
store i1 %res2971, i1* %ifptr2965
br label %ifcont2965

ifcont2965:
%ifres2972 = load i1, i1* %ifptr2965

br i1 %ifres2972, label %then2964, label %else2964

then2964:
%val2973 = load %XTMBone*, %XTMBone** %objPtr
%val2974 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2975 = getelementptr %XTMBone, %XTMBone* %val2974, i64 0, i32 0
%val2976 = load %String*, %String** %val2975
%val2977 = load %mzone*, %mzone** %fromzPtr
%val2978 = load %mzone*, %mzone** %tozPtr
%res2979 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val2976, %mzone* %val2977, %mzone* %val2978)
; set tuple
%val2980 = getelementptr %XTMBone, %XTMBone* %val2973, i64 0, i32 0
store %String* %res2979, %String** %val2980
store %String* %res2979, %String** %ifptr2964
br label %ifcont2964

else2964:
br label %ifcont2964

ifcont2964:
%ifres2981 = load %String*, %String** %ifptr2964

%val2982 = load %XTMBone*, %XTMBone** %objPtr
%val2983 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2984 = getelementptr %XTMBone, %XTMBone* %val2983, i64 0, i32 1
%val2985 = load i32, i32* %val2984
; set tuple
%val2986 = getelementptr %XTMBone, %XTMBone* %val2982, i64 0, i32 1
store i32 %val2985, i32* %val2986
%val2988 = load %mzone*, %mzone** %fromzPtr
%val2989 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val2990 = getelementptr %XTMBone, %XTMBone* %val2989, i64 0, i32 2
%val2991 = load float*, float** %val2990
%val2992 = bitcast float* %val2991 to i8*
%res2993 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val2988, i8* %val2992)
br i1 %res2993, label %then2987, label %else2987

then2987:
%tzone2998 = load i8*, i8** %_impzPtr
%zone2999 = bitcast i8* %tzone2998 to %mzone*

; let assign value to symbol newptr
%newptrPtr = alloca float*
%tzone2994 = load i8*, i8** %_impzPtr
%zone2995 = bitcast i8* %tzone2994 to %mzone*
%dat2996 = call i8* @llvm_zone_malloc(%mzone* %zone2995, i64 4)
call i8* @memset(i8* %dat2996, i32 0, i64 4)
%val2997 = bitcast i8* %dat2996 to float*

; let value assignment
%newptr = select i1 true, float* %val2997, float* %val2997
store float* %newptr, float** %newptrPtr

%val3000 = load float*, float** %newptrPtr
%val3001 = bitcast float* %val3000 to i8*
%val3002 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val3003 = getelementptr %XTMBone, %XTMBone* %val3002, i64 0, i32 2
%val3004 = load float*, float** %val3003
%val3005 = bitcast float* %val3004 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val3001, i8* %val3005, i64 4, i32 1, i1 0)
%val3007 = load %XTMBone*, %XTMBone** %objPtr
%val3008 = load float*, float** %newptrPtr
; set tuple
%val3009 = getelementptr %XTMBone, %XTMBone* %val3007, i64 0, i32 2
store float* %val3008, float** %val3009
store float* %val3008, float** %ifptr2987
br label %ifcont2987

else2987:
%val3010 = load %XTMBone*, %XTMBone** %objPtr
%val3011 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val3012 = getelementptr %XTMBone, %XTMBone* %val3011, i64 0, i32 2
%val3013 = load float*, float** %val3012
; set tuple
%val3014 = getelementptr %XTMBone, %XTMBone* %val3010, i64 0, i32 2
store float* %val3013, float** %val3014
store float* %val3013, float** %ifptr2987
br label %ifcont2987

ifcont2987:
%ifres3015 = load float*, float** %ifptr2987

%val3017 = load %mzone*, %mzone** %fromzPtr
%val3018 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val3019 = getelementptr %XTMBone, %XTMBone* %val3018, i64 0, i32 3
%val3020 = load float*, float** %val3019
%val3021 = bitcast float* %val3020 to i8*
%res3022 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val3017, i8* %val3021)
br i1 %res3022, label %then3016, label %else3016

then3016:
%tzone3027 = load i8*, i8** %_impzPtr
%zone3028 = bitcast i8* %tzone3027 to %mzone*

; let assign value to symbol newptr_s_16
%newptr_s_16Ptr = alloca float*
%tzone3023 = load i8*, i8** %_impzPtr
%zone3024 = bitcast i8* %tzone3023 to %mzone*
%dat3025 = call i8* @llvm_zone_malloc(%mzone* %zone3024, i64 4)
call i8* @memset(i8* %dat3025, i32 0, i64 4)
%val3026 = bitcast i8* %dat3025 to float*

; let value assignment
%newptr_s_16 = select i1 true, float* %val3026, float* %val3026
store float* %newptr_s_16, float** %newptr_s_16Ptr

%val3029 = load float*, float** %newptr_s_16Ptr
%val3030 = bitcast float* %val3029 to i8*
%val3031 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val3032 = getelementptr %XTMBone, %XTMBone* %val3031, i64 0, i32 3
%val3033 = load float*, float** %val3032
%val3034 = bitcast float* %val3033 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val3030, i8* %val3034, i64 4, i32 1, i1 0)
%val3036 = load %XTMBone*, %XTMBone** %objPtr
%val3037 = load float*, float** %newptr_s_16Ptr
; set tuple
%val3038 = getelementptr %XTMBone, %XTMBone* %val3036, i64 0, i32 3
store float* %val3037, float** %val3038
store float* %val3037, float** %ifptr3016
br label %ifcont3016

else3016:
%val3039 = load %XTMBone*, %XTMBone** %objPtr
%val3040 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val3041 = getelementptr %XTMBone, %XTMBone* %val3040, i64 0, i32 3
%val3042 = load float*, float** %val3041
; set tuple
%val3043 = getelementptr %XTMBone, %XTMBone* %val3039, i64 0, i32 3
store float* %val3042, float** %val3043
store float* %val3042, float** %ifptr3016
br label %ifcont3016

ifcont3016:
%ifres3044 = load float*, float** %ifptr3016

%val3045 = load %XTMBone*, %XTMBone** %objPtr
%val3046 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val3047 = getelementptr %XTMBone, %XTMBone* %val3046, i64 0, i32 4
%val3048 = load i32, i32* %val3047
; set tuple
%val3049 = getelementptr %XTMBone, %XTMBone* %val3045, i64 0, i32 4
store i32 %val3048, i32* %val3049
%val3050 = load %XTMBone*, %XTMBone** %objPtr
%val3051 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val3052 = getelementptr %XTMBone, %XTMBone* %val3051, i64 0, i32 5
%val3053 = load %XTMBone**, %XTMBone*** %val3052
; set tuple
%val3054 = getelementptr %XTMBone, %XTMBone* %val3050, i64 0, i32 5
store %XTMBone** %val3053, %XTMBone*** %val3054
%val3057 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val3058 = getelementptr %XTMBone, %XTMBone* %val3057, i64 0, i32 6
%val3059 = load %XTMBone*, %XTMBone** %val3058
%val3060 = icmp eq %XTMBone* %val3059, null
br i1 %val3060, label %then3056, label %else3056

then3056:
%res3061 = call ccc i1 @impc_false()
store i1 %res3061, i1* %ifptr3056
br label %ifcont3056

else3056:
%res3062 = call ccc i1 @impc_true()
store i1 %res3062, i1* %ifptr3056
br label %ifcont3056

ifcont3056:
%ifres3063 = load i1, i1* %ifptr3056

br i1 %ifres3063, label %then3055, label %else3055

then3055:
%val3064 = load %XTMBone*, %XTMBone** %objPtr
%val3065 = load %XTMBone*, %XTMBone** %xPtr
; tuple ref
%val3066 = getelementptr %XTMBone, %XTMBone* %val3065, i64 0, i32 6
%val3067 = load %XTMBone*, %XTMBone** %val3066
%val3068 = load %mzone*, %mzone** %fromzPtr
%val3069 = load %mzone*, %mzone** %tozPtr

; apply closure 
%vval3070 = load {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}**, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpdPtr
%val3071 = load {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}*,{i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}** %vval3070
%fPtr3072 = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}* %val3071, i32 0, i32 2
%ePtr3073 = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}* %val3071, i32 0, i32 1
%f3074 = load %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)** %fPtr3072
%e3075 = load i8*, i8** %ePtr3073
%tzone3076 = load i8*, i8** %_impzPtr
%zone3077 = bitcast i8* %tzone3076 to %mzone*
%z3078 = bitcast %mzone* %zone3077 to i8*
%result3079 = tail call fastcc %XTMBone* %f3074(i8* %z3078, i8* %e3075, %XTMBone* %val3067, %mzone* %val3068, %mzone* %val3069)
; set tuple
%val3080 = getelementptr %XTMBone, %XTMBone* %val3064, i64 0, i32 6
store %XTMBone* %result3079, %XTMBone** %val3080
store %XTMBone* %result3079, %XTMBone** %ifptr3055
br label %ifcont3055

else3055:
br label %ifcont3055

ifcont3055:
%ifres3081 = load %XTMBone*, %XTMBone** %ifptr3055

%oldzone3082 = call %mzone* @llvm_pop_zone_stack()
%newzone3083 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr3084 = bitcast %mzone* %newzone3083 to i8*
store i8* %zone_ptr3084, i8** %_impzPtr
%val3085 = load %XTMBone*, %XTMBone** %objPtr
ret %XTMBone* %val3085

else2950:
%val3088 = load %XTMBone*, %XTMBone** %xPtr
ret %XTMBone* %val3088
}
@gsxtmgraphics-pipeline115 = hidden constant [110 x i8] c"zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3108 = load i8*, i8** %_impzPtr
%zone3109 = bitcast i8* %tzone3108 to %mzone*

; let assign value to symbol zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd
%dat_zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone3109, i64 8)
%zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpdPtr = bitcast i8* %dat_zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd to { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}***
%tzone3089 = load i8*, i8** %_impzPtr
%zone3090 = bitcast i8* %tzone3089 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3090)
; malloc closure structure
%clsptr3091 = call i8* @llvm_zone_malloc(%mzone* %zone3090, i64 24)
%closure3092 = bitcast i8* %clsptr3091 to { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr3093 = call i8* @llvm_zone_malloc(%mzone* %zone3090, i64 8)
%environment3094 = bitcast i8* %envptr3093 to {{i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable3095 = call %clsvar* @new_address_table()
%var3096 = bitcast [57 x i8]* @gsxtmgraphics-pipeline113 to i8*
%var3097 = bitcast [65 x i8]* @gsxtmgraphics-pipeline114 to i8*
%addytable3098 = call %clsvar* @add_address_table(%mzone* %zone3090, i8* %var3096, i32 0, i8* %var3097, i32 3, %clsvar* %addytable3095)
%address-table3099 = bitcast %clsvar* %addytable3098 to i8*

; insert table, function and environment into closure struct
%closure.table3102 = getelementptr { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}, { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}* %closure3092, i32 0, i32 0
store i8* %address-table3099, i8** %closure.table3102
%closure.env3103 = getelementptr { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}, { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}* %closure3092, i32 0, i32 1
store i8* %envptr3093, i8** %closure.env3103
%closure.func3104 = getelementptr { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}, { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}* %closure3092, i32 0, i32 2
store %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)* @zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd__2948, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)** %closure.func3104
%closure_size3105 = call i64 @llvm_zone_mark_size(%mzone* %zone3090)
call void @llvm_zone_ptr_set_size(i8* %clsptr3091, i64 %closure_size3105)
%wrapper_ptr3106 = call i8* @llvm_zone_malloc(%mzone* %zone3090, i64 8)
%closure_wrapper3107 = bitcast i8* %wrapper_ptr3106 to { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}**
store { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}* %closure3092, { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}** %closure_wrapper3107

; let value assignment
%zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd = select i1 true, { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}** %closure_wrapper3107, { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}** %closure_wrapper3107
store { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd, { i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd
%tmp_envptr3101 = getelementptr {{i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}***}* %environment3094, i32 0, i32 0
store {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpdPtr, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}**** %tmp_envptr3101


%val3110 = load {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}**, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpdPtr
ret {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}** %val3110
}


@zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMBone* @zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd(%XTMBone* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}*, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*,  %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone* %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %XTMBone* %result
}


define dllexport ccc %XTMBone* @zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd_native(%XTMBone* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}*, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*,  %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone* %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %XTMBone* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3111 = bitcast [110 x i8]* @gsxtmgraphics-pipeline115 to i8*
call i32 (i8*, ...) @printf(i8* %var3111)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMBone*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3112 = bitcast [110 x i8]* @gsxtmgraphics-pipeline115 to i8*
call i32 (i8*, ...) @printf(i8* %var3112)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3113 = bitcast [110 x i8]* @gsxtmgraphics-pipeline115 to i8*
call i32 (i8*, ...) @printf(i8* %var3113)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}*, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*,  %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone* %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %XTMBone* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMBone*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%XTMBone*, %mzone*, %mzone*}, {%XTMBone*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMBone*, %XTMBone** %arg_p_0
%arg_p_1 = getelementptr {%XTMBone*, %mzone*, %mzone*}, {%XTMBone*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%XTMBone*, %mzone*, %mzone*}, {%XTMBone*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}*, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)*,  %XTMBone* (i8*, i8*, %XTMBone*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMBone* %ff(i8* %_impz, i8* %ee, %XTMBone* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%XTMMesh = type {%VBO*,%Texture*,float*,float*,float*,float*,float,float,i32,i64,%VAO*,%String*,i32,%XTMBone*,i32,%Texture*,%Texture*,%Texture*,%Texture*}
@gsxtmgraphics-pipeline116 = hidden constant [199 x i8] c"XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd\00"
@gsxtmgraphics-pipeline117 = hidden constant [192 x i8] c"{i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**\00"
define dllexport fastcc %XTMMesh* @XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd__3114(i8* %_impz,i8* %_impenv, %VBO* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float %arg_6, float %arg_7, i32 %arg_8, i64 %arg_9, %VAO* %arg_10, %String* %arg_11, i32 %arg_12, %XTMBone* %arg_13, i32 %arg_14, %Texture* %arg_15, %Texture* %arg_16, %Texture* %arg_17, %Texture* %arg_18) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3115 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}*
%XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpdPtr_ = getelementptr {{i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}, {{i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}* %impenv, i32 0, i32 0
%XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpdPtr = load {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**** %XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpdPtr_

; setup arguments
%arg_0Ptr = alloca %VBO*
store %VBO* %arg_0, %VBO** %arg_0Ptr
%arg_1Ptr = alloca %Texture*
store %Texture* %arg_1, %Texture** %arg_1Ptr
%arg_2Ptr = alloca float*
store float* %arg_2, float** %arg_2Ptr
%arg_3Ptr = alloca float*
store float* %arg_3, float** %arg_3Ptr
%arg_4Ptr = alloca float*
store float* %arg_4, float** %arg_4Ptr
%arg_5Ptr = alloca float*
store float* %arg_5, float** %arg_5Ptr
%arg_6Ptr = alloca float
store float %arg_6, float* %arg_6Ptr
%arg_7Ptr = alloca float
store float %arg_7, float* %arg_7Ptr
%arg_8Ptr = alloca i32
store i32 %arg_8, i32* %arg_8Ptr
%arg_9Ptr = alloca i64
store i64 %arg_9, i64* %arg_9Ptr
%arg_10Ptr = alloca %VAO*
store %VAO* %arg_10, %VAO** %arg_10Ptr
%arg_11Ptr = alloca %String*
store %String* %arg_11, %String** %arg_11Ptr
%arg_12Ptr = alloca i32
store i32 %arg_12, i32* %arg_12Ptr
%arg_13Ptr = alloca %XTMBone*
store %XTMBone* %arg_13, %XTMBone** %arg_13Ptr
%arg_14Ptr = alloca i32
store i32 %arg_14, i32* %arg_14Ptr
%arg_15Ptr = alloca %Texture*
store %Texture* %arg_15, %Texture** %arg_15Ptr
%arg_16Ptr = alloca %Texture*
store %Texture* %arg_16, %Texture** %arg_16Ptr
%arg_17Ptr = alloca %Texture*
store %Texture* %arg_17, %Texture** %arg_17Ptr
%arg_18Ptr = alloca %Texture*
store %Texture* %arg_18, %Texture** %arg_18Ptr


%tzone3120 = load i8*, i8** %_impzPtr
%zone3121 = bitcast i8* %tzone3120 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMMesh*
%tzone3116 = load i8*, i8** %_impzPtr
%zone3117 = bitcast i8* %tzone3116 to %mzone*
%dat3118 = call i8* @llvm_zone_malloc(%mzone* %zone3117, i64 144)
call i8* @memset(i8* %dat3118, i32 0, i64 144)
%val3119 = bitcast i8* %dat3118 to %XTMMesh*

; let value assignment
%obj = select i1 true, %XTMMesh* %val3119, %XTMMesh* %val3119
store %XTMMesh* %obj, %XTMMesh** %objPtr

%val3122 = load %XTMMesh*, %XTMMesh** %objPtr
%val3123 = load %VBO*, %VBO** %arg_0Ptr
; set tuple
%val3124 = getelementptr %XTMMesh, %XTMMesh* %val3122, i64 0, i32 0
store %VBO* %val3123, %VBO** %val3124
%val3125 = load %XTMMesh*, %XTMMesh** %objPtr
%val3126 = load %Texture*, %Texture** %arg_1Ptr
; set tuple
%val3127 = getelementptr %XTMMesh, %XTMMesh* %val3125, i64 0, i32 1
store %Texture* %val3126, %Texture** %val3127
%val3128 = load %XTMMesh*, %XTMMesh** %objPtr
%val3129 = load float*, float** %arg_2Ptr
; set tuple
%val3130 = getelementptr %XTMMesh, %XTMMesh* %val3128, i64 0, i32 2
store float* %val3129, float** %val3130
%val3131 = load %XTMMesh*, %XTMMesh** %objPtr
%val3132 = load float*, float** %arg_3Ptr
; set tuple
%val3133 = getelementptr %XTMMesh, %XTMMesh* %val3131, i64 0, i32 3
store float* %val3132, float** %val3133
%val3134 = load %XTMMesh*, %XTMMesh** %objPtr
%val3135 = load float*, float** %arg_4Ptr
; set tuple
%val3136 = getelementptr %XTMMesh, %XTMMesh* %val3134, i64 0, i32 4
store float* %val3135, float** %val3136
%val3137 = load %XTMMesh*, %XTMMesh** %objPtr
%val3138 = load float*, float** %arg_5Ptr
; set tuple
%val3139 = getelementptr %XTMMesh, %XTMMesh* %val3137, i64 0, i32 5
store float* %val3138, float** %val3139
%val3140 = load %XTMMesh*, %XTMMesh** %objPtr
%val3141 = load float, float* %arg_6Ptr
; set tuple
%val3142 = getelementptr %XTMMesh, %XTMMesh* %val3140, i64 0, i32 6
store float %val3141, float* %val3142
%val3143 = load %XTMMesh*, %XTMMesh** %objPtr
%val3144 = load float, float* %arg_7Ptr
; set tuple
%val3145 = getelementptr %XTMMesh, %XTMMesh* %val3143, i64 0, i32 7
store float %val3144, float* %val3145
%val3146 = load %XTMMesh*, %XTMMesh** %objPtr
%val3147 = load i32, i32* %arg_8Ptr
; set tuple
%val3148 = getelementptr %XTMMesh, %XTMMesh* %val3146, i64 0, i32 8
store i32 %val3147, i32* %val3148
%val3149 = load %XTMMesh*, %XTMMesh** %objPtr
%val3150 = load i64, i64* %arg_9Ptr
; set tuple
%val3151 = getelementptr %XTMMesh, %XTMMesh* %val3149, i64 0, i32 9
store i64 %val3150, i64* %val3151
%val3152 = load %XTMMesh*, %XTMMesh** %objPtr
%val3153 = load %VAO*, %VAO** %arg_10Ptr
; set tuple
%val3154 = getelementptr %XTMMesh, %XTMMesh* %val3152, i64 0, i32 10
store %VAO* %val3153, %VAO** %val3154
%val3155 = load %XTMMesh*, %XTMMesh** %objPtr
%val3156 = load %String*, %String** %arg_11Ptr
; set tuple
%val3157 = getelementptr %XTMMesh, %XTMMesh* %val3155, i64 0, i32 11
store %String* %val3156, %String** %val3157
%val3158 = load %XTMMesh*, %XTMMesh** %objPtr
%val3159 = load i32, i32* %arg_12Ptr
; set tuple
%val3160 = getelementptr %XTMMesh, %XTMMesh* %val3158, i64 0, i32 12
store i32 %val3159, i32* %val3160
%val3161 = load %XTMMesh*, %XTMMesh** %objPtr
%val3162 = load %XTMBone*, %XTMBone** %arg_13Ptr
; set tuple
%val3163 = getelementptr %XTMMesh, %XTMMesh* %val3161, i64 0, i32 13
store %XTMBone* %val3162, %XTMBone** %val3163
%val3164 = load %XTMMesh*, %XTMMesh** %objPtr
%val3165 = load i32, i32* %arg_14Ptr
; set tuple
%val3166 = getelementptr %XTMMesh, %XTMMesh* %val3164, i64 0, i32 14
store i32 %val3165, i32* %val3166
%val3167 = load %XTMMesh*, %XTMMesh** %objPtr
%val3168 = load %Texture*, %Texture** %arg_15Ptr
; set tuple
%val3169 = getelementptr %XTMMesh, %XTMMesh* %val3167, i64 0, i32 15
store %Texture* %val3168, %Texture** %val3169
%val3170 = load %XTMMesh*, %XTMMesh** %objPtr
%val3171 = load %Texture*, %Texture** %arg_16Ptr
; set tuple
%val3172 = getelementptr %XTMMesh, %XTMMesh* %val3170, i64 0, i32 16
store %Texture* %val3171, %Texture** %val3172
%val3173 = load %XTMMesh*, %XTMMesh** %objPtr
%val3174 = load %Texture*, %Texture** %arg_17Ptr
; set tuple
%val3175 = getelementptr %XTMMesh, %XTMMesh* %val3173, i64 0, i32 17
store %Texture* %val3174, %Texture** %val3175
%val3176 = load %XTMMesh*, %XTMMesh** %objPtr
%val3177 = load %Texture*, %Texture** %arg_18Ptr
; set tuple
%val3178 = getelementptr %XTMMesh, %XTMMesh* %val3176, i64 0, i32 18
store %Texture* %val3177, %Texture** %val3178
%val3179 = load %XTMMesh*, %XTMMesh** %objPtr
ret %XTMMesh* %val3179
}
@gsxtmgraphics-pipeline118 = hidden constant [252 x i8] c"XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** @XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3199 = load i8*, i8** %_impzPtr
%zone3200 = bitcast i8* %tzone3199 to %mzone*

; let assign value to symbol XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd
%dat_XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd = call i8* @llvm_zone_malloc(%mzone* %zone3200, i64 8)
%XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpdPtr = bitcast i8* %dat_XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd to { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***
%tzone3180 = load i8*, i8** %_impzPtr
%zone3181 = bitcast i8* %tzone3180 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3181)
; malloc closure structure
%clsptr3182 = call i8* @llvm_zone_malloc(%mzone* %zone3181, i64 24)
%closure3183 = bitcast i8* %clsptr3182 to { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*

; malloc environment structure
%envptr3184 = call i8* @llvm_zone_malloc(%mzone* %zone3181, i64 8)
%environment3185 = bitcast i8* %envptr3184 to {{i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}*

; malloc closure address table
%addytable3186 = call %clsvar* @new_address_table()
%var3187 = bitcast [199 x i8]* @gsxtmgraphics-pipeline116 to i8*
%var3188 = bitcast [192 x i8]* @gsxtmgraphics-pipeline117 to i8*
%addytable3189 = call %clsvar* @add_address_table(%mzone* %zone3181, i8* %var3187, i32 0, i8* %var3188, i32 3, %clsvar* %addytable3186)
%address-table3190 = bitcast %clsvar* %addytable3189 to i8*

; insert table, function and environment into closure struct
%closure.table3193 = getelementptr { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure3183, i32 0, i32 0
store i8* %address-table3190, i8** %closure.table3193
%closure.env3194 = getelementptr { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure3183, i32 0, i32 1
store i8* %envptr3184, i8** %closure.env3194
%closure.func3195 = getelementptr { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure3183, i32 0, i32 2
store %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)* @XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd__3114, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)** %closure.func3195
%closure_size3196 = call i64 @llvm_zone_mark_size(%mzone* %zone3181)
call void @llvm_zone_ptr_set_size(i8* %clsptr3182, i64 %closure_size3196)
%wrapper_ptr3197 = call i8* @llvm_zone_malloc(%mzone* %zone3181, i64 8)
%closure_wrapper3198 = bitcast i8* %wrapper_ptr3197 to { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**
store { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure3183, { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_wrapper3198

; let value assignment
%XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd = select i1 true, { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_wrapper3198, { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_wrapper3198
store { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd, { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*** %XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpdPtr

; add data to environment
; don't need to alloc for env var XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd
%tmp_envptr3192 = getelementptr {{i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}, {{i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}* %environment3185, i32 0, i32 0
store {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*** %XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpdPtr, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**** %tmp_envptr3192


%val3201 = load {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*** %XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpdPtr
ret {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %val3201
}


@XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** @XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMMesh* @XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd(%VBO* %arg_0,%Texture* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float* %arg_5,float %arg_6,float %arg_7,i32 %arg_8,i64 %arg_9,%VAO* %arg_10,%String* %arg_11,i32 %arg_12,%XTMBone* %arg_13,i32 %arg_14,%Texture* %arg_15,%Texture* %arg_16,%Texture* %arg_17,%Texture* %arg_18) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*,  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float %arg_6, float %arg_7, i32 %arg_8, i64 %arg_9, %VAO* %arg_10, %String* %arg_11, i32 %arg_12, %XTMBone* %arg_13, i32 %arg_14, %Texture* %arg_15, %Texture* %arg_16, %Texture* %arg_17, %Texture* %arg_18)
ret %XTMMesh* %result
}


define dllexport ccc %XTMMesh* @XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_native(%VBO* %arg_0,%Texture* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float* %arg_5,float %arg_6,float %arg_7,i32 %arg_8,i64 %arg_9,%VAO* %arg_10,%String* %arg_11,i32 %arg_12,%XTMBone* %arg_13,i32 %arg_14,%Texture* %arg_15,%Texture* %arg_16,%Texture* %arg_17,%Texture* %arg_18) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*,  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float %arg_6, float %arg_7, i32 %arg_8, i64 %arg_9, %VAO* %arg_10, %String* %arg_11, i32 %arg_12, %XTMBone* %arg_13, i32 %arg_14, %Texture* %arg_15, %Texture* %arg_16, %Texture* %arg_17, %Texture* %arg_18)
ret %XTMMesh* %result
}


define dllexport ccc i8*  @XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3202 = bitcast [252 x i8]* @gsxtmgraphics-pipeline118 to i8*
call i32 (i8*, ...) @printf(i8* %var3202)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3203 = bitcast [252 x i8]* @gsxtmgraphics-pipeline118 to i8*
call i32 (i8*, ...) @printf(i8* %var3203)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Texture*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3204 = bitcast [252 x i8]* @gsxtmgraphics-pipeline118 to i8*
call i32 (i8*, ...) @printf(i8* %var3204)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var3205 = bitcast [252 x i8]* @gsxtmgraphics-pipeline118 to i8*
call i32 (i8*, ...) @printf(i8* %var3205)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var3206 = bitcast [252 x i8]* @gsxtmgraphics-pipeline118 to i8*
call i32 (i8*, ...) @printf(i8* %var3206)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var3207 = bitcast [252 x i8]* @gsxtmgraphics-pipeline118 to i8*
call i32 (i8*, ...) @printf(i8* %var3207)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to float*
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_real(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var3208 = bitcast [252 x i8]* @gsxtmgraphics-pipeline118 to i8*
call i32 (i8*, ...) @printf(i8* %var3208)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%arg_6 = call ccc float  @r32value(i8* %arg_6_val)
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_real(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var3209 = bitcast [252 x i8]* @gsxtmgraphics-pipeline118 to i8*
call i32 (i8*, ...) @printf(i8* %var3209)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%arg_7 = call ccc float  @r32value(i8* %arg_7_val)
%arg_8_val = call ccc i8* @list_ref(i8* %_sc, i32 8,i8* %args)
%arg_8_rt_check = call i32 @is_integer(i8* %arg_8_val)
%arg_8_bool = icmp ne i32 %arg_8_rt_check, 0
br i1 %arg_8_bool, label %arg_8_true, label %arg_8_false

arg_8_true:
br label %arg_8_continue

arg_8_false:
%var3210 = bitcast [252 x i8]* @gsxtmgraphics-pipeline118 to i8*
call i32 (i8*, ...) @printf(i8* %var3210)
%arg_8_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_8_errret

arg_8_continue:
%arg_8 = call ccc i32  @i32value(i8* %arg_8_val)
%arg_9_val = call ccc i8* @list_ref(i8* %_sc, i32 9,i8* %args)
%arg_9_rt_check = call i32 @is_integer(i8* %arg_9_val)
%arg_9_bool = icmp ne i32 %arg_9_rt_check, 0
br i1 %arg_9_bool, label %arg_9_true, label %arg_9_false

arg_9_true:
br label %arg_9_continue

arg_9_false:
%var3211 = bitcast [252 x i8]* @gsxtmgraphics-pipeline118 to i8*
call i32 (i8*, ...) @printf(i8* %var3211)
%arg_9_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_9_errret

arg_9_continue:
%arg_9 = call ccc i64  @i64value(i8* %arg_9_val)
%arg_10_val = call ccc i8* @list_ref(i8* %_sc, i32 10,i8* %args)
%arg_10_rt_check = call i32 @is_cptr(i8* %arg_10_val)
%arg_10_bool = icmp ne i32 %arg_10_rt_check, 0
br i1 %arg_10_bool, label %arg_10_true, label %arg_10_false

arg_10_true:
br label %arg_10_continue

arg_10_false:
%var3212 = bitcast [252 x i8]* @gsxtmgraphics-pipeline118 to i8*
call i32 (i8*, ...) @printf(i8* %var3212)
%arg_10_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_10_errret

arg_10_continue:
%ttv_10 = call ccc i8* @cptr_value(i8* %arg_10_val)
%arg_10 = bitcast i8* %ttv_10 to %VAO*
%arg_11_val = call ccc i8* @list_ref(i8* %_sc, i32 11,i8* %args)
%arg_11_rt_check = call i32 @is_cptr(i8* %arg_11_val)
%arg_11_bool = icmp ne i32 %arg_11_rt_check, 0
br i1 %arg_11_bool, label %arg_11_true, label %arg_11_false

arg_11_true:
br label %arg_11_continue

arg_11_false:
%var3213 = bitcast [252 x i8]* @gsxtmgraphics-pipeline118 to i8*
call i32 (i8*, ...) @printf(i8* %var3213)
%arg_11_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_11_errret

arg_11_continue:
%ttv_11 = call ccc i8* @cptr_value(i8* %arg_11_val)
%arg_11 = bitcast i8* %ttv_11 to %String*
%arg_12_val = call ccc i8* @list_ref(i8* %_sc, i32 12,i8* %args)
%arg_12_rt_check = call i32 @is_integer(i8* %arg_12_val)
%arg_12_bool = icmp ne i32 %arg_12_rt_check, 0
br i1 %arg_12_bool, label %arg_12_true, label %arg_12_false

arg_12_true:
br label %arg_12_continue

arg_12_false:
%var3214 = bitcast [252 x i8]* @gsxtmgraphics-pipeline118 to i8*
call i32 (i8*, ...) @printf(i8* %var3214)
%arg_12_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_12_errret

arg_12_continue:
%arg_12 = call ccc i32  @i32value(i8* %arg_12_val)
%arg_13_val = call ccc i8* @list_ref(i8* %_sc, i32 13,i8* %args)
%arg_13_rt_check = call i32 @is_cptr(i8* %arg_13_val)
%arg_13_bool = icmp ne i32 %arg_13_rt_check, 0
br i1 %arg_13_bool, label %arg_13_true, label %arg_13_false

arg_13_true:
br label %arg_13_continue

arg_13_false:
%var3215 = bitcast [252 x i8]* @gsxtmgraphics-pipeline118 to i8*
call i32 (i8*, ...) @printf(i8* %var3215)
%arg_13_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_13_errret

arg_13_continue:
%ttv_13 = call ccc i8* @cptr_value(i8* %arg_13_val)
%arg_13 = bitcast i8* %ttv_13 to %XTMBone*
%arg_14_val = call ccc i8* @list_ref(i8* %_sc, i32 14,i8* %args)
%arg_14_rt_check = call i32 @is_integer(i8* %arg_14_val)
%arg_14_bool = icmp ne i32 %arg_14_rt_check, 0
br i1 %arg_14_bool, label %arg_14_true, label %arg_14_false

arg_14_true:
br label %arg_14_continue

arg_14_false:
%var3216 = bitcast [252 x i8]* @gsxtmgraphics-pipeline118 to i8*
call i32 (i8*, ...) @printf(i8* %var3216)
%arg_14_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_14_errret

arg_14_continue:
%arg_14 = call ccc i32  @i32value(i8* %arg_14_val)
%arg_15_val = call ccc i8* @list_ref(i8* %_sc, i32 15,i8* %args)
%arg_15_rt_check = call i32 @is_cptr(i8* %arg_15_val)
%arg_15_bool = icmp ne i32 %arg_15_rt_check, 0
br i1 %arg_15_bool, label %arg_15_true, label %arg_15_false

arg_15_true:
br label %arg_15_continue

arg_15_false:
%var3217 = bitcast [252 x i8]* @gsxtmgraphics-pipeline118 to i8*
call i32 (i8*, ...) @printf(i8* %var3217)
%arg_15_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_15_errret

arg_15_continue:
%ttv_15 = call ccc i8* @cptr_value(i8* %arg_15_val)
%arg_15 = bitcast i8* %ttv_15 to %Texture*
%arg_16_val = call ccc i8* @list_ref(i8* %_sc, i32 16,i8* %args)
%arg_16_rt_check = call i32 @is_cptr(i8* %arg_16_val)
%arg_16_bool = icmp ne i32 %arg_16_rt_check, 0
br i1 %arg_16_bool, label %arg_16_true, label %arg_16_false

arg_16_true:
br label %arg_16_continue

arg_16_false:
%var3218 = bitcast [252 x i8]* @gsxtmgraphics-pipeline118 to i8*
call i32 (i8*, ...) @printf(i8* %var3218)
%arg_16_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_16_errret

arg_16_continue:
%ttv_16 = call ccc i8* @cptr_value(i8* %arg_16_val)
%arg_16 = bitcast i8* %ttv_16 to %Texture*
%arg_17_val = call ccc i8* @list_ref(i8* %_sc, i32 17,i8* %args)
%arg_17_rt_check = call i32 @is_cptr(i8* %arg_17_val)
%arg_17_bool = icmp ne i32 %arg_17_rt_check, 0
br i1 %arg_17_bool, label %arg_17_true, label %arg_17_false

arg_17_true:
br label %arg_17_continue

arg_17_false:
%var3219 = bitcast [252 x i8]* @gsxtmgraphics-pipeline118 to i8*
call i32 (i8*, ...) @printf(i8* %var3219)
%arg_17_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_17_errret

arg_17_continue:
%ttv_17 = call ccc i8* @cptr_value(i8* %arg_17_val)
%arg_17 = bitcast i8* %ttv_17 to %Texture*
%arg_18_val = call ccc i8* @list_ref(i8* %_sc, i32 18,i8* %args)
%arg_18_rt_check = call i32 @is_cptr(i8* %arg_18_val)
%arg_18_bool = icmp ne i32 %arg_18_rt_check, 0
br i1 %arg_18_bool, label %arg_18_true, label %arg_18_false

arg_18_true:
br label %arg_18_continue

arg_18_false:
%var3220 = bitcast [252 x i8]* @gsxtmgraphics-pipeline118 to i8*
call i32 (i8*, ...) @printf(i8* %var3220)
%arg_18_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_18_errret

arg_18_continue:
%ttv_18 = call ccc i8* @cptr_value(i8* %arg_18_val)
%arg_18 = bitcast i8* %ttv_18 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*,  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float %arg_6, float %arg_7, i32 %arg_8, i64 %arg_9, %VAO* %arg_10, %String* %arg_11, i32 %arg_12, %XTMBone* %arg_13, i32 %arg_14, %Texture* %arg_15, %Texture* %arg_16, %Texture* %arg_17, %Texture* %arg_18)
%tmpres = bitcast %XTMMesh* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}*
%arg_p_0 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
%arg_p_1 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 1
%arg_1 = load %Texture*, %Texture** %arg_p_1
%arg_p_2 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 5
%arg_5 = load float*, float** %arg_p_5
%arg_p_6 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 6
%arg_6 = load float, float* %arg_p_6
%arg_p_7 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 7
%arg_7 = load float, float* %arg_p_7
%arg_p_8 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 8
%arg_8 = load i32, i32* %arg_p_8
%arg_p_9 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 9
%arg_9 = load i64, i64* %arg_p_9
%arg_p_10 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 10
%arg_10 = load %VAO*, %VAO** %arg_p_10
%arg_p_11 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 11
%arg_11 = load %String*, %String** %arg_p_11
%arg_p_12 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 12
%arg_12 = load i32, i32* %arg_p_12
%arg_p_13 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 13
%arg_13 = load %XTMBone*, %XTMBone** %arg_p_13
%arg_p_14 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 14
%arg_14 = load i32, i32* %arg_p_14
%arg_p_15 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 15
%arg_15 = load %Texture*, %Texture** %arg_p_15
%arg_p_16 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 16
%arg_16 = load %Texture*, %Texture** %arg_p_16
%arg_p_17 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 17
%arg_17 = load %Texture*, %Texture** %arg_p_17
%arg_p_18 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 18
%arg_18 = load %Texture*, %Texture** %arg_p_18
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*,  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float %arg_6, float %arg_7, i32 %arg_8, i64 %arg_9, %VAO* %arg_10, %String* %arg_11, i32 %arg_12, %XTMBone* %arg_13, i32 %arg_14, %Texture* %arg_15, %Texture* %arg_16, %Texture* %arg_17, %Texture* %arg_18)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline119 = hidden constant [201 x i8] c"XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd\00"
define dllexport fastcc %XTMMesh* @XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd__3221(i8* %_impz,i8* %_impenv, %VBO* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float %arg_6, float %arg_7, i32 %arg_8, i64 %arg_9, %VAO* %arg_10, %String* %arg_11, i32 %arg_12, %XTMBone* %arg_13, i32 %arg_14, %Texture* %arg_15, %Texture* %arg_16, %Texture* %arg_17, %Texture* %arg_18) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3222 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}*
%XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpdPtr_ = getelementptr {{i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}, {{i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}* %impenv, i32 0, i32 0
%XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpdPtr = load {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**** %XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpdPtr_

; setup arguments
%arg_0Ptr = alloca %VBO*
store %VBO* %arg_0, %VBO** %arg_0Ptr
%arg_1Ptr = alloca %Texture*
store %Texture* %arg_1, %Texture** %arg_1Ptr
%arg_2Ptr = alloca float*
store float* %arg_2, float** %arg_2Ptr
%arg_3Ptr = alloca float*
store float* %arg_3, float** %arg_3Ptr
%arg_4Ptr = alloca float*
store float* %arg_4, float** %arg_4Ptr
%arg_5Ptr = alloca float*
store float* %arg_5, float** %arg_5Ptr
%arg_6Ptr = alloca float
store float %arg_6, float* %arg_6Ptr
%arg_7Ptr = alloca float
store float %arg_7, float* %arg_7Ptr
%arg_8Ptr = alloca i32
store i32 %arg_8, i32* %arg_8Ptr
%arg_9Ptr = alloca i64
store i64 %arg_9, i64* %arg_9Ptr
%arg_10Ptr = alloca %VAO*
store %VAO* %arg_10, %VAO** %arg_10Ptr
%arg_11Ptr = alloca %String*
store %String* %arg_11, %String** %arg_11Ptr
%arg_12Ptr = alloca i32
store i32 %arg_12, i32* %arg_12Ptr
%arg_13Ptr = alloca %XTMBone*
store %XTMBone* %arg_13, %XTMBone** %arg_13Ptr
%arg_14Ptr = alloca i32
store i32 %arg_14, i32* %arg_14Ptr
%arg_15Ptr = alloca %Texture*
store %Texture* %arg_15, %Texture** %arg_15Ptr
%arg_16Ptr = alloca %Texture*
store %Texture* %arg_16, %Texture** %arg_16Ptr
%arg_17Ptr = alloca %Texture*
store %Texture* %arg_17, %Texture** %arg_17Ptr
%arg_18Ptr = alloca %Texture*
store %Texture* %arg_18, %Texture** %arg_18Ptr


%tzone3227 = load i8*, i8** %_impzPtr
%zone3228 = bitcast i8* %tzone3227 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMMesh*
%tzone3223 = load i8*, i8** %_impzPtr
%zone3224 = bitcast i8* %tzone3223 to %mzone*
%dat3225 = call i8* @llvm_zone_malloc(%mzone* %zone3224, i64 144)
call i8* @memset(i8* %dat3225, i32 0, i64 144)
%val3226 = bitcast i8* %dat3225 to %XTMMesh*

; let value assignment
%obj = select i1 true, %XTMMesh* %val3226, %XTMMesh* %val3226
store %XTMMesh* %obj, %XTMMesh** %objPtr

%val3229 = load %XTMMesh*, %XTMMesh** %objPtr
%val3230 = load %VBO*, %VBO** %arg_0Ptr
; set tuple
%val3231 = getelementptr %XTMMesh, %XTMMesh* %val3229, i64 0, i32 0
store %VBO* %val3230, %VBO** %val3231
%val3232 = load %XTMMesh*, %XTMMesh** %objPtr
%val3233 = load %Texture*, %Texture** %arg_1Ptr
; set tuple
%val3234 = getelementptr %XTMMesh, %XTMMesh* %val3232, i64 0, i32 1
store %Texture* %val3233, %Texture** %val3234
%val3235 = load %XTMMesh*, %XTMMesh** %objPtr
%val3236 = load float*, float** %arg_2Ptr
; set tuple
%val3237 = getelementptr %XTMMesh, %XTMMesh* %val3235, i64 0, i32 2
store float* %val3236, float** %val3237
%val3238 = load %XTMMesh*, %XTMMesh** %objPtr
%val3239 = load float*, float** %arg_3Ptr
; set tuple
%val3240 = getelementptr %XTMMesh, %XTMMesh* %val3238, i64 0, i32 3
store float* %val3239, float** %val3240
%val3241 = load %XTMMesh*, %XTMMesh** %objPtr
%val3242 = load float*, float** %arg_4Ptr
; set tuple
%val3243 = getelementptr %XTMMesh, %XTMMesh* %val3241, i64 0, i32 4
store float* %val3242, float** %val3243
%val3244 = load %XTMMesh*, %XTMMesh** %objPtr
%val3245 = load float*, float** %arg_5Ptr
; set tuple
%val3246 = getelementptr %XTMMesh, %XTMMesh* %val3244, i64 0, i32 5
store float* %val3245, float** %val3246
%val3247 = load %XTMMesh*, %XTMMesh** %objPtr
%val3248 = load float, float* %arg_6Ptr
; set tuple
%val3249 = getelementptr %XTMMesh, %XTMMesh* %val3247, i64 0, i32 6
store float %val3248, float* %val3249
%val3250 = load %XTMMesh*, %XTMMesh** %objPtr
%val3251 = load float, float* %arg_7Ptr
; set tuple
%val3252 = getelementptr %XTMMesh, %XTMMesh* %val3250, i64 0, i32 7
store float %val3251, float* %val3252
%val3253 = load %XTMMesh*, %XTMMesh** %objPtr
%val3254 = load i32, i32* %arg_8Ptr
; set tuple
%val3255 = getelementptr %XTMMesh, %XTMMesh* %val3253, i64 0, i32 8
store i32 %val3254, i32* %val3255
%val3256 = load %XTMMesh*, %XTMMesh** %objPtr
%val3257 = load i64, i64* %arg_9Ptr
; set tuple
%val3258 = getelementptr %XTMMesh, %XTMMesh* %val3256, i64 0, i32 9
store i64 %val3257, i64* %val3258
%val3259 = load %XTMMesh*, %XTMMesh** %objPtr
%val3260 = load %VAO*, %VAO** %arg_10Ptr
; set tuple
%val3261 = getelementptr %XTMMesh, %XTMMesh* %val3259, i64 0, i32 10
store %VAO* %val3260, %VAO** %val3261
%val3262 = load %XTMMesh*, %XTMMesh** %objPtr
%val3263 = load %String*, %String** %arg_11Ptr
; set tuple
%val3264 = getelementptr %XTMMesh, %XTMMesh* %val3262, i64 0, i32 11
store %String* %val3263, %String** %val3264
%val3265 = load %XTMMesh*, %XTMMesh** %objPtr
%val3266 = load i32, i32* %arg_12Ptr
; set tuple
%val3267 = getelementptr %XTMMesh, %XTMMesh* %val3265, i64 0, i32 12
store i32 %val3266, i32* %val3267
%val3268 = load %XTMMesh*, %XTMMesh** %objPtr
%val3269 = load %XTMBone*, %XTMBone** %arg_13Ptr
; set tuple
%val3270 = getelementptr %XTMMesh, %XTMMesh* %val3268, i64 0, i32 13
store %XTMBone* %val3269, %XTMBone** %val3270
%val3271 = load %XTMMesh*, %XTMMesh** %objPtr
%val3272 = load i32, i32* %arg_14Ptr
; set tuple
%val3273 = getelementptr %XTMMesh, %XTMMesh* %val3271, i64 0, i32 14
store i32 %val3272, i32* %val3273
%val3274 = load %XTMMesh*, %XTMMesh** %objPtr
%val3275 = load %Texture*, %Texture** %arg_15Ptr
; set tuple
%val3276 = getelementptr %XTMMesh, %XTMMesh* %val3274, i64 0, i32 15
store %Texture* %val3275, %Texture** %val3276
%val3277 = load %XTMMesh*, %XTMMesh** %objPtr
%val3278 = load %Texture*, %Texture** %arg_16Ptr
; set tuple
%val3279 = getelementptr %XTMMesh, %XTMMesh* %val3277, i64 0, i32 16
store %Texture* %val3278, %Texture** %val3279
%val3280 = load %XTMMesh*, %XTMMesh** %objPtr
%val3281 = load %Texture*, %Texture** %arg_17Ptr
; set tuple
%val3282 = getelementptr %XTMMesh, %XTMMesh* %val3280, i64 0, i32 17
store %Texture* %val3281, %Texture** %val3282
%val3283 = load %XTMMesh*, %XTMMesh** %objPtr
%val3284 = load %Texture*, %Texture** %arg_18Ptr
; set tuple
%val3285 = getelementptr %XTMMesh, %XTMMesh* %val3283, i64 0, i32 18
store %Texture* %val3284, %Texture** %val3285
%val3286 = load %XTMMesh*, %XTMMesh** %objPtr
ret %XTMMesh* %val3286
}
@gsxtmgraphics-pipeline120 = hidden constant [254 x i8] c"XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** @XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3306 = load i8*, i8** %_impzPtr
%zone3307 = bitcast i8* %tzone3306 to %mzone*

; let assign value to symbol XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd
%dat_XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd = call i8* @llvm_zone_malloc(%mzone* %zone3307, i64 8)
%XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpdPtr = bitcast i8* %dat_XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd to { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***
%tzone3287 = load i8*, i8** %_impzPtr
%zone3288 = bitcast i8* %tzone3287 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3288)
; malloc closure structure
%clsptr3289 = call i8* @llvm_zone_malloc(%mzone* %zone3288, i64 24)
%closure3290 = bitcast i8* %clsptr3289 to { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*

; malloc environment structure
%envptr3291 = call i8* @llvm_zone_malloc(%mzone* %zone3288, i64 8)
%environment3292 = bitcast i8* %envptr3291 to {{i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}*

; malloc closure address table
%addytable3293 = call %clsvar* @new_address_table()
%var3294 = bitcast [201 x i8]* @gsxtmgraphics-pipeline119 to i8*
%var3295 = bitcast [192 x i8]* @gsxtmgraphics-pipeline117 to i8*
%addytable3296 = call %clsvar* @add_address_table(%mzone* %zone3288, i8* %var3294, i32 0, i8* %var3295, i32 3, %clsvar* %addytable3293)
%address-table3297 = bitcast %clsvar* %addytable3296 to i8*

; insert table, function and environment into closure struct
%closure.table3300 = getelementptr { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure3290, i32 0, i32 0
store i8* %address-table3297, i8** %closure.table3300
%closure.env3301 = getelementptr { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure3290, i32 0, i32 1
store i8* %envptr3291, i8** %closure.env3301
%closure.func3302 = getelementptr { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure3290, i32 0, i32 2
store %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)* @XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd__3221, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)** %closure.func3302
%closure_size3303 = call i64 @llvm_zone_mark_size(%mzone* %zone3288)
call void @llvm_zone_ptr_set_size(i8* %clsptr3289, i64 %closure_size3303)
%wrapper_ptr3304 = call i8* @llvm_zone_malloc(%mzone* %zone3288, i64 8)
%closure_wrapper3305 = bitcast i8* %wrapper_ptr3304 to { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**
store { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure3290, { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_wrapper3305

; let value assignment
%XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd = select i1 true, { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_wrapper3305, { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_wrapper3305
store { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd, { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*** %XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpdPtr

; add data to environment
; don't need to alloc for env var XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd
%tmp_envptr3299 = getelementptr {{i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}, {{i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}* %environment3292, i32 0, i32 0
store {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*** %XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpdPtr, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**** %tmp_envptr3299


%val3308 = load {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*** %XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpdPtr
ret {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %val3308
}


@XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** @XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMMesh* @XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd(%VBO* %arg_0,%Texture* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float* %arg_5,float %arg_6,float %arg_7,i32 %arg_8,i64 %arg_9,%VAO* %arg_10,%String* %arg_11,i32 %arg_12,%XTMBone* %arg_13,i32 %arg_14,%Texture* %arg_15,%Texture* %arg_16,%Texture* %arg_17,%Texture* %arg_18) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*,  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float %arg_6, float %arg_7, i32 %arg_8, i64 %arg_9, %VAO* %arg_10, %String* %arg_11, i32 %arg_12, %XTMBone* %arg_13, i32 %arg_14, %Texture* %arg_15, %Texture* %arg_16, %Texture* %arg_17, %Texture* %arg_18)
ret %XTMMesh* %result
}


define dllexport ccc %XTMMesh* @XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_native(%VBO* %arg_0,%Texture* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float* %arg_5,float %arg_6,float %arg_7,i32 %arg_8,i64 %arg_9,%VAO* %arg_10,%String* %arg_11,i32 %arg_12,%XTMBone* %arg_13,i32 %arg_14,%Texture* %arg_15,%Texture* %arg_16,%Texture* %arg_17,%Texture* %arg_18) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*,  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float %arg_6, float %arg_7, i32 %arg_8, i64 %arg_9, %VAO* %arg_10, %String* %arg_11, i32 %arg_12, %XTMBone* %arg_13, i32 %arg_14, %Texture* %arg_15, %Texture* %arg_16, %Texture* %arg_17, %Texture* %arg_18)
ret %XTMMesh* %result
}


define dllexport ccc i8*  @XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3309 = bitcast [254 x i8]* @gsxtmgraphics-pipeline120 to i8*
call i32 (i8*, ...) @printf(i8* %var3309)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3310 = bitcast [254 x i8]* @gsxtmgraphics-pipeline120 to i8*
call i32 (i8*, ...) @printf(i8* %var3310)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Texture*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3311 = bitcast [254 x i8]* @gsxtmgraphics-pipeline120 to i8*
call i32 (i8*, ...) @printf(i8* %var3311)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var3312 = bitcast [254 x i8]* @gsxtmgraphics-pipeline120 to i8*
call i32 (i8*, ...) @printf(i8* %var3312)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var3313 = bitcast [254 x i8]* @gsxtmgraphics-pipeline120 to i8*
call i32 (i8*, ...) @printf(i8* %var3313)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var3314 = bitcast [254 x i8]* @gsxtmgraphics-pipeline120 to i8*
call i32 (i8*, ...) @printf(i8* %var3314)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to float*
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_real(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var3315 = bitcast [254 x i8]* @gsxtmgraphics-pipeline120 to i8*
call i32 (i8*, ...) @printf(i8* %var3315)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%arg_6 = call ccc float  @r32value(i8* %arg_6_val)
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_real(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var3316 = bitcast [254 x i8]* @gsxtmgraphics-pipeline120 to i8*
call i32 (i8*, ...) @printf(i8* %var3316)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%arg_7 = call ccc float  @r32value(i8* %arg_7_val)
%arg_8_val = call ccc i8* @list_ref(i8* %_sc, i32 8,i8* %args)
%arg_8_rt_check = call i32 @is_integer(i8* %arg_8_val)
%arg_8_bool = icmp ne i32 %arg_8_rt_check, 0
br i1 %arg_8_bool, label %arg_8_true, label %arg_8_false

arg_8_true:
br label %arg_8_continue

arg_8_false:
%var3317 = bitcast [254 x i8]* @gsxtmgraphics-pipeline120 to i8*
call i32 (i8*, ...) @printf(i8* %var3317)
%arg_8_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_8_errret

arg_8_continue:
%arg_8 = call ccc i32  @i32value(i8* %arg_8_val)
%arg_9_val = call ccc i8* @list_ref(i8* %_sc, i32 9,i8* %args)
%arg_9_rt_check = call i32 @is_integer(i8* %arg_9_val)
%arg_9_bool = icmp ne i32 %arg_9_rt_check, 0
br i1 %arg_9_bool, label %arg_9_true, label %arg_9_false

arg_9_true:
br label %arg_9_continue

arg_9_false:
%var3318 = bitcast [254 x i8]* @gsxtmgraphics-pipeline120 to i8*
call i32 (i8*, ...) @printf(i8* %var3318)
%arg_9_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_9_errret

arg_9_continue:
%arg_9 = call ccc i64  @i64value(i8* %arg_9_val)
%arg_10_val = call ccc i8* @list_ref(i8* %_sc, i32 10,i8* %args)
%arg_10_rt_check = call i32 @is_cptr(i8* %arg_10_val)
%arg_10_bool = icmp ne i32 %arg_10_rt_check, 0
br i1 %arg_10_bool, label %arg_10_true, label %arg_10_false

arg_10_true:
br label %arg_10_continue

arg_10_false:
%var3319 = bitcast [254 x i8]* @gsxtmgraphics-pipeline120 to i8*
call i32 (i8*, ...) @printf(i8* %var3319)
%arg_10_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_10_errret

arg_10_continue:
%ttv_10 = call ccc i8* @cptr_value(i8* %arg_10_val)
%arg_10 = bitcast i8* %ttv_10 to %VAO*
%arg_11_val = call ccc i8* @list_ref(i8* %_sc, i32 11,i8* %args)
%arg_11_rt_check = call i32 @is_cptr(i8* %arg_11_val)
%arg_11_bool = icmp ne i32 %arg_11_rt_check, 0
br i1 %arg_11_bool, label %arg_11_true, label %arg_11_false

arg_11_true:
br label %arg_11_continue

arg_11_false:
%var3320 = bitcast [254 x i8]* @gsxtmgraphics-pipeline120 to i8*
call i32 (i8*, ...) @printf(i8* %var3320)
%arg_11_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_11_errret

arg_11_continue:
%ttv_11 = call ccc i8* @cptr_value(i8* %arg_11_val)
%arg_11 = bitcast i8* %ttv_11 to %String*
%arg_12_val = call ccc i8* @list_ref(i8* %_sc, i32 12,i8* %args)
%arg_12_rt_check = call i32 @is_integer(i8* %arg_12_val)
%arg_12_bool = icmp ne i32 %arg_12_rt_check, 0
br i1 %arg_12_bool, label %arg_12_true, label %arg_12_false

arg_12_true:
br label %arg_12_continue

arg_12_false:
%var3321 = bitcast [254 x i8]* @gsxtmgraphics-pipeline120 to i8*
call i32 (i8*, ...) @printf(i8* %var3321)
%arg_12_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_12_errret

arg_12_continue:
%arg_12 = call ccc i32  @i32value(i8* %arg_12_val)
%arg_13_val = call ccc i8* @list_ref(i8* %_sc, i32 13,i8* %args)
%arg_13_rt_check = call i32 @is_cptr(i8* %arg_13_val)
%arg_13_bool = icmp ne i32 %arg_13_rt_check, 0
br i1 %arg_13_bool, label %arg_13_true, label %arg_13_false

arg_13_true:
br label %arg_13_continue

arg_13_false:
%var3322 = bitcast [254 x i8]* @gsxtmgraphics-pipeline120 to i8*
call i32 (i8*, ...) @printf(i8* %var3322)
%arg_13_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_13_errret

arg_13_continue:
%ttv_13 = call ccc i8* @cptr_value(i8* %arg_13_val)
%arg_13 = bitcast i8* %ttv_13 to %XTMBone*
%arg_14_val = call ccc i8* @list_ref(i8* %_sc, i32 14,i8* %args)
%arg_14_rt_check = call i32 @is_integer(i8* %arg_14_val)
%arg_14_bool = icmp ne i32 %arg_14_rt_check, 0
br i1 %arg_14_bool, label %arg_14_true, label %arg_14_false

arg_14_true:
br label %arg_14_continue

arg_14_false:
%var3323 = bitcast [254 x i8]* @gsxtmgraphics-pipeline120 to i8*
call i32 (i8*, ...) @printf(i8* %var3323)
%arg_14_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_14_errret

arg_14_continue:
%arg_14 = call ccc i32  @i32value(i8* %arg_14_val)
%arg_15_val = call ccc i8* @list_ref(i8* %_sc, i32 15,i8* %args)
%arg_15_rt_check = call i32 @is_cptr(i8* %arg_15_val)
%arg_15_bool = icmp ne i32 %arg_15_rt_check, 0
br i1 %arg_15_bool, label %arg_15_true, label %arg_15_false

arg_15_true:
br label %arg_15_continue

arg_15_false:
%var3324 = bitcast [254 x i8]* @gsxtmgraphics-pipeline120 to i8*
call i32 (i8*, ...) @printf(i8* %var3324)
%arg_15_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_15_errret

arg_15_continue:
%ttv_15 = call ccc i8* @cptr_value(i8* %arg_15_val)
%arg_15 = bitcast i8* %ttv_15 to %Texture*
%arg_16_val = call ccc i8* @list_ref(i8* %_sc, i32 16,i8* %args)
%arg_16_rt_check = call i32 @is_cptr(i8* %arg_16_val)
%arg_16_bool = icmp ne i32 %arg_16_rt_check, 0
br i1 %arg_16_bool, label %arg_16_true, label %arg_16_false

arg_16_true:
br label %arg_16_continue

arg_16_false:
%var3325 = bitcast [254 x i8]* @gsxtmgraphics-pipeline120 to i8*
call i32 (i8*, ...) @printf(i8* %var3325)
%arg_16_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_16_errret

arg_16_continue:
%ttv_16 = call ccc i8* @cptr_value(i8* %arg_16_val)
%arg_16 = bitcast i8* %ttv_16 to %Texture*
%arg_17_val = call ccc i8* @list_ref(i8* %_sc, i32 17,i8* %args)
%arg_17_rt_check = call i32 @is_cptr(i8* %arg_17_val)
%arg_17_bool = icmp ne i32 %arg_17_rt_check, 0
br i1 %arg_17_bool, label %arg_17_true, label %arg_17_false

arg_17_true:
br label %arg_17_continue

arg_17_false:
%var3326 = bitcast [254 x i8]* @gsxtmgraphics-pipeline120 to i8*
call i32 (i8*, ...) @printf(i8* %var3326)
%arg_17_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_17_errret

arg_17_continue:
%ttv_17 = call ccc i8* @cptr_value(i8* %arg_17_val)
%arg_17 = bitcast i8* %ttv_17 to %Texture*
%arg_18_val = call ccc i8* @list_ref(i8* %_sc, i32 18,i8* %args)
%arg_18_rt_check = call i32 @is_cptr(i8* %arg_18_val)
%arg_18_bool = icmp ne i32 %arg_18_rt_check, 0
br i1 %arg_18_bool, label %arg_18_true, label %arg_18_false

arg_18_true:
br label %arg_18_continue

arg_18_false:
%var3327 = bitcast [254 x i8]* @gsxtmgraphics-pipeline120 to i8*
call i32 (i8*, ...) @printf(i8* %var3327)
%arg_18_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_18_errret

arg_18_continue:
%ttv_18 = call ccc i8* @cptr_value(i8* %arg_18_val)
%arg_18 = bitcast i8* %ttv_18 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*,  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float %arg_6, float %arg_7, i32 %arg_8, i64 %arg_9, %VAO* %arg_10, %String* %arg_11, i32 %arg_12, %XTMBone* %arg_13, i32 %arg_14, %Texture* %arg_15, %Texture* %arg_16, %Texture* %arg_17, %Texture* %arg_18)
%tmpres = bitcast %XTMMesh* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}*
%arg_p_0 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
%arg_p_1 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 1
%arg_1 = load %Texture*, %Texture** %arg_p_1
%arg_p_2 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 5
%arg_5 = load float*, float** %arg_p_5
%arg_p_6 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 6
%arg_6 = load float, float* %arg_p_6
%arg_p_7 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 7
%arg_7 = load float, float* %arg_p_7
%arg_p_8 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 8
%arg_8 = load i32, i32* %arg_p_8
%arg_p_9 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 9
%arg_9 = load i64, i64* %arg_p_9
%arg_p_10 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 10
%arg_10 = load %VAO*, %VAO** %arg_p_10
%arg_p_11 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 11
%arg_11 = load %String*, %String** %arg_p_11
%arg_p_12 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 12
%arg_12 = load i32, i32* %arg_p_12
%arg_p_13 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 13
%arg_13 = load %XTMBone*, %XTMBone** %arg_p_13
%arg_p_14 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 14
%arg_14 = load i32, i32* %arg_p_14
%arg_p_15 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 15
%arg_15 = load %Texture*, %Texture** %arg_p_15
%arg_p_16 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 16
%arg_16 = load %Texture*, %Texture** %arg_p_16
%arg_p_17 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 17
%arg_17 = load %Texture*, %Texture** %arg_p_17
%arg_p_18 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 18
%arg_18 = load %Texture*, %Texture** %arg_p_18
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_z_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*,  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float %arg_6, float %arg_7, i32 %arg_8, i64 %arg_9, %VAO* %arg_10, %String* %arg_11, i32 %arg_12, %XTMBone* %arg_13, i32 %arg_14, %Texture* %arg_15, %Texture* %arg_16, %Texture* %arg_17, %Texture* %arg_18)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline121 = hidden constant [201 x i8] c"XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd\00"
define dllexport fastcc %XTMMesh* @XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd__3328(i8* %_impz,i8* %_impenv, %VBO* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float %arg_6, float %arg_7, i32 %arg_8, i64 %arg_9, %VAO* %arg_10, %String* %arg_11, i32 %arg_12, %XTMBone* %arg_13, i32 %arg_14, %Texture* %arg_15, %Texture* %arg_16, %Texture* %arg_17, %Texture* %arg_18) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3329 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}*
%XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpdPtr_ = getelementptr {{i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}, {{i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}* %impenv, i32 0, i32 0
%XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpdPtr = load {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**** %XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpdPtr_

; setup arguments
%arg_0Ptr = alloca %VBO*
store %VBO* %arg_0, %VBO** %arg_0Ptr
%arg_1Ptr = alloca %Texture*
store %Texture* %arg_1, %Texture** %arg_1Ptr
%arg_2Ptr = alloca float*
store float* %arg_2, float** %arg_2Ptr
%arg_3Ptr = alloca float*
store float* %arg_3, float** %arg_3Ptr
%arg_4Ptr = alloca float*
store float* %arg_4, float** %arg_4Ptr
%arg_5Ptr = alloca float*
store float* %arg_5, float** %arg_5Ptr
%arg_6Ptr = alloca float
store float %arg_6, float* %arg_6Ptr
%arg_7Ptr = alloca float
store float %arg_7, float* %arg_7Ptr
%arg_8Ptr = alloca i32
store i32 %arg_8, i32* %arg_8Ptr
%arg_9Ptr = alloca i64
store i64 %arg_9, i64* %arg_9Ptr
%arg_10Ptr = alloca %VAO*
store %VAO* %arg_10, %VAO** %arg_10Ptr
%arg_11Ptr = alloca %String*
store %String* %arg_11, %String** %arg_11Ptr
%arg_12Ptr = alloca i32
store i32 %arg_12, i32* %arg_12Ptr
%arg_13Ptr = alloca %XTMBone*
store %XTMBone* %arg_13, %XTMBone** %arg_13Ptr
%arg_14Ptr = alloca i32
store i32 %arg_14, i32* %arg_14Ptr
%arg_15Ptr = alloca %Texture*
store %Texture* %arg_15, %Texture** %arg_15Ptr
%arg_16Ptr = alloca %Texture*
store %Texture* %arg_16, %Texture** %arg_16Ptr
%arg_17Ptr = alloca %Texture*
store %Texture* %arg_17, %Texture** %arg_17Ptr
%arg_18Ptr = alloca %Texture*
store %Texture* %arg_18, %Texture** %arg_18Ptr


%tzone3332 = load i8*, i8** %_impzPtr
%zone3333 = bitcast i8* %tzone3332 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMMesh*
%dat3330 = call i8* @malloc(i64 144)
call i8* @memset(i8* %dat3330, i32 0, i64 144)
%val3331 = bitcast i8* %dat3330 to %XTMMesh*

; let value assignment
%obj = select i1 true, %XTMMesh* %val3331, %XTMMesh* %val3331
store %XTMMesh* %obj, %XTMMesh** %objPtr

%val3334 = load %XTMMesh*, %XTMMesh** %objPtr
%val3335 = load %VBO*, %VBO** %arg_0Ptr
; set tuple
%val3336 = getelementptr %XTMMesh, %XTMMesh* %val3334, i64 0, i32 0
store %VBO* %val3335, %VBO** %val3336
%val3337 = load %XTMMesh*, %XTMMesh** %objPtr
%val3338 = load %Texture*, %Texture** %arg_1Ptr
; set tuple
%val3339 = getelementptr %XTMMesh, %XTMMesh* %val3337, i64 0, i32 1
store %Texture* %val3338, %Texture** %val3339
%val3340 = load %XTMMesh*, %XTMMesh** %objPtr
%val3341 = load float*, float** %arg_2Ptr
; set tuple
%val3342 = getelementptr %XTMMesh, %XTMMesh* %val3340, i64 0, i32 2
store float* %val3341, float** %val3342
%val3343 = load %XTMMesh*, %XTMMesh** %objPtr
%val3344 = load float*, float** %arg_3Ptr
; set tuple
%val3345 = getelementptr %XTMMesh, %XTMMesh* %val3343, i64 0, i32 3
store float* %val3344, float** %val3345
%val3346 = load %XTMMesh*, %XTMMesh** %objPtr
%val3347 = load float*, float** %arg_4Ptr
; set tuple
%val3348 = getelementptr %XTMMesh, %XTMMesh* %val3346, i64 0, i32 4
store float* %val3347, float** %val3348
%val3349 = load %XTMMesh*, %XTMMesh** %objPtr
%val3350 = load float*, float** %arg_5Ptr
; set tuple
%val3351 = getelementptr %XTMMesh, %XTMMesh* %val3349, i64 0, i32 5
store float* %val3350, float** %val3351
%val3352 = load %XTMMesh*, %XTMMesh** %objPtr
%val3353 = load float, float* %arg_6Ptr
; set tuple
%val3354 = getelementptr %XTMMesh, %XTMMesh* %val3352, i64 0, i32 6
store float %val3353, float* %val3354
%val3355 = load %XTMMesh*, %XTMMesh** %objPtr
%val3356 = load float, float* %arg_7Ptr
; set tuple
%val3357 = getelementptr %XTMMesh, %XTMMesh* %val3355, i64 0, i32 7
store float %val3356, float* %val3357
%val3358 = load %XTMMesh*, %XTMMesh** %objPtr
%val3359 = load i32, i32* %arg_8Ptr
; set tuple
%val3360 = getelementptr %XTMMesh, %XTMMesh* %val3358, i64 0, i32 8
store i32 %val3359, i32* %val3360
%val3361 = load %XTMMesh*, %XTMMesh** %objPtr
%val3362 = load i64, i64* %arg_9Ptr
; set tuple
%val3363 = getelementptr %XTMMesh, %XTMMesh* %val3361, i64 0, i32 9
store i64 %val3362, i64* %val3363
%val3364 = load %XTMMesh*, %XTMMesh** %objPtr
%val3365 = load %VAO*, %VAO** %arg_10Ptr
; set tuple
%val3366 = getelementptr %XTMMesh, %XTMMesh* %val3364, i64 0, i32 10
store %VAO* %val3365, %VAO** %val3366
%val3367 = load %XTMMesh*, %XTMMesh** %objPtr
%val3368 = load %String*, %String** %arg_11Ptr
; set tuple
%val3369 = getelementptr %XTMMesh, %XTMMesh* %val3367, i64 0, i32 11
store %String* %val3368, %String** %val3369
%val3370 = load %XTMMesh*, %XTMMesh** %objPtr
%val3371 = load i32, i32* %arg_12Ptr
; set tuple
%val3372 = getelementptr %XTMMesh, %XTMMesh* %val3370, i64 0, i32 12
store i32 %val3371, i32* %val3372
%val3373 = load %XTMMesh*, %XTMMesh** %objPtr
%val3374 = load %XTMBone*, %XTMBone** %arg_13Ptr
; set tuple
%val3375 = getelementptr %XTMMesh, %XTMMesh* %val3373, i64 0, i32 13
store %XTMBone* %val3374, %XTMBone** %val3375
%val3376 = load %XTMMesh*, %XTMMesh** %objPtr
%val3377 = load i32, i32* %arg_14Ptr
; set tuple
%val3378 = getelementptr %XTMMesh, %XTMMesh* %val3376, i64 0, i32 14
store i32 %val3377, i32* %val3378
%val3379 = load %XTMMesh*, %XTMMesh** %objPtr
%val3380 = load %Texture*, %Texture** %arg_15Ptr
; set tuple
%val3381 = getelementptr %XTMMesh, %XTMMesh* %val3379, i64 0, i32 15
store %Texture* %val3380, %Texture** %val3381
%val3382 = load %XTMMesh*, %XTMMesh** %objPtr
%val3383 = load %Texture*, %Texture** %arg_16Ptr
; set tuple
%val3384 = getelementptr %XTMMesh, %XTMMesh* %val3382, i64 0, i32 16
store %Texture* %val3383, %Texture** %val3384
%val3385 = load %XTMMesh*, %XTMMesh** %objPtr
%val3386 = load %Texture*, %Texture** %arg_17Ptr
; set tuple
%val3387 = getelementptr %XTMMesh, %XTMMesh* %val3385, i64 0, i32 17
store %Texture* %val3386, %Texture** %val3387
%val3388 = load %XTMMesh*, %XTMMesh** %objPtr
%val3389 = load %Texture*, %Texture** %arg_18Ptr
; set tuple
%val3390 = getelementptr %XTMMesh, %XTMMesh* %val3388, i64 0, i32 18
store %Texture* %val3389, %Texture** %val3390
%val3391 = load %XTMMesh*, %XTMMesh** %objPtr
ret %XTMMesh* %val3391
}
@gsxtmgraphics-pipeline122 = hidden constant [254 x i8] c"XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** @XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3411 = load i8*, i8** %_impzPtr
%zone3412 = bitcast i8* %tzone3411 to %mzone*

; let assign value to symbol XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd
%dat_XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd = call i8* @llvm_zone_malloc(%mzone* %zone3412, i64 8)
%XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpdPtr = bitcast i8* %dat_XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd to { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***
%tzone3392 = load i8*, i8** %_impzPtr
%zone3393 = bitcast i8* %tzone3392 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3393)
; malloc closure structure
%clsptr3394 = call i8* @llvm_zone_malloc(%mzone* %zone3393, i64 24)
%closure3395 = bitcast i8* %clsptr3394 to { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*

; malloc environment structure
%envptr3396 = call i8* @llvm_zone_malloc(%mzone* %zone3393, i64 8)
%environment3397 = bitcast i8* %envptr3396 to {{i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}*

; malloc closure address table
%addytable3398 = call %clsvar* @new_address_table()
%var3399 = bitcast [201 x i8]* @gsxtmgraphics-pipeline121 to i8*
%var3400 = bitcast [192 x i8]* @gsxtmgraphics-pipeline117 to i8*
%addytable3401 = call %clsvar* @add_address_table(%mzone* %zone3393, i8* %var3399, i32 0, i8* %var3400, i32 3, %clsvar* %addytable3398)
%address-table3402 = bitcast %clsvar* %addytable3401 to i8*

; insert table, function and environment into closure struct
%closure.table3405 = getelementptr { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure3395, i32 0, i32 0
store i8* %address-table3402, i8** %closure.table3405
%closure.env3406 = getelementptr { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure3395, i32 0, i32 1
store i8* %envptr3396, i8** %closure.env3406
%closure.func3407 = getelementptr { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure3395, i32 0, i32 2
store %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)* @XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd__3328, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)** %closure.func3407
%closure_size3408 = call i64 @llvm_zone_mark_size(%mzone* %zone3393)
call void @llvm_zone_ptr_set_size(i8* %clsptr3394, i64 %closure_size3408)
%wrapper_ptr3409 = call i8* @llvm_zone_malloc(%mzone* %zone3393, i64 8)
%closure_wrapper3410 = bitcast i8* %wrapper_ptr3409 to { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**
store { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure3395, { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_wrapper3410

; let value assignment
%XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd = select i1 true, { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_wrapper3410, { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_wrapper3410
store { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd, { i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*** %XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpdPtr

; add data to environment
; don't need to alloc for env var XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd
%tmp_envptr3404 = getelementptr {{i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}, {{i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}* %environment3397, i32 0, i32 0
store {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*** %XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpdPtr, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**** %tmp_envptr3404


%val3413 = load {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*** %XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpdPtr
ret {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %val3413
}


@XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** @XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMMesh* @XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd(%VBO* %arg_0,%Texture* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float* %arg_5,float %arg_6,float %arg_7,i32 %arg_8,i64 %arg_9,%VAO* %arg_10,%String* %arg_11,i32 %arg_12,%XTMBone* %arg_13,i32 %arg_14,%Texture* %arg_15,%Texture* %arg_16,%Texture* %arg_17,%Texture* %arg_18) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*,  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float %arg_6, float %arg_7, i32 %arg_8, i64 %arg_9, %VAO* %arg_10, %String* %arg_11, i32 %arg_12, %XTMBone* %arg_13, i32 %arg_14, %Texture* %arg_15, %Texture* %arg_16, %Texture* %arg_17, %Texture* %arg_18)
ret %XTMMesh* %result
}


define dllexport ccc %XTMMesh* @XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_native(%VBO* %arg_0,%Texture* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float* %arg_5,float %arg_6,float %arg_7,i32 %arg_8,i64 %arg_9,%VAO* %arg_10,%String* %arg_11,i32 %arg_12,%XTMBone* %arg_13,i32 %arg_14,%Texture* %arg_15,%Texture* %arg_16,%Texture* %arg_17,%Texture* %arg_18) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*,  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float %arg_6, float %arg_7, i32 %arg_8, i64 %arg_9, %VAO* %arg_10, %String* %arg_11, i32 %arg_12, %XTMBone* %arg_13, i32 %arg_14, %Texture* %arg_15, %Texture* %arg_16, %Texture* %arg_17, %Texture* %arg_18)
ret %XTMMesh* %result
}


define dllexport ccc i8*  @XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3414 = bitcast [254 x i8]* @gsxtmgraphics-pipeline122 to i8*
call i32 (i8*, ...) @printf(i8* %var3414)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3415 = bitcast [254 x i8]* @gsxtmgraphics-pipeline122 to i8*
call i32 (i8*, ...) @printf(i8* %var3415)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Texture*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3416 = bitcast [254 x i8]* @gsxtmgraphics-pipeline122 to i8*
call i32 (i8*, ...) @printf(i8* %var3416)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var3417 = bitcast [254 x i8]* @gsxtmgraphics-pipeline122 to i8*
call i32 (i8*, ...) @printf(i8* %var3417)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var3418 = bitcast [254 x i8]* @gsxtmgraphics-pipeline122 to i8*
call i32 (i8*, ...) @printf(i8* %var3418)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var3419 = bitcast [254 x i8]* @gsxtmgraphics-pipeline122 to i8*
call i32 (i8*, ...) @printf(i8* %var3419)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to float*
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_real(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var3420 = bitcast [254 x i8]* @gsxtmgraphics-pipeline122 to i8*
call i32 (i8*, ...) @printf(i8* %var3420)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%arg_6 = call ccc float  @r32value(i8* %arg_6_val)
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_real(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var3421 = bitcast [254 x i8]* @gsxtmgraphics-pipeline122 to i8*
call i32 (i8*, ...) @printf(i8* %var3421)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%arg_7 = call ccc float  @r32value(i8* %arg_7_val)
%arg_8_val = call ccc i8* @list_ref(i8* %_sc, i32 8,i8* %args)
%arg_8_rt_check = call i32 @is_integer(i8* %arg_8_val)
%arg_8_bool = icmp ne i32 %arg_8_rt_check, 0
br i1 %arg_8_bool, label %arg_8_true, label %arg_8_false

arg_8_true:
br label %arg_8_continue

arg_8_false:
%var3422 = bitcast [254 x i8]* @gsxtmgraphics-pipeline122 to i8*
call i32 (i8*, ...) @printf(i8* %var3422)
%arg_8_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_8_errret

arg_8_continue:
%arg_8 = call ccc i32  @i32value(i8* %arg_8_val)
%arg_9_val = call ccc i8* @list_ref(i8* %_sc, i32 9,i8* %args)
%arg_9_rt_check = call i32 @is_integer(i8* %arg_9_val)
%arg_9_bool = icmp ne i32 %arg_9_rt_check, 0
br i1 %arg_9_bool, label %arg_9_true, label %arg_9_false

arg_9_true:
br label %arg_9_continue

arg_9_false:
%var3423 = bitcast [254 x i8]* @gsxtmgraphics-pipeline122 to i8*
call i32 (i8*, ...) @printf(i8* %var3423)
%arg_9_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_9_errret

arg_9_continue:
%arg_9 = call ccc i64  @i64value(i8* %arg_9_val)
%arg_10_val = call ccc i8* @list_ref(i8* %_sc, i32 10,i8* %args)
%arg_10_rt_check = call i32 @is_cptr(i8* %arg_10_val)
%arg_10_bool = icmp ne i32 %arg_10_rt_check, 0
br i1 %arg_10_bool, label %arg_10_true, label %arg_10_false

arg_10_true:
br label %arg_10_continue

arg_10_false:
%var3424 = bitcast [254 x i8]* @gsxtmgraphics-pipeline122 to i8*
call i32 (i8*, ...) @printf(i8* %var3424)
%arg_10_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_10_errret

arg_10_continue:
%ttv_10 = call ccc i8* @cptr_value(i8* %arg_10_val)
%arg_10 = bitcast i8* %ttv_10 to %VAO*
%arg_11_val = call ccc i8* @list_ref(i8* %_sc, i32 11,i8* %args)
%arg_11_rt_check = call i32 @is_cptr(i8* %arg_11_val)
%arg_11_bool = icmp ne i32 %arg_11_rt_check, 0
br i1 %arg_11_bool, label %arg_11_true, label %arg_11_false

arg_11_true:
br label %arg_11_continue

arg_11_false:
%var3425 = bitcast [254 x i8]* @gsxtmgraphics-pipeline122 to i8*
call i32 (i8*, ...) @printf(i8* %var3425)
%arg_11_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_11_errret

arg_11_continue:
%ttv_11 = call ccc i8* @cptr_value(i8* %arg_11_val)
%arg_11 = bitcast i8* %ttv_11 to %String*
%arg_12_val = call ccc i8* @list_ref(i8* %_sc, i32 12,i8* %args)
%arg_12_rt_check = call i32 @is_integer(i8* %arg_12_val)
%arg_12_bool = icmp ne i32 %arg_12_rt_check, 0
br i1 %arg_12_bool, label %arg_12_true, label %arg_12_false

arg_12_true:
br label %arg_12_continue

arg_12_false:
%var3426 = bitcast [254 x i8]* @gsxtmgraphics-pipeline122 to i8*
call i32 (i8*, ...) @printf(i8* %var3426)
%arg_12_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_12_errret

arg_12_continue:
%arg_12 = call ccc i32  @i32value(i8* %arg_12_val)
%arg_13_val = call ccc i8* @list_ref(i8* %_sc, i32 13,i8* %args)
%arg_13_rt_check = call i32 @is_cptr(i8* %arg_13_val)
%arg_13_bool = icmp ne i32 %arg_13_rt_check, 0
br i1 %arg_13_bool, label %arg_13_true, label %arg_13_false

arg_13_true:
br label %arg_13_continue

arg_13_false:
%var3427 = bitcast [254 x i8]* @gsxtmgraphics-pipeline122 to i8*
call i32 (i8*, ...) @printf(i8* %var3427)
%arg_13_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_13_errret

arg_13_continue:
%ttv_13 = call ccc i8* @cptr_value(i8* %arg_13_val)
%arg_13 = bitcast i8* %ttv_13 to %XTMBone*
%arg_14_val = call ccc i8* @list_ref(i8* %_sc, i32 14,i8* %args)
%arg_14_rt_check = call i32 @is_integer(i8* %arg_14_val)
%arg_14_bool = icmp ne i32 %arg_14_rt_check, 0
br i1 %arg_14_bool, label %arg_14_true, label %arg_14_false

arg_14_true:
br label %arg_14_continue

arg_14_false:
%var3428 = bitcast [254 x i8]* @gsxtmgraphics-pipeline122 to i8*
call i32 (i8*, ...) @printf(i8* %var3428)
%arg_14_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_14_errret

arg_14_continue:
%arg_14 = call ccc i32  @i32value(i8* %arg_14_val)
%arg_15_val = call ccc i8* @list_ref(i8* %_sc, i32 15,i8* %args)
%arg_15_rt_check = call i32 @is_cptr(i8* %arg_15_val)
%arg_15_bool = icmp ne i32 %arg_15_rt_check, 0
br i1 %arg_15_bool, label %arg_15_true, label %arg_15_false

arg_15_true:
br label %arg_15_continue

arg_15_false:
%var3429 = bitcast [254 x i8]* @gsxtmgraphics-pipeline122 to i8*
call i32 (i8*, ...) @printf(i8* %var3429)
%arg_15_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_15_errret

arg_15_continue:
%ttv_15 = call ccc i8* @cptr_value(i8* %arg_15_val)
%arg_15 = bitcast i8* %ttv_15 to %Texture*
%arg_16_val = call ccc i8* @list_ref(i8* %_sc, i32 16,i8* %args)
%arg_16_rt_check = call i32 @is_cptr(i8* %arg_16_val)
%arg_16_bool = icmp ne i32 %arg_16_rt_check, 0
br i1 %arg_16_bool, label %arg_16_true, label %arg_16_false

arg_16_true:
br label %arg_16_continue

arg_16_false:
%var3430 = bitcast [254 x i8]* @gsxtmgraphics-pipeline122 to i8*
call i32 (i8*, ...) @printf(i8* %var3430)
%arg_16_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_16_errret

arg_16_continue:
%ttv_16 = call ccc i8* @cptr_value(i8* %arg_16_val)
%arg_16 = bitcast i8* %ttv_16 to %Texture*
%arg_17_val = call ccc i8* @list_ref(i8* %_sc, i32 17,i8* %args)
%arg_17_rt_check = call i32 @is_cptr(i8* %arg_17_val)
%arg_17_bool = icmp ne i32 %arg_17_rt_check, 0
br i1 %arg_17_bool, label %arg_17_true, label %arg_17_false

arg_17_true:
br label %arg_17_continue

arg_17_false:
%var3431 = bitcast [254 x i8]* @gsxtmgraphics-pipeline122 to i8*
call i32 (i8*, ...) @printf(i8* %var3431)
%arg_17_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_17_errret

arg_17_continue:
%ttv_17 = call ccc i8* @cptr_value(i8* %arg_17_val)
%arg_17 = bitcast i8* %ttv_17 to %Texture*
%arg_18_val = call ccc i8* @list_ref(i8* %_sc, i32 18,i8* %args)
%arg_18_rt_check = call i32 @is_cptr(i8* %arg_18_val)
%arg_18_bool = icmp ne i32 %arg_18_rt_check, 0
br i1 %arg_18_bool, label %arg_18_true, label %arg_18_false

arg_18_true:
br label %arg_18_continue

arg_18_false:
%var3432 = bitcast [254 x i8]* @gsxtmgraphics-pipeline122 to i8*
call i32 (i8*, ...) @printf(i8* %var3432)
%arg_18_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_18_errret

arg_18_continue:
%ttv_18 = call ccc i8* @cptr_value(i8* %arg_18_val)
%arg_18 = bitcast i8* %ttv_18 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*,  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float %arg_6, float %arg_7, i32 %arg_8, i64 %arg_9, %VAO* %arg_10, %String* %arg_11, i32 %arg_12, %XTMBone* %arg_13, i32 %arg_14, %Texture* %arg_15, %Texture* %arg_16, %Texture* %arg_17, %Texture* %arg_18)
%tmpres = bitcast %XTMMesh* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}*
%arg_p_0 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
%arg_p_1 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 1
%arg_1 = load %Texture*, %Texture** %arg_p_1
%arg_p_2 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 5
%arg_5 = load float*, float** %arg_p_5
%arg_p_6 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 6
%arg_6 = load float, float* %arg_p_6
%arg_p_7 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 7
%arg_7 = load float, float* %arg_p_7
%arg_p_8 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 8
%arg_8 = load i32, i32* %arg_p_8
%arg_p_9 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 9
%arg_9 = load i64, i64* %arg_p_9
%arg_p_10 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 10
%arg_10 = load %VAO*, %VAO** %arg_p_10
%arg_p_11 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 11
%arg_11 = load %String*, %String** %arg_p_11
%arg_p_12 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 12
%arg_12 = load i32, i32* %arg_p_12
%arg_p_13 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 13
%arg_13 = load %XTMBone*, %XTMBone** %arg_p_13
%arg_p_14 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 14
%arg_14 = load i32, i32* %arg_p_14
%arg_p_15 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 15
%arg_15 = load %Texture*, %Texture** %arg_p_15
%arg_p_16 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 16
%arg_16 = load %Texture*, %Texture** %arg_p_16
%arg_p_17 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 17
%arg_17 = load %Texture*, %Texture** %arg_p_17
%arg_p_18 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 18
%arg_18 = load %Texture*, %Texture** %arg_p_18
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_h_adhoc_W1hUTU1lc2gqLFZCTyosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0LGZsb2F0LGkzMixpNjQsVkFPKixTdHJpbmcqLGkzMixYVE1Cb25lKixpMzIsVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*,  %XTMMesh* (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float %arg_6, float %arg_7, i32 %arg_8, i64 %arg_9, %VAO* %arg_10, %String* %arg_11, i32 %arg_12, %XTMBone* %arg_13, i32 %arg_14, %Texture* %arg_15, %Texture* %arg_16, %Texture* %arg_17, %Texture* %arg_18)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline123 = hidden constant [202 x i8] c"XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0\00"
@gsxtmgraphics-pipeline124 = hidden constant [191 x i8] c"{i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**\00"
define dllexport fastcc %XTMMesh @XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0__3433(i8* %_impz,i8* %_impenv, %VBO* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float %arg_6, float %arg_7, i32 %arg_8, i64 %arg_9, %VAO* %arg_10, %String* %arg_11, i32 %arg_12, %XTMBone* %arg_13, i32 %arg_14, %Texture* %arg_15, %Texture* %arg_16, %Texture* %arg_17, %Texture* %arg_18) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3434 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}*
%XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0Ptr_ = getelementptr {{i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}, {{i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}* %impenv, i32 0, i32 0
%XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0Ptr = load {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***, {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**** %XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0Ptr_

; setup arguments
%arg_0Ptr = alloca %VBO*
store %VBO* %arg_0, %VBO** %arg_0Ptr
%arg_1Ptr = alloca %Texture*
store %Texture* %arg_1, %Texture** %arg_1Ptr
%arg_2Ptr = alloca float*
store float* %arg_2, float** %arg_2Ptr
%arg_3Ptr = alloca float*
store float* %arg_3, float** %arg_3Ptr
%arg_4Ptr = alloca float*
store float* %arg_4, float** %arg_4Ptr
%arg_5Ptr = alloca float*
store float* %arg_5, float** %arg_5Ptr
%arg_6Ptr = alloca float
store float %arg_6, float* %arg_6Ptr
%arg_7Ptr = alloca float
store float %arg_7, float* %arg_7Ptr
%arg_8Ptr = alloca i32
store i32 %arg_8, i32* %arg_8Ptr
%arg_9Ptr = alloca i64
store i64 %arg_9, i64* %arg_9Ptr
%arg_10Ptr = alloca %VAO*
store %VAO* %arg_10, %VAO** %arg_10Ptr
%arg_11Ptr = alloca %String*
store %String* %arg_11, %String** %arg_11Ptr
%arg_12Ptr = alloca i32
store i32 %arg_12, i32* %arg_12Ptr
%arg_13Ptr = alloca %XTMBone*
store %XTMBone* %arg_13, %XTMBone** %arg_13Ptr
%arg_14Ptr = alloca i32
store i32 %arg_14, i32* %arg_14Ptr
%arg_15Ptr = alloca %Texture*
store %Texture* %arg_15, %Texture** %arg_15Ptr
%arg_16Ptr = alloca %Texture*
store %Texture* %arg_16, %Texture** %arg_16Ptr
%arg_17Ptr = alloca %Texture*
store %Texture* %arg_17, %Texture** %arg_17Ptr
%arg_18Ptr = alloca %Texture*
store %Texture* %arg_18, %Texture** %arg_18Ptr


%tzone3436 = load i8*, i8** %_impzPtr
%zone3437 = bitcast i8* %tzone3436 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMMesh*
%dat3435 = alloca %XTMMesh, align 16

; let value assignment
%obj = select i1 true, %XTMMesh* %dat3435, %XTMMesh* %dat3435
store %XTMMesh* %obj, %XTMMesh** %objPtr

%val3438 = load %XTMMesh*, %XTMMesh** %objPtr
%val3439 = load %VBO*, %VBO** %arg_0Ptr
; set tuple
%val3440 = getelementptr %XTMMesh, %XTMMesh* %val3438, i64 0, i32 0
store %VBO* %val3439, %VBO** %val3440
%val3441 = load %XTMMesh*, %XTMMesh** %objPtr
%val3442 = load %Texture*, %Texture** %arg_1Ptr
; set tuple
%val3443 = getelementptr %XTMMesh, %XTMMesh* %val3441, i64 0, i32 1
store %Texture* %val3442, %Texture** %val3443
%val3444 = load %XTMMesh*, %XTMMesh** %objPtr
%val3445 = load float*, float** %arg_2Ptr
; set tuple
%val3446 = getelementptr %XTMMesh, %XTMMesh* %val3444, i64 0, i32 2
store float* %val3445, float** %val3446
%val3447 = load %XTMMesh*, %XTMMesh** %objPtr
%val3448 = load float*, float** %arg_3Ptr
; set tuple
%val3449 = getelementptr %XTMMesh, %XTMMesh* %val3447, i64 0, i32 3
store float* %val3448, float** %val3449
%val3450 = load %XTMMesh*, %XTMMesh** %objPtr
%val3451 = load float*, float** %arg_4Ptr
; set tuple
%val3452 = getelementptr %XTMMesh, %XTMMesh* %val3450, i64 0, i32 4
store float* %val3451, float** %val3452
%val3453 = load %XTMMesh*, %XTMMesh** %objPtr
%val3454 = load float*, float** %arg_5Ptr
; set tuple
%val3455 = getelementptr %XTMMesh, %XTMMesh* %val3453, i64 0, i32 5
store float* %val3454, float** %val3455
%val3456 = load %XTMMesh*, %XTMMesh** %objPtr
%val3457 = load float, float* %arg_6Ptr
; set tuple
%val3458 = getelementptr %XTMMesh, %XTMMesh* %val3456, i64 0, i32 6
store float %val3457, float* %val3458
%val3459 = load %XTMMesh*, %XTMMesh** %objPtr
%val3460 = load float, float* %arg_7Ptr
; set tuple
%val3461 = getelementptr %XTMMesh, %XTMMesh* %val3459, i64 0, i32 7
store float %val3460, float* %val3461
%val3462 = load %XTMMesh*, %XTMMesh** %objPtr
%val3463 = load i32, i32* %arg_8Ptr
; set tuple
%val3464 = getelementptr %XTMMesh, %XTMMesh* %val3462, i64 0, i32 8
store i32 %val3463, i32* %val3464
%val3465 = load %XTMMesh*, %XTMMesh** %objPtr
%val3466 = load i64, i64* %arg_9Ptr
; set tuple
%val3467 = getelementptr %XTMMesh, %XTMMesh* %val3465, i64 0, i32 9
store i64 %val3466, i64* %val3467
%val3468 = load %XTMMesh*, %XTMMesh** %objPtr
%val3469 = load %VAO*, %VAO** %arg_10Ptr
; set tuple
%val3470 = getelementptr %XTMMesh, %XTMMesh* %val3468, i64 0, i32 10
store %VAO* %val3469, %VAO** %val3470
%val3471 = load %XTMMesh*, %XTMMesh** %objPtr
%val3472 = load %String*, %String** %arg_11Ptr
; set tuple
%val3473 = getelementptr %XTMMesh, %XTMMesh* %val3471, i64 0, i32 11
store %String* %val3472, %String** %val3473
%val3474 = load %XTMMesh*, %XTMMesh** %objPtr
%val3475 = load i32, i32* %arg_12Ptr
; set tuple
%val3476 = getelementptr %XTMMesh, %XTMMesh* %val3474, i64 0, i32 12
store i32 %val3475, i32* %val3476
%val3477 = load %XTMMesh*, %XTMMesh** %objPtr
%val3478 = load %XTMBone*, %XTMBone** %arg_13Ptr
; set tuple
%val3479 = getelementptr %XTMMesh, %XTMMesh* %val3477, i64 0, i32 13
store %XTMBone* %val3478, %XTMBone** %val3479
%val3480 = load %XTMMesh*, %XTMMesh** %objPtr
%val3481 = load i32, i32* %arg_14Ptr
; set tuple
%val3482 = getelementptr %XTMMesh, %XTMMesh* %val3480, i64 0, i32 14
store i32 %val3481, i32* %val3482
%val3483 = load %XTMMesh*, %XTMMesh** %objPtr
%val3484 = load %Texture*, %Texture** %arg_15Ptr
; set tuple
%val3485 = getelementptr %XTMMesh, %XTMMesh* %val3483, i64 0, i32 15
store %Texture* %val3484, %Texture** %val3485
%val3486 = load %XTMMesh*, %XTMMesh** %objPtr
%val3487 = load %Texture*, %Texture** %arg_16Ptr
; set tuple
%val3488 = getelementptr %XTMMesh, %XTMMesh* %val3486, i64 0, i32 16
store %Texture* %val3487, %Texture** %val3488
%val3489 = load %XTMMesh*, %XTMMesh** %objPtr
%val3490 = load %Texture*, %Texture** %arg_17Ptr
; set tuple
%val3491 = getelementptr %XTMMesh, %XTMMesh* %val3489, i64 0, i32 17
store %Texture* %val3490, %Texture** %val3491
%val3492 = load %XTMMesh*, %XTMMesh** %objPtr
%val3493 = load %Texture*, %Texture** %arg_18Ptr
; set tuple
%val3494 = getelementptr %XTMMesh, %XTMMesh* %val3492, i64 0, i32 18
store %Texture* %val3493, %Texture** %val3494
%val3495 = load %XTMMesh*, %XTMMesh** %objPtr
; pointer ref
%val3496 = getelementptr %XTMMesh, %XTMMesh* %val3495, i64 0
%val3497 = load %XTMMesh, %XTMMesh* %val3496
ret %XTMMesh %val3497
}
@gsxtmgraphics-pipeline125 = hidden constant [255 x i8] c"XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** @XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3517 = load i8*, i8** %_impzPtr
%zone3518 = bitcast i8* %tzone3517 to %mzone*

; let assign value to symbol XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0
%dat_XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3518, i64 8)
%XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0Ptr = bitcast i8* %dat_XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0 to { i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***
%tzone3498 = load i8*, i8** %_impzPtr
%zone3499 = bitcast i8* %tzone3498 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3499)
; malloc closure structure
%clsptr3500 = call i8* @llvm_zone_malloc(%mzone* %zone3499, i64 24)
%closure3501 = bitcast i8* %clsptr3500 to { i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*

; malloc environment structure
%envptr3502 = call i8* @llvm_zone_malloc(%mzone* %zone3499, i64 8)
%environment3503 = bitcast i8* %envptr3502 to {{i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}*

; malloc closure address table
%addytable3504 = call %clsvar* @new_address_table()
%var3505 = bitcast [202 x i8]* @gsxtmgraphics-pipeline123 to i8*
%var3506 = bitcast [191 x i8]* @gsxtmgraphics-pipeline124 to i8*
%addytable3507 = call %clsvar* @add_address_table(%mzone* %zone3499, i8* %var3505, i32 0, i8* %var3506, i32 3, %clsvar* %addytable3504)
%address-table3508 = bitcast %clsvar* %addytable3507 to i8*

; insert table, function and environment into closure struct
%closure.table3511 = getelementptr { i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, { i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure3501, i32 0, i32 0
store i8* %address-table3508, i8** %closure.table3511
%closure.env3512 = getelementptr { i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, { i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure3501, i32 0, i32 1
store i8* %envptr3502, i8** %closure.env3512
%closure.func3513 = getelementptr { i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, { i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure3501, i32 0, i32 2
store %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)* @XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0__3433, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)** %closure.func3513
%closure_size3514 = call i64 @llvm_zone_mark_size(%mzone* %zone3499)
call void @llvm_zone_ptr_set_size(i8* %clsptr3500, i64 %closure_size3514)
%wrapper_ptr3515 = call i8* @llvm_zone_malloc(%mzone* %zone3499, i64 8)
%closure_wrapper3516 = bitcast i8* %wrapper_ptr3515 to { i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**
store { i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure3501, { i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_wrapper3516

; let value assignment
%XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0 = select i1 true, { i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_wrapper3516, { i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_wrapper3516
store { i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0, { i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*** %XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0Ptr

; add data to environment
; don't need to alloc for env var XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0
%tmp_envptr3510 = getelementptr {{i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}, {{i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}***}* %environment3503, i32 0, i32 0
store {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*** %XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0Ptr, {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**** %tmp_envptr3510


%val3519 = load {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**, {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*** %XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0Ptr
ret {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %val3519
}


@XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0_var = dllexport global [1 x i8*] [ i8* null ]

@XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** @XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMMesh @XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0(%VBO* %arg_0,%Texture* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float* %arg_5,float %arg_6,float %arg_7,i32 %arg_8,i64 %arg_9,%VAO* %arg_10,%String* %arg_11,i32 %arg_12,%XTMBone* %arg_13,i32 %arg_14,%Texture* %arg_15,%Texture* %arg_16,%Texture* %arg_17,%Texture* %arg_18) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**
%closure = load {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*, {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*,  %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float %arg_6, float %arg_7, i32 %arg_8, i64 %arg_9, %VAO* %arg_10, %String* %arg_11, i32 %arg_12, %XTMBone* %arg_13, i32 %arg_14, %Texture* %arg_15, %Texture* %arg_16, %Texture* %arg_17, %Texture* %arg_18)
ret %XTMMesh %result
}


define dllexport ccc %XTMMesh @XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0_native(%VBO* %arg_0,%Texture* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float* %arg_5,float %arg_6,float %arg_7,i32 %arg_8,i64 %arg_9,%VAO* %arg_10,%String* %arg_11,i32 %arg_12,%XTMBone* %arg_13,i32 %arg_14,%Texture* %arg_15,%Texture* %arg_16,%Texture* %arg_17,%Texture* %arg_18) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**
%closure = load {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*, {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*,  %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float %arg_6, float %arg_7, i32 %arg_8, i64 %arg_9, %VAO* %arg_10, %String* %arg_11, i32 %arg_12, %XTMBone* %arg_13, i32 %arg_14, %Texture* %arg_15, %Texture* %arg_16, %Texture* %arg_17, %Texture* %arg_18)
ret %XTMMesh %result
}


define dllexport ccc void @XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}*
%arg_p_0 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
%arg_p_1 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 1
%arg_1 = load %Texture*, %Texture** %arg_p_1
%arg_p_2 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 5
%arg_5 = load float*, float** %arg_p_5
%arg_p_6 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 6
%arg_6 = load float, float* %arg_p_6
%arg_p_7 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 7
%arg_7 = load float, float* %arg_p_7
%arg_p_8 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 8
%arg_8 = load i32, i32* %arg_p_8
%arg_p_9 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 9
%arg_9 = load i64, i64* %arg_p_9
%arg_p_10 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 10
%arg_10 = load %VAO*, %VAO** %arg_p_10
%arg_p_11 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 11
%arg_11 = load %String*, %String** %arg_p_11
%arg_p_12 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 12
%arg_12 = load i32, i32* %arg_p_12
%arg_p_13 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 13
%arg_13 = load %XTMBone*, %XTMBone** %arg_p_13
%arg_p_14 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 14
%arg_14 = load i32, i32* %arg_p_14
%arg_p_15 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 15
%arg_15 = load %Texture*, %Texture** %arg_p_15
%arg_p_16 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 16
%arg_16 = load %Texture*, %Texture** %arg_p_16
%arg_p_17 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 17
%arg_17 = load %Texture*, %Texture** %arg_p_17
%arg_p_18 = getelementptr {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}, {%VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*}* %fstruct, i32 0, i32 18
%arg_18 = load %Texture*, %Texture** %arg_p_18
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMMesh_val_adhoc_W1hUTU1lc2gsVkJPKixUZXh0dXJlKixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQsZmxvYXQsaTMyLGk2NCxWQU8qLFN0cmluZyosaTMyLFhUTUJvbmUqLGkzMixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}**
%closure = load {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}*, {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}, {i8*, i8*, %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)*,  %XTMMesh (i8*, i8*, %VBO*, %Texture*, float*, float*, float*, float*, float, float, i32, i64, %VAO*, %String*, i32, %XTMBone*, i32, %Texture*, %Texture*, %Texture*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float %arg_6, float %arg_7, i32 %arg_8, i64 %arg_9, %VAO* %arg_10, %String* %arg_11, i32 %arg_12, %XTMBone* %arg_13, i32 %arg_14, %Texture* %arg_15, %Texture* %arg_16, %Texture* %arg_17, %Texture* %arg_18)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline126 = hidden constant [39 x i8] c"hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ\00"
@gsxtmgraphics-pipeline127 = hidden constant [47 x i8] c"{i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}**\00"
define dllexport fastcc %XTMMesh* @hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ__3539(i8* %_impz,i8* %_impenv, %XTMMesh* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3540 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}***}*
%hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQPtr_ = getelementptr {{i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}***}, {{i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQPtr = load {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}***, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}**** %hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQPtr_

; setup arguments
%xPtr = alloca %XTMMesh*
store %XTMMesh* %x, %XTMMesh** %xPtr


%tzone3543 = load i8*, i8** %_impzPtr
%zone3544 = bitcast i8* %tzone3543 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMMesh*
%dat3541 = call i8* @malloc(i64 144)
call i8* @memset(i8* %dat3541, i32 0, i64 144)
%val3542 = bitcast i8* %dat3541 to %XTMMesh*

; let value assignment
%obj = select i1 true, %XTMMesh* %val3542, %XTMMesh* %val3542
store %XTMMesh* %obj, %XTMMesh** %objPtr

; promote local stack var allocations
%tzone3740 = load i8*, i8** %_impzPtr
%zone3741 = bitcast i8* %tzone3740 to %mzone*
%ifptr3723 = alloca %Texture*
%ifptr3724 = alloca i1
%ifptr3707 = alloca %Texture*
%ifptr3708 = alloca i1
%ifptr3691 = alloca %Texture*
%ifptr3692 = alloca i1
%ifptr3675 = alloca %Texture*
%ifptr3676 = alloca i1
%ifptr3654 = alloca %XTMBone*
%ifptr3655 = alloca i1
%ifptr3633 = alloca %String*
%ifptr3634 = alloca i1
%ifptr3617 = alloca %VAO*
%ifptr3618 = alloca i1
%ifptr3561 = alloca %Texture*
%ifptr3562 = alloca i1
%ifptr3545 = alloca %VBO*
%ifptr3546 = alloca i1
%val3547 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3548 = getelementptr %XTMMesh, %XTMMesh* %val3547, i64 0, i32 0
%val3549 = load %VBO*, %VBO** %val3548
%val3550 = icmp eq %VBO* %val3549, null
br i1 %val3550, label %then3546, label %else3546

then3546:
%res3551 = call ccc i1 @impc_false()
store i1 %res3551, i1* %ifptr3546
br label %ifcont3546

else3546:
%res3552 = call ccc i1 @impc_true()
store i1 %res3552, i1* %ifptr3546
br label %ifcont3546

ifcont3546:
%ifres3553 = load i1, i1* %ifptr3546

br i1 %ifres3553, label %then3545, label %else3545

then3545:
%val3554 = load %XTMMesh*, %XTMMesh** %objPtr
%val3555 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3556 = getelementptr %XTMMesh, %XTMMesh* %val3555, i64 0, i32 0
%val3557 = load %VBO*, %VBO** %val3556
%res3558 = call fastcc %VBO* @hcopy_adhoc_W1ZCTyosVkJPKl0(%VBO* %val3557)
; set tuple
%val3559 = getelementptr %XTMMesh, %XTMMesh* %val3554, i64 0, i32 0
store %VBO* %res3558, %VBO** %val3559
store %VBO* %res3558, %VBO** %ifptr3545
br label %ifcont3545

else3545:
br label %ifcont3545

ifcont3545:
%ifres3560 = load %VBO*, %VBO** %ifptr3545

%val3563 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3564 = getelementptr %XTMMesh, %XTMMesh* %val3563, i64 0, i32 1
%val3565 = load %Texture*, %Texture** %val3564
%val3566 = icmp eq %Texture* %val3565, null
br i1 %val3566, label %then3562, label %else3562

then3562:
%res3567 = call ccc i1 @impc_false()
store i1 %res3567, i1* %ifptr3562
br label %ifcont3562

else3562:
%res3568 = call ccc i1 @impc_true()
store i1 %res3568, i1* %ifptr3562
br label %ifcont3562

ifcont3562:
%ifres3569 = load i1, i1* %ifptr3562

br i1 %ifres3569, label %then3561, label %else3561

then3561:
%val3570 = load %XTMMesh*, %XTMMesh** %objPtr
%val3571 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3572 = getelementptr %XTMMesh, %XTMMesh* %val3571, i64 0, i32 1
%val3573 = load %Texture*, %Texture** %val3572
%res3574 = call fastcc %Texture* @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ(%Texture* %val3573)
; set tuple
%val3575 = getelementptr %XTMMesh, %XTMMesh* %val3570, i64 0, i32 1
store %Texture* %res3574, %Texture** %val3575
store %Texture* %res3574, %Texture** %ifptr3561
br label %ifcont3561

else3561:
br label %ifcont3561

ifcont3561:
%ifres3576 = load %Texture*, %Texture** %ifptr3561

%val3577 = load %XTMMesh*, %XTMMesh** %objPtr
%val3578 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3579 = getelementptr %XTMMesh, %XTMMesh* %val3578, i64 0, i32 2
%val3580 = load float*, float** %val3579
; set tuple
%val3581 = getelementptr %XTMMesh, %XTMMesh* %val3577, i64 0, i32 2
store float* %val3580, float** %val3581
%val3582 = load %XTMMesh*, %XTMMesh** %objPtr
%val3583 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3584 = getelementptr %XTMMesh, %XTMMesh* %val3583, i64 0, i32 3
%val3585 = load float*, float** %val3584
; set tuple
%val3586 = getelementptr %XTMMesh, %XTMMesh* %val3582, i64 0, i32 3
store float* %val3585, float** %val3586
%val3587 = load %XTMMesh*, %XTMMesh** %objPtr
%val3588 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3589 = getelementptr %XTMMesh, %XTMMesh* %val3588, i64 0, i32 4
%val3590 = load float*, float** %val3589
; set tuple
%val3591 = getelementptr %XTMMesh, %XTMMesh* %val3587, i64 0, i32 4
store float* %val3590, float** %val3591
%val3592 = load %XTMMesh*, %XTMMesh** %objPtr
%val3593 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3594 = getelementptr %XTMMesh, %XTMMesh* %val3593, i64 0, i32 5
%val3595 = load float*, float** %val3594
; set tuple
%val3596 = getelementptr %XTMMesh, %XTMMesh* %val3592, i64 0, i32 5
store float* %val3595, float** %val3596
%val3597 = load %XTMMesh*, %XTMMesh** %objPtr
%val3598 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3599 = getelementptr %XTMMesh, %XTMMesh* %val3598, i64 0, i32 6
%val3600 = load float, float* %val3599
; set tuple
%val3601 = getelementptr %XTMMesh, %XTMMesh* %val3597, i64 0, i32 6
store float %val3600, float* %val3601
%val3602 = load %XTMMesh*, %XTMMesh** %objPtr
%val3603 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3604 = getelementptr %XTMMesh, %XTMMesh* %val3603, i64 0, i32 7
%val3605 = load float, float* %val3604
; set tuple
%val3606 = getelementptr %XTMMesh, %XTMMesh* %val3602, i64 0, i32 7
store float %val3605, float* %val3606
%val3607 = load %XTMMesh*, %XTMMesh** %objPtr
%val3608 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3609 = getelementptr %XTMMesh, %XTMMesh* %val3608, i64 0, i32 8
%val3610 = load i32, i32* %val3609
; set tuple
%val3611 = getelementptr %XTMMesh, %XTMMesh* %val3607, i64 0, i32 8
store i32 %val3610, i32* %val3611
%val3612 = load %XTMMesh*, %XTMMesh** %objPtr
%val3613 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3614 = getelementptr %XTMMesh, %XTMMesh* %val3613, i64 0, i32 9
%val3615 = load i64, i64* %val3614
; set tuple
%val3616 = getelementptr %XTMMesh, %XTMMesh* %val3612, i64 0, i32 9
store i64 %val3615, i64* %val3616
%val3619 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3620 = getelementptr %XTMMesh, %XTMMesh* %val3619, i64 0, i32 10
%val3621 = load %VAO*, %VAO** %val3620
%val3622 = icmp eq %VAO* %val3621, null
br i1 %val3622, label %then3618, label %else3618

then3618:
%res3623 = call ccc i1 @impc_false()
store i1 %res3623, i1* %ifptr3618
br label %ifcont3618

else3618:
%res3624 = call ccc i1 @impc_true()
store i1 %res3624, i1* %ifptr3618
br label %ifcont3618

ifcont3618:
%ifres3625 = load i1, i1* %ifptr3618

br i1 %ifres3625, label %then3617, label %else3617

then3617:
%val3626 = load %XTMMesh*, %XTMMesh** %objPtr
%val3627 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3628 = getelementptr %XTMMesh, %XTMMesh* %val3627, i64 0, i32 10
%val3629 = load %VAO*, %VAO** %val3628
%res3630 = call fastcc %VAO* @hcopy_adhoc_W1ZBTyosVkFPKl0(%VAO* %val3629)
; set tuple
%val3631 = getelementptr %XTMMesh, %XTMMesh* %val3626, i64 0, i32 10
store %VAO* %res3630, %VAO** %val3631
store %VAO* %res3630, %VAO** %ifptr3617
br label %ifcont3617

else3617:
br label %ifcont3617

ifcont3617:
%ifres3632 = load %VAO*, %VAO** %ifptr3617

%val3635 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3636 = getelementptr %XTMMesh, %XTMMesh* %val3635, i64 0, i32 11
%val3637 = load %String*, %String** %val3636
%val3638 = icmp eq %String* %val3637, null
br i1 %val3638, label %then3634, label %else3634

then3634:
%res3639 = call ccc i1 @impc_false()
store i1 %res3639, i1* %ifptr3634
br label %ifcont3634

else3634:
%res3640 = call ccc i1 @impc_true()
store i1 %res3640, i1* %ifptr3634
br label %ifcont3634

ifcont3634:
%ifres3641 = load i1, i1* %ifptr3634

br i1 %ifres3641, label %then3633, label %else3633

then3633:
%val3642 = load %XTMMesh*, %XTMMesh** %objPtr
%val3643 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3644 = getelementptr %XTMMesh, %XTMMesh* %val3643, i64 0, i32 11
%val3645 = load %String*, %String** %val3644
%res3646 = call fastcc %String* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0(%String* %val3645)
; set tuple
%val3647 = getelementptr %XTMMesh, %XTMMesh* %val3642, i64 0, i32 11
store %String* %res3646, %String** %val3647
store %String* %res3646, %String** %ifptr3633
br label %ifcont3633

else3633:
br label %ifcont3633

ifcont3633:
%ifres3648 = load %String*, %String** %ifptr3633

%val3649 = load %XTMMesh*, %XTMMesh** %objPtr
%val3650 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3651 = getelementptr %XTMMesh, %XTMMesh* %val3650, i64 0, i32 12
%val3652 = load i32, i32* %val3651
; set tuple
%val3653 = getelementptr %XTMMesh, %XTMMesh* %val3649, i64 0, i32 12
store i32 %val3652, i32* %val3653
%val3656 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3657 = getelementptr %XTMMesh, %XTMMesh* %val3656, i64 0, i32 13
%val3658 = load %XTMBone*, %XTMBone** %val3657
%val3659 = icmp eq %XTMBone* %val3658, null
br i1 %val3659, label %then3655, label %else3655

then3655:
%res3660 = call ccc i1 @impc_false()
store i1 %res3660, i1* %ifptr3655
br label %ifcont3655

else3655:
%res3661 = call ccc i1 @impc_true()
store i1 %res3661, i1* %ifptr3655
br label %ifcont3655

ifcont3655:
%ifres3662 = load i1, i1* %ifptr3655

br i1 %ifres3662, label %then3654, label %else3654

then3654:
%val3663 = load %XTMMesh*, %XTMMesh** %objPtr
%val3664 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3665 = getelementptr %XTMMesh, %XTMMesh* %val3664, i64 0, i32 13
%val3666 = load %XTMBone*, %XTMBone** %val3665
%res3667 = call fastcc %XTMBone* @hcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqXQ(%XTMBone* %val3666)
; set tuple
%val3668 = getelementptr %XTMMesh, %XTMMesh* %val3663, i64 0, i32 13
store %XTMBone* %res3667, %XTMBone** %val3668
store %XTMBone* %res3667, %XTMBone** %ifptr3654
br label %ifcont3654

else3654:
br label %ifcont3654

ifcont3654:
%ifres3669 = load %XTMBone*, %XTMBone** %ifptr3654

%val3670 = load %XTMMesh*, %XTMMesh** %objPtr
%val3671 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3672 = getelementptr %XTMMesh, %XTMMesh* %val3671, i64 0, i32 14
%val3673 = load i32, i32* %val3672
; set tuple
%val3674 = getelementptr %XTMMesh, %XTMMesh* %val3670, i64 0, i32 14
store i32 %val3673, i32* %val3674
%val3677 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3678 = getelementptr %XTMMesh, %XTMMesh* %val3677, i64 0, i32 15
%val3679 = load %Texture*, %Texture** %val3678
%val3680 = icmp eq %Texture* %val3679, null
br i1 %val3680, label %then3676, label %else3676

then3676:
%res3681 = call ccc i1 @impc_false()
store i1 %res3681, i1* %ifptr3676
br label %ifcont3676

else3676:
%res3682 = call ccc i1 @impc_true()
store i1 %res3682, i1* %ifptr3676
br label %ifcont3676

ifcont3676:
%ifres3683 = load i1, i1* %ifptr3676

br i1 %ifres3683, label %then3675, label %else3675

then3675:
%val3684 = load %XTMMesh*, %XTMMesh** %objPtr
%val3685 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3686 = getelementptr %XTMMesh, %XTMMesh* %val3685, i64 0, i32 15
%val3687 = load %Texture*, %Texture** %val3686
%res3688 = call fastcc %Texture* @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ(%Texture* %val3687)
; set tuple
%val3689 = getelementptr %XTMMesh, %XTMMesh* %val3684, i64 0, i32 15
store %Texture* %res3688, %Texture** %val3689
store %Texture* %res3688, %Texture** %ifptr3675
br label %ifcont3675

else3675:
br label %ifcont3675

ifcont3675:
%ifres3690 = load %Texture*, %Texture** %ifptr3675

%val3693 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3694 = getelementptr %XTMMesh, %XTMMesh* %val3693, i64 0, i32 16
%val3695 = load %Texture*, %Texture** %val3694
%val3696 = icmp eq %Texture* %val3695, null
br i1 %val3696, label %then3692, label %else3692

then3692:
%res3697 = call ccc i1 @impc_false()
store i1 %res3697, i1* %ifptr3692
br label %ifcont3692

else3692:
%res3698 = call ccc i1 @impc_true()
store i1 %res3698, i1* %ifptr3692
br label %ifcont3692

ifcont3692:
%ifres3699 = load i1, i1* %ifptr3692

br i1 %ifres3699, label %then3691, label %else3691

then3691:
%val3700 = load %XTMMesh*, %XTMMesh** %objPtr
%val3701 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3702 = getelementptr %XTMMesh, %XTMMesh* %val3701, i64 0, i32 16
%val3703 = load %Texture*, %Texture** %val3702
%res3704 = call fastcc %Texture* @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ(%Texture* %val3703)
; set tuple
%val3705 = getelementptr %XTMMesh, %XTMMesh* %val3700, i64 0, i32 16
store %Texture* %res3704, %Texture** %val3705
store %Texture* %res3704, %Texture** %ifptr3691
br label %ifcont3691

else3691:
br label %ifcont3691

ifcont3691:
%ifres3706 = load %Texture*, %Texture** %ifptr3691

%val3709 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3710 = getelementptr %XTMMesh, %XTMMesh* %val3709, i64 0, i32 17
%val3711 = load %Texture*, %Texture** %val3710
%val3712 = icmp eq %Texture* %val3711, null
br i1 %val3712, label %then3708, label %else3708

then3708:
%res3713 = call ccc i1 @impc_false()
store i1 %res3713, i1* %ifptr3708
br label %ifcont3708

else3708:
%res3714 = call ccc i1 @impc_true()
store i1 %res3714, i1* %ifptr3708
br label %ifcont3708

ifcont3708:
%ifres3715 = load i1, i1* %ifptr3708

br i1 %ifres3715, label %then3707, label %else3707

then3707:
%val3716 = load %XTMMesh*, %XTMMesh** %objPtr
%val3717 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3718 = getelementptr %XTMMesh, %XTMMesh* %val3717, i64 0, i32 17
%val3719 = load %Texture*, %Texture** %val3718
%res3720 = call fastcc %Texture* @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ(%Texture* %val3719)
; set tuple
%val3721 = getelementptr %XTMMesh, %XTMMesh* %val3716, i64 0, i32 17
store %Texture* %res3720, %Texture** %val3721
store %Texture* %res3720, %Texture** %ifptr3707
br label %ifcont3707

else3707:
br label %ifcont3707

ifcont3707:
%ifres3722 = load %Texture*, %Texture** %ifptr3707

%val3725 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3726 = getelementptr %XTMMesh, %XTMMesh* %val3725, i64 0, i32 18
%val3727 = load %Texture*, %Texture** %val3726
%val3728 = icmp eq %Texture* %val3727, null
br i1 %val3728, label %then3724, label %else3724

then3724:
%res3729 = call ccc i1 @impc_false()
store i1 %res3729, i1* %ifptr3724
br label %ifcont3724

else3724:
%res3730 = call ccc i1 @impc_true()
store i1 %res3730, i1* %ifptr3724
br label %ifcont3724

ifcont3724:
%ifres3731 = load i1, i1* %ifptr3724

br i1 %ifres3731, label %then3723, label %else3723

then3723:
%val3732 = load %XTMMesh*, %XTMMesh** %objPtr
%val3733 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3734 = getelementptr %XTMMesh, %XTMMesh* %val3733, i64 0, i32 18
%val3735 = load %Texture*, %Texture** %val3734
%res3736 = call fastcc %Texture* @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ(%Texture* %val3735)
; set tuple
%val3737 = getelementptr %XTMMesh, %XTMMesh* %val3732, i64 0, i32 18
store %Texture* %res3736, %Texture** %val3737
store %Texture* %res3736, %Texture** %ifptr3723
br label %ifcont3723

else3723:
br label %ifcont3723

ifcont3723:
%ifres3738 = load %Texture*, %Texture** %ifptr3723

%val3739 = load %XTMMesh*, %XTMMesh** %objPtr
ret %XTMMesh* %val3739
}
@gsxtmgraphics-pipeline128 = hidden constant [92 x i8] c"hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}** @hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3761 = load i8*, i8** %_impzPtr
%zone3762 = bitcast i8* %tzone3761 to %mzone*

; let assign value to symbol hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ
%dat_hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3762, i64 8)
%hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQPtr = bitcast i8* %dat_hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ to { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}***
%tzone3742 = load i8*, i8** %_impzPtr
%zone3743 = bitcast i8* %tzone3742 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3743)
; malloc closure structure
%clsptr3744 = call i8* @llvm_zone_malloc(%mzone* %zone3743, i64 24)
%closure3745 = bitcast i8* %clsptr3744 to { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}*

; malloc environment structure
%envptr3746 = call i8* @llvm_zone_malloc(%mzone* %zone3743, i64 8)
%environment3747 = bitcast i8* %envptr3746 to {{i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}***}*

; malloc closure address table
%addytable3748 = call %clsvar* @new_address_table()
%var3749 = bitcast [39 x i8]* @gsxtmgraphics-pipeline126 to i8*
%var3750 = bitcast [47 x i8]* @gsxtmgraphics-pipeline127 to i8*
%addytable3751 = call %clsvar* @add_address_table(%mzone* %zone3743, i8* %var3749, i32 0, i8* %var3750, i32 3, %clsvar* %addytable3748)
%address-table3752 = bitcast %clsvar* %addytable3751 to i8*

; insert table, function and environment into closure struct
%closure.table3755 = getelementptr { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}, { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}* %closure3745, i32 0, i32 0
store i8* %address-table3752, i8** %closure.table3755
%closure.env3756 = getelementptr { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}, { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}* %closure3745, i32 0, i32 1
store i8* %envptr3746, i8** %closure.env3756
%closure.func3757 = getelementptr { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}, { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}* %closure3745, i32 0, i32 2
store %XTMMesh* (i8*, i8*, %XTMMesh*)* @hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ__3539, %XTMMesh* (i8*, i8*, %XTMMesh*)** %closure.func3757
%closure_size3758 = call i64 @llvm_zone_mark_size(%mzone* %zone3743)
call void @llvm_zone_ptr_set_size(i8* %clsptr3744, i64 %closure_size3758)
%wrapper_ptr3759 = call i8* @llvm_zone_malloc(%mzone* %zone3743, i64 8)
%closure_wrapper3760 = bitcast i8* %wrapper_ptr3759 to { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}**
store { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}* %closure3745, { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}** %closure_wrapper3760

; let value assignment
%hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ = select i1 true, { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}** %closure_wrapper3760, { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}** %closure_wrapper3760
store { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}** %hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ, { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}*** %hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ
%tmp_envptr3754 = getelementptr {{i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}***}, {{i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}***}* %environment3747, i32 0, i32 0
store {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}*** %hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQPtr, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}**** %tmp_envptr3754


%val3763 = load {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}**, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}*** %hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQPtr
ret {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}** %val3763
}


@hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}** @hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMMesh* @hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ(%XTMMesh* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %XTMMesh*)*,  %XTMMesh* (i8*, i8*, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0)
ret %XTMMesh* %result
}


define dllexport ccc %XTMMesh* @hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ_native(%XTMMesh* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %XTMMesh*)*,  %XTMMesh* (i8*, i8*, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0)
ret %XTMMesh* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3764 = bitcast [92 x i8]* @gsxtmgraphics-pipeline128 to i8*
call i32 (i8*, ...) @printf(i8* %var3764)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMMesh*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %XTMMesh*)*,  %XTMMesh* (i8*, i8*, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0)
%tmpres = bitcast %XTMMesh* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMMesh*}*
%arg_p_0 = getelementptr {%XTMMesh*}, {%XTMMesh*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMMesh*, %XTMMesh** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %XTMMesh*)*,  %XTMMesh* (i8*, i8*, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline129 = hidden constant [33 x i8] c"hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd\00"
@gsxtmgraphics-pipeline130 = hidden constant [42 x i8] c"{i8*, i8*, void (i8*, i8*, %XTMMesh*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd__3765(i8* %_impz,i8* %_impenv, %XTMMesh* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3766 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %XTMMesh*)*}***}*
%hfree_adhoc_W3ZvaWQsWFRNTWVzaCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsWFRNTWVzaCpdPtr = load {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}***, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}**** %hfree_adhoc_W3ZvaWQsWFRNTWVzaCpdPtr_

; setup arguments
%xPtr = alloca %XTMMesh*
store %XTMMesh* %x, %XTMMesh** %xPtr

; promote local stack var allocations
%tzone3888 = load i8*, i8** %_impzPtr
%zone3889 = bitcast i8* %tzone3888 to %mzone*
%ifptr3872 = alloca i1
%ifptr3859 = alloca i1
%ifptr3846 = alloca i1
%ifptr3833 = alloca i1
%ifptr3820 = alloca i1
%ifptr3807 = alloca i1
%ifptr3794 = alloca i1
%ifptr3781 = alloca i1
%ifptr3768 = alloca i1

%val3769 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3770 = getelementptr %XTMMesh, %XTMMesh* %val3769, i64 0, i32 0
%val3771 = load %VBO*, %VBO** %val3770
%val3772 = icmp eq %VBO* %val3771, null
br i1 %val3772, label %then3768, label %else3768

then3768:
%res3773 = call ccc i1 @impc_false()
store i1 %res3773, i1* %ifptr3768
br label %ifcont3768

else3768:
%res3774 = call ccc i1 @impc_true()
store i1 %res3774, i1* %ifptr3768
br label %ifcont3768

ifcont3768:
%ifres3775 = load i1, i1* %ifptr3768

br i1 %ifres3775, label %then3767, label %else3767

then3767:
%val3776 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3777 = getelementptr %XTMMesh, %XTMMesh* %val3776, i64 0, i32 0
%val3778 = load %VBO*, %VBO** %val3777
call fastcc void @hfree_adhoc_W3ZvaWQsVkJPKl0(%VBO* %val3778)
br label %ifcont3767

else3767:
br label %ifcont3767

ifcont3767:
%val3782 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3783 = getelementptr %XTMMesh, %XTMMesh* %val3782, i64 0, i32 1
%val3784 = load %Texture*, %Texture** %val3783
%val3785 = icmp eq %Texture* %val3784, null
br i1 %val3785, label %then3781, label %else3781

then3781:
%res3786 = call ccc i1 @impc_false()
store i1 %res3786, i1* %ifptr3781
br label %ifcont3781

else3781:
%res3787 = call ccc i1 @impc_true()
store i1 %res3787, i1* %ifptr3781
br label %ifcont3781

ifcont3781:
%ifres3788 = load i1, i1* %ifptr3781

br i1 %ifres3788, label %then3780, label %else3780

then3780:
%val3789 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3790 = getelementptr %XTMMesh, %XTMMesh* %val3789, i64 0, i32 1
%val3791 = load %Texture*, %Texture** %val3790
call fastcc void @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val3791)
br label %ifcont3780

else3780:
br label %ifcont3780

ifcont3780:
%val3795 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3796 = getelementptr %XTMMesh, %XTMMesh* %val3795, i64 0, i32 10
%val3797 = load %VAO*, %VAO** %val3796
%val3798 = icmp eq %VAO* %val3797, null
br i1 %val3798, label %then3794, label %else3794

then3794:
%res3799 = call ccc i1 @impc_false()
store i1 %res3799, i1* %ifptr3794
br label %ifcont3794

else3794:
%res3800 = call ccc i1 @impc_true()
store i1 %res3800, i1* %ifptr3794
br label %ifcont3794

ifcont3794:
%ifres3801 = load i1, i1* %ifptr3794

br i1 %ifres3801, label %then3793, label %else3793

then3793:
%val3802 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3803 = getelementptr %XTMMesh, %XTMMesh* %val3802, i64 0, i32 10
%val3804 = load %VAO*, %VAO** %val3803
call fastcc void @hfree_adhoc_W3ZvaWQsVkFPKl0(%VAO* %val3804)
br label %ifcont3793

else3793:
br label %ifcont3793

ifcont3793:
%val3808 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3809 = getelementptr %XTMMesh, %XTMMesh* %val3808, i64 0, i32 11
%val3810 = load %String*, %String** %val3809
%val3811 = icmp eq %String* %val3810, null
br i1 %val3811, label %then3807, label %else3807

then3807:
%res3812 = call ccc i1 @impc_false()
store i1 %res3812, i1* %ifptr3807
br label %ifcont3807

else3807:
%res3813 = call ccc i1 @impc_true()
store i1 %res3813, i1* %ifptr3807
br label %ifcont3807

ifcont3807:
%ifres3814 = load i1, i1* %ifptr3807

br i1 %ifres3814, label %then3806, label %else3806

then3806:
%val3815 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3816 = getelementptr %XTMMesh, %XTMMesh* %val3815, i64 0, i32 11
%val3817 = load %String*, %String** %val3816
call fastcc void @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0(%String* %val3817)
br label %ifcont3806

else3806:
br label %ifcont3806

ifcont3806:
%val3821 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3822 = getelementptr %XTMMesh, %XTMMesh* %val3821, i64 0, i32 13
%val3823 = load %XTMBone*, %XTMBone** %val3822
%val3824 = icmp eq %XTMBone* %val3823, null
br i1 %val3824, label %then3820, label %else3820

then3820:
%res3825 = call ccc i1 @impc_false()
store i1 %res3825, i1* %ifptr3820
br label %ifcont3820

else3820:
%res3826 = call ccc i1 @impc_true()
store i1 %res3826, i1* %ifptr3820
br label %ifcont3820

ifcont3820:
%ifres3827 = load i1, i1* %ifptr3820

br i1 %ifres3827, label %then3819, label %else3819

then3819:
%val3828 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3829 = getelementptr %XTMMesh, %XTMMesh* %val3828, i64 0, i32 13
%val3830 = load %XTMBone*, %XTMBone** %val3829
call fastcc void @hfree_adhoc_W3ZvaWQsWFRNQm9uZSpd(%XTMBone* %val3830)
br label %ifcont3819

else3819:
br label %ifcont3819

ifcont3819:
%val3834 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3835 = getelementptr %XTMMesh, %XTMMesh* %val3834, i64 0, i32 15
%val3836 = load %Texture*, %Texture** %val3835
%val3837 = icmp eq %Texture* %val3836, null
br i1 %val3837, label %then3833, label %else3833

then3833:
%res3838 = call ccc i1 @impc_false()
store i1 %res3838, i1* %ifptr3833
br label %ifcont3833

else3833:
%res3839 = call ccc i1 @impc_true()
store i1 %res3839, i1* %ifptr3833
br label %ifcont3833

ifcont3833:
%ifres3840 = load i1, i1* %ifptr3833

br i1 %ifres3840, label %then3832, label %else3832

then3832:
%val3841 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3842 = getelementptr %XTMMesh, %XTMMesh* %val3841, i64 0, i32 15
%val3843 = load %Texture*, %Texture** %val3842
call fastcc void @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val3843)
br label %ifcont3832

else3832:
br label %ifcont3832

ifcont3832:
%val3847 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3848 = getelementptr %XTMMesh, %XTMMesh* %val3847, i64 0, i32 16
%val3849 = load %Texture*, %Texture** %val3848
%val3850 = icmp eq %Texture* %val3849, null
br i1 %val3850, label %then3846, label %else3846

then3846:
%res3851 = call ccc i1 @impc_false()
store i1 %res3851, i1* %ifptr3846
br label %ifcont3846

else3846:
%res3852 = call ccc i1 @impc_true()
store i1 %res3852, i1* %ifptr3846
br label %ifcont3846

ifcont3846:
%ifres3853 = load i1, i1* %ifptr3846

br i1 %ifres3853, label %then3845, label %else3845

then3845:
%val3854 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3855 = getelementptr %XTMMesh, %XTMMesh* %val3854, i64 0, i32 16
%val3856 = load %Texture*, %Texture** %val3855
call fastcc void @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val3856)
br label %ifcont3845

else3845:
br label %ifcont3845

ifcont3845:
%val3860 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3861 = getelementptr %XTMMesh, %XTMMesh* %val3860, i64 0, i32 17
%val3862 = load %Texture*, %Texture** %val3861
%val3863 = icmp eq %Texture* %val3862, null
br i1 %val3863, label %then3859, label %else3859

then3859:
%res3864 = call ccc i1 @impc_false()
store i1 %res3864, i1* %ifptr3859
br label %ifcont3859

else3859:
%res3865 = call ccc i1 @impc_true()
store i1 %res3865, i1* %ifptr3859
br label %ifcont3859

ifcont3859:
%ifres3866 = load i1, i1* %ifptr3859

br i1 %ifres3866, label %then3858, label %else3858

then3858:
%val3867 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3868 = getelementptr %XTMMesh, %XTMMesh* %val3867, i64 0, i32 17
%val3869 = load %Texture*, %Texture** %val3868
call fastcc void @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val3869)
br label %ifcont3858

else3858:
br label %ifcont3858

ifcont3858:
%val3873 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3874 = getelementptr %XTMMesh, %XTMMesh* %val3873, i64 0, i32 18
%val3875 = load %Texture*, %Texture** %val3874
%val3876 = icmp eq %Texture* %val3875, null
br i1 %val3876, label %then3872, label %else3872

then3872:
%res3877 = call ccc i1 @impc_false()
store i1 %res3877, i1* %ifptr3872
br label %ifcont3872

else3872:
%res3878 = call ccc i1 @impc_true()
store i1 %res3878, i1* %ifptr3872
br label %ifcont3872

ifcont3872:
%ifres3879 = load i1, i1* %ifptr3872

br i1 %ifres3879, label %then3871, label %else3871

then3871:
%val3880 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3881 = getelementptr %XTMMesh, %XTMMesh* %val3880, i64 0, i32 18
%val3882 = load %Texture*, %Texture** %val3881
call fastcc void @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val3882)
br label %ifcont3871

else3871:
br label %ifcont3871

ifcont3871:
%val3884 = load %XTMMesh*, %XTMMesh** %xPtr
%val3885 = bitcast %XTMMesh* %val3884 to i8*
call ccc void @free(i8* %val3885)
ret void
}
@gsxtmgraphics-pipeline131 = hidden constant [86 x i8] c"hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** @hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3909 = load i8*, i8** %_impzPtr
%zone3910 = bitcast i8* %tzone3909 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd
%dat_hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd = call i8* @llvm_zone_malloc(%mzone* %zone3910, i64 8)
%hfree_adhoc_W3ZvaWQsWFRNTWVzaCpdPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd to { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}***
%tzone3890 = load i8*, i8** %_impzPtr
%zone3891 = bitcast i8* %tzone3890 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3891)
; malloc closure structure
%clsptr3892 = call i8* @llvm_zone_malloc(%mzone* %zone3891, i64 24)
%closure3893 = bitcast i8* %clsptr3892 to { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}*

; malloc environment structure
%envptr3894 = call i8* @llvm_zone_malloc(%mzone* %zone3891, i64 8)
%environment3895 = bitcast i8* %envptr3894 to {{i8*, i8*, void (i8*, i8*, %XTMMesh*)*}***}*

; malloc closure address table
%addytable3896 = call %clsvar* @new_address_table()
%var3897 = bitcast [33 x i8]* @gsxtmgraphics-pipeline129 to i8*
%var3898 = bitcast [42 x i8]* @gsxtmgraphics-pipeline130 to i8*
%addytable3899 = call %clsvar* @add_address_table(%mzone* %zone3891, i8* %var3897, i32 0, i8* %var3898, i32 3, %clsvar* %addytable3896)
%address-table3900 = bitcast %clsvar* %addytable3899 to i8*

; insert table, function and environment into closure struct
%closure.table3903 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure3893, i32 0, i32 0
store i8* %address-table3900, i8** %closure.table3903
%closure.env3904 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure3893, i32 0, i32 1
store i8* %envptr3894, i8** %closure.env3904
%closure.func3905 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure3893, i32 0, i32 2
store void (i8*, i8*, %XTMMesh*)* @hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd__3765, void (i8*, i8*, %XTMMesh*)** %closure.func3905
%closure_size3906 = call i64 @llvm_zone_mark_size(%mzone* %zone3891)
call void @llvm_zone_ptr_set_size(i8* %clsptr3892, i64 %closure_size3906)
%wrapper_ptr3907 = call i8* @llvm_zone_malloc(%mzone* %zone3891, i64 8)
%closure_wrapper3908 = bitcast i8* %wrapper_ptr3907 to { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}**
store { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure3893, { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** %closure_wrapper3908

; let value assignment
%hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd = select i1 true, { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** %closure_wrapper3908, { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** %closure_wrapper3908
store { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** %hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd, { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}*** %hfree_adhoc_W3ZvaWQsWFRNTWVzaCpdPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd
%tmp_envptr3902 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*)*}***}* %environment3895, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}*** %hfree_adhoc_W3ZvaWQsWFRNTWVzaCpdPtr, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}**** %tmp_envptr3902


%val3911 = load {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}**, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}*** %hfree_adhoc_W3ZvaWQsWFRNTWVzaCpdPtr
ret {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** %val3911
}


@hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** @hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd(%XTMMesh* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*)*,  void (i8*, i8*, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd_native(%XTMMesh* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*)*,  void (i8*, i8*, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3912 = bitcast [86 x i8]* @gsxtmgraphics-pipeline131 to i8*
call i32 (i8*, ...) @printf(i8* %var3912)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMMesh*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*)*,  void (i8*, i8*, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMMesh*}*
%arg_p_0 = getelementptr {%XTMMesh*}, {%XTMMesh*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMMesh*, %XTMMesh** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*)*,  void (i8*, i8*, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline132 = hidden constant [57 x i8] c"zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd\00"
@gsxtmgraphics-pipeline133 = hidden constant [65 x i8] c"{i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %XTMMesh* @zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd__3913(i8* %_impz,i8* %_impenv, %XTMMesh* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3914 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpdPtr = load {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}***, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpdPtr_

; setup arguments
%xPtr = alloca %XTMMesh*
store %XTMMesh* %x, %XTMMesh** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val3916 = load %mzone*, %mzone** %fromzPtr
%val3917 = load %XTMMesh*, %XTMMesh** %xPtr
%val3918 = bitcast %XTMMesh* %val3917 to i8*
%res3919 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val3916, i8* %val3918)
br i1 %res3919, label %then3915, label %else3915

then3915:
%val3920 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val3920)
%zone_ptr3921 = bitcast %mzone* %val3920 to i8*
store i8* %zone_ptr3921, i8** %_impzPtr
%tzone3927 = load i8*, i8** %_impzPtr
%zone3928 = bitcast i8* %tzone3927 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMMesh*
%tzone3923 = load i8*, i8** %_impzPtr
%zone3924 = bitcast i8* %tzone3923 to %mzone*
%dat3925 = call i8* @llvm_zone_malloc(%mzone* %zone3924, i64 144)
call i8* @memset(i8* %dat3925, i32 0, i64 144)
%val3926 = bitcast i8* %dat3925 to %XTMMesh*

; let value assignment
%obj = select i1 true, %XTMMesh* %val3926, %XTMMesh* %val3926
store %XTMMesh* %obj, %XTMMesh** %objPtr

; promote local stack var allocations
%tzone4241 = load i8*, i8** %_impzPtr
%zone4242 = bitcast i8* %tzone4241 to %mzone*
%ifptr4219 = alloca %Texture*
%ifptr4220 = alloca i1
%ifptr4201 = alloca %Texture*
%ifptr4202 = alloca i1
%ifptr4183 = alloca %Texture*
%ifptr4184 = alloca i1
%ifptr4165 = alloca %Texture*
%ifptr4166 = alloca i1
%ifptr4142 = alloca %XTMBone*
%ifptr4143 = alloca i1
%ifptr4119 = alloca %String*
%ifptr4120 = alloca i1
%ifptr4101 = alloca %VAO*
%ifptr4102 = alloca i1
%ifptr4052 = alloca float*
%ifptr4023 = alloca float*
%ifptr3994 = alloca float*
%ifptr3965 = alloca float*
%ifptr3947 = alloca %Texture*
%ifptr3948 = alloca i1
%ifptr3929 = alloca %VBO*
%ifptr3930 = alloca i1
%val3931 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3932 = getelementptr %XTMMesh, %XTMMesh* %val3931, i64 0, i32 0
%val3933 = load %VBO*, %VBO** %val3932
%val3934 = icmp eq %VBO* %val3933, null
br i1 %val3934, label %then3930, label %else3930

then3930:
%res3935 = call ccc i1 @impc_false()
store i1 %res3935, i1* %ifptr3930
br label %ifcont3930

else3930:
%res3936 = call ccc i1 @impc_true()
store i1 %res3936, i1* %ifptr3930
br label %ifcont3930

ifcont3930:
%ifres3937 = load i1, i1* %ifptr3930

br i1 %ifres3937, label %then3929, label %else3929

then3929:
%val3938 = load %XTMMesh*, %XTMMesh** %objPtr
%val3939 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3940 = getelementptr %XTMMesh, %XTMMesh* %val3939, i64 0, i32 0
%val3941 = load %VBO*, %VBO** %val3940
%val3942 = load %mzone*, %mzone** %fromzPtr
%val3943 = load %mzone*, %mzone** %tozPtr
%res3944 = call fastcc %VBO* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ(%VBO* %val3941, %mzone* %val3942, %mzone* %val3943)
; set tuple
%val3945 = getelementptr %XTMMesh, %XTMMesh* %val3938, i64 0, i32 0
store %VBO* %res3944, %VBO** %val3945
store %VBO* %res3944, %VBO** %ifptr3929
br label %ifcont3929

else3929:
br label %ifcont3929

ifcont3929:
%ifres3946 = load %VBO*, %VBO** %ifptr3929

%val3949 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3950 = getelementptr %XTMMesh, %XTMMesh* %val3949, i64 0, i32 1
%val3951 = load %Texture*, %Texture** %val3950
%val3952 = icmp eq %Texture* %val3951, null
br i1 %val3952, label %then3948, label %else3948

then3948:
%res3953 = call ccc i1 @impc_false()
store i1 %res3953, i1* %ifptr3948
br label %ifcont3948

else3948:
%res3954 = call ccc i1 @impc_true()
store i1 %res3954, i1* %ifptr3948
br label %ifcont3948

ifcont3948:
%ifres3955 = load i1, i1* %ifptr3948

br i1 %ifres3955, label %then3947, label %else3947

then3947:
%val3956 = load %XTMMesh*, %XTMMesh** %objPtr
%val3957 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3958 = getelementptr %XTMMesh, %XTMMesh* %val3957, i64 0, i32 1
%val3959 = load %Texture*, %Texture** %val3958
%val3960 = load %mzone*, %mzone** %fromzPtr
%val3961 = load %mzone*, %mzone** %tozPtr
%res3962 = call fastcc %Texture* @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd(%Texture* %val3959, %mzone* %val3960, %mzone* %val3961)
; set tuple
%val3963 = getelementptr %XTMMesh, %XTMMesh* %val3956, i64 0, i32 1
store %Texture* %res3962, %Texture** %val3963
store %Texture* %res3962, %Texture** %ifptr3947
br label %ifcont3947

else3947:
br label %ifcont3947

ifcont3947:
%ifres3964 = load %Texture*, %Texture** %ifptr3947

%val3966 = load %mzone*, %mzone** %fromzPtr
%val3967 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3968 = getelementptr %XTMMesh, %XTMMesh* %val3967, i64 0, i32 2
%val3969 = load float*, float** %val3968
%val3970 = bitcast float* %val3969 to i8*
%res3971 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val3966, i8* %val3970)
br i1 %res3971, label %then3965, label %else3965

then3965:
%tzone3976 = load i8*, i8** %_impzPtr
%zone3977 = bitcast i8* %tzone3976 to %mzone*

; let assign value to symbol newptr
%newptrPtr = alloca float*
%tzone3972 = load i8*, i8** %_impzPtr
%zone3973 = bitcast i8* %tzone3972 to %mzone*
%dat3974 = call i8* @llvm_zone_malloc(%mzone* %zone3973, i64 4)
call i8* @memset(i8* %dat3974, i32 0, i64 4)
%val3975 = bitcast i8* %dat3974 to float*

; let value assignment
%newptr = select i1 true, float* %val3975, float* %val3975
store float* %newptr, float** %newptrPtr

%val3978 = load float*, float** %newptrPtr
%val3979 = bitcast float* %val3978 to i8*
%val3980 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3981 = getelementptr %XTMMesh, %XTMMesh* %val3980, i64 0, i32 2
%val3982 = load float*, float** %val3981
%val3983 = bitcast float* %val3982 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val3979, i8* %val3983, i64 4, i32 1, i1 0)
%val3985 = load %XTMMesh*, %XTMMesh** %objPtr
%val3986 = load float*, float** %newptrPtr
; set tuple
%val3987 = getelementptr %XTMMesh, %XTMMesh* %val3985, i64 0, i32 2
store float* %val3986, float** %val3987
store float* %val3986, float** %ifptr3965
br label %ifcont3965

else3965:
%val3988 = load %XTMMesh*, %XTMMesh** %objPtr
%val3989 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3990 = getelementptr %XTMMesh, %XTMMesh* %val3989, i64 0, i32 2
%val3991 = load float*, float** %val3990
; set tuple
%val3992 = getelementptr %XTMMesh, %XTMMesh* %val3988, i64 0, i32 2
store float* %val3991, float** %val3992
store float* %val3991, float** %ifptr3965
br label %ifcont3965

ifcont3965:
%ifres3993 = load float*, float** %ifptr3965

%val3995 = load %mzone*, %mzone** %fromzPtr
%val3996 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val3997 = getelementptr %XTMMesh, %XTMMesh* %val3996, i64 0, i32 3
%val3998 = load float*, float** %val3997
%val3999 = bitcast float* %val3998 to i8*
%res4000 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val3995, i8* %val3999)
br i1 %res4000, label %then3994, label %else3994

then3994:
%tzone4005 = load i8*, i8** %_impzPtr
%zone4006 = bitcast i8* %tzone4005 to %mzone*

; let assign value to symbol newptr_s_17
%newptr_s_17Ptr = alloca float*
%tzone4001 = load i8*, i8** %_impzPtr
%zone4002 = bitcast i8* %tzone4001 to %mzone*
%dat4003 = call i8* @llvm_zone_malloc(%mzone* %zone4002, i64 4)
call i8* @memset(i8* %dat4003, i32 0, i64 4)
%val4004 = bitcast i8* %dat4003 to float*

; let value assignment
%newptr_s_17 = select i1 true, float* %val4004, float* %val4004
store float* %newptr_s_17, float** %newptr_s_17Ptr

%val4007 = load float*, float** %newptr_s_17Ptr
%val4008 = bitcast float* %val4007 to i8*
%val4009 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4010 = getelementptr %XTMMesh, %XTMMesh* %val4009, i64 0, i32 3
%val4011 = load float*, float** %val4010
%val4012 = bitcast float* %val4011 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val4008, i8* %val4012, i64 4, i32 1, i1 0)
%val4014 = load %XTMMesh*, %XTMMesh** %objPtr
%val4015 = load float*, float** %newptr_s_17Ptr
; set tuple
%val4016 = getelementptr %XTMMesh, %XTMMesh* %val4014, i64 0, i32 3
store float* %val4015, float** %val4016
store float* %val4015, float** %ifptr3994
br label %ifcont3994

else3994:
%val4017 = load %XTMMesh*, %XTMMesh** %objPtr
%val4018 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4019 = getelementptr %XTMMesh, %XTMMesh* %val4018, i64 0, i32 3
%val4020 = load float*, float** %val4019
; set tuple
%val4021 = getelementptr %XTMMesh, %XTMMesh* %val4017, i64 0, i32 3
store float* %val4020, float** %val4021
store float* %val4020, float** %ifptr3994
br label %ifcont3994

ifcont3994:
%ifres4022 = load float*, float** %ifptr3994

%val4024 = load %mzone*, %mzone** %fromzPtr
%val4025 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4026 = getelementptr %XTMMesh, %XTMMesh* %val4025, i64 0, i32 4
%val4027 = load float*, float** %val4026
%val4028 = bitcast float* %val4027 to i8*
%res4029 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val4024, i8* %val4028)
br i1 %res4029, label %then4023, label %else4023

then4023:
%tzone4034 = load i8*, i8** %_impzPtr
%zone4035 = bitcast i8* %tzone4034 to %mzone*

; let assign value to symbol newptr_s_18
%newptr_s_18Ptr = alloca float*
%tzone4030 = load i8*, i8** %_impzPtr
%zone4031 = bitcast i8* %tzone4030 to %mzone*
%dat4032 = call i8* @llvm_zone_malloc(%mzone* %zone4031, i64 4)
call i8* @memset(i8* %dat4032, i32 0, i64 4)
%val4033 = bitcast i8* %dat4032 to float*

; let value assignment
%newptr_s_18 = select i1 true, float* %val4033, float* %val4033
store float* %newptr_s_18, float** %newptr_s_18Ptr

%val4036 = load float*, float** %newptr_s_18Ptr
%val4037 = bitcast float* %val4036 to i8*
%val4038 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4039 = getelementptr %XTMMesh, %XTMMesh* %val4038, i64 0, i32 4
%val4040 = load float*, float** %val4039
%val4041 = bitcast float* %val4040 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val4037, i8* %val4041, i64 4, i32 1, i1 0)
%val4043 = load %XTMMesh*, %XTMMesh** %objPtr
%val4044 = load float*, float** %newptr_s_18Ptr
; set tuple
%val4045 = getelementptr %XTMMesh, %XTMMesh* %val4043, i64 0, i32 4
store float* %val4044, float** %val4045
store float* %val4044, float** %ifptr4023
br label %ifcont4023

else4023:
%val4046 = load %XTMMesh*, %XTMMesh** %objPtr
%val4047 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4048 = getelementptr %XTMMesh, %XTMMesh* %val4047, i64 0, i32 4
%val4049 = load float*, float** %val4048
; set tuple
%val4050 = getelementptr %XTMMesh, %XTMMesh* %val4046, i64 0, i32 4
store float* %val4049, float** %val4050
store float* %val4049, float** %ifptr4023
br label %ifcont4023

ifcont4023:
%ifres4051 = load float*, float** %ifptr4023

%val4053 = load %mzone*, %mzone** %fromzPtr
%val4054 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4055 = getelementptr %XTMMesh, %XTMMesh* %val4054, i64 0, i32 5
%val4056 = load float*, float** %val4055
%val4057 = bitcast float* %val4056 to i8*
%res4058 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val4053, i8* %val4057)
br i1 %res4058, label %then4052, label %else4052

then4052:
%tzone4063 = load i8*, i8** %_impzPtr
%zone4064 = bitcast i8* %tzone4063 to %mzone*

; let assign value to symbol newptr_s_19
%newptr_s_19Ptr = alloca float*
%tzone4059 = load i8*, i8** %_impzPtr
%zone4060 = bitcast i8* %tzone4059 to %mzone*
%dat4061 = call i8* @llvm_zone_malloc(%mzone* %zone4060, i64 4)
call i8* @memset(i8* %dat4061, i32 0, i64 4)
%val4062 = bitcast i8* %dat4061 to float*

; let value assignment
%newptr_s_19 = select i1 true, float* %val4062, float* %val4062
store float* %newptr_s_19, float** %newptr_s_19Ptr

%val4065 = load float*, float** %newptr_s_19Ptr
%val4066 = bitcast float* %val4065 to i8*
%val4067 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4068 = getelementptr %XTMMesh, %XTMMesh* %val4067, i64 0, i32 5
%val4069 = load float*, float** %val4068
%val4070 = bitcast float* %val4069 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val4066, i8* %val4070, i64 4, i32 1, i1 0)
%val4072 = load %XTMMesh*, %XTMMesh** %objPtr
%val4073 = load float*, float** %newptr_s_19Ptr
; set tuple
%val4074 = getelementptr %XTMMesh, %XTMMesh* %val4072, i64 0, i32 5
store float* %val4073, float** %val4074
store float* %val4073, float** %ifptr4052
br label %ifcont4052

else4052:
%val4075 = load %XTMMesh*, %XTMMesh** %objPtr
%val4076 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4077 = getelementptr %XTMMesh, %XTMMesh* %val4076, i64 0, i32 5
%val4078 = load float*, float** %val4077
; set tuple
%val4079 = getelementptr %XTMMesh, %XTMMesh* %val4075, i64 0, i32 5
store float* %val4078, float** %val4079
store float* %val4078, float** %ifptr4052
br label %ifcont4052

ifcont4052:
%ifres4080 = load float*, float** %ifptr4052

%val4081 = load %XTMMesh*, %XTMMesh** %objPtr
%val4082 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4083 = getelementptr %XTMMesh, %XTMMesh* %val4082, i64 0, i32 6
%val4084 = load float, float* %val4083
; set tuple
%val4085 = getelementptr %XTMMesh, %XTMMesh* %val4081, i64 0, i32 6
store float %val4084, float* %val4085
%val4086 = load %XTMMesh*, %XTMMesh** %objPtr
%val4087 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4088 = getelementptr %XTMMesh, %XTMMesh* %val4087, i64 0, i32 7
%val4089 = load float, float* %val4088
; set tuple
%val4090 = getelementptr %XTMMesh, %XTMMesh* %val4086, i64 0, i32 7
store float %val4089, float* %val4090
%val4091 = load %XTMMesh*, %XTMMesh** %objPtr
%val4092 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4093 = getelementptr %XTMMesh, %XTMMesh* %val4092, i64 0, i32 8
%val4094 = load i32, i32* %val4093
; set tuple
%val4095 = getelementptr %XTMMesh, %XTMMesh* %val4091, i64 0, i32 8
store i32 %val4094, i32* %val4095
%val4096 = load %XTMMesh*, %XTMMesh** %objPtr
%val4097 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4098 = getelementptr %XTMMesh, %XTMMesh* %val4097, i64 0, i32 9
%val4099 = load i64, i64* %val4098
; set tuple
%val4100 = getelementptr %XTMMesh, %XTMMesh* %val4096, i64 0, i32 9
store i64 %val4099, i64* %val4100
%val4103 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4104 = getelementptr %XTMMesh, %XTMMesh* %val4103, i64 0, i32 10
%val4105 = load %VAO*, %VAO** %val4104
%val4106 = icmp eq %VAO* %val4105, null
br i1 %val4106, label %then4102, label %else4102

then4102:
%res4107 = call ccc i1 @impc_false()
store i1 %res4107, i1* %ifptr4102
br label %ifcont4102

else4102:
%res4108 = call ccc i1 @impc_true()
store i1 %res4108, i1* %ifptr4102
br label %ifcont4102

ifcont4102:
%ifres4109 = load i1, i1* %ifptr4102

br i1 %ifres4109, label %then4101, label %else4101

then4101:
%val4110 = load %XTMMesh*, %XTMMesh** %objPtr
%val4111 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4112 = getelementptr %XTMMesh, %XTMMesh* %val4111, i64 0, i32 10
%val4113 = load %VAO*, %VAO** %val4112
%val4114 = load %mzone*, %mzone** %fromzPtr
%val4115 = load %mzone*, %mzone** %tozPtr
%res4116 = call fastcc %VAO* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ(%VAO* %val4113, %mzone* %val4114, %mzone* %val4115)
; set tuple
%val4117 = getelementptr %XTMMesh, %XTMMesh* %val4110, i64 0, i32 10
store %VAO* %res4116, %VAO** %val4117
store %VAO* %res4116, %VAO** %ifptr4101
br label %ifcont4101

else4101:
br label %ifcont4101

ifcont4101:
%ifres4118 = load %VAO*, %VAO** %ifptr4101

%val4121 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4122 = getelementptr %XTMMesh, %XTMMesh* %val4121, i64 0, i32 11
%val4123 = load %String*, %String** %val4122
%val4124 = icmp eq %String* %val4123, null
br i1 %val4124, label %then4120, label %else4120

then4120:
%res4125 = call ccc i1 @impc_false()
store i1 %res4125, i1* %ifptr4120
br label %ifcont4120

else4120:
%res4126 = call ccc i1 @impc_true()
store i1 %res4126, i1* %ifptr4120
br label %ifcont4120

ifcont4120:
%ifres4127 = load i1, i1* %ifptr4120

br i1 %ifres4127, label %then4119, label %else4119

then4119:
%val4128 = load %XTMMesh*, %XTMMesh** %objPtr
%val4129 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4130 = getelementptr %XTMMesh, %XTMMesh* %val4129, i64 0, i32 11
%val4131 = load %String*, %String** %val4130
%val4132 = load %mzone*, %mzone** %fromzPtr
%val4133 = load %mzone*, %mzone** %tozPtr
%res4134 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val4131, %mzone* %val4132, %mzone* %val4133)
; set tuple
%val4135 = getelementptr %XTMMesh, %XTMMesh* %val4128, i64 0, i32 11
store %String* %res4134, %String** %val4135
store %String* %res4134, %String** %ifptr4119
br label %ifcont4119

else4119:
br label %ifcont4119

ifcont4119:
%ifres4136 = load %String*, %String** %ifptr4119

%val4137 = load %XTMMesh*, %XTMMesh** %objPtr
%val4138 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4139 = getelementptr %XTMMesh, %XTMMesh* %val4138, i64 0, i32 12
%val4140 = load i32, i32* %val4139
; set tuple
%val4141 = getelementptr %XTMMesh, %XTMMesh* %val4137, i64 0, i32 12
store i32 %val4140, i32* %val4141
%val4144 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4145 = getelementptr %XTMMesh, %XTMMesh* %val4144, i64 0, i32 13
%val4146 = load %XTMBone*, %XTMBone** %val4145
%val4147 = icmp eq %XTMBone* %val4146, null
br i1 %val4147, label %then4143, label %else4143

then4143:
%res4148 = call ccc i1 @impc_false()
store i1 %res4148, i1* %ifptr4143
br label %ifcont4143

else4143:
%res4149 = call ccc i1 @impc_true()
store i1 %res4149, i1* %ifptr4143
br label %ifcont4143

ifcont4143:
%ifres4150 = load i1, i1* %ifptr4143

br i1 %ifres4150, label %then4142, label %else4142

then4142:
%val4151 = load %XTMMesh*, %XTMMesh** %objPtr
%val4152 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4153 = getelementptr %XTMMesh, %XTMMesh* %val4152, i64 0, i32 13
%val4154 = load %XTMBone*, %XTMBone** %val4153
%val4155 = load %mzone*, %mzone** %fromzPtr
%val4156 = load %mzone*, %mzone** %tozPtr
%res4157 = call fastcc %XTMBone* @zcopy_adhoc_W1hUTUJvbmUqLFhUTUJvbmUqLG16b25lKixtem9uZSpd(%XTMBone* %val4154, %mzone* %val4155, %mzone* %val4156)
; set tuple
%val4158 = getelementptr %XTMMesh, %XTMMesh* %val4151, i64 0, i32 13
store %XTMBone* %res4157, %XTMBone** %val4158
store %XTMBone* %res4157, %XTMBone** %ifptr4142
br label %ifcont4142

else4142:
br label %ifcont4142

ifcont4142:
%ifres4159 = load %XTMBone*, %XTMBone** %ifptr4142

%val4160 = load %XTMMesh*, %XTMMesh** %objPtr
%val4161 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4162 = getelementptr %XTMMesh, %XTMMesh* %val4161, i64 0, i32 14
%val4163 = load i32, i32* %val4162
; set tuple
%val4164 = getelementptr %XTMMesh, %XTMMesh* %val4160, i64 0, i32 14
store i32 %val4163, i32* %val4164
%val4167 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4168 = getelementptr %XTMMesh, %XTMMesh* %val4167, i64 0, i32 15
%val4169 = load %Texture*, %Texture** %val4168
%val4170 = icmp eq %Texture* %val4169, null
br i1 %val4170, label %then4166, label %else4166

then4166:
%res4171 = call ccc i1 @impc_false()
store i1 %res4171, i1* %ifptr4166
br label %ifcont4166

else4166:
%res4172 = call ccc i1 @impc_true()
store i1 %res4172, i1* %ifptr4166
br label %ifcont4166

ifcont4166:
%ifres4173 = load i1, i1* %ifptr4166

br i1 %ifres4173, label %then4165, label %else4165

then4165:
%val4174 = load %XTMMesh*, %XTMMesh** %objPtr
%val4175 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4176 = getelementptr %XTMMesh, %XTMMesh* %val4175, i64 0, i32 15
%val4177 = load %Texture*, %Texture** %val4176
%val4178 = load %mzone*, %mzone** %fromzPtr
%val4179 = load %mzone*, %mzone** %tozPtr
%res4180 = call fastcc %Texture* @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd(%Texture* %val4177, %mzone* %val4178, %mzone* %val4179)
; set tuple
%val4181 = getelementptr %XTMMesh, %XTMMesh* %val4174, i64 0, i32 15
store %Texture* %res4180, %Texture** %val4181
store %Texture* %res4180, %Texture** %ifptr4165
br label %ifcont4165

else4165:
br label %ifcont4165

ifcont4165:
%ifres4182 = load %Texture*, %Texture** %ifptr4165

%val4185 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4186 = getelementptr %XTMMesh, %XTMMesh* %val4185, i64 0, i32 16
%val4187 = load %Texture*, %Texture** %val4186
%val4188 = icmp eq %Texture* %val4187, null
br i1 %val4188, label %then4184, label %else4184

then4184:
%res4189 = call ccc i1 @impc_false()
store i1 %res4189, i1* %ifptr4184
br label %ifcont4184

else4184:
%res4190 = call ccc i1 @impc_true()
store i1 %res4190, i1* %ifptr4184
br label %ifcont4184

ifcont4184:
%ifres4191 = load i1, i1* %ifptr4184

br i1 %ifres4191, label %then4183, label %else4183

then4183:
%val4192 = load %XTMMesh*, %XTMMesh** %objPtr
%val4193 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4194 = getelementptr %XTMMesh, %XTMMesh* %val4193, i64 0, i32 16
%val4195 = load %Texture*, %Texture** %val4194
%val4196 = load %mzone*, %mzone** %fromzPtr
%val4197 = load %mzone*, %mzone** %tozPtr
%res4198 = call fastcc %Texture* @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd(%Texture* %val4195, %mzone* %val4196, %mzone* %val4197)
; set tuple
%val4199 = getelementptr %XTMMesh, %XTMMesh* %val4192, i64 0, i32 16
store %Texture* %res4198, %Texture** %val4199
store %Texture* %res4198, %Texture** %ifptr4183
br label %ifcont4183

else4183:
br label %ifcont4183

ifcont4183:
%ifres4200 = load %Texture*, %Texture** %ifptr4183

%val4203 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4204 = getelementptr %XTMMesh, %XTMMesh* %val4203, i64 0, i32 17
%val4205 = load %Texture*, %Texture** %val4204
%val4206 = icmp eq %Texture* %val4205, null
br i1 %val4206, label %then4202, label %else4202

then4202:
%res4207 = call ccc i1 @impc_false()
store i1 %res4207, i1* %ifptr4202
br label %ifcont4202

else4202:
%res4208 = call ccc i1 @impc_true()
store i1 %res4208, i1* %ifptr4202
br label %ifcont4202

ifcont4202:
%ifres4209 = load i1, i1* %ifptr4202

br i1 %ifres4209, label %then4201, label %else4201

then4201:
%val4210 = load %XTMMesh*, %XTMMesh** %objPtr
%val4211 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4212 = getelementptr %XTMMesh, %XTMMesh* %val4211, i64 0, i32 17
%val4213 = load %Texture*, %Texture** %val4212
%val4214 = load %mzone*, %mzone** %fromzPtr
%val4215 = load %mzone*, %mzone** %tozPtr
%res4216 = call fastcc %Texture* @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd(%Texture* %val4213, %mzone* %val4214, %mzone* %val4215)
; set tuple
%val4217 = getelementptr %XTMMesh, %XTMMesh* %val4210, i64 0, i32 17
store %Texture* %res4216, %Texture** %val4217
store %Texture* %res4216, %Texture** %ifptr4201
br label %ifcont4201

else4201:
br label %ifcont4201

ifcont4201:
%ifres4218 = load %Texture*, %Texture** %ifptr4201

%val4221 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4222 = getelementptr %XTMMesh, %XTMMesh* %val4221, i64 0, i32 18
%val4223 = load %Texture*, %Texture** %val4222
%val4224 = icmp eq %Texture* %val4223, null
br i1 %val4224, label %then4220, label %else4220

then4220:
%res4225 = call ccc i1 @impc_false()
store i1 %res4225, i1* %ifptr4220
br label %ifcont4220

else4220:
%res4226 = call ccc i1 @impc_true()
store i1 %res4226, i1* %ifptr4220
br label %ifcont4220

ifcont4220:
%ifres4227 = load i1, i1* %ifptr4220

br i1 %ifres4227, label %then4219, label %else4219

then4219:
%val4228 = load %XTMMesh*, %XTMMesh** %objPtr
%val4229 = load %XTMMesh*, %XTMMesh** %xPtr
; tuple ref
%val4230 = getelementptr %XTMMesh, %XTMMesh* %val4229, i64 0, i32 18
%val4231 = load %Texture*, %Texture** %val4230
%val4232 = load %mzone*, %mzone** %fromzPtr
%val4233 = load %mzone*, %mzone** %tozPtr
%res4234 = call fastcc %Texture* @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd(%Texture* %val4231, %mzone* %val4232, %mzone* %val4233)
; set tuple
%val4235 = getelementptr %XTMMesh, %XTMMesh* %val4228, i64 0, i32 18
store %Texture* %res4234, %Texture** %val4235
store %Texture* %res4234, %Texture** %ifptr4219
br label %ifcont4219

else4219:
br label %ifcont4219

ifcont4219:
%ifres4236 = load %Texture*, %Texture** %ifptr4219

%oldzone4237 = call %mzone* @llvm_pop_zone_stack()
%newzone4238 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr4239 = bitcast %mzone* %newzone4238 to i8*
store i8* %zone_ptr4239, i8** %_impzPtr
%val4240 = load %XTMMesh*, %XTMMesh** %objPtr
ret %XTMMesh* %val4240

else3915:
%val4243 = load %XTMMesh*, %XTMMesh** %xPtr
ret %XTMMesh* %val4243
}
@gsxtmgraphics-pipeline134 = hidden constant [110 x i8] c"zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4263 = load i8*, i8** %_impzPtr
%zone4264 = bitcast i8* %tzone4263 to %mzone*

; let assign value to symbol zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd
%dat_zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone4264, i64 8)
%zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpdPtr = bitcast i8* %dat_zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd to { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}***
%tzone4244 = load i8*, i8** %_impzPtr
%zone4245 = bitcast i8* %tzone4244 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4245)
; malloc closure structure
%clsptr4246 = call i8* @llvm_zone_malloc(%mzone* %zone4245, i64 24)
%closure4247 = bitcast i8* %clsptr4246 to { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr4248 = call i8* @llvm_zone_malloc(%mzone* %zone4245, i64 8)
%environment4249 = bitcast i8* %envptr4248 to {{i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable4250 = call %clsvar* @new_address_table()
%var4251 = bitcast [57 x i8]* @gsxtmgraphics-pipeline132 to i8*
%var4252 = bitcast [65 x i8]* @gsxtmgraphics-pipeline133 to i8*
%addytable4253 = call %clsvar* @add_address_table(%mzone* %zone4245, i8* %var4251, i32 0, i8* %var4252, i32 3, %clsvar* %addytable4250)
%address-table4254 = bitcast %clsvar* %addytable4253 to i8*

; insert table, function and environment into closure struct
%closure.table4257 = getelementptr { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}, { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}* %closure4247, i32 0, i32 0
store i8* %address-table4254, i8** %closure.table4257
%closure.env4258 = getelementptr { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}, { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}* %closure4247, i32 0, i32 1
store i8* %envptr4248, i8** %closure.env4258
%closure.func4259 = getelementptr { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}, { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}* %closure4247, i32 0, i32 2
store %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)* @zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd__3913, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)** %closure.func4259
%closure_size4260 = call i64 @llvm_zone_mark_size(%mzone* %zone4245)
call void @llvm_zone_ptr_set_size(i8* %clsptr4246, i64 %closure_size4260)
%wrapper_ptr4261 = call i8* @llvm_zone_malloc(%mzone* %zone4245, i64 8)
%closure_wrapper4262 = bitcast i8* %wrapper_ptr4261 to { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}**
store { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}* %closure4247, { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}** %closure_wrapper4262

; let value assignment
%zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd = select i1 true, { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}** %closure_wrapper4262, { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}** %closure_wrapper4262
store { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd, { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd
%tmp_envptr4256 = getelementptr {{i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}***}* %environment4249, i32 0, i32 0
store {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpdPtr, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}**** %tmp_envptr4256


%val4265 = load {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}**, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpdPtr
ret {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}** %val4265
}


@zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMMesh* @zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd(%XTMMesh* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*,  %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %XTMMesh* %result
}


define dllexport ccc %XTMMesh* @zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd_native(%XTMMesh* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*,  %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %XTMMesh* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4266 = bitcast [110 x i8]* @gsxtmgraphics-pipeline134 to i8*
call i32 (i8*, ...) @printf(i8* %var4266)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMMesh*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4267 = bitcast [110 x i8]* @gsxtmgraphics-pipeline134 to i8*
call i32 (i8*, ...) @printf(i8* %var4267)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4268 = bitcast [110 x i8]* @gsxtmgraphics-pipeline134 to i8*
call i32 (i8*, ...) @printf(i8* %var4268)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*,  %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %XTMMesh* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMMesh*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%XTMMesh*, %mzone*, %mzone*}, {%XTMMesh*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMMesh*, %XTMMesh** %arg_p_0
%arg_p_1 = getelementptr {%XTMMesh*, %mzone*, %mzone*}, {%XTMMesh*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%XTMMesh*, %mzone*, %mzone*}, {%XTMMesh*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)*,  %XTMMesh* (i8*, i8*, %XTMMesh*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline135 = hidden constant [15 x i8] c"<XTMMesh:NULL>\00"
@gsxtmgraphics-pipeline136 = hidden constant [22 x i8] c"------ mesh ---------\00"
@gsxtmgraphics-pipeline137 = hidden constant [13 x i8] c"
 name    : \00"
@gsxtmgraphics-pipeline138 = hidden constant [13 x i8] c"
 texture : \00"
@gsxtmgraphics-pipeline139 = hidden constant [13 x i8] c"
 diffuse : \00"
@gsxtmgraphics-pipeline140 = hidden constant [12 x i8] c" ambient : \00"
@gsxtmgraphics-pipeline141 = hidden constant [12 x i8] c" speculr : \00"
@gsxtmgraphics-pipeline142 = hidden constant [12 x i8] c" emissiv : \00"
@gsxtmgraphics-pipeline143 = hidden constant [12 x i8] c" shine   : \00"
@gsxtmgraphics-pipeline144 = hidden constant [13 x i8] c"
 opacity : \00"
@gsxtmgraphics-pipeline145 = hidden constant [13 x i8] c"
 verts   : \00"
@gsxtmgraphics-pipeline146 = hidden constant [13 x i8] c"
 bones   : \00"
@gsxtmgraphics-pipeline147 = hidden constant [13 x i8] c"
 diff tex: \00"
@gsxtmgraphics-pipeline148 = hidden constant [13 x i8] c"
 spec tex: \00"
@gsxtmgraphics-pipeline149 = hidden constant [13 x i8] c"
 high tex: \00"
@gsxtmgraphics-pipeline150 = hidden constant [13 x i8] c"
 norm tex: \00"
@gsxtmgraphics-pipeline151 = hidden constant [33 x i8] c"print_adhoc_W3ZvaWQsWFRNTWVzaCpd\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsWFRNTWVzaCpd__4269(i8* %_impz,i8* %_impenv, %XTMMesh* %mesh) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4270 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %XTMMesh*)*}***}*
%print_adhoc_W3ZvaWQsWFRNTWVzaCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsWFRNTWVzaCpdPtr = load {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}***, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}**** %print_adhoc_W3ZvaWQsWFRNTWVzaCpdPtr_

; setup arguments
%meshPtr = alloca %XTMMesh*
store %XTMMesh* %mesh, %XTMMesh** %meshPtr


%val4272 = load %XTMMesh*, %XTMMesh** %meshPtr
%val4273 = icmp eq %XTMMesh* %val4272, null
br i1 %val4273, label %then4271, label %else4271

then4271:
%var4274 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var4275 = bitcast [15 x i8]* @gsxtmgraphics-pipeline135 to i8*

%val4276 = call i32 (i8*, ...) @printf(i8* %var4274, i8* %var4275)
call fastcc void @print_return_adhoc_W3ZvaWRd()
ret void

else4271:
%tzone4281 = load i8*, i8** %_impzPtr
%zone4282 = bitcast i8* %tzone4281 to %mzone*

; let assign value to symbol name_s_20
%name_s_20Ptr = alloca %String*
%tzone4286 = load i8*, i8** %_impzPtr
%zone4287 = bitcast i8* %tzone4286 to %mzone*

; let assign value to symbol texture
%texturePtr = alloca %Texture*
%tzone4291 = load i8*, i8** %_impzPtr
%zone4292 = bitcast i8* %tzone4291 to %mzone*

; let assign value to symbol diffuse
%diffusePtr = alloca float*
%tzone4296 = load i8*, i8** %_impzPtr
%zone4297 = bitcast i8* %tzone4296 to %mzone*

; let assign value to symbol ambient
%ambientPtr = alloca float*
%tzone4301 = load i8*, i8** %_impzPtr
%zone4302 = bitcast i8* %tzone4301 to %mzone*

; let assign value to symbol specular
%specularPtr = alloca float*
%tzone4306 = load i8*, i8** %_impzPtr
%zone4307 = bitcast i8* %tzone4306 to %mzone*

; let assign value to symbol emissive
%emissivePtr = alloca float*
%tzone4311 = load i8*, i8** %_impzPtr
%zone4312 = bitcast i8* %tzone4311 to %mzone*

; let assign value to symbol shininess
%shininessPtr = alloca float
%tzone4316 = load i8*, i8** %_impzPtr
%zone4317 = bitcast i8* %tzone4316 to %mzone*

; let assign value to symbol opacity
%opacityPtr = alloca float
%tzone4321 = load i8*, i8** %_impzPtr
%zone4322 = bitcast i8* %tzone4321 to %mzone*

; let assign value to symbol verts
%vertsPtr = alloca i64
%tzone4326 = load i8*, i8** %_impzPtr
%zone4327 = bitcast i8* %tzone4326 to %mzone*

; let assign value to symbol bones
%bonesPtr = alloca i32
%tzone4331 = load i8*, i8** %_impzPtr
%zone4332 = bitcast i8* %tzone4331 to %mzone*

; let assign value to symbol diffuse_tex
%diffuse_texPtr = alloca %Texture*
%tzone4336 = load i8*, i8** %_impzPtr
%zone4337 = bitcast i8* %tzone4336 to %mzone*

; let assign value to symbol specular_tex
%specular_texPtr = alloca %Texture*
%tzone4341 = load i8*, i8** %_impzPtr
%zone4342 = bitcast i8* %tzone4341 to %mzone*

; let assign value to symbol height_tex
%height_texPtr = alloca %Texture*
%tzone4346 = load i8*, i8** %_impzPtr
%zone4347 = bitcast i8* %tzone4346 to %mzone*

; let assign value to symbol normal_tex
%normal_texPtr = alloca %Texture*
%val4278 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val4279 = getelementptr %XTMMesh, %XTMMesh* %val4278, i64 0, i32 11
%val4280 = load %String*, %String** %val4279

; let value assignment
%name_s_20 = select i1 true, %String* %val4280, %String* %val4280
store %String* %name_s_20, %String** %name_s_20Ptr

%val4283 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val4284 = getelementptr %XTMMesh, %XTMMesh* %val4283, i64 0, i32 1
%val4285 = load %Texture*, %Texture** %val4284

; let value assignment
%texture = select i1 true, %Texture* %val4285, %Texture* %val4285
store %Texture* %texture, %Texture** %texturePtr

%val4288 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val4289 = getelementptr %XTMMesh, %XTMMesh* %val4288, i64 0, i32 2
%val4290 = load float*, float** %val4289

; let value assignment
%diffuse = select i1 true, float* %val4290, float* %val4290
store float* %diffuse, float** %diffusePtr

%val4293 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val4294 = getelementptr %XTMMesh, %XTMMesh* %val4293, i64 0, i32 3
%val4295 = load float*, float** %val4294

; let value assignment
%ambient = select i1 true, float* %val4295, float* %val4295
store float* %ambient, float** %ambientPtr

%val4298 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val4299 = getelementptr %XTMMesh, %XTMMesh* %val4298, i64 0, i32 4
%val4300 = load float*, float** %val4299

; let value assignment
%specular = select i1 true, float* %val4300, float* %val4300
store float* %specular, float** %specularPtr

%val4303 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val4304 = getelementptr %XTMMesh, %XTMMesh* %val4303, i64 0, i32 5
%val4305 = load float*, float** %val4304

; let value assignment
%emissive = select i1 true, float* %val4305, float* %val4305
store float* %emissive, float** %emissivePtr

%val4308 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val4309 = getelementptr %XTMMesh, %XTMMesh* %val4308, i64 0, i32 6
%val4310 = load float, float* %val4309

; let value assignment
%shininess = select i1 true, float %val4310, float %val4310
store float %shininess, float* %shininessPtr

%val4313 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val4314 = getelementptr %XTMMesh, %XTMMesh* %val4313, i64 0, i32 7
%val4315 = load float, float* %val4314

; let value assignment
%opacity = select i1 true, float %val4315, float %val4315
store float %opacity, float* %opacityPtr

%val4318 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val4319 = getelementptr %XTMMesh, %XTMMesh* %val4318, i64 0, i32 9
%val4320 = load i64, i64* %val4319

; let value assignment
%verts = select i1 true, i64 %val4320, i64 %val4320
store i64 %verts, i64* %vertsPtr

%val4323 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val4324 = getelementptr %XTMMesh, %XTMMesh* %val4323, i64 0, i32 12
%val4325 = load i32, i32* %val4324

; let value assignment
%bones = select i1 true, i32 %val4325, i32 %val4325
store i32 %bones, i32* %bonesPtr

%val4328 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val4329 = getelementptr %XTMMesh, %XTMMesh* %val4328, i64 0, i32 15
%val4330 = load %Texture*, %Texture** %val4329

; let value assignment
%diffuse_tex = select i1 true, %Texture* %val4330, %Texture* %val4330
store %Texture* %diffuse_tex, %Texture** %diffuse_texPtr

%val4333 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val4334 = getelementptr %XTMMesh, %XTMMesh* %val4333, i64 0, i32 16
%val4335 = load %Texture*, %Texture** %val4334

; let value assignment
%specular_tex = select i1 true, %Texture* %val4335, %Texture* %val4335
store %Texture* %specular_tex, %Texture** %specular_texPtr

%val4338 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val4339 = getelementptr %XTMMesh, %XTMMesh* %val4338, i64 0, i32 17
%val4340 = load %Texture*, %Texture** %val4339

; let value assignment
%height_tex = select i1 true, %Texture* %val4340, %Texture* %val4340
store %Texture* %height_tex, %Texture** %height_texPtr

%val4343 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val4344 = getelementptr %XTMMesh, %XTMMesh* %val4343, i64 0, i32 18
%val4345 = load %Texture*, %Texture** %val4344

; let value assignment
%normal_tex = select i1 true, %Texture* %val4345, %Texture* %val4345
store %Texture* %normal_tex, %Texture** %normal_texPtr

; promote local stack var allocations
%tzone4458 = load i8*, i8** %_impzPtr
%zone4459 = bitcast i8* %tzone4458 to %mzone*
%ifptr4448 = alloca i1
%ifptr4437 = alloca i1
%ifptr4426 = alloca i1
%ifptr4415 = alloca i1
%var4348 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var4349 = bitcast [22 x i8]* @gsxtmgraphics-pipeline136 to i8*

%val4350 = call i32 (i8*, ...) @printf(i8* %var4348, i8* %var4349)
%var4352 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var4353 = bitcast [13 x i8]* @gsxtmgraphics-pipeline137 to i8*

%val4354 = call i32 (i8*, ...) @printf(i8* %var4352, i8* %var4353)
%val4355 = load %String*, %String** %name_s_20Ptr
call fastcc void @print_adhoc_W3ZvaWQsU3RyaW5nKl0(%String* %val4355)
%var4358 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var4359 = bitcast [13 x i8]* @gsxtmgraphics-pipeline138 to i8*

%val4360 = call i32 (i8*, ...) @printf(i8* %var4358, i8* %var4359)
%val4361 = load %Texture*, %Texture** %texturePtr
call fastcc void @print_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val4361)
%var4364 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var4365 = bitcast [13 x i8]* @gsxtmgraphics-pipeline139 to i8*

%val4366 = call i32 (i8*, ...) @printf(i8* %var4364, i8* %var4365)
%val4368 = load float*, float** %diffusePtr
call fastcc void @mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd(float* %val4368, i64 1, i64 4)
%var4370 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var4371 = bitcast [12 x i8]* @gsxtmgraphics-pipeline140 to i8*

%val4372 = call i32 (i8*, ...) @printf(i8* %var4370, i8* %var4371)
%val4374 = load float*, float** %ambientPtr
call fastcc void @mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd(float* %val4374, i64 1, i64 4)
%var4376 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var4377 = bitcast [12 x i8]* @gsxtmgraphics-pipeline141 to i8*

%val4378 = call i32 (i8*, ...) @printf(i8* %var4376, i8* %var4377)
%val4380 = load float*, float** %specularPtr
call fastcc void @mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd(float* %val4380, i64 1, i64 4)
%var4382 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var4383 = bitcast [12 x i8]* @gsxtmgraphics-pipeline142 to i8*

%val4384 = call i32 (i8*, ...) @printf(i8* %var4382, i8* %var4383)
%val4386 = load float*, float** %emissivePtr
call fastcc void @mprint_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjRd(float* %val4386, i64 1, i64 4)
%var4388 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var4389 = bitcast [12 x i8]* @gsxtmgraphics-pipeline143 to i8*

%val4390 = call i32 (i8*, ...) @printf(i8* %var4388, i8* %var4389)
%val4391 = load float, float* %shininessPtr
call fastcc void @print_adhoc_W3ZvaWQsZmxvYXRd(float %val4391)
%var4394 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var4395 = bitcast [13 x i8]* @gsxtmgraphics-pipeline144 to i8*

%val4396 = call i32 (i8*, ...) @printf(i8* %var4394, i8* %var4395)
%val4397 = load float, float* %opacityPtr
call fastcc void @print_adhoc_W3ZvaWQsZmxvYXRd(float %val4397)
%var4400 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var4401 = bitcast [13 x i8]* @gsxtmgraphics-pipeline145 to i8*

%val4402 = call i32 (i8*, ...) @printf(i8* %var4400, i8* %var4401)
%val4403 = load i64, i64* %vertsPtr
call fastcc void @print_adhoc_W3ZvaWQsaTY0XQ(i64 %val4403)
%var4406 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var4407 = bitcast [13 x i8]* @gsxtmgraphics-pipeline146 to i8*

%val4408 = call i32 (i8*, ...) @printf(i8* %var4406, i8* %var4407)
%val4409 = load i32, i32* %bonesPtr
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val4409)
%var4412 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var4413 = bitcast [13 x i8]* @gsxtmgraphics-pipeline147 to i8*

%val4414 = call i32 (i8*, ...) @printf(i8* %var4412, i8* %var4413)
%val4416 = load %Texture*, %Texture** %diffuse_texPtr
%val4417 = icmp eq %Texture* %val4416, null
br i1 %val4417, label %then4415, label %else4415

then4415:
%res4418 = call ccc i1 @impc_false()
store i1 %res4418, i1* %ifptr4415
br label %ifcont4415

else4415:
%res4419 = call ccc i1 @impc_true()
store i1 %res4419, i1* %ifptr4415
br label %ifcont4415

ifcont4415:
%ifres4420 = load i1, i1* %ifptr4415

call fastcc void @print_adhoc_W3ZvaWQsaTFd(i1 %ifres4420)
%var4423 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var4424 = bitcast [13 x i8]* @gsxtmgraphics-pipeline148 to i8*

%val4425 = call i32 (i8*, ...) @printf(i8* %var4423, i8* %var4424)
%val4427 = load %Texture*, %Texture** %specular_texPtr
%val4428 = icmp eq %Texture* %val4427, null
br i1 %val4428, label %then4426, label %else4426

then4426:
%res4429 = call ccc i1 @impc_false()
store i1 %res4429, i1* %ifptr4426
br label %ifcont4426

else4426:
%res4430 = call ccc i1 @impc_true()
store i1 %res4430, i1* %ifptr4426
br label %ifcont4426

ifcont4426:
%ifres4431 = load i1, i1* %ifptr4426

call fastcc void @print_adhoc_W3ZvaWQsaTFd(i1 %ifres4431)
%var4434 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var4435 = bitcast [13 x i8]* @gsxtmgraphics-pipeline149 to i8*

%val4436 = call i32 (i8*, ...) @printf(i8* %var4434, i8* %var4435)
%val4438 = load %Texture*, %Texture** %height_texPtr
%val4439 = icmp eq %Texture* %val4438, null
br i1 %val4439, label %then4437, label %else4437

then4437:
%res4440 = call ccc i1 @impc_false()
store i1 %res4440, i1* %ifptr4437
br label %ifcont4437

else4437:
%res4441 = call ccc i1 @impc_true()
store i1 %res4441, i1* %ifptr4437
br label %ifcont4437

ifcont4437:
%ifres4442 = load i1, i1* %ifptr4437

call fastcc void @print_adhoc_W3ZvaWQsaTFd(i1 %ifres4442)
%var4445 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var4446 = bitcast [13 x i8]* @gsxtmgraphics-pipeline150 to i8*

%val4447 = call i32 (i8*, ...) @printf(i8* %var4445, i8* %var4446)
%val4449 = load %Texture*, %Texture** %normal_texPtr
%val4450 = icmp eq %Texture* %val4449, null
br i1 %val4450, label %then4448, label %else4448

then4448:
%res4451 = call ccc i1 @impc_false()
store i1 %res4451, i1* %ifptr4448
br label %ifcont4448

else4448:
%res4452 = call ccc i1 @impc_true()
store i1 %res4452, i1* %ifptr4448
br label %ifcont4448

ifcont4448:
%ifres4453 = load i1, i1* %ifptr4448

call fastcc void @print_adhoc_W3ZvaWQsaTFd(i1 %ifres4453)
call fastcc void @print_return_adhoc_W3ZvaWRd()
ret void
}
@gsxtmgraphics-pipeline152 = hidden constant [86 x i8] c"print_adhoc_W3ZvaWQsWFRNTWVzaCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** @print_adhoc_W3ZvaWQsWFRNTWVzaCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4479 = load i8*, i8** %_impzPtr
%zone4480 = bitcast i8* %tzone4479 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsWFRNTWVzaCpd
%dat_print_adhoc_W3ZvaWQsWFRNTWVzaCpd = call i8* @llvm_zone_malloc(%mzone* %zone4480, i64 8)
%print_adhoc_W3ZvaWQsWFRNTWVzaCpdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsWFRNTWVzaCpd to { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}***
%tzone4460 = load i8*, i8** %_impzPtr
%zone4461 = bitcast i8* %tzone4460 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4461)
; malloc closure structure
%clsptr4462 = call i8* @llvm_zone_malloc(%mzone* %zone4461, i64 24)
%closure4463 = bitcast i8* %clsptr4462 to { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}*

; malloc environment structure
%envptr4464 = call i8* @llvm_zone_malloc(%mzone* %zone4461, i64 8)
%environment4465 = bitcast i8* %envptr4464 to {{i8*, i8*, void (i8*, i8*, %XTMMesh*)*}***}*

; malloc closure address table
%addytable4466 = call %clsvar* @new_address_table()
%var4467 = bitcast [33 x i8]* @gsxtmgraphics-pipeline151 to i8*
%var4468 = bitcast [42 x i8]* @gsxtmgraphics-pipeline130 to i8*
%addytable4469 = call %clsvar* @add_address_table(%mzone* %zone4461, i8* %var4467, i32 0, i8* %var4468, i32 3, %clsvar* %addytable4466)
%address-table4470 = bitcast %clsvar* %addytable4469 to i8*

; insert table, function and environment into closure struct
%closure.table4473 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure4463, i32 0, i32 0
store i8* %address-table4470, i8** %closure.table4473
%closure.env4474 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure4463, i32 0, i32 1
store i8* %envptr4464, i8** %closure.env4474
%closure.func4475 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure4463, i32 0, i32 2
store void (i8*, i8*, %XTMMesh*)* @print_adhoc_W3ZvaWQsWFRNTWVzaCpd__4269, void (i8*, i8*, %XTMMesh*)** %closure.func4475
%closure_size4476 = call i64 @llvm_zone_mark_size(%mzone* %zone4461)
call void @llvm_zone_ptr_set_size(i8* %clsptr4462, i64 %closure_size4476)
%wrapper_ptr4477 = call i8* @llvm_zone_malloc(%mzone* %zone4461, i64 8)
%closure_wrapper4478 = bitcast i8* %wrapper_ptr4477 to { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}**
store { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure4463, { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** %closure_wrapper4478

; let value assignment
%print_adhoc_W3ZvaWQsWFRNTWVzaCpd = select i1 true, { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** %closure_wrapper4478, { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** %closure_wrapper4478
store { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** %print_adhoc_W3ZvaWQsWFRNTWVzaCpd, { i8*, i8*, void (i8*, i8*, %XTMMesh*)*}*** %print_adhoc_W3ZvaWQsWFRNTWVzaCpdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsWFRNTWVzaCpd
%tmp_envptr4472 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*)*}***}* %environment4465, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}*** %print_adhoc_W3ZvaWQsWFRNTWVzaCpdPtr, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}**** %tmp_envptr4472


%val4481 = load {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}**, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}*** %print_adhoc_W3ZvaWQsWFRNTWVzaCpdPtr
ret {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** %val4481
}


@print_adhoc_W3ZvaWQsWFRNTWVzaCpd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsWFRNTWVzaCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsWFRNTWVzaCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNTWVzaCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** @print_adhoc_W3ZvaWQsWFRNTWVzaCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNTWVzaCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsWFRNTWVzaCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNTWVzaCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsWFRNTWVzaCpd(%XTMMesh* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*)*,  void (i8*, i8*, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsWFRNTWVzaCpd_native(%XTMMesh* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*)*,  void (i8*, i8*, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsWFRNTWVzaCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4482 = bitcast [86 x i8]* @gsxtmgraphics-pipeline152 to i8*
call i32 (i8*, ...) @printf(i8* %var4482)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMMesh*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*)*,  void (i8*, i8*, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsWFRNTWVzaCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMMesh*}*
%arg_p_0 = getelementptr {%XTMMesh*}, {%XTMMesh*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMMesh*, %XTMMesh** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*)*,  void (i8*, i8*, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline153 = hidden constant [76 x i8] c"xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd\00"
@gsxtmgraphics-pipeline154 = hidden constant [70 x i8] c"{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**\00"
define dllexport fastcc void @xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd__4483(i8* %_impz,i8* %_impenv, %XTMMesh* %mesh, float %r, float %g, float %b, float %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4484 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}*
%xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**** %xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_

; setup arguments
%meshPtr = alloca %XTMMesh*
store %XTMMesh* %mesh, %XTMMesh** %meshPtr
%rPtr = alloca float
store float %r, float* %rPtr
%gPtr = alloca float
store float %g, float* %gPtr
%bPtr = alloca float
store float %b, float* %bPtr
%aPtr = alloca float
store float %a, float* %aPtr


%tzone4488 = load i8*, i8** %_impzPtr
%zone4489 = bitcast i8* %tzone4488 to %mzone*

; let assign value to symbol c
%cPtr = alloca float*
%val4485 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val4486 = getelementptr %XTMMesh, %XTMMesh* %val4485, i64 0, i32 2
%val4487 = load float*, float** %val4486

; let value assignment
%c = select i1 true, float* %val4487, float* %val4487
store float* %c, float** %cPtr

%val4490 = load float*, float** %cPtr
%val4491 = load float, float* %rPtr
; set pointer
%val4492 = getelementptr float, float* %val4490, i64 0
store float %val4491, float* %val4492
%val4493 = load float*, float** %cPtr
%val4494 = load float, float* %gPtr
; set pointer
%val4495 = getelementptr float, float* %val4493, i64 1
store float %val4494, float* %val4495
%val4496 = load float*, float** %cPtr
%val4497 = load float, float* %bPtr
; set pointer
%val4498 = getelementptr float, float* %val4496, i64 2
store float %val4497, float* %val4498
%val4499 = load float*, float** %cPtr
%val4500 = load float, float* %aPtr
; set pointer
%val4501 = getelementptr float, float* %val4499, i64 3
store float %val4500, float* %val4501
ret void
}
@gsxtmgraphics-pipeline155 = hidden constant [129 x i8] c"xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** @xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4522 = load i8*, i8** %_impzPtr
%zone4523 = bitcast i8* %tzone4522 to %mzone*

; let assign value to symbol xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd
%dat_xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone4523, i64 8)
%xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = bitcast i8* %dat_xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd to { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***
%tzone4503 = load i8*, i8** %_impzPtr
%zone4504 = bitcast i8* %tzone4503 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4504)
; malloc closure structure
%clsptr4505 = call i8* @llvm_zone_malloc(%mzone* %zone4504, i64 24)
%closure4506 = bitcast i8* %clsptr4505 to { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*

; malloc environment structure
%envptr4507 = call i8* @llvm_zone_malloc(%mzone* %zone4504, i64 8)
%environment4508 = bitcast i8* %envptr4507 to {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}*

; malloc closure address table
%addytable4509 = call %clsvar* @new_address_table()
%var4510 = bitcast [76 x i8]* @gsxtmgraphics-pipeline153 to i8*
%var4511 = bitcast [70 x i8]* @gsxtmgraphics-pipeline154 to i8*
%addytable4512 = call %clsvar* @add_address_table(%mzone* %zone4504, i8* %var4510, i32 0, i8* %var4511, i32 3, %clsvar* %addytable4509)
%address-table4513 = bitcast %clsvar* %addytable4512 to i8*

; insert table, function and environment into closure struct
%closure.table4516 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure4506, i32 0, i32 0
store i8* %address-table4513, i8** %closure.table4516
%closure.env4517 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure4506, i32 0, i32 1
store i8* %envptr4507, i8** %closure.env4517
%closure.func4518 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure4506, i32 0, i32 2
store void (i8*, i8*, %XTMMesh*, float, float, float, float)* @xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd__4483, void (i8*, i8*, %XTMMesh*, float, float, float, float)** %closure.func4518
%closure_size4519 = call i64 @llvm_zone_mark_size(%mzone* %zone4504)
call void @llvm_zone_ptr_set_size(i8* %clsptr4505, i64 %closure_size4519)
%wrapper_ptr4520 = call i8* @llvm_zone_malloc(%mzone* %zone4504, i64 8)
%closure_wrapper4521 = bitcast i8* %wrapper_ptr4520 to { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure4506, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_wrapper4521

; let value assignment
%xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd = select i1 true, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_wrapper4521, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_wrapper4521
store { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*** %xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd
%tmp_envptr4515 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}* %environment4508, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*** %xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**** %tmp_envptr4515


%val4524 = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*** %xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr
ret {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %val4524
}


@xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** @xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd(%XTMMesh* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, float, float, float, float)*,  void (i8*, i8*, %XTMMesh*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
ret void
}


define dllexport ccc void @xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_native(%XTMMesh* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, float, float, float, float)*,  void (i8*, i8*, %XTMMesh*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
ret void
}


define dllexport ccc i8*  @xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4525 = bitcast [129 x i8]* @gsxtmgraphics-pipeline155 to i8*
call i32 (i8*, ...) @printf(i8* %var4525)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMMesh*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4526 = bitcast [129 x i8]* @gsxtmgraphics-pipeline155 to i8*
call i32 (i8*, ...) @printf(i8* %var4526)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4527 = bitcast [129 x i8]* @gsxtmgraphics-pipeline155 to i8*
call i32 (i8*, ...) @printf(i8* %var4527)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var4528 = bitcast [129 x i8]* @gsxtmgraphics-pipeline155 to i8*
call i32 (i8*, ...) @printf(i8* %var4528)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var4529 = bitcast [129 x i8]* @gsxtmgraphics-pipeline155 to i8*
call i32 (i8*, ...) @printf(i8* %var4529)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, float, float, float, float)*,  void (i8*, i8*, %XTMMesh*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMMesh*, float, float, float, float}*
%arg_p_0 = getelementptr {%XTMMesh*, float, float, float, float}, {%XTMMesh*, float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMMesh*, %XTMMesh** %arg_p_0
%arg_p_1 = getelementptr {%XTMMesh*, float, float, float, float}, {%XTMMesh*, float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {%XTMMesh*, float, float, float, float}, {%XTMMesh*, float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {%XTMMesh*, float, float, float, float}, {%XTMMesh*, float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {%XTMMesh*, float, float, float, float}, {%XTMMesh*, float, float, float, float}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_diffuse_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, float, float, float, float)*,  void (i8*, i8*, %XTMMesh*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline156 = hidden constant [76 x i8] c"xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd\00"
define dllexport fastcc void @xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd__4530(i8* %_impz,i8* %_impenv, %XTMMesh* %mesh, float %r, float %g, float %b, float %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4531 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}*
%xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**** %xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_

; setup arguments
%meshPtr = alloca %XTMMesh*
store %XTMMesh* %mesh, %XTMMesh** %meshPtr
%rPtr = alloca float
store float %r, float* %rPtr
%gPtr = alloca float
store float %g, float* %gPtr
%bPtr = alloca float
store float %b, float* %bPtr
%aPtr = alloca float
store float %a, float* %aPtr


%tzone4535 = load i8*, i8** %_impzPtr
%zone4536 = bitcast i8* %tzone4535 to %mzone*

; let assign value to symbol c
%cPtr = alloca float*
%val4532 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val4533 = getelementptr %XTMMesh, %XTMMesh* %val4532, i64 0, i32 3
%val4534 = load float*, float** %val4533

; let value assignment
%c = select i1 true, float* %val4534, float* %val4534
store float* %c, float** %cPtr

%val4537 = load float*, float** %cPtr
%val4538 = load float, float* %rPtr
; set pointer
%val4539 = getelementptr float, float* %val4537, i64 0
store float %val4538, float* %val4539
%val4540 = load float*, float** %cPtr
%val4541 = load float, float* %gPtr
; set pointer
%val4542 = getelementptr float, float* %val4540, i64 1
store float %val4541, float* %val4542
%val4543 = load float*, float** %cPtr
%val4544 = load float, float* %bPtr
; set pointer
%val4545 = getelementptr float, float* %val4543, i64 2
store float %val4544, float* %val4545
%val4546 = load float*, float** %cPtr
%val4547 = load float, float* %aPtr
; set pointer
%val4548 = getelementptr float, float* %val4546, i64 3
store float %val4547, float* %val4548
ret void
}
@gsxtmgraphics-pipeline157 = hidden constant [129 x i8] c"xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** @xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4569 = load i8*, i8** %_impzPtr
%zone4570 = bitcast i8* %tzone4569 to %mzone*

; let assign value to symbol xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd
%dat_xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone4570, i64 8)
%xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = bitcast i8* %dat_xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd to { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***
%tzone4550 = load i8*, i8** %_impzPtr
%zone4551 = bitcast i8* %tzone4550 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4551)
; malloc closure structure
%clsptr4552 = call i8* @llvm_zone_malloc(%mzone* %zone4551, i64 24)
%closure4553 = bitcast i8* %clsptr4552 to { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*

; malloc environment structure
%envptr4554 = call i8* @llvm_zone_malloc(%mzone* %zone4551, i64 8)
%environment4555 = bitcast i8* %envptr4554 to {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}*

; malloc closure address table
%addytable4556 = call %clsvar* @new_address_table()
%var4557 = bitcast [76 x i8]* @gsxtmgraphics-pipeline156 to i8*
%var4558 = bitcast [70 x i8]* @gsxtmgraphics-pipeline154 to i8*
%addytable4559 = call %clsvar* @add_address_table(%mzone* %zone4551, i8* %var4557, i32 0, i8* %var4558, i32 3, %clsvar* %addytable4556)
%address-table4560 = bitcast %clsvar* %addytable4559 to i8*

; insert table, function and environment into closure struct
%closure.table4563 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure4553, i32 0, i32 0
store i8* %address-table4560, i8** %closure.table4563
%closure.env4564 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure4553, i32 0, i32 1
store i8* %envptr4554, i8** %closure.env4564
%closure.func4565 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure4553, i32 0, i32 2
store void (i8*, i8*, %XTMMesh*, float, float, float, float)* @xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd__4530, void (i8*, i8*, %XTMMesh*, float, float, float, float)** %closure.func4565
%closure_size4566 = call i64 @llvm_zone_mark_size(%mzone* %zone4551)
call void @llvm_zone_ptr_set_size(i8* %clsptr4552, i64 %closure_size4566)
%wrapper_ptr4567 = call i8* @llvm_zone_malloc(%mzone* %zone4551, i64 8)
%closure_wrapper4568 = bitcast i8* %wrapper_ptr4567 to { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure4553, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_wrapper4568

; let value assignment
%xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd = select i1 true, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_wrapper4568, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_wrapper4568
store { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*** %xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd
%tmp_envptr4562 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}* %environment4555, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*** %xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**** %tmp_envptr4562


%val4571 = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*** %xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr
ret {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %val4571
}


@xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** @xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd(%XTMMesh* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, float, float, float, float)*,  void (i8*, i8*, %XTMMesh*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
ret void
}


define dllexport ccc void @xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_native(%XTMMesh* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, float, float, float, float)*,  void (i8*, i8*, %XTMMesh*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
ret void
}


define dllexport ccc i8*  @xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4572 = bitcast [129 x i8]* @gsxtmgraphics-pipeline157 to i8*
call i32 (i8*, ...) @printf(i8* %var4572)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMMesh*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4573 = bitcast [129 x i8]* @gsxtmgraphics-pipeline157 to i8*
call i32 (i8*, ...) @printf(i8* %var4573)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4574 = bitcast [129 x i8]* @gsxtmgraphics-pipeline157 to i8*
call i32 (i8*, ...) @printf(i8* %var4574)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var4575 = bitcast [129 x i8]* @gsxtmgraphics-pipeline157 to i8*
call i32 (i8*, ...) @printf(i8* %var4575)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var4576 = bitcast [129 x i8]* @gsxtmgraphics-pipeline157 to i8*
call i32 (i8*, ...) @printf(i8* %var4576)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, float, float, float, float)*,  void (i8*, i8*, %XTMMesh*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMMesh*, float, float, float, float}*
%arg_p_0 = getelementptr {%XTMMesh*, float, float, float, float}, {%XTMMesh*, float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMMesh*, %XTMMesh** %arg_p_0
%arg_p_1 = getelementptr {%XTMMesh*, float, float, float, float}, {%XTMMesh*, float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {%XTMMesh*, float, float, float, float}, {%XTMMesh*, float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {%XTMMesh*, float, float, float, float}, {%XTMMesh*, float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {%XTMMesh*, float, float, float, float}, {%XTMMesh*, float, float, float, float}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_ambient_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, float, float, float, float)*,  void (i8*, i8*, %XTMMesh*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline158 = hidden constant [77 x i8] c"xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd\00"
define dllexport fastcc void @xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd__4577(i8* %_impz,i8* %_impenv, %XTMMesh* %mesh, float %r, float %g, float %b, float %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4578 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}*
%xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**** %xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_

; setup arguments
%meshPtr = alloca %XTMMesh*
store %XTMMesh* %mesh, %XTMMesh** %meshPtr
%rPtr = alloca float
store float %r, float* %rPtr
%gPtr = alloca float
store float %g, float* %gPtr
%bPtr = alloca float
store float %b, float* %bPtr
%aPtr = alloca float
store float %a, float* %aPtr


%tzone4582 = load i8*, i8** %_impzPtr
%zone4583 = bitcast i8* %tzone4582 to %mzone*

; let assign value to symbol c
%cPtr = alloca float*
%val4579 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val4580 = getelementptr %XTMMesh, %XTMMesh* %val4579, i64 0, i32 4
%val4581 = load float*, float** %val4580

; let value assignment
%c = select i1 true, float* %val4581, float* %val4581
store float* %c, float** %cPtr

%val4584 = load float*, float** %cPtr
%val4585 = load float, float* %rPtr
; set pointer
%val4586 = getelementptr float, float* %val4584, i64 0
store float %val4585, float* %val4586
%val4587 = load float*, float** %cPtr
%val4588 = load float, float* %gPtr
; set pointer
%val4589 = getelementptr float, float* %val4587, i64 1
store float %val4588, float* %val4589
%val4590 = load float*, float** %cPtr
%val4591 = load float, float* %bPtr
; set pointer
%val4592 = getelementptr float, float* %val4590, i64 2
store float %val4591, float* %val4592
%val4593 = load float*, float** %cPtr
%val4594 = load float, float* %aPtr
; set pointer
%val4595 = getelementptr float, float* %val4593, i64 3
store float %val4594, float* %val4595
ret void
}
@gsxtmgraphics-pipeline159 = hidden constant [130 x i8] c"xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** @xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4616 = load i8*, i8** %_impzPtr
%zone4617 = bitcast i8* %tzone4616 to %mzone*

; let assign value to symbol xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd
%dat_xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone4617, i64 8)
%xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = bitcast i8* %dat_xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd to { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***
%tzone4597 = load i8*, i8** %_impzPtr
%zone4598 = bitcast i8* %tzone4597 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4598)
; malloc closure structure
%clsptr4599 = call i8* @llvm_zone_malloc(%mzone* %zone4598, i64 24)
%closure4600 = bitcast i8* %clsptr4599 to { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*

; malloc environment structure
%envptr4601 = call i8* @llvm_zone_malloc(%mzone* %zone4598, i64 8)
%environment4602 = bitcast i8* %envptr4601 to {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}*

; malloc closure address table
%addytable4603 = call %clsvar* @new_address_table()
%var4604 = bitcast [77 x i8]* @gsxtmgraphics-pipeline158 to i8*
%var4605 = bitcast [70 x i8]* @gsxtmgraphics-pipeline154 to i8*
%addytable4606 = call %clsvar* @add_address_table(%mzone* %zone4598, i8* %var4604, i32 0, i8* %var4605, i32 3, %clsvar* %addytable4603)
%address-table4607 = bitcast %clsvar* %addytable4606 to i8*

; insert table, function and environment into closure struct
%closure.table4610 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure4600, i32 0, i32 0
store i8* %address-table4607, i8** %closure.table4610
%closure.env4611 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure4600, i32 0, i32 1
store i8* %envptr4601, i8** %closure.env4611
%closure.func4612 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure4600, i32 0, i32 2
store void (i8*, i8*, %XTMMesh*, float, float, float, float)* @xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd__4577, void (i8*, i8*, %XTMMesh*, float, float, float, float)** %closure.func4612
%closure_size4613 = call i64 @llvm_zone_mark_size(%mzone* %zone4598)
call void @llvm_zone_ptr_set_size(i8* %clsptr4599, i64 %closure_size4613)
%wrapper_ptr4614 = call i8* @llvm_zone_malloc(%mzone* %zone4598, i64 8)
%closure_wrapper4615 = bitcast i8* %wrapper_ptr4614 to { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure4600, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_wrapper4615

; let value assignment
%xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd = select i1 true, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_wrapper4615, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_wrapper4615
store { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*** %xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd
%tmp_envptr4609 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}* %environment4602, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*** %xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**** %tmp_envptr4609


%val4618 = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*** %xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr
ret {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %val4618
}


@xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** @xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd(%XTMMesh* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, float, float, float, float)*,  void (i8*, i8*, %XTMMesh*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
ret void
}


define dllexport ccc void @xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_native(%XTMMesh* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, float, float, float, float)*,  void (i8*, i8*, %XTMMesh*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
ret void
}


define dllexport ccc i8*  @xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4619 = bitcast [130 x i8]* @gsxtmgraphics-pipeline159 to i8*
call i32 (i8*, ...) @printf(i8* %var4619)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMMesh*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4620 = bitcast [130 x i8]* @gsxtmgraphics-pipeline159 to i8*
call i32 (i8*, ...) @printf(i8* %var4620)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4621 = bitcast [130 x i8]* @gsxtmgraphics-pipeline159 to i8*
call i32 (i8*, ...) @printf(i8* %var4621)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var4622 = bitcast [130 x i8]* @gsxtmgraphics-pipeline159 to i8*
call i32 (i8*, ...) @printf(i8* %var4622)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var4623 = bitcast [130 x i8]* @gsxtmgraphics-pipeline159 to i8*
call i32 (i8*, ...) @printf(i8* %var4623)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, float, float, float, float)*,  void (i8*, i8*, %XTMMesh*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMMesh*, float, float, float, float}*
%arg_p_0 = getelementptr {%XTMMesh*, float, float, float, float}, {%XTMMesh*, float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMMesh*, %XTMMesh** %arg_p_0
%arg_p_1 = getelementptr {%XTMMesh*, float, float, float, float}, {%XTMMesh*, float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {%XTMMesh*, float, float, float, float}, {%XTMMesh*, float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {%XTMMesh*, float, float, float, float}, {%XTMMesh*, float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {%XTMMesh*, float, float, float, float}, {%XTMMesh*, float, float, float, float}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_specular_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, float, float, float, float)*,  void (i8*, i8*, %XTMMesh*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline160 = hidden constant [77 x i8] c"xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd\00"
define dllexport fastcc void @xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd__4624(i8* %_impz,i8* %_impenv, %XTMMesh* %mesh, float %r, float %g, float %b, float %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4625 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}*
%xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**** %xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_

; setup arguments
%meshPtr = alloca %XTMMesh*
store %XTMMesh* %mesh, %XTMMesh** %meshPtr
%rPtr = alloca float
store float %r, float* %rPtr
%gPtr = alloca float
store float %g, float* %gPtr
%bPtr = alloca float
store float %b, float* %bPtr
%aPtr = alloca float
store float %a, float* %aPtr


%tzone4629 = load i8*, i8** %_impzPtr
%zone4630 = bitcast i8* %tzone4629 to %mzone*

; let assign value to symbol c
%cPtr = alloca float*
%val4626 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val4627 = getelementptr %XTMMesh, %XTMMesh* %val4626, i64 0, i32 5
%val4628 = load float*, float** %val4627

; let value assignment
%c = select i1 true, float* %val4628, float* %val4628
store float* %c, float** %cPtr

%val4631 = load float*, float** %cPtr
%val4632 = load float, float* %rPtr
; set pointer
%val4633 = getelementptr float, float* %val4631, i64 0
store float %val4632, float* %val4633
%val4634 = load float*, float** %cPtr
%val4635 = load float, float* %gPtr
; set pointer
%val4636 = getelementptr float, float* %val4634, i64 1
store float %val4635, float* %val4636
%val4637 = load float*, float** %cPtr
%val4638 = load float, float* %bPtr
; set pointer
%val4639 = getelementptr float, float* %val4637, i64 2
store float %val4638, float* %val4639
%val4640 = load float*, float** %cPtr
%val4641 = load float, float* %aPtr
; set pointer
%val4642 = getelementptr float, float* %val4640, i64 3
store float %val4641, float* %val4642
ret void
}
@gsxtmgraphics-pipeline161 = hidden constant [130 x i8] c"xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** @xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4663 = load i8*, i8** %_impzPtr
%zone4664 = bitcast i8* %tzone4663 to %mzone*

; let assign value to symbol xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd
%dat_xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone4664, i64 8)
%xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = bitcast i8* %dat_xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd to { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***
%tzone4644 = load i8*, i8** %_impzPtr
%zone4645 = bitcast i8* %tzone4644 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4645)
; malloc closure structure
%clsptr4646 = call i8* @llvm_zone_malloc(%mzone* %zone4645, i64 24)
%closure4647 = bitcast i8* %clsptr4646 to { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*

; malloc environment structure
%envptr4648 = call i8* @llvm_zone_malloc(%mzone* %zone4645, i64 8)
%environment4649 = bitcast i8* %envptr4648 to {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}*

; malloc closure address table
%addytable4650 = call %clsvar* @new_address_table()
%var4651 = bitcast [77 x i8]* @gsxtmgraphics-pipeline160 to i8*
%var4652 = bitcast [70 x i8]* @gsxtmgraphics-pipeline154 to i8*
%addytable4653 = call %clsvar* @add_address_table(%mzone* %zone4645, i8* %var4651, i32 0, i8* %var4652, i32 3, %clsvar* %addytable4650)
%address-table4654 = bitcast %clsvar* %addytable4653 to i8*

; insert table, function and environment into closure struct
%closure.table4657 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure4647, i32 0, i32 0
store i8* %address-table4654, i8** %closure.table4657
%closure.env4658 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure4647, i32 0, i32 1
store i8* %envptr4648, i8** %closure.env4658
%closure.func4659 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure4647, i32 0, i32 2
store void (i8*, i8*, %XTMMesh*, float, float, float, float)* @xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd__4624, void (i8*, i8*, %XTMMesh*, float, float, float, float)** %closure.func4659
%closure_size4660 = call i64 @llvm_zone_mark_size(%mzone* %zone4645)
call void @llvm_zone_ptr_set_size(i8* %clsptr4646, i64 %closure_size4660)
%wrapper_ptr4661 = call i8* @llvm_zone_malloc(%mzone* %zone4645, i64 8)
%closure_wrapper4662 = bitcast i8* %wrapper_ptr4661 to { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure4647, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_wrapper4662

; let value assignment
%xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd = select i1 true, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_wrapper4662, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_wrapper4662
store { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd, { i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*** %xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd
%tmp_envptr4656 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}***}* %environment4649, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*** %xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**** %tmp_envptr4656


%val4665 = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*** %xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr
ret {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %val4665
}


@xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** @xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd(%XTMMesh* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, float, float, float, float)*,  void (i8*, i8*, %XTMMesh*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
ret void
}


define dllexport ccc void @xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_native(%XTMMesh* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, float, float, float, float)*,  void (i8*, i8*, %XTMMesh*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
ret void
}


define dllexport ccc i8*  @xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4666 = bitcast [130 x i8]* @gsxtmgraphics-pipeline161 to i8*
call i32 (i8*, ...) @printf(i8* %var4666)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMMesh*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4667 = bitcast [130 x i8]* @gsxtmgraphics-pipeline161 to i8*
call i32 (i8*, ...) @printf(i8* %var4667)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4668 = bitcast [130 x i8]* @gsxtmgraphics-pipeline161 to i8*
call i32 (i8*, ...) @printf(i8* %var4668)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var4669 = bitcast [130 x i8]* @gsxtmgraphics-pipeline161 to i8*
call i32 (i8*, ...) @printf(i8* %var4669)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var4670 = bitcast [130 x i8]* @gsxtmgraphics-pipeline161 to i8*
call i32 (i8*, ...) @printf(i8* %var4670)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, float, float, float, float)*,  void (i8*, i8*, %XTMMesh*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMMesh*, float, float, float, float}*
%arg_p_0 = getelementptr {%XTMMesh*, float, float, float, float}, {%XTMMesh*, float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMMesh*, %XTMMesh** %arg_p_0
%arg_p_1 = getelementptr {%XTMMesh*, float, float, float, float}, {%XTMMesh*, float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {%XTMMesh*, float, float, float, float}, {%XTMMesh*, float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {%XTMMesh*, float, float, float, float}, {%XTMMesh*, float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {%XTMMesh*, float, float, float, float}, {%XTMMesh*, float, float, float, float}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_emissive_adhoc_W3ZvaWQsWFRNTWVzaCosZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, float, float, float, float)*,  void (i8*, i8*, %XTMMesh*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline162 = hidden constant [56 x i8] c"xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ\00"
@gsxtmgraphics-pipeline163 = hidden constant [50 x i8] c"{i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}**\00"
define dllexport fastcc float @xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ__4671(i8* %_impz,i8* %_impenv, %XTMMesh* %mesh, float %value) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4672 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}***}*
%xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}***}, {{i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}***}* %impenv, i32 0, i32 0
%xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQPtr = load {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}***, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}**** %xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQPtr_

; setup arguments
%meshPtr = alloca %XTMMesh*
store %XTMMesh* %mesh, %XTMMesh** %meshPtr
%valuePtr = alloca float
store float %value, float* %valuePtr


%val4673 = load %XTMMesh*, %XTMMesh** %meshPtr
%val4674 = load float, float* %valuePtr
; set tuple
%val4675 = getelementptr %XTMMesh, %XTMMesh* %val4673, i64 0, i32 6
store float %val4674, float* %val4675
ret float %val4674
}
@gsxtmgraphics-pipeline164 = hidden constant [109 x i8] c"xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** @xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4695 = load i8*, i8** %_impzPtr
%zone4696 = bitcast i8* %tzone4695 to %mzone*

; let assign value to symbol xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ
%dat_xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone4696, i64 8)
%xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQPtr = bitcast i8* %dat_xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ to { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}***
%tzone4676 = load i8*, i8** %_impzPtr
%zone4677 = bitcast i8* %tzone4676 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4677)
; malloc closure structure
%clsptr4678 = call i8* @llvm_zone_malloc(%mzone* %zone4677, i64 24)
%closure4679 = bitcast i8* %clsptr4678 to { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}*

; malloc environment structure
%envptr4680 = call i8* @llvm_zone_malloc(%mzone* %zone4677, i64 8)
%environment4681 = bitcast i8* %envptr4680 to {{i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}***}*

; malloc closure address table
%addytable4682 = call %clsvar* @new_address_table()
%var4683 = bitcast [56 x i8]* @gsxtmgraphics-pipeline162 to i8*
%var4684 = bitcast [50 x i8]* @gsxtmgraphics-pipeline163 to i8*
%addytable4685 = call %clsvar* @add_address_table(%mzone* %zone4677, i8* %var4683, i32 0, i8* %var4684, i32 3, %clsvar* %addytable4682)
%address-table4686 = bitcast %clsvar* %addytable4685 to i8*

; insert table, function and environment into closure struct
%closure.table4689 = getelementptr { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure4679, i32 0, i32 0
store i8* %address-table4686, i8** %closure.table4689
%closure.env4690 = getelementptr { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure4679, i32 0, i32 1
store i8* %envptr4680, i8** %closure.env4690
%closure.func4691 = getelementptr { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure4679, i32 0, i32 2
store float (i8*, i8*, %XTMMesh*, float)* @xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ__4671, float (i8*, i8*, %XTMMesh*, float)** %closure.func4691
%closure_size4692 = call i64 @llvm_zone_mark_size(%mzone* %zone4677)
call void @llvm_zone_ptr_set_size(i8* %clsptr4678, i64 %closure_size4692)
%wrapper_ptr4693 = call i8* @llvm_zone_malloc(%mzone* %zone4677, i64 8)
%closure_wrapper4694 = bitcast i8* %wrapper_ptr4693 to { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}**
store { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure4679, { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** %closure_wrapper4694

; let value assignment
%xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ = select i1 true, { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** %closure_wrapper4694, { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** %closure_wrapper4694
store { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** %xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ, { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}*** %xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ
%tmp_envptr4688 = getelementptr {{i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}***}, {{i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}***}* %environment4681, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}*** %xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQPtr, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}**** %tmp_envptr4688


%val4697 = load {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}**, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}*** %xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQPtr
ret {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** %val4697
}


@xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** @xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ(%XTMMesh* %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}*, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %XTMMesh*, float)*,  float (i8*, i8*, %XTMMesh*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1)
ret float %result
}


define dllexport ccc float @xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_native(%XTMMesh* %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}*, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %XTMMesh*, float)*,  float (i8*, i8*, %XTMMesh*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1)
ret float %result
}


define dllexport ccc i8*  @xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4698 = bitcast [109 x i8]* @gsxtmgraphics-pipeline164 to i8*
call i32 (i8*, ...) @printf(i8* %var4698)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMMesh*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4699 = bitcast [109 x i8]* @gsxtmgraphics-pipeline164 to i8*
call i32 (i8*, ...) @printf(i8* %var4699)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}*, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %XTMMesh*, float)*,  float (i8*, i8*, %XTMMesh*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMMesh*, float}*
%arg_p_0 = getelementptr {%XTMMesh*, float}, {%XTMMesh*, float}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMMesh*, %XTMMesh** %arg_p_0
%arg_p_1 = getelementptr {%XTMMesh*, float}, {%XTMMesh*, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_shininess_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}*, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %XTMMesh*, float)*,  float (i8*, i8*, %XTMMesh*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline165 = hidden constant [54 x i8] c"xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ\00"
define dllexport fastcc float @xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ__4700(i8* %_impz,i8* %_impenv, %XTMMesh* %mesh, float %value) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4701 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}***}*
%xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}***}, {{i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}***}* %impenv, i32 0, i32 0
%xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQPtr = load {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}***, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}**** %xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQPtr_

; setup arguments
%meshPtr = alloca %XTMMesh*
store %XTMMesh* %mesh, %XTMMesh** %meshPtr
%valuePtr = alloca float
store float %value, float* %valuePtr


%val4702 = load %XTMMesh*, %XTMMesh** %meshPtr
%val4703 = load float, float* %valuePtr
; set tuple
%val4704 = getelementptr %XTMMesh, %XTMMesh* %val4702, i64 0, i32 7
store float %val4703, float* %val4704
ret float %val4703
}
@gsxtmgraphics-pipeline166 = hidden constant [107 x i8] c"xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** @xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4724 = load i8*, i8** %_impzPtr
%zone4725 = bitcast i8* %tzone4724 to %mzone*

; let assign value to symbol xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ
%dat_xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone4725, i64 8)
%xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQPtr = bitcast i8* %dat_xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ to { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}***
%tzone4705 = load i8*, i8** %_impzPtr
%zone4706 = bitcast i8* %tzone4705 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4706)
; malloc closure structure
%clsptr4707 = call i8* @llvm_zone_malloc(%mzone* %zone4706, i64 24)
%closure4708 = bitcast i8* %clsptr4707 to { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}*

; malloc environment structure
%envptr4709 = call i8* @llvm_zone_malloc(%mzone* %zone4706, i64 8)
%environment4710 = bitcast i8* %envptr4709 to {{i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}***}*

; malloc closure address table
%addytable4711 = call %clsvar* @new_address_table()
%var4712 = bitcast [54 x i8]* @gsxtmgraphics-pipeline165 to i8*
%var4713 = bitcast [50 x i8]* @gsxtmgraphics-pipeline163 to i8*
%addytable4714 = call %clsvar* @add_address_table(%mzone* %zone4706, i8* %var4712, i32 0, i8* %var4713, i32 3, %clsvar* %addytable4711)
%address-table4715 = bitcast %clsvar* %addytable4714 to i8*

; insert table, function and environment into closure struct
%closure.table4718 = getelementptr { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure4708, i32 0, i32 0
store i8* %address-table4715, i8** %closure.table4718
%closure.env4719 = getelementptr { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure4708, i32 0, i32 1
store i8* %envptr4709, i8** %closure.env4719
%closure.func4720 = getelementptr { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure4708, i32 0, i32 2
store float (i8*, i8*, %XTMMesh*, float)* @xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ__4700, float (i8*, i8*, %XTMMesh*, float)** %closure.func4720
%closure_size4721 = call i64 @llvm_zone_mark_size(%mzone* %zone4706)
call void @llvm_zone_ptr_set_size(i8* %clsptr4707, i64 %closure_size4721)
%wrapper_ptr4722 = call i8* @llvm_zone_malloc(%mzone* %zone4706, i64 8)
%closure_wrapper4723 = bitcast i8* %wrapper_ptr4722 to { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}**
store { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure4708, { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** %closure_wrapper4723

; let value assignment
%xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ = select i1 true, { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** %closure_wrapper4723, { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** %closure_wrapper4723
store { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** %xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ, { i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}*** %xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ
%tmp_envptr4717 = getelementptr {{i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}***}, {{i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}***}* %environment4710, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}*** %xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQPtr, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}**** %tmp_envptr4717


%val4726 = load {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}**, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}*** %xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQPtr
ret {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** %val4726
}


@xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** @xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ(%XTMMesh* %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}*, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %XTMMesh*, float)*,  float (i8*, i8*, %XTMMesh*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1)
ret float %result
}


define dllexport ccc float @xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_native(%XTMMesh* %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}*, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %XTMMesh*, float)*,  float (i8*, i8*, %XTMMesh*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1)
ret float %result
}


define dllexport ccc i8*  @xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4727 = bitcast [107 x i8]* @gsxtmgraphics-pipeline166 to i8*
call i32 (i8*, ...) @printf(i8* %var4727)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMMesh*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4728 = bitcast [107 x i8]* @gsxtmgraphics-pipeline166 to i8*
call i32 (i8*, ...) @printf(i8* %var4728)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}*, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %XTMMesh*, float)*,  float (i8*, i8*, %XTMMesh*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMMesh*, float}*
%arg_p_0 = getelementptr {%XTMMesh*, float}, {%XTMMesh*, float}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMMesh*, %XTMMesh** %arg_p_0
%arg_p_1 = getelementptr {%XTMMesh*, float}, {%XTMMesh*, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_mesh_opacity_adhoc_W2Zsb2F0LFhUTU1lc2gqLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}*, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}, {i8*, i8*, float (i8*, i8*, %XTMMesh*, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %XTMMesh*, float)*,  float (i8*, i8*, %XTMMesh*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%XTMModel = type {%String*,float*,%XTMModel*,i32,%XTMModel*,i32,%XTMMesh*}
@gsxtmgraphics-pipeline167 = hidden constant [100 x i8] c"XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd\00"
@gsxtmgraphics-pipeline168 = hidden constant [100 x i8] c"{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**\00"
define dllexport fastcc %XTMModel* @XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd__4729(i8* %_impz,i8* %_impenv, %String* %arg_0, float* %arg_1, %XTMModel* %arg_2, i32 %arg_3, %XTMModel* %arg_4, i32 %arg_5, %XTMMesh* %arg_6) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4730 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}*
%XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpdPtr_ = getelementptr {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}, {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}* %impenv, i32 0, i32 0
%XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpdPtr = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**** %XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpdPtr_

; setup arguments
%arg_0Ptr = alloca %String*
store %String* %arg_0, %String** %arg_0Ptr
%arg_1Ptr = alloca float*
store float* %arg_1, float** %arg_1Ptr
%arg_2Ptr = alloca %XTMModel*
store %XTMModel* %arg_2, %XTMModel** %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca %XTMModel*
store %XTMModel* %arg_4, %XTMModel** %arg_4Ptr
%arg_5Ptr = alloca i32
store i32 %arg_5, i32* %arg_5Ptr
%arg_6Ptr = alloca %XTMMesh*
store %XTMMesh* %arg_6, %XTMMesh** %arg_6Ptr


%tzone4735 = load i8*, i8** %_impzPtr
%zone4736 = bitcast i8* %tzone4735 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMModel*
%tzone4731 = load i8*, i8** %_impzPtr
%zone4732 = bitcast i8* %tzone4731 to %mzone*
%dat4733 = call i8* @llvm_zone_malloc(%mzone* %zone4732, i64 56)
call i8* @memset(i8* %dat4733, i32 0, i64 56)
%val4734 = bitcast i8* %dat4733 to %XTMModel*

; let value assignment
%obj = select i1 true, %XTMModel* %val4734, %XTMModel* %val4734
store %XTMModel* %obj, %XTMModel** %objPtr

%val4737 = load %XTMModel*, %XTMModel** %objPtr
%val4738 = load %String*, %String** %arg_0Ptr
; set tuple
%val4739 = getelementptr %XTMModel, %XTMModel* %val4737, i64 0, i32 0
store %String* %val4738, %String** %val4739
%val4740 = load %XTMModel*, %XTMModel** %objPtr
%val4741 = load float*, float** %arg_1Ptr
; set tuple
%val4742 = getelementptr %XTMModel, %XTMModel* %val4740, i64 0, i32 1
store float* %val4741, float** %val4742
%val4743 = load %XTMModel*, %XTMModel** %objPtr
%val4744 = load %XTMModel*, %XTMModel** %arg_2Ptr
; set tuple
%val4745 = getelementptr %XTMModel, %XTMModel* %val4743, i64 0, i32 2
store %XTMModel* %val4744, %XTMModel** %val4745
%val4746 = load %XTMModel*, %XTMModel** %objPtr
%val4747 = load i32, i32* %arg_3Ptr
; set tuple
%val4748 = getelementptr %XTMModel, %XTMModel* %val4746, i64 0, i32 3
store i32 %val4747, i32* %val4748
%val4749 = load %XTMModel*, %XTMModel** %objPtr
%val4750 = load %XTMModel*, %XTMModel** %arg_4Ptr
; set tuple
%val4751 = getelementptr %XTMModel, %XTMModel* %val4749, i64 0, i32 4
store %XTMModel* %val4750, %XTMModel** %val4751
%val4752 = load %XTMModel*, %XTMModel** %objPtr
%val4753 = load i32, i32* %arg_5Ptr
; set tuple
%val4754 = getelementptr %XTMModel, %XTMModel* %val4752, i64 0, i32 5
store i32 %val4753, i32* %val4754
%val4755 = load %XTMModel*, %XTMModel** %objPtr
%val4756 = load %XTMMesh*, %XTMMesh** %arg_6Ptr
; set tuple
%val4757 = getelementptr %XTMModel, %XTMModel* %val4755, i64 0, i32 6
store %XTMMesh* %val4756, %XTMMesh** %val4757
%val4758 = load %XTMModel*, %XTMModel** %objPtr
ret %XTMModel* %val4758
}
@gsxtmgraphics-pipeline169 = hidden constant [153 x i8] c"XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** @XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4778 = load i8*, i8** %_impzPtr
%zone4779 = bitcast i8* %tzone4778 to %mzone*

; let assign value to symbol XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd
%dat_XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd = call i8* @llvm_zone_malloc(%mzone* %zone4779, i64 8)
%XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpdPtr = bitcast i8* %dat_XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd to { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***
%tzone4759 = load i8*, i8** %_impzPtr
%zone4760 = bitcast i8* %tzone4759 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4760)
; malloc closure structure
%clsptr4761 = call i8* @llvm_zone_malloc(%mzone* %zone4760, i64 24)
%closure4762 = bitcast i8* %clsptr4761 to { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*

; malloc environment structure
%envptr4763 = call i8* @llvm_zone_malloc(%mzone* %zone4760, i64 8)
%environment4764 = bitcast i8* %envptr4763 to {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}*

; malloc closure address table
%addytable4765 = call %clsvar* @new_address_table()
%var4766 = bitcast [100 x i8]* @gsxtmgraphics-pipeline167 to i8*
%var4767 = bitcast [100 x i8]* @gsxtmgraphics-pipeline168 to i8*
%addytable4768 = call %clsvar* @add_address_table(%mzone* %zone4760, i8* %var4766, i32 0, i8* %var4767, i32 3, %clsvar* %addytable4765)
%address-table4769 = bitcast %clsvar* %addytable4768 to i8*

; insert table, function and environment into closure struct
%closure.table4772 = getelementptr { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure4762, i32 0, i32 0
store i8* %address-table4769, i8** %closure.table4772
%closure.env4773 = getelementptr { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure4762, i32 0, i32 1
store i8* %envptr4763, i8** %closure.env4773
%closure.func4774 = getelementptr { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure4762, i32 0, i32 2
store %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)* @XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd__4729, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)** %closure.func4774
%closure_size4775 = call i64 @llvm_zone_mark_size(%mzone* %zone4760)
call void @llvm_zone_ptr_set_size(i8* %clsptr4761, i64 %closure_size4775)
%wrapper_ptr4776 = call i8* @llvm_zone_malloc(%mzone* %zone4760, i64 8)
%closure_wrapper4777 = bitcast i8* %wrapper_ptr4776 to { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**
store { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure4762, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_wrapper4777

; let value assignment
%XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd = select i1 true, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_wrapper4777, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_wrapper4777
store { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*** %XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpdPtr

; add data to environment
; don't need to alloc for env var XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd
%tmp_envptr4771 = getelementptr {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}, {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}* %environment4764, i32 0, i32 0
store {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*** %XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpdPtr, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**** %tmp_envptr4771


%val4780 = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*** %XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpdPtr
ret {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %val4780
}


@XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var = dllexport global [1 x i8*] [ i8* null ]

@XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** @XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMModel* @XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd(%String* %arg_0,float* %arg_1,%XTMModel* %arg_2,i32 %arg_3,%XTMModel* %arg_4,i32 %arg_5,%XTMMesh* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*,  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %String* %arg_0, float* %arg_1, %XTMModel* %arg_2, i32 %arg_3, %XTMModel* %arg_4, i32 %arg_5, %XTMMesh* %arg_6)
ret %XTMModel* %result
}


define dllexport ccc %XTMModel* @XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_native(%String* %arg_0,float* %arg_1,%XTMModel* %arg_2,i32 %arg_3,%XTMModel* %arg_4,i32 %arg_5,%XTMMesh* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*,  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %String* %arg_0, float* %arg_1, %XTMModel* %arg_2, i32 %arg_3, %XTMModel* %arg_4, i32 %arg_5, %XTMMesh* %arg_6)
ret %XTMModel* %result
}


define dllexport ccc i8*  @XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4781 = bitcast [153 x i8]* @gsxtmgraphics-pipeline169 to i8*
call i32 (i8*, ...) @printf(i8* %var4781)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4782 = bitcast [153 x i8]* @gsxtmgraphics-pipeline169 to i8*
call i32 (i8*, ...) @printf(i8* %var4782)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4783 = bitcast [153 x i8]* @gsxtmgraphics-pipeline169 to i8*
call i32 (i8*, ...) @printf(i8* %var4783)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %XTMModel*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var4784 = bitcast [153 x i8]* @gsxtmgraphics-pipeline169 to i8*
call i32 (i8*, ...) @printf(i8* %var4784)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var4785 = bitcast [153 x i8]* @gsxtmgraphics-pipeline169 to i8*
call i32 (i8*, ...) @printf(i8* %var4785)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to %XTMModel*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var4786 = bitcast [153 x i8]* @gsxtmgraphics-pipeline169 to i8*
call i32 (i8*, ...) @printf(i8* %var4786)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var4787 = bitcast [153 x i8]* @gsxtmgraphics-pipeline169 to i8*
call i32 (i8*, ...) @printf(i8* %var4787)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to %XTMMesh*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*,  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %String* %arg_0, float* %arg_1, %XTMModel* %arg_2, i32 %arg_3, %XTMModel* %arg_4, i32 %arg_5, %XTMMesh* %arg_6)
%tmpres = bitcast %XTMModel* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}*
%arg_p_0 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 2
%arg_2 = load %XTMModel*, %XTMModel** %arg_p_2
%arg_p_3 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 4
%arg_4 = load %XTMModel*, %XTMModel** %arg_p_4
%arg_p_5 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
%arg_p_6 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 6
%arg_6 = load %XTMMesh*, %XTMMesh** %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*,  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %String* %arg_0, float* %arg_1, %XTMModel* %arg_2, i32 %arg_3, %XTMModel* %arg_4, i32 %arg_5, %XTMMesh* %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline170 = hidden constant [102 x i8] c"XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd\00"
define dllexport fastcc %XTMModel* @XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd__4788(i8* %_impz,i8* %_impenv, %String* %arg_0, float* %arg_1, %XTMModel* %arg_2, i32 %arg_3, %XTMModel* %arg_4, i32 %arg_5, %XTMMesh* %arg_6) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4789 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}*
%XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpdPtr_ = getelementptr {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}, {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}* %impenv, i32 0, i32 0
%XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpdPtr = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**** %XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpdPtr_

; setup arguments
%arg_0Ptr = alloca %String*
store %String* %arg_0, %String** %arg_0Ptr
%arg_1Ptr = alloca float*
store float* %arg_1, float** %arg_1Ptr
%arg_2Ptr = alloca %XTMModel*
store %XTMModel* %arg_2, %XTMModel** %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca %XTMModel*
store %XTMModel* %arg_4, %XTMModel** %arg_4Ptr
%arg_5Ptr = alloca i32
store i32 %arg_5, i32* %arg_5Ptr
%arg_6Ptr = alloca %XTMMesh*
store %XTMMesh* %arg_6, %XTMMesh** %arg_6Ptr


%tzone4794 = load i8*, i8** %_impzPtr
%zone4795 = bitcast i8* %tzone4794 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMModel*
%tzone4790 = load i8*, i8** %_impzPtr
%zone4791 = bitcast i8* %tzone4790 to %mzone*
%dat4792 = call i8* @llvm_zone_malloc(%mzone* %zone4791, i64 56)
call i8* @memset(i8* %dat4792, i32 0, i64 56)
%val4793 = bitcast i8* %dat4792 to %XTMModel*

; let value assignment
%obj = select i1 true, %XTMModel* %val4793, %XTMModel* %val4793
store %XTMModel* %obj, %XTMModel** %objPtr

%val4796 = load %XTMModel*, %XTMModel** %objPtr
%val4797 = load %String*, %String** %arg_0Ptr
; set tuple
%val4798 = getelementptr %XTMModel, %XTMModel* %val4796, i64 0, i32 0
store %String* %val4797, %String** %val4798
%val4799 = load %XTMModel*, %XTMModel** %objPtr
%val4800 = load float*, float** %arg_1Ptr
; set tuple
%val4801 = getelementptr %XTMModel, %XTMModel* %val4799, i64 0, i32 1
store float* %val4800, float** %val4801
%val4802 = load %XTMModel*, %XTMModel** %objPtr
%val4803 = load %XTMModel*, %XTMModel** %arg_2Ptr
; set tuple
%val4804 = getelementptr %XTMModel, %XTMModel* %val4802, i64 0, i32 2
store %XTMModel* %val4803, %XTMModel** %val4804
%val4805 = load %XTMModel*, %XTMModel** %objPtr
%val4806 = load i32, i32* %arg_3Ptr
; set tuple
%val4807 = getelementptr %XTMModel, %XTMModel* %val4805, i64 0, i32 3
store i32 %val4806, i32* %val4807
%val4808 = load %XTMModel*, %XTMModel** %objPtr
%val4809 = load %XTMModel*, %XTMModel** %arg_4Ptr
; set tuple
%val4810 = getelementptr %XTMModel, %XTMModel* %val4808, i64 0, i32 4
store %XTMModel* %val4809, %XTMModel** %val4810
%val4811 = load %XTMModel*, %XTMModel** %objPtr
%val4812 = load i32, i32* %arg_5Ptr
; set tuple
%val4813 = getelementptr %XTMModel, %XTMModel* %val4811, i64 0, i32 5
store i32 %val4812, i32* %val4813
%val4814 = load %XTMModel*, %XTMModel** %objPtr
%val4815 = load %XTMMesh*, %XTMMesh** %arg_6Ptr
; set tuple
%val4816 = getelementptr %XTMModel, %XTMModel* %val4814, i64 0, i32 6
store %XTMMesh* %val4815, %XTMMesh** %val4816
%val4817 = load %XTMModel*, %XTMModel** %objPtr
ret %XTMModel* %val4817
}
@gsxtmgraphics-pipeline171 = hidden constant [155 x i8] c"XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** @XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4837 = load i8*, i8** %_impzPtr
%zone4838 = bitcast i8* %tzone4837 to %mzone*

; let assign value to symbol XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd
%dat_XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd = call i8* @llvm_zone_malloc(%mzone* %zone4838, i64 8)
%XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpdPtr = bitcast i8* %dat_XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd to { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***
%tzone4818 = load i8*, i8** %_impzPtr
%zone4819 = bitcast i8* %tzone4818 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4819)
; malloc closure structure
%clsptr4820 = call i8* @llvm_zone_malloc(%mzone* %zone4819, i64 24)
%closure4821 = bitcast i8* %clsptr4820 to { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*

; malloc environment structure
%envptr4822 = call i8* @llvm_zone_malloc(%mzone* %zone4819, i64 8)
%environment4823 = bitcast i8* %envptr4822 to {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}*

; malloc closure address table
%addytable4824 = call %clsvar* @new_address_table()
%var4825 = bitcast [102 x i8]* @gsxtmgraphics-pipeline170 to i8*
%var4826 = bitcast [100 x i8]* @gsxtmgraphics-pipeline168 to i8*
%addytable4827 = call %clsvar* @add_address_table(%mzone* %zone4819, i8* %var4825, i32 0, i8* %var4826, i32 3, %clsvar* %addytable4824)
%address-table4828 = bitcast %clsvar* %addytable4827 to i8*

; insert table, function and environment into closure struct
%closure.table4831 = getelementptr { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure4821, i32 0, i32 0
store i8* %address-table4828, i8** %closure.table4831
%closure.env4832 = getelementptr { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure4821, i32 0, i32 1
store i8* %envptr4822, i8** %closure.env4832
%closure.func4833 = getelementptr { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure4821, i32 0, i32 2
store %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)* @XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd__4788, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)** %closure.func4833
%closure_size4834 = call i64 @llvm_zone_mark_size(%mzone* %zone4819)
call void @llvm_zone_ptr_set_size(i8* %clsptr4820, i64 %closure_size4834)
%wrapper_ptr4835 = call i8* @llvm_zone_malloc(%mzone* %zone4819, i64 8)
%closure_wrapper4836 = bitcast i8* %wrapper_ptr4835 to { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**
store { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure4821, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_wrapper4836

; let value assignment
%XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd = select i1 true, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_wrapper4836, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_wrapper4836
store { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*** %XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpdPtr

; add data to environment
; don't need to alloc for env var XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd
%tmp_envptr4830 = getelementptr {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}, {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}* %environment4823, i32 0, i32 0
store {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*** %XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpdPtr, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**** %tmp_envptr4830


%val4839 = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*** %XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpdPtr
ret {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %val4839
}


@XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var = dllexport global [1 x i8*] [ i8* null ]

@XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** @XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMModel* @XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd(%String* %arg_0,float* %arg_1,%XTMModel* %arg_2,i32 %arg_3,%XTMModel* %arg_4,i32 %arg_5,%XTMMesh* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*,  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %String* %arg_0, float* %arg_1, %XTMModel* %arg_2, i32 %arg_3, %XTMModel* %arg_4, i32 %arg_5, %XTMMesh* %arg_6)
ret %XTMModel* %result
}


define dllexport ccc %XTMModel* @XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_native(%String* %arg_0,float* %arg_1,%XTMModel* %arg_2,i32 %arg_3,%XTMModel* %arg_4,i32 %arg_5,%XTMMesh* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*,  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %String* %arg_0, float* %arg_1, %XTMModel* %arg_2, i32 %arg_3, %XTMModel* %arg_4, i32 %arg_5, %XTMMesh* %arg_6)
ret %XTMModel* %result
}


define dllexport ccc i8*  @XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4840 = bitcast [155 x i8]* @gsxtmgraphics-pipeline171 to i8*
call i32 (i8*, ...) @printf(i8* %var4840)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4841 = bitcast [155 x i8]* @gsxtmgraphics-pipeline171 to i8*
call i32 (i8*, ...) @printf(i8* %var4841)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4842 = bitcast [155 x i8]* @gsxtmgraphics-pipeline171 to i8*
call i32 (i8*, ...) @printf(i8* %var4842)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %XTMModel*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var4843 = bitcast [155 x i8]* @gsxtmgraphics-pipeline171 to i8*
call i32 (i8*, ...) @printf(i8* %var4843)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var4844 = bitcast [155 x i8]* @gsxtmgraphics-pipeline171 to i8*
call i32 (i8*, ...) @printf(i8* %var4844)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to %XTMModel*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var4845 = bitcast [155 x i8]* @gsxtmgraphics-pipeline171 to i8*
call i32 (i8*, ...) @printf(i8* %var4845)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var4846 = bitcast [155 x i8]* @gsxtmgraphics-pipeline171 to i8*
call i32 (i8*, ...) @printf(i8* %var4846)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to %XTMMesh*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*,  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %String* %arg_0, float* %arg_1, %XTMModel* %arg_2, i32 %arg_3, %XTMModel* %arg_4, i32 %arg_5, %XTMMesh* %arg_6)
%tmpres = bitcast %XTMModel* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}*
%arg_p_0 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 2
%arg_2 = load %XTMModel*, %XTMModel** %arg_p_2
%arg_p_3 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 4
%arg_4 = load %XTMModel*, %XTMModel** %arg_p_4
%arg_p_5 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
%arg_p_6 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 6
%arg_6 = load %XTMMesh*, %XTMMesh** %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_z_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*,  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %String* %arg_0, float* %arg_1, %XTMModel* %arg_2, i32 %arg_3, %XTMModel* %arg_4, i32 %arg_5, %XTMMesh* %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline172 = hidden constant [102 x i8] c"XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd\00"
define dllexport fastcc %XTMModel* @XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd__4847(i8* %_impz,i8* %_impenv, %String* %arg_0, float* %arg_1, %XTMModel* %arg_2, i32 %arg_3, %XTMModel* %arg_4, i32 %arg_5, %XTMMesh* %arg_6) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4848 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}*
%XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpdPtr_ = getelementptr {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}, {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}* %impenv, i32 0, i32 0
%XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpdPtr = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**** %XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpdPtr_

; setup arguments
%arg_0Ptr = alloca %String*
store %String* %arg_0, %String** %arg_0Ptr
%arg_1Ptr = alloca float*
store float* %arg_1, float** %arg_1Ptr
%arg_2Ptr = alloca %XTMModel*
store %XTMModel* %arg_2, %XTMModel** %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca %XTMModel*
store %XTMModel* %arg_4, %XTMModel** %arg_4Ptr
%arg_5Ptr = alloca i32
store i32 %arg_5, i32* %arg_5Ptr
%arg_6Ptr = alloca %XTMMesh*
store %XTMMesh* %arg_6, %XTMMesh** %arg_6Ptr


%tzone4851 = load i8*, i8** %_impzPtr
%zone4852 = bitcast i8* %tzone4851 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMModel*
%dat4849 = call i8* @malloc(i64 56)
call i8* @memset(i8* %dat4849, i32 0, i64 56)
%val4850 = bitcast i8* %dat4849 to %XTMModel*

; let value assignment
%obj = select i1 true, %XTMModel* %val4850, %XTMModel* %val4850
store %XTMModel* %obj, %XTMModel** %objPtr

%val4853 = load %XTMModel*, %XTMModel** %objPtr
%val4854 = load %String*, %String** %arg_0Ptr
; set tuple
%val4855 = getelementptr %XTMModel, %XTMModel* %val4853, i64 0, i32 0
store %String* %val4854, %String** %val4855
%val4856 = load %XTMModel*, %XTMModel** %objPtr
%val4857 = load float*, float** %arg_1Ptr
; set tuple
%val4858 = getelementptr %XTMModel, %XTMModel* %val4856, i64 0, i32 1
store float* %val4857, float** %val4858
%val4859 = load %XTMModel*, %XTMModel** %objPtr
%val4860 = load %XTMModel*, %XTMModel** %arg_2Ptr
; set tuple
%val4861 = getelementptr %XTMModel, %XTMModel* %val4859, i64 0, i32 2
store %XTMModel* %val4860, %XTMModel** %val4861
%val4862 = load %XTMModel*, %XTMModel** %objPtr
%val4863 = load i32, i32* %arg_3Ptr
; set tuple
%val4864 = getelementptr %XTMModel, %XTMModel* %val4862, i64 0, i32 3
store i32 %val4863, i32* %val4864
%val4865 = load %XTMModel*, %XTMModel** %objPtr
%val4866 = load %XTMModel*, %XTMModel** %arg_4Ptr
; set tuple
%val4867 = getelementptr %XTMModel, %XTMModel* %val4865, i64 0, i32 4
store %XTMModel* %val4866, %XTMModel** %val4867
%val4868 = load %XTMModel*, %XTMModel** %objPtr
%val4869 = load i32, i32* %arg_5Ptr
; set tuple
%val4870 = getelementptr %XTMModel, %XTMModel* %val4868, i64 0, i32 5
store i32 %val4869, i32* %val4870
%val4871 = load %XTMModel*, %XTMModel** %objPtr
%val4872 = load %XTMMesh*, %XTMMesh** %arg_6Ptr
; set tuple
%val4873 = getelementptr %XTMModel, %XTMModel* %val4871, i64 0, i32 6
store %XTMMesh* %val4872, %XTMMesh** %val4873
%val4874 = load %XTMModel*, %XTMModel** %objPtr
ret %XTMModel* %val4874
}
@gsxtmgraphics-pipeline173 = hidden constant [155 x i8] c"XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** @XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4894 = load i8*, i8** %_impzPtr
%zone4895 = bitcast i8* %tzone4894 to %mzone*

; let assign value to symbol XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd
%dat_XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd = call i8* @llvm_zone_malloc(%mzone* %zone4895, i64 8)
%XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpdPtr = bitcast i8* %dat_XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd to { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***
%tzone4875 = load i8*, i8** %_impzPtr
%zone4876 = bitcast i8* %tzone4875 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4876)
; malloc closure structure
%clsptr4877 = call i8* @llvm_zone_malloc(%mzone* %zone4876, i64 24)
%closure4878 = bitcast i8* %clsptr4877 to { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*

; malloc environment structure
%envptr4879 = call i8* @llvm_zone_malloc(%mzone* %zone4876, i64 8)
%environment4880 = bitcast i8* %envptr4879 to {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}*

; malloc closure address table
%addytable4881 = call %clsvar* @new_address_table()
%var4882 = bitcast [102 x i8]* @gsxtmgraphics-pipeline172 to i8*
%var4883 = bitcast [100 x i8]* @gsxtmgraphics-pipeline168 to i8*
%addytable4884 = call %clsvar* @add_address_table(%mzone* %zone4876, i8* %var4882, i32 0, i8* %var4883, i32 3, %clsvar* %addytable4881)
%address-table4885 = bitcast %clsvar* %addytable4884 to i8*

; insert table, function and environment into closure struct
%closure.table4888 = getelementptr { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure4878, i32 0, i32 0
store i8* %address-table4885, i8** %closure.table4888
%closure.env4889 = getelementptr { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure4878, i32 0, i32 1
store i8* %envptr4879, i8** %closure.env4889
%closure.func4890 = getelementptr { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure4878, i32 0, i32 2
store %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)* @XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd__4847, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)** %closure.func4890
%closure_size4891 = call i64 @llvm_zone_mark_size(%mzone* %zone4876)
call void @llvm_zone_ptr_set_size(i8* %clsptr4877, i64 %closure_size4891)
%wrapper_ptr4892 = call i8* @llvm_zone_malloc(%mzone* %zone4876, i64 8)
%closure_wrapper4893 = bitcast i8* %wrapper_ptr4892 to { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**
store { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure4878, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_wrapper4893

; let value assignment
%XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd = select i1 true, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_wrapper4893, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_wrapper4893
store { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*** %XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpdPtr

; add data to environment
; don't need to alloc for env var XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd
%tmp_envptr4887 = getelementptr {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}, {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}* %environment4880, i32 0, i32 0
store {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*** %XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpdPtr, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**** %tmp_envptr4887


%val4896 = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*** %XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpdPtr
ret {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %val4896
}


@XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var = dllexport global [1 x i8*] [ i8* null ]

@XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** @XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMModel* @XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd(%String* %arg_0,float* %arg_1,%XTMModel* %arg_2,i32 %arg_3,%XTMModel* %arg_4,i32 %arg_5,%XTMMesh* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*,  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %String* %arg_0, float* %arg_1, %XTMModel* %arg_2, i32 %arg_3, %XTMModel* %arg_4, i32 %arg_5, %XTMMesh* %arg_6)
ret %XTMModel* %result
}


define dllexport ccc %XTMModel* @XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_native(%String* %arg_0,float* %arg_1,%XTMModel* %arg_2,i32 %arg_3,%XTMModel* %arg_4,i32 %arg_5,%XTMMesh* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*,  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %String* %arg_0, float* %arg_1, %XTMModel* %arg_2, i32 %arg_3, %XTMModel* %arg_4, i32 %arg_5, %XTMMesh* %arg_6)
ret %XTMModel* %result
}


define dllexport ccc i8*  @XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4897 = bitcast [155 x i8]* @gsxtmgraphics-pipeline173 to i8*
call i32 (i8*, ...) @printf(i8* %var4897)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4898 = bitcast [155 x i8]* @gsxtmgraphics-pipeline173 to i8*
call i32 (i8*, ...) @printf(i8* %var4898)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4899 = bitcast [155 x i8]* @gsxtmgraphics-pipeline173 to i8*
call i32 (i8*, ...) @printf(i8* %var4899)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %XTMModel*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var4900 = bitcast [155 x i8]* @gsxtmgraphics-pipeline173 to i8*
call i32 (i8*, ...) @printf(i8* %var4900)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var4901 = bitcast [155 x i8]* @gsxtmgraphics-pipeline173 to i8*
call i32 (i8*, ...) @printf(i8* %var4901)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to %XTMModel*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var4902 = bitcast [155 x i8]* @gsxtmgraphics-pipeline173 to i8*
call i32 (i8*, ...) @printf(i8* %var4902)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var4903 = bitcast [155 x i8]* @gsxtmgraphics-pipeline173 to i8*
call i32 (i8*, ...) @printf(i8* %var4903)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to %XTMMesh*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*,  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %String* %arg_0, float* %arg_1, %XTMModel* %arg_2, i32 %arg_3, %XTMModel* %arg_4, i32 %arg_5, %XTMMesh* %arg_6)
%tmpres = bitcast %XTMModel* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}*
%arg_p_0 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 2
%arg_2 = load %XTMModel*, %XTMModel** %arg_p_2
%arg_p_3 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 4
%arg_4 = load %XTMModel*, %XTMModel** %arg_p_4
%arg_p_5 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
%arg_p_6 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 6
%arg_6 = load %XTMMesh*, %XTMMesh** %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_h_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixYVE1Nb2RlbCosaTMyLFhUTU1vZGVsKixpMzIsWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*,  %XTMModel* (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %String* %arg_0, float* %arg_1, %XTMModel* %arg_2, i32 %arg_3, %XTMModel* %arg_4, i32 %arg_5, %XTMMesh* %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline174 = hidden constant [103 x i8] c"XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0\00"
@gsxtmgraphics-pipeline175 = hidden constant [99 x i8] c"{i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**\00"
define dllexport fastcc %XTMModel @XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0__4904(i8* %_impz,i8* %_impenv, %String* %arg_0, float* %arg_1, %XTMModel* %arg_2, i32 %arg_3, %XTMModel* %arg_4, i32 %arg_5, %XTMMesh* %arg_6) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4905 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}*
%XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0Ptr_ = getelementptr {{i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}, {{i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}* %impenv, i32 0, i32 0
%XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0Ptr = load {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***, {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**** %XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0Ptr_

; setup arguments
%arg_0Ptr = alloca %String*
store %String* %arg_0, %String** %arg_0Ptr
%arg_1Ptr = alloca float*
store float* %arg_1, float** %arg_1Ptr
%arg_2Ptr = alloca %XTMModel*
store %XTMModel* %arg_2, %XTMModel** %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca %XTMModel*
store %XTMModel* %arg_4, %XTMModel** %arg_4Ptr
%arg_5Ptr = alloca i32
store i32 %arg_5, i32* %arg_5Ptr
%arg_6Ptr = alloca %XTMMesh*
store %XTMMesh* %arg_6, %XTMMesh** %arg_6Ptr


%tzone4907 = load i8*, i8** %_impzPtr
%zone4908 = bitcast i8* %tzone4907 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMModel*
%dat4906 = alloca %XTMModel, align 16

; let value assignment
%obj = select i1 true, %XTMModel* %dat4906, %XTMModel* %dat4906
store %XTMModel* %obj, %XTMModel** %objPtr

%val4909 = load %XTMModel*, %XTMModel** %objPtr
%val4910 = load %String*, %String** %arg_0Ptr
; set tuple
%val4911 = getelementptr %XTMModel, %XTMModel* %val4909, i64 0, i32 0
store %String* %val4910, %String** %val4911
%val4912 = load %XTMModel*, %XTMModel** %objPtr
%val4913 = load float*, float** %arg_1Ptr
; set tuple
%val4914 = getelementptr %XTMModel, %XTMModel* %val4912, i64 0, i32 1
store float* %val4913, float** %val4914
%val4915 = load %XTMModel*, %XTMModel** %objPtr
%val4916 = load %XTMModel*, %XTMModel** %arg_2Ptr
; set tuple
%val4917 = getelementptr %XTMModel, %XTMModel* %val4915, i64 0, i32 2
store %XTMModel* %val4916, %XTMModel** %val4917
%val4918 = load %XTMModel*, %XTMModel** %objPtr
%val4919 = load i32, i32* %arg_3Ptr
; set tuple
%val4920 = getelementptr %XTMModel, %XTMModel* %val4918, i64 0, i32 3
store i32 %val4919, i32* %val4920
%val4921 = load %XTMModel*, %XTMModel** %objPtr
%val4922 = load %XTMModel*, %XTMModel** %arg_4Ptr
; set tuple
%val4923 = getelementptr %XTMModel, %XTMModel* %val4921, i64 0, i32 4
store %XTMModel* %val4922, %XTMModel** %val4923
%val4924 = load %XTMModel*, %XTMModel** %objPtr
%val4925 = load i32, i32* %arg_5Ptr
; set tuple
%val4926 = getelementptr %XTMModel, %XTMModel* %val4924, i64 0, i32 5
store i32 %val4925, i32* %val4926
%val4927 = load %XTMModel*, %XTMModel** %objPtr
%val4928 = load %XTMMesh*, %XTMMesh** %arg_6Ptr
; set tuple
%val4929 = getelementptr %XTMModel, %XTMModel* %val4927, i64 0, i32 6
store %XTMMesh* %val4928, %XTMMesh** %val4929
%val4930 = load %XTMModel*, %XTMModel** %objPtr
; pointer ref
%val4931 = getelementptr %XTMModel, %XTMModel* %val4930, i64 0
%val4932 = load %XTMModel, %XTMModel* %val4931
ret %XTMModel %val4932
}
@gsxtmgraphics-pipeline176 = hidden constant [156 x i8] c"XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** @XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4952 = load i8*, i8** %_impzPtr
%zone4953 = bitcast i8* %tzone4952 to %mzone*

; let assign value to symbol XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0
%dat_XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0 = call i8* @llvm_zone_malloc(%mzone* %zone4953, i64 8)
%XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0Ptr = bitcast i8* %dat_XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0 to { i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***
%tzone4933 = load i8*, i8** %_impzPtr
%zone4934 = bitcast i8* %tzone4933 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4934)
; malloc closure structure
%clsptr4935 = call i8* @llvm_zone_malloc(%mzone* %zone4934, i64 24)
%closure4936 = bitcast i8* %clsptr4935 to { i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*

; malloc environment structure
%envptr4937 = call i8* @llvm_zone_malloc(%mzone* %zone4934, i64 8)
%environment4938 = bitcast i8* %envptr4937 to {{i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}*

; malloc closure address table
%addytable4939 = call %clsvar* @new_address_table()
%var4940 = bitcast [103 x i8]* @gsxtmgraphics-pipeline174 to i8*
%var4941 = bitcast [99 x i8]* @gsxtmgraphics-pipeline175 to i8*
%addytable4942 = call %clsvar* @add_address_table(%mzone* %zone4934, i8* %var4940, i32 0, i8* %var4941, i32 3, %clsvar* %addytable4939)
%address-table4943 = bitcast %clsvar* %addytable4942 to i8*

; insert table, function and environment into closure struct
%closure.table4946 = getelementptr { i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, { i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure4936, i32 0, i32 0
store i8* %address-table4943, i8** %closure.table4946
%closure.env4947 = getelementptr { i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, { i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure4936, i32 0, i32 1
store i8* %envptr4937, i8** %closure.env4947
%closure.func4948 = getelementptr { i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, { i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure4936, i32 0, i32 2
store %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)* @XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0__4904, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)** %closure.func4948
%closure_size4949 = call i64 @llvm_zone_mark_size(%mzone* %zone4934)
call void @llvm_zone_ptr_set_size(i8* %clsptr4935, i64 %closure_size4949)
%wrapper_ptr4950 = call i8* @llvm_zone_malloc(%mzone* %zone4934, i64 8)
%closure_wrapper4951 = bitcast i8* %wrapper_ptr4950 to { i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**
store { i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure4936, { i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_wrapper4951

; let value assignment
%XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0 = select i1 true, { i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_wrapper4951, { i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_wrapper4951
store { i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0, { i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*** %XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0Ptr

; add data to environment
; don't need to alloc for env var XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0
%tmp_envptr4945 = getelementptr {{i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}, {{i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}***}* %environment4938, i32 0, i32 0
store {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*** %XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0Ptr, {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**** %tmp_envptr4945


%val4954 = load {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**, {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*** %XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0Ptr
ret {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %val4954
}


@XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0_var = dllexport global [1 x i8*] [ i8* null ]

@XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** @XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMModel @XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0(%String* %arg_0,float* %arg_1,%XTMModel* %arg_2,i32 %arg_3,%XTMModel* %arg_4,i32 %arg_5,%XTMMesh* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**
%closure = load {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*, {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*,  %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel %ff(i8* %_impz, i8* %ee, %String* %arg_0, float* %arg_1, %XTMModel* %arg_2, i32 %arg_3, %XTMModel* %arg_4, i32 %arg_5, %XTMMesh* %arg_6)
ret %XTMModel %result
}


define dllexport ccc %XTMModel @XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0_native(%String* %arg_0,float* %arg_1,%XTMModel* %arg_2,i32 %arg_3,%XTMModel* %arg_4,i32 %arg_5,%XTMMesh* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**
%closure = load {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*, {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*,  %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel %ff(i8* %_impz, i8* %ee, %String* %arg_0, float* %arg_1, %XTMModel* %arg_2, i32 %arg_3, %XTMModel* %arg_4, i32 %arg_5, %XTMMesh* %arg_6)
ret %XTMModel %result
}


define dllexport ccc void @XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}*
%arg_p_0 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 2
%arg_2 = load %XTMModel*, %XTMModel** %arg_p_2
%arg_p_3 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 4
%arg_4 = load %XTMModel*, %XTMModel** %arg_p_4
%arg_p_5 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
%arg_p_6 = getelementptr {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}, {%String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*}* %fstruct, i32 0, i32 6
%arg_6 = load %XTMMesh*, %XTMMesh** %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @XTMModel_val_adhoc_W1hUTU1vZGVsLFN0cmluZyosZmxvYXQqLFhUTU1vZGVsKixpMzIsWFRNTW9kZWwqLGkzMixYVE1NZXNoKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}**
%closure = load {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}*, {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}, {i8*, i8*, %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)*,  %XTMModel (i8*, i8*, %String*, float*, %XTMModel*, i32, %XTMModel*, i32, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel %ff(i8* %_impz, i8* %ee, %String* %arg_0, float* %arg_1, %XTMModel* %arg_2, i32 %arg_3, %XTMModel* %arg_4, i32 %arg_5, %XTMMesh* %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline177 = hidden constant [41 x i8] c"hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd\00"
@gsxtmgraphics-pipeline178 = hidden constant [49 x i8] c"{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}**\00"
define dllexport fastcc %XTMModel* @hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd__4962(i8* %_impz,i8* %_impenv, %XTMModel* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4963 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}***}*
%hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpdPtr_ = getelementptr {{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}***}, {{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpdPtr = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}***, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}**** %hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpdPtr_

; setup arguments
%xPtr = alloca %XTMModel*
store %XTMModel* %x, %XTMModel** %xPtr


%tzone4966 = load i8*, i8** %_impzPtr
%zone4967 = bitcast i8* %tzone4966 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMModel*
%dat4964 = call i8* @malloc(i64 56)
call i8* @memset(i8* %dat4964, i32 0, i64 56)
%val4965 = bitcast i8* %dat4964 to %XTMModel*

; let value assignment
%obj = select i1 true, %XTMModel* %val4965, %XTMModel* %val4965
store %XTMModel* %obj, %XTMModel** %objPtr

; promote local stack var allocations
%tzone5066 = load i8*, i8** %_impzPtr
%zone5067 = bitcast i8* %tzone5066 to %mzone*
%ifptr5049 = alloca %XTMMesh*
%ifptr5050 = alloca i1
%ifptr5019 = alloca %XTMModel*
%ifptr5020 = alloca i1
%ifptr4989 = alloca %XTMModel*
%ifptr4990 = alloca i1
%ifptr4968 = alloca %String*
%ifptr4969 = alloca i1
%val4970 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val4971 = getelementptr %XTMModel, %XTMModel* %val4970, i64 0, i32 0
%val4972 = load %String*, %String** %val4971
%val4973 = icmp eq %String* %val4972, null
br i1 %val4973, label %then4969, label %else4969

then4969:
%res4974 = call ccc i1 @impc_false()
store i1 %res4974, i1* %ifptr4969
br label %ifcont4969

else4969:
%res4975 = call ccc i1 @impc_true()
store i1 %res4975, i1* %ifptr4969
br label %ifcont4969

ifcont4969:
%ifres4976 = load i1, i1* %ifptr4969

br i1 %ifres4976, label %then4968, label %else4968

then4968:
%val4977 = load %XTMModel*, %XTMModel** %objPtr
%val4978 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val4979 = getelementptr %XTMModel, %XTMModel* %val4978, i64 0, i32 0
%val4980 = load %String*, %String** %val4979
%res4981 = call fastcc %String* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0(%String* %val4980)
; set tuple
%val4982 = getelementptr %XTMModel, %XTMModel* %val4977, i64 0, i32 0
store %String* %res4981, %String** %val4982
store %String* %res4981, %String** %ifptr4968
br label %ifcont4968

else4968:
br label %ifcont4968

ifcont4968:
%ifres4983 = load %String*, %String** %ifptr4968

%val4984 = load %XTMModel*, %XTMModel** %objPtr
%val4985 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val4986 = getelementptr %XTMModel, %XTMModel* %val4985, i64 0, i32 1
%val4987 = load float*, float** %val4986
; set tuple
%val4988 = getelementptr %XTMModel, %XTMModel* %val4984, i64 0, i32 1
store float* %val4987, float** %val4988
%val4991 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val4992 = getelementptr %XTMModel, %XTMModel* %val4991, i64 0, i32 2
%val4993 = load %XTMModel*, %XTMModel** %val4992
%val4994 = icmp eq %XTMModel* %val4993, null
br i1 %val4994, label %then4990, label %else4990

then4990:
%res4995 = call ccc i1 @impc_false()
store i1 %res4995, i1* %ifptr4990
br label %ifcont4990

else4990:
%res4996 = call ccc i1 @impc_true()
store i1 %res4996, i1* %ifptr4990
br label %ifcont4990

ifcont4990:
%ifres4997 = load i1, i1* %ifptr4990

br i1 %ifres4997, label %then4989, label %else4989

then4989:
%val4998 = load %XTMModel*, %XTMModel** %objPtr
%val4999 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5000 = getelementptr %XTMModel, %XTMModel* %val4999, i64 0, i32 2
%val5001 = load %XTMModel*, %XTMModel** %val5000

; apply closure 
%vval5002 = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}**, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}*** %hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpdPtr
%val5003 = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}*,{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}** %vval5002
%fPtr5004 = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}* %val5003, i32 0, i32 2
%ePtr5005 = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}* %val5003, i32 0, i32 1
%f5006 = load %XTMModel* (i8*, i8*, %XTMModel*)*, %XTMModel* (i8*, i8*, %XTMModel*)** %fPtr5004
%e5007 = load i8*, i8** %ePtr5005
%tzone5008 = load i8*, i8** %_impzPtr
%zone5009 = bitcast i8* %tzone5008 to %mzone*
%z5010 = bitcast %mzone* %zone5009 to i8*
%result5011 = tail call fastcc %XTMModel* %f5006(i8* %z5010, i8* %e5007, %XTMModel* %val5001)
; set tuple
%val5012 = getelementptr %XTMModel, %XTMModel* %val4998, i64 0, i32 2
store %XTMModel* %result5011, %XTMModel** %val5012
store %XTMModel* %result5011, %XTMModel** %ifptr4989
br label %ifcont4989

else4989:
br label %ifcont4989

ifcont4989:
%ifres5013 = load %XTMModel*, %XTMModel** %ifptr4989

%val5014 = load %XTMModel*, %XTMModel** %objPtr
%val5015 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5016 = getelementptr %XTMModel, %XTMModel* %val5015, i64 0, i32 3
%val5017 = load i32, i32* %val5016
; set tuple
%val5018 = getelementptr %XTMModel, %XTMModel* %val5014, i64 0, i32 3
store i32 %val5017, i32* %val5018
%val5021 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5022 = getelementptr %XTMModel, %XTMModel* %val5021, i64 0, i32 4
%val5023 = load %XTMModel*, %XTMModel** %val5022
%val5024 = icmp eq %XTMModel* %val5023, null
br i1 %val5024, label %then5020, label %else5020

then5020:
%res5025 = call ccc i1 @impc_false()
store i1 %res5025, i1* %ifptr5020
br label %ifcont5020

else5020:
%res5026 = call ccc i1 @impc_true()
store i1 %res5026, i1* %ifptr5020
br label %ifcont5020

ifcont5020:
%ifres5027 = load i1, i1* %ifptr5020

br i1 %ifres5027, label %then5019, label %else5019

then5019:
%val5028 = load %XTMModel*, %XTMModel** %objPtr
%val5029 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5030 = getelementptr %XTMModel, %XTMModel* %val5029, i64 0, i32 4
%val5031 = load %XTMModel*, %XTMModel** %val5030

; apply closure 
%vval5032 = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}**, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}*** %hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpdPtr
%val5033 = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}*,{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}** %vval5032
%fPtr5034 = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}* %val5033, i32 0, i32 2
%ePtr5035 = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}* %val5033, i32 0, i32 1
%f5036 = load %XTMModel* (i8*, i8*, %XTMModel*)*, %XTMModel* (i8*, i8*, %XTMModel*)** %fPtr5034
%e5037 = load i8*, i8** %ePtr5035
%tzone5038 = load i8*, i8** %_impzPtr
%zone5039 = bitcast i8* %tzone5038 to %mzone*
%z5040 = bitcast %mzone* %zone5039 to i8*
%result5041 = tail call fastcc %XTMModel* %f5036(i8* %z5040, i8* %e5037, %XTMModel* %val5031)
; set tuple
%val5042 = getelementptr %XTMModel, %XTMModel* %val5028, i64 0, i32 4
store %XTMModel* %result5041, %XTMModel** %val5042
store %XTMModel* %result5041, %XTMModel** %ifptr5019
br label %ifcont5019

else5019:
br label %ifcont5019

ifcont5019:
%ifres5043 = load %XTMModel*, %XTMModel** %ifptr5019

%val5044 = load %XTMModel*, %XTMModel** %objPtr
%val5045 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5046 = getelementptr %XTMModel, %XTMModel* %val5045, i64 0, i32 5
%val5047 = load i32, i32* %val5046
; set tuple
%val5048 = getelementptr %XTMModel, %XTMModel* %val5044, i64 0, i32 5
store i32 %val5047, i32* %val5048
%val5051 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5052 = getelementptr %XTMModel, %XTMModel* %val5051, i64 0, i32 6
%val5053 = load %XTMMesh*, %XTMMesh** %val5052
%val5054 = icmp eq %XTMMesh* %val5053, null
br i1 %val5054, label %then5050, label %else5050

then5050:
%res5055 = call ccc i1 @impc_false()
store i1 %res5055, i1* %ifptr5050
br label %ifcont5050

else5050:
%res5056 = call ccc i1 @impc_true()
store i1 %res5056, i1* %ifptr5050
br label %ifcont5050

ifcont5050:
%ifres5057 = load i1, i1* %ifptr5050

br i1 %ifres5057, label %then5049, label %else5049

then5049:
%val5058 = load %XTMModel*, %XTMModel** %objPtr
%val5059 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5060 = getelementptr %XTMModel, %XTMModel* %val5059, i64 0, i32 6
%val5061 = load %XTMMesh*, %XTMMesh** %val5060
%res5062 = call fastcc %XTMMesh* @hcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqXQ(%XTMMesh* %val5061)
; set tuple
%val5063 = getelementptr %XTMModel, %XTMModel* %val5058, i64 0, i32 6
store %XTMMesh* %res5062, %XTMMesh** %val5063
store %XTMMesh* %res5062, %XTMMesh** %ifptr5049
br label %ifcont5049

else5049:
br label %ifcont5049

ifcont5049:
%ifres5064 = load %XTMMesh*, %XTMMesh** %ifptr5049

%val5065 = load %XTMModel*, %XTMModel** %objPtr
ret %XTMModel* %val5065
}
@gsxtmgraphics-pipeline179 = hidden constant [94 x i8] c"hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}** @hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5087 = load i8*, i8** %_impzPtr
%zone5088 = bitcast i8* %tzone5087 to %mzone*

; let assign value to symbol hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd
%dat_hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd = call i8* @llvm_zone_malloc(%mzone* %zone5088, i64 8)
%hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpdPtr = bitcast i8* %dat_hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd to { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}***
%tzone5068 = load i8*, i8** %_impzPtr
%zone5069 = bitcast i8* %tzone5068 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5069)
; malloc closure structure
%clsptr5070 = call i8* @llvm_zone_malloc(%mzone* %zone5069, i64 24)
%closure5071 = bitcast i8* %clsptr5070 to { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}*

; malloc environment structure
%envptr5072 = call i8* @llvm_zone_malloc(%mzone* %zone5069, i64 8)
%environment5073 = bitcast i8* %envptr5072 to {{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}***}*

; malloc closure address table
%addytable5074 = call %clsvar* @new_address_table()
%var5075 = bitcast [41 x i8]* @gsxtmgraphics-pipeline177 to i8*
%var5076 = bitcast [49 x i8]* @gsxtmgraphics-pipeline178 to i8*
%addytable5077 = call %clsvar* @add_address_table(%mzone* %zone5069, i8* %var5075, i32 0, i8* %var5076, i32 3, %clsvar* %addytable5074)
%address-table5078 = bitcast %clsvar* %addytable5077 to i8*

; insert table, function and environment into closure struct
%closure.table5081 = getelementptr { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}, { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}* %closure5071, i32 0, i32 0
store i8* %address-table5078, i8** %closure.table5081
%closure.env5082 = getelementptr { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}, { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}* %closure5071, i32 0, i32 1
store i8* %envptr5072, i8** %closure.env5082
%closure.func5083 = getelementptr { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}, { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}* %closure5071, i32 0, i32 2
store %XTMModel* (i8*, i8*, %XTMModel*)* @hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd__4962, %XTMModel* (i8*, i8*, %XTMModel*)** %closure.func5083
%closure_size5084 = call i64 @llvm_zone_mark_size(%mzone* %zone5069)
call void @llvm_zone_ptr_set_size(i8* %clsptr5070, i64 %closure_size5084)
%wrapper_ptr5085 = call i8* @llvm_zone_malloc(%mzone* %zone5069, i64 8)
%closure_wrapper5086 = bitcast i8* %wrapper_ptr5085 to { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}**
store { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}* %closure5071, { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}** %closure_wrapper5086

; let value assignment
%hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd = select i1 true, { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}** %closure_wrapper5086, { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}** %closure_wrapper5086
store { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}** %hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd, { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}*** %hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpdPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd
%tmp_envptr5080 = getelementptr {{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}***}, {{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}***}* %environment5073, i32 0, i32 0
store {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}*** %hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpdPtr, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}**** %tmp_envptr5080


%val5089 = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}**, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}*** %hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpdPtr
ret {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}** %val5089
}


@hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}** @hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMModel* @hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd(%XTMModel* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %XTMModel*)*,  %XTMModel* (i8*, i8*, %XTMModel*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0)
ret %XTMModel* %result
}


define dllexport ccc %XTMModel* @hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd_native(%XTMModel* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %XTMModel*)*,  %XTMModel* (i8*, i8*, %XTMModel*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0)
ret %XTMModel* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5090 = bitcast [94 x i8]* @gsxtmgraphics-pipeline179 to i8*
call i32 (i8*, ...) @printf(i8* %var5090)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMModel*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %XTMModel*)*,  %XTMModel* (i8*, i8*, %XTMModel*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0)
%tmpres = bitcast %XTMModel* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMModel*}*
%arg_p_0 = getelementptr {%XTMModel*}, {%XTMModel*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMModel*, %XTMModel** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %XTMModel*)*,  %XTMModel* (i8*, i8*, %XTMModel*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline180 = hidden constant [35 x i8] c"hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ\00"
@gsxtmgraphics-pipeline181 = hidden constant [43 x i8] c"{i8*, i8*, void (i8*, i8*, %XTMModel*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ__5091(i8* %_impz,i8* %_impenv, %XTMModel* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5092 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %XTMModel*)*}***}*
%hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMModel*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMModel*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}***, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**** %hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr_

; setup arguments
%xPtr = alloca %XTMModel*
store %XTMModel* %x, %XTMModel** %xPtr

; promote local stack var allocations
%tzone5167 = load i8*, i8** %_impzPtr
%zone5168 = bitcast i8* %tzone5167 to %mzone*
%ifptr5151 = alloca i1
%ifptr5129 = alloca i1
%ifptr5107 = alloca i1
%ifptr5094 = alloca i1

%val5095 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5096 = getelementptr %XTMModel, %XTMModel* %val5095, i64 0, i32 0
%val5097 = load %String*, %String** %val5096
%val5098 = icmp eq %String* %val5097, null
br i1 %val5098, label %then5094, label %else5094

then5094:
%res5099 = call ccc i1 @impc_false()
store i1 %res5099, i1* %ifptr5094
br label %ifcont5094

else5094:
%res5100 = call ccc i1 @impc_true()
store i1 %res5100, i1* %ifptr5094
br label %ifcont5094

ifcont5094:
%ifres5101 = load i1, i1* %ifptr5094

br i1 %ifres5101, label %then5093, label %else5093

then5093:
%val5102 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5103 = getelementptr %XTMModel, %XTMModel* %val5102, i64 0, i32 0
%val5104 = load %String*, %String** %val5103
call fastcc void @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0(%String* %val5104)
br label %ifcont5093

else5093:
br label %ifcont5093

ifcont5093:
%val5108 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5109 = getelementptr %XTMModel, %XTMModel* %val5108, i64 0, i32 2
%val5110 = load %XTMModel*, %XTMModel** %val5109
%val5111 = icmp eq %XTMModel* %val5110, null
br i1 %val5111, label %then5107, label %else5107

then5107:
%res5112 = call ccc i1 @impc_false()
store i1 %res5112, i1* %ifptr5107
br label %ifcont5107

else5107:
%res5113 = call ccc i1 @impc_true()
store i1 %res5113, i1* %ifptr5107
br label %ifcont5107

ifcont5107:
%ifres5114 = load i1, i1* %ifptr5107

br i1 %ifres5114, label %then5106, label %else5106

then5106:
%val5115 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5116 = getelementptr %XTMModel, %XTMModel* %val5115, i64 0, i32 2
%val5117 = load %XTMModel*, %XTMModel** %val5116

; apply closure 
%vval5118 = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*** %hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr
%val5119 = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*,{i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %vval5118
%fPtr5120 = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %val5119, i32 0, i32 2
%ePtr5121 = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %val5119, i32 0, i32 1
%f5122 = load void (i8*, i8*, %XTMModel*)*, void (i8*, i8*, %XTMModel*)** %fPtr5120
%e5123 = load i8*, i8** %ePtr5121
%tzone5124 = load i8*, i8** %_impzPtr
%zone5125 = bitcast i8* %tzone5124 to %mzone*
%z5126 = bitcast %mzone* %zone5125 to i8*
tail call fastcc void %f5122(i8* %z5126, i8* %e5123, %XTMModel* %val5117)
br label %ifcont5106

else5106:
br label %ifcont5106

ifcont5106:
%val5130 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5131 = getelementptr %XTMModel, %XTMModel* %val5130, i64 0, i32 4
%val5132 = load %XTMModel*, %XTMModel** %val5131
%val5133 = icmp eq %XTMModel* %val5132, null
br i1 %val5133, label %then5129, label %else5129

then5129:
%res5134 = call ccc i1 @impc_false()
store i1 %res5134, i1* %ifptr5129
br label %ifcont5129

else5129:
%res5135 = call ccc i1 @impc_true()
store i1 %res5135, i1* %ifptr5129
br label %ifcont5129

ifcont5129:
%ifres5136 = load i1, i1* %ifptr5129

br i1 %ifres5136, label %then5128, label %else5128

then5128:
%val5137 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5138 = getelementptr %XTMModel, %XTMModel* %val5137, i64 0, i32 4
%val5139 = load %XTMModel*, %XTMModel** %val5138

; apply closure 
%vval5140 = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*** %hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr
%val5141 = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*,{i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %vval5140
%fPtr5142 = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %val5141, i32 0, i32 2
%ePtr5143 = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %val5141, i32 0, i32 1
%f5144 = load void (i8*, i8*, %XTMModel*)*, void (i8*, i8*, %XTMModel*)** %fPtr5142
%e5145 = load i8*, i8** %ePtr5143
%tzone5146 = load i8*, i8** %_impzPtr
%zone5147 = bitcast i8* %tzone5146 to %mzone*
%z5148 = bitcast %mzone* %zone5147 to i8*
tail call fastcc void %f5144(i8* %z5148, i8* %e5145, %XTMModel* %val5139)
br label %ifcont5128

else5128:
br label %ifcont5128

ifcont5128:
%val5152 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5153 = getelementptr %XTMModel, %XTMModel* %val5152, i64 0, i32 6
%val5154 = load %XTMMesh*, %XTMMesh** %val5153
%val5155 = icmp eq %XTMMesh* %val5154, null
br i1 %val5155, label %then5151, label %else5151

then5151:
%res5156 = call ccc i1 @impc_false()
store i1 %res5156, i1* %ifptr5151
br label %ifcont5151

else5151:
%res5157 = call ccc i1 @impc_true()
store i1 %res5157, i1* %ifptr5151
br label %ifcont5151

ifcont5151:
%ifres5158 = load i1, i1* %ifptr5151

br i1 %ifres5158, label %then5150, label %else5150

then5150:
%val5159 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5160 = getelementptr %XTMModel, %XTMModel* %val5159, i64 0, i32 6
%val5161 = load %XTMMesh*, %XTMMesh** %val5160
call fastcc void @hfree_adhoc_W3ZvaWQsWFRNTWVzaCpd(%XTMMesh* %val5161)
br label %ifcont5150

else5150:
br label %ifcont5150

ifcont5150:
%val5163 = load %XTMModel*, %XTMModel** %xPtr
%val5164 = bitcast %XTMModel* %val5163 to i8*
call ccc void @free(i8* %val5164)
ret void
}
@gsxtmgraphics-pipeline182 = hidden constant [88 x i8] c"hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** @hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5188 = load i8*, i8** %_impzPtr
%zone5189 = bitcast i8* %tzone5188 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ
%dat_hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ = call i8* @llvm_zone_malloc(%mzone* %zone5189, i64 8)
%hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ to { i8*, i8*, void (i8*, i8*, %XTMModel*)*}***
%tzone5169 = load i8*, i8** %_impzPtr
%zone5170 = bitcast i8* %tzone5169 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5170)
; malloc closure structure
%clsptr5171 = call i8* @llvm_zone_malloc(%mzone* %zone5170, i64 24)
%closure5172 = bitcast i8* %clsptr5171 to { i8*, i8*, void (i8*, i8*, %XTMModel*)*}*

; malloc environment structure
%envptr5173 = call i8* @llvm_zone_malloc(%mzone* %zone5170, i64 8)
%environment5174 = bitcast i8* %envptr5173 to {{i8*, i8*, void (i8*, i8*, %XTMModel*)*}***}*

; malloc closure address table
%addytable5175 = call %clsvar* @new_address_table()
%var5176 = bitcast [35 x i8]* @gsxtmgraphics-pipeline180 to i8*
%var5177 = bitcast [43 x i8]* @gsxtmgraphics-pipeline181 to i8*
%addytable5178 = call %clsvar* @add_address_table(%mzone* %zone5170, i8* %var5176, i32 0, i8* %var5177, i32 3, %clsvar* %addytable5175)
%address-table5179 = bitcast %clsvar* %addytable5178 to i8*

; insert table, function and environment into closure struct
%closure.table5182 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMModel*)*}, { i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure5172, i32 0, i32 0
store i8* %address-table5179, i8** %closure.table5182
%closure.env5183 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMModel*)*}, { i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure5172, i32 0, i32 1
store i8* %envptr5173, i8** %closure.env5183
%closure.func5184 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMModel*)*}, { i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure5172, i32 0, i32 2
store void (i8*, i8*, %XTMModel*)* @hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ__5091, void (i8*, i8*, %XTMModel*)** %closure.func5184
%closure_size5185 = call i64 @llvm_zone_mark_size(%mzone* %zone5170)
call void @llvm_zone_ptr_set_size(i8* %clsptr5171, i64 %closure_size5185)
%wrapper_ptr5186 = call i8* @llvm_zone_malloc(%mzone* %zone5170, i64 8)
%closure_wrapper5187 = bitcast i8* %wrapper_ptr5186 to { i8*, i8*, void (i8*, i8*, %XTMModel*)*}**
store { i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure5172, { i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure_wrapper5187

; let value assignment
%hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure_wrapper5187, { i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure_wrapper5187
store { i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ, { i8*, i8*, void (i8*, i8*, %XTMModel*)*}*** %hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ
%tmp_envptr5181 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMModel*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMModel*)*}***}* %environment5174, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*** %hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**** %tmp_envptr5181


%val5190 = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*** %hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr
ret {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %val5190
}


@hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** @hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ(%XTMModel* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*)*,  void (i8*, i8*, %XTMModel*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_native(%XTMModel* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*)*,  void (i8*, i8*, %XTMModel*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5191 = bitcast [88 x i8]* @gsxtmgraphics-pipeline182 to i8*
call i32 (i8*, ...) @printf(i8* %var5191)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMModel*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*)*,  void (i8*, i8*, %XTMModel*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMModel*}*
%arg_p_0 = getelementptr {%XTMModel*}, {%XTMModel*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMModel*, %XTMModel** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*)*,  void (i8*, i8*, %XTMModel*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline183 = hidden constant [60 x i8] c"zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0\00"
@gsxtmgraphics-pipeline184 = hidden constant [67 x i8] c"{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %XTMModel* @zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0__5192(i8* %_impz,i8* %_impenv, %XTMModel* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5193 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0Ptr_ = getelementptr {{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0Ptr = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}***, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0Ptr_

; setup arguments
%xPtr = alloca %XTMModel*
store %XTMModel* %x, %XTMModel** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val5195 = load %mzone*, %mzone** %fromzPtr
%val5196 = load %XTMModel*, %XTMModel** %xPtr
%val5197 = bitcast %XTMModel* %val5196 to i8*
%res5198 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val5195, i8* %val5197)
br i1 %res5198, label %then5194, label %else5194

then5194:
%val5199 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val5199)
%zone_ptr5200 = bitcast %mzone* %val5199 to i8*
store i8* %zone_ptr5200, i8** %_impzPtr
%tzone5206 = load i8*, i8** %_impzPtr
%zone5207 = bitcast i8* %tzone5206 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %XTMModel*
%tzone5202 = load i8*, i8** %_impzPtr
%zone5203 = bitcast i8* %tzone5202 to %mzone*
%dat5204 = call i8* @llvm_zone_malloc(%mzone* %zone5203, i64 56)
call i8* @memset(i8* %dat5204, i32 0, i64 56)
%val5205 = bitcast i8* %dat5204 to %XTMModel*

; let value assignment
%obj = select i1 true, %XTMModel* %val5205, %XTMModel* %val5205
store %XTMModel* %obj, %XTMModel** %objPtr

; promote local stack var allocations
%tzone5341 = load i8*, i8** %_impzPtr
%zone5342 = bitcast i8* %tzone5341 to %mzone*
%ifptr5319 = alloca %XTMMesh*
%ifptr5320 = alloca i1
%ifptr5287 = alloca %XTMModel*
%ifptr5288 = alloca i1
%ifptr5255 = alloca %XTMModel*
%ifptr5256 = alloca i1
%ifptr5226 = alloca float*
%ifptr5208 = alloca %String*
%ifptr5209 = alloca i1
%val5210 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5211 = getelementptr %XTMModel, %XTMModel* %val5210, i64 0, i32 0
%val5212 = load %String*, %String** %val5211
%val5213 = icmp eq %String* %val5212, null
br i1 %val5213, label %then5209, label %else5209

then5209:
%res5214 = call ccc i1 @impc_false()
store i1 %res5214, i1* %ifptr5209
br label %ifcont5209

else5209:
%res5215 = call ccc i1 @impc_true()
store i1 %res5215, i1* %ifptr5209
br label %ifcont5209

ifcont5209:
%ifres5216 = load i1, i1* %ifptr5209

br i1 %ifres5216, label %then5208, label %else5208

then5208:
%val5217 = load %XTMModel*, %XTMModel** %objPtr
%val5218 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5219 = getelementptr %XTMModel, %XTMModel* %val5218, i64 0, i32 0
%val5220 = load %String*, %String** %val5219
%val5221 = load %mzone*, %mzone** %fromzPtr
%val5222 = load %mzone*, %mzone** %tozPtr
%res5223 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val5220, %mzone* %val5221, %mzone* %val5222)
; set tuple
%val5224 = getelementptr %XTMModel, %XTMModel* %val5217, i64 0, i32 0
store %String* %res5223, %String** %val5224
store %String* %res5223, %String** %ifptr5208
br label %ifcont5208

else5208:
br label %ifcont5208

ifcont5208:
%ifres5225 = load %String*, %String** %ifptr5208

%val5227 = load %mzone*, %mzone** %fromzPtr
%val5228 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5229 = getelementptr %XTMModel, %XTMModel* %val5228, i64 0, i32 1
%val5230 = load float*, float** %val5229
%val5231 = bitcast float* %val5230 to i8*
%res5232 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val5227, i8* %val5231)
br i1 %res5232, label %then5226, label %else5226

then5226:
%tzone5237 = load i8*, i8** %_impzPtr
%zone5238 = bitcast i8* %tzone5237 to %mzone*

; let assign value to symbol newptr
%newptrPtr = alloca float*
%tzone5233 = load i8*, i8** %_impzPtr
%zone5234 = bitcast i8* %tzone5233 to %mzone*
%dat5235 = call i8* @llvm_zone_malloc(%mzone* %zone5234, i64 4)
call i8* @memset(i8* %dat5235, i32 0, i64 4)
%val5236 = bitcast i8* %dat5235 to float*

; let value assignment
%newptr = select i1 true, float* %val5236, float* %val5236
store float* %newptr, float** %newptrPtr

%val5239 = load float*, float** %newptrPtr
%val5240 = bitcast float* %val5239 to i8*
%val5241 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5242 = getelementptr %XTMModel, %XTMModel* %val5241, i64 0, i32 1
%val5243 = load float*, float** %val5242
%val5244 = bitcast float* %val5243 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val5240, i8* %val5244, i64 4, i32 1, i1 0)
%val5246 = load %XTMModel*, %XTMModel** %objPtr
%val5247 = load float*, float** %newptrPtr
; set tuple
%val5248 = getelementptr %XTMModel, %XTMModel* %val5246, i64 0, i32 1
store float* %val5247, float** %val5248
store float* %val5247, float** %ifptr5226
br label %ifcont5226

else5226:
%val5249 = load %XTMModel*, %XTMModel** %objPtr
%val5250 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5251 = getelementptr %XTMModel, %XTMModel* %val5250, i64 0, i32 1
%val5252 = load float*, float** %val5251
; set tuple
%val5253 = getelementptr %XTMModel, %XTMModel* %val5249, i64 0, i32 1
store float* %val5252, float** %val5253
store float* %val5252, float** %ifptr5226
br label %ifcont5226

ifcont5226:
%ifres5254 = load float*, float** %ifptr5226

%val5257 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5258 = getelementptr %XTMModel, %XTMModel* %val5257, i64 0, i32 2
%val5259 = load %XTMModel*, %XTMModel** %val5258
%val5260 = icmp eq %XTMModel* %val5259, null
br i1 %val5260, label %then5256, label %else5256

then5256:
%res5261 = call ccc i1 @impc_false()
store i1 %res5261, i1* %ifptr5256
br label %ifcont5256

else5256:
%res5262 = call ccc i1 @impc_true()
store i1 %res5262, i1* %ifptr5256
br label %ifcont5256

ifcont5256:
%ifres5263 = load i1, i1* %ifptr5256

br i1 %ifres5263, label %then5255, label %else5255

then5255:
%val5264 = load %XTMModel*, %XTMModel** %objPtr
%val5265 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5266 = getelementptr %XTMModel, %XTMModel* %val5265, i64 0, i32 2
%val5267 = load %XTMModel*, %XTMModel** %val5266
%val5268 = load %mzone*, %mzone** %fromzPtr
%val5269 = load %mzone*, %mzone** %tozPtr

; apply closure 
%vval5270 = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}**, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0Ptr
%val5271 = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}*,{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}** %vval5270
%fPtr5272 = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}* %val5271, i32 0, i32 2
%ePtr5273 = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}* %val5271, i32 0, i32 1
%f5274 = load %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)** %fPtr5272
%e5275 = load i8*, i8** %ePtr5273
%tzone5276 = load i8*, i8** %_impzPtr
%zone5277 = bitcast i8* %tzone5276 to %mzone*
%z5278 = bitcast %mzone* %zone5277 to i8*
%result5279 = tail call fastcc %XTMModel* %f5274(i8* %z5278, i8* %e5275, %XTMModel* %val5267, %mzone* %val5268, %mzone* %val5269)
; set tuple
%val5280 = getelementptr %XTMModel, %XTMModel* %val5264, i64 0, i32 2
store %XTMModel* %result5279, %XTMModel** %val5280
store %XTMModel* %result5279, %XTMModel** %ifptr5255
br label %ifcont5255

else5255:
br label %ifcont5255

ifcont5255:
%ifres5281 = load %XTMModel*, %XTMModel** %ifptr5255

%val5282 = load %XTMModel*, %XTMModel** %objPtr
%val5283 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5284 = getelementptr %XTMModel, %XTMModel* %val5283, i64 0, i32 3
%val5285 = load i32, i32* %val5284
; set tuple
%val5286 = getelementptr %XTMModel, %XTMModel* %val5282, i64 0, i32 3
store i32 %val5285, i32* %val5286
%val5289 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5290 = getelementptr %XTMModel, %XTMModel* %val5289, i64 0, i32 4
%val5291 = load %XTMModel*, %XTMModel** %val5290
%val5292 = icmp eq %XTMModel* %val5291, null
br i1 %val5292, label %then5288, label %else5288

then5288:
%res5293 = call ccc i1 @impc_false()
store i1 %res5293, i1* %ifptr5288
br label %ifcont5288

else5288:
%res5294 = call ccc i1 @impc_true()
store i1 %res5294, i1* %ifptr5288
br label %ifcont5288

ifcont5288:
%ifres5295 = load i1, i1* %ifptr5288

br i1 %ifres5295, label %then5287, label %else5287

then5287:
%val5296 = load %XTMModel*, %XTMModel** %objPtr
%val5297 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5298 = getelementptr %XTMModel, %XTMModel* %val5297, i64 0, i32 4
%val5299 = load %XTMModel*, %XTMModel** %val5298
%val5300 = load %mzone*, %mzone** %fromzPtr
%val5301 = load %mzone*, %mzone** %tozPtr

; apply closure 
%vval5302 = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}**, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0Ptr
%val5303 = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}*,{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}** %vval5302
%fPtr5304 = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}* %val5303, i32 0, i32 2
%ePtr5305 = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}* %val5303, i32 0, i32 1
%f5306 = load %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)** %fPtr5304
%e5307 = load i8*, i8** %ePtr5305
%tzone5308 = load i8*, i8** %_impzPtr
%zone5309 = bitcast i8* %tzone5308 to %mzone*
%z5310 = bitcast %mzone* %zone5309 to i8*
%result5311 = tail call fastcc %XTMModel* %f5306(i8* %z5310, i8* %e5307, %XTMModel* %val5299, %mzone* %val5300, %mzone* %val5301)
; set tuple
%val5312 = getelementptr %XTMModel, %XTMModel* %val5296, i64 0, i32 4
store %XTMModel* %result5311, %XTMModel** %val5312
store %XTMModel* %result5311, %XTMModel** %ifptr5287
br label %ifcont5287

else5287:
br label %ifcont5287

ifcont5287:
%ifres5313 = load %XTMModel*, %XTMModel** %ifptr5287

%val5314 = load %XTMModel*, %XTMModel** %objPtr
%val5315 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5316 = getelementptr %XTMModel, %XTMModel* %val5315, i64 0, i32 5
%val5317 = load i32, i32* %val5316
; set tuple
%val5318 = getelementptr %XTMModel, %XTMModel* %val5314, i64 0, i32 5
store i32 %val5317, i32* %val5318
%val5321 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5322 = getelementptr %XTMModel, %XTMModel* %val5321, i64 0, i32 6
%val5323 = load %XTMMesh*, %XTMMesh** %val5322
%val5324 = icmp eq %XTMMesh* %val5323, null
br i1 %val5324, label %then5320, label %else5320

then5320:
%res5325 = call ccc i1 @impc_false()
store i1 %res5325, i1* %ifptr5320
br label %ifcont5320

else5320:
%res5326 = call ccc i1 @impc_true()
store i1 %res5326, i1* %ifptr5320
br label %ifcont5320

ifcont5320:
%ifres5327 = load i1, i1* %ifptr5320

br i1 %ifres5327, label %then5319, label %else5319

then5319:
%val5328 = load %XTMModel*, %XTMModel** %objPtr
%val5329 = load %XTMModel*, %XTMModel** %xPtr
; tuple ref
%val5330 = getelementptr %XTMModel, %XTMModel* %val5329, i64 0, i32 6
%val5331 = load %XTMMesh*, %XTMMesh** %val5330
%val5332 = load %mzone*, %mzone** %fromzPtr
%val5333 = load %mzone*, %mzone** %tozPtr
%res5334 = call fastcc %XTMMesh* @zcopy_adhoc_W1hUTU1lc2gqLFhUTU1lc2gqLG16b25lKixtem9uZSpd(%XTMMesh* %val5331, %mzone* %val5332, %mzone* %val5333)
; set tuple
%val5335 = getelementptr %XTMModel, %XTMModel* %val5328, i64 0, i32 6
store %XTMMesh* %res5334, %XTMMesh** %val5335
store %XTMMesh* %res5334, %XTMMesh** %ifptr5319
br label %ifcont5319

else5319:
br label %ifcont5319

ifcont5319:
%ifres5336 = load %XTMMesh*, %XTMMesh** %ifptr5319

%oldzone5337 = call %mzone* @llvm_pop_zone_stack()
%newzone5338 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr5339 = bitcast %mzone* %newzone5338 to i8*
store i8* %zone_ptr5339, i8** %_impzPtr
%val5340 = load %XTMModel*, %XTMModel** %objPtr
ret %XTMModel* %val5340

else5194:
%val5343 = load %XTMModel*, %XTMModel** %xPtr
ret %XTMModel* %val5343
}
@gsxtmgraphics-pipeline185 = hidden constant [113 x i8] c"zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5363 = load i8*, i8** %_impzPtr
%zone5364 = bitcast i8* %tzone5363 to %mzone*

; let assign value to symbol zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0
%dat_zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone5364, i64 8)
%zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0Ptr = bitcast i8* %dat_zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0 to { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}***
%tzone5344 = load i8*, i8** %_impzPtr
%zone5345 = bitcast i8* %tzone5344 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5345)
; malloc closure structure
%clsptr5346 = call i8* @llvm_zone_malloc(%mzone* %zone5345, i64 24)
%closure5347 = bitcast i8* %clsptr5346 to { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr5348 = call i8* @llvm_zone_malloc(%mzone* %zone5345, i64 8)
%environment5349 = bitcast i8* %envptr5348 to {{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable5350 = call %clsvar* @new_address_table()
%var5351 = bitcast [60 x i8]* @gsxtmgraphics-pipeline183 to i8*
%var5352 = bitcast [67 x i8]* @gsxtmgraphics-pipeline184 to i8*
%addytable5353 = call %clsvar* @add_address_table(%mzone* %zone5345, i8* %var5351, i32 0, i8* %var5352, i32 3, %clsvar* %addytable5350)
%address-table5354 = bitcast %clsvar* %addytable5353 to i8*

; insert table, function and environment into closure struct
%closure.table5357 = getelementptr { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}, { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}* %closure5347, i32 0, i32 0
store i8* %address-table5354, i8** %closure.table5357
%closure.env5358 = getelementptr { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}, { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}* %closure5347, i32 0, i32 1
store i8* %envptr5348, i8** %closure.env5358
%closure.func5359 = getelementptr { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}, { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}* %closure5347, i32 0, i32 2
store %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)* @zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0__5192, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)** %closure.func5359
%closure_size5360 = call i64 @llvm_zone_mark_size(%mzone* %zone5345)
call void @llvm_zone_ptr_set_size(i8* %clsptr5346, i64 %closure_size5360)
%wrapper_ptr5361 = call i8* @llvm_zone_malloc(%mzone* %zone5345, i64 8)
%closure_wrapper5362 = bitcast i8* %wrapper_ptr5361 to { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}**
store { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}* %closure5347, { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}** %closure_wrapper5362

; let value assignment
%zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0 = select i1 true, { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}** %closure_wrapper5362, { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}** %closure_wrapper5362
store { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0, { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0Ptr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0
%tmp_envptr5356 = getelementptr {{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}***}* %environment5349, i32 0, i32 0
store {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0Ptr, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}**** %tmp_envptr5356


%val5365 = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}**, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0Ptr
ret {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}** %val5365
}


@zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMModel* @zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0(%XTMModel* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*,  %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %XTMModel* %result
}


define dllexport ccc %XTMModel* @zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0_native(%XTMModel* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*,  %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %XTMModel* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5366 = bitcast [113 x i8]* @gsxtmgraphics-pipeline185 to i8*
call i32 (i8*, ...) @printf(i8* %var5366)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMModel*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5367 = bitcast [113 x i8]* @gsxtmgraphics-pipeline185 to i8*
call i32 (i8*, ...) @printf(i8* %var5367)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5368 = bitcast [113 x i8]* @gsxtmgraphics-pipeline185 to i8*
call i32 (i8*, ...) @printf(i8* %var5368)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*,  %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %XTMModel* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMModel*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%XTMModel*, %mzone*, %mzone*}, {%XTMModel*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMModel*, %XTMModel** %arg_p_0
%arg_p_1 = getelementptr {%XTMModel*, %mzone*, %mzone*}, {%XTMModel*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%XTMModel*, %mzone*, %mzone*}, {%XTMModel*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)*,  %XTMModel* (i8*, i8*, %XTMModel*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline186 = hidden constant [16 x i8] c"<XTMModel:null>\00"
@gsxtmgraphics-pipeline187 = hidden constant [7 x i8] c"<null>\00"
@gsxtmgraphics-pipeline188 = hidden constant [25 x i8] c"
======= model =========\00"
@gsxtmgraphics-pipeline189 = hidden constant [12 x i8] c"
name    : \00"
@gsxtmgraphics-pipeline190 = hidden constant [12 x i8] c"
parent  : \00"
@gsxtmgraphics-pipeline191 = hidden constant [12 x i8] c"
children: \00"
@gsxtmgraphics-pipeline192 = hidden constant [12 x i8] c"
meshes  : \00"
@gsxtmgraphics-pipeline193 = hidden constant [44 x i8] c"print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ\00"
define dllexport fastcc void @print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ__5369(i8* %_impz,i8* %_impenv, %XTMModel* %model) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5370 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %XTMModel*)*}***}*
%print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMModel*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMModel*)*}***}* %impenv, i32 0, i32 0
%print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}***, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**** %print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr_

; setup arguments
%modelPtr = alloca %XTMModel*
store %XTMModel* %model, %XTMModel** %modelPtr

; promote local stack var allocations
%tzone5483 = load i8*, i8** %_impzPtr
%zone5484 = bitcast i8* %tzone5483 to %mzone*
%ifptr5390 = alloca %String*

%val5372 = load %XTMModel*, %XTMModel** %modelPtr
%val5373 = icmp eq %XTMModel* %val5372, null
br i1 %val5373, label %then5371, label %else5371

then5371:
%var5374 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var5375 = bitcast [16 x i8]* @gsxtmgraphics-pipeline186 to i8*

%val5376 = call i32 (i8*, ...) @printf(i8* %var5374, i8* %var5375)
call fastcc void @print_return_adhoc_W3ZvaWRd()
ret void

else5371:
%tzone5378 = load i8*, i8** %_impzPtr
%zone5379 = bitcast i8* %tzone5378 to %mzone*

; let assign value to symbol i
%iPtr = alloca i32
%tzone5383 = load i8*, i8** %_impzPtr
%zone5384 = bitcast i8* %tzone5383 to %mzone*

; let assign value to symbol name_s_21
%name_s_21Ptr = alloca %String*
%tzone5388 = load i8*, i8** %_impzPtr
%zone5389 = bitcast i8* %tzone5388 to %mzone*

; let assign value to symbol parent
%parentPtr = alloca %XTMModel*
%tzone5399 = load i8*, i8** %_impzPtr
%zone5400 = bitcast i8* %tzone5399 to %mzone*

; let assign value to symbol parent_name
%parent_namePtr = alloca %String*
%tzone5404 = load i8*, i8** %_impzPtr
%zone5405 = bitcast i8* %tzone5404 to %mzone*

; let assign value to symbol num_children
%num_childrenPtr = alloca i32
%tzone5409 = load i8*, i8** %_impzPtr
%zone5410 = bitcast i8* %tzone5409 to %mzone*

; let assign value to symbol children
%childrenPtr = alloca %XTMModel*
%tzone5414 = load i8*, i8** %_impzPtr
%zone5415 = bitcast i8* %tzone5414 to %mzone*

; let assign value to symbol num_meshes
%num_meshesPtr = alloca i32
%tzone5419 = load i8*, i8** %_impzPtr
%zone5420 = bitcast i8* %tzone5419 to %mzone*

; let assign value to symbol meshes
%meshesPtr = alloca %XTMMesh*

; let value assignment
%i = select i1 true, i32 0, i32 0
store i32 %i, i32* %iPtr

%val5380 = load %XTMModel*, %XTMModel** %modelPtr
; tuple ref
%val5381 = getelementptr %XTMModel, %XTMModel* %val5380, i64 0, i32 0
%val5382 = load %String*, %String** %val5381

; let value assignment
%name_s_21 = select i1 true, %String* %val5382, %String* %val5382
store %String* %name_s_21, %String** %name_s_21Ptr

%val5385 = load %XTMModel*, %XTMModel** %modelPtr
; tuple ref
%val5386 = getelementptr %XTMModel, %XTMModel* %val5385, i64 0, i32 2
%val5387 = load %XTMModel*, %XTMModel** %val5386

; let value assignment
%parent = select i1 true, %XTMModel* %val5387, %XTMModel* %val5387
store %XTMModel* %parent, %XTMModel** %parentPtr

%val5391 = load %XTMModel*, %XTMModel** %parentPtr
%val5392 = icmp eq %XTMModel* %val5391, null
br i1 %val5392, label %then5390, label %else5390

then5390:
%var5393 = bitcast [7 x i8]* @gsxtmgraphics-pipeline187 to i8*
%res5394 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %var5393)
store %String* %res5394, %String** %ifptr5390
br label %ifcont5390

else5390:
%val5395 = load %XTMModel*, %XTMModel** %parentPtr
; tuple ref
%val5396 = getelementptr %XTMModel, %XTMModel* %val5395, i64 0, i32 0
%val5397 = load %String*, %String** %val5396
store %String* %val5397, %String** %ifptr5390
br label %ifcont5390

ifcont5390:
%ifres5398 = load %String*, %String** %ifptr5390


; let value assignment
%parent_name = select i1 true, %String* %ifres5398, %String* %ifres5398
store %String* %parent_name, %String** %parent_namePtr

%val5401 = load %XTMModel*, %XTMModel** %modelPtr
; tuple ref
%val5402 = getelementptr %XTMModel, %XTMModel* %val5401, i64 0, i32 3
%val5403 = load i32, i32* %val5402

; let value assignment
%num_children = select i1 true, i32 %val5403, i32 %val5403
store i32 %num_children, i32* %num_childrenPtr

%val5406 = load %XTMModel*, %XTMModel** %modelPtr
; tuple ref
%val5407 = getelementptr %XTMModel, %XTMModel* %val5406, i64 0, i32 4
%val5408 = load %XTMModel*, %XTMModel** %val5407

; let value assignment
%children = select i1 true, %XTMModel* %val5408, %XTMModel* %val5408
store %XTMModel* %children, %XTMModel** %childrenPtr

%val5411 = load %XTMModel*, %XTMModel** %modelPtr
; tuple ref
%val5412 = getelementptr %XTMModel, %XTMModel* %val5411, i64 0, i32 5
%val5413 = load i32, i32* %val5412

; let value assignment
%num_meshes = select i1 true, i32 %val5413, i32 %val5413
store i32 %num_meshes, i32* %num_meshesPtr

%val5416 = load %XTMModel*, %XTMModel** %modelPtr
; tuple ref
%val5417 = getelementptr %XTMModel, %XTMModel* %val5416, i64 0, i32 6
%val5418 = load %XTMMesh*, %XTMMesh** %val5417

; let value assignment
%meshes = select i1 true, %XTMMesh* %val5418, %XTMMesh* %val5418
store %XTMMesh* %meshes, %XTMMesh** %meshesPtr

%var5421 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var5422 = bitcast [25 x i8]* @gsxtmgraphics-pipeline188 to i8*

%val5423 = call i32 (i8*, ...) @printf(i8* %var5421, i8* %var5422)
%var5425 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var5426 = bitcast [12 x i8]* @gsxtmgraphics-pipeline189 to i8*

%val5427 = call i32 (i8*, ...) @printf(i8* %var5425, i8* %var5426)
%val5428 = load %String*, %String** %name_s_21Ptr
call fastcc void @print_adhoc_W3ZvaWQsU3RyaW5nKl0(%String* %val5428)
%var5431 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var5432 = bitcast [12 x i8]* @gsxtmgraphics-pipeline190 to i8*

%val5433 = call i32 (i8*, ...) @printf(i8* %var5431, i8* %var5432)
%val5434 = load %String*, %String** %parent_namePtr
call fastcc void @print_adhoc_W3ZvaWQsU3RyaW5nKl0(%String* %val5434)
%var5437 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var5438 = bitcast [12 x i8]* @gsxtmgraphics-pipeline191 to i8*

%val5439 = call i32 (i8*, ...) @printf(i8* %var5437, i8* %var5438)
%val5440 = load i32, i32* %num_childrenPtr
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val5440)
%var5443 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var5444 = bitcast [12 x i8]* @gsxtmgraphics-pipeline192 to i8*

%val5445 = call i32 (i8*, ...) @printf(i8* %var5443, i8* %var5444)
%val5446 = load i32, i32* %num_meshesPtr
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val5446)
call fastcc void @print_return_adhoc_W3ZvaWRd()
; setup loop
%val5452 = load i32, i32* %num_meshesPtr
store i32 0, i32* %iPtr
%val5458 = load i32, i32* %iPtr
%num5459 = add i32 %val5452, %val5458
%comp5460 = icmp ult i32 %val5452, 1
br i1 %comp5460, label %after5450, label %loop5450

loop5450:
%val5453 = load i32, i32* %iPtr
%val5454 = load %XTMMesh*, %XTMMesh** %meshesPtr
; pointer ref
%val5455 = getelementptr %XTMMesh, %XTMMesh* %val5454, i32 %val5453
call fastcc void @print_adhoc_W3ZvaWQsWFRNTWVzaCpd(%XTMMesh* %val5455)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%loop_cnt5450 = load i32, i32* %iPtr
%next5450 = add i32 %loop_cnt5450, 1
store i32 %next5450, i32* %iPtr
%cmp5450 = icmp ult i32 %next5450, %num5459
br i1 %cmp5450, label %loop5450, label %after5450

after5450:
; setup loop
%val5464 = load i32, i32* %num_childrenPtr
store i32 0, i32* %iPtr
%val5478 = load i32, i32* %iPtr
%num5479 = add i32 %val5464, %val5478
%comp5480 = icmp ult i32 %val5464, 1
br i1 %comp5480, label %after5462, label %loop5462

loop5462:
%val5465 = load i32, i32* %iPtr
%val5466 = load %XTMModel*, %XTMModel** %childrenPtr
; pointer ref
%val5467 = getelementptr %XTMModel, %XTMModel* %val5466, i32 %val5465

; apply closure 
%vval5468 = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*** %print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr
%val5469 = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*,{i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %vval5468
%fPtr5470 = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %val5469, i32 0, i32 2
%ePtr5471 = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %val5469, i32 0, i32 1
%f5472 = load void (i8*, i8*, %XTMModel*)*, void (i8*, i8*, %XTMModel*)** %fPtr5470
%e5473 = load i8*, i8** %ePtr5471
%tzone5474 = load i8*, i8** %_impzPtr
%zone5475 = bitcast i8* %tzone5474 to %mzone*
%z5476 = bitcast %mzone* %zone5475 to i8*
tail call fastcc void %f5472(i8* %z5476, i8* %e5473, %XTMModel* %val5467)
%loop_cnt5462 = load i32, i32* %iPtr
%next5462 = add i32 %loop_cnt5462, 1
store i32 %next5462, i32* %iPtr
%cmp5462 = icmp ult i32 %next5462, %num5479
br i1 %cmp5462, label %loop5462, label %after5462

after5462:
ret void
}
@gsxtmgraphics-pipeline194 = hidden constant [97 x i8] c"print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** @print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5504 = load i8*, i8** %_impzPtr
%zone5505 = bitcast i8* %tzone5504 to %mzone*

; let assign value to symbol print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ
%dat_print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ = call i8* @llvm_zone_malloc(%mzone* %zone5505, i64 8)
%print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr = bitcast i8* %dat_print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ to { i8*, i8*, void (i8*, i8*, %XTMModel*)*}***
%tzone5485 = load i8*, i8** %_impzPtr
%zone5486 = bitcast i8* %tzone5485 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5486)
; malloc closure structure
%clsptr5487 = call i8* @llvm_zone_malloc(%mzone* %zone5486, i64 24)
%closure5488 = bitcast i8* %clsptr5487 to { i8*, i8*, void (i8*, i8*, %XTMModel*)*}*

; malloc environment structure
%envptr5489 = call i8* @llvm_zone_malloc(%mzone* %zone5486, i64 8)
%environment5490 = bitcast i8* %envptr5489 to {{i8*, i8*, void (i8*, i8*, %XTMModel*)*}***}*

; malloc closure address table
%addytable5491 = call %clsvar* @new_address_table()
%var5492 = bitcast [44 x i8]* @gsxtmgraphics-pipeline193 to i8*
%var5493 = bitcast [43 x i8]* @gsxtmgraphics-pipeline181 to i8*
%addytable5494 = call %clsvar* @add_address_table(%mzone* %zone5486, i8* %var5492, i32 0, i8* %var5493, i32 3, %clsvar* %addytable5491)
%address-table5495 = bitcast %clsvar* %addytable5494 to i8*

; insert table, function and environment into closure struct
%closure.table5498 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMModel*)*}, { i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure5488, i32 0, i32 0
store i8* %address-table5495, i8** %closure.table5498
%closure.env5499 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMModel*)*}, { i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure5488, i32 0, i32 1
store i8* %envptr5489, i8** %closure.env5499
%closure.func5500 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMModel*)*}, { i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure5488, i32 0, i32 2
store void (i8*, i8*, %XTMModel*)* @print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ__5369, void (i8*, i8*, %XTMModel*)** %closure.func5500
%closure_size5501 = call i64 @llvm_zone_mark_size(%mzone* %zone5486)
call void @llvm_zone_ptr_set_size(i8* %clsptr5487, i64 %closure_size5501)
%wrapper_ptr5502 = call i8* @llvm_zone_malloc(%mzone* %zone5486, i64 8)
%closure_wrapper5503 = bitcast i8* %wrapper_ptr5502 to { i8*, i8*, void (i8*, i8*, %XTMModel*)*}**
store { i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure5488, { i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure_wrapper5503

; let value assignment
%print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure_wrapper5503, { i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure_wrapper5503
store { i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ, { i8*, i8*, void (i8*, i8*, %XTMModel*)*}*** %print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr

; add data to environment
; don't need to alloc for env var print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ
%tmp_envptr5497 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMModel*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMModel*)*}***}* %environment5490, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*** %print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**** %tmp_envptr5497


%val5506 = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*** %print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr
ret {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %val5506
}


@print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** @print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ(%XTMModel* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*)*,  void (i8*, i8*, %XTMModel*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0)
ret void
}


define dllexport ccc void @print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_native(%XTMModel* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*)*,  void (i8*, i8*, %XTMModel*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0)
ret void
}


define dllexport ccc i8*  @print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5507 = bitcast [97 x i8]* @gsxtmgraphics-pipeline194 to i8*
call i32 (i8*, ...) @printf(i8* %var5507)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMModel*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*)*,  void (i8*, i8*, %XTMModel*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMModel*}*
%arg_p_0 = getelementptr {%XTMModel*}, {%XTMModel*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMModel*, %XTMModel** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*)*,  void (i8*, i8*, %XTMModel*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline195 = hidden constant [35 x i8] c"print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ__5508(i8* %_impz,i8* %_impenv, %XTMModel* %model) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5509 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %XTMModel*)*}***}*
%print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMModel*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMModel*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}***, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**** %print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr_

; setup arguments
%modelPtr = alloca %XTMModel*
store %XTMModel* %model, %XTMModel** %modelPtr


%val5510 = load %XTMModel*, %XTMModel** %modelPtr
call fastcc void @print_xtmmodel_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ(%XTMModel* %val5510)
ret void
}
@gsxtmgraphics-pipeline196 = hidden constant [88 x i8] c"print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** @print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5531 = load i8*, i8** %_impzPtr
%zone5532 = bitcast i8* %tzone5531 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ
%dat_print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ = call i8* @llvm_zone_malloc(%mzone* %zone5532, i64 8)
%print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ to { i8*, i8*, void (i8*, i8*, %XTMModel*)*}***
%tzone5512 = load i8*, i8** %_impzPtr
%zone5513 = bitcast i8* %tzone5512 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5513)
; malloc closure structure
%clsptr5514 = call i8* @llvm_zone_malloc(%mzone* %zone5513, i64 24)
%closure5515 = bitcast i8* %clsptr5514 to { i8*, i8*, void (i8*, i8*, %XTMModel*)*}*

; malloc environment structure
%envptr5516 = call i8* @llvm_zone_malloc(%mzone* %zone5513, i64 8)
%environment5517 = bitcast i8* %envptr5516 to {{i8*, i8*, void (i8*, i8*, %XTMModel*)*}***}*

; malloc closure address table
%addytable5518 = call %clsvar* @new_address_table()
%var5519 = bitcast [35 x i8]* @gsxtmgraphics-pipeline195 to i8*
%var5520 = bitcast [43 x i8]* @gsxtmgraphics-pipeline181 to i8*
%addytable5521 = call %clsvar* @add_address_table(%mzone* %zone5513, i8* %var5519, i32 0, i8* %var5520, i32 3, %clsvar* %addytable5518)
%address-table5522 = bitcast %clsvar* %addytable5521 to i8*

; insert table, function and environment into closure struct
%closure.table5525 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMModel*)*}, { i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure5515, i32 0, i32 0
store i8* %address-table5522, i8** %closure.table5525
%closure.env5526 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMModel*)*}, { i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure5515, i32 0, i32 1
store i8* %envptr5516, i8** %closure.env5526
%closure.func5527 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMModel*)*}, { i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure5515, i32 0, i32 2
store void (i8*, i8*, %XTMModel*)* @print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ__5508, void (i8*, i8*, %XTMModel*)** %closure.func5527
%closure_size5528 = call i64 @llvm_zone_mark_size(%mzone* %zone5513)
call void @llvm_zone_ptr_set_size(i8* %clsptr5514, i64 %closure_size5528)
%wrapper_ptr5529 = call i8* @llvm_zone_malloc(%mzone* %zone5513, i64 8)
%closure_wrapper5530 = bitcast i8* %wrapper_ptr5529 to { i8*, i8*, void (i8*, i8*, %XTMModel*)*}**
store { i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure5515, { i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure_wrapper5530

; let value assignment
%print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure_wrapper5530, { i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure_wrapper5530
store { i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ, { i8*, i8*, void (i8*, i8*, %XTMModel*)*}*** %print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ
%tmp_envptr5524 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMModel*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMModel*)*}***}* %environment5517, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*** %print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**** %tmp_envptr5524


%val5533 = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*** %print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQPtr
ret {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %val5533
}


@print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** @print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ(%XTMModel* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*)*,  void (i8*, i8*, %XTMModel*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_native(%XTMModel* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*)*,  void (i8*, i8*, %XTMModel*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5534 = bitcast [88 x i8]* @gsxtmgraphics-pipeline196 to i8*
call i32 (i8*, ...) @printf(i8* %var5534)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMModel*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*)*,  void (i8*, i8*, %XTMModel*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMModel*}*
%arg_p_0 = getelementptr {%XTMModel*}, {%XTMModel*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMModel*, %XTMModel** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsWFRNTW9kZWwqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*)*,  void (i8*, i8*, %XTMModel*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline197 = hidden constant [57 x i8] c"xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ\00"
@gsxtmgraphics-pipeline198 = hidden constant [54 x i8] c"{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}**\00"
define dllexport fastcc %XTMModel* @xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ__5535(i8* %_impz,i8* %_impenv, %XTMModel* %model, i32 %idx) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5536 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}***}*
%xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQPtr_ = getelementptr {{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}***}, {{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}***}* %impenv, i32 0, i32 0
%xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQPtr = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}***, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}**** %xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQPtr_

; setup arguments
%modelPtr = alloca %XTMModel*
store %XTMModel* %model, %XTMModel** %modelPtr
%idxPtr = alloca i32
store i32 %idx, i32* %idxPtr


%tzone5540 = load i8*, i8** %_impzPtr
%zone5541 = bitcast i8* %tzone5540 to %mzone*

; let assign value to symbol num_children
%num_childrenPtr = alloca i32
%tzone5545 = load i8*, i8** %_impzPtr
%zone5546 = bitcast i8* %tzone5545 to %mzone*

; let assign value to symbol models
%modelsPtr = alloca %XTMModel*
%val5537 = load %XTMModel*, %XTMModel** %modelPtr
; tuple ref
%val5538 = getelementptr %XTMModel, %XTMModel* %val5537, i64 0, i32 3
%val5539 = load i32, i32* %val5538

; let value assignment
%num_children = select i1 true, i32 %val5539, i32 %val5539
store i32 %num_children, i32* %num_childrenPtr

%val5542 = load %XTMModel*, %XTMModel** %modelPtr
; tuple ref
%val5543 = getelementptr %XTMModel, %XTMModel* %val5542, i64 0, i32 4
%val5544 = load %XTMModel*, %XTMModel** %val5543

; let value assignment
%models = select i1 true, %XTMModel* %val5544, %XTMModel* %val5544
store %XTMModel* %models, %XTMModel** %modelsPtr

%val5548 = load i32, i32* %idxPtr
%val5549 = load i32, i32* %num_childrenPtr
%cmp5550 = icmp slt i32 %val5548, %val5549
br i1 %cmp5550, label %then5547, label %else5547

then5547:
%val5551 = load i32, i32* %idxPtr
%val5552 = load %XTMModel*, %XTMModel** %modelsPtr
; pointer ref
%val5553 = getelementptr %XTMModel, %XTMModel* %val5552, i32 %val5551
ret %XTMModel* %val5553

else5547:
%null5554 = bitcast i8* null to %XTMModel*
ret %XTMModel* %null5554
}
@gsxtmgraphics-pipeline199 = hidden constant [110 x i8] c"xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}** @xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5574 = load i8*, i8** %_impzPtr
%zone5575 = bitcast i8* %tzone5574 to %mzone*

; let assign value to symbol xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ
%dat_xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone5575, i64 8)
%xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQPtr = bitcast i8* %dat_xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ to { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}***
%tzone5555 = load i8*, i8** %_impzPtr
%zone5556 = bitcast i8* %tzone5555 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5556)
; malloc closure structure
%clsptr5557 = call i8* @llvm_zone_malloc(%mzone* %zone5556, i64 24)
%closure5558 = bitcast i8* %clsptr5557 to { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}*

; malloc environment structure
%envptr5559 = call i8* @llvm_zone_malloc(%mzone* %zone5556, i64 8)
%environment5560 = bitcast i8* %envptr5559 to {{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}***}*

; malloc closure address table
%addytable5561 = call %clsvar* @new_address_table()
%var5562 = bitcast [57 x i8]* @gsxtmgraphics-pipeline197 to i8*
%var5563 = bitcast [54 x i8]* @gsxtmgraphics-pipeline198 to i8*
%addytable5564 = call %clsvar* @add_address_table(%mzone* %zone5556, i8* %var5562, i32 0, i8* %var5563, i32 3, %clsvar* %addytable5561)
%address-table5565 = bitcast %clsvar* %addytable5564 to i8*

; insert table, function and environment into closure struct
%closure.table5568 = getelementptr { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}, { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}* %closure5558, i32 0, i32 0
store i8* %address-table5565, i8** %closure.table5568
%closure.env5569 = getelementptr { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}, { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}* %closure5558, i32 0, i32 1
store i8* %envptr5559, i8** %closure.env5569
%closure.func5570 = getelementptr { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}, { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}* %closure5558, i32 0, i32 2
store %XTMModel* (i8*, i8*, %XTMModel*, i32)* @xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ__5535, %XTMModel* (i8*, i8*, %XTMModel*, i32)** %closure.func5570
%closure_size5571 = call i64 @llvm_zone_mark_size(%mzone* %zone5556)
call void @llvm_zone_ptr_set_size(i8* %clsptr5557, i64 %closure_size5571)
%wrapper_ptr5572 = call i8* @llvm_zone_malloc(%mzone* %zone5556, i64 8)
%closure_wrapper5573 = bitcast i8* %wrapper_ptr5572 to { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}**
store { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}* %closure5558, { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}** %closure_wrapper5573

; let value assignment
%xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ = select i1 true, { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}** %closure_wrapper5573, { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}** %closure_wrapper5573
store { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}** %xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ, { i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}*** %xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQPtr

; add data to environment
; don't need to alloc for env var xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ
%tmp_envptr5567 = getelementptr {{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}***}, {{i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}***}* %environment5560, i32 0, i32 0
store {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}*** %xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQPtr, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}**** %tmp_envptr5567


%val5576 = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}**, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}*** %xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQPtr
ret {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}** %val5576
}


@xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}** @xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMModel* @xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ(%XTMModel* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %XTMModel*, i32)*,  %XTMModel* (i8*, i8*, %XTMModel*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, i32 %arg_1)
ret %XTMModel* %result
}


define dllexport ccc %XTMModel* @xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ_native(%XTMModel* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %XTMModel*, i32)*,  %XTMModel* (i8*, i8*, %XTMModel*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, i32 %arg_1)
ret %XTMModel* %result
}


define dllexport ccc i8*  @xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5577 = bitcast [110 x i8]* @gsxtmgraphics-pipeline199 to i8*
call i32 (i8*, ...) @printf(i8* %var5577)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMModel*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5578 = bitcast [110 x i8]* @gsxtmgraphics-pipeline199 to i8*
call i32 (i8*, ...) @printf(i8* %var5578)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %XTMModel*, i32)*,  %XTMModel* (i8*, i8*, %XTMModel*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, i32 %arg_1)
%tmpres = bitcast %XTMModel* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMModel*, i32}*
%arg_p_0 = getelementptr {%XTMModel*, i32}, {%XTMModel*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMModel*, %XTMModel** %arg_p_0
%arg_p_1 = getelementptr {%XTMModel*, i32}, {%XTMModel*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_model_child_adhoc_W1hUTU1vZGVsKixYVE1Nb2RlbCosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %XTMModel*, i32)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %XTMModel*, i32)*,  %XTMModel* (i8*, i8*, %XTMModel*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline200 = hidden constant [54 x i8] c"xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd\00"
@gsxtmgraphics-pipeline201 = hidden constant [53 x i8] c"{i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}**\00"
define dllexport fastcc %XTMMesh* @xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd__5579(i8* %_impz,i8* %_impenv, %XTMModel* %model, i32 %idx) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5580 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}***}*
%xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJdPtr_ = getelementptr {{i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}***}, {{i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}***}* %impenv, i32 0, i32 0
%xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJdPtr = load {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}***, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}**** %xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJdPtr_

; setup arguments
%modelPtr = alloca %XTMModel*
store %XTMModel* %model, %XTMModel** %modelPtr
%idxPtr = alloca i32
store i32 %idx, i32* %idxPtr


%tzone5584 = load i8*, i8** %_impzPtr
%zone5585 = bitcast i8* %tzone5584 to %mzone*

; let assign value to symbol num_meshes
%num_meshesPtr = alloca i32
%tzone5589 = load i8*, i8** %_impzPtr
%zone5590 = bitcast i8* %tzone5589 to %mzone*

; let assign value to symbol meshes
%meshesPtr = alloca %XTMMesh*
%val5581 = load %XTMModel*, %XTMModel** %modelPtr
; tuple ref
%val5582 = getelementptr %XTMModel, %XTMModel* %val5581, i64 0, i32 5
%val5583 = load i32, i32* %val5582

; let value assignment
%num_meshes = select i1 true, i32 %val5583, i32 %val5583
store i32 %num_meshes, i32* %num_meshesPtr

%val5586 = load %XTMModel*, %XTMModel** %modelPtr
; tuple ref
%val5587 = getelementptr %XTMModel, %XTMModel* %val5586, i64 0, i32 6
%val5588 = load %XTMMesh*, %XTMMesh** %val5587

; let value assignment
%meshes = select i1 true, %XTMMesh* %val5588, %XTMMesh* %val5588
store %XTMMesh* %meshes, %XTMMesh** %meshesPtr

%val5592 = load i32, i32* %idxPtr
%val5593 = load i32, i32* %num_meshesPtr
%cmp5594 = icmp slt i32 %val5592, %val5593
br i1 %cmp5594, label %then5591, label %else5591

then5591:
%val5595 = load i32, i32* %idxPtr
%val5596 = load %XTMMesh*, %XTMMesh** %meshesPtr
; pointer ref
%val5597 = getelementptr %XTMMesh, %XTMMesh* %val5596, i32 %val5595
ret %XTMMesh* %val5597

else5591:
%null5598 = bitcast i8* null to %XTMMesh*
ret %XTMMesh* %null5598
}
@gsxtmgraphics-pipeline202 = hidden constant [107 x i8] c"xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}** @xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5618 = load i8*, i8** %_impzPtr
%zone5619 = bitcast i8* %tzone5618 to %mzone*

; let assign value to symbol xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd
%dat_xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone5619, i64 8)
%xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJdPtr = bitcast i8* %dat_xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd to { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}***
%tzone5599 = load i8*, i8** %_impzPtr
%zone5600 = bitcast i8* %tzone5599 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5600)
; malloc closure structure
%clsptr5601 = call i8* @llvm_zone_malloc(%mzone* %zone5600, i64 24)
%closure5602 = bitcast i8* %clsptr5601 to { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}*

; malloc environment structure
%envptr5603 = call i8* @llvm_zone_malloc(%mzone* %zone5600, i64 8)
%environment5604 = bitcast i8* %envptr5603 to {{i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}***}*

; malloc closure address table
%addytable5605 = call %clsvar* @new_address_table()
%var5606 = bitcast [54 x i8]* @gsxtmgraphics-pipeline200 to i8*
%var5607 = bitcast [53 x i8]* @gsxtmgraphics-pipeline201 to i8*
%addytable5608 = call %clsvar* @add_address_table(%mzone* %zone5600, i8* %var5606, i32 0, i8* %var5607, i32 3, %clsvar* %addytable5605)
%address-table5609 = bitcast %clsvar* %addytable5608 to i8*

; insert table, function and environment into closure struct
%closure.table5612 = getelementptr { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}, { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}* %closure5602, i32 0, i32 0
store i8* %address-table5609, i8** %closure.table5612
%closure.env5613 = getelementptr { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}, { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}* %closure5602, i32 0, i32 1
store i8* %envptr5603, i8** %closure.env5613
%closure.func5614 = getelementptr { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}, { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}* %closure5602, i32 0, i32 2
store %XTMMesh* (i8*, i8*, %XTMModel*, i32)* @xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd__5579, %XTMMesh* (i8*, i8*, %XTMModel*, i32)** %closure.func5614
%closure_size5615 = call i64 @llvm_zone_mark_size(%mzone* %zone5600)
call void @llvm_zone_ptr_set_size(i8* %clsptr5601, i64 %closure_size5615)
%wrapper_ptr5616 = call i8* @llvm_zone_malloc(%mzone* %zone5600, i64 8)
%closure_wrapper5617 = bitcast i8* %wrapper_ptr5616 to { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}**
store { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}* %closure5602, { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}** %closure_wrapper5617

; let value assignment
%xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd = select i1 true, { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}** %closure_wrapper5617, { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}** %closure_wrapper5617
store { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}** %xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd, { i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}*** %xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJdPtr

; add data to environment
; don't need to alloc for env var xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd
%tmp_envptr5611 = getelementptr {{i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}***}, {{i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}***}* %environment5604, i32 0, i32 0
store {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}*** %xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJdPtr, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}**** %tmp_envptr5611


%val5620 = load {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}**, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}*** %xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJdPtr
ret {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}** %val5620
}


@xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}** @xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMMesh* @xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd(%XTMModel* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %XTMModel*, i32)*,  %XTMMesh* (i8*, i8*, %XTMModel*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, i32 %arg_1)
ret %XTMMesh* %result
}


define dllexport ccc %XTMMesh* @xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd_native(%XTMModel* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %XTMModel*, i32)*,  %XTMMesh* (i8*, i8*, %XTMModel*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, i32 %arg_1)
ret %XTMMesh* %result
}


define dllexport ccc i8*  @xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5621 = bitcast [107 x i8]* @gsxtmgraphics-pipeline202 to i8*
call i32 (i8*, ...) @printf(i8* %var5621)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMModel*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5622 = bitcast [107 x i8]* @gsxtmgraphics-pipeline202 to i8*
call i32 (i8*, ...) @printf(i8* %var5622)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %XTMModel*, i32)*,  %XTMMesh* (i8*, i8*, %XTMModel*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, i32 %arg_1)
%tmpres = bitcast %XTMMesh* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMModel*, i32}*
%arg_p_0 = getelementptr {%XTMModel*, i32}, {%XTMModel*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMModel*, %XTMModel** %arg_p_0
%arg_p_1 = getelementptr {%XTMModel*, i32}, {%XTMModel*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_model_mesh_adhoc_W1hUTU1lc2gqLFhUTU1vZGVsKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}**
%closure = load {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}*, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}, {i8*, i8*, %XTMMesh* (i8*, i8*, %XTMModel*, i32)*}* %closure, i32 0, i32 1
%ff = load  %XTMMesh* (i8*, i8*, %XTMModel*, i32)*,  %XTMMesh* (i8*, i8*, %XTMModel*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMMesh* %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline203 = hidden constant [57 x i8] c"set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd\00"
@gsxtmgraphics-pipeline204 = hidden constant [50 x i8] c"{i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}**\00"
define dllexport fastcc void @set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd__5623(i8* %_impz,i8* %_impenv, %XTMModel* %model, %VBO* %vbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5624 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}***}*
%set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}***}* %impenv, i32 0, i32 0
%set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypdPtr = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}***, {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}**** %set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypdPtr_

; setup arguments
%modelPtr = alloca %XTMModel*
store %XTMModel* %model, %XTMModel** %modelPtr
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr


%tzone5625 = load i8*, i8** %_impzPtr
%zone5626 = bitcast i8* %tzone5625 to %mzone*

; let assign value to symbol i
%iPtr = alloca i32
%tzone5630 = load i8*, i8** %_impzPtr
%zone5631 = bitcast i8* %tzone5630 to %mzone*

; let assign value to symbol num_children
%num_childrenPtr = alloca i32
%tzone5635 = load i8*, i8** %_impzPtr
%zone5636 = bitcast i8* %tzone5635 to %mzone*

; let assign value to symbol children
%childrenPtr = alloca %XTMModel*
%tzone5640 = load i8*, i8** %_impzPtr
%zone5641 = bitcast i8* %tzone5640 to %mzone*

; let assign value to symbol num_meshes
%num_meshesPtr = alloca i32
%tzone5645 = load i8*, i8** %_impzPtr
%zone5646 = bitcast i8* %tzone5645 to %mzone*

; let assign value to symbol meshes
%meshesPtr = alloca %XTMMesh*
%tzone5648 = load i8*, i8** %_impzPtr
%zone5649 = bitcast i8* %tzone5648 to %mzone*

; let assign value to symbol mesh
%meshPtr = alloca %XTMMesh*
%tzone5651 = load i8*, i8** %_impzPtr
%zone5652 = bitcast i8* %tzone5651 to %mzone*

; let assign value to symbol vao
%vaoPtr = alloca %VAO*

; let value assignment
%i = select i1 true, i32 0, i32 0
store i32 %i, i32* %iPtr

%val5627 = load %XTMModel*, %XTMModel** %modelPtr
; tuple ref
%val5628 = getelementptr %XTMModel, %XTMModel* %val5627, i64 0, i32 3
%val5629 = load i32, i32* %val5628

; let value assignment
%num_children = select i1 true, i32 %val5629, i32 %val5629
store i32 %num_children, i32* %num_childrenPtr

%val5632 = load %XTMModel*, %XTMModel** %modelPtr
; tuple ref
%val5633 = getelementptr %XTMModel, %XTMModel* %val5632, i64 0, i32 4
%val5634 = load %XTMModel*, %XTMModel** %val5633

; let value assignment
%children = select i1 true, %XTMModel* %val5634, %XTMModel* %val5634
store %XTMModel* %children, %XTMModel** %childrenPtr

%val5637 = load %XTMModel*, %XTMModel** %modelPtr
; tuple ref
%val5638 = getelementptr %XTMModel, %XTMModel* %val5637, i64 0, i32 5
%val5639 = load i32, i32* %val5638

; let value assignment
%num_meshes = select i1 true, i32 %val5639, i32 %val5639
store i32 %num_meshes, i32* %num_meshesPtr

%val5642 = load %XTMModel*, %XTMModel** %modelPtr
; tuple ref
%val5643 = getelementptr %XTMModel, %XTMModel* %val5642, i64 0, i32 6
%val5644 = load %XTMMesh*, %XTMMesh** %val5643

; let value assignment
%meshes = select i1 true, %XTMMesh* %val5644, %XTMMesh* %val5644
store %XTMMesh* %meshes, %XTMMesh** %meshesPtr

%null5647 = bitcast i8* null to %XTMMesh*

; let value assignment
%mesh = select i1 true, %XTMMesh* %null5647, %XTMMesh* %null5647
store %XTMMesh* %mesh, %XTMMesh** %meshPtr

%null5650 = bitcast i8* null to %VAO*

; let value assignment
%vao = select i1 true, %VAO* %null5650, %VAO* %null5650
store %VAO* %vao, %VAO** %vaoPtr

; setup loop
%val5655 = load i32, i32* %num_childrenPtr
store i32 0, i32* %iPtr
%val5670 = load i32, i32* %iPtr
%num5671 = add i32 %val5655, %val5670
%comp5672 = icmp ult i32 %val5655, 1
br i1 %comp5672, label %after5653, label %loop5653

loop5653:
%val5656 = load i32, i32* %iPtr
%val5657 = load %XTMModel*, %XTMModel** %childrenPtr
; pointer ref
%val5658 = getelementptr %XTMModel, %XTMModel* %val5657, i32 %val5656
%val5659 = load %VBO*, %VBO** %vboPtr

; apply closure 
%vval5660 = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}**, {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}*** %set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypdPtr
%val5661 = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}*,{i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}** %vval5660
%fPtr5662 = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}* %val5661, i32 0, i32 2
%ePtr5663 = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}* %val5661, i32 0, i32 1
%f5664 = load void (i8*, i8*, %XTMModel*, %VBO*)*, void (i8*, i8*, %XTMModel*, %VBO*)** %fPtr5662
%e5665 = load i8*, i8** %ePtr5663
%tzone5666 = load i8*, i8** %_impzPtr
%zone5667 = bitcast i8* %tzone5666 to %mzone*
%z5668 = bitcast %mzone* %zone5667 to i8*
tail call fastcc void %f5664(i8* %z5668, i8* %e5665, %XTMModel* %val5658, %VBO* %val5659)
%loop_cnt5653 = load i32, i32* %iPtr
%next5653 = add i32 %loop_cnt5653, 1
store i32 %next5653, i32* %iPtr
%cmp5653 = icmp ult i32 %next5653, %num5671
br i1 %cmp5653, label %loop5653, label %after5653

after5653:
; setup loop
%val5676 = load i32, i32* %num_meshesPtr
store i32 0, i32* %iPtr
%val5687 = load i32, i32* %iPtr
%num5688 = add i32 %val5676, %val5687
%comp5689 = icmp ult i32 %val5676, 1
br i1 %comp5689, label %after5674, label %loop5674

loop5674:
; do set!
%val5677 = load i32, i32* %iPtr
%val5678 = load %XTMMesh*, %XTMMesh** %meshesPtr
; pointer ref
%val5679 = getelementptr %XTMMesh, %XTMMesh* %val5678, i32 %val5677
store %XTMMesh* %val5679, %XTMMesh** %meshPtr
; do set!
%val5680 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val5681 = getelementptr %XTMMesh, %XTMMesh* %val5680, i64 0, i32 10
%val5682 = load %VAO*, %VAO** %val5681
store %VAO* %val5682, %VAO** %vaoPtr
%val5683 = load %VAO*, %VAO** %vaoPtr
%val5684 = load %VBO*, %VBO** %vboPtr
%res5685 = call ccc i1 @impc_true()
call fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd(%VAO* %val5683, %VBO* %val5684, i32 4, i32 16, i1 %res5685)
%loop_cnt5674 = load i32, i32* %iPtr
%next5674 = add i32 %loop_cnt5674, 1
store i32 %next5674, i32* %iPtr
%cmp5674 = icmp ult i32 %next5674, %num5688
br i1 %cmp5674, label %loop5674, label %after5674

after5674:
ret void
}
@gsxtmgraphics-pipeline205 = hidden constant [110 x i8] c"set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}** @set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5711 = load i8*, i8** %_impzPtr
%zone5712 = bitcast i8* %tzone5711 to %mzone*

; let assign value to symbol set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd
%dat_set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd = call i8* @llvm_zone_malloc(%mzone* %zone5712, i64 8)
%set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypdPtr = bitcast i8* %dat_set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd to { i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}***
%tzone5692 = load i8*, i8** %_impzPtr
%zone5693 = bitcast i8* %tzone5692 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5693)
; malloc closure structure
%clsptr5694 = call i8* @llvm_zone_malloc(%mzone* %zone5693, i64 24)
%closure5695 = bitcast i8* %clsptr5694 to { i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}*

; malloc environment structure
%envptr5696 = call i8* @llvm_zone_malloc(%mzone* %zone5693, i64 8)
%environment5697 = bitcast i8* %envptr5696 to {{i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}***}*

; malloc closure address table
%addytable5698 = call %clsvar* @new_address_table()
%var5699 = bitcast [57 x i8]* @gsxtmgraphics-pipeline203 to i8*
%var5700 = bitcast [50 x i8]* @gsxtmgraphics-pipeline204 to i8*
%addytable5701 = call %clsvar* @add_address_table(%mzone* %zone5693, i8* %var5699, i32 0, i8* %var5700, i32 3, %clsvar* %addytable5698)
%address-table5702 = bitcast %clsvar* %addytable5701 to i8*

; insert table, function and environment into closure struct
%closure.table5705 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}* %closure5695, i32 0, i32 0
store i8* %address-table5702, i8** %closure.table5705
%closure.env5706 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}* %closure5695, i32 0, i32 1
store i8* %envptr5696, i8** %closure.env5706
%closure.func5707 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}* %closure5695, i32 0, i32 2
store void (i8*, i8*, %XTMModel*, %VBO*)* @set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd__5623, void (i8*, i8*, %XTMModel*, %VBO*)** %closure.func5707
%closure_size5708 = call i64 @llvm_zone_mark_size(%mzone* %zone5693)
call void @llvm_zone_ptr_set_size(i8* %clsptr5694, i64 %closure_size5708)
%wrapper_ptr5709 = call i8* @llvm_zone_malloc(%mzone* %zone5693, i64 8)
%closure_wrapper5710 = bitcast i8* %wrapper_ptr5709 to { i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}**
store { i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}* %closure5695, { i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}** %closure_wrapper5710

; let value assignment
%set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd = select i1 true, { i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}** %closure_wrapper5710, { i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}** %closure_wrapper5710
store { i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}** %set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd, { i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}*** %set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypdPtr

; add data to environment
; don't need to alloc for env var set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd
%tmp_envptr5704 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}***}* %environment5697, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}*** %set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypdPtr, {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}**** %tmp_envptr5704


%val5713 = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}**, {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}*** %set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypdPtr
ret {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}** %val5713
}


@set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd_var = dllexport global [1 x i8*] [ i8* null ]

@set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}** @set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd(%XTMModel* %arg_0,%VBO* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*, %VBO*)*,  void (i8*, i8*, %XTMModel*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, %VBO* %arg_1)
ret void
}


define dllexport ccc void @set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd_native(%XTMModel* %arg_0,%VBO* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*, %VBO*)*,  void (i8*, i8*, %XTMModel*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, %VBO* %arg_1)
ret void
}


define dllexport ccc i8*  @set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5714 = bitcast [110 x i8]* @gsxtmgraphics-pipeline205 to i8*
call i32 (i8*, ...) @printf(i8* %var5714)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMModel*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5715 = bitcast [110 x i8]* @gsxtmgraphics-pipeline205 to i8*
call i32 (i8*, ...) @printf(i8* %var5715)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*, %VBO*)*,  void (i8*, i8*, %XTMModel*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, %VBO* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMModel*, %VBO*}*
%arg_p_0 = getelementptr {%XTMModel*, %VBO*}, {%XTMModel*, %VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMModel*, %XTMModel** %arg_p_0
%arg_p_1 = getelementptr {%XTMModel*, %VBO*}, {%XTMModel*, %VBO*}* %fstruct, i32 0, i32 1
%arg_1 = load %VBO*, %VBO** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_instance_matrices_adhoc_W3ZvaWQsWFRNTW9kZWwqLFZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*, %VBO*)*,  void (i8*, i8*, %XTMModel*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, %VBO* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline206 = hidden constant [73 x i8] c"shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
define dllexport fastcc void @shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ__5716(i8* %_impz,i8* %_impenv, float* %matrix, float %width_s_22, float %height_s_23, float %factor) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5717 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***}*
%shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***}* %impenv, i32 0, i32 0
%shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**** %shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr_

; setup arguments
%matrixPtr = alloca float*
store float* %matrix, float** %matrixPtr
%width_s_22Ptr = alloca float
store float %width_s_22, float* %width_s_22Ptr
%height_s_23Ptr = alloca float
store float %height_s_23, float* %height_s_23Ptr
%factorPtr = alloca float
store float %factor, float* %factorPtr


%tzone5721 = load i8*, i8** %_impzPtr
%zone5722 = bitcast i8* %tzone5721 to %mzone*

; let assign value to symbol xinc
%xincPtr = alloca float
%tzone5726 = load i8*, i8** %_impzPtr
%zone5727 = bitcast i8* %tzone5726 to %mzone*

; let assign value to symbol yinc
%yincPtr = alloca float
%tzone5728 = load i8*, i8** %_impzPtr
%zone5729 = bitcast i8* %tzone5728 to %mzone*

; let assign value to symbol i
%iPtr = alloca i32
%tzone5730 = load i8*, i8** %_impzPtr
%zone5731 = bitcast i8* %tzone5730 to %mzone*

; let assign value to symbol j
%jPtr = alloca i32
%val5718 = load float, float* %factorPtr
%val5719 = load float, float* %width_s_22Ptr
%val5720 = fdiv float %val5718, %val5719

; let value assignment
%xinc = select i1 true, float %val5720, float %val5720
store float %xinc, float* %xincPtr

%val5723 = load float, float* %factorPtr
%val5724 = load float, float* %height_s_23Ptr
%val5725 = fdiv float %val5723, %val5724

; let value assignment
%yinc = select i1 true, float %val5725, float %val5725
store float %yinc, float* %yincPtr


; let value assignment
%i = select i1 true, i32 0, i32 0
store i32 %i, i32* %iPtr


; let value assignment
%j = select i1 true, i32 0, i32 0
store i32 %j, i32* %jPtr

; setup loop
store i32 0, i32* %iPtr
%val5768 = load i32, i32* %iPtr
%num5769 = add i32 5, %val5768
%comp5770 = icmp ult i32 5, 1
br i1 %comp5770, label %after5732, label %loop5732

loop5732:
; setup loop
store i32 0, i32* %jPtr
%val5764 = load i32, i32* %jPtr
%num5765 = add i32 5, %val5764
%comp5766 = icmp ult i32 5, 1
br i1 %comp5766, label %after5733, label %loop5733

loop5733:
%val5734 = load i32, i32* %iPtr
%val5735 = mul i32 %val5734, 5
%val5736 = load i32, i32* %jPtr
%val5737 = add i32 %val5735, %val5736
%val5738 = mul i32 %val5737, 2
%val5739 = add i32 %val5738, 0
%val5740 = load float*, float** %matrixPtr
%val5741 = load float, float* %xincPtr
%val5742 = fmul float 0xc000000000000000, %val5741
%val5743 = load i32, i32* %iPtr
%res5744 = call ccc float @i32tof(i32 %val5743)
%val5745 = load float, float* %xincPtr
%val5746 = fmul float %res5744, %val5745
%val5747 = fadd float %val5742, %val5746
; set pointer
%val5748 = getelementptr float, float* %val5740, i32 %val5739
store float %val5747, float* %val5748
%val5749 = load i32, i32* %iPtr
%val5750 = mul i32 %val5749, 5
%val5751 = load i32, i32* %jPtr
%val5752 = add i32 %val5750, %val5751
%val5753 = mul i32 %val5752, 2
%val5754 = add i32 %val5753, 1
%val5755 = load float*, float** %matrixPtr
%val5756 = load float, float* %xincPtr
%val5757 = fmul float 0xc000000000000000, %val5756
%val5758 = load i32, i32* %iPtr
%res5759 = call ccc float @i32tof(i32 %val5758)
%val5760 = load float, float* %yincPtr
%val5761 = fmul float %res5759, %val5760
%val5762 = fadd float %val5757, %val5761
; set pointer
%val5763 = getelementptr float, float* %val5755, i32 %val5754
store float %val5762, float* %val5763
%loop_cnt5733 = load i32, i32* %jPtr
%next5733 = add i32 %loop_cnt5733, 1
store i32 %next5733, i32* %jPtr
%cmp5733 = icmp ult i32 %next5733, %num5765
br i1 %cmp5733, label %loop5733, label %after5733

after5733:
%loop_cnt5732 = load i32, i32* %iPtr
%next5732 = add i32 %loop_cnt5732, 1
store i32 %next5732, i32* %iPtr
%cmp5732 = icmp ult i32 %next5732, %num5769
br i1 %cmp5732, label %loop5732, label %after5732

after5732:
ret void
}
@gsxtmgraphics-pipeline207 = hidden constant [126 x i8] c"shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** @shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5792 = load i8*, i8** %_impzPtr
%zone5793 = bitcast i8* %tzone5792 to %mzone*

; let assign value to symbol shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone5793, i64 8)
%shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ to { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***
%tzone5773 = load i8*, i8** %_impzPtr
%zone5774 = bitcast i8* %tzone5773 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5774)
; malloc closure structure
%clsptr5775 = call i8* @llvm_zone_malloc(%mzone* %zone5774, i64 24)
%closure5776 = bitcast i8* %clsptr5775 to { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*

; malloc environment structure
%envptr5777 = call i8* @llvm_zone_malloc(%mzone* %zone5774, i64 8)
%environment5778 = bitcast i8* %envptr5777 to {{i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***}*

; malloc closure address table
%addytable5779 = call %clsvar* @new_address_table()
%var5780 = bitcast [73 x i8]* @gsxtmgraphics-pipeline206 to i8*
%var5781 = bitcast [60 x i8]* @gsxtmgraphics-pipeline7 to i8*
%addytable5782 = call %clsvar* @add_address_table(%mzone* %zone5774, i8* %var5780, i32 0, i8* %var5781, i32 3, %clsvar* %addytable5779)
%address-table5783 = bitcast %clsvar* %addytable5782 to i8*

; insert table, function and environment into closure struct
%closure.table5786 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure5776, i32 0, i32 0
store i8* %address-table5783, i8** %closure.table5786
%closure.env5787 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure5776, i32 0, i32 1
store i8* %envptr5777, i8** %closure.env5787
%closure.func5788 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure5776, i32 0, i32 2
store void (i8*, i8*, float*, float, float, float)* @shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ__5716, void (i8*, i8*, float*, float, float, float)** %closure.func5788
%closure_size5789 = call i64 @llvm_zone_mark_size(%mzone* %zone5774)
call void @llvm_zone_ptr_set_size(i8* %clsptr5775, i64 %closure_size5789)
%wrapper_ptr5790 = call i8* @llvm_zone_malloc(%mzone* %zone5774, i64 8)
%closure_wrapper5791 = bitcast i8* %wrapper_ptr5790 to { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure5776, { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure_wrapper5791

; let value assignment
%shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure_wrapper5791, { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure_wrapper5791
store { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ, { i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*** %shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr5785 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float, float, float)*}***}* %environment5778, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*** %shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**** %tmp_envptr5785


%val5794 = load {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*** %shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %val5794
}


@shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** @shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ(float* %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float)*,  void (i8*, i8*, float*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret void
}


define dllexport ccc void @shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_native(float* %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float)*,  void (i8*, i8*, float*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret void
}


define dllexport ccc i8*  @shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5795 = bitcast [126 x i8]* @gsxtmgraphics-pipeline207 to i8*
call i32 (i8*, ...) @printf(i8* %var5795)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5796 = bitcast [126 x i8]* @gsxtmgraphics-pipeline207 to i8*
call i32 (i8*, ...) @printf(i8* %var5796)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5797 = bitcast [126 x i8]* @gsxtmgraphics-pipeline207 to i8*
call i32 (i8*, ...) @printf(i8* %var5797)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var5798 = bitcast [126 x i8]* @gsxtmgraphics-pipeline207 to i8*
call i32 (i8*, ...) @printf(i8* %var5798)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float)*,  void (i8*, i8*, float*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float, float, float}*
%arg_p_0 = getelementptr {float*, float, float, float}, {float*, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float, float, float}, {float*, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float*, float, float, float}, {float*, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float*, float, float, float}, {float*, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float, float, float)*,  void (i8*, i8*, float*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline208 = hidden constant [10 x i8] c"texoffset\00"
@gsxtmgraphics-pipeline209 = hidden constant [15 x i8] c"diffuseTexture\00"
@gsxtmgraphics-pipeline210 = hidden constant [85 x i8] c"shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ\00"
@gsxtmgraphics-pipeline211 = hidden constant [63 x i8] c"{i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}**\00"
define dllexport fastcc void @shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ__5799(i8* %_impz,i8* %_impenv, float* %matrix, %ShaderProgram* %shader, float %offset) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5800 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}***}*
%shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}***}, {{i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}***}* %impenv, i32 0, i32 0
%shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQPtr = load {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}***, {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}**** %shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQPtr_

; setup arguments
%matrixPtr = alloca float*
store float* %matrix, float** %matrixPtr
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%offsetPtr = alloca float
store float %offset, float* %offsetPtr


%val5801 = load float*, float** %matrixPtr
%val5802 = load float, float* %offsetPtr
call fastcc void @shader_set_grid_offsets_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ(float* %val5801, float 0x3ff0000000000000, float 0x3ff0000000000000, float %val5802)
%val5804 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res5805 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val5804)
%var5806 = bitcast [10 x i8]* @gsxtmgraphics-pipeline208 to i8*
%res5807 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res5805, i8* %var5806)
%val5808 = load float*, float** %matrixPtr
call fastcc void @glUniform2fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res5807, i32 25, float* %val5808)
%val5810 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res5811 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val5810)
%var5812 = bitcast [15 x i8]* @gsxtmgraphics-pipeline209 to i8*
%res5813 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res5811, i8* %var5812)
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res5813, i32 1)
ret void
}
@gsxtmgraphics-pipeline212 = hidden constant [138 x i8] c"shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}** @shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5834 = load i8*, i8** %_impzPtr
%zone5835 = bitcast i8* %tzone5834 to %mzone*

; let assign value to symbol shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ
%dat_shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone5835, i64 8)
%shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQPtr = bitcast i8* %dat_shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ to { i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}***
%tzone5815 = load i8*, i8** %_impzPtr
%zone5816 = bitcast i8* %tzone5815 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5816)
; malloc closure structure
%clsptr5817 = call i8* @llvm_zone_malloc(%mzone* %zone5816, i64 24)
%closure5818 = bitcast i8* %clsptr5817 to { i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}*

; malloc environment structure
%envptr5819 = call i8* @llvm_zone_malloc(%mzone* %zone5816, i64 8)
%environment5820 = bitcast i8* %envptr5819 to {{i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}***}*

; malloc closure address table
%addytable5821 = call %clsvar* @new_address_table()
%var5822 = bitcast [85 x i8]* @gsxtmgraphics-pipeline210 to i8*
%var5823 = bitcast [63 x i8]* @gsxtmgraphics-pipeline211 to i8*
%addytable5824 = call %clsvar* @add_address_table(%mzone* %zone5816, i8* %var5822, i32 0, i8* %var5823, i32 3, %clsvar* %addytable5821)
%address-table5825 = bitcast %clsvar* %addytable5824 to i8*

; insert table, function and environment into closure struct
%closure.table5828 = getelementptr { i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}, { i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}* %closure5818, i32 0, i32 0
store i8* %address-table5825, i8** %closure.table5828
%closure.env5829 = getelementptr { i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}, { i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}* %closure5818, i32 0, i32 1
store i8* %envptr5819, i8** %closure.env5829
%closure.func5830 = getelementptr { i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}, { i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}* %closure5818, i32 0, i32 2
store void (i8*, i8*, float*, %ShaderProgram*, float)* @shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ__5799, void (i8*, i8*, float*, %ShaderProgram*, float)** %closure.func5830
%closure_size5831 = call i64 @llvm_zone_mark_size(%mzone* %zone5816)
call void @llvm_zone_ptr_set_size(i8* %clsptr5817, i64 %closure_size5831)
%wrapper_ptr5832 = call i8* @llvm_zone_malloc(%mzone* %zone5816, i64 8)
%closure_wrapper5833 = bitcast i8* %wrapper_ptr5832 to { i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}**
store { i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}* %closure5818, { i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}** %closure_wrapper5833

; let value assignment
%shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}** %closure_wrapper5833, { i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}** %closure_wrapper5833
store { i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}** %shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ, { i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}*** %shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ
%tmp_envptr5827 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}***}, {{i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}***}* %environment5820, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}*** %shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQPtr, {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}**** %tmp_envptr5827


%val5836 = load {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}**, {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}*** %shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQPtr
ret {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}** %val5836
}


@shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}** @shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ(float* %arg_0,%ShaderProgram* %arg_1,float %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}*, {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}, {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}, {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, %ShaderProgram*, float)*,  void (i8*, i8*, float*, %ShaderProgram*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, %ShaderProgram* %arg_1, float %arg_2)
ret void
}


define dllexport ccc void @shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ_native(float* %arg_0,%ShaderProgram* %arg_1,float %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}*, {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}, {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}, {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, %ShaderProgram*, float)*,  void (i8*, i8*, float*, %ShaderProgram*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, %ShaderProgram* %arg_1, float %arg_2)
ret void
}


define dllexport ccc i8*  @shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5837 = bitcast [138 x i8]* @gsxtmgraphics-pipeline212 to i8*
call i32 (i8*, ...) @printf(i8* %var5837)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5838 = bitcast [138 x i8]* @gsxtmgraphics-pipeline212 to i8*
call i32 (i8*, ...) @printf(i8* %var5838)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %ShaderProgram*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5839 = bitcast [138 x i8]* @gsxtmgraphics-pipeline212 to i8*
call i32 (i8*, ...) @printf(i8* %var5839)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}*, {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}, {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}, {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, %ShaderProgram*, float)*,  void (i8*, i8*, float*, %ShaderProgram*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, %ShaderProgram* %arg_1, float %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, %ShaderProgram*, float}*
%arg_p_0 = getelementptr {float*, %ShaderProgram*, float}, {float*, %ShaderProgram*, float}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, %ShaderProgram*, float}, {float*, %ShaderProgram*, float}* %fstruct, i32 0, i32 1
%arg_1 = load %ShaderProgram*, %ShaderProgram** %arg_p_1
%arg_p_2 = getelementptr {float*, %ShaderProgram*, float}, {float*, %ShaderProgram*, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_setup_convolution_filter_adhoc_W3ZvaWQsZmxvYXQqLFNoYWRlclByb2dyYW0qLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}*, {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}, {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}, {i8*, i8*, void (i8*, i8*, float*, %ShaderProgram*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, %ShaderProgram*, float)*,  void (i8*, i8*, float*, %ShaderProgram*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, %ShaderProgram* %arg_1, float %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline213 = hidden constant [10 x i8] c"CameraPos\00"
@gsxtmgraphics-pipeline214 = hidden constant [10 x i8] c"CameraDir\00"
@gsxtmgraphics-pipeline215 = hidden constant [75 x i8] c"shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0\00"
@gsxtmgraphics-pipeline216 = hidden constant [64 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}**\00"
define dllexport fastcc void @shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0__5840(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, float* %position, float* %target) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5841 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}***}*
%shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}***}* %impenv, i32 0, i32 0
%shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0Ptr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}**** %shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0Ptr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%positionPtr = alloca float*
store float* %position, float** %positionPtr
%targetPtr = alloca float*
store float* %target, float** %targetPtr


%tzone5843 = load i8*, i8** %_impzPtr
%zone5844 = bitcast i8* %tzone5843 to %mzone*

; let assign value to symbol direction
%directionPtr = alloca float*
%tzone5847 = load i8*, i8** %_impzPtr
%zone5848 = bitcast i8* %tzone5847 to %mzone*

; let assign value to symbol tmp
%tmpPtr = alloca float*
%dat5842 = alloca float, i64 8, align 16

; let value assignment
%direction = select i1 true, float* %dat5842, float* %dat5842
store float* %direction, float** %directionPtr

%val5845 = load float*, float** %directionPtr
; pointer ref
%val5846 = getelementptr float, float* %val5845, i64 4

; let value assignment
%tmp = select i1 true, float* %val5846, float* %val5846
store float* %tmp, float** %tmpPtr

%val5849 = load float*, float** %positionPtr
%val5850 = load float*, float** %targetPtr
%val5851 = load float*, float** %tmpPtr
call fastcc void @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ(float* %val5849, float* %val5850, i64 3, float* %val5851)
%val5853 = load float*, float** %tmpPtr
%val5854 = load float*, float** %directionPtr
call fastcc void @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd(float* %val5853, i64 3, float* %val5854)
%val5856 = load float*, float** %directionPtr
; set pointer
%val5857 = getelementptr float, float* %val5856, i64 3
store float 0x0, float* %val5857
%val5858 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res5859 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val5858)
%var5860 = bitcast [10 x i8]* @gsxtmgraphics-pipeline213 to i8*
%res5861 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res5859, i8* %var5860)
%val5862 = load float*, float** %positionPtr
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res5861, i32 1, float* %val5862)
%val5864 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res5865 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val5864)
%var5866 = bitcast [10 x i8]* @gsxtmgraphics-pipeline214 to i8*
%res5867 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res5865, i8* %var5866)
%val5868 = load float*, float** %directionPtr
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res5867, i32 1, float* %val5868)
ret void
}
@gsxtmgraphics-pipeline217 = hidden constant [128 x i8] c"shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}** @shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5890 = load i8*, i8** %_impzPtr
%zone5891 = bitcast i8* %tzone5890 to %mzone*

; let assign value to symbol shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0
%dat_shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone5891, i64 8)
%shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0Ptr = bitcast i8* %dat_shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}***
%tzone5871 = load i8*, i8** %_impzPtr
%zone5872 = bitcast i8* %tzone5871 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5872)
; malloc closure structure
%clsptr5873 = call i8* @llvm_zone_malloc(%mzone* %zone5872, i64 24)
%closure5874 = bitcast i8* %clsptr5873 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}*

; malloc environment structure
%envptr5875 = call i8* @llvm_zone_malloc(%mzone* %zone5872, i64 8)
%environment5876 = bitcast i8* %envptr5875 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}***}*

; malloc closure address table
%addytable5877 = call %clsvar* @new_address_table()
%var5878 = bitcast [75 x i8]* @gsxtmgraphics-pipeline215 to i8*
%var5879 = bitcast [64 x i8]* @gsxtmgraphics-pipeline216 to i8*
%addytable5880 = call %clsvar* @add_address_table(%mzone* %zone5872, i8* %var5878, i32 0, i8* %var5879, i32 3, %clsvar* %addytable5877)
%address-table5881 = bitcast %clsvar* %addytable5880 to i8*

; insert table, function and environment into closure struct
%closure.table5884 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}* %closure5874, i32 0, i32 0
store i8* %address-table5881, i8** %closure.table5884
%closure.env5885 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}* %closure5874, i32 0, i32 1
store i8* %envptr5875, i8** %closure.env5885
%closure.func5886 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}* %closure5874, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, float*, float*)* @shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0__5840, void (i8*, i8*, %ShaderProgram*, float*, float*)** %closure.func5886
%closure_size5887 = call i64 @llvm_zone_mark_size(%mzone* %zone5872)
call void @llvm_zone_ptr_set_size(i8* %clsptr5873, i64 %closure_size5887)
%wrapper_ptr5888 = call i8* @llvm_zone_malloc(%mzone* %zone5872, i64 8)
%closure_wrapper5889 = bitcast i8* %wrapper_ptr5888 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}* %closure5874, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}** %closure_wrapper5889

; let value assignment
%shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}** %closure_wrapper5889, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}** %closure_wrapper5889
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}** %shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}*** %shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0Ptr

; add data to environment
; don't need to alloc for env var shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0
%tmp_envptr5883 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}***}* %environment5876, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}*** %shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0Ptr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}**** %tmp_envptr5883


%val5892 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}*** %shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}** %val5892
}


@shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}** @shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0(%ShaderProgram* %arg_0,float* %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2)
ret void
}


define dllexport ccc void @shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0_native(%ShaderProgram* %arg_0,float* %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2)
ret void
}


define dllexport ccc i8*  @shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5893 = bitcast [128 x i8]* @gsxtmgraphics-pipeline217 to i8*
call i32 (i8*, ...) @printf(i8* %var5893)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5894 = bitcast [128 x i8]* @gsxtmgraphics-pipeline217 to i8*
call i32 (i8*, ...) @printf(i8* %var5894)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5895 = bitcast [128 x i8]* @gsxtmgraphics-pipeline217 to i8*
call i32 (i8*, ...) @printf(i8* %var5895)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, float*, float*}*
%arg_p_0 = getelementptr {%ShaderProgram*, float*, float*}, {%ShaderProgram*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, float*, float*}, {%ShaderProgram*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, float*, float*}, {%ShaderProgram*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline218 = hidden constant [20 x i8] c"ConstantAttenuation\00"
@gsxtmgraphics-pipeline219 = hidden constant [18 x i8] c"LinearAttenuation\00"
@gsxtmgraphics-pipeline220 = hidden constant [21 x i8] c"QuadraticAttenuation\00"
@gsxtmgraphics-pipeline221 = hidden constant [13 x i8] c"SpotExponent\00"
@gsxtmgraphics-pipeline222 = hidden constant [10 x i8] c"SpotAngle\00"
@gsxtmgraphics-pipeline223 = hidden constant [9 x i8] c"LightPos\00"
@gsxtmgraphics-pipeline224 = hidden constant [13 x i8] c"LightAmbient\00"
@gsxtmgraphics-pipeline225 = hidden constant [14 x i8] c"LightSpecular\00"
@gsxtmgraphics-pipeline226 = hidden constant [13 x i8] c"LightDiffuse\00"
@gsxtmgraphics-pipeline227 = hidden constant [8 x i8] c"SpotDir\00"
@gsxtmgraphics-pipeline228 = hidden constant [118 x i8] c"shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0\00"
@gsxtmgraphics-pipeline229 = hidden constant [102 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}**\00"
define dllexport fastcc void @shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0__5896(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, float* %position, float* %target, float %angle, float %power, float* %ambient, float* %diffuse, float* %specular) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5897 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}***}*
%shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}**** %shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%positionPtr = alloca float*
store float* %position, float** %positionPtr
%targetPtr = alloca float*
store float* %target, float** %targetPtr
%anglePtr = alloca float
store float %angle, float* %anglePtr
%powerPtr = alloca float
store float %power, float* %powerPtr
%ambientPtr = alloca float*
store float* %ambient, float** %ambientPtr
%diffusePtr = alloca float*
store float* %diffuse, float** %diffusePtr
%specularPtr = alloca float*
store float* %specular, float** %specularPtr


%val5898 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res5899 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val5898)
%var5900 = bitcast [20 x i8]* @gsxtmgraphics-pipeline218 to i8*
%res5901 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res5899, i8* %var5900)
call fastcc void @glUniform1f_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %res5901, float 0x3ff0000000000000)
%val5903 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res5904 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val5903)
%var5905 = bitcast [18 x i8]* @gsxtmgraphics-pipeline219 to i8*
%res5906 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res5904, i8* %var5905)
call fastcc void @glUniform1f_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %res5906, float 0x0)
%val5908 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res5909 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val5908)
%var5910 = bitcast [21 x i8]* @gsxtmgraphics-pipeline220 to i8*
%res5911 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res5909, i8* %var5910)
call fastcc void @glUniform1f_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %res5911, float 0x0)
%val5913 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res5914 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val5913)
%var5915 = bitcast [13 x i8]* @gsxtmgraphics-pipeline221 to i8*
%res5916 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res5914, i8* %var5915)
%val5917 = load float, float* %powerPtr
call fastcc void @glUniform1f_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %res5916, float %val5917)
%val5919 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res5920 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val5919)
%var5921 = bitcast [10 x i8]* @gsxtmgraphics-pipeline222 to i8*
%res5922 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res5920, i8* %var5921)
%val5923 = load float, float* %anglePtr
%val5924 = fdiv float %val5923, 0x4066800000000000
%val5925 = fsub float 0x3ff0000000000000, %val5924
call fastcc void @glUniform1f_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %res5922, float %val5925)
%val5927 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res5928 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val5927)
%var5929 = bitcast [9 x i8]* @gsxtmgraphics-pipeline223 to i8*
%res5930 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res5928, i8* %var5929)
%val5931 = load float*, float** %positionPtr
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res5930, i32 1, float* %val5931)
%val5933 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res5934 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val5933)
%var5935 = bitcast [13 x i8]* @gsxtmgraphics-pipeline224 to i8*
%res5936 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res5934, i8* %var5935)
%val5937 = load float*, float** %ambientPtr
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res5936, i32 1, float* %val5937)
%val5939 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res5940 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val5939)
%var5941 = bitcast [14 x i8]* @gsxtmgraphics-pipeline225 to i8*
%res5942 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res5940, i8* %var5941)
%val5943 = load float*, float** %specularPtr
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res5942, i32 1, float* %val5943)
%val5945 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res5946 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val5945)
%var5947 = bitcast [13 x i8]* @gsxtmgraphics-pipeline226 to i8*
%res5948 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res5946, i8* %var5947)
%val5949 = load float*, float** %diffusePtr
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res5948, i32 1, float* %val5949)
%tzone5952 = load i8*, i8** %_impzPtr
%zone5953 = bitcast i8* %tzone5952 to %mzone*

; let assign value to symbol direction
%directionPtr = alloca float*
%tzone5955 = load i8*, i8** %_impzPtr
%zone5956 = bitcast i8* %tzone5955 to %mzone*

; let assign value to symbol tmp
%tmpPtr = alloca float*
%dat5951 = alloca float, i64 4, align 16

; let value assignment
%direction = select i1 true, float* %dat5951, float* %dat5951
store float* %direction, float** %directionPtr

%dat5954 = alloca float, i64 4, align 16

; let value assignment
%tmp = select i1 true, float* %dat5954, float* %dat5954
store float* %tmp, float** %tmpPtr

%val5957 = load float*, float** %targetPtr
%val5958 = load float*, float** %positionPtr
%val5959 = load float*, float** %tmpPtr
call fastcc void @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ(float* %val5957, float* %val5958, i64 3, float* %val5959)
%val5961 = load float*, float** %tmpPtr
%val5962 = load float*, float** %directionPtr
call fastcc void @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd(float* %val5961, i64 3, float* %val5962)
%val5964 = load float*, float** %directionPtr
; set pointer
%val5965 = getelementptr float, float* %val5964, i64 3
store float 0x0, float* %val5965
%val5966 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res5967 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val5966)
%var5968 = bitcast [8 x i8]* @gsxtmgraphics-pipeline227 to i8*
%res5969 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res5967, i8* %var5968)
%val5970 = load float*, float** %directionPtr
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res5969, i32 1, float* %val5970)
ret void
}
@gsxtmgraphics-pipeline230 = hidden constant [171 x i8] c"shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}** @shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5992 = load i8*, i8** %_impzPtr
%zone5993 = bitcast i8* %tzone5992 to %mzone*

; let assign value to symbol shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0
%dat_shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone5993, i64 8)
%shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr = bitcast i8* %dat_shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}***
%tzone5973 = load i8*, i8** %_impzPtr
%zone5974 = bitcast i8* %tzone5973 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5974)
; malloc closure structure
%clsptr5975 = call i8* @llvm_zone_malloc(%mzone* %zone5974, i64 24)
%closure5976 = bitcast i8* %clsptr5975 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}*

; malloc environment structure
%envptr5977 = call i8* @llvm_zone_malloc(%mzone* %zone5974, i64 8)
%environment5978 = bitcast i8* %envptr5977 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}***}*

; malloc closure address table
%addytable5979 = call %clsvar* @new_address_table()
%var5980 = bitcast [118 x i8]* @gsxtmgraphics-pipeline228 to i8*
%var5981 = bitcast [102 x i8]* @gsxtmgraphics-pipeline229 to i8*
%addytable5982 = call %clsvar* @add_address_table(%mzone* %zone5974, i8* %var5980, i32 0, i8* %var5981, i32 3, %clsvar* %addytable5979)
%address-table5983 = bitcast %clsvar* %addytable5982 to i8*

; insert table, function and environment into closure struct
%closure.table5986 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}* %closure5976, i32 0, i32 0
store i8* %address-table5983, i8** %closure.table5986
%closure.env5987 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}* %closure5976, i32 0, i32 1
store i8* %envptr5977, i8** %closure.env5987
%closure.func5988 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}* %closure5976, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)* @shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0__5896, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)** %closure.func5988
%closure_size5989 = call i64 @llvm_zone_mark_size(%mzone* %zone5974)
call void @llvm_zone_ptr_set_size(i8* %clsptr5975, i64 %closure_size5989)
%wrapper_ptr5990 = call i8* @llvm_zone_malloc(%mzone* %zone5974, i64 8)
%closure_wrapper5991 = bitcast i8* %wrapper_ptr5990 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}* %closure5976, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}** %closure_wrapper5991

; let value assignment
%shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}** %closure_wrapper5991, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}** %closure_wrapper5991
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}** %shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}*** %shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr

; add data to environment
; don't need to alloc for env var shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0
%tmp_envptr5985 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}***}* %environment5978, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}*** %shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}**** %tmp_envptr5985


%val5994 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}*** %shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}** %val5994
}


@shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}** @shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0(%ShaderProgram* %arg_0,float* %arg_1,float* %arg_2,float %arg_3,float %arg_4,float* %arg_5,float* %arg_6,float* %arg_7) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float %arg_3, float %arg_4, float* %arg_5, float* %arg_6, float* %arg_7)
ret void
}


define dllexport ccc void @shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_native(%ShaderProgram* %arg_0,float* %arg_1,float* %arg_2,float %arg_3,float %arg_4,float* %arg_5,float* %arg_6,float* %arg_7) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float %arg_3, float %arg_4, float* %arg_5, float* %arg_6, float* %arg_7)
ret void
}


define dllexport ccc i8*  @shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5995 = bitcast [171 x i8]* @gsxtmgraphics-pipeline230 to i8*
call i32 (i8*, ...) @printf(i8* %var5995)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5996 = bitcast [171 x i8]* @gsxtmgraphics-pipeline230 to i8*
call i32 (i8*, ...) @printf(i8* %var5996)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5997 = bitcast [171 x i8]* @gsxtmgraphics-pipeline230 to i8*
call i32 (i8*, ...) @printf(i8* %var5997)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var5998 = bitcast [171 x i8]* @gsxtmgraphics-pipeline230 to i8*
call i32 (i8*, ...) @printf(i8* %var5998)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var5999 = bitcast [171 x i8]* @gsxtmgraphics-pipeline230 to i8*
call i32 (i8*, ...) @printf(i8* %var5999)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var6000 = bitcast [171 x i8]* @gsxtmgraphics-pipeline230 to i8*
call i32 (i8*, ...) @printf(i8* %var6000)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to float*
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var6001 = bitcast [171 x i8]* @gsxtmgraphics-pipeline230 to i8*
call i32 (i8*, ...) @printf(i8* %var6001)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to float*
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_cptr(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var6002 = bitcast [171 x i8]* @gsxtmgraphics-pipeline230 to i8*
call i32 (i8*, ...) @printf(i8* %var6002)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%ttv_7 = call ccc i8* @cptr_value(i8* %arg_7_val)
%arg_7 = bitcast i8* %ttv_7 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float %arg_3, float %arg_4, float* %arg_5, float* %arg_6, float* %arg_7)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, float*, float*, float, float, float*, float*, float*}*
%arg_p_0 = getelementptr {%ShaderProgram*, float*, float*, float, float, float*, float*, float*}, {%ShaderProgram*, float*, float*, float, float, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, float*, float*, float, float, float*, float*, float*}, {%ShaderProgram*, float*, float*, float, float, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, float*, float*, float, float, float*, float*, float*}, {%ShaderProgram*, float*, float*, float, float, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%ShaderProgram*, float*, float*, float, float, float*, float*, float*}, {%ShaderProgram*, float*, float*, float, float, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {%ShaderProgram*, float*, float*, float, float, float*, float*, float*}, {%ShaderProgram*, float*, float*, float, float, float*, float*, float*}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
%arg_p_5 = getelementptr {%ShaderProgram*, float*, float*, float, float, float*, float*, float*}, {%ShaderProgram*, float*, float*, float, float, float*, float*, float*}* %fstruct, i32 0, i32 5
%arg_5 = load float*, float** %arg_p_5
%arg_p_6 = getelementptr {%ShaderProgram*, float*, float*, float, float, float*, float*, float*}, {%ShaderProgram*, float*, float*, float, float, float*, float*, float*}* %fstruct, i32 0, i32 6
%arg_6 = load float*, float** %arg_p_6
%arg_p_7 = getelementptr {%ShaderProgram*, float*, float*, float, float, float*, float*, float*}, {%ShaderProgram*, float*, float*, float, float, float*, float*, float*}* %fstruct, i32 0, i32 7
%arg_7 = load float*, float** %arg_p_7
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_light_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float %arg_3, float %arg_4, float* %arg_5, float* %arg_6, float* %arg_7)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline231 = hidden constant [10 x i8] c"numLights\00"
@gsxtmgraphics-pipeline232 = hidden constant [127 x i8] c"shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0\00"
@gsxtmgraphics-pipeline233 = hidden constant [109 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}**\00"
@gsxtmgraphics-pipeline234 = hidden constant [4 x i8] c"tmp\00"
@gsxtmgraphics-pipeline235 = hidden constant [4 x i8] c"dir\00"
@gsxtmgraphics-pipeline236 = hidden constant [3 x i8] c"sa\00"
@gsxtmgraphics-pipeline237 = hidden constant [3 x i8] c"qa\00"
@gsxtmgraphics-pipeline238 = hidden constant [3 x i8] c"la\00"
@gsxtmgraphics-pipeline239 = hidden constant [3 x i8] c"ca\00"
@gsxtmgraphics-pipeline240 = hidden constant [2 x i8] c"i\00"
@gsxtmgraphics-pipeline241 = hidden constant [4 x i8] c"i32\00"
@gsxtmgraphics-pipeline242 = hidden constant [15 x i8] c"_anon_lambda_3\00"
define dllexport fastcc void @shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0__6003(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, i32 %numlights, float* %position, float* %target, float* %angle, float* %power, float* %ambient, float* %diffuse, float* %specular) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6070 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}*
%shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}**** %shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr_
%tmpPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 1
%tmpPtr = load float**, float*** %tmpPtr_
%dirPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 2
%dirPtr = load float**, float*** %dirPtr_
%saPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 3
%saPtr = load float**, float*** %saPtr_
%qaPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 4
%qaPtr = load float**, float*** %qaPtr_
%laPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 5
%laPtr = load float**, float*** %laPtr_
%caPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 6
%caPtr = load float**, float*** %caPtr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 7
%iPtr = load i32*, i32** %iPtr_
%_anon_lambda_3Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 8
%_anon_lambda_3Ptr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}**** %_anon_lambda_3Ptr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%numlightsPtr = alloca i32
store i32 %numlights, i32* %numlightsPtr
%positionPtr = alloca float*
store float* %position, float** %positionPtr
%targetPtr = alloca float*
store float* %target, float** %targetPtr
%anglePtr = alloca float*
store float* %angle, float** %anglePtr
%powerPtr = alloca float*
store float* %power, float** %powerPtr
%ambientPtr = alloca float*
store float* %ambient, float** %ambientPtr
%diffusePtr = alloca float*
store float* %diffuse, float** %diffusePtr
%specularPtr = alloca float*
store float* %specular, float** %specularPtr

; promote local stack var allocations
%tzone6202 = load i8*, i8** %_impzPtr
%zone6203 = bitcast i8* %tzone6202 to %mzone*
%ifptr6071 = alloca i32

%val6072 = load i32, i32* %numlightsPtr
%cmp6073 = icmp sgt i32 %val6072, 5
br i1 %cmp6073, label %then6071, label %else6071

then6071:
; do set!
store i32 5, i32* %numlightsPtr
store i32 5, i32* %ifptr6071
br label %ifcont6071

else6071:
br label %ifcont6071

ifcont6071:
%ifres6074 = load i32, i32* %ifptr6071

; setup loop
%val6077 = load i32, i32* %numlightsPtr
store i32 0, i32* %iPtr
%val6087 = load i32, i32* %iPtr
%num6088 = add i32 %val6077, %val6087
%comp6089 = icmp ult i32 %val6077, 1
br i1 %comp6089, label %after6075, label %loop6075

loop6075:
%val6078 = load i32, i32* %iPtr
%val6079 = load float*, float** %saPtr
%val6080 = load i32, i32* %iPtr
%val6081 = load float*, float** %anglePtr
; pointer ref
%val6082 = getelementptr float, float* %val6081, i32 %val6080
%val6083 = load float, float* %val6082
%val6084 = fdiv float %val6083, 0x4066800000000000
%val6085 = fsub float 0x3ff0000000000000, %val6084
; set pointer
%val6086 = getelementptr float, float* %val6079, i32 %val6078
store float %val6085, float* %val6086
%loop_cnt6075 = load i32, i32* %iPtr
%next6075 = add i32 %loop_cnt6075, 1
store i32 %next6075, i32* %iPtr
%cmp6075 = icmp ult i32 %next6075, %num6088
br i1 %cmp6075, label %loop6075, label %after6075

after6075:
%val6091 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6092 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6091)
%var6093 = bitcast [10 x i8]* @gsxtmgraphics-pipeline231 to i8*
%res6094 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6092, i8* %var6093)
%val6095 = load i32, i32* %numlightsPtr
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res6094, i32 %val6095)
%val6097 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6098 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6097)
%var6099 = bitcast [20 x i8]* @gsxtmgraphics-pipeline218 to i8*
%res6100 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6098, i8* %var6099)
%val6101 = load i32, i32* %numlightsPtr
%val6102 = load float*, float** %caPtr
call fastcc void @glUniform1fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res6100, i32 %val6101, float* %val6102)
%val6104 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6105 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6104)
%var6106 = bitcast [18 x i8]* @gsxtmgraphics-pipeline219 to i8*
%res6107 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6105, i8* %var6106)
%val6108 = load i32, i32* %numlightsPtr
%val6109 = load float*, float** %laPtr
call fastcc void @glUniform1fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res6107, i32 %val6108, float* %val6109)
%val6111 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6112 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6111)
%var6113 = bitcast [21 x i8]* @gsxtmgraphics-pipeline220 to i8*
%res6114 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6112, i8* %var6113)
%val6115 = load i32, i32* %numlightsPtr
%val6116 = load float*, float** %qaPtr
call fastcc void @glUniform1fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res6114, i32 %val6115, float* %val6116)
%val6118 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6119 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6118)
%var6120 = bitcast [13 x i8]* @gsxtmgraphics-pipeline221 to i8*
%res6121 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6119, i8* %var6120)
%val6122 = load i32, i32* %numlightsPtr
%val6123 = load float*, float** %powerPtr
call fastcc void @glUniform1fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res6121, i32 %val6122, float* %val6123)
%val6125 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6126 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6125)
%var6127 = bitcast [10 x i8]* @gsxtmgraphics-pipeline222 to i8*
%res6128 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6126, i8* %var6127)
%val6129 = load i32, i32* %numlightsPtr
%val6130 = load float*, float** %saPtr
call fastcc void @glUniform1fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res6128, i32 %val6129, float* %val6130)
%val6132 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6133 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6132)
%var6134 = bitcast [9 x i8]* @gsxtmgraphics-pipeline223 to i8*
%res6135 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6133, i8* %var6134)
%val6136 = load i32, i32* %numlightsPtr
%val6137 = load float*, float** %positionPtr
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res6135, i32 %val6136, float* %val6137)
%val6139 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6140 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6139)
%var6141 = bitcast [13 x i8]* @gsxtmgraphics-pipeline224 to i8*
%res6142 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6140, i8* %var6141)
%val6143 = load i32, i32* %numlightsPtr
%val6144 = load float*, float** %ambientPtr
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res6142, i32 %val6143, float* %val6144)
%val6146 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6147 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6146)
%var6148 = bitcast [14 x i8]* @gsxtmgraphics-pipeline225 to i8*
%res6149 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6147, i8* %var6148)
%val6150 = load i32, i32* %numlightsPtr
%val6151 = load float*, float** %specularPtr
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res6149, i32 %val6150, float* %val6151)
%val6153 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6154 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6153)
%var6155 = bitcast [13 x i8]* @gsxtmgraphics-pipeline226 to i8*
%res6156 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6154, i8* %var6155)
%val6157 = load i32, i32* %numlightsPtr
%val6158 = load float*, float** %diffusePtr
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res6156, i32 %val6157, float* %val6158)
; setup loop
%val6162 = load i32, i32* %numlightsPtr
store i32 0, i32* %iPtr
%val6190 = load i32, i32* %iPtr
%num6191 = add i32 %val6162, %val6190
%comp6192 = icmp ult i32 %val6162, 1
br i1 %comp6192, label %after6160, label %loop6160

loop6160:
%val6163 = load i32, i32* %iPtr
%val6164 = mul i32 %val6163, 4
%val6165 = load float*, float** %targetPtr
; pointer ref
%val6166 = getelementptr float, float* %val6165, i32 %val6164
%val6167 = load i32, i32* %iPtr
%val6168 = mul i32 %val6167, 4
%val6169 = load float*, float** %positionPtr
; pointer ref
%val6170 = getelementptr float, float* %val6169, i32 %val6168
%val6171 = load i32, i32* %iPtr
%val6172 = mul i32 %val6171, 4
%val6173 = load float*, float** %tmpPtr
; pointer ref
%val6174 = getelementptr float, float* %val6173, i32 %val6172
call fastcc void @vvsub_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixpNjQsZmxvYXQqXQ(float* %val6166, float* %val6170, i64 3, float* %val6174)
%val6176 = load i32, i32* %iPtr
%val6177 = mul i32 %val6176, 4
%val6178 = load float*, float** %tmpPtr
; pointer ref
%val6179 = getelementptr float, float* %val6178, i32 %val6177
%val6180 = load i32, i32* %iPtr
%val6181 = mul i32 %val6180, 4
%val6182 = load float*, float** %dirPtr
; pointer ref
%val6183 = getelementptr float, float* %val6182, i32 %val6181
call fastcc void @vnormalise_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd(float* %val6179, i64 3, float* %val6183)
%val6185 = load i32, i32* %iPtr
%val6186 = mul i32 %val6185, 4
%val6187 = load float*, float** %dirPtr
; pointer ref
%val6188 = getelementptr float, float* %val6187, i32 %val6186
; set pointer
%val6189 = getelementptr float, float* %val6188, i64 3
store float 0x0, float* %val6189
%loop_cnt6160 = load i32, i32* %iPtr
%next6160 = add i32 %loop_cnt6160, 1
store i32 %next6160, i32* %iPtr
%cmp6160 = icmp ult i32 %next6160, %num6191
br i1 %cmp6160, label %loop6160, label %after6160

after6160:
%val6194 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6195 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6194)
%var6196 = bitcast [8 x i8]* @gsxtmgraphics-pipeline227 to i8*
%res6197 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6195, i8* %var6196)
%val6198 = load i32, i32* %numlightsPtr
%val6199 = load float*, float** %dirPtr
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res6197, i32 %val6198, float* %val6199)
ret void
}
@gsxtmgraphics-pipeline243 = hidden constant [180 x i8] c"shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}** @shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6266 = load i8*, i8** %_impzPtr
%zone6267 = bitcast i8* %tzone6266 to %mzone*

; let assign value to symbol shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0
%dat_shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone6267, i64 8)
%shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr = bitcast i8* %dat_shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***
%tzone6004 = load i8*, i8** %_impzPtr
%zone6005 = bitcast i8* %tzone6004 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone6005, i64 4)
%iPtr = bitcast i8* %dat_i to i32*
%tzone6012 = load i8*, i8** %_impzPtr
%zone6013 = bitcast i8* %tzone6012 to %mzone*

; let assign value to symbol ca
%dat_ca = call i8* @llvm_zone_malloc(%mzone* %zone6013, i64 8)
%caPtr = bitcast i8* %dat_ca to float**
%tzone6020 = load i8*, i8** %_impzPtr
%zone6021 = bitcast i8* %tzone6020 to %mzone*

; let assign value to symbol la
%dat_la = call i8* @llvm_zone_malloc(%mzone* %zone6021, i64 8)
%laPtr = bitcast i8* %dat_la to float**
%tzone6028 = load i8*, i8** %_impzPtr
%zone6029 = bitcast i8* %tzone6028 to %mzone*

; let assign value to symbol qa
%dat_qa = call i8* @llvm_zone_malloc(%mzone* %zone6029, i64 8)
%qaPtr = bitcast i8* %dat_qa to float**
%tzone6036 = load i8*, i8** %_impzPtr
%zone6037 = bitcast i8* %tzone6036 to %mzone*

; let assign value to symbol sa
%dat_sa = call i8* @llvm_zone_malloc(%mzone* %zone6037, i64 8)
%saPtr = bitcast i8* %dat_sa to float**
%tzone6045 = load i8*, i8** %_impzPtr
%zone6046 = bitcast i8* %tzone6045 to %mzone*

; let assign value to symbol dir
%dat_dir = call i8* @llvm_zone_malloc(%mzone* %zone6046, i64 8)
%dirPtr = bitcast i8* %dat_dir to float**
%tzone6054 = load i8*, i8** %_impzPtr
%zone6055 = bitcast i8* %tzone6054 to %mzone*

; let assign value to symbol tmp
%dat_tmp = call i8* @llvm_zone_malloc(%mzone* %zone6055, i64 8)
%tmpPtr = bitcast i8* %dat_tmp to float**

; let value assignment
%i = select i1 true, i32 0, i32 0
store i32 %i, i32* %iPtr

%val6006 = getelementptr i64, i64* null, i32 1
%zonesize6007 = mul i64 4, 5
%tzone6008 = load i8*, i8** %_impzPtr
%zone6009 = bitcast i8* %tzone6008 to %mzone*
%dat6010 = call i8* @llvm_zone_malloc(%mzone* %zone6009, i64 %zonesize6007)
call i8* @memset(i8* %dat6010, i32 0, i64 %zonesize6007)
%val6011 = bitcast i8* %dat6010 to float*

; let value assignment
%ca = select i1 true, float* %val6011, float* %val6011
store float* %ca, float** %caPtr

%val6014 = getelementptr i64, i64* null, i32 1
%zonesize6015 = mul i64 4, 5
%tzone6016 = load i8*, i8** %_impzPtr
%zone6017 = bitcast i8* %tzone6016 to %mzone*
%dat6018 = call i8* @llvm_zone_malloc(%mzone* %zone6017, i64 %zonesize6015)
call i8* @memset(i8* %dat6018, i32 0, i64 %zonesize6015)
%val6019 = bitcast i8* %dat6018 to float*

; let value assignment
%la = select i1 true, float* %val6019, float* %val6019
store float* %la, float** %laPtr

%val6022 = getelementptr i64, i64* null, i32 1
%zonesize6023 = mul i64 4, 5
%tzone6024 = load i8*, i8** %_impzPtr
%zone6025 = bitcast i8* %tzone6024 to %mzone*
%dat6026 = call i8* @llvm_zone_malloc(%mzone* %zone6025, i64 %zonesize6023)
call i8* @memset(i8* %dat6026, i32 0, i64 %zonesize6023)
%val6027 = bitcast i8* %dat6026 to float*

; let value assignment
%qa = select i1 true, float* %val6027, float* %val6027
store float* %qa, float** %qaPtr

%val6030 = getelementptr i64, i64* null, i32 1
%zonesize6031 = mul i64 4, 5
%tzone6032 = load i8*, i8** %_impzPtr
%zone6033 = bitcast i8* %tzone6032 to %mzone*
%dat6034 = call i8* @llvm_zone_malloc(%mzone* %zone6033, i64 %zonesize6031)
call i8* @memset(i8* %dat6034, i32 0, i64 %zonesize6031)
%val6035 = bitcast i8* %dat6034 to float*

; let value assignment
%sa = select i1 true, float* %val6035, float* %val6035
store float* %sa, float** %saPtr

%val6038 = mul i64 5, 4
%val6039 = getelementptr i64, i64* null, i32 1
%zonesize6040 = mul i64 4, %val6038
%tzone6041 = load i8*, i8** %_impzPtr
%zone6042 = bitcast i8* %tzone6041 to %mzone*
%dat6043 = call i8* @llvm_zone_malloc(%mzone* %zone6042, i64 %zonesize6040)
call i8* @memset(i8* %dat6043, i32 0, i64 %zonesize6040)
%val6044 = bitcast i8* %dat6043 to float*

; let value assignment
%dir = select i1 true, float* %val6044, float* %val6044
store float* %dir, float** %dirPtr

%val6047 = mul i64 5, 4
%val6048 = getelementptr i64, i64* null, i32 1
%zonesize6049 = mul i64 4, %val6047
%tzone6050 = load i8*, i8** %_impzPtr
%zone6051 = bitcast i8* %tzone6050 to %mzone*
%dat6052 = call i8* @llvm_zone_malloc(%mzone* %zone6051, i64 %zonesize6049)
call i8* @memset(i8* %dat6052, i32 0, i64 %zonesize6049)
%val6053 = bitcast i8* %dat6052 to float*

; let value assignment
%tmp = select i1 true, float* %val6053, float* %val6053
store float* %tmp, float** %tmpPtr

; setup loop
store i32 0, i32* %iPtr
%val6066 = load i32, i32* %iPtr
%num6067 = add i32 5, %val6066
%comp6068 = icmp ult i32 5, 1
br i1 %comp6068, label %after6056, label %loop6056

loop6056:
%val6057 = load i32, i32* %iPtr
%val6058 = load float*, float** %caPtr
; set pointer
%val6059 = getelementptr float, float* %val6058, i32 %val6057
store float 0x3ff0000000000000, float* %val6059
%val6060 = load i32, i32* %iPtr
%val6061 = load float*, float** %laPtr
; set pointer
%val6062 = getelementptr float, float* %val6061, i32 %val6060
store float 0x0, float* %val6062
%val6063 = load i32, i32* %iPtr
%val6064 = load float*, float** %qaPtr
; set pointer
%val6065 = getelementptr float, float* %val6064, i32 %val6063
store float 0x0, float* %val6065
%loop_cnt6056 = load i32, i32* %iPtr
%next6056 = add i32 %loop_cnt6056, 1
store i32 %next6056, i32* %iPtr
%cmp6056 = icmp ult i32 %next6056, %num6067
br i1 %cmp6056, label %loop6056, label %after6056

after6056:
%tzone6263 = load i8*, i8** %_impzPtr
%zone6264 = bitcast i8* %tzone6263 to %mzone*

; let assign value to symbol _anon_lambda_3
%dat__anon_lambda_3 = call i8* @llvm_zone_malloc(%mzone* %zone6264, i64 8)
%_anon_lambda_3Ptr = bitcast i8* %dat__anon_lambda_3 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***
%tzone6204 = load i8*, i8** %_impzPtr
%zone6205 = bitcast i8* %tzone6204 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6205)
; malloc closure structure
%clsptr6206 = call i8* @llvm_zone_malloc(%mzone* %zone6205, i64 24)
%closure6207 = bitcast i8* %clsptr6206 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}*

; malloc environment structure
%envptr6208 = call i8* @llvm_zone_malloc(%mzone* %zone6205, i64 72)
%environment6209 = bitcast i8* %envptr6208 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}*

; malloc closure address table
%addytable6210 = call %clsvar* @new_address_table()
%var6211 = bitcast [127 x i8]* @gsxtmgraphics-pipeline232 to i8*
%var6212 = bitcast [109 x i8]* @gsxtmgraphics-pipeline233 to i8*
%addytable6213 = call %clsvar* @add_address_table(%mzone* %zone6205, i8* %var6211, i32 0, i8* %var6212, i32 3, %clsvar* %addytable6210)
%var6214 = bitcast [4 x i8]* @gsxtmgraphics-pipeline234 to i8*
%var6215 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable6216 = call %clsvar* @add_address_table(%mzone* %zone6205, i8* %var6214, i32 8, i8* %var6215, i32 3, %clsvar* %addytable6213)
%var6217 = bitcast [4 x i8]* @gsxtmgraphics-pipeline235 to i8*
%var6218 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable6219 = call %clsvar* @add_address_table(%mzone* %zone6205, i8* %var6217, i32 16, i8* %var6218, i32 3, %clsvar* %addytable6216)
%var6220 = bitcast [3 x i8]* @gsxtmgraphics-pipeline236 to i8*
%var6221 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable6222 = call %clsvar* @add_address_table(%mzone* %zone6205, i8* %var6220, i32 24, i8* %var6221, i32 3, %clsvar* %addytable6219)
%var6223 = bitcast [3 x i8]* @gsxtmgraphics-pipeline237 to i8*
%var6224 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable6225 = call %clsvar* @add_address_table(%mzone* %zone6205, i8* %var6223, i32 32, i8* %var6224, i32 3, %clsvar* %addytable6222)
%var6226 = bitcast [3 x i8]* @gsxtmgraphics-pipeline238 to i8*
%var6227 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable6228 = call %clsvar* @add_address_table(%mzone* %zone6205, i8* %var6226, i32 40, i8* %var6227, i32 3, %clsvar* %addytable6225)
%var6229 = bitcast [3 x i8]* @gsxtmgraphics-pipeline239 to i8*
%var6230 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable6231 = call %clsvar* @add_address_table(%mzone* %zone6205, i8* %var6229, i32 48, i8* %var6230, i32 3, %clsvar* %addytable6228)
%var6232 = bitcast [2 x i8]* @gsxtmgraphics-pipeline240 to i8*
%var6233 = bitcast [4 x i8]* @gsxtmgraphics-pipeline241 to i8*
%addytable6234 = call %clsvar* @add_address_table(%mzone* %zone6205, i8* %var6232, i32 56, i8* %var6233, i32 3, %clsvar* %addytable6231)
%var6235 = bitcast [15 x i8]* @gsxtmgraphics-pipeline242 to i8*
%var6236 = bitcast [109 x i8]* @gsxtmgraphics-pipeline233 to i8*
%addytable6237 = call %clsvar* @add_address_table(%mzone* %zone6205, i8* %var6235, i32 64, i8* %var6236, i32 3, %clsvar* %addytable6234)
%address-table6238 = bitcast %clsvar* %addytable6237 to i8*

; insert table, function and environment into closure struct
%closure.table6257 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}* %closure6207, i32 0, i32 0
store i8* %address-table6238, i8** %closure.table6257
%closure.env6258 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}* %closure6207, i32 0, i32 1
store i8* %envptr6208, i8** %closure.env6258
%closure.func6259 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}* %closure6207, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)* @shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0__6003, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)** %closure.func6259
%closure_size6260 = call i64 @llvm_zone_mark_size(%mzone* %zone6205)
call void @llvm_zone_ptr_set_size(i8* %clsptr6206, i64 %closure_size6260)
%wrapper_ptr6261 = call i8* @llvm_zone_malloc(%mzone* %zone6205, i64 8)
%closure_wrapper6262 = bitcast i8* %wrapper_ptr6261 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}* %closure6207, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}** %closure_wrapper6262

; let value assignment
%_anon_lambda_3 = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}** %closure_wrapper6262, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}** %closure_wrapper6262
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}** %_anon_lambda_3, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}*** %_anon_lambda_3Ptr

; add data to environment
; don't need to alloc for env var shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0
%tmp_envptr6240 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}* %environment6209, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}*** %shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}**** %tmp_envptr6240

; don't need to alloc for env var tmp
%tmp_envptr6242 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}* %environment6209, i32 0, i32 1
store float** %tmpPtr, float*** %tmp_envptr6242

; don't need to alloc for env var dir
%tmp_envptr6244 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}* %environment6209, i32 0, i32 2
store float** %dirPtr, float*** %tmp_envptr6244

; don't need to alloc for env var sa
%tmp_envptr6246 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}* %environment6209, i32 0, i32 3
store float** %saPtr, float*** %tmp_envptr6246

; don't need to alloc for env var qa
%tmp_envptr6248 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}* %environment6209, i32 0, i32 4
store float** %qaPtr, float*** %tmp_envptr6248

; don't need to alloc for env var la
%tmp_envptr6250 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}* %environment6209, i32 0, i32 5
store float** %laPtr, float*** %tmp_envptr6250

; don't need to alloc for env var ca
%tmp_envptr6252 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}* %environment6209, i32 0, i32 6
store float** %caPtr, float*** %tmp_envptr6252

; don't need to alloc for env var i
%tmp_envptr6254 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}* %environment6209, i32 0, i32 7
store i32* %iPtr, i32** %tmp_envptr6254

; don't need to alloc for env var _anon_lambda_3
%tmp_envptr6256 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***, float**, float**, float**, float**, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}***}* %environment6209, i32 0, i32 8
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}*** %_anon_lambda_3Ptr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}**** %tmp_envptr6256


%val6265 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}*** %_anon_lambda_3Ptr

; let value assignment
%shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 = select i1 true, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}** %val6265, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}** %val6265
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}** %shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}*** %shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr

%val6268 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}*** %shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}** %val6268
}


@shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}** @shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(%ShaderProgram* %arg_0,i32 %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float* %arg_5,float* %arg_6,float* %arg_7,float* %arg_8) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8)
ret void
}


define dllexport ccc void @shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_native(%ShaderProgram* %arg_0,i32 %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float* %arg_5,float* %arg_6,float* %arg_7,float* %arg_8) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8)
ret void
}


define dllexport ccc i8*  @shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6269 = bitcast [180 x i8]* @gsxtmgraphics-pipeline243 to i8*
call i32 (i8*, ...) @printf(i8* %var6269)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6270 = bitcast [180 x i8]* @gsxtmgraphics-pipeline243 to i8*
call i32 (i8*, ...) @printf(i8* %var6270)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var6271 = bitcast [180 x i8]* @gsxtmgraphics-pipeline243 to i8*
call i32 (i8*, ...) @printf(i8* %var6271)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var6272 = bitcast [180 x i8]* @gsxtmgraphics-pipeline243 to i8*
call i32 (i8*, ...) @printf(i8* %var6272)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var6273 = bitcast [180 x i8]* @gsxtmgraphics-pipeline243 to i8*
call i32 (i8*, ...) @printf(i8* %var6273)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var6274 = bitcast [180 x i8]* @gsxtmgraphics-pipeline243 to i8*
call i32 (i8*, ...) @printf(i8* %var6274)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to float*
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var6275 = bitcast [180 x i8]* @gsxtmgraphics-pipeline243 to i8*
call i32 (i8*, ...) @printf(i8* %var6275)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to float*
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_cptr(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var6276 = bitcast [180 x i8]* @gsxtmgraphics-pipeline243 to i8*
call i32 (i8*, ...) @printf(i8* %var6276)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%ttv_7 = call ccc i8* @cptr_value(i8* %arg_7_val)
%arg_7 = bitcast i8* %ttv_7 to float*
%arg_8_val = call ccc i8* @list_ref(i8* %_sc, i32 8,i8* %args)
%arg_8_rt_check = call i32 @is_cptr(i8* %arg_8_val)
%arg_8_bool = icmp ne i32 %arg_8_rt_check, 0
br i1 %arg_8_bool, label %arg_8_true, label %arg_8_false

arg_8_true:
br label %arg_8_continue

arg_8_false:
%var6277 = bitcast [180 x i8]* @gsxtmgraphics-pipeline243 to i8*
call i32 (i8*, ...) @printf(i8* %var6277)
%arg_8_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_8_errret

arg_8_continue:
%ttv_8 = call ccc i8* @cptr_value(i8* %arg_8_val)
%arg_8 = bitcast i8* %ttv_8 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*}*
%arg_p_0 = getelementptr {%ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*}, {%ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*}, {%ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*}, {%ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*}, {%ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {%ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*}, {%ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {%ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*}, {%ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*}* %fstruct, i32 0, i32 5
%arg_5 = load float*, float** %arg_p_5
%arg_p_6 = getelementptr {%ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*}, {%ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*}* %fstruct, i32 0, i32 6
%arg_6 = load float*, float** %arg_p_6
%arg_p_7 = getelementptr {%ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*}, {%ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*}* %fstruct, i32 0, i32 7
%arg_7 = load float*, float** %arg_p_7
%arg_p_8 = getelementptr {%ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*}, {%ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*}* %fstruct, i32 0, i32 8
%arg_8 = load float*, float** %arg_p_8
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, i32, float*, float*, float*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, i32 %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline244 = hidden constant [12 x i8] c"ModelMatrix\00"
@gsxtmgraphics-pipeline245 = hidden constant [11 x i8] c"ViewMatrix\00"
@gsxtmgraphics-pipeline246 = hidden constant [17 x i8] c"ProjectionMatrix\00"
@gsxtmgraphics-pipeline247 = hidden constant [13 x i8] c"NormalMatrix\00"
@gsxtmgraphics-pipeline248 = hidden constant [16 x i8] c"ModelViewMatrix\00"
@gsxtmgraphics-pipeline249 = hidden constant [26 x i8] c"ModelViewProjectionMatrix\00"
@gsxtmgraphics-pipeline250 = hidden constant [86 x i8] c"shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd\00"
@gsxtmgraphics-pipeline251 = hidden constant [72 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}**\00"
define dllexport fastcc void @shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd__6278(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, float* %m, float* %v, float* %p) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6279 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}***}*
%shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}**** %shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%mPtr = alloca float*
store float* %m, float** %mPtr
%vPtr = alloca float*
store float* %v, float** %vPtr
%pPtr = alloca float*
store float* %p, float** %pPtr


%tzone6281 = load i8*, i8** %_impzPtr
%zone6282 = bitcast i8* %tzone6281 to %mzone*

; let assign value to symbol mv
%mvPtr = alloca float*
%tzone6285 = load i8*, i8** %_impzPtr
%zone6286 = bitcast i8* %tzone6285 to %mzone*

; let assign value to symbol mvp
%mvpPtr = alloca float*
%tzone6289 = load i8*, i8** %_impzPtr
%zone6290 = bitcast i8* %tzone6289 to %mzone*

; let assign value to symbol mn
%mnPtr = alloca float*
%dat6280 = alloca float, i64 48, align 16

; let value assignment
%mv = select i1 true, float* %dat6280, float* %dat6280
store float* %mv, float** %mvPtr

%val6283 = load float*, float** %mvPtr
; pointer ref
%val6284 = getelementptr float, float* %val6283, i64 16

; let value assignment
%mvp = select i1 true, float* %val6284, float* %val6284
store float* %mvp, float** %mvpPtr

%val6287 = load float*, float** %mvPtr
; pointer ref
%val6288 = getelementptr float, float* %val6287, i64 32

; let value assignment
%mn = select i1 true, float* %val6288, float* %val6288
store float* %mn, float** %mnPtr

%val6291 = load float*, float** %mPtr
%val6292 = load float*, float** %vPtr
%val6293 = load float*, float** %mvPtr
%res6294 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val6291, float* %val6292, float* %val6293)
%val6295 = load float*, float** %mvPtr
%val6296 = load float*, float** %mnPtr
%res6297 = call fastcc float* @mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd(float* %val6295, i64 4, i64 4, float* %val6296)
%val6298 = load float*, float** %mnPtr
%val6299 = load float*, float** %mvpPtr
call fastcc void @minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd(float* %val6298, i64 4, float* %val6299)
%val6301 = load float*, float** %mvpPtr
%val6302 = load float*, float** %mnPtr
call fastcc void @mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0(float* %val6301, float* %val6302)
%val6304 = load float*, float** %mvPtr
%val6305 = load float*, float** %pPtr
%val6306 = load float*, float** %mvpPtr
%res6307 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val6304, float* %val6305, float* %val6306)
%val6308 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6309 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6308)
%var6310 = bitcast [12 x i8]* @gsxtmgraphics-pipeline244 to i8*
%res6311 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6309, i8* %var6310)
%val6312 = load i8, i8* @GL_FALSE
%val6313 = load float*, float** %mPtr
call fastcc void @glUniformMatrix4fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res6311, i32 1, i8 %val6312, float* %val6313)
%val6315 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6316 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6315)
%var6317 = bitcast [11 x i8]* @gsxtmgraphics-pipeline245 to i8*
%res6318 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6316, i8* %var6317)
%val6319 = load i8, i8* @GL_FALSE
%val6320 = load float*, float** %vPtr
call fastcc void @glUniformMatrix4fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res6318, i32 1, i8 %val6319, float* %val6320)
%val6322 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6323 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6322)
%var6324 = bitcast [17 x i8]* @gsxtmgraphics-pipeline246 to i8*
%res6325 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6323, i8* %var6324)
%val6326 = load i8, i8* @GL_FALSE
%val6327 = load float*, float** %pPtr
call fastcc void @glUniformMatrix4fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res6325, i32 1, i8 %val6326, float* %val6327)
%val6329 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6330 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6329)
%var6331 = bitcast [13 x i8]* @gsxtmgraphics-pipeline247 to i8*
%res6332 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6330, i8* %var6331)
%val6333 = load i8, i8* @GL_FALSE
%val6334 = load float*, float** %mnPtr
call fastcc void @glUniformMatrix3fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res6332, i32 1, i8 %val6333, float* %val6334)
%val6336 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6337 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6336)
%var6338 = bitcast [16 x i8]* @gsxtmgraphics-pipeline248 to i8*
%res6339 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6337, i8* %var6338)
%val6340 = load i8, i8* @GL_FALSE
%val6341 = load float*, float** %mvPtr
call fastcc void @glUniformMatrix4fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res6339, i32 1, i8 %val6340, float* %val6341)
%val6343 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6344 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6343)
%var6345 = bitcast [26 x i8]* @gsxtmgraphics-pipeline249 to i8*
%res6346 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6344, i8* %var6345)
%val6347 = load i8, i8* @GL_FALSE
%val6348 = load float*, float** %mvpPtr
call fastcc void @glUniformMatrix4fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res6346, i32 1, i8 %val6347, float* %val6348)
ret void
}
@gsxtmgraphics-pipeline252 = hidden constant [139 x i8] c"shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** @shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6370 = load i8*, i8** %_impzPtr
%zone6371 = bitcast i8* %tzone6370 to %mzone*

; let assign value to symbol shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd
%dat_shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd = call i8* @llvm_zone_malloc(%mzone* %zone6371, i64 8)
%shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr = bitcast i8* %dat_shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}***
%tzone6351 = load i8*, i8** %_impzPtr
%zone6352 = bitcast i8* %tzone6351 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6352)
; malloc closure structure
%clsptr6353 = call i8* @llvm_zone_malloc(%mzone* %zone6352, i64 24)
%closure6354 = bitcast i8* %clsptr6353 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}*

; malloc environment structure
%envptr6355 = call i8* @llvm_zone_malloc(%mzone* %zone6352, i64 8)
%environment6356 = bitcast i8* %envptr6355 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}***}*

; malloc closure address table
%addytable6357 = call %clsvar* @new_address_table()
%var6358 = bitcast [86 x i8]* @gsxtmgraphics-pipeline250 to i8*
%var6359 = bitcast [72 x i8]* @gsxtmgraphics-pipeline251 to i8*
%addytable6360 = call %clsvar* @add_address_table(%mzone* %zone6352, i8* %var6358, i32 0, i8* %var6359, i32 3, %clsvar* %addytable6357)
%address-table6361 = bitcast %clsvar* %addytable6360 to i8*

; insert table, function and environment into closure struct
%closure.table6364 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure6354, i32 0, i32 0
store i8* %address-table6361, i8** %closure.table6364
%closure.env6365 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure6354, i32 0, i32 1
store i8* %envptr6355, i8** %closure.env6365
%closure.func6366 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure6354, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, float*, float*, float*)* @shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd__6278, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)** %closure.func6366
%closure_size6367 = call i64 @llvm_zone_mark_size(%mzone* %zone6352)
call void @llvm_zone_ptr_set_size(i8* %clsptr6353, i64 %closure_size6367)
%wrapper_ptr6368 = call i8* @llvm_zone_malloc(%mzone* %zone6352, i64 8)
%closure_wrapper6369 = bitcast i8* %wrapper_ptr6368 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure6354, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** %closure_wrapper6369

; let value assignment
%shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** %closure_wrapper6369, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** %closure_wrapper6369
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** %shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}*** %shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr

; add data to environment
; don't need to alloc for env var shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd
%tmp_envptr6363 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}***}* %environment6356, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}*** %shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}**** %tmp_envptr6363


%val6372 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}*** %shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** %val6372
}


@shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** @shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd(%ShaderProgram* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
ret void
}


define dllexport ccc void @shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_native(%ShaderProgram* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
ret void
}


define dllexport ccc i8*  @shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6373 = bitcast [139 x i8]* @gsxtmgraphics-pipeline252 to i8*
call i32 (i8*, ...) @printf(i8* %var6373)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6374 = bitcast [139 x i8]* @gsxtmgraphics-pipeline252 to i8*
call i32 (i8*, ...) @printf(i8* %var6374)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var6375 = bitcast [139 x i8]* @gsxtmgraphics-pipeline252 to i8*
call i32 (i8*, ...) @printf(i8* %var6375)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var6376 = bitcast [139 x i8]* @gsxtmgraphics-pipeline252 to i8*
call i32 (i8*, ...) @printf(i8* %var6376)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, float*, float*, float*}*
%arg_p_0 = getelementptr {%ShaderProgram*, float*, float*, float*}, {%ShaderProgram*, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, float*, float*, float*}, {%ShaderProgram*, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, float*, float*, float*}, {%ShaderProgram*, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%ShaderProgram*, float*, float*, float*}, {%ShaderProgram*, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline253 = hidden constant [9 x i8] c"UVMatrix\00"
@gsxtmgraphics-pipeline254 = hidden constant [69 x i8] c"shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ\00"
@gsxtmgraphics-pipeline255 = hidden constant [56 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}**\00"
define dllexport fastcc void @shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ__6377(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, float* %uvmat) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6378 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}***}*
%shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}***}* %impenv, i32 0, i32 0
%shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}**** %shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQPtr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%uvmatPtr = alloca float*
store float* %uvmat, float** %uvmatPtr


%val6379 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6380 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6379)
%var6381 = bitcast [9 x i8]* @gsxtmgraphics-pipeline253 to i8*
%res6382 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6380, i8* %var6381)
%val6383 = load i8, i8* @GL_FALSE
%val6384 = load float*, float** %uvmatPtr
call fastcc void @glUniformMatrix4fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res6382, i32 1, i8 %val6383, float* %val6384)
ret void
}
@gsxtmgraphics-pipeline256 = hidden constant [122 x i8] c"shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** @shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6406 = load i8*, i8** %_impzPtr
%zone6407 = bitcast i8* %tzone6406 to %mzone*

; let assign value to symbol shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ
%dat_shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone6407, i64 8)
%shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQPtr = bitcast i8* %dat_shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}***
%tzone6387 = load i8*, i8** %_impzPtr
%zone6388 = bitcast i8* %tzone6387 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6388)
; malloc closure structure
%clsptr6389 = call i8* @llvm_zone_malloc(%mzone* %zone6388, i64 24)
%closure6390 = bitcast i8* %clsptr6389 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}*

; malloc environment structure
%envptr6391 = call i8* @llvm_zone_malloc(%mzone* %zone6388, i64 8)
%environment6392 = bitcast i8* %envptr6391 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}***}*

; malloc closure address table
%addytable6393 = call %clsvar* @new_address_table()
%var6394 = bitcast [69 x i8]* @gsxtmgraphics-pipeline254 to i8*
%var6395 = bitcast [56 x i8]* @gsxtmgraphics-pipeline255 to i8*
%addytable6396 = call %clsvar* @add_address_table(%mzone* %zone6388, i8* %var6394, i32 0, i8* %var6395, i32 3, %clsvar* %addytable6393)
%address-table6397 = bitcast %clsvar* %addytable6396 to i8*

; insert table, function and environment into closure struct
%closure.table6400 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure6390, i32 0, i32 0
store i8* %address-table6397, i8** %closure.table6400
%closure.env6401 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure6390, i32 0, i32 1
store i8* %envptr6391, i8** %closure.env6401
%closure.func6402 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure6390, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, float*)* @shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ__6377, void (i8*, i8*, %ShaderProgram*, float*)** %closure.func6402
%closure_size6403 = call i64 @llvm_zone_mark_size(%mzone* %zone6388)
call void @llvm_zone_ptr_set_size(i8* %clsptr6389, i64 %closure_size6403)
%wrapper_ptr6404 = call i8* @llvm_zone_malloc(%mzone* %zone6388, i64 8)
%closure_wrapper6405 = bitcast i8* %wrapper_ptr6404 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure6390, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** %closure_wrapper6405

; let value assignment
%shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** %closure_wrapper6405, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** %closure_wrapper6405
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** %shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}*** %shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQPtr

; add data to environment
; don't need to alloc for env var shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ
%tmp_envptr6399 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}***}* %environment6392, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}*** %shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}**** %tmp_envptr6399


%val6408 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}*** %shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** %val6408
}


@shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** @shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ(%ShaderProgram* %arg_0,float* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1)
ret void
}


define dllexport ccc void @shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_native(%ShaderProgram* %arg_0,float* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1)
ret void
}


define dllexport ccc i8*  @shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6409 = bitcast [122 x i8]* @gsxtmgraphics-pipeline256 to i8*
call i32 (i8*, ...) @printf(i8* %var6409)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6410 = bitcast [122 x i8]* @gsxtmgraphics-pipeline256 to i8*
call i32 (i8*, ...) @printf(i8* %var6410)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, float*}*
%arg_p_0 = getelementptr {%ShaderProgram*, float*}, {%ShaderProgram*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, float*}, {%ShaderProgram*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline257 = hidden constant [31 x i8] c"LightModelViewProjectionMatrix\00"
@gsxtmgraphics-pipeline258 = hidden constant [99 x i8] c"shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ\00"
@gsxtmgraphics-pipeline259 = hidden constant [80 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}**\00"
@gsxtmgraphics-pipeline260 = hidden constant [5 x i8] c"bias\00"
@gsxtmgraphics-pipeline261 = hidden constant [15 x i8] c"_anon_lambda_4\00"
define dllexport fastcc void @shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ__6411(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, float* %m, float* %v, float* %p, float* %lv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6452 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***}*
%shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}**** %shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_
%biasPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 1
%biasPtr = load float**, float*** %biasPtr_
%_anon_lambda_4Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_4Ptr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}**** %_anon_lambda_4Ptr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%mPtr = alloca float*
store float* %m, float** %mPtr
%vPtr = alloca float*
store float* %v, float** %vPtr
%pPtr = alloca float*
store float* %p, float** %pPtr
%lvPtr = alloca float*
store float* %lv, float** %lvPtr


%tzone6454 = load i8*, i8** %_impzPtr
%zone6455 = bitcast i8* %tzone6454 to %mzone*

; let assign value to symbol mlv
%mlvPtr = alloca float*
%tzone6457 = load i8*, i8** %_impzPtr
%zone6458 = bitcast i8* %tzone6457 to %mzone*

; let assign value to symbol mlvp
%mlvpPtr = alloca float*
%tzone6460 = load i8*, i8** %_impzPtr
%zone6461 = bitcast i8* %tzone6460 to %mzone*

; let assign value to symbol mlvpb
%mlvpbPtr = alloca float*
%dat6453 = alloca float, i64 16, align 16

; let value assignment
%mlv = select i1 true, float* %dat6453, float* %dat6453
store float* %mlv, float** %mlvPtr

%dat6456 = alloca float, i64 16, align 16

; let value assignment
%mlvp = select i1 true, float* %dat6456, float* %dat6456
store float* %mlvp, float** %mlvpPtr

%dat6459 = alloca float, i64 16, align 16

; let value assignment
%mlvpb = select i1 true, float* %dat6459, float* %dat6459
store float* %mlvpb, float** %mlvpbPtr

%val6462 = load float*, float** %mPtr
%val6463 = load float*, float** %lvPtr
%val6464 = load float*, float** %mlvPtr
%res6465 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val6462, float* %val6463, float* %val6464)
%val6466 = load float*, float** %mlvPtr
%val6467 = load float*, float** %pPtr
%val6468 = load float*, float** %mlvpPtr
%res6469 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val6466, float* %val6467, float* %val6468)
%val6470 = load float*, float** %mlvpPtr
%val6471 = load float*, float** %biasPtr
%val6472 = load float*, float** %mlvpbPtr
%res6473 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val6470, float* %val6471, float* %val6472)
%val6474 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6475 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6474)
%var6476 = bitcast [31 x i8]* @gsxtmgraphics-pipeline257 to i8*
%res6477 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6475, i8* %var6476)
%val6478 = load i8, i8* @GL_FALSE
%val6479 = load float*, float** %mlvpbPtr
call fastcc void @glUniformMatrix4fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res6477, i32 1, i8 %val6478, float* %val6479)
%tzone6482 = load i8*, i8** %_impzPtr
%zone6483 = bitcast i8* %tzone6482 to %mzone*

; let assign value to symbol mv
%mvPtr = alloca float*
%tzone6486 = load i8*, i8** %_impzPtr
%zone6487 = bitcast i8* %tzone6486 to %mzone*

; let assign value to symbol mvp
%mvpPtr = alloca float*
%tzone6490 = load i8*, i8** %_impzPtr
%zone6491 = bitcast i8* %tzone6490 to %mzone*

; let assign value to symbol mn
%mnPtr = alloca float*
%dat6481 = alloca float, i64 48, align 16

; let value assignment
%mv = select i1 true, float* %dat6481, float* %dat6481
store float* %mv, float** %mvPtr

%val6484 = load float*, float** %mvPtr
; pointer ref
%val6485 = getelementptr float, float* %val6484, i64 16

; let value assignment
%mvp = select i1 true, float* %val6485, float* %val6485
store float* %mvp, float** %mvpPtr

%val6488 = load float*, float** %mvPtr
; pointer ref
%val6489 = getelementptr float, float* %val6488, i64 32

; let value assignment
%mn = select i1 true, float* %val6489, float* %val6489
store float* %mn, float** %mnPtr

%val6492 = load float*, float** %mPtr
%val6493 = load float*, float** %vPtr
%val6494 = load float*, float** %mvPtr
%res6495 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val6492, float* %val6493, float* %val6494)
%val6496 = load float*, float** %mvPtr
%val6497 = load float*, float** %mnPtr
%res6498 = call fastcc float* @mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd(float* %val6496, i64 4, i64 4, float* %val6497)
%val6499 = load float*, float** %mnPtr
%val6500 = load float*, float** %mvpPtr
call fastcc void @minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd(float* %val6499, i64 4, float* %val6500)
%val6502 = load float*, float** %mvpPtr
%val6503 = load float*, float** %mnPtr
call fastcc void @mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0(float* %val6502, float* %val6503)
%val6505 = load float*, float** %mvPtr
%val6506 = load float*, float** %pPtr
%val6507 = load float*, float** %mvpPtr
%res6508 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val6505, float* %val6506, float* %val6507)
%val6509 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6510 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6509)
%var6511 = bitcast [12 x i8]* @gsxtmgraphics-pipeline244 to i8*
%res6512 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6510, i8* %var6511)
%val6513 = load i8, i8* @GL_FALSE
%val6514 = load float*, float** %mPtr
call fastcc void @glUniformMatrix4fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res6512, i32 1, i8 %val6513, float* %val6514)
%val6516 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6517 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6516)
%var6518 = bitcast [11 x i8]* @gsxtmgraphics-pipeline245 to i8*
%res6519 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6517, i8* %var6518)
%val6520 = load i8, i8* @GL_FALSE
%val6521 = load float*, float** %vPtr
call fastcc void @glUniformMatrix4fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res6519, i32 1, i8 %val6520, float* %val6521)
%val6523 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6524 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6523)
%var6525 = bitcast [17 x i8]* @gsxtmgraphics-pipeline246 to i8*
%res6526 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6524, i8* %var6525)
%val6527 = load i8, i8* @GL_FALSE
%val6528 = load float*, float** %pPtr
call fastcc void @glUniformMatrix4fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res6526, i32 1, i8 %val6527, float* %val6528)
%val6530 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6531 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6530)
%var6532 = bitcast [13 x i8]* @gsxtmgraphics-pipeline247 to i8*
%res6533 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6531, i8* %var6532)
%val6534 = load i8, i8* @GL_FALSE
%val6535 = load float*, float** %mnPtr
call fastcc void @glUniformMatrix3fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res6533, i32 1, i8 %val6534, float* %val6535)
%val6537 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6538 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6537)
%var6539 = bitcast [16 x i8]* @gsxtmgraphics-pipeline248 to i8*
%res6540 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6538, i8* %var6539)
%val6541 = load i8, i8* @GL_FALSE
%val6542 = load float*, float** %mvPtr
call fastcc void @glUniformMatrix4fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res6540, i32 1, i8 %val6541, float* %val6542)
%val6544 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6545 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6544)
%var6546 = bitcast [26 x i8]* @gsxtmgraphics-pipeline249 to i8*
%res6547 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6545, i8* %var6546)
%val6548 = load i8, i8* @GL_FALSE
%val6549 = load float*, float** %mvpPtr
call fastcc void @glUniformMatrix4fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res6547, i32 1, i8 %val6548, float* %val6549)
ret void
}
@gsxtmgraphics-pipeline262 = hidden constant [152 x i8] c"shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}** @shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6584 = load i8*, i8** %_impzPtr
%zone6585 = bitcast i8* %tzone6584 to %mzone*

; let assign value to symbol shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%dat_shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone6585, i64 8)
%shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = bitcast i8* %dat_shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***
%tzone6418 = load i8*, i8** %_impzPtr
%zone6419 = bitcast i8* %tzone6418 to %mzone*

; let assign value to symbol bias
%dat_bias = call i8* @llvm_zone_malloc(%mzone* %zone6419, i64 8)
%biasPtr = bitcast i8* %dat_bias to float**
%val6412 = getelementptr i64, i64* null, i32 1
%zonesize6413 = mul i64 4, 16
%tzone6414 = load i8*, i8** %_impzPtr
%zone6415 = bitcast i8* %tzone6414 to %mzone*
%dat6416 = call i8* @llvm_zone_malloc(%mzone* %zone6415, i64 %zonesize6413)
call i8* @memset(i8* %dat6416, i32 0, i64 %zonesize6413)
%val6417 = bitcast i8* %dat6416 to float*

; let value assignment
%bias = select i1 true, float* %val6417, float* %val6417
store float* %bias, float** %biasPtr

%val6420 = load float*, float** %biasPtr
; set pointer
%val6421 = getelementptr float, float* %val6420, i64 0
store float 0x3fe0000000000000, float* %val6421
%val6422 = load float*, float** %biasPtr
; set pointer
%val6423 = getelementptr float, float* %val6422, i64 1
store float 0x0, float* %val6423
%val6424 = load float*, float** %biasPtr
; set pointer
%val6425 = getelementptr float, float* %val6424, i64 2
store float 0x0, float* %val6425
%val6426 = load float*, float** %biasPtr
; set pointer
%val6427 = getelementptr float, float* %val6426, i64 3
store float 0x0, float* %val6427
%val6428 = load float*, float** %biasPtr
; set pointer
%val6429 = getelementptr float, float* %val6428, i64 4
store float 0x0, float* %val6429
%val6430 = load float*, float** %biasPtr
; set pointer
%val6431 = getelementptr float, float* %val6430, i64 5
store float 0x3fe0000000000000, float* %val6431
%val6432 = load float*, float** %biasPtr
; set pointer
%val6433 = getelementptr float, float* %val6432, i64 6
store float 0x0, float* %val6433
%val6434 = load float*, float** %biasPtr
; set pointer
%val6435 = getelementptr float, float* %val6434, i64 7
store float 0x0, float* %val6435
%val6436 = load float*, float** %biasPtr
; set pointer
%val6437 = getelementptr float, float* %val6436, i64 8
store float 0x0, float* %val6437
%val6438 = load float*, float** %biasPtr
; set pointer
%val6439 = getelementptr float, float* %val6438, i64 9
store float 0x0, float* %val6439
%val6440 = load float*, float** %biasPtr
; set pointer
%val6441 = getelementptr float, float* %val6440, i64 10
store float 0x3fe0000000000000, float* %val6441
%val6442 = load float*, float** %biasPtr
; set pointer
%val6443 = getelementptr float, float* %val6442, i64 11
store float 0x0, float* %val6443
%val6444 = load float*, float** %biasPtr
; set pointer
%val6445 = getelementptr float, float* %val6444, i64 12
store float 0x3fe0000000000000, float* %val6445
%val6446 = load float*, float** %biasPtr
; set pointer
%val6447 = getelementptr float, float* %val6446, i64 13
store float 0x3fe0000000000000, float* %val6447
%val6448 = load float*, float** %biasPtr
; set pointer
%val6449 = getelementptr float, float* %val6448, i64 14
store float 0x3fe0000000000000, float* %val6449
%val6450 = load float*, float** %biasPtr
; set pointer
%val6451 = getelementptr float, float* %val6450, i64 15
store float 0x3ff0000000000000, float* %val6451
%tzone6581 = load i8*, i8** %_impzPtr
%zone6582 = bitcast i8* %tzone6581 to %mzone*

; let assign value to symbol _anon_lambda_4
%dat__anon_lambda_4 = call i8* @llvm_zone_malloc(%mzone* %zone6582, i64 8)
%_anon_lambda_4Ptr = bitcast i8* %dat__anon_lambda_4 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***
%tzone6552 = load i8*, i8** %_impzPtr
%zone6553 = bitcast i8* %tzone6552 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6553)
; malloc closure structure
%clsptr6554 = call i8* @llvm_zone_malloc(%mzone* %zone6553, i64 24)
%closure6555 = bitcast i8* %clsptr6554 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}*

; malloc environment structure
%envptr6556 = call i8* @llvm_zone_malloc(%mzone* %zone6553, i64 24)
%environment6557 = bitcast i8* %envptr6556 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***}*

; malloc closure address table
%addytable6558 = call %clsvar* @new_address_table()
%var6559 = bitcast [99 x i8]* @gsxtmgraphics-pipeline258 to i8*
%var6560 = bitcast [80 x i8]* @gsxtmgraphics-pipeline259 to i8*
%addytable6561 = call %clsvar* @add_address_table(%mzone* %zone6553, i8* %var6559, i32 0, i8* %var6560, i32 3, %clsvar* %addytable6558)
%var6562 = bitcast [5 x i8]* @gsxtmgraphics-pipeline260 to i8*
%var6563 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable6564 = call %clsvar* @add_address_table(%mzone* %zone6553, i8* %var6562, i32 8, i8* %var6563, i32 3, %clsvar* %addytable6561)
%var6565 = bitcast [15 x i8]* @gsxtmgraphics-pipeline261 to i8*
%var6566 = bitcast [80 x i8]* @gsxtmgraphics-pipeline259 to i8*
%addytable6567 = call %clsvar* @add_address_table(%mzone* %zone6553, i8* %var6565, i32 16, i8* %var6566, i32 3, %clsvar* %addytable6564)
%address-table6568 = bitcast %clsvar* %addytable6567 to i8*

; insert table, function and environment into closure struct
%closure.table6575 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}* %closure6555, i32 0, i32 0
store i8* %address-table6568, i8** %closure.table6575
%closure.env6576 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}* %closure6555, i32 0, i32 1
store i8* %envptr6556, i8** %closure.env6576
%closure.func6577 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}* %closure6555, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)* @shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ__6411, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)** %closure.func6577
%closure_size6578 = call i64 @llvm_zone_mark_size(%mzone* %zone6553)
call void @llvm_zone_ptr_set_size(i8* %clsptr6554, i64 %closure_size6578)
%wrapper_ptr6579 = call i8* @llvm_zone_malloc(%mzone* %zone6553, i64 8)
%closure_wrapper6580 = bitcast i8* %wrapper_ptr6579 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}* %closure6555, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}** %closure_wrapper6580

; let value assignment
%_anon_lambda_4 = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}** %closure_wrapper6580, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}** %closure_wrapper6580
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}** %_anon_lambda_4, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}*** %_anon_lambda_4Ptr

; add data to environment
; don't need to alloc for env var shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%tmp_envptr6570 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***}* %environment6557, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}*** %shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}**** %tmp_envptr6570

; don't need to alloc for env var bias
%tmp_envptr6572 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***}* %environment6557, i32 0, i32 1
store float** %biasPtr, float*** %tmp_envptr6572

; don't need to alloc for env var _anon_lambda_4
%tmp_envptr6574 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}***}* %environment6557, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}*** %_anon_lambda_4Ptr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}**** %tmp_envptr6574


%val6583 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}*** %_anon_lambda_4Ptr

; let value assignment
%shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ = select i1 true, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}** %val6583, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}** %val6583
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}** %shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}*** %shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr

%val6586 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}*** %shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}** %val6586
}


@shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}** @shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ(%ShaderProgram* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4)
ret void
}


define dllexport ccc void @shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_native(%ShaderProgram* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4)
ret void
}


define dllexport ccc i8*  @shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6587 = bitcast [152 x i8]* @gsxtmgraphics-pipeline262 to i8*
call i32 (i8*, ...) @printf(i8* %var6587)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6588 = bitcast [152 x i8]* @gsxtmgraphics-pipeline262 to i8*
call i32 (i8*, ...) @printf(i8* %var6588)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var6589 = bitcast [152 x i8]* @gsxtmgraphics-pipeline262 to i8*
call i32 (i8*, ...) @printf(i8* %var6589)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var6590 = bitcast [152 x i8]* @gsxtmgraphics-pipeline262 to i8*
call i32 (i8*, ...) @printf(i8* %var6590)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var6591 = bitcast [152 x i8]* @gsxtmgraphics-pipeline262 to i8*
call i32 (i8*, ...) @printf(i8* %var6591)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, float*, float*, float*, float*}*
%arg_p_0 = getelementptr {%ShaderProgram*, float*, float*, float*, float*}, {%ShaderProgram*, float*, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, float*, float*, float*, float*}, {%ShaderProgram*, float*, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, float*, float*, float*, float*}, {%ShaderProgram*, float*, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%ShaderProgram*, float*, float*, float*, float*}, {%ShaderProgram*, float*, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {%ShaderProgram*, float*, float*, float*, float*}, {%ShaderProgram*, float*, float*, float*, float*}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_matrices_lv_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline263 = hidden constant [105 x i8] c"shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0\00"
@gsxtmgraphics-pipeline264 = hidden constant [85 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}**\00"
@gsxtmgraphics-pipeline265 = hidden constant [6 x i8] c"mlvpb\00"
@gsxtmgraphics-pipeline266 = hidden constant [15 x i8] c"_anon_lambda_5\00"
define dllexport fastcc void @shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0__6592(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, float* %m, float* %v, float* %p, i32 %lights, float* %lv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6644 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}*
%shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}* %impenv, i32 0, i32 0
%shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0Ptr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}**** %shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0Ptr_
%biasPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}* %impenv, i32 0, i32 1
%biasPtr = load float**, float*** %biasPtr_
%mlvpbPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}* %impenv, i32 0, i32 2
%mlvpbPtr = load float**, float*** %mlvpbPtr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}* %impenv, i32 0, i32 3
%iPtr = load i32*, i32** %iPtr_
%_anon_lambda_5Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}* %impenv, i32 0, i32 4
%_anon_lambda_5Ptr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}**** %_anon_lambda_5Ptr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%mPtr = alloca float*
store float* %m, float** %mPtr
%vPtr = alloca float*
store float* %v, float** %vPtr
%pPtr = alloca float*
store float* %p, float** %pPtr
%lightsPtr = alloca i32
store i32 %lights, i32* %lightsPtr
%lvPtr = alloca float*
store float* %lv, float** %lvPtr


; setup loop
%val6647 = load i32, i32* %lightsPtr
store i32 0, i32* %iPtr
%val6672 = load i32, i32* %iPtr
%num6673 = add i32 %val6647, %val6672
%comp6674 = icmp ult i32 %val6647, 1
br i1 %comp6674, label %after6645, label %loop6645

loop6645:
%tzone6649 = load i8*, i8** %_impzPtr
%zone6650 = bitcast i8* %tzone6649 to %mzone*

; let assign value to symbol mlv
%mlvPtr = alloca float*
%tzone6652 = load i8*, i8** %_impzPtr
%zone6653 = bitcast i8* %tzone6652 to %mzone*

; let assign value to symbol mlvp
%mlvpPtr = alloca float*
%dat6648 = alloca float, i64 16, align 16

; let value assignment
%mlv = select i1 true, float* %dat6648, float* %dat6648
store float* %mlv, float** %mlvPtr

%dat6651 = alloca float, i64 16, align 16

; let value assignment
%mlvp = select i1 true, float* %dat6651, float* %dat6651
store float* %mlvp, float** %mlvpPtr

%val6654 = load float*, float** %mPtr
%val6655 = load i32, i32* %iPtr
%val6656 = mul i32 %val6655, 16
%val6657 = load float*, float** %lvPtr
; pointer ref
%val6658 = getelementptr float, float* %val6657, i32 %val6656
%val6659 = load float*, float** %mlvPtr
%res6660 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val6654, float* %val6658, float* %val6659)
%val6661 = load float*, float** %mlvPtr
%val6662 = load float*, float** %pPtr
%val6663 = load float*, float** %mlvpPtr
%res6664 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val6661, float* %val6662, float* %val6663)
%val6665 = load float*, float** %mlvpPtr
%val6666 = load float*, float** %biasPtr
%val6667 = load i32, i32* %iPtr
%val6668 = mul i32 %val6667, 16
%val6669 = load float*, float** %mlvpbPtr
; pointer ref
%val6670 = getelementptr float, float* %val6669, i32 %val6668
%res6671 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val6665, float* %val6666, float* %val6670)
%loop_cnt6645 = load i32, i32* %iPtr
%next6645 = add i32 %loop_cnt6645, 1
store i32 %next6645, i32* %iPtr
%cmp6645 = icmp ult i32 %next6645, %num6673
br i1 %cmp6645, label %loop6645, label %after6645

after6645:
%val6676 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6677 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6676)
%var6678 = bitcast [31 x i8]* @gsxtmgraphics-pipeline257 to i8*
%res6679 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6677, i8* %var6678)
%val6680 = load i32, i32* %lightsPtr
%val6681 = load i8, i8* @GL_FALSE
%val6682 = load float*, float** %mlvpbPtr
call fastcc void @glUniformMatrix4fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res6679, i32 %val6680, i8 %val6681, float* %val6682)
%tzone6685 = load i8*, i8** %_impzPtr
%zone6686 = bitcast i8* %tzone6685 to %mzone*

; let assign value to symbol mv
%mvPtr = alloca float*
%tzone6689 = load i8*, i8** %_impzPtr
%zone6690 = bitcast i8* %tzone6689 to %mzone*

; let assign value to symbol mvp
%mvpPtr = alloca float*
%tzone6693 = load i8*, i8** %_impzPtr
%zone6694 = bitcast i8* %tzone6693 to %mzone*

; let assign value to symbol mn
%mnPtr = alloca float*
%dat6684 = alloca float, i64 48, align 16

; let value assignment
%mv = select i1 true, float* %dat6684, float* %dat6684
store float* %mv, float** %mvPtr

%val6687 = load float*, float** %mvPtr
; pointer ref
%val6688 = getelementptr float, float* %val6687, i64 16

; let value assignment
%mvp = select i1 true, float* %val6688, float* %val6688
store float* %mvp, float** %mvpPtr

%val6691 = load float*, float** %mvPtr
; pointer ref
%val6692 = getelementptr float, float* %val6691, i64 32

; let value assignment
%mn = select i1 true, float* %val6692, float* %val6692
store float* %mn, float** %mnPtr

%val6695 = load float*, float** %mPtr
%val6696 = load float*, float** %vPtr
%val6697 = load float*, float** %mvPtr
%res6698 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val6695, float* %val6696, float* %val6697)
%val6699 = load float*, float** %mvPtr
%val6700 = load float*, float** %mnPtr
%res6701 = call fastcc float* @mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd(float* %val6699, i64 4, i64 4, float* %val6700)
%val6702 = load float*, float** %mnPtr
%val6703 = load float*, float** %mvpPtr
call fastcc void @minverse_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxmbG9hdCpd(float* %val6702, i64 4, float* %val6703)
%val6705 = load float*, float** %mvpPtr
%val6706 = load float*, float** %mnPtr
call fastcc void @mat4_to_mat3_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0Kl0(float* %val6705, float* %val6706)
%val6708 = load float*, float** %mvPtr
%val6709 = load float*, float** %pPtr
%val6710 = load float*, float** %mvpPtr
%res6711 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val6708, float* %val6709, float* %val6710)
%val6712 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6713 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6712)
%var6714 = bitcast [12 x i8]* @gsxtmgraphics-pipeline244 to i8*
%res6715 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6713, i8* %var6714)
%val6716 = load i8, i8* @GL_FALSE
%val6717 = load float*, float** %mPtr
call fastcc void @glUniformMatrix4fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res6715, i32 1, i8 %val6716, float* %val6717)
%val6719 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6720 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6719)
%var6721 = bitcast [11 x i8]* @gsxtmgraphics-pipeline245 to i8*
%res6722 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6720, i8* %var6721)
%val6723 = load i8, i8* @GL_FALSE
%val6724 = load float*, float** %vPtr
call fastcc void @glUniformMatrix4fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res6722, i32 1, i8 %val6723, float* %val6724)
%val6726 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6727 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6726)
%var6728 = bitcast [17 x i8]* @gsxtmgraphics-pipeline246 to i8*
%res6729 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6727, i8* %var6728)
%val6730 = load i8, i8* @GL_FALSE
%val6731 = load float*, float** %pPtr
call fastcc void @glUniformMatrix4fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res6729, i32 1, i8 %val6730, float* %val6731)
%val6733 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6734 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6733)
%var6735 = bitcast [13 x i8]* @gsxtmgraphics-pipeline247 to i8*
%res6736 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6734, i8* %var6735)
%val6737 = load i8, i8* @GL_FALSE
%val6738 = load float*, float** %mnPtr
call fastcc void @glUniformMatrix3fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res6736, i32 1, i8 %val6737, float* %val6738)
%val6740 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6741 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6740)
%var6742 = bitcast [16 x i8]* @gsxtmgraphics-pipeline248 to i8*
%res6743 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6741, i8* %var6742)
%val6744 = load i8, i8* @GL_FALSE
%val6745 = load float*, float** %mvPtr
call fastcc void @glUniformMatrix4fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res6743, i32 1, i8 %val6744, float* %val6745)
%val6747 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6748 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6747)
%var6749 = bitcast [26 x i8]* @gsxtmgraphics-pipeline249 to i8*
%res6750 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6748, i8* %var6749)
%val6751 = load i8, i8* @GL_FALSE
%val6752 = load float*, float** %mvpPtr
call fastcc void @glUniformMatrix4fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res6750, i32 1, i8 %val6751, float* %val6752)
ret void
}
@gsxtmgraphics-pipeline267 = hidden constant [158 x i8] c"shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}** @shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6797 = load i8*, i8** %_impzPtr
%zone6798 = bitcast i8* %tzone6797 to %mzone*

; let assign value to symbol shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0
%dat_shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone6798, i64 8)
%shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0Ptr = bitcast i8* %dat_shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0 to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***
%tzone6593 = load i8*, i8** %_impzPtr
%zone6594 = bitcast i8* %tzone6593 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone6594, i64 4)
%iPtr = bitcast i8* %dat_i to i32*
%tzone6602 = load i8*, i8** %_impzPtr
%zone6603 = bitcast i8* %tzone6602 to %mzone*

; let assign value to symbol mlvpb
%dat_mlvpb = call i8* @llvm_zone_malloc(%mzone* %zone6603, i64 8)
%mlvpbPtr = bitcast i8* %dat_mlvpb to float**
%tzone6610 = load i8*, i8** %_impzPtr
%zone6611 = bitcast i8* %tzone6610 to %mzone*

; let assign value to symbol bias
%dat_bias = call i8* @llvm_zone_malloc(%mzone* %zone6611, i64 8)
%biasPtr = bitcast i8* %dat_bias to float**

; let value assignment
%i = select i1 true, i32 0, i32 0
store i32 %i, i32* %iPtr

%val6595 = mul i64 10, 16
%val6596 = getelementptr i64, i64* null, i32 1
%zonesize6597 = mul i64 4, %val6595
%tzone6598 = load i8*, i8** %_impzPtr
%zone6599 = bitcast i8* %tzone6598 to %mzone*
%dat6600 = call i8* @llvm_zone_malloc(%mzone* %zone6599, i64 %zonesize6597)
call i8* @memset(i8* %dat6600, i32 0, i64 %zonesize6597)
%val6601 = bitcast i8* %dat6600 to float*

; let value assignment
%mlvpb = select i1 true, float* %val6601, float* %val6601
store float* %mlvpb, float** %mlvpbPtr

%val6604 = getelementptr i64, i64* null, i32 1
%zonesize6605 = mul i64 4, 16
%tzone6606 = load i8*, i8** %_impzPtr
%zone6607 = bitcast i8* %tzone6606 to %mzone*
%dat6608 = call i8* @llvm_zone_malloc(%mzone* %zone6607, i64 %zonesize6605)
call i8* @memset(i8* %dat6608, i32 0, i64 %zonesize6605)
%val6609 = bitcast i8* %dat6608 to float*

; let value assignment
%bias = select i1 true, float* %val6609, float* %val6609
store float* %bias, float** %biasPtr

%val6612 = load float*, float** %biasPtr
; set pointer
%val6613 = getelementptr float, float* %val6612, i64 0
store float 0x3fe0000000000000, float* %val6613
%val6614 = load float*, float** %biasPtr
; set pointer
%val6615 = getelementptr float, float* %val6614, i64 1
store float 0x0, float* %val6615
%val6616 = load float*, float** %biasPtr
; set pointer
%val6617 = getelementptr float, float* %val6616, i64 2
store float 0x0, float* %val6617
%val6618 = load float*, float** %biasPtr
; set pointer
%val6619 = getelementptr float, float* %val6618, i64 3
store float 0x0, float* %val6619
%val6620 = load float*, float** %biasPtr
; set pointer
%val6621 = getelementptr float, float* %val6620, i64 4
store float 0x0, float* %val6621
%val6622 = load float*, float** %biasPtr
; set pointer
%val6623 = getelementptr float, float* %val6622, i64 5
store float 0x3fe0000000000000, float* %val6623
%val6624 = load float*, float** %biasPtr
; set pointer
%val6625 = getelementptr float, float* %val6624, i64 6
store float 0x0, float* %val6625
%val6626 = load float*, float** %biasPtr
; set pointer
%val6627 = getelementptr float, float* %val6626, i64 7
store float 0x0, float* %val6627
%val6628 = load float*, float** %biasPtr
; set pointer
%val6629 = getelementptr float, float* %val6628, i64 8
store float 0x0, float* %val6629
%val6630 = load float*, float** %biasPtr
; set pointer
%val6631 = getelementptr float, float* %val6630, i64 9
store float 0x0, float* %val6631
%val6632 = load float*, float** %biasPtr
; set pointer
%val6633 = getelementptr float, float* %val6632, i64 10
store float 0x3fe0000000000000, float* %val6633
%val6634 = load float*, float** %biasPtr
; set pointer
%val6635 = getelementptr float, float* %val6634, i64 11
store float 0x0, float* %val6635
%val6636 = load float*, float** %biasPtr
; set pointer
%val6637 = getelementptr float, float* %val6636, i64 12
store float 0x3fe0000000000000, float* %val6637
%val6638 = load float*, float** %biasPtr
; set pointer
%val6639 = getelementptr float, float* %val6638, i64 13
store float 0x3fe0000000000000, float* %val6639
%val6640 = load float*, float** %biasPtr
; set pointer
%val6641 = getelementptr float, float* %val6640, i64 14
store float 0x3fe0000000000000, float* %val6641
%val6642 = load float*, float** %biasPtr
; set pointer
%val6643 = getelementptr float, float* %val6642, i64 15
store float 0x3ff0000000000000, float* %val6643
%tzone6794 = load i8*, i8** %_impzPtr
%zone6795 = bitcast i8* %tzone6794 to %mzone*

; let assign value to symbol _anon_lambda_5
%dat__anon_lambda_5 = call i8* @llvm_zone_malloc(%mzone* %zone6795, i64 8)
%_anon_lambda_5Ptr = bitcast i8* %dat__anon_lambda_5 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***
%tzone6755 = load i8*, i8** %_impzPtr
%zone6756 = bitcast i8* %tzone6755 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6756)
; malloc closure structure
%clsptr6757 = call i8* @llvm_zone_malloc(%mzone* %zone6756, i64 24)
%closure6758 = bitcast i8* %clsptr6757 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}*

; malloc environment structure
%envptr6759 = call i8* @llvm_zone_malloc(%mzone* %zone6756, i64 40)
%environment6760 = bitcast i8* %envptr6759 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}*

; malloc closure address table
%addytable6761 = call %clsvar* @new_address_table()
%var6762 = bitcast [105 x i8]* @gsxtmgraphics-pipeline263 to i8*
%var6763 = bitcast [85 x i8]* @gsxtmgraphics-pipeline264 to i8*
%addytable6764 = call %clsvar* @add_address_table(%mzone* %zone6756, i8* %var6762, i32 0, i8* %var6763, i32 3, %clsvar* %addytable6761)
%var6765 = bitcast [5 x i8]* @gsxtmgraphics-pipeline260 to i8*
%var6766 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable6767 = call %clsvar* @add_address_table(%mzone* %zone6756, i8* %var6765, i32 8, i8* %var6766, i32 3, %clsvar* %addytable6764)
%var6768 = bitcast [6 x i8]* @gsxtmgraphics-pipeline265 to i8*
%var6769 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable6770 = call %clsvar* @add_address_table(%mzone* %zone6756, i8* %var6768, i32 16, i8* %var6769, i32 3, %clsvar* %addytable6767)
%var6771 = bitcast [2 x i8]* @gsxtmgraphics-pipeline240 to i8*
%var6772 = bitcast [4 x i8]* @gsxtmgraphics-pipeline241 to i8*
%addytable6773 = call %clsvar* @add_address_table(%mzone* %zone6756, i8* %var6771, i32 24, i8* %var6772, i32 3, %clsvar* %addytable6770)
%var6774 = bitcast [15 x i8]* @gsxtmgraphics-pipeline266 to i8*
%var6775 = bitcast [85 x i8]* @gsxtmgraphics-pipeline264 to i8*
%addytable6776 = call %clsvar* @add_address_table(%mzone* %zone6756, i8* %var6774, i32 32, i8* %var6775, i32 3, %clsvar* %addytable6773)
%address-table6777 = bitcast %clsvar* %addytable6776 to i8*

; insert table, function and environment into closure struct
%closure.table6788 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}* %closure6758, i32 0, i32 0
store i8* %address-table6777, i8** %closure.table6788
%closure.env6789 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}* %closure6758, i32 0, i32 1
store i8* %envptr6759, i8** %closure.env6789
%closure.func6790 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}* %closure6758, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)* @shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0__6592, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)** %closure.func6790
%closure_size6791 = call i64 @llvm_zone_mark_size(%mzone* %zone6756)
call void @llvm_zone_ptr_set_size(i8* %clsptr6757, i64 %closure_size6791)
%wrapper_ptr6792 = call i8* @llvm_zone_malloc(%mzone* %zone6756, i64 8)
%closure_wrapper6793 = bitcast i8* %wrapper_ptr6792 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}* %closure6758, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}** %closure_wrapper6793

; let value assignment
%_anon_lambda_5 = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}** %closure_wrapper6793, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}** %closure_wrapper6793
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}** %_anon_lambda_5, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}*** %_anon_lambda_5Ptr

; add data to environment
; don't need to alloc for env var shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0
%tmp_envptr6779 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}* %environment6760, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}*** %shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0Ptr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}**** %tmp_envptr6779

; don't need to alloc for env var bias
%tmp_envptr6781 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}* %environment6760, i32 0, i32 1
store float** %biasPtr, float*** %tmp_envptr6781

; don't need to alloc for env var mlvpb
%tmp_envptr6783 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}* %environment6760, i32 0, i32 2
store float** %mlvpbPtr, float*** %tmp_envptr6783

; don't need to alloc for env var i
%tmp_envptr6785 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}* %environment6760, i32 0, i32 3
store i32* %iPtr, i32** %tmp_envptr6785

; don't need to alloc for env var _anon_lambda_5
%tmp_envptr6787 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***, float**, float**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}***}* %environment6760, i32 0, i32 4
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}*** %_anon_lambda_5Ptr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}**** %tmp_envptr6787


%val6796 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}*** %_anon_lambda_5Ptr

; let value assignment
%shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0 = select i1 true, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}** %val6796, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}** %val6796
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}** %shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}*** %shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0Ptr

%val6799 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}*** %shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}** %val6799
}


@shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}** @shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0(%ShaderProgram* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3,i32 %arg_4,float* %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, float* %arg_5)
ret void
}


define dllexport ccc void @shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0_native(%ShaderProgram* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3,i32 %arg_4,float* %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, float* %arg_5)
ret void
}


define dllexport ccc i8*  @shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6800 = bitcast [158 x i8]* @gsxtmgraphics-pipeline267 to i8*
call i32 (i8*, ...) @printf(i8* %var6800)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6801 = bitcast [158 x i8]* @gsxtmgraphics-pipeline267 to i8*
call i32 (i8*, ...) @printf(i8* %var6801)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var6802 = bitcast [158 x i8]* @gsxtmgraphics-pipeline267 to i8*
call i32 (i8*, ...) @printf(i8* %var6802)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var6803 = bitcast [158 x i8]* @gsxtmgraphics-pipeline267 to i8*
call i32 (i8*, ...) @printf(i8* %var6803)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var6804 = bitcast [158 x i8]* @gsxtmgraphics-pipeline267 to i8*
call i32 (i8*, ...) @printf(i8* %var6804)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var6805 = bitcast [158 x i8]* @gsxtmgraphics-pipeline267 to i8*
call i32 (i8*, ...) @printf(i8* %var6805)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, float* %arg_5)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, float*, float*, float*, i32, float*}*
%arg_p_0 = getelementptr {%ShaderProgram*, float*, float*, float*, i32, float*}, {%ShaderProgram*, float*, float*, float*, i32, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, float*, float*, float*, i32, float*}, {%ShaderProgram*, float*, float*, float*, i32, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, float*, float*, float*, i32, float*}, {%ShaderProgram*, float*, float*, float*, i32, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%ShaderProgram*, float*, float*, float*, i32, float*}, {%ShaderProgram*, float*, float*, float*, i32, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {%ShaderProgram*, float*, float*, float*, i32, float*}, {%ShaderProgram*, float*, float*, float*, i32, float*}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
%arg_p_5 = getelementptr {%ShaderProgram*, float*, float*, float*, i32, float*}, {%ShaderProgram*, float*, float*, float*, i32, float*}* %fstruct, i32 0, i32 5
%arg_5 = load float*, float** %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, i32, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, i32 %arg_4, float* %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@XTM_EMIT_VCOLOUR = dllexport global i32 0
@gsxtmgraphics-pipeline268 = hidden constant [38 x i8] c"xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ\00"
@gsxtmgraphics-pipeline269 = hidden constant [36 x i8] c"{i8*, i8*, void (i8*, i8*, i32)*}**\00"
define dllexport fastcc void @xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ__6806(i8* %_impz,i8* %_impenv, i32 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6807 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i32)*}***}*
%xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32)*}***}, {{i8*, i8*, void (i8*, i8*, i32)*}***}* %impenv, i32 0, i32 0
%xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQPtr = load {i8*, i8*, void (i8*, i8*, i32)*}***, {i8*, i8*, void (i8*, i8*, i32)*}**** %xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQPtr_

; setup arguments
%xPtr = alloca i32
store i32 %x, i32* %xPtr


; do set!
%val6808 = load i32, i32* %xPtr
store i32 %val6808, i32* @XTM_EMIT_VCOLOUR
ret void
}
@gsxtmgraphics-pipeline270 = hidden constant [91 x i8] c"xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i32)*}** @xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6829 = load i8*, i8** %_impzPtr
%zone6830 = bitcast i8* %tzone6829 to %mzone*

; let assign value to symbol xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ
%dat_xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone6830, i64 8)
%xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQPtr = bitcast i8* %dat_xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ to { i8*, i8*, void (i8*, i8*, i32)*}***
%tzone6810 = load i8*, i8** %_impzPtr
%zone6811 = bitcast i8* %tzone6810 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6811)
; malloc closure structure
%clsptr6812 = call i8* @llvm_zone_malloc(%mzone* %zone6811, i64 24)
%closure6813 = bitcast i8* %clsptr6812 to { i8*, i8*, void (i8*, i8*, i32)*}*

; malloc environment structure
%envptr6814 = call i8* @llvm_zone_malloc(%mzone* %zone6811, i64 8)
%environment6815 = bitcast i8* %envptr6814 to {{i8*, i8*, void (i8*, i8*, i32)*}***}*

; malloc closure address table
%addytable6816 = call %clsvar* @new_address_table()
%var6817 = bitcast [38 x i8]* @gsxtmgraphics-pipeline268 to i8*
%var6818 = bitcast [36 x i8]* @gsxtmgraphics-pipeline269 to i8*
%addytable6819 = call %clsvar* @add_address_table(%mzone* %zone6811, i8* %var6817, i32 0, i8* %var6818, i32 3, %clsvar* %addytable6816)
%address-table6820 = bitcast %clsvar* %addytable6819 to i8*

; insert table, function and environment into closure struct
%closure.table6823 = getelementptr { i8*, i8*, void (i8*, i8*, i32)*}, { i8*, i8*, void (i8*, i8*, i32)*}* %closure6813, i32 0, i32 0
store i8* %address-table6820, i8** %closure.table6823
%closure.env6824 = getelementptr { i8*, i8*, void (i8*, i8*, i32)*}, { i8*, i8*, void (i8*, i8*, i32)*}* %closure6813, i32 0, i32 1
store i8* %envptr6814, i8** %closure.env6824
%closure.func6825 = getelementptr { i8*, i8*, void (i8*, i8*, i32)*}, { i8*, i8*, void (i8*, i8*, i32)*}* %closure6813, i32 0, i32 2
store void (i8*, i8*, i32)* @xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ__6806, void (i8*, i8*, i32)** %closure.func6825
%closure_size6826 = call i64 @llvm_zone_mark_size(%mzone* %zone6811)
call void @llvm_zone_ptr_set_size(i8* %clsptr6812, i64 %closure_size6826)
%wrapper_ptr6827 = call i8* @llvm_zone_malloc(%mzone* %zone6811, i64 8)
%closure_wrapper6828 = bitcast i8* %wrapper_ptr6827 to { i8*, i8*, void (i8*, i8*, i32)*}**
store { i8*, i8*, void (i8*, i8*, i32)*}* %closure6813, { i8*, i8*, void (i8*, i8*, i32)*}** %closure_wrapper6828

; let value assignment
%xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ = select i1 true, { i8*, i8*, void (i8*, i8*, i32)*}** %closure_wrapper6828, { i8*, i8*, void (i8*, i8*, i32)*}** %closure_wrapper6828
store { i8*, i8*, void (i8*, i8*, i32)*}** %xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ, { i8*, i8*, void (i8*, i8*, i32)*}*** %xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQPtr

; add data to environment
; don't need to alloc for env var xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ
%tmp_envptr6822 = getelementptr {{i8*, i8*, void (i8*, i8*, i32)*}***}, {{i8*, i8*, void (i8*, i8*, i32)*}***}* %environment6815, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i32)*}*** %xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQPtr, {i8*, i8*, void (i8*, i8*, i32)*}**** %tmp_envptr6822


%val6831 = load {i8*, i8*, void (i8*, i8*, i32)*}**, {i8*, i8*, void (i8*, i8*, i32)*}*** %xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQPtr
ret {i8*, i8*, void (i8*, i8*, i32)*}** %val6831
}


@xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i32)*}** @xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32)*,  void (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret void
}


define dllexport ccc void @xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ_native(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32)*,  void (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret void
}


define dllexport ccc i8*  @xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6832 = bitcast [91 x i8]* @gsxtmgraphics-pipeline270 to i8*
call i32 (i8*, ...) @printf(i8* %var6832)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32)*,  void (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32}*
%arg_p_0 = getelementptr {i32}, {i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_emit_vcolour_adhoc_W3ZvaWQsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32)*,  void (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline271 = hidden constant [16 x i8] c"MaterialAmbient\00"
@gsxtmgraphics-pipeline272 = hidden constant [16 x i8] c"MaterialDiffuse\00"
@gsxtmgraphics-pipeline273 = hidden constant [17 x i8] c"MaterialSpecular\00"
@gsxtmgraphics-pipeline274 = hidden constant [17 x i8] c"MaterialEmissive\00"
@gsxtmgraphics-pipeline275 = hidden constant [18 x i8] c"MaterialShininess\00"
@gsxtmgraphics-pipeline276 = hidden constant [12 x i8] c"emitVColour\00"
@gsxtmgraphics-pipeline277 = hidden constant [104 x i8] c"shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ\00"
@gsxtmgraphics-pipeline278 = hidden constant [87 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}**\00"
define dllexport fastcc void @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ__6833(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, float* %ambient, float* %diffuse, float* %emissive, float* %specular, float %shininess) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6834 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}***}*
%shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}***}* %impenv, i32 0, i32 0
%shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}**** %shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQPtr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%ambientPtr = alloca float*
store float* %ambient, float** %ambientPtr
%diffusePtr = alloca float*
store float* %diffuse, float** %diffusePtr
%emissivePtr = alloca float*
store float* %emissive, float** %emissivePtr
%specularPtr = alloca float*
store float* %specular, float** %specularPtr
%shininessPtr = alloca float
store float %shininess, float* %shininessPtr


%val6835 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6836 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6835)
%var6837 = bitcast [16 x i8]* @gsxtmgraphics-pipeline271 to i8*
%res6838 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6836, i8* %var6837)
%val6839 = load float*, float** %ambientPtr
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res6838, i32 1, float* %val6839)
%val6841 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6842 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6841)
%var6843 = bitcast [16 x i8]* @gsxtmgraphics-pipeline272 to i8*
%res6844 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6842, i8* %var6843)
%val6845 = load float*, float** %diffusePtr
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res6844, i32 1, float* %val6845)
%val6847 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6848 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6847)
%var6849 = bitcast [17 x i8]* @gsxtmgraphics-pipeline273 to i8*
%res6850 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6848, i8* %var6849)
%val6851 = load float*, float** %specularPtr
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res6850, i32 1, float* %val6851)
%val6853 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6854 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6853)
%var6855 = bitcast [17 x i8]* @gsxtmgraphics-pipeline274 to i8*
%res6856 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6854, i8* %var6855)
%val6857 = load float*, float** %emissivePtr
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res6856, i32 1, float* %val6857)
%val6859 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6860 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6859)
%var6861 = bitcast [18 x i8]* @gsxtmgraphics-pipeline275 to i8*
%res6862 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6860, i8* %var6861)
%val6863 = load float, float* %shininessPtr
call fastcc void @glUniform1f_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %res6862, float %val6863)
%val6865 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6866 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6865)
%var6867 = bitcast [12 x i8]* @gsxtmgraphics-pipeline276 to i8*
%res6868 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6866, i8* %var6867)
%val6869 = load i32, i32* @XTM_EMIT_VCOLOUR
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res6868, i32 %val6869)
ret void
}
@gsxtmgraphics-pipeline279 = hidden constant [157 x i8] c"shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}** @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6891 = load i8*, i8** %_impzPtr
%zone6892 = bitcast i8* %tzone6891 to %mzone*

; let assign value to symbol shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ
%dat_shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone6892, i64 8)
%shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQPtr = bitcast i8* %dat_shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}***
%tzone6872 = load i8*, i8** %_impzPtr
%zone6873 = bitcast i8* %tzone6872 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6873)
; malloc closure structure
%clsptr6874 = call i8* @llvm_zone_malloc(%mzone* %zone6873, i64 24)
%closure6875 = bitcast i8* %clsptr6874 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}*

; malloc environment structure
%envptr6876 = call i8* @llvm_zone_malloc(%mzone* %zone6873, i64 8)
%environment6877 = bitcast i8* %envptr6876 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}***}*

; malloc closure address table
%addytable6878 = call %clsvar* @new_address_table()
%var6879 = bitcast [104 x i8]* @gsxtmgraphics-pipeline277 to i8*
%var6880 = bitcast [87 x i8]* @gsxtmgraphics-pipeline278 to i8*
%addytable6881 = call %clsvar* @add_address_table(%mzone* %zone6873, i8* %var6879, i32 0, i8* %var6880, i32 3, %clsvar* %addytable6878)
%address-table6882 = bitcast %clsvar* %addytable6881 to i8*

; insert table, function and environment into closure struct
%closure.table6885 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}* %closure6875, i32 0, i32 0
store i8* %address-table6882, i8** %closure.table6885
%closure.env6886 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}* %closure6875, i32 0, i32 1
store i8* %envptr6876, i8** %closure.env6886
%closure.func6887 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}* %closure6875, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ__6833, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)** %closure.func6887
%closure_size6888 = call i64 @llvm_zone_mark_size(%mzone* %zone6873)
call void @llvm_zone_ptr_set_size(i8* %clsptr6874, i64 %closure_size6888)
%wrapper_ptr6889 = call i8* @llvm_zone_malloc(%mzone* %zone6873, i64 8)
%closure_wrapper6890 = bitcast i8* %wrapper_ptr6889 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}* %closure6875, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}** %closure_wrapper6890

; let value assignment
%shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}** %closure_wrapper6890, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}** %closure_wrapper6890
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}** %shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}*** %shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ
%tmp_envptr6884 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}***}* %environment6877, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}*** %shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}**** %tmp_envptr6884


%val6893 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}*** %shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}** %val6893
}


@shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}** @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ(%ShaderProgram* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float %arg_5)
ret void
}


define dllexport ccc void @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ_native(%ShaderProgram* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float %arg_5)
ret void
}


define dllexport ccc i8*  @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6894 = bitcast [157 x i8]* @gsxtmgraphics-pipeline279 to i8*
call i32 (i8*, ...) @printf(i8* %var6894)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6895 = bitcast [157 x i8]* @gsxtmgraphics-pipeline279 to i8*
call i32 (i8*, ...) @printf(i8* %var6895)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var6896 = bitcast [157 x i8]* @gsxtmgraphics-pipeline279 to i8*
call i32 (i8*, ...) @printf(i8* %var6896)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var6897 = bitcast [157 x i8]* @gsxtmgraphics-pipeline279 to i8*
call i32 (i8*, ...) @printf(i8* %var6897)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var6898 = bitcast [157 x i8]* @gsxtmgraphics-pipeline279 to i8*
call i32 (i8*, ...) @printf(i8* %var6898)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_real(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var6899 = bitcast [157 x i8]* @gsxtmgraphics-pipeline279 to i8*
call i32 (i8*, ...) @printf(i8* %var6899)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc float  @r32value(i8* %arg_5_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float %arg_5)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, float*, float*, float*, float*, float}*
%arg_p_0 = getelementptr {%ShaderProgram*, float*, float*, float*, float*, float}, {%ShaderProgram*, float*, float*, float*, float*, float}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, float*, float*, float*, float*, float}, {%ShaderProgram*, float*, float*, float*, float*, float}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, float*, float*, float*, float*, float}, {%ShaderProgram*, float*, float*, float*, float*, float}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%ShaderProgram*, float*, float*, float*, float*, float}, {%ShaderProgram*, float*, float*, float*, float*, float}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {%ShaderProgram*, float*, float*, float*, float*, float}, {%ShaderProgram*, float*, float*, float*, float*, float}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {%ShaderProgram*, float*, float*, float*, float*, float}, {%ShaderProgram*, float*, float*, float*, float*, float}* %fstruct, i32 0, i32 5
%arg_5 = load float, float* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float*, float*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline280 = hidden constant [55 x i8] c"array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0\00"
@gsxtmgraphics-pipeline281 = hidden constant [52 x i8] c"{i8*, i8*, void (i8*, i8*, [4 x float], float*)*}**\00"
define dllexport fastcc void @array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0__6900(i8* %_impz,i8* %_impenv, [4 x float] %a, float* %data_s_24) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6901 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, [4 x float], float*)*}***}*
%array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, [4 x float], float*)*}***}, {{i8*, i8*, void (i8*, i8*, [4 x float], float*)*}***}* %impenv, i32 0, i32 0
%array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0Ptr = load {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}***, {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}**** %array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0Ptr_

; setup arguments
%aPtr = alloca [4 x float]
store [4 x float] %a, [4 x float]* %aPtr
%data_s_24Ptr = alloca float*
store float* %data_s_24, float** %data_s_24Ptr


%val6902 = load float*, float** %data_s_24Ptr
%val6903 = load [4 x float], [4 x float]* %aPtr
; array ref
%val6904 = extractvalue [4 x float] %val6903, 0
; set pointer
%val6905 = getelementptr float, float* %val6902, i64 0
store float %val6904, float* %val6905
%val6906 = load float*, float** %data_s_24Ptr
%val6907 = load [4 x float], [4 x float]* %aPtr
; array ref
%val6908 = extractvalue [4 x float] %val6907, 1
; set pointer
%val6909 = getelementptr float, float* %val6906, i64 1
store float %val6908, float* %val6909
%val6910 = load float*, float** %data_s_24Ptr
%val6911 = load [4 x float], [4 x float]* %aPtr
; array ref
%val6912 = extractvalue [4 x float] %val6911, 2
; set pointer
%val6913 = getelementptr float, float* %val6910, i64 2
store float %val6912, float* %val6913
%val6914 = load float*, float** %data_s_24Ptr
%val6915 = load [4 x float], [4 x float]* %aPtr
; array ref
%val6916 = extractvalue [4 x float] %val6915, 3
; set pointer
%val6917 = getelementptr float, float* %val6914, i64 3
store float %val6916, float* %val6917
ret void
}
@gsxtmgraphics-pipeline282 = hidden constant [108 x i8] c"array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}** @array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6938 = load i8*, i8** %_impzPtr
%zone6939 = bitcast i8* %tzone6938 to %mzone*

; let assign value to symbol array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0
%dat_array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone6939, i64 8)
%array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0Ptr = bitcast i8* %dat_array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0 to { i8*, i8*, void (i8*, i8*, [4 x float], float*)*}***
%tzone6919 = load i8*, i8** %_impzPtr
%zone6920 = bitcast i8* %tzone6919 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6920)
; malloc closure structure
%clsptr6921 = call i8* @llvm_zone_malloc(%mzone* %zone6920, i64 24)
%closure6922 = bitcast i8* %clsptr6921 to { i8*, i8*, void (i8*, i8*, [4 x float], float*)*}*

; malloc environment structure
%envptr6923 = call i8* @llvm_zone_malloc(%mzone* %zone6920, i64 8)
%environment6924 = bitcast i8* %envptr6923 to {{i8*, i8*, void (i8*, i8*, [4 x float], float*)*}***}*

; malloc closure address table
%addytable6925 = call %clsvar* @new_address_table()
%var6926 = bitcast [55 x i8]* @gsxtmgraphics-pipeline280 to i8*
%var6927 = bitcast [52 x i8]* @gsxtmgraphics-pipeline281 to i8*
%addytable6928 = call %clsvar* @add_address_table(%mzone* %zone6920, i8* %var6926, i32 0, i8* %var6927, i32 3, %clsvar* %addytable6925)
%address-table6929 = bitcast %clsvar* %addytable6928 to i8*

; insert table, function and environment into closure struct
%closure.table6932 = getelementptr { i8*, i8*, void (i8*, i8*, [4 x float], float*)*}, { i8*, i8*, void (i8*, i8*, [4 x float], float*)*}* %closure6922, i32 0, i32 0
store i8* %address-table6929, i8** %closure.table6932
%closure.env6933 = getelementptr { i8*, i8*, void (i8*, i8*, [4 x float], float*)*}, { i8*, i8*, void (i8*, i8*, [4 x float], float*)*}* %closure6922, i32 0, i32 1
store i8* %envptr6923, i8** %closure.env6933
%closure.func6934 = getelementptr { i8*, i8*, void (i8*, i8*, [4 x float], float*)*}, { i8*, i8*, void (i8*, i8*, [4 x float], float*)*}* %closure6922, i32 0, i32 2
store void (i8*, i8*, [4 x float], float*)* @array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0__6900, void (i8*, i8*, [4 x float], float*)** %closure.func6934
%closure_size6935 = call i64 @llvm_zone_mark_size(%mzone* %zone6920)
call void @llvm_zone_ptr_set_size(i8* %clsptr6921, i64 %closure_size6935)
%wrapper_ptr6936 = call i8* @llvm_zone_malloc(%mzone* %zone6920, i64 8)
%closure_wrapper6937 = bitcast i8* %wrapper_ptr6936 to { i8*, i8*, void (i8*, i8*, [4 x float], float*)*}**
store { i8*, i8*, void (i8*, i8*, [4 x float], float*)*}* %closure6922, { i8*, i8*, void (i8*, i8*, [4 x float], float*)*}** %closure_wrapper6937

; let value assignment
%array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, [4 x float], float*)*}** %closure_wrapper6937, { i8*, i8*, void (i8*, i8*, [4 x float], float*)*}** %closure_wrapper6937
store { i8*, i8*, void (i8*, i8*, [4 x float], float*)*}** %array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0, { i8*, i8*, void (i8*, i8*, [4 x float], float*)*}*** %array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0Ptr

; add data to environment
; don't need to alloc for env var array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0
%tmp_envptr6931 = getelementptr {{i8*, i8*, void (i8*, i8*, [4 x float], float*)*}***}, {{i8*, i8*, void (i8*, i8*, [4 x float], float*)*}***}* %environment6924, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}*** %array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0Ptr, {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}**** %tmp_envptr6931


%val6940 = load {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}**, {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}*** %array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}** %val6940
}


@array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}** @array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0([4 x float] %arg_0,float* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}*, {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}, {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}, {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, [4 x float], float*)*,  void (i8*, i8*, [4 x float], float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, [4 x float] %arg_0, float* %arg_1)
ret void
}


define dllexport ccc void @array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0_native([4 x float] %arg_0,float* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}*, {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}, {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}, {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, [4 x float], float*)*,  void (i8*, i8*, [4 x float], float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, [4 x float] %arg_0, float* %arg_1)
ret void
}


define dllexport ccc void @array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {[4 x float], float*}*
%arg_p_0 = getelementptr {[4 x float], float*}, {[4 x float], float*}* %fstruct, i32 0, i32 0
%arg_0 = load [4 x float], [4 x float]* %arg_p_0
%arg_p_1 = getelementptr {[4 x float], float*}, {[4 x float], float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}*, {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}, {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}, {i8*, i8*, void (i8*, i8*, [4 x float], float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, [4 x float], float*)*,  void (i8*, i8*, [4 x float], float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, [4 x float] %arg_0, float* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline283 = hidden constant [120 x i8] c"shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ\00"
@gsxtmgraphics-pipeline284 = hidden constant [107 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}**\00"
@gsxtmgraphics-pipeline285 = hidden constant [10 x i8] c"data_s_25\00"
@gsxtmgraphics-pipeline286 = hidden constant [15 x i8] c"_anon_lambda_6\00"
define dllexport fastcc void @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ__6942(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, [4 x float] %ambient, [4 x float] %diffuse, [4 x float] %emissive, [4 x float] %specular, float %shininess) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6954 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***}*
%shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***}* %impenv, i32 0, i32 0
%shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}**** %shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQPtr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***}* %impenv, i32 0, i32 1
%iPtr = load i32*, i32** %iPtr_
%data_s_25Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***}* %impenv, i32 0, i32 2
%data_s_25Ptr = load float**, float*** %data_s_25Ptr_
%_anon_lambda_6Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***}* %impenv, i32 0, i32 3
%_anon_lambda_6Ptr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}**** %_anon_lambda_6Ptr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%ambientPtr = alloca [4 x float]
store [4 x float] %ambient, [4 x float]* %ambientPtr
%diffusePtr = alloca [4 x float]
store [4 x float] %diffuse, [4 x float]* %diffusePtr
%emissivePtr = alloca [4 x float]
store [4 x float] %emissive, [4 x float]* %emissivePtr
%specularPtr = alloca [4 x float]
store [4 x float] %specular, [4 x float]* %specularPtr
%shininessPtr = alloca float
store float %shininess, float* %shininessPtr


%val6955 = load [4 x float], [4 x float]* %ambientPtr
%val6956 = load float*, float** %data_s_25Ptr
; pointer ref
%val6957 = getelementptr float, float* %val6956, i64 0
call fastcc void @array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0([4 x float] %val6955, float* %val6957)
%val6959 = load [4 x float], [4 x float]* %diffusePtr
%val6960 = load float*, float** %data_s_25Ptr
; pointer ref
%val6961 = getelementptr float, float* %val6960, i64 4
call fastcc void @array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0([4 x float] %val6959, float* %val6961)
%val6963 = load [4 x float], [4 x float]* %emissivePtr
%val6964 = load float*, float** %data_s_25Ptr
; pointer ref
%val6965 = getelementptr float, float* %val6964, i64 8
call fastcc void @array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0([4 x float] %val6963, float* %val6965)
%val6967 = load [4 x float], [4 x float]* %specularPtr
%val6968 = load float*, float** %data_s_25Ptr
; pointer ref
%val6969 = getelementptr float, float* %val6968, i64 12
call fastcc void @array_4_ptr_copy_adhoc_W3ZvaWQsfDQsZmxvYXR8LGZsb2F0Kl0([4 x float] %val6967, float* %val6969)
%val6971 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6972 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6971)
%var6973 = bitcast [16 x i8]* @gsxtmgraphics-pipeline271 to i8*
%res6974 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6972, i8* %var6973)
%val6975 = load float*, float** %data_s_25Ptr
; pointer ref
%val6976 = getelementptr float, float* %val6975, i64 0
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res6974, i32 1, float* %val6976)
%val6978 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6979 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6978)
%var6980 = bitcast [16 x i8]* @gsxtmgraphics-pipeline272 to i8*
%res6981 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6979, i8* %var6980)
%val6982 = load float*, float** %data_s_25Ptr
; pointer ref
%val6983 = getelementptr float, float* %val6982, i64 4
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res6981, i32 1, float* %val6983)
%val6985 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6986 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6985)
%var6987 = bitcast [17 x i8]* @gsxtmgraphics-pipeline274 to i8*
%res6988 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6986, i8* %var6987)
%val6989 = load float*, float** %data_s_25Ptr
; pointer ref
%val6990 = getelementptr float, float* %val6989, i64 8
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res6988, i32 1, float* %val6990)
%val6992 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res6993 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6992)
%var6994 = bitcast [17 x i8]* @gsxtmgraphics-pipeline273 to i8*
%res6995 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res6993, i8* %var6994)
%val6996 = load float*, float** %data_s_25Ptr
; pointer ref
%val6997 = getelementptr float, float* %val6996, i64 12
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res6995, i32 1, float* %val6997)
%val6999 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res7000 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6999)
%var7001 = bitcast [18 x i8]* @gsxtmgraphics-pipeline275 to i8*
%res7002 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res7000, i8* %var7001)
%val7003 = load float, float* %shininessPtr
call fastcc void @glUniform1f_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %res7002, float %val7003)
%val7005 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res7006 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val7005)
%var7007 = bitcast [12 x i8]* @gsxtmgraphics-pipeline276 to i8*
%res7008 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res7006, i8* %var7007)
%val7009 = load i32, i32* @XTM_EMIT_VCOLOUR
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res7008, i32 %val7009)
ret void
}
@gsxtmgraphics-pipeline287 = hidden constant [173 x i8] c"shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}** @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7049 = load i8*, i8** %_impzPtr
%zone7050 = bitcast i8* %tzone7049 to %mzone*

; let assign value to symbol shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ
%dat_shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone7050, i64 8)
%shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQPtr = bitcast i8* %dat_shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***
%tzone6950 = load i8*, i8** %_impzPtr
%zone6951 = bitcast i8* %tzone6950 to %mzone*

; let assign value to symbol data_s_25
%dat_data_s_25 = call i8* @llvm_zone_malloc(%mzone* %zone6951, i64 8)
%data_s_25Ptr = bitcast i8* %dat_data_s_25 to float**
%tzone6952 = load i8*, i8** %_impzPtr
%zone6953 = bitcast i8* %tzone6952 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone6953, i64 4)
%iPtr = bitcast i8* %dat_i to i32*
%val6943 = mul i64 4, 4
%val6944 = getelementptr i64, i64* null, i32 1
%zonesize6945 = mul i64 4, %val6943
%tzone6946 = load i8*, i8** %_impzPtr
%zone6947 = bitcast i8* %tzone6946 to %mzone*
%dat6948 = call i8* @llvm_zone_malloc(%mzone* %zone6947, i64 %zonesize6945)
call i8* @memset(i8* %dat6948, i32 0, i64 %zonesize6945)
%val6949 = bitcast i8* %dat6948 to float*

; let value assignment
%data_s_25 = select i1 true, float* %val6949, float* %val6949
store float* %data_s_25, float** %data_s_25Ptr


; let value assignment
%i = select i1 true, i32 0, i32 0
store i32 %i, i32* %iPtr

%tzone7046 = load i8*, i8** %_impzPtr
%zone7047 = bitcast i8* %tzone7046 to %mzone*

; let assign value to symbol _anon_lambda_6
%dat__anon_lambda_6 = call i8* @llvm_zone_malloc(%mzone* %zone7047, i64 8)
%_anon_lambda_6Ptr = bitcast i8* %dat__anon_lambda_6 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***
%tzone7012 = load i8*, i8** %_impzPtr
%zone7013 = bitcast i8* %tzone7012 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7013)
; malloc closure structure
%clsptr7014 = call i8* @llvm_zone_malloc(%mzone* %zone7013, i64 24)
%closure7015 = bitcast i8* %clsptr7014 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}*

; malloc environment structure
%envptr7016 = call i8* @llvm_zone_malloc(%mzone* %zone7013, i64 32)
%environment7017 = bitcast i8* %envptr7016 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***}*

; malloc closure address table
%addytable7018 = call %clsvar* @new_address_table()
%var7019 = bitcast [120 x i8]* @gsxtmgraphics-pipeline283 to i8*
%var7020 = bitcast [107 x i8]* @gsxtmgraphics-pipeline284 to i8*
%addytable7021 = call %clsvar* @add_address_table(%mzone* %zone7013, i8* %var7019, i32 0, i8* %var7020, i32 3, %clsvar* %addytable7018)
%var7022 = bitcast [2 x i8]* @gsxtmgraphics-pipeline240 to i8*
%var7023 = bitcast [4 x i8]* @gsxtmgraphics-pipeline241 to i8*
%addytable7024 = call %clsvar* @add_address_table(%mzone* %zone7013, i8* %var7022, i32 8, i8* %var7023, i32 3, %clsvar* %addytable7021)
%var7025 = bitcast [10 x i8]* @gsxtmgraphics-pipeline285 to i8*
%var7026 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable7027 = call %clsvar* @add_address_table(%mzone* %zone7013, i8* %var7025, i32 16, i8* %var7026, i32 3, %clsvar* %addytable7024)
%var7028 = bitcast [15 x i8]* @gsxtmgraphics-pipeline286 to i8*
%var7029 = bitcast [107 x i8]* @gsxtmgraphics-pipeline284 to i8*
%addytable7030 = call %clsvar* @add_address_table(%mzone* %zone7013, i8* %var7028, i32 24, i8* %var7029, i32 3, %clsvar* %addytable7027)
%address-table7031 = bitcast %clsvar* %addytable7030 to i8*

; insert table, function and environment into closure struct
%closure.table7040 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}* %closure7015, i32 0, i32 0
store i8* %address-table7031, i8** %closure.table7040
%closure.env7041 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}* %closure7015, i32 0, i32 1
store i8* %envptr7016, i8** %closure.env7041
%closure.func7042 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}* %closure7015, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ__6942, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)** %closure.func7042
%closure_size7043 = call i64 @llvm_zone_mark_size(%mzone* %zone7013)
call void @llvm_zone_ptr_set_size(i8* %clsptr7014, i64 %closure_size7043)
%wrapper_ptr7044 = call i8* @llvm_zone_malloc(%mzone* %zone7013, i64 8)
%closure_wrapper7045 = bitcast i8* %wrapper_ptr7044 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}* %closure7015, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}** %closure_wrapper7045

; let value assignment
%_anon_lambda_6 = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}** %closure_wrapper7045, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}** %closure_wrapper7045
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}** %_anon_lambda_6, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}*** %_anon_lambda_6Ptr

; add data to environment
; don't need to alloc for env var shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ
%tmp_envptr7033 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***}* %environment7017, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}*** %shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}**** %tmp_envptr7033

; don't need to alloc for env var i
%tmp_envptr7035 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***}* %environment7017, i32 0, i32 1
store i32* %iPtr, i32** %tmp_envptr7035

; don't need to alloc for env var data_s_25
%tmp_envptr7037 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***}* %environment7017, i32 0, i32 2
store float** %data_s_25Ptr, float*** %tmp_envptr7037

; don't need to alloc for env var _anon_lambda_6
%tmp_envptr7039 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}***}* %environment7017, i32 0, i32 3
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}*** %_anon_lambda_6Ptr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}**** %tmp_envptr7039


%val7048 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}*** %_anon_lambda_6Ptr

; let value assignment
%shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ = select i1 true, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}** %val7048, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}** %val7048
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}** %shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}*** %shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQPtr

%val7051 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}*** %shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}** %val7051
}


@shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}** @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ(%ShaderProgram* %arg_0,[4 x float] %arg_1,[4 x float] %arg_2,[4 x float] %arg_3,[4 x float] %arg_4,float %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*,  void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, [4 x float] %arg_1, [4 x float] %arg_2, [4 x float] %arg_3, [4 x float] %arg_4, float %arg_5)
ret void
}


define dllexport ccc void @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ_native(%ShaderProgram* %arg_0,[4 x float] %arg_1,[4 x float] %arg_2,[4 x float] %arg_3,[4 x float] %arg_4,float %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*,  void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, [4 x float] %arg_1, [4 x float] %arg_2, [4 x float] %arg_3, [4 x float] %arg_4, float %arg_5)
ret void
}


define dllexport ccc void @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float}*
%arg_p_0 = getelementptr {%ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float}, {%ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float}, {%ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float}* %fstruct, i32 0, i32 1
%arg_1 = load [4 x float], [4 x float]* %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float}, {%ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float}* %fstruct, i32 0, i32 2
%arg_2 = load [4 x float], [4 x float]* %arg_p_2
%arg_p_3 = getelementptr {%ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float}, {%ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float}* %fstruct, i32 0, i32 3
%arg_3 = load [4 x float], [4 x float]* %arg_p_3
%arg_p_4 = getelementptr {%ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float}, {%ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float}* %fstruct, i32 0, i32 4
%arg_4 = load [4 x float], [4 x float]* %arg_p_4
%arg_p_5 = getelementptr {%ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float}, {%ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float}* %fstruct, i32 0, i32 5
%arg_5 = load float, float* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)*,  void (i8*, i8*, %ShaderProgram*, [4 x float], [4 x float], [4 x float], [4 x float], float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, [4 x float] %arg_1, [4 x float] %arg_2, [4 x float] %arg_3, [4 x float] %arg_4, float %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline288 = hidden constant [80 x i8] c"shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ\00"
@gsxtmgraphics-pipeline289 = hidden constant [68 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}**\00"
define dllexport fastcc void @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ__7054(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, [4 x float] %diffuse, float %shininess) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7055 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}***}*
%shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}***}* %impenv, i32 0, i32 0
%shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}**** %shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQPtr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%diffusePtr = alloca [4 x float]
store [4 x float] %diffuse, [4 x float]* %diffusePtr
%shininessPtr = alloca float
store float %shininess, float* %shininessPtr


%val7056 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%arrayl7057 = insertvalue [4 x float] undef, float 0x0, 0
%arrayl7058 = insertvalue [4 x float] %arrayl7057, float 0x0, 1
%arrayl7059 = insertvalue [4 x float] %arrayl7058, float 0x0, 2
%arrayl7060 = insertvalue [4 x float] %arrayl7059, float 0x3ff0000000000000, 3
%val7061 = load [4 x float], [4 x float]* %diffusePtr
%arrayl7062 = insertvalue [4 x float] undef, float 0x0, 0
%arrayl7063 = insertvalue [4 x float] %arrayl7062, float 0x0, 1
%arrayl7064 = insertvalue [4 x float] %arrayl7063, float 0x0, 2
%arrayl7065 = insertvalue [4 x float] %arrayl7064, float 0x3ff0000000000000, 3
%arrayl7066 = insertvalue [4 x float] undef, float 0x0, 0
%arrayl7067 = insertvalue [4 x float] %arrayl7066, float 0x0, 1
%arrayl7068 = insertvalue [4 x float] %arrayl7067, float 0x0, 2
%arrayl7069 = insertvalue [4 x float] %arrayl7068, float 0x3ff0000000000000, 3
%val7070 = load float, float* %shininessPtr
call fastcc void @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LHw0LGZsb2F0fCx8NCxmbG9hdHwsfDQsZmxvYXR8LGZsb2F0XQ(%ShaderProgram* %val7056, [4 x float] %arrayl7060, [4 x float] %val7061, [4 x float] %arrayl7065, [4 x float] %arrayl7069, float %val7070)
ret void
}
@gsxtmgraphics-pipeline290 = hidden constant [133 x i8] c"shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}** @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7091 = load i8*, i8** %_impzPtr
%zone7092 = bitcast i8* %tzone7091 to %mzone*

; let assign value to symbol shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ
%dat_shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone7092, i64 8)
%shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQPtr = bitcast i8* %dat_shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}***
%tzone7072 = load i8*, i8** %_impzPtr
%zone7073 = bitcast i8* %tzone7072 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7073)
; malloc closure structure
%clsptr7074 = call i8* @llvm_zone_malloc(%mzone* %zone7073, i64 24)
%closure7075 = bitcast i8* %clsptr7074 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}*

; malloc environment structure
%envptr7076 = call i8* @llvm_zone_malloc(%mzone* %zone7073, i64 8)
%environment7077 = bitcast i8* %envptr7076 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}***}*

; malloc closure address table
%addytable7078 = call %clsvar* @new_address_table()
%var7079 = bitcast [80 x i8]* @gsxtmgraphics-pipeline288 to i8*
%var7080 = bitcast [68 x i8]* @gsxtmgraphics-pipeline289 to i8*
%addytable7081 = call %clsvar* @add_address_table(%mzone* %zone7073, i8* %var7079, i32 0, i8* %var7080, i32 3, %clsvar* %addytable7078)
%address-table7082 = bitcast %clsvar* %addytable7081 to i8*

; insert table, function and environment into closure struct
%closure.table7085 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}* %closure7075, i32 0, i32 0
store i8* %address-table7082, i8** %closure.table7085
%closure.env7086 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}* %closure7075, i32 0, i32 1
store i8* %envptr7076, i8** %closure.env7086
%closure.func7087 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}* %closure7075, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, [4 x float], float)* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ__7054, void (i8*, i8*, %ShaderProgram*, [4 x float], float)** %closure.func7087
%closure_size7088 = call i64 @llvm_zone_mark_size(%mzone* %zone7073)
call void @llvm_zone_ptr_set_size(i8* %clsptr7074, i64 %closure_size7088)
%wrapper_ptr7089 = call i8* @llvm_zone_malloc(%mzone* %zone7073, i64 8)
%closure_wrapper7090 = bitcast i8* %wrapper_ptr7089 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}* %closure7075, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}** %closure_wrapper7090

; let value assignment
%shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}** %closure_wrapper7090, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}** %closure_wrapper7090
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}** %shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}*** %shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ
%tmp_envptr7084 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}***}* %environment7077, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}*** %shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}**** %tmp_envptr7084


%val7093 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}*** %shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}** %val7093
}


@shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}** @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ(%ShaderProgram* %arg_0,[4 x float] %arg_1,float %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, [4 x float], float)*,  void (i8*, i8*, %ShaderProgram*, [4 x float], float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, [4 x float] %arg_1, float %arg_2)
ret void
}


define dllexport ccc void @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ_native(%ShaderProgram* %arg_0,[4 x float] %arg_1,float %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, [4 x float], float)*,  void (i8*, i8*, %ShaderProgram*, [4 x float], float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, [4 x float] %arg_1, float %arg_2)
ret void
}


define dllexport ccc void @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, [4 x float], float}*
%arg_p_0 = getelementptr {%ShaderProgram*, [4 x float], float}, {%ShaderProgram*, [4 x float], float}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, [4 x float], float}, {%ShaderProgram*, [4 x float], float}* %fstruct, i32 0, i32 1
%arg_1 = load [4 x float], [4 x float]* %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, [4 x float], float}, {%ShaderProgram*, [4 x float], float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_material_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosfDQsZmxvYXR8LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, [4 x float], float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, [4 x float], float)*,  void (i8*, i8*, %ShaderProgram*, [4 x float], float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, [4 x float] %arg_1, float %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline291 = hidden constant [5 x i8] c"Bone\00"
@gsxtmgraphics-pipeline292 = hidden constant [21 x i8] c"Error updating bones\00"
@gsxtmgraphics-pipeline293 = hidden constant [67 x i8] c"shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd\00"
@gsxtmgraphics-pipeline294 = hidden constant [59 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}**\00"
@gsxtmgraphics-pipeline295 = hidden constant [9 x i8] c"bonesdat\00"
@gsxtmgraphics-pipeline296 = hidden constant [15 x i8] c"_anon_lambda_7\00"
define dllexport fastcc void @shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd__7096(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, %XTMMesh* %mesh) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7119 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***}*
%shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***}* %impenv, i32 0, i32 0
%shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpdPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}**** %shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpdPtr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***}* %impenv, i32 0, i32 1
%iPtr = load i32*, i32** %iPtr_
%bonesdatPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***}* %impenv, i32 0, i32 2
%bonesdatPtr = load float**, float*** %bonesdatPtr_
%_anon_lambda_7Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***}* %impenv, i32 0, i32 3
%_anon_lambda_7Ptr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}**** %_anon_lambda_7Ptr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%meshPtr = alloca %XTMMesh*
store %XTMMesh* %mesh, %XTMMesh** %meshPtr


%tzone7123 = load i8*, i8** %_impzPtr
%zone7124 = bitcast i8* %tzone7123 to %mzone*

; let assign value to symbol num_bones
%num_bonesPtr = alloca i32
%tzone7128 = load i8*, i8** %_impzPtr
%zone7129 = bitcast i8* %tzone7128 to %mzone*

; let assign value to symbol bones
%bonesPtr = alloca %XTMBone*
%tzone7131 = load i8*, i8** %_impzPtr
%zone7132 = bitcast i8* %tzone7131 to %mzone*

; let assign value to symbol bone
%bonePtr = alloca %XTMBone*
%tzone7139 = load i8*, i8** %_impzPtr
%zone7140 = bitcast i8* %tzone7139 to %mzone*

; let assign value to symbol mymat
%mymatPtr = alloca float*
%tzone7142 = load i8*, i8** %_impzPtr
%zone7143 = bitcast i8* %tzone7142 to %mzone*

; let assign value to symbol transmat
%transmatPtr = alloca float*
%val7120 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val7121 = getelementptr %XTMMesh, %XTMMesh* %val7120, i64 0, i32 12
%val7122 = load i32, i32* %val7121

; let value assignment
%num_bones = select i1 true, i32 %val7122, i32 %val7122
store i32 %num_bones, i32* %num_bonesPtr

%val7125 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val7126 = getelementptr %XTMMesh, %XTMMesh* %val7125, i64 0, i32 13
%val7127 = load %XTMBone*, %XTMBone** %val7126

; let value assignment
%bones = select i1 true, %XTMBone* %val7127, %XTMBone* %val7127
store %XTMBone* %bones, %XTMBone** %bonesPtr

%null7130 = bitcast i8* null to %XTMBone*

; let value assignment
%bone = select i1 true, %XTMBone* %null7130, %XTMBone* %null7130
store %XTMBone* %bone, %XTMBone** %bonePtr

%val7133 = getelementptr i64, i64* null, i32 1
%zonesize7134 = mul i64 4, 16
%tzone7135 = load i8*, i8** %_impzPtr
%zone7136 = bitcast i8* %tzone7135 to %mzone*
%dat7137 = call i8* @llvm_zone_malloc(%mzone* %zone7136, i64 %zonesize7134)
call i8* @memset(i8* %dat7137, i32 0, i64 %zonesize7134)
%val7138 = bitcast i8* %dat7137 to float*

; let value assignment
%mymat = select i1 true, float* %val7138, float* %val7138
store float* %mymat, float** %mymatPtr

%null7141 = bitcast i8* null to float*

; let value assignment
%transmat = select i1 true, float* %null7141, float* %null7141
store float* %transmat, float** %transmatPtr

%val7144 = load float*, float** %mymatPtr
call fastcc void @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %val7144)
%val7146 = load float*, float** %mymatPtr
call fastcc void @translate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0XQ(float* %val7146, float 0x4000000000000000, float 0x4000000000000000, float 0x4000000000000000)
; setup loop
%val7150 = load i32, i32* %num_bonesPtr
store i32 0, i32* %iPtr
%val7186 = load i32, i32* %iPtr
%num7187 = add i32 %val7150, %val7186
%comp7188 = icmp ult i32 %val7150, 1
br i1 %comp7188, label %after7148, label %loop7148

loop7148:
; do set!
%val7151 = load i32, i32* %iPtr
%val7152 = load %XTMBone*, %XTMBone** %bonesPtr
; pointer ref
%val7153 = getelementptr %XTMBone, %XTMBone* %val7152, i32 %val7151
store %XTMBone* %val7153, %XTMBone** %bonePtr
; do set!
%val7154 = load %XTMBone*, %XTMBone** %bonePtr
; tuple ref
%val7155 = getelementptr %XTMBone, %XTMBone* %val7154, i64 0, i32 2
%val7156 = load float*, float** %val7155
store float* %val7156, float** %transmatPtr
%val7157 = load float*, float** %mymatPtr
%val7158 = bitcast float* %val7157 to i8*
%val7159 = load float*, float** %transmatPtr
%val7160 = bitcast float* %val7159 to i8*
%val7161 = mul i64 16, 4
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val7158, i8* %val7160, i64 %val7161, i32 1, i1 0)
%val7164 = load i32, i32* %iPtr
%cmp7165 = icmp eq i32 %val7164, -1
br i1 %cmp7165, label %then7163, label %else7163

then7163:
%val7166 = load float*, float** %mymatPtr
call fastcc void @rotate_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ(float* %val7166, float 0x4049000000000000, float 0x0, float 0x3ff0000000000000, float 0x0)
%val7168 = load i32, i32* %iPtr
%val7169 = mul i32 16, %val7168
%val7170 = load float*, float** %bonesdatPtr
; pointer ref
%val7171 = getelementptr float, float* %val7170, i32 %val7169
%val7172 = bitcast float* %val7171 to i8*
%val7173 = load float*, float** %mymatPtr
%val7174 = bitcast float* %val7173 to i8*
%val7175 = mul i64 16, 4
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val7172, i8* %val7174, i64 %val7175, i32 1, i1 0)
br label %ifcont7163

else7163:
%val7177 = load i32, i32* %iPtr
%val7178 = mul i32 16, %val7177
%val7179 = load float*, float** %bonesdatPtr
; pointer ref
%val7180 = getelementptr float, float* %val7179, i32 %val7178
%val7181 = bitcast float* %val7180 to i8*
%val7182 = load float*, float** %transmatPtr
%val7183 = bitcast float* %val7182 to i8*
%val7184 = mul i64 16, 4
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val7181, i8* %val7183, i64 %val7184, i32 1, i1 0)
br label %ifcont7163

ifcont7163:
%loop_cnt7148 = load i32, i32* %iPtr
%next7148 = add i32 %loop_cnt7148, 1
store i32 %next7148, i32* %iPtr
%cmp7148 = icmp ult i32 %next7148, %num7187
br i1 %cmp7148, label %loop7148, label %after7148

after7148:
%val7190 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res7191 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val7190)
%var7192 = bitcast [5 x i8]* @gsxtmgraphics-pipeline291 to i8*
%res7193 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res7191, i8* %var7192)
%val7194 = load i8, i8* @GL_FALSE
%val7195 = load float*, float** %bonesdatPtr
call fastcc void @glUniformMatrix4fv_adhoc_W3ZvaWQsaTMyLGkzMixpOCxmbG9hdCpd(i32 %res7193, i32 20, i8 %val7194, float* %val7195)
%var7197 = bitcast [21 x i8]* @gsxtmgraphics-pipeline292 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var7197)
ret void
}
@gsxtmgraphics-pipeline297 = hidden constant [120 x i8] c"shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}** @shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7237 = load i8*, i8** %_impzPtr
%zone7238 = bitcast i8* %tzone7237 to %mzone*

; let assign value to symbol shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd
%dat_shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd = call i8* @llvm_zone_malloc(%mzone* %zone7238, i64 8)
%shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpdPtr = bitcast i8* %dat_shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***
%tzone7105 = load i8*, i8** %_impzPtr
%zone7106 = bitcast i8* %tzone7105 to %mzone*

; let assign value to symbol bonesdat
%dat_bonesdat = call i8* @llvm_zone_malloc(%mzone* %zone7106, i64 8)
%bonesdatPtr = bitcast i8* %dat_bonesdat to float**
%tzone7107 = load i8*, i8** %_impzPtr
%zone7108 = bitcast i8* %tzone7107 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone7108, i64 4)
%iPtr = bitcast i8* %dat_i to i32*
%val7097 = mul i64 16, 4
%val7098 = mul i64 %val7097, 20
%val7099 = getelementptr i64, i64* null, i32 1
%zonesize7100 = mul i64 4, %val7098
%tzone7101 = load i8*, i8** %_impzPtr
%zone7102 = bitcast i8* %tzone7101 to %mzone*
%dat7103 = call i8* @llvm_zone_malloc(%mzone* %zone7102, i64 %zonesize7100)
call i8* @memset(i8* %dat7103, i32 0, i64 %zonesize7100)
%val7104 = bitcast i8* %dat7103 to float*

; let value assignment
%bonesdat = select i1 true, float* %val7104, float* %val7104
store float* %bonesdat, float** %bonesdatPtr


; let value assignment
%i = select i1 true, i32 0, i32 0
store i32 %i, i32* %iPtr

; setup loop
store i32 0, i32* %iPtr
%val7115 = load i32, i32* %iPtr
%num7116 = add i32 20, %val7115
%comp7117 = icmp ult i32 20, 1
br i1 %comp7117, label %after7109, label %loop7109

loop7109:
%val7110 = load i32, i32* %iPtr
%val7111 = mul i32 16, %val7110
%val7112 = load float*, float** %bonesdatPtr
; pointer ref
%val7113 = getelementptr float, float* %val7112, i32 %val7111
call fastcc void @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %val7113)
%loop_cnt7109 = load i32, i32* %iPtr
%next7109 = add i32 %loop_cnt7109, 1
store i32 %next7109, i32* %iPtr
%cmp7109 = icmp ult i32 %next7109, %num7116
br i1 %cmp7109, label %loop7109, label %after7109

after7109:
%tzone7234 = load i8*, i8** %_impzPtr
%zone7235 = bitcast i8* %tzone7234 to %mzone*

; let assign value to symbol _anon_lambda_7
%dat__anon_lambda_7 = call i8* @llvm_zone_malloc(%mzone* %zone7235, i64 8)
%_anon_lambda_7Ptr = bitcast i8* %dat__anon_lambda_7 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***
%tzone7200 = load i8*, i8** %_impzPtr
%zone7201 = bitcast i8* %tzone7200 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7201)
; malloc closure structure
%clsptr7202 = call i8* @llvm_zone_malloc(%mzone* %zone7201, i64 24)
%closure7203 = bitcast i8* %clsptr7202 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}*

; malloc environment structure
%envptr7204 = call i8* @llvm_zone_malloc(%mzone* %zone7201, i64 32)
%environment7205 = bitcast i8* %envptr7204 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***}*

; malloc closure address table
%addytable7206 = call %clsvar* @new_address_table()
%var7207 = bitcast [67 x i8]* @gsxtmgraphics-pipeline293 to i8*
%var7208 = bitcast [59 x i8]* @gsxtmgraphics-pipeline294 to i8*
%addytable7209 = call %clsvar* @add_address_table(%mzone* %zone7201, i8* %var7207, i32 0, i8* %var7208, i32 3, %clsvar* %addytable7206)
%var7210 = bitcast [2 x i8]* @gsxtmgraphics-pipeline240 to i8*
%var7211 = bitcast [4 x i8]* @gsxtmgraphics-pipeline241 to i8*
%addytable7212 = call %clsvar* @add_address_table(%mzone* %zone7201, i8* %var7210, i32 8, i8* %var7211, i32 3, %clsvar* %addytable7209)
%var7213 = bitcast [9 x i8]* @gsxtmgraphics-pipeline295 to i8*
%var7214 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable7215 = call %clsvar* @add_address_table(%mzone* %zone7201, i8* %var7213, i32 16, i8* %var7214, i32 3, %clsvar* %addytable7212)
%var7216 = bitcast [15 x i8]* @gsxtmgraphics-pipeline296 to i8*
%var7217 = bitcast [59 x i8]* @gsxtmgraphics-pipeline294 to i8*
%addytable7218 = call %clsvar* @add_address_table(%mzone* %zone7201, i8* %var7216, i32 24, i8* %var7217, i32 3, %clsvar* %addytable7215)
%address-table7219 = bitcast %clsvar* %addytable7218 to i8*

; insert table, function and environment into closure struct
%closure.table7228 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}* %closure7203, i32 0, i32 0
store i8* %address-table7219, i8** %closure.table7228
%closure.env7229 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}* %closure7203, i32 0, i32 1
store i8* %envptr7204, i8** %closure.env7229
%closure.func7230 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}* %closure7203, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, %XTMMesh*)* @shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd__7096, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)** %closure.func7230
%closure_size7231 = call i64 @llvm_zone_mark_size(%mzone* %zone7201)
call void @llvm_zone_ptr_set_size(i8* %clsptr7202, i64 %closure_size7231)
%wrapper_ptr7232 = call i8* @llvm_zone_malloc(%mzone* %zone7201, i64 8)
%closure_wrapper7233 = bitcast i8* %wrapper_ptr7232 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}* %closure7203, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}** %closure_wrapper7233

; let value assignment
%_anon_lambda_7 = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}** %closure_wrapper7233, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}** %closure_wrapper7233
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}** %_anon_lambda_7, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}*** %_anon_lambda_7Ptr

; add data to environment
; don't need to alloc for env var shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd
%tmp_envptr7221 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***}* %environment7205, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}*** %shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpdPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}**** %tmp_envptr7221

; don't need to alloc for env var i
%tmp_envptr7223 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***}* %environment7205, i32 0, i32 1
store i32* %iPtr, i32** %tmp_envptr7223

; don't need to alloc for env var bonesdat
%tmp_envptr7225 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***}* %environment7205, i32 0, i32 2
store float** %bonesdatPtr, float*** %tmp_envptr7225

; don't need to alloc for env var _anon_lambda_7
%tmp_envptr7227 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***, i32*, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}***}* %environment7205, i32 0, i32 3
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}*** %_anon_lambda_7Ptr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}**** %tmp_envptr7227


%val7236 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}*** %_anon_lambda_7Ptr

; let value assignment
%shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd = select i1 true, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}** %val7236, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}** %val7236
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}** %shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}*** %shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpdPtr

%val7239 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}*** %shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpdPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}** %val7239
}


@shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd_var = dllexport global [1 x i8*] [ i8* null ]

@shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}** @shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd(%ShaderProgram* %arg_0,%XTMMesh* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*,  void (i8*, i8*, %ShaderProgram*, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %XTMMesh* %arg_1)
ret void
}


define dllexport ccc void @shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd_native(%ShaderProgram* %arg_0,%XTMMesh* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*,  void (i8*, i8*, %ShaderProgram*, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %XTMMesh* %arg_1)
ret void
}


define dllexport ccc i8*  @shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7240 = bitcast [120 x i8]* @gsxtmgraphics-pipeline297 to i8*
call i32 (i8*, ...) @printf(i8* %var7240)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var7241 = bitcast [120 x i8]* @gsxtmgraphics-pipeline297 to i8*
call i32 (i8*, ...) @printf(i8* %var7241)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %XTMMesh*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*,  void (i8*, i8*, %ShaderProgram*, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %XTMMesh* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, %XTMMesh*}*
%arg_p_0 = getelementptr {%ShaderProgram*, %XTMMesh*}, {%ShaderProgram*, %XTMMesh*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, %XTMMesh*}, {%ShaderProgram*, %XTMMesh*}* %fstruct, i32 0, i32 1
%arg_1 = load %XTMMesh*, %XTMMesh** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %XTMMesh*)*,  void (i8*, i8*, %ShaderProgram*, %XTMMesh*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %XTMMesh* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@PROJECTION_TEXTURE_WEIGHT = dllexport global float 0x3fe0000000000000
@gsxtmgraphics-pipeline298 = hidden constant [21 x i8] c"isProjectionTextured\00"
@gsxtmgraphics-pipeline299 = hidden constant [18 x i8] c"projectionTexture\00"
@gsxtmgraphics-pipeline300 = hidden constant [24 x i8] c"projectionTextureWeight\00"
@gsxtmgraphics-pipeline301 = hidden constant [36 x i8] c"Error setting up projection texture\00"
@gsxtmgraphics-pipeline302 = hidden constant [86 x i8] c"shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ\00"
@gsxtmgraphics-pipeline303 = hidden constant [64 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}**\00"
define dllexport fastcc void @shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ__7242(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, i32 %textureUnit, %Texture* %texture) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7243 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}***}*
%shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}***}* %impenv, i32 0, i32 0
%shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}**** %shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQPtr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%textureUnitPtr = alloca i32
store i32 %textureUnit, i32* %textureUnitPtr
%texturePtr = alloca %Texture*
store %Texture* %texture, %Texture** %texturePtr

; promote local stack var allocations
%tzone7300 = load i8*, i8** %_impzPtr
%zone7301 = bitcast i8* %tzone7300 to %mzone*
%ifptr7245 = alloca i1
%ifptr7250 = alloca i1

%val7246 = load %Texture*, %Texture** %texturePtr
%val7247 = icmp eq %Texture* %val7246, null
br i1 %val7247, label %then7245, label %else7245

then7245:
%val7248 = load %Texture*, %Texture** %texturePtr
%val7249 = icmp eq %Texture* %val7248, null
store i1 %val7249, i1* %ifptr7245
br label %ifcont7245

else7245:
%val7251 = load %Texture*, %Texture** %texturePtr
%res7252 = call fastcc i32 @id_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val7251)
%cmp7253 = icmp slt i32 %res7252, 1
br i1 %cmp7253, label %then7250, label %else7250

then7250:
%val7254 = load %Texture*, %Texture** %texturePtr
%res7255 = call fastcc i32 @id_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val7254)
%cmp7256 = icmp slt i32 %res7255, 1
store i1 %cmp7256, i1* %ifptr7250
br label %ifcont7250

else7250:
%res7257 = call ccc i1 @impc_false()
store i1 %res7257, i1* %ifptr7250
br label %ifcont7250

ifcont7250:
%ifres7258 = load i1, i1* %ifptr7250

store i1 %ifres7258, i1* %ifptr7245
br label %ifcont7245

ifcont7245:
%ifres7259 = load i1, i1* %ifptr7245

br i1 %ifres7259, label %then7244, label %else7244

then7244:
%val7260 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res7261 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val7260)
%var7262 = bitcast [21 x i8]* @gsxtmgraphics-pipeline298 to i8*
%res7263 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res7261, i8* %var7262)
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res7263, i32 0)
%val7265 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res7266 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val7265)
%var7267 = bitcast [18 x i8]* @gsxtmgraphics-pipeline299 to i8*
%res7268 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res7266, i8* %var7267)
%val7269 = load i32, i32* %textureUnitPtr
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res7268, i32 %val7269)
%val7271 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res7272 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val7271)
%var7273 = bitcast [24 x i8]* @gsxtmgraphics-pipeline300 to i8*
%res7274 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res7272, i8* %var7273)
%val7275 = load float, float* @PROJECTION_TEXTURE_WEIGHT
call fastcc void @glUniform1f_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %res7274, float %val7275)
br label %ifcont7244

else7244:
%val7277 = load %Texture*, %Texture** %texturePtr
%val7278 = load i32, i32* %textureUnitPtr
%res7279 = call fastcc i32 @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd(%Texture* %val7277, i32 %val7278)
%val7280 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res7281 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val7280)
%var7282 = bitcast [24 x i8]* @gsxtmgraphics-pipeline300 to i8*
%res7283 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res7281, i8* %var7282)
%val7284 = load float, float* @PROJECTION_TEXTURE_WEIGHT
call fastcc void @glUniform1f_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %res7283, float %val7284)
%val7286 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res7287 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val7286)
%var7288 = bitcast [21 x i8]* @gsxtmgraphics-pipeline298 to i8*
%res7289 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res7287, i8* %var7288)
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res7289, i32 1)
%val7291 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res7292 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val7291)
%var7293 = bitcast [18 x i8]* @gsxtmgraphics-pipeline299 to i8*
%res7294 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res7292, i8* %var7293)
%val7295 = load i32, i32* %textureUnitPtr
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res7294, i32 %val7295)
br label %ifcont7244

ifcont7244:
%var7297 = bitcast [36 x i8]* @gsxtmgraphics-pipeline301 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var7297)
ret void
}
@gsxtmgraphics-pipeline304 = hidden constant [139 x i8] c"shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** @shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7321 = load i8*, i8** %_impzPtr
%zone7322 = bitcast i8* %tzone7321 to %mzone*

; let assign value to symbol shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ
%dat_shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone7322, i64 8)
%shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQPtr = bitcast i8* %dat_shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}***
%tzone7302 = load i8*, i8** %_impzPtr
%zone7303 = bitcast i8* %tzone7302 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7303)
; malloc closure structure
%clsptr7304 = call i8* @llvm_zone_malloc(%mzone* %zone7303, i64 24)
%closure7305 = bitcast i8* %clsptr7304 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}*

; malloc environment structure
%envptr7306 = call i8* @llvm_zone_malloc(%mzone* %zone7303, i64 8)
%environment7307 = bitcast i8* %envptr7306 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}***}*

; malloc closure address table
%addytable7308 = call %clsvar* @new_address_table()
%var7309 = bitcast [86 x i8]* @gsxtmgraphics-pipeline302 to i8*
%var7310 = bitcast [64 x i8]* @gsxtmgraphics-pipeline303 to i8*
%addytable7311 = call %clsvar* @add_address_table(%mzone* %zone7303, i8* %var7309, i32 0, i8* %var7310, i32 3, %clsvar* %addytable7308)
%address-table7312 = bitcast %clsvar* %addytable7311 to i8*

; insert table, function and environment into closure struct
%closure.table7315 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure7305, i32 0, i32 0
store i8* %address-table7312, i8** %closure.table7315
%closure.env7316 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure7305, i32 0, i32 1
store i8* %envptr7306, i8** %closure.env7316
%closure.func7317 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure7305, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, i32, %Texture*)* @shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ__7242, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)** %closure.func7317
%closure_size7318 = call i64 @llvm_zone_mark_size(%mzone* %zone7303)
call void @llvm_zone_ptr_set_size(i8* %clsptr7304, i64 %closure_size7318)
%wrapper_ptr7319 = call i8* @llvm_zone_malloc(%mzone* %zone7303, i64 8)
%closure_wrapper7320 = bitcast i8* %wrapper_ptr7319 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure7305, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** %closure_wrapper7320

; let value assignment
%shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** %closure_wrapper7320, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** %closure_wrapper7320
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** %shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}*** %shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQPtr

; add data to environment
; don't need to alloc for env var shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ
%tmp_envptr7314 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}***}* %environment7307, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}*** %shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}**** %tmp_envptr7314


%val7323 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}*** %shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** %val7323
}


@shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** @shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ(%ShaderProgram* %arg_0,i32 %arg_1,%Texture* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*,  void (i8*, i8*, %ShaderProgram*, i32, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, i32 %arg_1, %Texture* %arg_2)
ret void
}


define dllexport ccc void @shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_native(%ShaderProgram* %arg_0,i32 %arg_1,%Texture* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*,  void (i8*, i8*, %ShaderProgram*, i32, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, i32 %arg_1, %Texture* %arg_2)
ret void
}


define dllexport ccc i8*  @shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7324 = bitcast [139 x i8]* @gsxtmgraphics-pipeline304 to i8*
call i32 (i8*, ...) @printf(i8* %var7324)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var7325 = bitcast [139 x i8]* @gsxtmgraphics-pipeline304 to i8*
call i32 (i8*, ...) @printf(i8* %var7325)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var7326 = bitcast [139 x i8]* @gsxtmgraphics-pipeline304 to i8*
call i32 (i8*, ...) @printf(i8* %var7326)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*,  void (i8*, i8*, %ShaderProgram*, i32, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, i32 %arg_1, %Texture* %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, i32, %Texture*}*
%arg_p_0 = getelementptr {%ShaderProgram*, i32, %Texture*}, {%ShaderProgram*, i32, %Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, i32, %Texture*}, {%ShaderProgram*, i32, %Texture*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, i32, %Texture*}, {%ShaderProgram*, i32, %Texture*}* %fstruct, i32 0, i32 2
%arg_2 = load %Texture*, %Texture** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*,  void (i8*, i8*, %ShaderProgram*, i32, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, i32 %arg_1, %Texture* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@ENV_MAP_WEIGHT = dllexport global float 0x3ff0000000000000
@gsxtmgraphics-pipeline305 = hidden constant [12 x i8] c"isEnvMapped\00"
@gsxtmgraphics-pipeline306 = hidden constant [13 x i8] c"envMapWeight\00"
@gsxtmgraphics-pipeline307 = hidden constant [7 x i8] c"envMap\00"
@gsxtmgraphics-pipeline308 = hidden constant [25 x i8] c"Error setting up envmap!\00"
@gsxtmgraphics-pipeline309 = hidden constant [74 x i8] c"shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ\00"
define dllexport fastcc void @shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ__7327(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, i32 %textureUnit, %Texture* %texture) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7328 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}***}*
%shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}***}* %impenv, i32 0, i32 0
%shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}**** %shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQPtr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%textureUnitPtr = alloca i32
store i32 %textureUnit, i32* %textureUnitPtr
%texturePtr = alloca %Texture*
store %Texture* %texture, %Texture** %texturePtr

; promote local stack var allocations
%tzone7387 = load i8*, i8** %_impzPtr
%zone7388 = bitcast i8* %tzone7387 to %mzone*
%ifptr7330 = alloca i1
%ifptr7335 = alloca i1

%val7331 = load %Texture*, %Texture** %texturePtr
%val7332 = icmp eq %Texture* %val7331, null
br i1 %val7332, label %then7330, label %else7330

then7330:
%val7333 = load %Texture*, %Texture** %texturePtr
%val7334 = icmp eq %Texture* %val7333, null
store i1 %val7334, i1* %ifptr7330
br label %ifcont7330

else7330:
%val7336 = load %Texture*, %Texture** %texturePtr
%res7337 = call fastcc i32 @id_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val7336)
%cmp7338 = icmp slt i32 %res7337, 1
br i1 %cmp7338, label %then7335, label %else7335

then7335:
%val7339 = load %Texture*, %Texture** %texturePtr
%res7340 = call fastcc i32 @id_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val7339)
%cmp7341 = icmp slt i32 %res7340, 1
store i1 %cmp7341, i1* %ifptr7335
br label %ifcont7335

else7335:
%res7342 = call ccc i1 @impc_false()
store i1 %res7342, i1* %ifptr7335
br label %ifcont7335

ifcont7335:
%ifres7343 = load i1, i1* %ifptr7335

store i1 %ifres7343, i1* %ifptr7330
br label %ifcont7330

ifcont7330:
%ifres7344 = load i1, i1* %ifptr7330

br i1 %ifres7344, label %then7329, label %else7329

then7329:
%val7345 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res7346 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val7345)
%var7347 = bitcast [12 x i8]* @gsxtmgraphics-pipeline305 to i8*
%res7348 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res7346, i8* %var7347)
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res7348, i32 0)
%val7350 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res7351 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val7350)
%var7352 = bitcast [13 x i8]* @gsxtmgraphics-pipeline306 to i8*
%res7353 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res7351, i8* %var7352)
%val7354 = load float, float* @ENV_MAP_WEIGHT
call fastcc void @glUniform1f_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %res7353, float %val7354)
%val7356 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res7357 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val7356)
%var7358 = bitcast [7 x i8]* @gsxtmgraphics-pipeline307 to i8*
%res7359 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res7357, i8* %var7358)
%val7360 = load i32, i32* %textureUnitPtr
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res7359, i32 %val7360)
br label %ifcont7329

else7329:
%val7363 = load %Texture*, %Texture** %texturePtr
%val7364 = load i32, i32* %textureUnitPtr
%res7365 = call fastcc i32 @bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd(%Texture* %val7363, i32 %val7364)
%val7366 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res7367 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val7366)
%var7368 = bitcast [12 x i8]* @gsxtmgraphics-pipeline305 to i8*
%res7369 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res7367, i8* %var7368)
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res7369, i32 1)
%val7371 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res7372 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val7371)
%var7373 = bitcast [13 x i8]* @gsxtmgraphics-pipeline306 to i8*
%res7374 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res7372, i8* %var7373)
%val7375 = load float, float* @ENV_MAP_WEIGHT
call fastcc void @glUniform1f_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %res7374, float %val7375)
%val7377 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res7378 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val7377)
%var7379 = bitcast [7 x i8]* @gsxtmgraphics-pipeline307 to i8*
%res7380 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res7378, i8* %var7379)
%val7381 = load i32, i32* %textureUnitPtr
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res7380, i32 %val7381)
br label %ifcont7329

ifcont7329:
%var7384 = bitcast [25 x i8]* @gsxtmgraphics-pipeline308 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var7384)
ret void
}
@gsxtmgraphics-pipeline310 = hidden constant [127 x i8] c"shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** @shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7408 = load i8*, i8** %_impzPtr
%zone7409 = bitcast i8* %tzone7408 to %mzone*

; let assign value to symbol shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ
%dat_shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone7409, i64 8)
%shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQPtr = bitcast i8* %dat_shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}***
%tzone7389 = load i8*, i8** %_impzPtr
%zone7390 = bitcast i8* %tzone7389 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7390)
; malloc closure structure
%clsptr7391 = call i8* @llvm_zone_malloc(%mzone* %zone7390, i64 24)
%closure7392 = bitcast i8* %clsptr7391 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}*

; malloc environment structure
%envptr7393 = call i8* @llvm_zone_malloc(%mzone* %zone7390, i64 8)
%environment7394 = bitcast i8* %envptr7393 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}***}*

; malloc closure address table
%addytable7395 = call %clsvar* @new_address_table()
%var7396 = bitcast [74 x i8]* @gsxtmgraphics-pipeline309 to i8*
%var7397 = bitcast [64 x i8]* @gsxtmgraphics-pipeline303 to i8*
%addytable7398 = call %clsvar* @add_address_table(%mzone* %zone7390, i8* %var7396, i32 0, i8* %var7397, i32 3, %clsvar* %addytable7395)
%address-table7399 = bitcast %clsvar* %addytable7398 to i8*

; insert table, function and environment into closure struct
%closure.table7402 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure7392, i32 0, i32 0
store i8* %address-table7399, i8** %closure.table7402
%closure.env7403 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure7392, i32 0, i32 1
store i8* %envptr7393, i8** %closure.env7403
%closure.func7404 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure7392, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, i32, %Texture*)* @shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ__7327, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)** %closure.func7404
%closure_size7405 = call i64 @llvm_zone_mark_size(%mzone* %zone7390)
call void @llvm_zone_ptr_set_size(i8* %clsptr7391, i64 %closure_size7405)
%wrapper_ptr7406 = call i8* @llvm_zone_malloc(%mzone* %zone7390, i64 8)
%closure_wrapper7407 = bitcast i8* %wrapper_ptr7406 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure7392, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** %closure_wrapper7407

; let value assignment
%shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** %closure_wrapper7407, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** %closure_wrapper7407
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** %shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}*** %shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQPtr

; add data to environment
; don't need to alloc for env var shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ
%tmp_envptr7401 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}***}* %environment7394, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}*** %shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}**** %tmp_envptr7401


%val7410 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}*** %shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** %val7410
}


@shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** @shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ(%ShaderProgram* %arg_0,i32 %arg_1,%Texture* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*,  void (i8*, i8*, %ShaderProgram*, i32, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, i32 %arg_1, %Texture* %arg_2)
ret void
}


define dllexport ccc void @shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_native(%ShaderProgram* %arg_0,i32 %arg_1,%Texture* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*,  void (i8*, i8*, %ShaderProgram*, i32, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, i32 %arg_1, %Texture* %arg_2)
ret void
}


define dllexport ccc i8*  @shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7411 = bitcast [127 x i8]* @gsxtmgraphics-pipeline310 to i8*
call i32 (i8*, ...) @printf(i8* %var7411)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var7412 = bitcast [127 x i8]* @gsxtmgraphics-pipeline310 to i8*
call i32 (i8*, ...) @printf(i8* %var7412)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var7413 = bitcast [127 x i8]* @gsxtmgraphics-pipeline310 to i8*
call i32 (i8*, ...) @printf(i8* %var7413)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*,  void (i8*, i8*, %ShaderProgram*, i32, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, i32 %arg_1, %Texture* %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, i32, %Texture*}*
%arg_p_0 = getelementptr {%ShaderProgram*, i32, %Texture*}, {%ShaderProgram*, i32, %Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, i32, %Texture*}, {%ShaderProgram*, i32, %Texture*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, i32, %Texture*}, {%ShaderProgram*, i32, %Texture*}* %fstruct, i32 0, i32 2
%arg_2 = load %Texture*, %Texture** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, i32, %Texture*)*,  void (i8*, i8*, %ShaderProgram*, i32, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, i32 %arg_1, %Texture* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline311 = hidden constant [9 x i8] c"isPoints\00"
@gsxtmgraphics-pipeline312 = hidden constant [11 x i8] c"isTextured\00"
@gsxtmgraphics-pipeline313 = hidden constant [10 x i8] c"instances\00"
@gsxtmgraphics-pipeline314 = hidden constant [77 x i8] c"shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ\00"
@gsxtmgraphics-pipeline315 = hidden constant [68 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}**\00"
define dllexport fastcc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ__7414(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, %Texture* %tex, i32 %instances, i1 %is_points) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7415 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}***}*
%shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}***}* %impenv, i32 0, i32 0
%shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}**** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQPtr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr
%instancesPtr = alloca i32
store i32 %instances, i32* %instancesPtr
%is_pointsPtr = alloca i1
store i1 %is_points, i1* %is_pointsPtr

; promote local stack var allocations
%tzone7460 = load i8*, i8** %_impzPtr
%zone7461 = bitcast i8* %tzone7460 to %mzone*
%ifptr7428 = alloca i32
%ifptr7429 = alloca i1
%ifptr7434 = alloca i1
%ifptr7420 = alloca i32

%val7416 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res7417 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val7416)
%var7418 = bitcast [9 x i8]* @gsxtmgraphics-pipeline311 to i8*
%res7419 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res7417, i8* %var7418)
%val7421 = load i1, i1* %is_pointsPtr
br i1 %val7421, label %then7420, label %else7420

then7420:
store i32 1, i32* %ifptr7420
br label %ifcont7420

else7420:
store i32 0, i32* %ifptr7420
br label %ifcont7420

ifcont7420:
%ifres7422 = load i32, i32* %ifptr7420

call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res7419, i32 %ifres7422)
%val7424 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res7425 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val7424)
%var7426 = bitcast [11 x i8]* @gsxtmgraphics-pipeline312 to i8*
%res7427 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res7425, i8* %var7426)
%val7430 = load %Texture*, %Texture** %texPtr
%val7431 = icmp eq %Texture* %val7430, null
br i1 %val7431, label %then7429, label %else7429

then7429:
%val7432 = load %Texture*, %Texture** %texPtr
%val7433 = icmp eq %Texture* %val7432, null
store i1 %val7433, i1* %ifptr7429
br label %ifcont7429

else7429:
%val7435 = load i1, i1* %is_pointsPtr
br i1 %val7435, label %then7434, label %else7434

then7434:
%val7436 = load i1, i1* %is_pointsPtr
store i1 %val7436, i1* %ifptr7434
br label %ifcont7434

else7434:
%res7437 = call ccc i1 @impc_false()
store i1 %res7437, i1* %ifptr7434
br label %ifcont7434

ifcont7434:
%ifres7438 = load i1, i1* %ifptr7434

store i1 %ifres7438, i1* %ifptr7429
br label %ifcont7429

ifcont7429:
%ifres7439 = load i1, i1* %ifptr7429

br i1 %ifres7439, label %then7428, label %else7428

then7428:
store i32 0, i32* %ifptr7428
br label %ifcont7428

else7428:
store i32 1, i32* %ifptr7428
br label %ifcont7428

ifcont7428:
%ifres7440 = load i32, i32* %ifptr7428

call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res7427, i32 %ifres7440)
%val7442 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res7443 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val7442)
%var7444 = bitcast [15 x i8]* @gsxtmgraphics-pipeline209 to i8*
%res7445 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res7443, i8* %var7444)
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res7445, i32 1)
%val7447 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res7448 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val7447)
%var7449 = bitcast [10 x i8]* @gsxtmgraphics-pipeline313 to i8*
%res7450 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res7448, i8* %var7449)
%val7451 = load i32, i32* %instancesPtr
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res7450, i32 %val7451)
%val7453 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res7454 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val7453)
%var7455 = bitcast [12 x i8]* @gsxtmgraphics-pipeline276 to i8*
%res7456 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res7454, i8* %var7455)
%val7457 = load i32, i32* @XTM_EMIT_VCOLOUR
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res7456, i32 %val7457)
ret void
}
@gsxtmgraphics-pipeline316 = hidden constant [130 x i8] c"shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}** @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7481 = load i8*, i8** %_impzPtr
%zone7482 = bitcast i8* %tzone7481 to %mzone*

; let assign value to symbol shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ
%dat_shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ = call i8* @llvm_zone_malloc(%mzone* %zone7482, i64 8)
%shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQPtr = bitcast i8* %dat_shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}***
%tzone7462 = load i8*, i8** %_impzPtr
%zone7463 = bitcast i8* %tzone7462 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7463)
; malloc closure structure
%clsptr7464 = call i8* @llvm_zone_malloc(%mzone* %zone7463, i64 24)
%closure7465 = bitcast i8* %clsptr7464 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}*

; malloc environment structure
%envptr7466 = call i8* @llvm_zone_malloc(%mzone* %zone7463, i64 8)
%environment7467 = bitcast i8* %envptr7466 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}***}*

; malloc closure address table
%addytable7468 = call %clsvar* @new_address_table()
%var7469 = bitcast [77 x i8]* @gsxtmgraphics-pipeline314 to i8*
%var7470 = bitcast [68 x i8]* @gsxtmgraphics-pipeline315 to i8*
%addytable7471 = call %clsvar* @add_address_table(%mzone* %zone7463, i8* %var7469, i32 0, i8* %var7470, i32 3, %clsvar* %addytable7468)
%address-table7472 = bitcast %clsvar* %addytable7471 to i8*

; insert table, function and environment into closure struct
%closure.table7475 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}* %closure7465, i32 0, i32 0
store i8* %address-table7472, i8** %closure.table7475
%closure.env7476 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}* %closure7465, i32 0, i32 1
store i8* %envptr7466, i8** %closure.env7476
%closure.func7477 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}* %closure7465, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ__7414, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)** %closure.func7477
%closure_size7478 = call i64 @llvm_zone_mark_size(%mzone* %zone7463)
call void @llvm_zone_ptr_set_size(i8* %clsptr7464, i64 %closure_size7478)
%wrapper_ptr7479 = call i8* @llvm_zone_malloc(%mzone* %zone7463, i64 8)
%closure_wrapper7480 = bitcast i8* %wrapper_ptr7479 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}* %closure7465, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}** %closure_wrapper7480

; let value assignment
%shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}** %closure_wrapper7480, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}** %closure_wrapper7480
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}*** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQPtr

; add data to environment
; don't need to alloc for env var shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ
%tmp_envptr7474 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}***}* %environment7467, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}*** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}**** %tmp_envptr7474


%val7483 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}*** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}** %val7483
}


@shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ_var = dllexport global [1 x i8*] [ i8* null ]

@shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}** @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ(%ShaderProgram* %arg_0,%Texture* %arg_1,i32 %arg_2,i1 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, i32 %arg_2, i1 %arg_3)
ret void
}


define dllexport ccc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ_native(%ShaderProgram* %arg_0,%Texture* %arg_1,i32 %arg_2,i1 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, i32 %arg_2, i1 %arg_3)
ret void
}


define dllexport ccc i8*  @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7484 = bitcast [130 x i8]* @gsxtmgraphics-pipeline316 to i8*
call i32 (i8*, ...) @printf(i8* %var7484)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var7485 = bitcast [130 x i8]* @gsxtmgraphics-pipeline316 to i8*
call i32 (i8*, ...) @printf(i8* %var7485)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Texture*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var7486 = bitcast [130 x i8]* @gsxtmgraphics-pipeline316 to i8*
call i32 (i8*, ...) @printf(i8* %var7486)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var7487 = bitcast [130 x i8]* @gsxtmgraphics-pipeline316 to i8*
call i32 (i8*, ...) @printf(i8* %var7487)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i1  @i1value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, i32 %arg_2, i1 %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, %Texture*, i32, i1}*
%arg_p_0 = getelementptr {%ShaderProgram*, %Texture*, i32, i1}, {%ShaderProgram*, %Texture*, i32, i1}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, %Texture*, i32, i1}, {%ShaderProgram*, %Texture*, i32, i1}* %fstruct, i32 0, i32 1
%arg_1 = load %Texture*, %Texture** %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, %Texture*, i32, i1}, {%ShaderProgram*, %Texture*, i32, i1}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {%ShaderProgram*, %Texture*, i32, i1}, {%ShaderProgram*, %Texture*, i32, i1}* %fstruct, i32 0, i32 3
%arg_3 = load i1, i1* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, i32 %arg_2, i1 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline317 = hidden constant [67 x i8] c"shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd\00"
@gsxtmgraphics-pipeline318 = hidden constant [59 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}**\00"
define dllexport fastcc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd__7488(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, %Texture* %tex) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7489 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}***}*
%shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}***}* %impenv, i32 0, i32 0
%shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpdPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}**** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpdPtr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr


%val7490 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val7491 = load %Texture*, %Texture** %texPtr
%res7492 = call ccc i1 @impc_false()
call fastcc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ(%ShaderProgram* %val7490, %Texture* %val7491, i32 0, i1 %res7492)
ret void
}
@gsxtmgraphics-pipeline319 = hidden constant [120 x i8] c"shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}** @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7514 = load i8*, i8** %_impzPtr
%zone7515 = bitcast i8* %tzone7514 to %mzone*

; let assign value to symbol shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd
%dat_shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd = call i8* @llvm_zone_malloc(%mzone* %zone7515, i64 8)
%shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpdPtr = bitcast i8* %dat_shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}***
%tzone7495 = load i8*, i8** %_impzPtr
%zone7496 = bitcast i8* %tzone7495 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7496)
; malloc closure structure
%clsptr7497 = call i8* @llvm_zone_malloc(%mzone* %zone7496, i64 24)
%closure7498 = bitcast i8* %clsptr7497 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}*

; malloc environment structure
%envptr7499 = call i8* @llvm_zone_malloc(%mzone* %zone7496, i64 8)
%environment7500 = bitcast i8* %envptr7499 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}***}*

; malloc closure address table
%addytable7501 = call %clsvar* @new_address_table()
%var7502 = bitcast [67 x i8]* @gsxtmgraphics-pipeline317 to i8*
%var7503 = bitcast [59 x i8]* @gsxtmgraphics-pipeline318 to i8*
%addytable7504 = call %clsvar* @add_address_table(%mzone* %zone7496, i8* %var7502, i32 0, i8* %var7503, i32 3, %clsvar* %addytable7501)
%address-table7505 = bitcast %clsvar* %addytable7504 to i8*

; insert table, function and environment into closure struct
%closure.table7508 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}* %closure7498, i32 0, i32 0
store i8* %address-table7505, i8** %closure.table7508
%closure.env7509 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}* %closure7498, i32 0, i32 1
store i8* %envptr7499, i8** %closure.env7509
%closure.func7510 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}* %closure7498, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, %Texture*)* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd__7488, void (i8*, i8*, %ShaderProgram*, %Texture*)** %closure.func7510
%closure_size7511 = call i64 @llvm_zone_mark_size(%mzone* %zone7496)
call void @llvm_zone_ptr_set_size(i8* %clsptr7497, i64 %closure_size7511)
%wrapper_ptr7512 = call i8* @llvm_zone_malloc(%mzone* %zone7496, i64 8)
%closure_wrapper7513 = bitcast i8* %wrapper_ptr7512 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}* %closure7498, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}** %closure_wrapper7513

; let value assignment
%shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}** %closure_wrapper7513, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}** %closure_wrapper7513
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}*** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpdPtr

; add data to environment
; don't need to alloc for env var shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd
%tmp_envptr7507 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}***}* %environment7500, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}*** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpdPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}**** %tmp_envptr7507


%val7516 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}*** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpdPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}** %val7516
}


@shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}** @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd(%ShaderProgram* %arg_0,%Texture* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1)
ret void
}


define dllexport ccc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd_native(%ShaderProgram* %arg_0,%Texture* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1)
ret void
}


define dllexport ccc i8*  @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7517 = bitcast [120 x i8]* @gsxtmgraphics-pipeline319 to i8*
call i32 (i8*, ...) @printf(i8* %var7517)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var7518 = bitcast [120 x i8]* @gsxtmgraphics-pipeline319 to i8*
call i32 (i8*, ...) @printf(i8* %var7518)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, %Texture*}*
%arg_p_0 = getelementptr {%ShaderProgram*, %Texture*}, {%ShaderProgram*, %Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, %Texture*}, {%ShaderProgram*, %Texture*}* %fstruct, i32 0, i32 1
%arg_1 = load %Texture*, %Texture** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline320 = hidden constant [71 x i8] c"shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd\00"
@gsxtmgraphics-pipeline321 = hidden constant [63 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}**\00"
define dllexport fastcc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd__7519(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, %Texture* %tex, i1 %pointTex) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7520 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}***}*
%shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}***}* %impenv, i32 0, i32 0
%shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFdPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}**** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFdPtr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr
%pointTexPtr = alloca i1
store i1 %pointTex, i1* %pointTexPtr


%val7521 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val7522 = load %Texture*, %Texture** %texPtr
%val7523 = load i1, i1* %pointTexPtr
call fastcc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ(%ShaderProgram* %val7521, %Texture* %val7522, i32 0, i1 %val7523)
ret void
}
@gsxtmgraphics-pipeline322 = hidden constant [124 x i8] c"shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}** @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7545 = load i8*, i8** %_impzPtr
%zone7546 = bitcast i8* %tzone7545 to %mzone*

; let assign value to symbol shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd
%dat_shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd = call i8* @llvm_zone_malloc(%mzone* %zone7546, i64 8)
%shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFdPtr = bitcast i8* %dat_shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}***
%tzone7526 = load i8*, i8** %_impzPtr
%zone7527 = bitcast i8* %tzone7526 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7527)
; malloc closure structure
%clsptr7528 = call i8* @llvm_zone_malloc(%mzone* %zone7527, i64 24)
%closure7529 = bitcast i8* %clsptr7528 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}*

; malloc environment structure
%envptr7530 = call i8* @llvm_zone_malloc(%mzone* %zone7527, i64 8)
%environment7531 = bitcast i8* %envptr7530 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}***}*

; malloc closure address table
%addytable7532 = call %clsvar* @new_address_table()
%var7533 = bitcast [71 x i8]* @gsxtmgraphics-pipeline320 to i8*
%var7534 = bitcast [63 x i8]* @gsxtmgraphics-pipeline321 to i8*
%addytable7535 = call %clsvar* @add_address_table(%mzone* %zone7527, i8* %var7533, i32 0, i8* %var7534, i32 3, %clsvar* %addytable7532)
%address-table7536 = bitcast %clsvar* %addytable7535 to i8*

; insert table, function and environment into closure struct
%closure.table7539 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}* %closure7529, i32 0, i32 0
store i8* %address-table7536, i8** %closure.table7539
%closure.env7540 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}* %closure7529, i32 0, i32 1
store i8* %envptr7530, i8** %closure.env7540
%closure.func7541 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}* %closure7529, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, %Texture*, i1)* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd__7519, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)** %closure.func7541
%closure_size7542 = call i64 @llvm_zone_mark_size(%mzone* %zone7527)
call void @llvm_zone_ptr_set_size(i8* %clsptr7528, i64 %closure_size7542)
%wrapper_ptr7543 = call i8* @llvm_zone_malloc(%mzone* %zone7527, i64 8)
%closure_wrapper7544 = bitcast i8* %wrapper_ptr7543 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}* %closure7529, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}** %closure_wrapper7544

; let value assignment
%shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}** %closure_wrapper7544, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}** %closure_wrapper7544
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}*** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFdPtr

; add data to environment
; don't need to alloc for env var shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd
%tmp_envptr7538 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}***}* %environment7531, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}*** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFdPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}**** %tmp_envptr7538


%val7547 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}*** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFdPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}** %val7547
}


@shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd_var = dllexport global [1 x i8*] [ i8* null ]

@shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}** @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd(%ShaderProgram* %arg_0,%Texture* %arg_1,i1 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, i1 %arg_2)
ret void
}


define dllexport ccc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd_native(%ShaderProgram* %arg_0,%Texture* %arg_1,i1 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, i1 %arg_2)
ret void
}


define dllexport ccc i8*  @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7548 = bitcast [124 x i8]* @gsxtmgraphics-pipeline322 to i8*
call i32 (i8*, ...) @printf(i8* %var7548)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var7549 = bitcast [124 x i8]* @gsxtmgraphics-pipeline322 to i8*
call i32 (i8*, ...) @printf(i8* %var7549)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Texture*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var7550 = bitcast [124 x i8]* @gsxtmgraphics-pipeline322 to i8*
call i32 (i8*, ...) @printf(i8* %var7550)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i1  @i1value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, i1 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, %Texture*, i1}*
%arg_p_0 = getelementptr {%ShaderProgram*, %Texture*, i1}, {%ShaderProgram*, %Texture*, i1}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, %Texture*, i1}, {%ShaderProgram*, %Texture*, i1}* %fstruct, i32 0, i32 1
%arg_1 = load %Texture*, %Texture** %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, %Texture*, i1}, {%ShaderProgram*, %Texture*, i1}* %fstruct, i32 0, i32 2
%arg_2 = load i1, i1* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, i1)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, i1 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline323 = hidden constant [61 x i8] c"shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ\00"
@gsxtmgraphics-pipeline324 = hidden constant [53 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}**\00"
define dllexport fastcc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ__7551(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, i32 %instances) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7552 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}***}*
%shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}***}* %impenv, i32 0, i32 0
%shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}**** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQPtr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%instancesPtr = alloca i32
store i32 %instances, i32* %instancesPtr


%val7553 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%null7554 = bitcast i8* null to %Texture*
%val7555 = load i32, i32* %instancesPtr
%res7556 = call ccc i1 @impc_false()
call fastcc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ(%ShaderProgram* %val7553, %Texture* %null7554, i32 %val7555, i1 %res7556)
ret void
}
@gsxtmgraphics-pipeline325 = hidden constant [114 x i8] c"shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}** @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7578 = load i8*, i8** %_impzPtr
%zone7579 = bitcast i8* %tzone7578 to %mzone*

; let assign value to symbol shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ
%dat_shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone7579, i64 8)
%shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQPtr = bitcast i8* %dat_shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}***
%tzone7559 = load i8*, i8** %_impzPtr
%zone7560 = bitcast i8* %tzone7559 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7560)
; malloc closure structure
%clsptr7561 = call i8* @llvm_zone_malloc(%mzone* %zone7560, i64 24)
%closure7562 = bitcast i8* %clsptr7561 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}*

; malloc environment structure
%envptr7563 = call i8* @llvm_zone_malloc(%mzone* %zone7560, i64 8)
%environment7564 = bitcast i8* %envptr7563 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}***}*

; malloc closure address table
%addytable7565 = call %clsvar* @new_address_table()
%var7566 = bitcast [61 x i8]* @gsxtmgraphics-pipeline323 to i8*
%var7567 = bitcast [53 x i8]* @gsxtmgraphics-pipeline324 to i8*
%addytable7568 = call %clsvar* @add_address_table(%mzone* %zone7560, i8* %var7566, i32 0, i8* %var7567, i32 3, %clsvar* %addytable7565)
%address-table7569 = bitcast %clsvar* %addytable7568 to i8*

; insert table, function and environment into closure struct
%closure.table7572 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}* %closure7562, i32 0, i32 0
store i8* %address-table7569, i8** %closure.table7572
%closure.env7573 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}* %closure7562, i32 0, i32 1
store i8* %envptr7563, i8** %closure.env7573
%closure.func7574 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}* %closure7562, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, i32)* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ__7551, void (i8*, i8*, %ShaderProgram*, i32)** %closure.func7574
%closure_size7575 = call i64 @llvm_zone_mark_size(%mzone* %zone7560)
call void @llvm_zone_ptr_set_size(i8* %clsptr7561, i64 %closure_size7575)
%wrapper_ptr7576 = call i8* @llvm_zone_malloc(%mzone* %zone7560, i64 8)
%closure_wrapper7577 = bitcast i8* %wrapper_ptr7576 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}* %closure7562, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}** %closure_wrapper7577

; let value assignment
%shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}** %closure_wrapper7577, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}** %closure_wrapper7577
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}*** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQPtr

; add data to environment
; don't need to alloc for env var shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ
%tmp_envptr7571 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}***}* %environment7564, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}*** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}**** %tmp_envptr7571


%val7580 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}*** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}** %val7580
}


@shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}** @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ(%ShaderProgram* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, i32)*,  void (i8*, i8*, %ShaderProgram*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, i32 %arg_1)
ret void
}


define dllexport ccc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ_native(%ShaderProgram* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, i32)*,  void (i8*, i8*, %ShaderProgram*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, i32 %arg_1)
ret void
}


define dllexport ccc i8*  @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7581 = bitcast [114 x i8]* @gsxtmgraphics-pipeline325 to i8*
call i32 (i8*, ...) @printf(i8* %var7581)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var7582 = bitcast [114 x i8]* @gsxtmgraphics-pipeline325 to i8*
call i32 (i8*, ...) @printf(i8* %var7582)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, i32)*,  void (i8*, i8*, %ShaderProgram*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, i32 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, i32}*
%arg_p_0 = getelementptr {%ShaderProgram*, i32}, {%ShaderProgram*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, i32}, {%ShaderProgram*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, i32)*,  void (i8*, i8*, %ShaderProgram*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline326 = hidden constant [55 x i8] c"shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd\00"
@gsxtmgraphics-pipeline327 = hidden constant [48 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**\00"
define dllexport fastcc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd__7583(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7584 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}*
%shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}* %impenv, i32 0, i32 0
%shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr


%val7585 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%null7586 = bitcast i8* null to %Texture*
%res7587 = call ccc i1 @impc_false()
call fastcc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ(%ShaderProgram* %val7585, %Texture* %null7586, i32 0, i1 %res7587)
ret void
}
@gsxtmgraphics-pipeline328 = hidden constant [108 x i8] c"shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7609 = load i8*, i8** %_impzPtr
%zone7610 = bitcast i8* %tzone7609 to %mzone*

; let assign value to symbol shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd
%dat_shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd = call i8* @llvm_zone_malloc(%mzone* %zone7610, i64 8)
%shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr = bitcast i8* %dat_shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd to { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***
%tzone7590 = load i8*, i8** %_impzPtr
%zone7591 = bitcast i8* %tzone7590 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7591)
; malloc closure structure
%clsptr7592 = call i8* @llvm_zone_malloc(%mzone* %zone7591, i64 24)
%closure7593 = bitcast i8* %clsptr7592 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*

; malloc environment structure
%envptr7594 = call i8* @llvm_zone_malloc(%mzone* %zone7591, i64 8)
%environment7595 = bitcast i8* %envptr7594 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}*

; malloc closure address table
%addytable7596 = call %clsvar* @new_address_table()
%var7597 = bitcast [55 x i8]* @gsxtmgraphics-pipeline326 to i8*
%var7598 = bitcast [48 x i8]* @gsxtmgraphics-pipeline327 to i8*
%addytable7599 = call %clsvar* @add_address_table(%mzone* %zone7591, i8* %var7597, i32 0, i8* %var7598, i32 3, %clsvar* %addytable7596)
%address-table7600 = bitcast %clsvar* %addytable7599 to i8*

; insert table, function and environment into closure struct
%closure.table7603 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure7593, i32 0, i32 0
store i8* %address-table7600, i8** %closure.table7603
%closure.env7604 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure7593, i32 0, i32 1
store i8* %envptr7594, i8** %closure.env7604
%closure.func7605 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure7593, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*)* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd__7583, void (i8*, i8*, %ShaderProgram*)** %closure.func7605
%closure_size7606 = call i64 @llvm_zone_mark_size(%mzone* %zone7591)
call void @llvm_zone_ptr_set_size(i8* %clsptr7592, i64 %closure_size7606)
%wrapper_ptr7607 = call i8* @llvm_zone_malloc(%mzone* %zone7591, i64 8)
%closure_wrapper7608 = bitcast i8* %wrapper_ptr7607 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure7593, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper7608

; let value assignment
%shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper7608, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper7608
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr

; add data to environment
; don't need to alloc for env var shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd
%tmp_envptr7602 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}* %environment7595, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**** %tmp_envptr7602


%val7611 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %val7611
}


@shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var = dllexport global [1 x i8*] [ i8* null ]

@shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
ret void
}


define dllexport ccc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_native(%ShaderProgram* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
ret void
}


define dllexport ccc i8*  @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7612 = bitcast [108 x i8]* @gsxtmgraphics-pipeline328 to i8*
call i32 (i8*, ...) @printf(i8* %var7612)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*}*
%arg_p_0 = getelementptr {%ShaderProgram*}, {%ShaderProgram*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline329 = hidden constant [56 x i8] c"xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ\00"
@gsxtmgraphics-pipeline330 = hidden constant [52 x i8] c"{i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}**\00"
define dllexport fastcc %VBO* @xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ__7613(i8* %_impz,i8* %_impenv, %VAO* %vao, float* %verts, i64 %num_verts) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7614 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}***}*
%xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}***}* %impenv, i32 0, i32 0
%xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQPtr = load {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}***, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}**** %xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQPtr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr
%vertsPtr = alloca float*
store float* %verts, float** %vertsPtr
%num_vertsPtr = alloca i64
store i64 %num_verts, i64* %num_vertsPtr


%tzone7615 = load i8*, i8** %_impzPtr
%zone7616 = bitcast i8* %tzone7615 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%tzone7618 = load i8*, i8** %_impzPtr
%zone7619 = bitcast i8* %tzone7618 to %mzone*

; let assign value to symbol vert
%vertPtr = alloca float*
%tzone7621 = load i8*, i8** %_impzPtr
%zone7622 = bitcast i8* %tzone7621 to %mzone*

; let assign value to symbol n1
%n1Ptr = alloca float*
%tzone7624 = load i8*, i8** %_impzPtr
%zone7625 = bitcast i8* %tzone7624 to %mzone*

; let assign value to symbol norm
%normPtr = alloca float*
%tzone7626 = load i8*, i8** %_impzPtr
%zone7627 = bitcast i8* %tzone7626 to %mzone*

; let assign value to symbol vbostride
%vbostridePtr = alloca i64
%tzone7637 = load i8*, i8** %_impzPtr
%zone7638 = bitcast i8* %tzone7637 to %mzone*

; let assign value to symbol vbodata
%vbodataPtr = alloca float*

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

%null7617 = bitcast i8* null to float*

; let value assignment
%vert = select i1 true, float* %null7617, float* %null7617
store float* %vert, float** %vertPtr

%dat7620 = alloca float, i64 3, align 16

; let value assignment
%n1 = select i1 true, float* %dat7620, float* %dat7620
store float* %n1, float** %n1Ptr

%dat7623 = alloca float, i64 3, align 16

; let value assignment
%norm = select i1 true, float* %dat7623, float* %dat7623
store float* %norm, float** %normPtr


; let value assignment
%vbostride = select i1 true, i64 14, i64 14
store i64 %vbostride, i64* %vbostridePtr

%val7628 = load i64, i64* %num_vertsPtr
%val7629 = load i64, i64* %vbostridePtr
%val7630 = mul i64 %val7628, %val7629
%val7631 = getelementptr i64, i64* null, i32 1
%zonesize7632 = mul i64 4, %val7630
%tzone7633 = load i8*, i8** %_impzPtr
%zone7634 = bitcast i8* %tzone7633 to %mzone*
%dat7635 = call i8* @llvm_zone_malloc(%mzone* %zone7634, i64 %zonesize7632)
call i8* @memset(i8* %dat7635, i32 0, i64 %zonesize7632)
%val7636 = bitcast i8* %dat7635 to float*

; let value assignment
%vbodata = select i1 true, float* %val7636, float* %val7636
store float* %vbodata, float** %vbodataPtr

; promote local stack var allocations
%tzone7870 = load i8*, i8** %_impzPtr
%zone7871 = bitcast i8* %tzone7870 to %mzone*
%ifptr7734 = alloca float
%ifptr7759 = alloca float
%ifptr7646 = alloca i64
%ifptr7650 = alloca i64
; setup loop
%val7641 = load i64, i64* %num_vertsPtr
store i64 0, i64* %iPtr
%val7835 = load i64, i64* %iPtr
%num7836 = add i64 %val7641, %val7835
%comp7837 = icmp ult i64 %val7641, 1
br i1 %comp7837, label %after7639, label %loop7639

loop7639:
; do set!
%val7642 = load i64, i64* %iPtr
%val7643 = mul i64 %val7642, 3
%val7644 = load float*, float** %vertsPtr
; pointer ref
%val7645 = getelementptr float, float* %val7644, i64 %val7643
store float* %val7645, float** %vertPtr
%val7647 = load i64, i64* %iPtr
%val7648 = srem i64 %val7647, 3
%cmp7649 = icmp eq i64 %val7648, 0
br i1 %cmp7649, label %then7646, label %else7646

then7646:
%val7651 = load i64, i64* %iPtr
%val7652 = load i64, i64* %num_vertsPtr
%val7653 = sub i64 %val7652, 2
%cmp7654 = icmp sgt i64 %val7651, %val7653
br i1 %cmp7654, label %then7650, label %else7650

then7650:
%val7655 = load float*, float** %normPtr
; set pointer
%val7656 = getelementptr float, float* %val7655, i64 0
store float 0x0, float* %val7656
%val7657 = load float*, float** %normPtr
; set pointer
%val7658 = getelementptr float, float* %val7657, i64 1
store float 0x3ff0000000000000, float* %val7658
%val7659 = load float*, float** %normPtr
; set pointer
%val7660 = getelementptr float, float* %val7659, i64 2
store float 0x0, float* %val7660
store i64 1, i64* %ifptr7650
br label %ifcont7650

else7650:
%val7661 = load float*, float** %vertPtr
%val7662 = load float*, float** %vertPtr
; pointer ref
%val7663 = getelementptr float, float* %val7662, i64 3
%val7664 = load float*, float** %n1Ptr
call fastcc void @vvcross_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCpd(float* %val7661, float* %val7663, float* %val7664)
%val7666 = load float*, float** %n1Ptr
%val7667 = load float*, float** %normPtr
call fastcc void @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd(float* %val7666, float 0xbff0000000000000, i64 3, float* %val7667)
store i64 1, i64* %ifptr7650
br label %ifcont7650

ifcont7650:
%ifres7669 = load i64, i64* %ifptr7650

store i64 %ifres7669, i64* %ifptr7646
br label %ifcont7646

else7646:
store i64 1, i64* %ifptr7646
br label %ifcont7646

ifcont7646:
%ifres7670 = load i64, i64* %ifptr7646

%val7671 = load i64, i64* %iPtr
%val7672 = load i64, i64* %vbostridePtr
%val7673 = mul i64 %val7671, %val7672
%val7674 = load float*, float** %vbodataPtr
; pointer ref
%val7675 = getelementptr float, float* %val7674, i64 %val7673
%val7676 = load float*, float** %vertPtr
; pointer ref
%val7677 = getelementptr float, float* %val7676, i64 0
%val7678 = load float, float* %val7677
; set pointer
%val7679 = getelementptr float, float* %val7675, i64 0
store float %val7678, float* %val7679
%val7680 = load i64, i64* %iPtr
%val7681 = load i64, i64* %vbostridePtr
%val7682 = mul i64 %val7680, %val7681
%val7683 = load float*, float** %vbodataPtr
; pointer ref
%val7684 = getelementptr float, float* %val7683, i64 %val7682
%val7685 = load float*, float** %vertPtr
; pointer ref
%val7686 = getelementptr float, float* %val7685, i64 1
%val7687 = load float, float* %val7686
; set pointer
%val7688 = getelementptr float, float* %val7684, i64 1
store float %val7687, float* %val7688
%val7689 = load i64, i64* %iPtr
%val7690 = load i64, i64* %vbostridePtr
%val7691 = mul i64 %val7689, %val7690
%val7692 = load float*, float** %vbodataPtr
; pointer ref
%val7693 = getelementptr float, float* %val7692, i64 %val7691
%val7694 = load float*, float** %vertPtr
; pointer ref
%val7695 = getelementptr float, float* %val7694, i64 2
%val7696 = load float, float* %val7695
; set pointer
%val7697 = getelementptr float, float* %val7693, i64 2
store float %val7696, float* %val7697
%val7698 = load i64, i64* %iPtr
%val7699 = load i64, i64* %vbostridePtr
%val7700 = mul i64 %val7698, %val7699
%val7701 = load float*, float** %vbodataPtr
; pointer ref
%val7702 = getelementptr float, float* %val7701, i64 %val7700
; set pointer
%val7703 = getelementptr float, float* %val7702, i64 3
store float 0x3ff0000000000000, float* %val7703
%val7704 = load i64, i64* %iPtr
%val7705 = load i64, i64* %vbostridePtr
%val7706 = mul i64 %val7704, %val7705
%val7707 = add i64 4, %val7706
%val7708 = load float*, float** %vbodataPtr
; pointer ref
%val7709 = getelementptr float, float* %val7708, i64 %val7707
%val7710 = load float*, float** %normPtr
; pointer ref
%val7711 = getelementptr float, float* %val7710, i64 0
%val7712 = load float, float* %val7711
; set pointer
%val7713 = getelementptr float, float* %val7709, i64 0
store float %val7712, float* %val7713
%val7714 = load i64, i64* %iPtr
%val7715 = load i64, i64* %vbostridePtr
%val7716 = mul i64 %val7714, %val7715
%val7717 = add i64 4, %val7716
%val7718 = load float*, float** %vbodataPtr
; pointer ref
%val7719 = getelementptr float, float* %val7718, i64 %val7717
%val7720 = load float*, float** %normPtr
; pointer ref
%val7721 = getelementptr float, float* %val7720, i64 1
%val7722 = load float, float* %val7721
; set pointer
%val7723 = getelementptr float, float* %val7719, i64 1
store float %val7722, float* %val7723
%val7724 = load i64, i64* %iPtr
%val7725 = load i64, i64* %vbostridePtr
%val7726 = mul i64 %val7724, %val7725
%val7727 = add i64 4, %val7726
%val7728 = load float*, float** %vbodataPtr
; pointer ref
%val7729 = getelementptr float, float* %val7728, i64 %val7727
%val7730 = load float*, float** %normPtr
; pointer ref
%val7731 = getelementptr float, float* %val7730, i64 2
%val7732 = load float, float* %val7731
; set pointer
%val7733 = getelementptr float, float* %val7729, i64 2
store float %val7732, float* %val7733
%val7735 = load i64, i64* %iPtr
%val7736 = srem i64 %val7735, 3
%cmp7737 = icmp eq i64 %val7736, 0
br i1 %cmp7737, label %then7734, label %else7734

then7734:
%val7738 = load i64, i64* %iPtr
%val7739 = load i64, i64* %vbostridePtr
%val7740 = mul i64 %val7738, %val7739
%val7741 = add i64 7, %val7740
%val7742 = load float*, float** %vbodataPtr
; pointer ref
%val7743 = getelementptr float, float* %val7742, i64 %val7741
; set pointer
%val7744 = getelementptr float, float* %val7743, i64 0
store float 0x0, float* %val7744
%val7745 = load i64, i64* %iPtr
%val7746 = load i64, i64* %vbostridePtr
%val7747 = mul i64 %val7745, %val7746
%val7748 = add i64 7, %val7747
%val7749 = load float*, float** %vbodataPtr
; pointer ref
%val7750 = getelementptr float, float* %val7749, i64 %val7748
; set pointer
%val7751 = getelementptr float, float* %val7750, i64 1
store float 0x0, float* %val7751
%val7752 = load i64, i64* %iPtr
%val7753 = load i64, i64* %vbostridePtr
%val7754 = mul i64 %val7752, %val7753
%val7755 = add i64 7, %val7754
%val7756 = load float*, float** %vbodataPtr
; pointer ref
%val7757 = getelementptr float, float* %val7756, i64 %val7755
; set pointer
%val7758 = getelementptr float, float* %val7757, i64 2
store float 0x0, float* %val7758
store float 0x0, float* %ifptr7734
br label %ifcont7734

else7734:
%val7760 = load i64, i64* %iPtr
%val7761 = srem i64 %val7760, 3
%cmp7762 = icmp eq i64 %val7761, 1
br i1 %cmp7762, label %then7759, label %else7759

then7759:
%val7763 = load i64, i64* %iPtr
%val7764 = load i64, i64* %vbostridePtr
%val7765 = mul i64 %val7763, %val7764
%val7766 = add i64 7, %val7765
%val7767 = load float*, float** %vbodataPtr
; pointer ref
%val7768 = getelementptr float, float* %val7767, i64 %val7766
; set pointer
%val7769 = getelementptr float, float* %val7768, i64 0
store float 0x3fe0000000000000, float* %val7769
%val7770 = load i64, i64* %iPtr
%val7771 = load i64, i64* %vbostridePtr
%val7772 = mul i64 %val7770, %val7771
%val7773 = add i64 7, %val7772
%val7774 = load float*, float** %vbodataPtr
; pointer ref
%val7775 = getelementptr float, float* %val7774, i64 %val7773
; set pointer
%val7776 = getelementptr float, float* %val7775, i64 1
store float 0x3ff0000000000000, float* %val7776
%val7777 = load i64, i64* %iPtr
%val7778 = load i64, i64* %vbostridePtr
%val7779 = mul i64 %val7777, %val7778
%val7780 = add i64 7, %val7779
%val7781 = load float*, float** %vbodataPtr
; pointer ref
%val7782 = getelementptr float, float* %val7781, i64 %val7780
; set pointer
%val7783 = getelementptr float, float* %val7782, i64 2
store float 0x0, float* %val7783
store float 0x0, float* %ifptr7759
br label %ifcont7759

else7759:
%val7784 = load i64, i64* %iPtr
%val7785 = load i64, i64* %vbostridePtr
%val7786 = mul i64 %val7784, %val7785
%val7787 = add i64 7, %val7786
%val7788 = load float*, float** %vbodataPtr
; pointer ref
%val7789 = getelementptr float, float* %val7788, i64 %val7787
; set pointer
%val7790 = getelementptr float, float* %val7789, i64 0
store float 0x3ff0000000000000, float* %val7790
%val7791 = load i64, i64* %iPtr
%val7792 = load i64, i64* %vbostridePtr
%val7793 = mul i64 %val7791, %val7792
%val7794 = add i64 7, %val7793
%val7795 = load float*, float** %vbodataPtr
; pointer ref
%val7796 = getelementptr float, float* %val7795, i64 %val7794
; set pointer
%val7797 = getelementptr float, float* %val7796, i64 1
store float 0x0, float* %val7797
%val7798 = load i64, i64* %iPtr
%val7799 = load i64, i64* %vbostridePtr
%val7800 = mul i64 %val7798, %val7799
%val7801 = add i64 7, %val7800
%val7802 = load float*, float** %vbodataPtr
; pointer ref
%val7803 = getelementptr float, float* %val7802, i64 %val7801
; set pointer
%val7804 = getelementptr float, float* %val7803, i64 2
store float 0x0, float* %val7804
store float 0x0, float* %ifptr7759
br label %ifcont7759

ifcont7759:
%ifres7805 = load float, float* %ifptr7759

store float %ifres7805, float* %ifptr7734
br label %ifcont7734

ifcont7734:
%ifres7806 = load float, float* %ifptr7734

%val7807 = load i64, i64* %iPtr
%val7808 = load i64, i64* %vbostridePtr
%val7809 = mul i64 %val7807, %val7808
%val7810 = add i64 10, %val7809
%val7811 = load float*, float** %vbodataPtr
; pointer ref
%val7812 = getelementptr float, float* %val7811, i64 %val7810
; set pointer
%val7813 = getelementptr float, float* %val7812, i64 0
store float 0x3ff0000000000000, float* %val7813
%val7814 = load i64, i64* %iPtr
%val7815 = load i64, i64* %vbostridePtr
%val7816 = mul i64 %val7814, %val7815
%val7817 = add i64 10, %val7816
%val7818 = load float*, float** %vbodataPtr
; pointer ref
%val7819 = getelementptr float, float* %val7818, i64 %val7817
; set pointer
%val7820 = getelementptr float, float* %val7819, i64 1
store float 0x3ff0000000000000, float* %val7820
%val7821 = load i64, i64* %iPtr
%val7822 = load i64, i64* %vbostridePtr
%val7823 = mul i64 %val7821, %val7822
%val7824 = add i64 10, %val7823
%val7825 = load float*, float** %vbodataPtr
; pointer ref
%val7826 = getelementptr float, float* %val7825, i64 %val7824
; set pointer
%val7827 = getelementptr float, float* %val7826, i64 2
store float 0x3ff0000000000000, float* %val7827
%val7828 = load i64, i64* %iPtr
%val7829 = load i64, i64* %vbostridePtr
%val7830 = mul i64 %val7828, %val7829
%val7831 = add i64 10, %val7830
%val7832 = load float*, float** %vbodataPtr
; pointer ref
%val7833 = getelementptr float, float* %val7832, i64 %val7831
; set pointer
%val7834 = getelementptr float, float* %val7833, i64 3
store float 0x3ff0000000000000, float* %val7834
%loop_cnt7639 = load i64, i64* %iPtr
%next7639 = add i64 %loop_cnt7639, 1
store i64 %next7639, i64* %iPtr
%cmp7639 = icmp ult i64 %next7639, %num7836
br i1 %cmp7639, label %loop7639, label %after7639

after7639:
%tzone7847 = load i8*, i8** %_impzPtr
%zone7848 = bitcast i8* %tzone7847 to %mzone*

; let assign value to symbol vbo
%vboPtr = alloca %VBO*
%val7839 = load float*, float** %vbodataPtr
%val7840 = load i64, i64* %num_vertsPtr
%val7841 = load i64, i64* %vbostridePtr
%val7842 = mul i64 %val7840, %val7841
%val7843 = load i32, i32* @GL_STATIC_DRAW
%val7844 = load i64, i64* %num_vertsPtr
%val7845 = load i64, i64* %vbostridePtr
%res7846 = call fastcc %VBO* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0(float* %val7839, i64 %val7842, i32 %val7843, i64 %val7844, i64 %val7845)

; let value assignment
%vbo = select i1 true, %VBO* %res7846, %VBO* %res7846
store %VBO* %vbo, %VBO** %vboPtr

%val7849 = load %VAO*, %VAO** %vaoPtr
%val7850 = load %VBO*, %VBO** %vboPtr
%val7851 = load i64, i64* %vbostridePtr
%res7852 = call ccc i32 @i64toi32(i64 %val7851)
call fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0(%VAO* %val7849, %VBO* %val7850, i32 0, i32 4, i32 %res7852, i32 0)
%val7854 = load %VAO*, %VAO** %vaoPtr
%val7855 = load %VBO*, %VBO** %vboPtr
%val7856 = load i64, i64* %vbostridePtr
%res7857 = call ccc i32 @i64toi32(i64 %val7856)
call fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0(%VAO* %val7854, %VBO* %val7855, i32 1, i32 3, i32 %res7857, i32 4)
%val7859 = load %VAO*, %VAO** %vaoPtr
%val7860 = load %VBO*, %VBO** %vboPtr
%val7861 = load i64, i64* %vbostridePtr
%res7862 = call ccc i32 @i64toi32(i64 %val7861)
call fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0(%VAO* %val7859, %VBO* %val7860, i32 2, i32 3, i32 %res7862, i32 7)
%val7864 = load %VAO*, %VAO** %vaoPtr
%val7865 = load %VBO*, %VBO** %vboPtr
%val7866 = load i64, i64* %vbostridePtr
%res7867 = call ccc i32 @i64toi32(i64 %val7866)
call fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0(%VAO* %val7864, %VBO* %val7865, i32 3, i32 4, i32 %res7867, i32 10)
%val7869 = load %VBO*, %VBO** %vboPtr
ret %VBO* %val7869
}
@gsxtmgraphics-pipeline331 = hidden constant [109 x i8] c"xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}** @xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7891 = load i8*, i8** %_impzPtr
%zone7892 = bitcast i8* %tzone7891 to %mzone*

; let assign value to symbol xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ
%dat_xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone7892, i64 8)
%xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQPtr = bitcast i8* %dat_xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ to { i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}***
%tzone7872 = load i8*, i8** %_impzPtr
%zone7873 = bitcast i8* %tzone7872 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7873)
; malloc closure structure
%clsptr7874 = call i8* @llvm_zone_malloc(%mzone* %zone7873, i64 24)
%closure7875 = bitcast i8* %clsptr7874 to { i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}*

; malloc environment structure
%envptr7876 = call i8* @llvm_zone_malloc(%mzone* %zone7873, i64 8)
%environment7877 = bitcast i8* %envptr7876 to {{i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}***}*

; malloc closure address table
%addytable7878 = call %clsvar* @new_address_table()
%var7879 = bitcast [56 x i8]* @gsxtmgraphics-pipeline329 to i8*
%var7880 = bitcast [52 x i8]* @gsxtmgraphics-pipeline330 to i8*
%addytable7881 = call %clsvar* @add_address_table(%mzone* %zone7873, i8* %var7879, i32 0, i8* %var7880, i32 3, %clsvar* %addytable7878)
%address-table7882 = bitcast %clsvar* %addytable7881 to i8*

; insert table, function and environment into closure struct
%closure.table7885 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}* %closure7875, i32 0, i32 0
store i8* %address-table7882, i8** %closure.table7885
%closure.env7886 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}* %closure7875, i32 0, i32 1
store i8* %envptr7876, i8** %closure.env7886
%closure.func7887 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}* %closure7875, i32 0, i32 2
store %VBO* (i8*, i8*, %VAO*, float*, i64)* @xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ__7613, %VBO* (i8*, i8*, %VAO*, float*, i64)** %closure.func7887
%closure_size7888 = call i64 @llvm_zone_mark_size(%mzone* %zone7873)
call void @llvm_zone_ptr_set_size(i8* %clsptr7874, i64 %closure_size7888)
%wrapper_ptr7889 = call i8* @llvm_zone_malloc(%mzone* %zone7873, i64 8)
%closure_wrapper7890 = bitcast i8* %wrapper_ptr7889 to { i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}**
store { i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}* %closure7875, { i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}** %closure_wrapper7890

; let value assignment
%xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}** %closure_wrapper7890, { i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}** %closure_wrapper7890
store { i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}** %xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ, { i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}*** %xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQPtr

; add data to environment
; don't need to alloc for env var xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ
%tmp_envptr7884 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}***}* %environment7877, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}*** %xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQPtr, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}**** %tmp_envptr7884


%val7893 = load {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}**, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}*** %xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQPtr
ret {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}** %val7893
}


@xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}** @xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ(%VAO* %arg_0,float* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VAO*, float*, i64)*,  %VBO* (i8*, i8*, %VAO*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, float* %arg_1, i64 %arg_2)
ret %VBO* %result
}


define dllexport ccc %VBO* @xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ_native(%VAO* %arg_0,float* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VAO*, float*, i64)*,  %VBO* (i8*, i8*, %VAO*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, float* %arg_1, i64 %arg_2)
ret %VBO* %result
}


define dllexport ccc i8*  @xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7894 = bitcast [109 x i8]* @gsxtmgraphics-pipeline331 to i8*
call i32 (i8*, ...) @printf(i8* %var7894)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var7895 = bitcast [109 x i8]* @gsxtmgraphics-pipeline331 to i8*
call i32 (i8*, ...) @printf(i8* %var7895)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var7896 = bitcast [109 x i8]* @gsxtmgraphics-pipeline331 to i8*
call i32 (i8*, ...) @printf(i8* %var7896)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VAO*, float*, i64)*,  %VBO* (i8*, i8*, %VAO*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, float* %arg_1, i64 %arg_2)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*, float*, i64}*
%arg_p_0 = getelementptr {%VAO*, float*, i64}, {%VAO*, float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
%arg_p_1 = getelementptr {%VAO*, float*, i64}, {%VAO*, float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {%VAO*, float*, i64}, {%VAO*, float*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VAO*, float*, i64)*,  %VBO* (i8*, i8*, %VAO*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, float* %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline332 = hidden constant [86 x i8] c"xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd\00"
@gsxtmgraphics-pipeline333 = hidden constant [81 x i8] c"{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}**\00"
define dllexport fastcc %XTMModel* @xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd__7897(i8* %_impz,i8* %_impenv, %String* %name_s_26, float* %verts, i64 %num_verts, float %r, float %g, float %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7898 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}***}*
%xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}***}, {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}***}* %impenv, i32 0, i32 0
%xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}***, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}**** %xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_

; setup arguments
%name_s_26Ptr = alloca %String*
store %String* %name_s_26, %String** %name_s_26Ptr
%vertsPtr = alloca float*
store float* %verts, float** %vertsPtr
%num_vertsPtr = alloca i64
store i64 %num_verts, i64* %num_vertsPtr
%rPtr = alloca float
store float %r, float* %rPtr
%gPtr = alloca float
store float %g, float* %gPtr
%bPtr = alloca float
store float %b, float* %bPtr


%tzone7903 = load i8*, i8** %_impzPtr
%zone7904 = bitcast i8* %tzone7903 to %mzone*

; let assign value to symbol mesh
%meshPtr = alloca %XTMMesh*
%tzone7909 = load i8*, i8** %_impzPtr
%zone7910 = bitcast i8* %tzone7909 to %mzone*

; let assign value to symbol node
%nodePtr = alloca %XTMModel*
%tzone7917 = load i8*, i8** %_impzPtr
%zone7918 = bitcast i8* %tzone7917 to %mzone*

; let assign value to symbol transmat
%transmatPtr = alloca float*
%tzone7919 = load i8*, i8** %_impzPtr
%zone7920 = bitcast i8* %tzone7919 to %mzone*

; let assign value to symbol vbostride
%vbostridePtr = alloca i32
%tzone7922 = load i8*, i8** %_impzPtr
%zone7923 = bitcast i8* %tzone7922 to %mzone*

; let assign value to symbol vbodata
%vbodataPtr = alloca float*
%tzone7924 = load i8*, i8** %_impzPtr
%zone7925 = bitcast i8* %tzone7924 to %mzone*

; let assign value to symbol shininess
%shininessPtr = alloca float
%tzone7926 = load i8*, i8** %_impzPtr
%zone7927 = bitcast i8* %tzone7926 to %mzone*

; let assign value to symbol opacity
%opacityPtr = alloca float
%tzone7934 = load i8*, i8** %_impzPtr
%zone7935 = bitcast i8* %tzone7934 to %mzone*

; let assign value to symbol diffuse
%diffusePtr = alloca float*
%tzone7942 = load i8*, i8** %_impzPtr
%zone7943 = bitcast i8* %tzone7942 to %mzone*

; let assign value to symbol ambient
%ambientPtr = alloca float*
%tzone7950 = load i8*, i8** %_impzPtr
%zone7951 = bitcast i8* %tzone7950 to %mzone*

; let assign value to symbol specular
%specularPtr = alloca float*
%tzone7958 = load i8*, i8** %_impzPtr
%zone7959 = bitcast i8* %tzone7958 to %mzone*

; let assign value to symbol emissive
%emissivePtr = alloca float*
%tzone7961 = load i8*, i8** %_impzPtr
%zone7962 = bitcast i8* %tzone7961 to %mzone*

; let assign value to symbol vao
%vaoPtr = alloca %VAO*
%tzone7967 = load i8*, i8** %_impzPtr
%zone7968 = bitcast i8* %tzone7967 to %mzone*

; let assign value to symbol vbo
%vboPtr = alloca %VBO*
%tzone7899 = load i8*, i8** %_impzPtr
%zone7900 = bitcast i8* %tzone7899 to %mzone*
%dat7901 = call i8* @llvm_zone_malloc(%mzone* %zone7900, i64 144)
call i8* @memset(i8* %dat7901, i32 0, i64 144)
%val7902 = bitcast i8* %dat7901 to %XTMMesh*

; let value assignment
%mesh = select i1 true, %XTMMesh* %val7902, %XTMMesh* %val7902
store %XTMMesh* %mesh, %XTMMesh** %meshPtr

%tzone7905 = load i8*, i8** %_impzPtr
%zone7906 = bitcast i8* %tzone7905 to %mzone*
%dat7907 = call i8* @llvm_zone_malloc(%mzone* %zone7906, i64 56)
call i8* @memset(i8* %dat7907, i32 0, i64 56)
%val7908 = bitcast i8* %dat7907 to %XTMModel*

; let value assignment
%node = select i1 true, %XTMModel* %val7908, %XTMModel* %val7908
store %XTMModel* %node, %XTMModel** %nodePtr

%val7911 = getelementptr i64, i64* null, i32 1
%zonesize7912 = mul i64 4, 16
%tzone7913 = load i8*, i8** %_impzPtr
%zone7914 = bitcast i8* %tzone7913 to %mzone*
%dat7915 = call i8* @llvm_zone_malloc(%mzone* %zone7914, i64 %zonesize7912)
call i8* @memset(i8* %dat7915, i32 0, i64 %zonesize7912)
%val7916 = bitcast i8* %dat7915 to float*

; let value assignment
%transmat = select i1 true, float* %val7916, float* %val7916
store float* %transmat, float** %transmatPtr


; let value assignment
%vbostride = select i1 true, i32 14, i32 14
store i32 %vbostride, i32* %vbostridePtr

%null7921 = bitcast i8* null to float*

; let value assignment
%vbodata = select i1 true, float* %null7921, float* %null7921
store float* %vbodata, float** %vbodataPtr


; let value assignment
%shininess = select i1 true, float 0x3ff0000000000000, float 0x3ff0000000000000
store float %shininess, float* %shininessPtr


; let value assignment
%opacity = select i1 true, float 0x3ff0000000000000, float 0x3ff0000000000000
store float %opacity, float* %opacityPtr

%val7928 = getelementptr i64, i64* null, i32 1
%zonesize7929 = mul i64 4, 4
%tzone7930 = load i8*, i8** %_impzPtr
%zone7931 = bitcast i8* %tzone7930 to %mzone*
%dat7932 = call i8* @llvm_zone_malloc(%mzone* %zone7931, i64 %zonesize7929)
call i8* @memset(i8* %dat7932, i32 0, i64 %zonesize7929)
%val7933 = bitcast i8* %dat7932 to float*

; let value assignment
%diffuse = select i1 true, float* %val7933, float* %val7933
store float* %diffuse, float** %diffusePtr

%val7936 = getelementptr i64, i64* null, i32 1
%zonesize7937 = mul i64 4, 4
%tzone7938 = load i8*, i8** %_impzPtr
%zone7939 = bitcast i8* %tzone7938 to %mzone*
%dat7940 = call i8* @llvm_zone_malloc(%mzone* %zone7939, i64 %zonesize7937)
call i8* @memset(i8* %dat7940, i32 0, i64 %zonesize7937)
%val7941 = bitcast i8* %dat7940 to float*

; let value assignment
%ambient = select i1 true, float* %val7941, float* %val7941
store float* %ambient, float** %ambientPtr

%val7944 = getelementptr i64, i64* null, i32 1
%zonesize7945 = mul i64 4, 4
%tzone7946 = load i8*, i8** %_impzPtr
%zone7947 = bitcast i8* %tzone7946 to %mzone*
%dat7948 = call i8* @llvm_zone_malloc(%mzone* %zone7947, i64 %zonesize7945)
call i8* @memset(i8* %dat7948, i32 0, i64 %zonesize7945)
%val7949 = bitcast i8* %dat7948 to float*

; let value assignment
%specular = select i1 true, float* %val7949, float* %val7949
store float* %specular, float** %specularPtr

%val7952 = getelementptr i64, i64* null, i32 1
%zonesize7953 = mul i64 4, 4
%tzone7954 = load i8*, i8** %_impzPtr
%zone7955 = bitcast i8* %tzone7954 to %mzone*
%dat7956 = call i8* @llvm_zone_malloc(%mzone* %zone7955, i64 %zonesize7953)
call i8* @memset(i8* %dat7956, i32 0, i64 %zonesize7953)
%val7957 = bitcast i8* %dat7956 to float*

; let value assignment
%emissive = select i1 true, float* %val7957, float* %val7957
store float* %emissive, float** %emissivePtr

%res7960 = call fastcc %VAO* @VAO_adhoc_W1ZBTypd()

; let value assignment
%vao = select i1 true, %VAO* %res7960, %VAO* %res7960
store %VAO* %vao, %VAO** %vaoPtr

%val7963 = load %VAO*, %VAO** %vaoPtr
%val7964 = load float*, float** %vertsPtr
%val7965 = load i64, i64* %num_vertsPtr
%res7966 = call fastcc %VBO* @xtm_build_mesh_vbo_adhoc_W1ZCTyosVkFPKixmbG9hdCosaTY0XQ(%VAO* %val7963, float* %val7964, i64 %val7965)

; let value assignment
%vbo = select i1 true, %VBO* %res7966, %VBO* %res7966
store %VBO* %vbo, %VBO** %vboPtr

%val7969 = load float*, float** %ambientPtr
; set pointer
%val7970 = getelementptr float, float* %val7969, i64 0
store float 0x0, float* %val7970
%val7971 = load float*, float** %ambientPtr
; set pointer
%val7972 = getelementptr float, float* %val7971, i64 1
store float 0x0, float* %val7972
%val7973 = load float*, float** %ambientPtr
; set pointer
%val7974 = getelementptr float, float* %val7973, i64 2
store float 0x0, float* %val7974
%val7975 = load float*, float** %ambientPtr
; set pointer
%val7976 = getelementptr float, float* %val7975, i64 3
store float 0x3ff0000000000000, float* %val7976
%val7977 = load float*, float** %diffusePtr
%val7978 = load float, float* %rPtr
; set pointer
%val7979 = getelementptr float, float* %val7977, i64 0
store float %val7978, float* %val7979
%val7980 = load float*, float** %diffusePtr
%val7981 = load float, float* %gPtr
; set pointer
%val7982 = getelementptr float, float* %val7980, i64 1
store float %val7981, float* %val7982
%val7983 = load float*, float** %diffusePtr
%val7984 = load float, float* %bPtr
; set pointer
%val7985 = getelementptr float, float* %val7983, i64 2
store float %val7984, float* %val7985
%val7986 = load float*, float** %diffusePtr
; set pointer
%val7987 = getelementptr float, float* %val7986, i64 3
store float 0x3ff0000000000000, float* %val7987
%val7988 = load float*, float** %specularPtr
; set pointer
%val7989 = getelementptr float, float* %val7988, i64 0
store float 0x3ff0000000000000, float* %val7989
%val7990 = load float*, float** %specularPtr
; set pointer
%val7991 = getelementptr float, float* %val7990, i64 1
store float 0x3ff0000000000000, float* %val7991
%val7992 = load float*, float** %specularPtr
; set pointer
%val7993 = getelementptr float, float* %val7992, i64 2
store float 0x3ff0000000000000, float* %val7993
%val7994 = load float*, float** %specularPtr
; set pointer
%val7995 = getelementptr float, float* %val7994, i64 3
store float 0x3ff0000000000000, float* %val7995
%val7996 = load float*, float** %emissivePtr
; set pointer
%val7997 = getelementptr float, float* %val7996, i64 0
store float 0x0, float* %val7997
%val7998 = load float*, float** %emissivePtr
; set pointer
%val7999 = getelementptr float, float* %val7998, i64 1
store float 0x0, float* %val7999
%val8000 = load float*, float** %emissivePtr
; set pointer
%val8001 = getelementptr float, float* %val8000, i64 2
store float 0x0, float* %val8001
%val8002 = load float*, float** %emissivePtr
; set pointer
%val8003 = getelementptr float, float* %val8002, i64 3
store float 0x3ff0000000000000, float* %val8003
%val8004 = load %XTMMesh*, %XTMMesh** %meshPtr
%val8005 = load %VBO*, %VBO** %vboPtr
; set tuple
%val8006 = getelementptr %XTMMesh, %XTMMesh* %val8004, i64 0, i32 0
store %VBO* %val8005, %VBO** %val8006
%val8007 = load %XTMMesh*, %XTMMesh** %meshPtr
%null8008 = bitcast i8* null to %Texture*
; set tuple
%val8009 = getelementptr %XTMMesh, %XTMMesh* %val8007, i64 0, i32 1
store %Texture* %null8008, %Texture** %val8009
%val8010 = load %XTMMesh*, %XTMMesh** %meshPtr
%val8011 = load float*, float** %diffusePtr
; set tuple
%val8012 = getelementptr %XTMMesh, %XTMMesh* %val8010, i64 0, i32 2
store float* %val8011, float** %val8012
%val8013 = load %XTMMesh*, %XTMMesh** %meshPtr
%val8014 = load float*, float** %ambientPtr
; set tuple
%val8015 = getelementptr %XTMMesh, %XTMMesh* %val8013, i64 0, i32 3
store float* %val8014, float** %val8015
%val8016 = load %XTMMesh*, %XTMMesh** %meshPtr
%val8017 = load float*, float** %specularPtr
; set tuple
%val8018 = getelementptr %XTMMesh, %XTMMesh* %val8016, i64 0, i32 4
store float* %val8017, float** %val8018
%val8019 = load %XTMMesh*, %XTMMesh** %meshPtr
%val8020 = load float*, float** %emissivePtr
; set tuple
%val8021 = getelementptr %XTMMesh, %XTMMesh* %val8019, i64 0, i32 5
store float* %val8020, float** %val8021
%val8022 = load %XTMMesh*, %XTMMesh** %meshPtr
%val8023 = load float, float* %shininessPtr
; set tuple
%val8024 = getelementptr %XTMMesh, %XTMMesh* %val8022, i64 0, i32 6
store float %val8023, float* %val8024
%val8025 = load %XTMMesh*, %XTMMesh** %meshPtr
%val8026 = load float, float* %opacityPtr
; set tuple
%val8027 = getelementptr %XTMMesh, %XTMMesh* %val8025, i64 0, i32 7
store float %val8026, float* %val8027
%val8028 = load %XTMMesh*, %XTMMesh** %meshPtr
%val8029 = load i32, i32* @GL_TRIANGLES
; set tuple
%val8030 = getelementptr %XTMMesh, %XTMMesh* %val8028, i64 0, i32 8
store i32 %val8029, i32* %val8030
%val8031 = load %XTMMesh*, %XTMMesh** %meshPtr
%val8032 = load i64, i64* %num_vertsPtr
; set tuple
%val8033 = getelementptr %XTMMesh, %XTMMesh* %val8031, i64 0, i32 9
store i64 %val8032, i64* %val8033
%val8034 = load %XTMMesh*, %XTMMesh** %meshPtr
%val8035 = load %VAO*, %VAO** %vaoPtr
; set tuple
%val8036 = getelementptr %XTMMesh, %XTMMesh* %val8034, i64 0, i32 10
store %VAO* %val8035, %VAO** %val8036
%val8037 = load %XTMMesh*, %XTMMesh** %meshPtr
%val8038 = load %String*, %String** %name_s_26Ptr
; set tuple
%val8039 = getelementptr %XTMMesh, %XTMMesh* %val8037, i64 0, i32 11
store %String* %val8038, %String** %val8039
%val8040 = load float*, float** %transmatPtr
call fastcc void @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %val8040)
%val8042 = load %XTMModel*, %XTMModel** %nodePtr
%val8043 = load %String*, %String** %name_s_26Ptr
; set tuple
%val8044 = getelementptr %XTMModel, %XTMModel* %val8042, i64 0, i32 0
store %String* %val8043, %String** %val8044
%val8045 = load %XTMModel*, %XTMModel** %nodePtr
%val8046 = load float*, float** %transmatPtr
; set tuple
%val8047 = getelementptr %XTMModel, %XTMModel* %val8045, i64 0, i32 1
store float* %val8046, float** %val8047
%val8048 = load %XTMModel*, %XTMModel** %nodePtr
%null8049 = bitcast i8* null to %XTMModel*
; set tuple
%val8050 = getelementptr %XTMModel, %XTMModel* %val8048, i64 0, i32 2
store %XTMModel* %null8049, %XTMModel** %val8050
%val8051 = load %XTMModel*, %XTMModel** %nodePtr
; set tuple
%val8052 = getelementptr %XTMModel, %XTMModel* %val8051, i64 0, i32 3
store i32 0, i32* %val8052
%val8053 = load %XTMModel*, %XTMModel** %nodePtr
%null8054 = bitcast i8* null to %XTMModel*
; set tuple
%val8055 = getelementptr %XTMModel, %XTMModel* %val8053, i64 0, i32 4
store %XTMModel* %null8054, %XTMModel** %val8055
%val8056 = load %XTMModel*, %XTMModel** %nodePtr
; set tuple
%val8057 = getelementptr %XTMModel, %XTMModel* %val8056, i64 0, i32 5
store i32 1, i32* %val8057
%val8058 = load %XTMModel*, %XTMModel** %nodePtr
%val8059 = load %XTMMesh*, %XTMMesh** %meshPtr
; set tuple
%val8060 = getelementptr %XTMModel, %XTMModel* %val8058, i64 0, i32 6
store %XTMMesh* %val8059, %XTMMesh** %val8060
%val8061 = load %XTMModel*, %XTMModel** %nodePtr
ret %XTMModel* %val8061
}
@gsxtmgraphics-pipeline334 = hidden constant [139 x i8] c"xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}** @xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8081 = load i8*, i8** %_impzPtr
%zone8082 = bitcast i8* %tzone8081 to %mzone*

; let assign value to symbol xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd
%dat_xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone8082, i64 8)
%xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = bitcast i8* %dat_xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd to { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}***
%tzone8062 = load i8*, i8** %_impzPtr
%zone8063 = bitcast i8* %tzone8062 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8063)
; malloc closure structure
%clsptr8064 = call i8* @llvm_zone_malloc(%mzone* %zone8063, i64 24)
%closure8065 = bitcast i8* %clsptr8064 to { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}*

; malloc environment structure
%envptr8066 = call i8* @llvm_zone_malloc(%mzone* %zone8063, i64 8)
%environment8067 = bitcast i8* %envptr8066 to {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}***}*

; malloc closure address table
%addytable8068 = call %clsvar* @new_address_table()
%var8069 = bitcast [86 x i8]* @gsxtmgraphics-pipeline332 to i8*
%var8070 = bitcast [81 x i8]* @gsxtmgraphics-pipeline333 to i8*
%addytable8071 = call %clsvar* @add_address_table(%mzone* %zone8063, i8* %var8069, i32 0, i8* %var8070, i32 3, %clsvar* %addytable8068)
%address-table8072 = bitcast %clsvar* %addytable8071 to i8*

; insert table, function and environment into closure struct
%closure.table8075 = getelementptr { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}* %closure8065, i32 0, i32 0
store i8* %address-table8072, i8** %closure.table8075
%closure.env8076 = getelementptr { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}* %closure8065, i32 0, i32 1
store i8* %envptr8066, i8** %closure.env8076
%closure.func8077 = getelementptr { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}* %closure8065, i32 0, i32 2
store %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)* @xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd__7897, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)** %closure.func8077
%closure_size8078 = call i64 @llvm_zone_mark_size(%mzone* %zone8063)
call void @llvm_zone_ptr_set_size(i8* %clsptr8064, i64 %closure_size8078)
%wrapper_ptr8079 = call i8* @llvm_zone_malloc(%mzone* %zone8063, i64 8)
%closure_wrapper8080 = bitcast i8* %wrapper_ptr8079 to { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}**
store { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}* %closure8065, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}** %closure_wrapper8080

; let value assignment
%xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd = select i1 true, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}** %closure_wrapper8080, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}** %closure_wrapper8080
store { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}** %xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd, { i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}*** %xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd
%tmp_envptr8074 = getelementptr {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}***}, {{i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}***}* %environment8067, i32 0, i32 0
store {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}*** %xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRdPtr, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}**** %tmp_envptr8074


%val8083 = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}**, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}*** %xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRdPtr
ret {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}** %val8083
}


@xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}** @xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %XTMModel* @xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd(%String* %arg_0,float* %arg_1,i64 %arg_2,float %arg_3,float %arg_4,float %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*,  %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %String* %arg_0, float* %arg_1, i64 %arg_2, float %arg_3, float %arg_4, float %arg_5)
ret %XTMModel* %result
}


define dllexport ccc %XTMModel* @xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd_native(%String* %arg_0,float* %arg_1,i64 %arg_2,float %arg_3,float %arg_4,float %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*,  %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %String* %arg_0, float* %arg_1, i64 %arg_2, float %arg_3, float %arg_4, float %arg_5)
ret %XTMModel* %result
}


define dllexport ccc i8*  @xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8084 = bitcast [139 x i8]* @gsxtmgraphics-pipeline334 to i8*
call i32 (i8*, ...) @printf(i8* %var8084)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var8085 = bitcast [139 x i8]* @gsxtmgraphics-pipeline334 to i8*
call i32 (i8*, ...) @printf(i8* %var8085)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var8086 = bitcast [139 x i8]* @gsxtmgraphics-pipeline334 to i8*
call i32 (i8*, ...) @printf(i8* %var8086)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var8087 = bitcast [139 x i8]* @gsxtmgraphics-pipeline334 to i8*
call i32 (i8*, ...) @printf(i8* %var8087)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var8088 = bitcast [139 x i8]* @gsxtmgraphics-pipeline334 to i8*
call i32 (i8*, ...) @printf(i8* %var8088)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_real(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var8089 = bitcast [139 x i8]* @gsxtmgraphics-pipeline334 to i8*
call i32 (i8*, ...) @printf(i8* %var8089)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc float  @r32value(i8* %arg_5_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*,  %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %String* %arg_0, float* %arg_1, i64 %arg_2, float %arg_3, float %arg_4, float %arg_5)
%tmpres = bitcast %XTMModel* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, float*, i64, float, float, float}*
%arg_p_0 = getelementptr {%String*, float*, i64, float, float, float}, {%String*, float*, i64, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, float*, i64, float, float, float}, {%String*, float*, i64, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {%String*, float*, i64, float, float, float}, {%String*, float*, i64, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {%String*, float*, i64, float, float, float}, {%String*, float*, i64, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {%String*, float*, i64, float, float, float}, {%String*, float*, i64, float, float, float}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
%arg_p_5 = getelementptr {%String*, float*, i64, float, float, float}, {%String*, float*, i64, float, float, float}* %fstruct, i32 0, i32 5
%arg_5 = load float, float* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_make_model_adhoc_W1hUTU1vZGVsKixTdHJpbmcqLGZsb2F0KixpNjQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}**
%closure = load {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}*, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}, {i8*, i8*, %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)*,  %XTMModel* (i8*, i8*, %String*, float*, i64, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %XTMModel* %ff(i8* %_impz, i8* %ee, %String* %arg_0, float* %arg_1, i64 %arg_2, float %arg_3, float %arg_4, float %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%xtm_camera = type {float*,float*,float*}
@gsxtmgraphics-pipeline335 = hidden constant [64 x i8] c"xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ\00"
@gsxtmgraphics-pipeline336 = hidden constant [63 x i8] c"{i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**\00"
define dllexport fastcc %xtm_camera* @xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ__8090(i8* %_impz,i8* %_impenv, float* %arg_0, float* %arg_1, float* %arg_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8091 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***}*
%xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = load {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**** %xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_

; setup arguments
%arg_0Ptr = alloca float*
store float* %arg_0, float** %arg_0Ptr
%arg_1Ptr = alloca float*
store float* %arg_1, float** %arg_1Ptr
%arg_2Ptr = alloca float*
store float* %arg_2, float** %arg_2Ptr


%tzone8096 = load i8*, i8** %_impzPtr
%zone8097 = bitcast i8* %tzone8096 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %xtm_camera*
%tzone8092 = load i8*, i8** %_impzPtr
%zone8093 = bitcast i8* %tzone8092 to %mzone*
%dat8094 = call i8* @llvm_zone_malloc(%mzone* %zone8093, i64 24)
call i8* @memset(i8* %dat8094, i32 0, i64 24)
%val8095 = bitcast i8* %dat8094 to %xtm_camera*

; let value assignment
%obj = select i1 true, %xtm_camera* %val8095, %xtm_camera* %val8095
store %xtm_camera* %obj, %xtm_camera** %objPtr

%val8098 = load %xtm_camera*, %xtm_camera** %objPtr
%val8099 = load float*, float** %arg_0Ptr
; set tuple
%val8100 = getelementptr %xtm_camera, %xtm_camera* %val8098, i64 0, i32 0
store float* %val8099, float** %val8100
%val8101 = load %xtm_camera*, %xtm_camera** %objPtr
%val8102 = load float*, float** %arg_1Ptr
; set tuple
%val8103 = getelementptr %xtm_camera, %xtm_camera* %val8101, i64 0, i32 1
store float* %val8102, float** %val8103
%val8104 = load %xtm_camera*, %xtm_camera** %objPtr
%val8105 = load float*, float** %arg_2Ptr
; set tuple
%val8106 = getelementptr %xtm_camera, %xtm_camera* %val8104, i64 0, i32 2
store float* %val8105, float** %val8106
%val8107 = load %xtm_camera*, %xtm_camera** %objPtr
ret %xtm_camera* %val8107
}
@gsxtmgraphics-pipeline337 = hidden constant [117 x i8] c"xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** @xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8127 = load i8*, i8** %_impzPtr
%zone8128 = bitcast i8* %tzone8127 to %mzone*

; let assign value to symbol xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%dat_xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone8128, i64 8)
%xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = bitcast i8* %dat_xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ to { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***
%tzone8108 = load i8*, i8** %_impzPtr
%zone8109 = bitcast i8* %tzone8108 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8109)
; malloc closure structure
%clsptr8110 = call i8* @llvm_zone_malloc(%mzone* %zone8109, i64 24)
%closure8111 = bitcast i8* %clsptr8110 to { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*

; malloc environment structure
%envptr8112 = call i8* @llvm_zone_malloc(%mzone* %zone8109, i64 8)
%environment8113 = bitcast i8* %envptr8112 to {{i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***}*

; malloc closure address table
%addytable8114 = call %clsvar* @new_address_table()
%var8115 = bitcast [64 x i8]* @gsxtmgraphics-pipeline335 to i8*
%var8116 = bitcast [63 x i8]* @gsxtmgraphics-pipeline336 to i8*
%addytable8117 = call %clsvar* @add_address_table(%mzone* %zone8109, i8* %var8115, i32 0, i8* %var8116, i32 3, %clsvar* %addytable8114)
%address-table8118 = bitcast %clsvar* %addytable8117 to i8*

; insert table, function and environment into closure struct
%closure.table8121 = getelementptr { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure8111, i32 0, i32 0
store i8* %address-table8118, i8** %closure.table8121
%closure.env8122 = getelementptr { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure8111, i32 0, i32 1
store i8* %envptr8112, i8** %closure.env8122
%closure.func8123 = getelementptr { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure8111, i32 0, i32 2
store %xtm_camera* (i8*, i8*, float*, float*, float*)* @xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ__8090, %xtm_camera* (i8*, i8*, float*, float*, float*)** %closure.func8123
%closure_size8124 = call i64 @llvm_zone_mark_size(%mzone* %zone8109)
call void @llvm_zone_ptr_set_size(i8* %clsptr8110, i64 %closure_size8124)
%wrapper_ptr8125 = call i8* @llvm_zone_malloc(%mzone* %zone8109, i64 8)
%closure_wrapper8126 = bitcast i8* %wrapper_ptr8125 to { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**
store { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure8111, { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure_wrapper8126

; let value assignment
%xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ = select i1 true, { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure_wrapper8126, { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure_wrapper8126
store { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ, { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*** %xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr

; add data to environment
; don't need to alloc for env var xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%tmp_envptr8120 = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***}* %environment8113, i32 0, i32 0
store {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*** %xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**** %tmp_envptr8120


%val8129 = load {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*** %xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr
ret {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %val8129
}


@xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** @xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %xtm_camera* @xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ(float* %arg_0,float* %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*, float*, float*, float*)*,  %xtm_camera* (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
ret %xtm_camera* %result
}


define dllexport ccc %xtm_camera* @xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_native(float* %arg_0,float* %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*, float*, float*, float*)*,  %xtm_camera* (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
ret %xtm_camera* %result
}


define dllexport ccc i8*  @xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8130 = bitcast [117 x i8]* @gsxtmgraphics-pipeline337 to i8*
call i32 (i8*, ...) @printf(i8* %var8130)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var8131 = bitcast [117 x i8]* @gsxtmgraphics-pipeline337 to i8*
call i32 (i8*, ...) @printf(i8* %var8131)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var8132 = bitcast [117 x i8]* @gsxtmgraphics-pipeline337 to i8*
call i32 (i8*, ...) @printf(i8* %var8132)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*, float*, float*, float*)*,  %xtm_camera* (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
%tmpres = bitcast %xtm_camera* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, float*}*
%arg_p_0 = getelementptr {float*, float*, float*}, {float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, float*}, {float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, float*}, {float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*, float*, float*, float*)*,  %xtm_camera* (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline338 = hidden constant [66 x i8] c"xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ\00"
define dllexport fastcc %xtm_camera* @xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ__8133(i8* %_impz,i8* %_impenv, float* %arg_0, float* %arg_1, float* %arg_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8134 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***}*
%xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = load {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**** %xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_

; setup arguments
%arg_0Ptr = alloca float*
store float* %arg_0, float** %arg_0Ptr
%arg_1Ptr = alloca float*
store float* %arg_1, float** %arg_1Ptr
%arg_2Ptr = alloca float*
store float* %arg_2, float** %arg_2Ptr


%tzone8139 = load i8*, i8** %_impzPtr
%zone8140 = bitcast i8* %tzone8139 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %xtm_camera*
%tzone8135 = load i8*, i8** %_impzPtr
%zone8136 = bitcast i8* %tzone8135 to %mzone*
%dat8137 = call i8* @llvm_zone_malloc(%mzone* %zone8136, i64 24)
call i8* @memset(i8* %dat8137, i32 0, i64 24)
%val8138 = bitcast i8* %dat8137 to %xtm_camera*

; let value assignment
%obj = select i1 true, %xtm_camera* %val8138, %xtm_camera* %val8138
store %xtm_camera* %obj, %xtm_camera** %objPtr

%val8141 = load %xtm_camera*, %xtm_camera** %objPtr
%val8142 = load float*, float** %arg_0Ptr
; set tuple
%val8143 = getelementptr %xtm_camera, %xtm_camera* %val8141, i64 0, i32 0
store float* %val8142, float** %val8143
%val8144 = load %xtm_camera*, %xtm_camera** %objPtr
%val8145 = load float*, float** %arg_1Ptr
; set tuple
%val8146 = getelementptr %xtm_camera, %xtm_camera* %val8144, i64 0, i32 1
store float* %val8145, float** %val8146
%val8147 = load %xtm_camera*, %xtm_camera** %objPtr
%val8148 = load float*, float** %arg_2Ptr
; set tuple
%val8149 = getelementptr %xtm_camera, %xtm_camera* %val8147, i64 0, i32 2
store float* %val8148, float** %val8149
%val8150 = load %xtm_camera*, %xtm_camera** %objPtr
ret %xtm_camera* %val8150
}
@gsxtmgraphics-pipeline339 = hidden constant [119 x i8] c"xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** @xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8170 = load i8*, i8** %_impzPtr
%zone8171 = bitcast i8* %tzone8170 to %mzone*

; let assign value to symbol xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%dat_xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone8171, i64 8)
%xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = bitcast i8* %dat_xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ to { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***
%tzone8151 = load i8*, i8** %_impzPtr
%zone8152 = bitcast i8* %tzone8151 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8152)
; malloc closure structure
%clsptr8153 = call i8* @llvm_zone_malloc(%mzone* %zone8152, i64 24)
%closure8154 = bitcast i8* %clsptr8153 to { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*

; malloc environment structure
%envptr8155 = call i8* @llvm_zone_malloc(%mzone* %zone8152, i64 8)
%environment8156 = bitcast i8* %envptr8155 to {{i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***}*

; malloc closure address table
%addytable8157 = call %clsvar* @new_address_table()
%var8158 = bitcast [66 x i8]* @gsxtmgraphics-pipeline338 to i8*
%var8159 = bitcast [63 x i8]* @gsxtmgraphics-pipeline336 to i8*
%addytable8160 = call %clsvar* @add_address_table(%mzone* %zone8152, i8* %var8158, i32 0, i8* %var8159, i32 3, %clsvar* %addytable8157)
%address-table8161 = bitcast %clsvar* %addytable8160 to i8*

; insert table, function and environment into closure struct
%closure.table8164 = getelementptr { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure8154, i32 0, i32 0
store i8* %address-table8161, i8** %closure.table8164
%closure.env8165 = getelementptr { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure8154, i32 0, i32 1
store i8* %envptr8155, i8** %closure.env8165
%closure.func8166 = getelementptr { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure8154, i32 0, i32 2
store %xtm_camera* (i8*, i8*, float*, float*, float*)* @xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ__8133, %xtm_camera* (i8*, i8*, float*, float*, float*)** %closure.func8166
%closure_size8167 = call i64 @llvm_zone_mark_size(%mzone* %zone8152)
call void @llvm_zone_ptr_set_size(i8* %clsptr8153, i64 %closure_size8167)
%wrapper_ptr8168 = call i8* @llvm_zone_malloc(%mzone* %zone8152, i64 8)
%closure_wrapper8169 = bitcast i8* %wrapper_ptr8168 to { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**
store { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure8154, { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure_wrapper8169

; let value assignment
%xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ = select i1 true, { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure_wrapper8169, { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure_wrapper8169
store { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ, { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*** %xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr

; add data to environment
; don't need to alloc for env var xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%tmp_envptr8163 = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***}* %environment8156, i32 0, i32 0
store {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*** %xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**** %tmp_envptr8163


%val8172 = load {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*** %xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr
ret {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %val8172
}


@xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** @xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %xtm_camera* @xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ(float* %arg_0,float* %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*, float*, float*, float*)*,  %xtm_camera* (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
ret %xtm_camera* %result
}


define dllexport ccc %xtm_camera* @xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_native(float* %arg_0,float* %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*, float*, float*, float*)*,  %xtm_camera* (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
ret %xtm_camera* %result
}


define dllexport ccc i8*  @xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8173 = bitcast [119 x i8]* @gsxtmgraphics-pipeline339 to i8*
call i32 (i8*, ...) @printf(i8* %var8173)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var8174 = bitcast [119 x i8]* @gsxtmgraphics-pipeline339 to i8*
call i32 (i8*, ...) @printf(i8* %var8174)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var8175 = bitcast [119 x i8]* @gsxtmgraphics-pipeline339 to i8*
call i32 (i8*, ...) @printf(i8* %var8175)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*, float*, float*, float*)*,  %xtm_camera* (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
%tmpres = bitcast %xtm_camera* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, float*}*
%arg_p_0 = getelementptr {float*, float*, float*}, {float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, float*}, {float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, float*}, {float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_z_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*, float*, float*, float*)*,  %xtm_camera* (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline340 = hidden constant [66 x i8] c"xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ\00"
define dllexport fastcc %xtm_camera* @xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ__8176(i8* %_impz,i8* %_impenv, float* %arg_0, float* %arg_1, float* %arg_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8177 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***}*
%xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = load {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**** %xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_

; setup arguments
%arg_0Ptr = alloca float*
store float* %arg_0, float** %arg_0Ptr
%arg_1Ptr = alloca float*
store float* %arg_1, float** %arg_1Ptr
%arg_2Ptr = alloca float*
store float* %arg_2, float** %arg_2Ptr


%tzone8180 = load i8*, i8** %_impzPtr
%zone8181 = bitcast i8* %tzone8180 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %xtm_camera*
%dat8178 = call i8* @malloc(i64 24)
call i8* @memset(i8* %dat8178, i32 0, i64 24)
%val8179 = bitcast i8* %dat8178 to %xtm_camera*

; let value assignment
%obj = select i1 true, %xtm_camera* %val8179, %xtm_camera* %val8179
store %xtm_camera* %obj, %xtm_camera** %objPtr

%val8182 = load %xtm_camera*, %xtm_camera** %objPtr
%val8183 = load float*, float** %arg_0Ptr
; set tuple
%val8184 = getelementptr %xtm_camera, %xtm_camera* %val8182, i64 0, i32 0
store float* %val8183, float** %val8184
%val8185 = load %xtm_camera*, %xtm_camera** %objPtr
%val8186 = load float*, float** %arg_1Ptr
; set tuple
%val8187 = getelementptr %xtm_camera, %xtm_camera* %val8185, i64 0, i32 1
store float* %val8186, float** %val8187
%val8188 = load %xtm_camera*, %xtm_camera** %objPtr
%val8189 = load float*, float** %arg_2Ptr
; set tuple
%val8190 = getelementptr %xtm_camera, %xtm_camera* %val8188, i64 0, i32 2
store float* %val8189, float** %val8190
%val8191 = load %xtm_camera*, %xtm_camera** %objPtr
ret %xtm_camera* %val8191
}
@gsxtmgraphics-pipeline341 = hidden constant [119 x i8] c"xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** @xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8211 = load i8*, i8** %_impzPtr
%zone8212 = bitcast i8* %tzone8211 to %mzone*

; let assign value to symbol xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%dat_xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone8212, i64 8)
%xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = bitcast i8* %dat_xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ to { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***
%tzone8192 = load i8*, i8** %_impzPtr
%zone8193 = bitcast i8* %tzone8192 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8193)
; malloc closure structure
%clsptr8194 = call i8* @llvm_zone_malloc(%mzone* %zone8193, i64 24)
%closure8195 = bitcast i8* %clsptr8194 to { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*

; malloc environment structure
%envptr8196 = call i8* @llvm_zone_malloc(%mzone* %zone8193, i64 8)
%environment8197 = bitcast i8* %envptr8196 to {{i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***}*

; malloc closure address table
%addytable8198 = call %clsvar* @new_address_table()
%var8199 = bitcast [66 x i8]* @gsxtmgraphics-pipeline340 to i8*
%var8200 = bitcast [63 x i8]* @gsxtmgraphics-pipeline336 to i8*
%addytable8201 = call %clsvar* @add_address_table(%mzone* %zone8193, i8* %var8199, i32 0, i8* %var8200, i32 3, %clsvar* %addytable8198)
%address-table8202 = bitcast %clsvar* %addytable8201 to i8*

; insert table, function and environment into closure struct
%closure.table8205 = getelementptr { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure8195, i32 0, i32 0
store i8* %address-table8202, i8** %closure.table8205
%closure.env8206 = getelementptr { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure8195, i32 0, i32 1
store i8* %envptr8196, i8** %closure.env8206
%closure.func8207 = getelementptr { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure8195, i32 0, i32 2
store %xtm_camera* (i8*, i8*, float*, float*, float*)* @xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ__8176, %xtm_camera* (i8*, i8*, float*, float*, float*)** %closure.func8207
%closure_size8208 = call i64 @llvm_zone_mark_size(%mzone* %zone8193)
call void @llvm_zone_ptr_set_size(i8* %clsptr8194, i64 %closure_size8208)
%wrapper_ptr8209 = call i8* @llvm_zone_malloc(%mzone* %zone8193, i64 8)
%closure_wrapper8210 = bitcast i8* %wrapper_ptr8209 to { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**
store { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure8195, { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure_wrapper8210

; let value assignment
%xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ = select i1 true, { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure_wrapper8210, { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure_wrapper8210
store { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ, { i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*** %xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr

; add data to environment
; don't need to alloc for env var xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%tmp_envptr8204 = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}***}* %environment8197, i32 0, i32 0
store {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*** %xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**** %tmp_envptr8204


%val8213 = load {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*** %xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr
ret {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %val8213
}


@xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** @xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %xtm_camera* @xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ(float* %arg_0,float* %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*, float*, float*, float*)*,  %xtm_camera* (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
ret %xtm_camera* %result
}


define dllexport ccc %xtm_camera* @xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_native(float* %arg_0,float* %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*, float*, float*, float*)*,  %xtm_camera* (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
ret %xtm_camera* %result
}


define dllexport ccc i8*  @xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8214 = bitcast [119 x i8]* @gsxtmgraphics-pipeline341 to i8*
call i32 (i8*, ...) @printf(i8* %var8214)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var8215 = bitcast [119 x i8]* @gsxtmgraphics-pipeline341 to i8*
call i32 (i8*, ...) @printf(i8* %var8215)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var8216 = bitcast [119 x i8]* @gsxtmgraphics-pipeline341 to i8*
call i32 (i8*, ...) @printf(i8* %var8216)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*, float*, float*, float*)*,  %xtm_camera* (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
%tmpres = bitcast %xtm_camera* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, float*}*
%arg_p_0 = getelementptr {float*, float*, float*}, {float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, float*}, {float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, float*}, {float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_h_adhoc_W3h0bV9jYW1lcmEqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*, float*, float*, float*)*,  %xtm_camera* (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline342 = hidden constant [18 x i8] c"<xtm_camera:null>\00"
@gsxtmgraphics-pipeline343 = hidden constant [13 x i8] c"<xtm_camera:\00"
@gsxtmgraphics-pipeline344 = hidden constant [44 x i8] c"toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd\00"
@gsxtmgraphics-pipeline345 = hidden constant [49 x i8] c"{i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd__8217(i8* %_impz,i8* %_impenv, %xtm_camera* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8218 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}***}*
%toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpdPtr = load {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}***, {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}**** %toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpdPtr_

; setup arguments
%xPtr = alloca %xtm_camera*
store %xtm_camera* %x, %xtm_camera** %xPtr


%val8220 = load %xtm_camera*, %xtm_camera** %xPtr
%val8221 = icmp eq %xtm_camera* %val8220, null
br i1 %val8221, label %then8219, label %else8219

then8219:
%zone8222 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone8222)
%zone_ptr8223 = bitcast %mzone* %zone8222 to i8*
store i8* %zone_ptr8223, i8** %_impzPtr
%tzone8233 = load i8*, i8** %_impzPtr
%zone8234 = bitcast i8* %tzone8233 to %mzone*

; let assign value to symbol res4
%res4Ptr = alloca %String*
%tzone8238 = load i8*, i8** %_impzPtr
%zone8239 = bitcast i8* %tzone8238 to %mzone*

; let assign value to symbol zone4
%zone4Ptr = alloca %mzone*
%tzone8241 = load i8*, i8** %_impzPtr
%zone8242 = bitcast i8* %tzone8241 to %mzone*

; let assign value to symbol newz4
%newz4Ptr = alloca %mzone*
%tzone8225 = load i8*, i8** %_impzPtr
%zone8226 = bitcast i8* %tzone8225 to %mzone*

; let assign value to symbol xx_t_mst
%xx_t_mstPtr = alloca i8*
%dat8224 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst = select i1 true, i8* %dat8224, i8* %dat8224
store i8* %xx_t_mst, i8** %xx_t_mstPtr

%val8227 = load i8*, i8** %xx_t_mstPtr
%var8228 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var8229 = bitcast [18 x i8]* @gsxtmgraphics-pipeline342 to i8*

%val8230 = call i32 (i8*,i8*, ...) @sprintf(i8* %val8227, i8* %var8228, i8* %var8229)
%val8231 = load i8*, i8** %xx_t_mstPtr
%res8232 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val8231)

; let value assignment
%res4 = select i1 true, %String* %res8232, %String* %res8232
store %String* %res4, %String** %res4Ptr

%oldzone8235 = call %mzone* @llvm_pop_zone_stack()
%newzone8236 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr8237 = bitcast %mzone* %newzone8236 to i8*
store i8* %zone_ptr8237, i8** %_impzPtr

; let value assignment
%zone4 = select i1 true, %mzone* %oldzone8235, %mzone* %oldzone8235
store %mzone* %zone4, %mzone** %zone4Ptr

%res8240 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz4 = select i1 true, %mzone* %res8240, %mzone* %res8240
store %mzone* %newz4, %mzone** %newz4Ptr

%tzone8247 = load i8*, i8** %_impzPtr
%zone8248 = bitcast i8* %tzone8247 to %mzone*

; let assign value to symbol rescopy4
%rescopy4Ptr = alloca %String*
%tzone8253 = load i8*, i8** %_impzPtr
%zone8254 = bitcast i8* %tzone8253 to %mzone*

; let assign value to symbol hook
%hookPtr = alloca {i64,i8*,i8*}*
%tzone8256 = load i8*, i8** %_impzPtr
%zone8257 = bitcast i8* %tzone8256 to %mzone*

; let assign value to symbol f
%fPtr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val8243 = load %String*, %String** %res4Ptr
%val8244 = load %mzone*, %mzone** %zone4Ptr
%val8245 = load %mzone*, %mzone** %newz4Ptr
%res8246 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val8243, %mzone* %val8244, %mzone* %val8245)

; let value assignment
%rescopy4 = select i1 true, %String* %res8246, %String* %res8246
store %String* %rescopy4, %String** %rescopy4Ptr

%val8249 = load %mzone*, %mzone** %zone4Ptr
; tuple ref
%val8250 = getelementptr %mzone, %mzone* %val8249, i64 0, i32 4
%val8251 = load i8*, i8** %val8250
%val8252 = bitcast i8* %val8251 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val8252, {i64,i8*,i8*}* %val8252
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%null8255 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null8255, {i8*, i8*, void (i8*, i8*)*}** %null8255
store {i8*, i8*, void (i8*, i8*)*}** %f, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; promote local stack var allocations
%tzone8293 = load i8*, i8** %_impzPtr
%zone8294 = bitcast i8* %tzone8293 to %mzone*
%ifptr8283 = alloca i1
%ifptr8259 = alloca i1
; while loop
%val8260 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val8261 = icmp eq {i64,i8*,i8*}* %val8260, null
br i1 %val8261, label %then8259, label %else8259

then8259:
%res8262 = call ccc i1 @impc_false()
store i1 %res8262, i1* %ifptr8259
br label %ifcont8259

else8259:
%res8263 = call ccc i1 @impc_true()
store i1 %res8263, i1* %ifptr8259
br label %ifcont8259

ifcont8259:
%ifres8264 = load i1, i1* %ifptr8259

br i1 %ifres8264, label %loop8258, label %after8258

loop8258:
; do set!
%val8265 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val8266 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val8265, i64 0, i32 1
%val8267 = load i8*, i8** %val8266
%val8268 = bitcast i8* %val8267 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val8268, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; apply closure 
%vval8269 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val8270 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval8269
%fPtr8271 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val8270, i32 0, i32 2
%ePtr8272 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val8270, i32 0, i32 1
%f8273 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr8271
%e8274 = load i8*, i8** %ePtr8272
%tzone8275 = load i8*, i8** %_impzPtr
%zone8276 = bitcast i8* %tzone8275 to %mzone*
%z8277 = bitcast %mzone* %zone8276 to i8*
tail call fastcc void %f8273(i8* %z8277, i8* %e8274)
; do set!
%val8279 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val8280 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val8279, i64 0, i32 2
%val8281 = load i8*, i8** %val8280
%val8282 = bitcast i8* %val8281 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val8282, {i64,i8*,i8*}** %hookPtr
%val8284 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val8285 = icmp eq {i64,i8*,i8*}* %val8284, null
br i1 %val8285, label %then8283, label %else8283

then8283:
%res8286 = call ccc i1 @impc_false()
store i1 %res8286, i1* %ifptr8283
br label %ifcont8283

else8283:
%res8287 = call ccc i1 @impc_true()
store i1 %res8287, i1* %ifptr8283
br label %ifcont8283

ifcont8283:
%ifres8288 = load i1, i1* %ifptr8283

br i1 %ifres8288, label %loop8258, label %after8258

after8258:
%val8290 = load %mzone*, %mzone** %zone4Ptr
call ccc void @llvm_zone_destroy(%mzone* %val8290)
%val8292 = load %String*, %String** %rescopy4Ptr
ret %String* %val8292

else8219:
%zone8295 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone8295)
%zone_ptr8296 = bitcast %mzone* %zone8295 to i8*
store i8* %zone_ptr8296, i8** %_impzPtr
%tzone8351 = load i8*, i8** %_impzPtr
%zone8352 = bitcast i8* %tzone8351 to %mzone*

; let assign value to symbol res5
%res5Ptr = alloca %String*
%tzone8356 = load i8*, i8** %_impzPtr
%zone8357 = bitcast i8* %tzone8356 to %mzone*

; let assign value to symbol zone5
%zone5Ptr = alloca %mzone*
%tzone8359 = load i8*, i8** %_impzPtr
%zone8360 = bitcast i8* %tzone8359 to %mzone*

; let assign value to symbol newz5
%newz5Ptr = alloca %mzone*
%tzone8298 = load i8*, i8** %_impzPtr
%zone8299 = bitcast i8* %tzone8298 to %mzone*

; let assign value to symbol xx_t_mst_s_27
%xx_t_mst_s_27Ptr = alloca i8*
%dat8297 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_27 = select i1 true, i8* %dat8297, i8* %dat8297
store i8* %xx_t_mst_s_27, i8** %xx_t_mst_s_27Ptr

%val8300 = load i8*, i8** %xx_t_mst_s_27Ptr
%var8301 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var8302 = bitcast [13 x i8]* @gsxtmgraphics-pipeline343 to i8*

%val8303 = call i32 (i8*,i8*, ...) @sprintf(i8* %val8300, i8* %var8301, i8* %var8302)
%val8304 = load i8*, i8** %xx_t_mst_s_27Ptr
%res8305 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val8304)
%val8306 = load %xtm_camera*, %xtm_camera** %xPtr
; tuple ref
%val8307 = getelementptr %xtm_camera, %xtm_camera* %val8306, i64 0, i32 0
%val8308 = load float*, float** %val8307
%res8309 = call fastcc %String* @toString_poly_W1N0cmluZyosZmxvYXQqXSo(float* %val8308)
%res8310 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res8305, %String* %res8309)
%tzone8312 = load i8*, i8** %_impzPtr
%zone8313 = bitcast i8* %tzone8312 to %mzone*

; let assign value to symbol xx_t_mst_s_28
%xx_t_mst_s_28Ptr = alloca i8*
%dat8311 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_28 = select i1 true, i8* %dat8311, i8* %dat8311
store i8* %xx_t_mst_s_28, i8** %xx_t_mst_s_28Ptr

%val8314 = load i8*, i8** %xx_t_mst_s_28Ptr
%var8315 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var8316 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val8317 = call i32 (i8*,i8*, ...) @sprintf(i8* %val8314, i8* %var8315, i8* %var8316)
%val8318 = load i8*, i8** %xx_t_mst_s_28Ptr
%res8319 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val8318)
%res8320 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res8310, %String* %res8319)
%val8321 = load %xtm_camera*, %xtm_camera** %xPtr
; tuple ref
%val8322 = getelementptr %xtm_camera, %xtm_camera* %val8321, i64 0, i32 1
%val8323 = load float*, float** %val8322
%res8324 = call fastcc %String* @toString_poly_W1N0cmluZyosZmxvYXQqXSo(float* %val8323)
%res8325 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res8320, %String* %res8324)
%tzone8327 = load i8*, i8** %_impzPtr
%zone8328 = bitcast i8* %tzone8327 to %mzone*

; let assign value to symbol xx_t_mst_s_29
%xx_t_mst_s_29Ptr = alloca i8*
%dat8326 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_29 = select i1 true, i8* %dat8326, i8* %dat8326
store i8* %xx_t_mst_s_29, i8** %xx_t_mst_s_29Ptr

%val8329 = load i8*, i8** %xx_t_mst_s_29Ptr
%var8330 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var8331 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val8332 = call i32 (i8*,i8*, ...) @sprintf(i8* %val8329, i8* %var8330, i8* %var8331)
%val8333 = load i8*, i8** %xx_t_mst_s_29Ptr
%res8334 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val8333)
%res8335 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res8325, %String* %res8334)
%val8336 = load %xtm_camera*, %xtm_camera** %xPtr
; tuple ref
%val8337 = getelementptr %xtm_camera, %xtm_camera* %val8336, i64 0, i32 2
%val8338 = load float*, float** %val8337
%res8339 = call fastcc %String* @toString_poly_W1N0cmluZyosZmxvYXQqXSo(float* %val8338)
%res8340 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res8335, %String* %res8339)
%tzone8342 = load i8*, i8** %_impzPtr
%zone8343 = bitcast i8* %tzone8342 to %mzone*

; let assign value to symbol xx_t_mst_s_30
%xx_t_mst_s_30Ptr = alloca i8*
%dat8341 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_30 = select i1 true, i8* %dat8341, i8* %dat8341
store i8* %xx_t_mst_s_30, i8** %xx_t_mst_s_30Ptr

%val8344 = load i8*, i8** %xx_t_mst_s_30Ptr
%var8345 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var8346 = bitcast [2 x i8]* @gsxtmgraphics-pipeline56 to i8*

%val8347 = call i32 (i8*,i8*, ...) @sprintf(i8* %val8344, i8* %var8345, i8* %var8346)
%val8348 = load i8*, i8** %xx_t_mst_s_30Ptr
%res8349 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val8348)
%res8350 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res8340, %String* %res8349)

; let value assignment
%res5 = select i1 true, %String* %res8350, %String* %res8350
store %String* %res5, %String** %res5Ptr

%oldzone8353 = call %mzone* @llvm_pop_zone_stack()
%newzone8354 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr8355 = bitcast %mzone* %newzone8354 to i8*
store i8* %zone_ptr8355, i8** %_impzPtr

; let value assignment
%zone5 = select i1 true, %mzone* %oldzone8353, %mzone* %oldzone8353
store %mzone* %zone5, %mzone** %zone5Ptr

%res8358 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz5 = select i1 true, %mzone* %res8358, %mzone* %res8358
store %mzone* %newz5, %mzone** %newz5Ptr

%tzone8365 = load i8*, i8** %_impzPtr
%zone8366 = bitcast i8* %tzone8365 to %mzone*

; let assign value to symbol rescopy5
%rescopy5Ptr = alloca %String*
%tzone8371 = load i8*, i8** %_impzPtr
%zone8372 = bitcast i8* %tzone8371 to %mzone*

; let assign value to symbol hook_s_31
%hook_s_31Ptr = alloca {i64,i8*,i8*}*
%tzone8374 = load i8*, i8** %_impzPtr
%zone8375 = bitcast i8* %tzone8374 to %mzone*

; let assign value to symbol f_s_32
%f_s_32Ptr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val8361 = load %String*, %String** %res5Ptr
%val8362 = load %mzone*, %mzone** %zone5Ptr
%val8363 = load %mzone*, %mzone** %newz5Ptr
%res8364 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val8361, %mzone* %val8362, %mzone* %val8363)

; let value assignment
%rescopy5 = select i1 true, %String* %res8364, %String* %res8364
store %String* %rescopy5, %String** %rescopy5Ptr

%val8367 = load %mzone*, %mzone** %zone5Ptr
; tuple ref
%val8368 = getelementptr %mzone, %mzone* %val8367, i64 0, i32 4
%val8369 = load i8*, i8** %val8368
%val8370 = bitcast i8* %val8369 to {i64,i8*,i8*}*

; let value assignment
%hook_s_31 = select i1 true, {i64,i8*,i8*}* %val8370, {i64,i8*,i8*}* %val8370
store {i64,i8*,i8*}* %hook_s_31, {i64,i8*,i8*}** %hook_s_31Ptr

%null8373 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f_s_32 = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null8373, {i8*, i8*, void (i8*, i8*)*}** %null8373
store {i8*, i8*, void (i8*, i8*)*}** %f_s_32, {i8*, i8*, void (i8*, i8*)*}*** %f_s_32Ptr

; promote local stack var allocations
%tzone8411 = load i8*, i8** %_impzPtr
%zone8412 = bitcast i8* %tzone8411 to %mzone*
%ifptr8401 = alloca i1
%ifptr8377 = alloca i1
; while loop
%val8378 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_31Ptr
%val8379 = icmp eq {i64,i8*,i8*}* %val8378, null
br i1 %val8379, label %then8377, label %else8377

then8377:
%res8380 = call ccc i1 @impc_false()
store i1 %res8380, i1* %ifptr8377
br label %ifcont8377

else8377:
%res8381 = call ccc i1 @impc_true()
store i1 %res8381, i1* %ifptr8377
br label %ifcont8377

ifcont8377:
%ifres8382 = load i1, i1* %ifptr8377

br i1 %ifres8382, label %loop8376, label %after8376

loop8376:
; do set!
%val8383 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_31Ptr
; tuple ref
%val8384 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val8383, i64 0, i32 1
%val8385 = load i8*, i8** %val8384
%val8386 = bitcast i8* %val8385 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val8386, {i8*, i8*, void (i8*, i8*)*}*** %f_s_32Ptr

; apply closure 
%vval8387 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %f_s_32Ptr
%val8388 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval8387
%fPtr8389 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val8388, i32 0, i32 2
%ePtr8390 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val8388, i32 0, i32 1
%f8391 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr8389
%e8392 = load i8*, i8** %ePtr8390
%tzone8393 = load i8*, i8** %_impzPtr
%zone8394 = bitcast i8* %tzone8393 to %mzone*
%z8395 = bitcast %mzone* %zone8394 to i8*
tail call fastcc void %f8391(i8* %z8395, i8* %e8392)
; do set!
%val8397 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_31Ptr
; tuple ref
%val8398 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val8397, i64 0, i32 2
%val8399 = load i8*, i8** %val8398
%val8400 = bitcast i8* %val8399 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val8400, {i64,i8*,i8*}** %hook_s_31Ptr
%val8402 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_31Ptr
%val8403 = icmp eq {i64,i8*,i8*}* %val8402, null
br i1 %val8403, label %then8401, label %else8401

then8401:
%res8404 = call ccc i1 @impc_false()
store i1 %res8404, i1* %ifptr8401
br label %ifcont8401

else8401:
%res8405 = call ccc i1 @impc_true()
store i1 %res8405, i1* %ifptr8401
br label %ifcont8401

ifcont8401:
%ifres8406 = load i1, i1* %ifptr8401

br i1 %ifres8406, label %loop8376, label %after8376

after8376:
%val8408 = load %mzone*, %mzone** %zone5Ptr
call ccc void @llvm_zone_destroy(%mzone* %val8408)
%val8410 = load %String*, %String** %rescopy5Ptr
ret %String* %val8410
}
@gsxtmgraphics-pipeline346 = hidden constant [97 x i8] c"toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}** @toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8432 = load i8*, i8** %_impzPtr
%zone8433 = bitcast i8* %tzone8432 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd
%dat_toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd = call i8* @llvm_zone_malloc(%mzone* %zone8433, i64 8)
%toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpdPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd to { i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}***
%tzone8413 = load i8*, i8** %_impzPtr
%zone8414 = bitcast i8* %tzone8413 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8414)
; malloc closure structure
%clsptr8415 = call i8* @llvm_zone_malloc(%mzone* %zone8414, i64 24)
%closure8416 = bitcast i8* %clsptr8415 to { i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}*

; malloc environment structure
%envptr8417 = call i8* @llvm_zone_malloc(%mzone* %zone8414, i64 8)
%environment8418 = bitcast i8* %envptr8417 to {{i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}***}*

; malloc closure address table
%addytable8419 = call %clsvar* @new_address_table()
%var8420 = bitcast [44 x i8]* @gsxtmgraphics-pipeline344 to i8*
%var8421 = bitcast [49 x i8]* @gsxtmgraphics-pipeline345 to i8*
%addytable8422 = call %clsvar* @add_address_table(%mzone* %zone8414, i8* %var8420, i32 0, i8* %var8421, i32 3, %clsvar* %addytable8419)
%address-table8423 = bitcast %clsvar* %addytable8422 to i8*

; insert table, function and environment into closure struct
%closure.table8426 = getelementptr { i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}, { i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}* %closure8416, i32 0, i32 0
store i8* %address-table8423, i8** %closure.table8426
%closure.env8427 = getelementptr { i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}, { i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}* %closure8416, i32 0, i32 1
store i8* %envptr8417, i8** %closure.env8427
%closure.func8428 = getelementptr { i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}, { i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}* %closure8416, i32 0, i32 2
store %String* (i8*, i8*, %xtm_camera*)* @toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd__8217, %String* (i8*, i8*, %xtm_camera*)** %closure.func8428
%closure_size8429 = call i64 @llvm_zone_mark_size(%mzone* %zone8414)
call void @llvm_zone_ptr_set_size(i8* %clsptr8415, i64 %closure_size8429)
%wrapper_ptr8430 = call i8* @llvm_zone_malloc(%mzone* %zone8414, i64 8)
%closure_wrapper8431 = bitcast i8* %wrapper_ptr8430 to { i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}**
store { i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}* %closure8416, { i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}** %closure_wrapper8431

; let value assignment
%toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd = select i1 true, { i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}** %closure_wrapper8431, { i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}** %closure_wrapper8431
store { i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}** %toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd, { i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}*** %toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpdPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd
%tmp_envptr8425 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}***}* %environment8418, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}*** %toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpdPtr, {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}**** %tmp_envptr8425


%val8434 = load {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}**, {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}*** %toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpdPtr
ret {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}** %val8434
}


@toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}** @toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd(%xtm_camera* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}*, {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %xtm_camera*)*,  %String* (i8*, i8*, %xtm_camera*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %xtm_camera* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd_native(%xtm_camera* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}*, {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %xtm_camera*)*,  %String* (i8*, i8*, %xtm_camera*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %xtm_camera* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8435 = bitcast [97 x i8]* @gsxtmgraphics-pipeline346 to i8*
call i32 (i8*, ...) @printf(i8* %var8435)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %xtm_camera*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}*, {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %xtm_camera*)*,  %String* (i8*, i8*, %xtm_camera*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %xtm_camera* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%xtm_camera*}*
%arg_p_0 = getelementptr {%xtm_camera*}, {%xtm_camera*}* %fstruct, i32 0, i32 0
%arg_0 = load %xtm_camera*, %xtm_camera** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyoseHRtX2NhbWVyYSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}*, {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, %String* (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %xtm_camera*)*,  %String* (i8*, i8*, %xtm_camera*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %xtm_camera* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline347 = hidden constant [37 x i8] c"print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd\00"
@gsxtmgraphics-pipeline348 = hidden constant [45 x i8] c"{i8*, i8*, void (i8*, i8*, %xtm_camera*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd__8436(i8* %_impz,i8* %_impenv, %xtm_camera* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8437 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %xtm_camera*)*}***}*
%print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %xtm_camera*)*}***}, {{i8*, i8*, void (i8*, i8*, %xtm_camera*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpdPtr = load {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}***, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}**** %print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpdPtr_

; setup arguments
%xPtr = alloca %xtm_camera*
store %xtm_camera* %x, %xtm_camera** %xPtr


%val8439 = load %xtm_camera*, %xtm_camera** %xPtr
%val8440 = icmp eq %xtm_camera* %val8439, null
br i1 %val8440, label %then8438, label %else8438

then8438:
%var8441 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var8442 = bitcast [18 x i8]* @gsxtmgraphics-pipeline342 to i8*

%val8443 = call i32 (i8*, ...) @printf(i8* %var8441, i8* %var8442)
br label %ifcont8438

else8438:
%var8445 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var8446 = bitcast [13 x i8]* @gsxtmgraphics-pipeline343 to i8*

%val8447 = call i32 (i8*, ...) @printf(i8* %var8445, i8* %var8446)
%val8448 = load %xtm_camera*, %xtm_camera** %xPtr
; tuple ref
%val8449 = getelementptr %xtm_camera, %xtm_camera* %val8448, i64 0, i32 0
%val8450 = load float*, float** %val8449
call fastcc void @print_poly_W3ZvaWQsZmxvYXQqXSo(float* %val8450)
%var8452 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var8453 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val8454 = call i32 (i8*, ...) @printf(i8* %var8452, i8* %var8453)
%val8455 = load %xtm_camera*, %xtm_camera** %xPtr
; tuple ref
%val8456 = getelementptr %xtm_camera, %xtm_camera* %val8455, i64 0, i32 1
%val8457 = load float*, float** %val8456
call fastcc void @print_poly_W3ZvaWQsZmxvYXQqXSo(float* %val8457)
%var8459 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var8460 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val8461 = call i32 (i8*, ...) @printf(i8* %var8459, i8* %var8460)
%val8462 = load %xtm_camera*, %xtm_camera** %xPtr
; tuple ref
%val8463 = getelementptr %xtm_camera, %xtm_camera* %val8462, i64 0, i32 2
%val8464 = load float*, float** %val8463
call fastcc void @print_poly_W3ZvaWQsZmxvYXQqXSo(float* %val8464)
%var8466 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var8467 = bitcast [2 x i8]* @gsxtmgraphics-pipeline56 to i8*

%val8468 = call i32 (i8*, ...) @printf(i8* %var8466, i8* %var8467)
br label %ifcont8438

ifcont8438:
ret void
}
@gsxtmgraphics-pipeline349 = hidden constant [90 x i8] c"print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** @print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8490 = load i8*, i8** %_impzPtr
%zone8491 = bitcast i8* %tzone8490 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd
%dat_print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd = call i8* @llvm_zone_malloc(%mzone* %zone8491, i64 8)
%print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd to { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}***
%tzone8471 = load i8*, i8** %_impzPtr
%zone8472 = bitcast i8* %tzone8471 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8472)
; malloc closure structure
%clsptr8473 = call i8* @llvm_zone_malloc(%mzone* %zone8472, i64 24)
%closure8474 = bitcast i8* %clsptr8473 to { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}*

; malloc environment structure
%envptr8475 = call i8* @llvm_zone_malloc(%mzone* %zone8472, i64 8)
%environment8476 = bitcast i8* %envptr8475 to {{i8*, i8*, void (i8*, i8*, %xtm_camera*)*}***}*

; malloc closure address table
%addytable8477 = call %clsvar* @new_address_table()
%var8478 = bitcast [37 x i8]* @gsxtmgraphics-pipeline347 to i8*
%var8479 = bitcast [45 x i8]* @gsxtmgraphics-pipeline348 to i8*
%addytable8480 = call %clsvar* @add_address_table(%mzone* %zone8472, i8* %var8478, i32 0, i8* %var8479, i32 3, %clsvar* %addytable8477)
%address-table8481 = bitcast %clsvar* %addytable8480 to i8*

; insert table, function and environment into closure struct
%closure.table8484 = getelementptr { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure8474, i32 0, i32 0
store i8* %address-table8481, i8** %closure.table8484
%closure.env8485 = getelementptr { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure8474, i32 0, i32 1
store i8* %envptr8475, i8** %closure.env8485
%closure.func8486 = getelementptr { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure8474, i32 0, i32 2
store void (i8*, i8*, %xtm_camera*)* @print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd__8436, void (i8*, i8*, %xtm_camera*)** %closure.func8486
%closure_size8487 = call i64 @llvm_zone_mark_size(%mzone* %zone8472)
call void @llvm_zone_ptr_set_size(i8* %clsptr8473, i64 %closure_size8487)
%wrapper_ptr8488 = call i8* @llvm_zone_malloc(%mzone* %zone8472, i64 8)
%closure_wrapper8489 = bitcast i8* %wrapper_ptr8488 to { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}**
store { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure8474, { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** %closure_wrapper8489

; let value assignment
%print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd = select i1 true, { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** %closure_wrapper8489, { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** %closure_wrapper8489
store { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** %print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd, { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}*** %print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd
%tmp_envptr8483 = getelementptr {{i8*, i8*, void (i8*, i8*, %xtm_camera*)*}***}, {{i8*, i8*, void (i8*, i8*, %xtm_camera*)*}***}* %environment8476, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}*** %print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpdPtr, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}**** %tmp_envptr8483


%val8492 = load {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}**, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}*** %print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpdPtr
ret {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** %val8492
}


@print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** @print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd(%xtm_camera* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}*, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %xtm_camera*)*,  void (i8*, i8*, %xtm_camera*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %xtm_camera* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_native(%xtm_camera* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}*, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %xtm_camera*)*,  void (i8*, i8*, %xtm_camera*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %xtm_camera* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8493 = bitcast [90 x i8]* @gsxtmgraphics-pipeline349 to i8*
call i32 (i8*, ...) @printf(i8* %var8493)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %xtm_camera*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}*, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %xtm_camera*)*,  void (i8*, i8*, %xtm_camera*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %xtm_camera* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%xtm_camera*}*
%arg_p_0 = getelementptr {%xtm_camera*}, {%xtm_camera*}* %fstruct, i32 0, i32 0
%arg_0 = load %xtm_camera*, %xtm_camera** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}*, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %xtm_camera*)*,  void (i8*, i8*, %xtm_camera*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %xtm_camera* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline350 = hidden constant [66 x i8] c"xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd\00"
@gsxtmgraphics-pipeline351 = hidden constant [62 x i8] c"{i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}**\00"
define dllexport fastcc %xtm_camera @xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd__8494(i8* %_impz,i8* %_impenv, float* %arg_0, float* %arg_1, float* %arg_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8495 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}***}*
%xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr_ = getelementptr {{i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}***}, {{i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr = load {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}***, {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}**** %xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr_

; setup arguments
%arg_0Ptr = alloca float*
store float* %arg_0, float** %arg_0Ptr
%arg_1Ptr = alloca float*
store float* %arg_1, float** %arg_1Ptr
%arg_2Ptr = alloca float*
store float* %arg_2, float** %arg_2Ptr


%tzone8497 = load i8*, i8** %_impzPtr
%zone8498 = bitcast i8* %tzone8497 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %xtm_camera*
%dat8496 = alloca %xtm_camera, align 16

; let value assignment
%obj = select i1 true, %xtm_camera* %dat8496, %xtm_camera* %dat8496
store %xtm_camera* %obj, %xtm_camera** %objPtr

%val8499 = load %xtm_camera*, %xtm_camera** %objPtr
%val8500 = load float*, float** %arg_0Ptr
; set tuple
%val8501 = getelementptr %xtm_camera, %xtm_camera* %val8499, i64 0, i32 0
store float* %val8500, float** %val8501
%val8502 = load %xtm_camera*, %xtm_camera** %objPtr
%val8503 = load float*, float** %arg_1Ptr
; set tuple
%val8504 = getelementptr %xtm_camera, %xtm_camera* %val8502, i64 0, i32 1
store float* %val8503, float** %val8504
%val8505 = load %xtm_camera*, %xtm_camera** %objPtr
%val8506 = load float*, float** %arg_2Ptr
; set tuple
%val8507 = getelementptr %xtm_camera, %xtm_camera* %val8505, i64 0, i32 2
store float* %val8506, float** %val8507
%val8508 = load %xtm_camera*, %xtm_camera** %objPtr
; pointer ref
%val8509 = getelementptr %xtm_camera, %xtm_camera* %val8508, i64 0
%val8510 = load %xtm_camera, %xtm_camera* %val8509
ret %xtm_camera %val8510
}
@gsxtmgraphics-pipeline352 = hidden constant [119 x i8] c"xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}** @xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8530 = load i8*, i8** %_impzPtr
%zone8531 = bitcast i8* %tzone8530 to %mzone*

; let assign value to symbol xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd
%dat_xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd = call i8* @llvm_zone_malloc(%mzone* %zone8531, i64 8)
%xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr = bitcast i8* %dat_xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd to { i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}***
%tzone8511 = load i8*, i8** %_impzPtr
%zone8512 = bitcast i8* %tzone8511 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8512)
; malloc closure structure
%clsptr8513 = call i8* @llvm_zone_malloc(%mzone* %zone8512, i64 24)
%closure8514 = bitcast i8* %clsptr8513 to { i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}*

; malloc environment structure
%envptr8515 = call i8* @llvm_zone_malloc(%mzone* %zone8512, i64 8)
%environment8516 = bitcast i8* %envptr8515 to {{i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}***}*

; malloc closure address table
%addytable8517 = call %clsvar* @new_address_table()
%var8518 = bitcast [66 x i8]* @gsxtmgraphics-pipeline350 to i8*
%var8519 = bitcast [62 x i8]* @gsxtmgraphics-pipeline351 to i8*
%addytable8520 = call %clsvar* @add_address_table(%mzone* %zone8512, i8* %var8518, i32 0, i8* %var8519, i32 3, %clsvar* %addytable8517)
%address-table8521 = bitcast %clsvar* %addytable8520 to i8*

; insert table, function and environment into closure struct
%closure.table8524 = getelementptr { i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}, { i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}* %closure8514, i32 0, i32 0
store i8* %address-table8521, i8** %closure.table8524
%closure.env8525 = getelementptr { i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}, { i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}* %closure8514, i32 0, i32 1
store i8* %envptr8515, i8** %closure.env8525
%closure.func8526 = getelementptr { i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}, { i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}* %closure8514, i32 0, i32 2
store %xtm_camera (i8*, i8*, float*, float*, float*)* @xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd__8494, %xtm_camera (i8*, i8*, float*, float*, float*)** %closure.func8526
%closure_size8527 = call i64 @llvm_zone_mark_size(%mzone* %zone8512)
call void @llvm_zone_ptr_set_size(i8* %clsptr8513, i64 %closure_size8527)
%wrapper_ptr8528 = call i8* @llvm_zone_malloc(%mzone* %zone8512, i64 8)
%closure_wrapper8529 = bitcast i8* %wrapper_ptr8528 to { i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}**
store { i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}* %closure8514, { i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}** %closure_wrapper8529

; let value assignment
%xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd = select i1 true, { i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}** %closure_wrapper8529, { i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}** %closure_wrapper8529
store { i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}** %xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd, { i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}*** %xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr

; add data to environment
; don't need to alloc for env var xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd
%tmp_envptr8523 = getelementptr {{i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}***}, {{i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}***}* %environment8516, i32 0, i32 0
store {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}*** %xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr, {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}**** %tmp_envptr8523


%val8532 = load {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}**, {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}*** %xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr
ret {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}** %val8532
}


@xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}** @xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %xtm_camera @xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd(float* %arg_0,float* %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera (i8*, i8*, float*, float*, float*)*,  %xtm_camera (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
ret %xtm_camera %result
}


define dllexport ccc %xtm_camera @xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_native(float* %arg_0,float* %arg_1,float* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera (i8*, i8*, float*, float*, float*)*,  %xtm_camera (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
ret %xtm_camera %result
}


define dllexport ccc void @xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, float*}*
%arg_p_0 = getelementptr {float*, float*, float*}, {float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, float*}, {float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, float*}, {float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_val_adhoc_W3h0bV9jYW1lcmEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}**
%closure = load {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}*, {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}, {i8*, i8*, %xtm_camera (i8*, i8*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera (i8*, i8*, float*, float*, float*)*,  %xtm_camera (i8*, i8*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline353 = hidden constant [47 x i8] c"hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ\00"
@gsxtmgraphics-pipeline354 = hidden constant [53 x i8] c"{i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}**\00"
define dllexport fastcc %xtm_camera* @hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ__8536(i8* %_impz,i8* %_impenv, %xtm_camera* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8537 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}***}*
%hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQPtr_ = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQPtr = load {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}***, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}**** %hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQPtr_

; setup arguments
%xPtr = alloca %xtm_camera*
store %xtm_camera* %x, %xtm_camera** %xPtr


%tzone8540 = load i8*, i8** %_impzPtr
%zone8541 = bitcast i8* %tzone8540 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %xtm_camera*
%dat8538 = call i8* @malloc(i64 24)
call i8* @memset(i8* %dat8538, i32 0, i64 24)
%val8539 = bitcast i8* %dat8538 to %xtm_camera*

; let value assignment
%obj = select i1 true, %xtm_camera* %val8539, %xtm_camera* %val8539
store %xtm_camera* %obj, %xtm_camera** %objPtr

%val8542 = load %xtm_camera*, %xtm_camera** %objPtr
%val8543 = load %xtm_camera*, %xtm_camera** %xPtr
; tuple ref
%val8544 = getelementptr %xtm_camera, %xtm_camera* %val8543, i64 0, i32 0
%val8545 = load float*, float** %val8544
; set tuple
%val8546 = getelementptr %xtm_camera, %xtm_camera* %val8542, i64 0, i32 0
store float* %val8545, float** %val8546
%val8547 = load %xtm_camera*, %xtm_camera** %objPtr
%val8548 = load %xtm_camera*, %xtm_camera** %xPtr
; tuple ref
%val8549 = getelementptr %xtm_camera, %xtm_camera* %val8548, i64 0, i32 1
%val8550 = load float*, float** %val8549
; set tuple
%val8551 = getelementptr %xtm_camera, %xtm_camera* %val8547, i64 0, i32 1
store float* %val8550, float** %val8551
%val8552 = load %xtm_camera*, %xtm_camera** %objPtr
%val8553 = load %xtm_camera*, %xtm_camera** %xPtr
; tuple ref
%val8554 = getelementptr %xtm_camera, %xtm_camera* %val8553, i64 0, i32 2
%val8555 = load float*, float** %val8554
; set tuple
%val8556 = getelementptr %xtm_camera, %xtm_camera* %val8552, i64 0, i32 2
store float* %val8555, float** %val8556
%val8557 = load %xtm_camera*, %xtm_camera** %objPtr
ret %xtm_camera* %val8557
}
@gsxtmgraphics-pipeline355 = hidden constant [100 x i8] c"hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}** @hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8577 = load i8*, i8** %_impzPtr
%zone8578 = bitcast i8* %tzone8577 to %mzone*

; let assign value to symbol hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ
%dat_hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ = call i8* @llvm_zone_malloc(%mzone* %zone8578, i64 8)
%hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQPtr = bitcast i8* %dat_hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ to { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}***
%tzone8558 = load i8*, i8** %_impzPtr
%zone8559 = bitcast i8* %tzone8558 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8559)
; malloc closure structure
%clsptr8560 = call i8* @llvm_zone_malloc(%mzone* %zone8559, i64 24)
%closure8561 = bitcast i8* %clsptr8560 to { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}*

; malloc environment structure
%envptr8562 = call i8* @llvm_zone_malloc(%mzone* %zone8559, i64 8)
%environment8563 = bitcast i8* %envptr8562 to {{i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}***}*

; malloc closure address table
%addytable8564 = call %clsvar* @new_address_table()
%var8565 = bitcast [47 x i8]* @gsxtmgraphics-pipeline353 to i8*
%var8566 = bitcast [53 x i8]* @gsxtmgraphics-pipeline354 to i8*
%addytable8567 = call %clsvar* @add_address_table(%mzone* %zone8559, i8* %var8565, i32 0, i8* %var8566, i32 3, %clsvar* %addytable8564)
%address-table8568 = bitcast %clsvar* %addytable8567 to i8*

; insert table, function and environment into closure struct
%closure.table8571 = getelementptr { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}, { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}* %closure8561, i32 0, i32 0
store i8* %address-table8568, i8** %closure.table8571
%closure.env8572 = getelementptr { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}, { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}* %closure8561, i32 0, i32 1
store i8* %envptr8562, i8** %closure.env8572
%closure.func8573 = getelementptr { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}, { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}* %closure8561, i32 0, i32 2
store %xtm_camera* (i8*, i8*, %xtm_camera*)* @hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ__8536, %xtm_camera* (i8*, i8*, %xtm_camera*)** %closure.func8573
%closure_size8574 = call i64 @llvm_zone_mark_size(%mzone* %zone8559)
call void @llvm_zone_ptr_set_size(i8* %clsptr8560, i64 %closure_size8574)
%wrapper_ptr8575 = call i8* @llvm_zone_malloc(%mzone* %zone8559, i64 8)
%closure_wrapper8576 = bitcast i8* %wrapper_ptr8575 to { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}**
store { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}* %closure8561, { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}** %closure_wrapper8576

; let value assignment
%hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ = select i1 true, { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}** %closure_wrapper8576, { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}** %closure_wrapper8576
store { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}** %hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ, { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}*** %hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ
%tmp_envptr8570 = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}***}* %environment8563, i32 0, i32 0
store {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}*** %hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQPtr, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}**** %tmp_envptr8570


%val8579 = load {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}**, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}*** %hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQPtr
ret {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}** %val8579
}


@hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}** @hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %xtm_camera* @hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ(%xtm_camera* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*, %xtm_camera*)*,  %xtm_camera* (i8*, i8*, %xtm_camera*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee, %xtm_camera* %arg_0)
ret %xtm_camera* %result
}


define dllexport ccc %xtm_camera* @hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ_native(%xtm_camera* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*, %xtm_camera*)*,  %xtm_camera* (i8*, i8*, %xtm_camera*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee, %xtm_camera* %arg_0)
ret %xtm_camera* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8580 = bitcast [100 x i8]* @gsxtmgraphics-pipeline355 to i8*
call i32 (i8*, ...) @printf(i8* %var8580)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %xtm_camera*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*, %xtm_camera*)*,  %xtm_camera* (i8*, i8*, %xtm_camera*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee, %xtm_camera* %arg_0)
%tmpres = bitcast %xtm_camera* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%xtm_camera*}*
%arg_p_0 = getelementptr {%xtm_camera*}, {%xtm_camera*}* %fstruct, i32 0, i32 0
%arg_0 = load %xtm_camera*, %xtm_camera** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*, %xtm_camera*)*,  %xtm_camera* (i8*, i8*, %xtm_camera*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee, %xtm_camera* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline356 = hidden constant [37 x i8] c"hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd__8581(i8* %_impz,i8* %_impenv, %xtm_camera* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8582 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %xtm_camera*)*}***}*
%hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %xtm_camera*)*}***}, {{i8*, i8*, void (i8*, i8*, %xtm_camera*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpdPtr = load {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}***, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}**** %hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpdPtr_

; setup arguments
%xPtr = alloca %xtm_camera*
store %xtm_camera* %x, %xtm_camera** %xPtr


%val8583 = load %xtm_camera*, %xtm_camera** %xPtr
%val8584 = bitcast %xtm_camera* %val8583 to i8*
call ccc void @free(i8* %val8584)
ret void
}
@gsxtmgraphics-pipeline357 = hidden constant [90 x i8] c"hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** @hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8606 = load i8*, i8** %_impzPtr
%zone8607 = bitcast i8* %tzone8606 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd
%dat_hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd = call i8* @llvm_zone_malloc(%mzone* %zone8607, i64 8)
%hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpdPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd to { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}***
%tzone8587 = load i8*, i8** %_impzPtr
%zone8588 = bitcast i8* %tzone8587 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8588)
; malloc closure structure
%clsptr8589 = call i8* @llvm_zone_malloc(%mzone* %zone8588, i64 24)
%closure8590 = bitcast i8* %clsptr8589 to { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}*

; malloc environment structure
%envptr8591 = call i8* @llvm_zone_malloc(%mzone* %zone8588, i64 8)
%environment8592 = bitcast i8* %envptr8591 to {{i8*, i8*, void (i8*, i8*, %xtm_camera*)*}***}*

; malloc closure address table
%addytable8593 = call %clsvar* @new_address_table()
%var8594 = bitcast [37 x i8]* @gsxtmgraphics-pipeline356 to i8*
%var8595 = bitcast [45 x i8]* @gsxtmgraphics-pipeline348 to i8*
%addytable8596 = call %clsvar* @add_address_table(%mzone* %zone8588, i8* %var8594, i32 0, i8* %var8595, i32 3, %clsvar* %addytable8593)
%address-table8597 = bitcast %clsvar* %addytable8596 to i8*

; insert table, function and environment into closure struct
%closure.table8600 = getelementptr { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure8590, i32 0, i32 0
store i8* %address-table8597, i8** %closure.table8600
%closure.env8601 = getelementptr { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure8590, i32 0, i32 1
store i8* %envptr8591, i8** %closure.env8601
%closure.func8602 = getelementptr { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure8590, i32 0, i32 2
store void (i8*, i8*, %xtm_camera*)* @hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd__8581, void (i8*, i8*, %xtm_camera*)** %closure.func8602
%closure_size8603 = call i64 @llvm_zone_mark_size(%mzone* %zone8588)
call void @llvm_zone_ptr_set_size(i8* %clsptr8589, i64 %closure_size8603)
%wrapper_ptr8604 = call i8* @llvm_zone_malloc(%mzone* %zone8588, i64 8)
%closure_wrapper8605 = bitcast i8* %wrapper_ptr8604 to { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}**
store { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure8590, { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** %closure_wrapper8605

; let value assignment
%hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd = select i1 true, { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** %closure_wrapper8605, { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** %closure_wrapper8605
store { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** %hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd, { i8*, i8*, void (i8*, i8*, %xtm_camera*)*}*** %hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpdPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd
%tmp_envptr8599 = getelementptr {{i8*, i8*, void (i8*, i8*, %xtm_camera*)*}***}, {{i8*, i8*, void (i8*, i8*, %xtm_camera*)*}***}* %environment8592, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}*** %hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpdPtr, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}**** %tmp_envptr8599


%val8608 = load {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}**, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}*** %hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpdPtr
ret {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** %val8608
}


@hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** @hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd(%xtm_camera* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}*, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %xtm_camera*)*,  void (i8*, i8*, %xtm_camera*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %xtm_camera* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_native(%xtm_camera* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}*, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %xtm_camera*)*,  void (i8*, i8*, %xtm_camera*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %xtm_camera* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8609 = bitcast [90 x i8]* @gsxtmgraphics-pipeline357 to i8*
call i32 (i8*, ...) @printf(i8* %var8609)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %xtm_camera*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}*, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %xtm_camera*)*,  void (i8*, i8*, %xtm_camera*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %xtm_camera* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%xtm_camera*}*
%arg_p_0 = getelementptr {%xtm_camera*}, {%xtm_camera*}* %fstruct, i32 0, i32 0
%arg_0 = load %xtm_camera*, %xtm_camera** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQseHRtX2NhbWVyYSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}*, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}, {i8*, i8*, void (i8*, i8*, %xtm_camera*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %xtm_camera*)*,  void (i8*, i8*, %xtm_camera*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %xtm_camera* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline358 = hidden constant [65 x i8] c"zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd\00"
@gsxtmgraphics-pipeline359 = hidden constant [71 x i8] c"{i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %xtm_camera* @zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd__8610(i8* %_impz,i8* %_impenv, %xtm_camera* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8611 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpdPtr = load {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}***, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpdPtr_

; setup arguments
%xPtr = alloca %xtm_camera*
store %xtm_camera* %x, %xtm_camera** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val8613 = load %mzone*, %mzone** %fromzPtr
%val8614 = load %xtm_camera*, %xtm_camera** %xPtr
%val8615 = bitcast %xtm_camera* %val8614 to i8*
%res8616 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val8613, i8* %val8615)
br i1 %res8616, label %then8612, label %else8612

then8612:
%val8617 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val8617)
%zone_ptr8618 = bitcast %mzone* %val8617 to i8*
store i8* %zone_ptr8618, i8** %_impzPtr
%tzone8624 = load i8*, i8** %_impzPtr
%zone8625 = bitcast i8* %tzone8624 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %xtm_camera*
%tzone8620 = load i8*, i8** %_impzPtr
%zone8621 = bitcast i8* %tzone8620 to %mzone*
%dat8622 = call i8* @llvm_zone_malloc(%mzone* %zone8621, i64 24)
call i8* @memset(i8* %dat8622, i32 0, i64 24)
%val8623 = bitcast i8* %dat8622 to %xtm_camera*

; let value assignment
%obj = select i1 true, %xtm_camera* %val8623, %xtm_camera* %val8623
store %xtm_camera* %obj, %xtm_camera** %objPtr

; promote local stack var allocations
%tzone8717 = load i8*, i8** %_impzPtr
%zone8718 = bitcast i8* %tzone8717 to %mzone*
%ifptr8684 = alloca float*
%ifptr8655 = alloca float*
%ifptr8626 = alloca float*
%val8627 = load %mzone*, %mzone** %fromzPtr
%val8628 = load %xtm_camera*, %xtm_camera** %xPtr
; tuple ref
%val8629 = getelementptr %xtm_camera, %xtm_camera* %val8628, i64 0, i32 0
%val8630 = load float*, float** %val8629
%val8631 = bitcast float* %val8630 to i8*
%res8632 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val8627, i8* %val8631)
br i1 %res8632, label %then8626, label %else8626

then8626:
%tzone8637 = load i8*, i8** %_impzPtr
%zone8638 = bitcast i8* %tzone8637 to %mzone*

; let assign value to symbol newptr
%newptrPtr = alloca float*
%tzone8633 = load i8*, i8** %_impzPtr
%zone8634 = bitcast i8* %tzone8633 to %mzone*
%dat8635 = call i8* @llvm_zone_malloc(%mzone* %zone8634, i64 4)
call i8* @memset(i8* %dat8635, i32 0, i64 4)
%val8636 = bitcast i8* %dat8635 to float*

; let value assignment
%newptr = select i1 true, float* %val8636, float* %val8636
store float* %newptr, float** %newptrPtr

%val8639 = load float*, float** %newptrPtr
%val8640 = bitcast float* %val8639 to i8*
%val8641 = load %xtm_camera*, %xtm_camera** %xPtr
; tuple ref
%val8642 = getelementptr %xtm_camera, %xtm_camera* %val8641, i64 0, i32 0
%val8643 = load float*, float** %val8642
%val8644 = bitcast float* %val8643 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val8640, i8* %val8644, i64 4, i32 1, i1 0)
%val8646 = load %xtm_camera*, %xtm_camera** %objPtr
%val8647 = load float*, float** %newptrPtr
; set tuple
%val8648 = getelementptr %xtm_camera, %xtm_camera* %val8646, i64 0, i32 0
store float* %val8647, float** %val8648
store float* %val8647, float** %ifptr8626
br label %ifcont8626

else8626:
%val8649 = load %xtm_camera*, %xtm_camera** %objPtr
%val8650 = load %xtm_camera*, %xtm_camera** %xPtr
; tuple ref
%val8651 = getelementptr %xtm_camera, %xtm_camera* %val8650, i64 0, i32 0
%val8652 = load float*, float** %val8651
; set tuple
%val8653 = getelementptr %xtm_camera, %xtm_camera* %val8649, i64 0, i32 0
store float* %val8652, float** %val8653
store float* %val8652, float** %ifptr8626
br label %ifcont8626

ifcont8626:
%ifres8654 = load float*, float** %ifptr8626

%val8656 = load %mzone*, %mzone** %fromzPtr
%val8657 = load %xtm_camera*, %xtm_camera** %xPtr
; tuple ref
%val8658 = getelementptr %xtm_camera, %xtm_camera* %val8657, i64 0, i32 1
%val8659 = load float*, float** %val8658
%val8660 = bitcast float* %val8659 to i8*
%res8661 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val8656, i8* %val8660)
br i1 %res8661, label %then8655, label %else8655

then8655:
%tzone8666 = load i8*, i8** %_impzPtr
%zone8667 = bitcast i8* %tzone8666 to %mzone*

; let assign value to symbol newptr_s_33
%newptr_s_33Ptr = alloca float*
%tzone8662 = load i8*, i8** %_impzPtr
%zone8663 = bitcast i8* %tzone8662 to %mzone*
%dat8664 = call i8* @llvm_zone_malloc(%mzone* %zone8663, i64 4)
call i8* @memset(i8* %dat8664, i32 0, i64 4)
%val8665 = bitcast i8* %dat8664 to float*

; let value assignment
%newptr_s_33 = select i1 true, float* %val8665, float* %val8665
store float* %newptr_s_33, float** %newptr_s_33Ptr

%val8668 = load float*, float** %newptr_s_33Ptr
%val8669 = bitcast float* %val8668 to i8*
%val8670 = load %xtm_camera*, %xtm_camera** %xPtr
; tuple ref
%val8671 = getelementptr %xtm_camera, %xtm_camera* %val8670, i64 0, i32 1
%val8672 = load float*, float** %val8671
%val8673 = bitcast float* %val8672 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val8669, i8* %val8673, i64 4, i32 1, i1 0)
%val8675 = load %xtm_camera*, %xtm_camera** %objPtr
%val8676 = load float*, float** %newptr_s_33Ptr
; set tuple
%val8677 = getelementptr %xtm_camera, %xtm_camera* %val8675, i64 0, i32 1
store float* %val8676, float** %val8677
store float* %val8676, float** %ifptr8655
br label %ifcont8655

else8655:
%val8678 = load %xtm_camera*, %xtm_camera** %objPtr
%val8679 = load %xtm_camera*, %xtm_camera** %xPtr
; tuple ref
%val8680 = getelementptr %xtm_camera, %xtm_camera* %val8679, i64 0, i32 1
%val8681 = load float*, float** %val8680
; set tuple
%val8682 = getelementptr %xtm_camera, %xtm_camera* %val8678, i64 0, i32 1
store float* %val8681, float** %val8682
store float* %val8681, float** %ifptr8655
br label %ifcont8655

ifcont8655:
%ifres8683 = load float*, float** %ifptr8655

%val8685 = load %mzone*, %mzone** %fromzPtr
%val8686 = load %xtm_camera*, %xtm_camera** %xPtr
; tuple ref
%val8687 = getelementptr %xtm_camera, %xtm_camera* %val8686, i64 0, i32 2
%val8688 = load float*, float** %val8687
%val8689 = bitcast float* %val8688 to i8*
%res8690 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val8685, i8* %val8689)
br i1 %res8690, label %then8684, label %else8684

then8684:
%tzone8695 = load i8*, i8** %_impzPtr
%zone8696 = bitcast i8* %tzone8695 to %mzone*

; let assign value to symbol newptr_s_34
%newptr_s_34Ptr = alloca float*
%tzone8691 = load i8*, i8** %_impzPtr
%zone8692 = bitcast i8* %tzone8691 to %mzone*
%dat8693 = call i8* @llvm_zone_malloc(%mzone* %zone8692, i64 4)
call i8* @memset(i8* %dat8693, i32 0, i64 4)
%val8694 = bitcast i8* %dat8693 to float*

; let value assignment
%newptr_s_34 = select i1 true, float* %val8694, float* %val8694
store float* %newptr_s_34, float** %newptr_s_34Ptr

%val8697 = load float*, float** %newptr_s_34Ptr
%val8698 = bitcast float* %val8697 to i8*
%val8699 = load %xtm_camera*, %xtm_camera** %xPtr
; tuple ref
%val8700 = getelementptr %xtm_camera, %xtm_camera* %val8699, i64 0, i32 2
%val8701 = load float*, float** %val8700
%val8702 = bitcast float* %val8701 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val8698, i8* %val8702, i64 4, i32 1, i1 0)
%val8704 = load %xtm_camera*, %xtm_camera** %objPtr
%val8705 = load float*, float** %newptr_s_34Ptr
; set tuple
%val8706 = getelementptr %xtm_camera, %xtm_camera* %val8704, i64 0, i32 2
store float* %val8705, float** %val8706
store float* %val8705, float** %ifptr8684
br label %ifcont8684

else8684:
%val8707 = load %xtm_camera*, %xtm_camera** %objPtr
%val8708 = load %xtm_camera*, %xtm_camera** %xPtr
; tuple ref
%val8709 = getelementptr %xtm_camera, %xtm_camera* %val8708, i64 0, i32 2
%val8710 = load float*, float** %val8709
; set tuple
%val8711 = getelementptr %xtm_camera, %xtm_camera* %val8707, i64 0, i32 2
store float* %val8710, float** %val8711
store float* %val8710, float** %ifptr8684
br label %ifcont8684

ifcont8684:
%ifres8712 = load float*, float** %ifptr8684

%oldzone8713 = call %mzone* @llvm_pop_zone_stack()
%newzone8714 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr8715 = bitcast %mzone* %newzone8714 to i8*
store i8* %zone_ptr8715, i8** %_impzPtr
%val8716 = load %xtm_camera*, %xtm_camera** %objPtr
ret %xtm_camera* %val8716

else8612:
%val8719 = load %xtm_camera*, %xtm_camera** %xPtr
ret %xtm_camera* %val8719
}
@gsxtmgraphics-pipeline360 = hidden constant [118 x i8] c"zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}** @zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8739 = load i8*, i8** %_impzPtr
%zone8740 = bitcast i8* %tzone8739 to %mzone*

; let assign value to symbol zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd
%dat_zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone8740, i64 8)
%zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpdPtr = bitcast i8* %dat_zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd to { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}***
%tzone8720 = load i8*, i8** %_impzPtr
%zone8721 = bitcast i8* %tzone8720 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8721)
; malloc closure structure
%clsptr8722 = call i8* @llvm_zone_malloc(%mzone* %zone8721, i64 24)
%closure8723 = bitcast i8* %clsptr8722 to { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr8724 = call i8* @llvm_zone_malloc(%mzone* %zone8721, i64 8)
%environment8725 = bitcast i8* %envptr8724 to {{i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable8726 = call %clsvar* @new_address_table()
%var8727 = bitcast [65 x i8]* @gsxtmgraphics-pipeline358 to i8*
%var8728 = bitcast [71 x i8]* @gsxtmgraphics-pipeline359 to i8*
%addytable8729 = call %clsvar* @add_address_table(%mzone* %zone8721, i8* %var8727, i32 0, i8* %var8728, i32 3, %clsvar* %addytable8726)
%address-table8730 = bitcast %clsvar* %addytable8729 to i8*

; insert table, function and environment into closure struct
%closure.table8733 = getelementptr { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}, { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}* %closure8723, i32 0, i32 0
store i8* %address-table8730, i8** %closure.table8733
%closure.env8734 = getelementptr { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}, { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}* %closure8723, i32 0, i32 1
store i8* %envptr8724, i8** %closure.env8734
%closure.func8735 = getelementptr { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}, { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}* %closure8723, i32 0, i32 2
store %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)* @zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd__8610, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)** %closure.func8735
%closure_size8736 = call i64 @llvm_zone_mark_size(%mzone* %zone8721)
call void @llvm_zone_ptr_set_size(i8* %clsptr8722, i64 %closure_size8736)
%wrapper_ptr8737 = call i8* @llvm_zone_malloc(%mzone* %zone8721, i64 8)
%closure_wrapper8738 = bitcast i8* %wrapper_ptr8737 to { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}**
store { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}* %closure8723, { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}** %closure_wrapper8738

; let value assignment
%zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd = select i1 true, { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}** %closure_wrapper8738, { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}** %closure_wrapper8738
store { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}** %zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd, { i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd
%tmp_envptr8732 = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}***}* %environment8725, i32 0, i32 0
store {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpdPtr, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}**** %tmp_envptr8732


%val8741 = load {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}**, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpdPtr
ret {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}** %val8741
}


@zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}** @zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %xtm_camera* @zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd(%xtm_camera* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*,  %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee, %xtm_camera* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %xtm_camera* %result
}


define dllexport ccc %xtm_camera* @zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd_native(%xtm_camera* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*,  %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee, %xtm_camera* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %xtm_camera* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8742 = bitcast [118 x i8]* @gsxtmgraphics-pipeline360 to i8*
call i32 (i8*, ...) @printf(i8* %var8742)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %xtm_camera*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var8743 = bitcast [118 x i8]* @gsxtmgraphics-pipeline360 to i8*
call i32 (i8*, ...) @printf(i8* %var8743)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var8744 = bitcast [118 x i8]* @gsxtmgraphics-pipeline360 to i8*
call i32 (i8*, ...) @printf(i8* %var8744)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*,  %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee, %xtm_camera* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %xtm_camera* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%xtm_camera*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%xtm_camera*, %mzone*, %mzone*}, {%xtm_camera*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %xtm_camera*, %xtm_camera** %arg_p_0
%arg_p_1 = getelementptr {%xtm_camera*, %mzone*, %mzone*}, {%xtm_camera*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%xtm_camera*, %mzone*, %mzone*}, {%xtm_camera*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W3h0bV9jYW1lcmEqLHh0bV9jYW1lcmEqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)*,  %xtm_camera* (i8*, i8*, %xtm_camera*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee, %xtm_camera* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline361 = hidden constant [40 x i8] c"xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ\00"
@gsxtmgraphics-pipeline362 = hidden constant [39 x i8] c"{i8*, i8*, %xtm_camera* (i8*, i8*)*}**\00"
@gsxtmgraphics-pipeline363 = hidden constant [2 x i8] c"u\00"
@gsxtmgraphics-pipeline364 = hidden constant [2 x i8] c"t\00"
@gsxtmgraphics-pipeline365 = hidden constant [2 x i8] c"p\00"
@gsxtmgraphics-pipeline366 = hidden constant [7 x i8] c"camera\00"
@gsxtmgraphics-pipeline367 = hidden constant [13 x i8] c"%xtm_camera*\00"
@gsxtmgraphics-pipeline368 = hidden constant [15 x i8] c"_anon_lambda_8\00"
define dllexport fastcc %xtm_camera* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ__8745(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8809 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}*
%xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQPtr_ = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQPtr = load {i8*, i8*, %xtm_camera* (i8*, i8*)*}***, {i8*, i8*, %xtm_camera* (i8*, i8*)*}**** %xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQPtr_
%uPtr_ = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}* %impenv, i32 0, i32 1
%uPtr = load float**, float*** %uPtr_
%tPtr_ = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}* %impenv, i32 0, i32 2
%tPtr = load float**, float*** %tPtr_
%pPtr_ = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}* %impenv, i32 0, i32 3
%pPtr = load float**, float*** %pPtr_
%cameraPtr_ = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}* %impenv, i32 0, i32 4
%cameraPtr = load %xtm_camera**, %xtm_camera*** %cameraPtr_
%_anon_lambda_8Ptr_ = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}* %impenv, i32 0, i32 5
%_anon_lambda_8Ptr = load {i8*, i8*, %xtm_camera* (i8*, i8*)*}***, {i8*, i8*, %xtm_camera* (i8*, i8*)*}**** %_anon_lambda_8Ptr_

; setup arguments


%val8810 = load %xtm_camera*, %xtm_camera** %cameraPtr
ret %xtm_camera* %val8810
}
define dllexport ccc {i8*, i8*, %xtm_camera* (i8*, i8*)*}** @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8858 = load i8*, i8** %_impzPtr
%zone8859 = bitcast i8* %tzone8858 to %mzone*

; let assign value to symbol xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ
%dat_xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ = call i8* @llvm_zone_malloc(%mzone* %zone8859, i64 8)
%xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQPtr = bitcast i8* %dat_xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ to {i8*, i8*, %xtm_camera* (i8*, i8*)*}***
%tzone8750 = load i8*, i8** %_impzPtr
%zone8751 = bitcast i8* %tzone8750 to %mzone*

; let assign value to symbol camera
%dat_camera = call i8* @llvm_zone_malloc(%mzone* %zone8751, i64 8)
%cameraPtr = bitcast i8* %dat_camera to %xtm_camera**
%tzone8758 = load i8*, i8** %_impzPtr
%zone8759 = bitcast i8* %tzone8758 to %mzone*

; let assign value to symbol p
%dat_p = call i8* @llvm_zone_malloc(%mzone* %zone8759, i64 8)
%pPtr = bitcast i8* %dat_p to float**
%tzone8766 = load i8*, i8** %_impzPtr
%zone8767 = bitcast i8* %tzone8766 to %mzone*

; let assign value to symbol t
%dat_t = call i8* @llvm_zone_malloc(%mzone* %zone8767, i64 8)
%tPtr = bitcast i8* %dat_t to float**
%tzone8774 = load i8*, i8** %_impzPtr
%zone8775 = bitcast i8* %tzone8774 to %mzone*

; let assign value to symbol u
%dat_u = call i8* @llvm_zone_malloc(%mzone* %zone8775, i64 8)
%uPtr = bitcast i8* %dat_u to float**
%tzone8746 = load i8*, i8** %_impzPtr
%zone8747 = bitcast i8* %tzone8746 to %mzone*
%dat8748 = call i8* @llvm_zone_malloc(%mzone* %zone8747, i64 24)
call i8* @memset(i8* %dat8748, i32 0, i64 24)
%val8749 = bitcast i8* %dat8748 to %xtm_camera*

; let value assignment
%camera = select i1 true, %xtm_camera* %val8749, %xtm_camera* %val8749
store %xtm_camera* %camera, %xtm_camera** %cameraPtr

%val8752 = getelementptr i64, i64* null, i32 1
%zonesize8753 = mul i64 4, 4
%tzone8754 = load i8*, i8** %_impzPtr
%zone8755 = bitcast i8* %tzone8754 to %mzone*
%dat8756 = call i8* @llvm_zone_malloc(%mzone* %zone8755, i64 %zonesize8753)
call i8* @memset(i8* %dat8756, i32 0, i64 %zonesize8753)
%val8757 = bitcast i8* %dat8756 to float*

; let value assignment
%p = select i1 true, float* %val8757, float* %val8757
store float* %p, float** %pPtr

%val8760 = getelementptr i64, i64* null, i32 1
%zonesize8761 = mul i64 4, 4
%tzone8762 = load i8*, i8** %_impzPtr
%zone8763 = bitcast i8* %tzone8762 to %mzone*
%dat8764 = call i8* @llvm_zone_malloc(%mzone* %zone8763, i64 %zonesize8761)
call i8* @memset(i8* %dat8764, i32 0, i64 %zonesize8761)
%val8765 = bitcast i8* %dat8764 to float*

; let value assignment
%t = select i1 true, float* %val8765, float* %val8765
store float* %t, float** %tPtr

%val8768 = getelementptr i64, i64* null, i32 1
%zonesize8769 = mul i64 4, 4
%tzone8770 = load i8*, i8** %_impzPtr
%zone8771 = bitcast i8* %tzone8770 to %mzone*
%dat8772 = call i8* @llvm_zone_malloc(%mzone* %zone8771, i64 %zonesize8769)
call i8* @memset(i8* %dat8772, i32 0, i64 %zonesize8769)
%val8773 = bitcast i8* %dat8772 to float*

; let value assignment
%u = select i1 true, float* %val8773, float* %val8773
store float* %u, float** %uPtr

%val8776 = load float*, float** %pPtr
; set pointer
%val8777 = getelementptr float, float* %val8776, i64 0
store float 0x0, float* %val8777
%val8778 = load float*, float** %pPtr
; set pointer
%val8779 = getelementptr float, float* %val8778, i64 1
store float 0x0, float* %val8779
%val8780 = load float*, float** %pPtr
; set pointer
%val8781 = getelementptr float, float* %val8780, i64 2
store float 0x4024000000000000, float* %val8781
%val8782 = load float*, float** %pPtr
; set pointer
%val8783 = getelementptr float, float* %val8782, i64 3
store float 0x3ff0000000000000, float* %val8783
%val8784 = load float*, float** %tPtr
; set pointer
%val8785 = getelementptr float, float* %val8784, i64 0
store float 0x0, float* %val8785
%val8786 = load float*, float** %tPtr
; set pointer
%val8787 = getelementptr float, float* %val8786, i64 1
store float 0x0, float* %val8787
%val8788 = load float*, float** %tPtr
; set pointer
%val8789 = getelementptr float, float* %val8788, i64 2
store float 0x0, float* %val8789
%val8790 = load float*, float** %tPtr
; set pointer
%val8791 = getelementptr float, float* %val8790, i64 3
store float 0x3ff0000000000000, float* %val8791
%val8792 = load float*, float** %uPtr
; set pointer
%val8793 = getelementptr float, float* %val8792, i64 0
store float 0x0, float* %val8793
%val8794 = load float*, float** %uPtr
; set pointer
%val8795 = getelementptr float, float* %val8794, i64 1
store float 0x3ff0000000000000, float* %val8795
%val8796 = load float*, float** %uPtr
; set pointer
%val8797 = getelementptr float, float* %val8796, i64 2
store float 0x0, float* %val8797
%val8798 = load float*, float** %uPtr
; set pointer
%val8799 = getelementptr float, float* %val8798, i64 3
store float 0x0, float* %val8799
%val8800 = load %xtm_camera*, %xtm_camera** %cameraPtr
%val8801 = load float*, float** %pPtr
; set tuple
%val8802 = getelementptr %xtm_camera, %xtm_camera* %val8800, i64 0, i32 0
store float* %val8801, float** %val8802
%val8803 = load %xtm_camera*, %xtm_camera** %cameraPtr
%val8804 = load float*, float** %tPtr
; set tuple
%val8805 = getelementptr %xtm_camera, %xtm_camera* %val8803, i64 0, i32 1
store float* %val8804, float** %val8805
%val8806 = load %xtm_camera*, %xtm_camera** %cameraPtr
%val8807 = load float*, float** %uPtr
; set tuple
%val8808 = getelementptr %xtm_camera, %xtm_camera* %val8806, i64 0, i32 2
store float* %val8807, float** %val8808
%tzone8855 = load i8*, i8** %_impzPtr
%zone8856 = bitcast i8* %tzone8855 to %mzone*

; let assign value to symbol _anon_lambda_8
%dat__anon_lambda_8 = call i8* @llvm_zone_malloc(%mzone* %zone8856, i64 8)
%_anon_lambda_8Ptr = bitcast i8* %dat__anon_lambda_8 to { i8*, i8*, %xtm_camera* (i8*, i8*)*}***
%tzone8811 = load i8*, i8** %_impzPtr
%zone8812 = bitcast i8* %tzone8811 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8812)
; malloc closure structure
%clsptr8813 = call i8* @llvm_zone_malloc(%mzone* %zone8812, i64 24)
%closure8814 = bitcast i8* %clsptr8813 to { i8*, i8*, %xtm_camera* (i8*, i8*)*}*

; malloc environment structure
%envptr8815 = call i8* @llvm_zone_malloc(%mzone* %zone8812, i64 48)
%environment8816 = bitcast i8* %envptr8815 to {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}*

; malloc closure address table
%addytable8817 = call %clsvar* @new_address_table()
%var8818 = bitcast [40 x i8]* @gsxtmgraphics-pipeline361 to i8*
%var8819 = bitcast [39 x i8]* @gsxtmgraphics-pipeline362 to i8*
%addytable8820 = call %clsvar* @add_address_table(%mzone* %zone8812, i8* %var8818, i32 0, i8* %var8819, i32 3, %clsvar* %addytable8817)
%var8821 = bitcast [2 x i8]* @gsxtmgraphics-pipeline363 to i8*
%var8822 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable8823 = call %clsvar* @add_address_table(%mzone* %zone8812, i8* %var8821, i32 8, i8* %var8822, i32 3, %clsvar* %addytable8820)
%var8824 = bitcast [2 x i8]* @gsxtmgraphics-pipeline364 to i8*
%var8825 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable8826 = call %clsvar* @add_address_table(%mzone* %zone8812, i8* %var8824, i32 16, i8* %var8825, i32 3, %clsvar* %addytable8823)
%var8827 = bitcast [2 x i8]* @gsxtmgraphics-pipeline365 to i8*
%var8828 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable8829 = call %clsvar* @add_address_table(%mzone* %zone8812, i8* %var8827, i32 24, i8* %var8828, i32 3, %clsvar* %addytable8826)
%var8830 = bitcast [7 x i8]* @gsxtmgraphics-pipeline366 to i8*
%var8831 = bitcast [13 x i8]* @gsxtmgraphics-pipeline367 to i8*
%addytable8832 = call %clsvar* @add_address_table(%mzone* %zone8812, i8* %var8830, i32 32, i8* %var8831, i32 3, %clsvar* %addytable8829)
%var8833 = bitcast [15 x i8]* @gsxtmgraphics-pipeline368 to i8*
%var8834 = bitcast [39 x i8]* @gsxtmgraphics-pipeline362 to i8*
%addytable8835 = call %clsvar* @add_address_table(%mzone* %zone8812, i8* %var8833, i32 40, i8* %var8834, i32 3, %clsvar* %addytable8832)
%address-table8836 = bitcast %clsvar* %addytable8835 to i8*

; insert table, function and environment into closure struct
%closure.table8849 = getelementptr { i8*, i8*, %xtm_camera* (i8*, i8*)*}, { i8*, i8*, %xtm_camera* (i8*, i8*)*}* %closure8814, i32 0, i32 0
store i8* %address-table8836, i8** %closure.table8849
%closure.env8850 = getelementptr { i8*, i8*, %xtm_camera* (i8*, i8*)*}, { i8*, i8*, %xtm_camera* (i8*, i8*)*}* %closure8814, i32 0, i32 1
store i8* %envptr8815, i8** %closure.env8850
%closure.func8851 = getelementptr { i8*, i8*, %xtm_camera* (i8*, i8*)*}, { i8*, i8*, %xtm_camera* (i8*, i8*)*}* %closure8814, i32 0, i32 2
store %xtm_camera* (i8*, i8*)* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ__8745, %xtm_camera* (i8*, i8*)** %closure.func8851
%closure_size8852 = call i64 @llvm_zone_mark_size(%mzone* %zone8812)
call void @llvm_zone_ptr_set_size(i8* %clsptr8813, i64 %closure_size8852)
%wrapper_ptr8853 = call i8* @llvm_zone_malloc(%mzone* %zone8812, i64 8)
%closure_wrapper8854 = bitcast i8* %wrapper_ptr8853 to { i8*, i8*, %xtm_camera* (i8*, i8*)*}**
store { i8*, i8*, %xtm_camera* (i8*, i8*)*}* %closure8814, { i8*, i8*, %xtm_camera* (i8*, i8*)*}** %closure_wrapper8854

; let value assignment
%_anon_lambda_8 = select i1 true, { i8*, i8*, %xtm_camera* (i8*, i8*)*}** %closure_wrapper8854, { i8*, i8*, %xtm_camera* (i8*, i8*)*}** %closure_wrapper8854
store { i8*, i8*, %xtm_camera* (i8*, i8*)*}** %_anon_lambda_8, { i8*, i8*, %xtm_camera* (i8*, i8*)*}*** %_anon_lambda_8Ptr

; add data to environment
; don't need to alloc for env var xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ
%tmp_envptr8838 = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}* %environment8816, i32 0, i32 0
store {i8*, i8*, %xtm_camera* (i8*, i8*)*}*** %xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQPtr, {i8*, i8*, %xtm_camera* (i8*, i8*)*}**** %tmp_envptr8838

; don't need to alloc for env var u
%tmp_envptr8840 = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}* %environment8816, i32 0, i32 1
store float** %uPtr, float*** %tmp_envptr8840

; don't need to alloc for env var t
%tmp_envptr8842 = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}* %environment8816, i32 0, i32 2
store float** %tPtr, float*** %tmp_envptr8842

; don't need to alloc for env var p
%tmp_envptr8844 = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}* %environment8816, i32 0, i32 3
store float** %pPtr, float*** %tmp_envptr8844

; don't need to alloc for env var camera
%tmp_envptr8846 = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}* %environment8816, i32 0, i32 4
store %xtm_camera** %cameraPtr, %xtm_camera*** %tmp_envptr8846

; don't need to alloc for env var _anon_lambda_8
%tmp_envptr8848 = getelementptr {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_camera* (i8*, i8*)*}***, float**, float**, float**, %xtm_camera**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}***}* %environment8816, i32 0, i32 5
store {i8*, i8*, %xtm_camera* (i8*, i8*)*}*** %_anon_lambda_8Ptr, {i8*, i8*, %xtm_camera* (i8*, i8*)*}**** %tmp_envptr8848


%val8857 = load {i8*, i8*, %xtm_camera* (i8*, i8*)*}**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}*** %_anon_lambda_8Ptr

; let value assignment
%xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ = select i1 true, {i8*, i8*, %xtm_camera* (i8*, i8*)*}** %val8857, {i8*, i8*, %xtm_camera* (i8*, i8*)*}** %val8857
store {i8*, i8*, %xtm_camera* (i8*, i8*)*}** %xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ, {i8*, i8*, %xtm_camera* (i8*, i8*)*}*** %xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQPtr

%val8860 = load {i8*, i8*, %xtm_camera* (i8*, i8*)*}**, {i8*, i8*, %xtm_camera* (i8*, i8*)*}*** %xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQPtr
ret {i8*, i8*, %xtm_camera* (i8*, i8*)*}** %val8860
}


@xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %xtm_camera* (i8*, i8*)*}** @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %xtm_camera* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %xtm_camera* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*)*,  %xtm_camera* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee)
ret %xtm_camera* %result
}


define dllexport ccc %xtm_camera* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*)*,  %xtm_camera* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee)
ret %xtm_camera* %result
}


define dllexport ccc i8*  @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*)*,  %xtm_camera* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast %xtm_camera* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_camera* (i8*, i8*)*}**
%closure = load {i8*, i8*, %xtm_camera* (i8*, i8*)*}*, {i8*, i8*, %xtm_camera* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_camera* (i8*, i8*)*}, {i8*, i8*, %xtm_camera* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_camera* (i8*, i8*)*,  %xtm_camera* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_camera* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline369 = hidden constant [54 x i8] c"xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd\00"
@gsxtmgraphics-pipeline370 = hidden constant [52 x i8] c"{i8*, i8*, void (i8*, i8*, float, float, float)*}**\00"
define dllexport fastcc void @xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd__8861(i8* %_impz,i8* %_impenv, float %x, float %y, float %z) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8862 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}*
%xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}* %impenv, i32 0, i32 0
%xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = load {i8*, i8*, void (i8*, i8*, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, float, float, float)*}**** %xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_

; setup arguments
%xPtr = alloca float
store float %x, float* %xPtr
%yPtr = alloca float
store float %y, float* %yPtr
%zPtr = alloca float
store float %z, float* %zPtr


%res8863 = call fastcc %xtm_camera* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ()
; tuple ref
%val8864 = getelementptr %xtm_camera, %xtm_camera* %res8863, i64 0, i32 0
%val8865 = load float*, float** %val8864
%val8866 = load float, float* %xPtr
; set pointer
%val8867 = getelementptr float, float* %val8865, i64 0
store float %val8866, float* %val8867
%res8868 = call fastcc %xtm_camera* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ()
; tuple ref
%val8869 = getelementptr %xtm_camera, %xtm_camera* %res8868, i64 0, i32 0
%val8870 = load float*, float** %val8869
%val8871 = load float, float* %yPtr
; set pointer
%val8872 = getelementptr float, float* %val8870, i64 1
store float %val8871, float* %val8872
%res8873 = call fastcc %xtm_camera* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ()
; tuple ref
%val8874 = getelementptr %xtm_camera, %xtm_camera* %res8873, i64 0, i32 0
%val8875 = load float*, float** %val8874
%val8876 = load float, float* %zPtr
; set pointer
%val8877 = getelementptr float, float* %val8875, i64 2
store float %val8876, float* %val8877
%res8878 = call fastcc %xtm_camera* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ()
; tuple ref
%val8879 = getelementptr %xtm_camera, %xtm_camera* %res8878, i64 0, i32 0
%val8880 = load float*, float** %val8879
; set pointer
%val8881 = getelementptr float, float* %val8880, i64 3
store float 0x3ff0000000000000, float* %val8881
ret void
}
@gsxtmgraphics-pipeline371 = hidden constant [107 x i8] c"xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float, float, float)*}** @xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8902 = load i8*, i8** %_impzPtr
%zone8903 = bitcast i8* %tzone8902 to %mzone*

; let assign value to symbol xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd
%dat_xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone8903, i64 8)
%xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = bitcast i8* %dat_xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd to { i8*, i8*, void (i8*, i8*, float, float, float)*}***
%tzone8883 = load i8*, i8** %_impzPtr
%zone8884 = bitcast i8* %tzone8883 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8884)
; malloc closure structure
%clsptr8885 = call i8* @llvm_zone_malloc(%mzone* %zone8884, i64 24)
%closure8886 = bitcast i8* %clsptr8885 to { i8*, i8*, void (i8*, i8*, float, float, float)*}*

; malloc environment structure
%envptr8887 = call i8* @llvm_zone_malloc(%mzone* %zone8884, i64 8)
%environment8888 = bitcast i8* %envptr8887 to {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}*

; malloc closure address table
%addytable8889 = call %clsvar* @new_address_table()
%var8890 = bitcast [54 x i8]* @gsxtmgraphics-pipeline369 to i8*
%var8891 = bitcast [52 x i8]* @gsxtmgraphics-pipeline370 to i8*
%addytable8892 = call %clsvar* @add_address_table(%mzone* %zone8884, i8* %var8890, i32 0, i8* %var8891, i32 3, %clsvar* %addytable8889)
%address-table8893 = bitcast %clsvar* %addytable8892 to i8*

; insert table, function and environment into closure struct
%closure.table8896 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure8886, i32 0, i32 0
store i8* %address-table8893, i8** %closure.table8896
%closure.env8897 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure8886, i32 0, i32 1
store i8* %envptr8887, i8** %closure.env8897
%closure.func8898 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure8886, i32 0, i32 2
store void (i8*, i8*, float, float, float)* @xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd__8861, void (i8*, i8*, float, float, float)** %closure.func8898
%closure_size8899 = call i64 @llvm_zone_mark_size(%mzone* %zone8884)
call void @llvm_zone_ptr_set_size(i8* %clsptr8885, i64 %closure_size8899)
%wrapper_ptr8900 = call i8* @llvm_zone_malloc(%mzone* %zone8884, i64 8)
%closure_wrapper8901 = bitcast i8* %wrapper_ptr8900 to { i8*, i8*, void (i8*, i8*, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure8886, { i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_wrapper8901

; let value assignment
%xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd = select i1 true, { i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_wrapper8901, { i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_wrapper8901
store { i8*, i8*, void (i8*, i8*, float, float, float)*}** %xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd, { i8*, i8*, void (i8*, i8*, float, float, float)*}*** %xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd
%tmp_envptr8895 = getelementptr {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}* %environment8888, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float, float, float)*}*** %xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr, {i8*, i8*, void (i8*, i8*, float, float, float)*}**** %tmp_envptr8895


%val8904 = load {i8*, i8*, void (i8*, i8*, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, float, float, float)*}*** %xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr
ret {i8*, i8*, void (i8*, i8*, float, float, float)*}** %val8904
}


@xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float, float, float)*}** @xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd(float %arg_0,float %arg_1,float %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float)*,  void (i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2)
ret void
}


define dllexport ccc void @xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_native(float %arg_0,float %arg_1,float %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float)*,  void (i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2)
ret void
}


define dllexport ccc i8*  @xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8905 = bitcast [107 x i8]* @gsxtmgraphics-pipeline371 to i8*
call i32 (i8*, ...) @printf(i8* %var8905)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var8906 = bitcast [107 x i8]* @gsxtmgraphics-pipeline371 to i8*
call i32 (i8*, ...) @printf(i8* %var8906)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var8907 = bitcast [107 x i8]* @gsxtmgraphics-pipeline371 to i8*
call i32 (i8*, ...) @printf(i8* %var8907)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float)*,  void (i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float, float}*
%arg_p_0 = getelementptr {float, float, float}, {float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float, float}, {float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float, float, float}, {float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_pos_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float)*,  void (i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline372 = hidden constant [54 x i8] c"xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd\00"
define dllexport fastcc void @xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd__8908(i8* %_impz,i8* %_impenv, float %x, float %y, float %z) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8909 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}*
%xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}* %impenv, i32 0, i32 0
%xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = load {i8*, i8*, void (i8*, i8*, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, float, float, float)*}**** %xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_

; setup arguments
%xPtr = alloca float
store float %x, float* %xPtr
%yPtr = alloca float
store float %y, float* %yPtr
%zPtr = alloca float
store float %z, float* %zPtr


%res8910 = call fastcc %xtm_camera* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ()
; tuple ref
%val8911 = getelementptr %xtm_camera, %xtm_camera* %res8910, i64 0, i32 1
%val8912 = load float*, float** %val8911
%val8913 = load float, float* %xPtr
; set pointer
%val8914 = getelementptr float, float* %val8912, i64 0
store float %val8913, float* %val8914
%res8915 = call fastcc %xtm_camera* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ()
; tuple ref
%val8916 = getelementptr %xtm_camera, %xtm_camera* %res8915, i64 0, i32 1
%val8917 = load float*, float** %val8916
%val8918 = load float, float* %yPtr
; set pointer
%val8919 = getelementptr float, float* %val8917, i64 1
store float %val8918, float* %val8919
%res8920 = call fastcc %xtm_camera* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ()
; tuple ref
%val8921 = getelementptr %xtm_camera, %xtm_camera* %res8920, i64 0, i32 1
%val8922 = load float*, float** %val8921
%val8923 = load float, float* %zPtr
; set pointer
%val8924 = getelementptr float, float* %val8922, i64 2
store float %val8923, float* %val8924
%res8925 = call fastcc %xtm_camera* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ()
; tuple ref
%val8926 = getelementptr %xtm_camera, %xtm_camera* %res8925, i64 0, i32 1
%val8927 = load float*, float** %val8926
; set pointer
%val8928 = getelementptr float, float* %val8927, i64 3
store float 0x3ff0000000000000, float* %val8928
ret void
}
@gsxtmgraphics-pipeline373 = hidden constant [107 x i8] c"xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float, float, float)*}** @xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8949 = load i8*, i8** %_impzPtr
%zone8950 = bitcast i8* %tzone8949 to %mzone*

; let assign value to symbol xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd
%dat_xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone8950, i64 8)
%xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = bitcast i8* %dat_xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd to { i8*, i8*, void (i8*, i8*, float, float, float)*}***
%tzone8930 = load i8*, i8** %_impzPtr
%zone8931 = bitcast i8* %tzone8930 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8931)
; malloc closure structure
%clsptr8932 = call i8* @llvm_zone_malloc(%mzone* %zone8931, i64 24)
%closure8933 = bitcast i8* %clsptr8932 to { i8*, i8*, void (i8*, i8*, float, float, float)*}*

; malloc environment structure
%envptr8934 = call i8* @llvm_zone_malloc(%mzone* %zone8931, i64 8)
%environment8935 = bitcast i8* %envptr8934 to {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}*

; malloc closure address table
%addytable8936 = call %clsvar* @new_address_table()
%var8937 = bitcast [54 x i8]* @gsxtmgraphics-pipeline372 to i8*
%var8938 = bitcast [52 x i8]* @gsxtmgraphics-pipeline370 to i8*
%addytable8939 = call %clsvar* @add_address_table(%mzone* %zone8931, i8* %var8937, i32 0, i8* %var8938, i32 3, %clsvar* %addytable8936)
%address-table8940 = bitcast %clsvar* %addytable8939 to i8*

; insert table, function and environment into closure struct
%closure.table8943 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure8933, i32 0, i32 0
store i8* %address-table8940, i8** %closure.table8943
%closure.env8944 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure8933, i32 0, i32 1
store i8* %envptr8934, i8** %closure.env8944
%closure.func8945 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure8933, i32 0, i32 2
store void (i8*, i8*, float, float, float)* @xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd__8908, void (i8*, i8*, float, float, float)** %closure.func8945
%closure_size8946 = call i64 @llvm_zone_mark_size(%mzone* %zone8931)
call void @llvm_zone_ptr_set_size(i8* %clsptr8932, i64 %closure_size8946)
%wrapper_ptr8947 = call i8* @llvm_zone_malloc(%mzone* %zone8931, i64 8)
%closure_wrapper8948 = bitcast i8* %wrapper_ptr8947 to { i8*, i8*, void (i8*, i8*, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure8933, { i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_wrapper8948

; let value assignment
%xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd = select i1 true, { i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_wrapper8948, { i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_wrapper8948
store { i8*, i8*, void (i8*, i8*, float, float, float)*}** %xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd, { i8*, i8*, void (i8*, i8*, float, float, float)*}*** %xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd
%tmp_envptr8942 = getelementptr {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}* %environment8935, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float, float, float)*}*** %xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr, {i8*, i8*, void (i8*, i8*, float, float, float)*}**** %tmp_envptr8942


%val8951 = load {i8*, i8*, void (i8*, i8*, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, float, float, float)*}*** %xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr
ret {i8*, i8*, void (i8*, i8*, float, float, float)*}** %val8951
}


@xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float, float, float)*}** @xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd(float %arg_0,float %arg_1,float %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float)*,  void (i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2)
ret void
}


define dllexport ccc void @xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_native(float %arg_0,float %arg_1,float %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float)*,  void (i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2)
ret void
}


define dllexport ccc i8*  @xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8952 = bitcast [107 x i8]* @gsxtmgraphics-pipeline373 to i8*
call i32 (i8*, ...) @printf(i8* %var8952)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var8953 = bitcast [107 x i8]* @gsxtmgraphics-pipeline373 to i8*
call i32 (i8*, ...) @printf(i8* %var8953)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var8954 = bitcast [107 x i8]* @gsxtmgraphics-pipeline373 to i8*
call i32 (i8*, ...) @printf(i8* %var8954)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float)*,  void (i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float, float}*
%arg_p_0 = getelementptr {float, float, float}, {float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float, float}, {float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float, float, float}, {float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_tgt_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float)*,  void (i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline374 = hidden constant [53 x i8] c"xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd\00"
define dllexport fastcc void @xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd__8955(i8* %_impz,i8* %_impenv, float %x, float %y, float %z) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone8956 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}*
%xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}* %impenv, i32 0, i32 0
%xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = load {i8*, i8*, void (i8*, i8*, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, float, float, float)*}**** %xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_

; setup arguments
%xPtr = alloca float
store float %x, float* %xPtr
%yPtr = alloca float
store float %y, float* %yPtr
%zPtr = alloca float
store float %z, float* %zPtr


%res8957 = call fastcc %xtm_camera* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ()
; tuple ref
%val8958 = getelementptr %xtm_camera, %xtm_camera* %res8957, i64 0, i32 2
%val8959 = load float*, float** %val8958
%val8960 = load float, float* %xPtr
; set pointer
%val8961 = getelementptr float, float* %val8959, i64 0
store float %val8960, float* %val8961
%res8962 = call fastcc %xtm_camera* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ()
; tuple ref
%val8963 = getelementptr %xtm_camera, %xtm_camera* %res8962, i64 0, i32 2
%val8964 = load float*, float** %val8963
%val8965 = load float, float* %yPtr
; set pointer
%val8966 = getelementptr float, float* %val8964, i64 1
store float %val8965, float* %val8966
%res8967 = call fastcc %xtm_camera* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ()
; tuple ref
%val8968 = getelementptr %xtm_camera, %xtm_camera* %res8967, i64 0, i32 2
%val8969 = load float*, float** %val8968
%val8970 = load float, float* %zPtr
; set pointer
%val8971 = getelementptr float, float* %val8969, i64 2
store float %val8970, float* %val8971
%res8972 = call fastcc %xtm_camera* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ()
; tuple ref
%val8973 = getelementptr %xtm_camera, %xtm_camera* %res8972, i64 0, i32 2
%val8974 = load float*, float** %val8973
; set pointer
%val8975 = getelementptr float, float* %val8974, i64 3
store float 0x0, float* %val8975
ret void
}
@gsxtmgraphics-pipeline375 = hidden constant [106 x i8] c"xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float, float, float)*}** @xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone8996 = load i8*, i8** %_impzPtr
%zone8997 = bitcast i8* %tzone8996 to %mzone*

; let assign value to symbol xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd
%dat_xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone8997, i64 8)
%xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = bitcast i8* %dat_xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd to { i8*, i8*, void (i8*, i8*, float, float, float)*}***
%tzone8977 = load i8*, i8** %_impzPtr
%zone8978 = bitcast i8* %tzone8977 to %mzone*
call void @llvm_zone_mark(%mzone* %zone8978)
; malloc closure structure
%clsptr8979 = call i8* @llvm_zone_malloc(%mzone* %zone8978, i64 24)
%closure8980 = bitcast i8* %clsptr8979 to { i8*, i8*, void (i8*, i8*, float, float, float)*}*

; malloc environment structure
%envptr8981 = call i8* @llvm_zone_malloc(%mzone* %zone8978, i64 8)
%environment8982 = bitcast i8* %envptr8981 to {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}*

; malloc closure address table
%addytable8983 = call %clsvar* @new_address_table()
%var8984 = bitcast [53 x i8]* @gsxtmgraphics-pipeline374 to i8*
%var8985 = bitcast [52 x i8]* @gsxtmgraphics-pipeline370 to i8*
%addytable8986 = call %clsvar* @add_address_table(%mzone* %zone8978, i8* %var8984, i32 0, i8* %var8985, i32 3, %clsvar* %addytable8983)
%address-table8987 = bitcast %clsvar* %addytable8986 to i8*

; insert table, function and environment into closure struct
%closure.table8990 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure8980, i32 0, i32 0
store i8* %address-table8987, i8** %closure.table8990
%closure.env8991 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure8980, i32 0, i32 1
store i8* %envptr8981, i8** %closure.env8991
%closure.func8992 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure8980, i32 0, i32 2
store void (i8*, i8*, float, float, float)* @xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd__8955, void (i8*, i8*, float, float, float)** %closure.func8992
%closure_size8993 = call i64 @llvm_zone_mark_size(%mzone* %zone8978)
call void @llvm_zone_ptr_set_size(i8* %clsptr8979, i64 %closure_size8993)
%wrapper_ptr8994 = call i8* @llvm_zone_malloc(%mzone* %zone8978, i64 8)
%closure_wrapper8995 = bitcast i8* %wrapper_ptr8994 to { i8*, i8*, void (i8*, i8*, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure8980, { i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_wrapper8995

; let value assignment
%xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd = select i1 true, { i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_wrapper8995, { i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_wrapper8995
store { i8*, i8*, void (i8*, i8*, float, float, float)*}** %xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd, { i8*, i8*, void (i8*, i8*, float, float, float)*}*** %xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd
%tmp_envptr8989 = getelementptr {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}* %environment8982, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float, float, float)*}*** %xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr, {i8*, i8*, void (i8*, i8*, float, float, float)*}**** %tmp_envptr8989


%val8998 = load {i8*, i8*, void (i8*, i8*, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, float, float, float)*}*** %xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr
ret {i8*, i8*, void (i8*, i8*, float, float, float)*}** %val8998
}


@xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float, float, float)*}** @xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd(float %arg_0,float %arg_1,float %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float)*,  void (i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2)
ret void
}


define dllexport ccc void @xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_native(float %arg_0,float %arg_1,float %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float)*,  void (i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2)
ret void
}


define dllexport ccc i8*  @xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var8999 = bitcast [106 x i8]* @gsxtmgraphics-pipeline375 to i8*
call i32 (i8*, ...) @printf(i8* %var8999)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var9000 = bitcast [106 x i8]* @gsxtmgraphics-pipeline375 to i8*
call i32 (i8*, ...) @printf(i8* %var9000)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var9001 = bitcast [106 x i8]* @gsxtmgraphics-pipeline375 to i8*
call i32 (i8*, ...) @printf(i8* %var9001)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float)*,  void (i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float, float}*
%arg_p_0 = getelementptr {float, float, float}, {float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float, float}, {float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float, float, float}, {float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_up_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float)*,  void (i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline376 = hidden constant [41 x i8] c"xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ\00"
@gsxtmgraphics-pipeline377 = hidden constant [15 x i8] c"_anon_lambda_9\00"
define dllexport fastcc void @xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ__9002(i8* %_impz,i8* %_impenv, float* %view) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9006 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*)*}***, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}*
%xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*)*}***, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*)*}***, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQPtr = load {i8*, i8*, void (i8*, i8*, float*)*}***, {i8*, i8*, void (i8*, i8*, float*)*}**** %xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQPtr_
%cameraPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*)*}***, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*)*}***, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}* %impenv, i32 0, i32 1
%cameraPtr = load %xtm_camera**, %xtm_camera*** %cameraPtr_
%_anon_lambda_9Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*)*}***, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*)*}***, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_9Ptr = load {i8*, i8*, void (i8*, i8*, float*)*}***, {i8*, i8*, void (i8*, i8*, float*)*}**** %_anon_lambda_9Ptr_

; setup arguments
%viewPtr = alloca float*
store float* %view, float** %viewPtr


; do set!
%res9007 = call fastcc %xtm_camera* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ()
store %xtm_camera* %res9007, %xtm_camera** %cameraPtr
%val9008 = load float*, float** %viewPtr
%val9009 = load %xtm_camera*, %xtm_camera** %cameraPtr
; tuple ref
%val9010 = getelementptr %xtm_camera, %xtm_camera* %val9009, i64 0, i32 0
%val9011 = load float*, float** %val9010
%val9012 = load %xtm_camera*, %xtm_camera** %cameraPtr
; tuple ref
%val9013 = getelementptr %xtm_camera, %xtm_camera* %val9012, i64 0, i32 1
%val9014 = load float*, float** %val9013
%val9015 = load %xtm_camera*, %xtm_camera** %cameraPtr
; tuple ref
%val9016 = getelementptr %xtm_camera, %xtm_camera* %val9015, i64 0, i32 2
%val9017 = load float*, float** %val9016
call fastcc void @fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ(float* %val9008, float* %val9011, float* %val9014, float* %val9017)
ret void
}
@gsxtmgraphics-pipeline378 = hidden constant [94 x i8] c"xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*)*}** @xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9052 = load i8*, i8** %_impzPtr
%zone9053 = bitcast i8* %tzone9052 to %mzone*

; let assign value to symbol xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ
%dat_xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone9053, i64 8)
%xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQPtr = bitcast i8* %dat_xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ to {i8*, i8*, void (i8*, i8*, float*)*}***
%tzone9004 = load i8*, i8** %_impzPtr
%zone9005 = bitcast i8* %tzone9004 to %mzone*

; let assign value to symbol camera
%dat_camera = call i8* @llvm_zone_malloc(%mzone* %zone9005, i64 8)
%cameraPtr = bitcast i8* %dat_camera to %xtm_camera**
%null9003 = bitcast i8* null to %xtm_camera*

; let value assignment
%camera = select i1 true, %xtm_camera* %null9003, %xtm_camera* %null9003
store %xtm_camera* %camera, %xtm_camera** %cameraPtr

%tzone9049 = load i8*, i8** %_impzPtr
%zone9050 = bitcast i8* %tzone9049 to %mzone*

; let assign value to symbol _anon_lambda_9
%dat__anon_lambda_9 = call i8* @llvm_zone_malloc(%mzone* %zone9050, i64 8)
%_anon_lambda_9Ptr = bitcast i8* %dat__anon_lambda_9 to { i8*, i8*, void (i8*, i8*, float*)*}***
%tzone9020 = load i8*, i8** %_impzPtr
%zone9021 = bitcast i8* %tzone9020 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9021)
; malloc closure structure
%clsptr9022 = call i8* @llvm_zone_malloc(%mzone* %zone9021, i64 24)
%closure9023 = bitcast i8* %clsptr9022 to { i8*, i8*, void (i8*, i8*, float*)*}*

; malloc environment structure
%envptr9024 = call i8* @llvm_zone_malloc(%mzone* %zone9021, i64 24)
%environment9025 = bitcast i8* %envptr9024 to {{i8*, i8*, void (i8*, i8*, float*)*}***, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}*

; malloc closure address table
%addytable9026 = call %clsvar* @new_address_table()
%var9027 = bitcast [41 x i8]* @gsxtmgraphics-pipeline376 to i8*
%var9028 = bitcast [39 x i8]* @gsxtmgraphics-pipeline12 to i8*
%addytable9029 = call %clsvar* @add_address_table(%mzone* %zone9021, i8* %var9027, i32 0, i8* %var9028, i32 3, %clsvar* %addytable9026)
%var9030 = bitcast [7 x i8]* @gsxtmgraphics-pipeline366 to i8*
%var9031 = bitcast [13 x i8]* @gsxtmgraphics-pipeline367 to i8*
%addytable9032 = call %clsvar* @add_address_table(%mzone* %zone9021, i8* %var9030, i32 8, i8* %var9031, i32 3, %clsvar* %addytable9029)
%var9033 = bitcast [15 x i8]* @gsxtmgraphics-pipeline377 to i8*
%var9034 = bitcast [39 x i8]* @gsxtmgraphics-pipeline12 to i8*
%addytable9035 = call %clsvar* @add_address_table(%mzone* %zone9021, i8* %var9033, i32 16, i8* %var9034, i32 3, %clsvar* %addytable9032)
%address-table9036 = bitcast %clsvar* %addytable9035 to i8*

; insert table, function and environment into closure struct
%closure.table9043 = getelementptr { i8*, i8*, void (i8*, i8*, float*)*}, { i8*, i8*, void (i8*, i8*, float*)*}* %closure9023, i32 0, i32 0
store i8* %address-table9036, i8** %closure.table9043
%closure.env9044 = getelementptr { i8*, i8*, void (i8*, i8*, float*)*}, { i8*, i8*, void (i8*, i8*, float*)*}* %closure9023, i32 0, i32 1
store i8* %envptr9024, i8** %closure.env9044
%closure.func9045 = getelementptr { i8*, i8*, void (i8*, i8*, float*)*}, { i8*, i8*, void (i8*, i8*, float*)*}* %closure9023, i32 0, i32 2
store void (i8*, i8*, float*)* @xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ__9002, void (i8*, i8*, float*)** %closure.func9045
%closure_size9046 = call i64 @llvm_zone_mark_size(%mzone* %zone9021)
call void @llvm_zone_ptr_set_size(i8* %clsptr9022, i64 %closure_size9046)
%wrapper_ptr9047 = call i8* @llvm_zone_malloc(%mzone* %zone9021, i64 8)
%closure_wrapper9048 = bitcast i8* %wrapper_ptr9047 to { i8*, i8*, void (i8*, i8*, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*)*}* %closure9023, { i8*, i8*, void (i8*, i8*, float*)*}** %closure_wrapper9048

; let value assignment
%_anon_lambda_9 = select i1 true, { i8*, i8*, void (i8*, i8*, float*)*}** %closure_wrapper9048, { i8*, i8*, void (i8*, i8*, float*)*}** %closure_wrapper9048
store { i8*, i8*, void (i8*, i8*, float*)*}** %_anon_lambda_9, { i8*, i8*, void (i8*, i8*, float*)*}*** %_anon_lambda_9Ptr

; add data to environment
; don't need to alloc for env var xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ
%tmp_envptr9038 = getelementptr {{i8*, i8*, void (i8*, i8*, float*)*}***, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*)*}***, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}* %environment9025, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*)*}*** %xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQPtr, {i8*, i8*, void (i8*, i8*, float*)*}**** %tmp_envptr9038

; don't need to alloc for env var camera
%tmp_envptr9040 = getelementptr {{i8*, i8*, void (i8*, i8*, float*)*}***, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*)*}***, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}* %environment9025, i32 0, i32 1
store %xtm_camera** %cameraPtr, %xtm_camera*** %tmp_envptr9040

; don't need to alloc for env var _anon_lambda_9
%tmp_envptr9042 = getelementptr {{i8*, i8*, void (i8*, i8*, float*)*}***, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*)*}***, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}* %environment9025, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, float*)*}*** %_anon_lambda_9Ptr, {i8*, i8*, void (i8*, i8*, float*)*}**** %tmp_envptr9042


%val9051 = load {i8*, i8*, void (i8*, i8*, float*)*}**, {i8*, i8*, void (i8*, i8*, float*)*}*** %_anon_lambda_9Ptr

; let value assignment
%xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ = select i1 true, {i8*, i8*, void (i8*, i8*, float*)*}** %val9051, {i8*, i8*, void (i8*, i8*, float*)*}** %val9051
store {i8*, i8*, void (i8*, i8*, float*)*}** %xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ, {i8*, i8*, void (i8*, i8*, float*)*}*** %xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQPtr

%val9054 = load {i8*, i8*, void (i8*, i8*, float*)*}**, {i8*, i8*, void (i8*, i8*, float*)*}*** %xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQPtr
ret {i8*, i8*, void (i8*, i8*, float*)*}** %val9054
}


@xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*)*}** @xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*)*,  void (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0)
ret void
}


define dllexport ccc void @xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ_native(float* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*)*,  void (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0)
ret void
}


define dllexport ccc i8*  @xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var9055 = bitcast [94 x i8]* @gsxtmgraphics-pipeline378 to i8*
call i32 (i8*, ...) @printf(i8* %var9055)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*)*,  void (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*}*
%arg_p_0 = getelementptr {float*}, {float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*)*,  void (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline379 = hidden constant [49 x i8] c"xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ\00"
@gsxtmgraphics-pipeline380 = hidden constant [7 x i8] c"centre\00"
@gsxtmgraphics-pipeline381 = hidden constant [16 x i8] c"_anon_lambda_10\00"
define dllexport fastcc void @xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ__9056(i8* %_impz,i8* %_impenv, float* %view) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9074 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*)*}***, float**, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}*
%xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*)*}***, float**, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*)*}***, float**, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQPtr = load {i8*, i8*, void (i8*, i8*, float*)*}***, {i8*, i8*, void (i8*, i8*, float*)*}**** %xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQPtr_
%centrePtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*)*}***, float**, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*)*}***, float**, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}* %impenv, i32 0, i32 1
%centrePtr = load float**, float*** %centrePtr_
%cameraPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*)*}***, float**, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*)*}***, float**, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}* %impenv, i32 0, i32 2
%cameraPtr = load %xtm_camera**, %xtm_camera*** %cameraPtr_
%_anon_lambda_10Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*)*}***, float**, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*)*}***, float**, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}* %impenv, i32 0, i32 3
%_anon_lambda_10Ptr = load {i8*, i8*, void (i8*, i8*, float*)*}***, {i8*, i8*, void (i8*, i8*, float*)*}**** %_anon_lambda_10Ptr_

; setup arguments
%viewPtr = alloca float*
store float* %view, float** %viewPtr


; do set!
%res9075 = call fastcc %xtm_camera* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ()
store %xtm_camera* %res9075, %xtm_camera** %cameraPtr
%val9076 = load float*, float** %viewPtr
%val9077 = load float*, float** %centrePtr
%val9078 = load %xtm_camera*, %xtm_camera** %cameraPtr
; tuple ref
%val9079 = getelementptr %xtm_camera, %xtm_camera* %val9078, i64 0, i32 1
%val9080 = load float*, float** %val9079
%val9081 = load %xtm_camera*, %xtm_camera** %cameraPtr
; tuple ref
%val9082 = getelementptr %xtm_camera, %xtm_camera* %val9081, i64 0, i32 2
%val9083 = load float*, float** %val9082
call fastcc void @fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ(float* %val9076, float* %val9077, float* %val9080, float* %val9083)
ret void
}
@gsxtmgraphics-pipeline382 = hidden constant [102 x i8] c"xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*)*}** @xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9123 = load i8*, i8** %_impzPtr
%zone9124 = bitcast i8* %tzone9123 to %mzone*

; let assign value to symbol xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ
%dat_xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone9124, i64 8)
%xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQPtr = bitcast i8* %dat_xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ to {i8*, i8*, void (i8*, i8*, float*)*}***
%tzone9058 = load i8*, i8** %_impzPtr
%zone9059 = bitcast i8* %tzone9058 to %mzone*

; let assign value to symbol camera
%dat_camera = call i8* @llvm_zone_malloc(%mzone* %zone9059, i64 8)
%cameraPtr = bitcast i8* %dat_camera to %xtm_camera**
%tzone9066 = load i8*, i8** %_impzPtr
%zone9067 = bitcast i8* %tzone9066 to %mzone*

; let assign value to symbol centre
%dat_centre = call i8* @llvm_zone_malloc(%mzone* %zone9067, i64 8)
%centrePtr = bitcast i8* %dat_centre to float**
%null9057 = bitcast i8* null to %xtm_camera*

; let value assignment
%camera = select i1 true, %xtm_camera* %null9057, %xtm_camera* %null9057
store %xtm_camera* %camera, %xtm_camera** %cameraPtr

%val9060 = getelementptr i64, i64* null, i32 1
%zonesize9061 = mul i64 4, 3
%tzone9062 = load i8*, i8** %_impzPtr
%zone9063 = bitcast i8* %tzone9062 to %mzone*
%dat9064 = call i8* @llvm_zone_malloc(%mzone* %zone9063, i64 %zonesize9061)
call i8* @memset(i8* %dat9064, i32 0, i64 %zonesize9061)
%val9065 = bitcast i8* %dat9064 to float*

; let value assignment
%centre = select i1 true, float* %val9065, float* %val9065
store float* %centre, float** %centrePtr

%val9068 = load float*, float** %centrePtr
; set pointer
%val9069 = getelementptr float, float* %val9068, i64 0
store float 0x0, float* %val9069
%val9070 = load float*, float** %centrePtr
; set pointer
%val9071 = getelementptr float, float* %val9070, i64 1
store float 0x0, float* %val9071
%val9072 = load float*, float** %centrePtr
; set pointer
%val9073 = getelementptr float, float* %val9072, i64 2
store float 0x0, float* %val9073
%tzone9120 = load i8*, i8** %_impzPtr
%zone9121 = bitcast i8* %tzone9120 to %mzone*

; let assign value to symbol _anon_lambda_10
%dat__anon_lambda_10 = call i8* @llvm_zone_malloc(%mzone* %zone9121, i64 8)
%_anon_lambda_10Ptr = bitcast i8* %dat__anon_lambda_10 to { i8*, i8*, void (i8*, i8*, float*)*}***
%tzone9086 = load i8*, i8** %_impzPtr
%zone9087 = bitcast i8* %tzone9086 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9087)
; malloc closure structure
%clsptr9088 = call i8* @llvm_zone_malloc(%mzone* %zone9087, i64 24)
%closure9089 = bitcast i8* %clsptr9088 to { i8*, i8*, void (i8*, i8*, float*)*}*

; malloc environment structure
%envptr9090 = call i8* @llvm_zone_malloc(%mzone* %zone9087, i64 32)
%environment9091 = bitcast i8* %envptr9090 to {{i8*, i8*, void (i8*, i8*, float*)*}***, float**, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}*

; malloc closure address table
%addytable9092 = call %clsvar* @new_address_table()
%var9093 = bitcast [49 x i8]* @gsxtmgraphics-pipeline379 to i8*
%var9094 = bitcast [39 x i8]* @gsxtmgraphics-pipeline12 to i8*
%addytable9095 = call %clsvar* @add_address_table(%mzone* %zone9087, i8* %var9093, i32 0, i8* %var9094, i32 3, %clsvar* %addytable9092)
%var9096 = bitcast [7 x i8]* @gsxtmgraphics-pipeline380 to i8*
%var9097 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable9098 = call %clsvar* @add_address_table(%mzone* %zone9087, i8* %var9096, i32 8, i8* %var9097, i32 3, %clsvar* %addytable9095)
%var9099 = bitcast [7 x i8]* @gsxtmgraphics-pipeline366 to i8*
%var9100 = bitcast [13 x i8]* @gsxtmgraphics-pipeline367 to i8*
%addytable9101 = call %clsvar* @add_address_table(%mzone* %zone9087, i8* %var9099, i32 16, i8* %var9100, i32 3, %clsvar* %addytable9098)
%var9102 = bitcast [16 x i8]* @gsxtmgraphics-pipeline381 to i8*
%var9103 = bitcast [39 x i8]* @gsxtmgraphics-pipeline12 to i8*
%addytable9104 = call %clsvar* @add_address_table(%mzone* %zone9087, i8* %var9102, i32 24, i8* %var9103, i32 3, %clsvar* %addytable9101)
%address-table9105 = bitcast %clsvar* %addytable9104 to i8*

; insert table, function and environment into closure struct
%closure.table9114 = getelementptr { i8*, i8*, void (i8*, i8*, float*)*}, { i8*, i8*, void (i8*, i8*, float*)*}* %closure9089, i32 0, i32 0
store i8* %address-table9105, i8** %closure.table9114
%closure.env9115 = getelementptr { i8*, i8*, void (i8*, i8*, float*)*}, { i8*, i8*, void (i8*, i8*, float*)*}* %closure9089, i32 0, i32 1
store i8* %envptr9090, i8** %closure.env9115
%closure.func9116 = getelementptr { i8*, i8*, void (i8*, i8*, float*)*}, { i8*, i8*, void (i8*, i8*, float*)*}* %closure9089, i32 0, i32 2
store void (i8*, i8*, float*)* @xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ__9056, void (i8*, i8*, float*)** %closure.func9116
%closure_size9117 = call i64 @llvm_zone_mark_size(%mzone* %zone9087)
call void @llvm_zone_ptr_set_size(i8* %clsptr9088, i64 %closure_size9117)
%wrapper_ptr9118 = call i8* @llvm_zone_malloc(%mzone* %zone9087, i64 8)
%closure_wrapper9119 = bitcast i8* %wrapper_ptr9118 to { i8*, i8*, void (i8*, i8*, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*)*}* %closure9089, { i8*, i8*, void (i8*, i8*, float*)*}** %closure_wrapper9119

; let value assignment
%_anon_lambda_10 = select i1 true, { i8*, i8*, void (i8*, i8*, float*)*}** %closure_wrapper9119, { i8*, i8*, void (i8*, i8*, float*)*}** %closure_wrapper9119
store { i8*, i8*, void (i8*, i8*, float*)*}** %_anon_lambda_10, { i8*, i8*, void (i8*, i8*, float*)*}*** %_anon_lambda_10Ptr

; add data to environment
; don't need to alloc for env var xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ
%tmp_envptr9107 = getelementptr {{i8*, i8*, void (i8*, i8*, float*)*}***, float**, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*)*}***, float**, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}* %environment9091, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*)*}*** %xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQPtr, {i8*, i8*, void (i8*, i8*, float*)*}**** %tmp_envptr9107

; don't need to alloc for env var centre
%tmp_envptr9109 = getelementptr {{i8*, i8*, void (i8*, i8*, float*)*}***, float**, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*)*}***, float**, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}* %environment9091, i32 0, i32 1
store float** %centrePtr, float*** %tmp_envptr9109

; don't need to alloc for env var camera
%tmp_envptr9111 = getelementptr {{i8*, i8*, void (i8*, i8*, float*)*}***, float**, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*)*}***, float**, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}* %environment9091, i32 0, i32 2
store %xtm_camera** %cameraPtr, %xtm_camera*** %tmp_envptr9111

; don't need to alloc for env var _anon_lambda_10
%tmp_envptr9113 = getelementptr {{i8*, i8*, void (i8*, i8*, float*)*}***, float**, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*)*}***, float**, %xtm_camera**, {i8*, i8*, void (i8*, i8*, float*)*}***}* %environment9091, i32 0, i32 3
store {i8*, i8*, void (i8*, i8*, float*)*}*** %_anon_lambda_10Ptr, {i8*, i8*, void (i8*, i8*, float*)*}**** %tmp_envptr9113


%val9122 = load {i8*, i8*, void (i8*, i8*, float*)*}**, {i8*, i8*, void (i8*, i8*, float*)*}*** %_anon_lambda_10Ptr

; let value assignment
%xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ = select i1 true, {i8*, i8*, void (i8*, i8*, float*)*}** %val9122, {i8*, i8*, void (i8*, i8*, float*)*}** %val9122
store {i8*, i8*, void (i8*, i8*, float*)*}** %xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ, {i8*, i8*, void (i8*, i8*, float*)*}*** %xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQPtr

%val9125 = load {i8*, i8*, void (i8*, i8*, float*)*}**, {i8*, i8*, void (i8*, i8*, float*)*}*** %xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQPtr
ret {i8*, i8*, void (i8*, i8*, float*)*}** %val9125
}


@xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*)*}** @xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*)*,  void (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0)
ret void
}


define dllexport ccc void @xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ_native(float* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*)*,  void (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0)
ret void
}


define dllexport ccc i8*  @xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var9126 = bitcast [102 x i8]* @gsxtmgraphics-pipeline382 to i8*
call i32 (i8*, ...) @printf(i8* %var9126)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*)*,  void (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*}*
%arg_p_0 = getelementptr {float*}, {float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_camera_view_centred_adhoc_W3ZvaWQsZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*)*}, {i8*, i8*, void (i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*)*,  void (i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline383 = hidden constant [53 x i8] c"xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd\00"
define dllexport fastcc void @xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd__9127(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9128 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}*
%xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}* %impenv, i32 0, i32 0
%xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**** %xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr


%val9129 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res9130 = call fastcc %xtm_camera* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ()
; tuple ref
%val9131 = getelementptr %xtm_camera, %xtm_camera* %res9130, i64 0, i32 0
%val9132 = load float*, float** %val9131
%res9133 = call fastcc %xtm_camera* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ()
; tuple ref
%val9134 = getelementptr %xtm_camera, %xtm_camera* %res9133, i64 0, i32 1
%val9135 = load float*, float** %val9134
call fastcc void @shader_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0Kl0(%ShaderProgram* %val9129, float* %val9132, float* %val9135)
ret void
}
@gsxtmgraphics-pipeline384 = hidden constant [106 x i8] c"xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** @xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9157 = load i8*, i8** %_impzPtr
%zone9158 = bitcast i8* %tzone9157 to %mzone*

; let assign value to symbol xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd
%dat_xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd = call i8* @llvm_zone_malloc(%mzone* %zone9158, i64 8)
%xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr = bitcast i8* %dat_xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd to { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***
%tzone9138 = load i8*, i8** %_impzPtr
%zone9139 = bitcast i8* %tzone9138 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9139)
; malloc closure structure
%clsptr9140 = call i8* @llvm_zone_malloc(%mzone* %zone9139, i64 24)
%closure9141 = bitcast i8* %clsptr9140 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*

; malloc environment structure
%envptr9142 = call i8* @llvm_zone_malloc(%mzone* %zone9139, i64 8)
%environment9143 = bitcast i8* %envptr9142 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}*

; malloc closure address table
%addytable9144 = call %clsvar* @new_address_table()
%var9145 = bitcast [53 x i8]* @gsxtmgraphics-pipeline383 to i8*
%var9146 = bitcast [48 x i8]* @gsxtmgraphics-pipeline327 to i8*
%addytable9147 = call %clsvar* @add_address_table(%mzone* %zone9139, i8* %var9145, i32 0, i8* %var9146, i32 3, %clsvar* %addytable9144)
%address-table9148 = bitcast %clsvar* %addytable9147 to i8*

; insert table, function and environment into closure struct
%closure.table9151 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure9141, i32 0, i32 0
store i8* %address-table9148, i8** %closure.table9151
%closure.env9152 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure9141, i32 0, i32 1
store i8* %envptr9142, i8** %closure.env9152
%closure.func9153 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure9141, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*)* @xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd__9127, void (i8*, i8*, %ShaderProgram*)** %closure.func9153
%closure_size9154 = call i64 @llvm_zone_mark_size(%mzone* %zone9139)
call void @llvm_zone_ptr_set_size(i8* %clsptr9140, i64 %closure_size9154)
%wrapper_ptr9155 = call i8* @llvm_zone_malloc(%mzone* %zone9139, i64 8)
%closure_wrapper9156 = bitcast i8* %wrapper_ptr9155 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure9141, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper9156

; let value assignment
%xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper9156, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper9156
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr

; add data to environment
; don't need to alloc for env var xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd
%tmp_envptr9150 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}* %environment9143, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**** %tmp_envptr9150


%val9159 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %val9159
}


@xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** @xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
ret void
}


define dllexport ccc void @xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_native(%ShaderProgram* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
ret void
}


define dllexport ccc i8*  @xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var9160 = bitcast [106 x i8]* @gsxtmgraphics-pipeline384 to i8*
call i32 (i8*, ...) @printf(i8* %var9160)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*}*
%arg_p_0 = getelementptr {%ShaderProgram*}, {%ShaderProgram*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%xtm_lights = type {float*,float*,float*,float*,float*,float*,float*,float*,float*,i32}
@gsxtmgraphics-pipeline385 = hidden constant [125 x i8] c"xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0\00"
@gsxtmgraphics-pipeline386 = hidden constant [116 x i8] c"{i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**\00"
define dllexport fastcc %xtm_lights* @xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0__9161(i8* %_impz,i8* %_impenv, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8, i32 %arg_9) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9162 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}*
%xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}* %impenv, i32 0, i32 0
%xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0Ptr = load {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**** %xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca float*
store float* %arg_0, float** %arg_0Ptr
%arg_1Ptr = alloca float*
store float* %arg_1, float** %arg_1Ptr
%arg_2Ptr = alloca float*
store float* %arg_2, float** %arg_2Ptr
%arg_3Ptr = alloca float*
store float* %arg_3, float** %arg_3Ptr
%arg_4Ptr = alloca float*
store float* %arg_4, float** %arg_4Ptr
%arg_5Ptr = alloca float*
store float* %arg_5, float** %arg_5Ptr
%arg_6Ptr = alloca float*
store float* %arg_6, float** %arg_6Ptr
%arg_7Ptr = alloca float*
store float* %arg_7, float** %arg_7Ptr
%arg_8Ptr = alloca float*
store float* %arg_8, float** %arg_8Ptr
%arg_9Ptr = alloca i32
store i32 %arg_9, i32* %arg_9Ptr


%tzone9167 = load i8*, i8** %_impzPtr
%zone9168 = bitcast i8* %tzone9167 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %xtm_lights*
%tzone9163 = load i8*, i8** %_impzPtr
%zone9164 = bitcast i8* %tzone9163 to %mzone*
%dat9165 = call i8* @llvm_zone_malloc(%mzone* %zone9164, i64 80)
call i8* @memset(i8* %dat9165, i32 0, i64 80)
%val9166 = bitcast i8* %dat9165 to %xtm_lights*

; let value assignment
%obj = select i1 true, %xtm_lights* %val9166, %xtm_lights* %val9166
store %xtm_lights* %obj, %xtm_lights** %objPtr

%val9169 = load %xtm_lights*, %xtm_lights** %objPtr
%val9170 = load float*, float** %arg_0Ptr
; set tuple
%val9171 = getelementptr %xtm_lights, %xtm_lights* %val9169, i64 0, i32 0
store float* %val9170, float** %val9171
%val9172 = load %xtm_lights*, %xtm_lights** %objPtr
%val9173 = load float*, float** %arg_1Ptr
; set tuple
%val9174 = getelementptr %xtm_lights, %xtm_lights* %val9172, i64 0, i32 1
store float* %val9173, float** %val9174
%val9175 = load %xtm_lights*, %xtm_lights** %objPtr
%val9176 = load float*, float** %arg_2Ptr
; set tuple
%val9177 = getelementptr %xtm_lights, %xtm_lights* %val9175, i64 0, i32 2
store float* %val9176, float** %val9177
%val9178 = load %xtm_lights*, %xtm_lights** %objPtr
%val9179 = load float*, float** %arg_3Ptr
; set tuple
%val9180 = getelementptr %xtm_lights, %xtm_lights* %val9178, i64 0, i32 3
store float* %val9179, float** %val9180
%val9181 = load %xtm_lights*, %xtm_lights** %objPtr
%val9182 = load float*, float** %arg_4Ptr
; set tuple
%val9183 = getelementptr %xtm_lights, %xtm_lights* %val9181, i64 0, i32 4
store float* %val9182, float** %val9183
%val9184 = load %xtm_lights*, %xtm_lights** %objPtr
%val9185 = load float*, float** %arg_5Ptr
; set tuple
%val9186 = getelementptr %xtm_lights, %xtm_lights* %val9184, i64 0, i32 5
store float* %val9185, float** %val9186
%val9187 = load %xtm_lights*, %xtm_lights** %objPtr
%val9188 = load float*, float** %arg_6Ptr
; set tuple
%val9189 = getelementptr %xtm_lights, %xtm_lights* %val9187, i64 0, i32 6
store float* %val9188, float** %val9189
%val9190 = load %xtm_lights*, %xtm_lights** %objPtr
%val9191 = load float*, float** %arg_7Ptr
; set tuple
%val9192 = getelementptr %xtm_lights, %xtm_lights* %val9190, i64 0, i32 7
store float* %val9191, float** %val9192
%val9193 = load %xtm_lights*, %xtm_lights** %objPtr
%val9194 = load float*, float** %arg_8Ptr
; set tuple
%val9195 = getelementptr %xtm_lights, %xtm_lights* %val9193, i64 0, i32 8
store float* %val9194, float** %val9195
%val9196 = load %xtm_lights*, %xtm_lights** %objPtr
%val9197 = load i32, i32* %arg_9Ptr
; set tuple
%val9198 = getelementptr %xtm_lights, %xtm_lights* %val9196, i64 0, i32 9
store i32 %val9197, i32* %val9198
%val9199 = load %xtm_lights*, %xtm_lights** %objPtr
ret %xtm_lights* %val9199
}
@gsxtmgraphics-pipeline387 = hidden constant [178 x i8] c"xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** @xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9219 = load i8*, i8** %_impzPtr
%zone9220 = bitcast i8* %tzone9219 to %mzone*

; let assign value to symbol xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0
%dat_xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone9220, i64 8)
%xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0Ptr = bitcast i8* %dat_xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0 to { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***
%tzone9200 = load i8*, i8** %_impzPtr
%zone9201 = bitcast i8* %tzone9200 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9201)
; malloc closure structure
%clsptr9202 = call i8* @llvm_zone_malloc(%mzone* %zone9201, i64 24)
%closure9203 = bitcast i8* %clsptr9202 to { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*

; malloc environment structure
%envptr9204 = call i8* @llvm_zone_malloc(%mzone* %zone9201, i64 8)
%environment9205 = bitcast i8* %envptr9204 to {{i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}*

; malloc closure address table
%addytable9206 = call %clsvar* @new_address_table()
%var9207 = bitcast [125 x i8]* @gsxtmgraphics-pipeline385 to i8*
%var9208 = bitcast [116 x i8]* @gsxtmgraphics-pipeline386 to i8*
%addytable9209 = call %clsvar* @add_address_table(%mzone* %zone9201, i8* %var9207, i32 0, i8* %var9208, i32 3, %clsvar* %addytable9206)
%address-table9210 = bitcast %clsvar* %addytable9209 to i8*

; insert table, function and environment into closure struct
%closure.table9213 = getelementptr { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure9203, i32 0, i32 0
store i8* %address-table9210, i8** %closure.table9213
%closure.env9214 = getelementptr { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure9203, i32 0, i32 1
store i8* %envptr9204, i8** %closure.env9214
%closure.func9215 = getelementptr { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure9203, i32 0, i32 2
store %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)* @xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0__9161, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)** %closure.func9215
%closure_size9216 = call i64 @llvm_zone_mark_size(%mzone* %zone9201)
call void @llvm_zone_ptr_set_size(i8* %clsptr9202, i64 %closure_size9216)
%wrapper_ptr9217 = call i8* @llvm_zone_malloc(%mzone* %zone9201, i64 8)
%closure_wrapper9218 = bitcast i8* %wrapper_ptr9217 to { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**
store { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure9203, { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_wrapper9218

; let value assignment
%xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0 = select i1 true, { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_wrapper9218, { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_wrapper9218
store { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0, { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*** %xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0
%tmp_envptr9212 = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}* %environment9205, i32 0, i32 0
store {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*** %xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0Ptr, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**** %tmp_envptr9212


%val9221 = load {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*** %xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0Ptr
ret {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %val9221
}


@xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** @xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %xtm_lights* @xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0(float* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float* %arg_5,float* %arg_6,float* %arg_7,float* %arg_8,i32 %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*,  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8, i32 %arg_9)
ret %xtm_lights* %result
}


define dllexport ccc %xtm_lights* @xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_native(float* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float* %arg_5,float* %arg_6,float* %arg_7,float* %arg_8,i32 %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*,  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8, i32 %arg_9)
ret %xtm_lights* %result
}


define dllexport ccc i8*  @xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var9222 = bitcast [178 x i8]* @gsxtmgraphics-pipeline387 to i8*
call i32 (i8*, ...) @printf(i8* %var9222)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var9223 = bitcast [178 x i8]* @gsxtmgraphics-pipeline387 to i8*
call i32 (i8*, ...) @printf(i8* %var9223)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var9224 = bitcast [178 x i8]* @gsxtmgraphics-pipeline387 to i8*
call i32 (i8*, ...) @printf(i8* %var9224)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var9225 = bitcast [178 x i8]* @gsxtmgraphics-pipeline387 to i8*
call i32 (i8*, ...) @printf(i8* %var9225)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var9226 = bitcast [178 x i8]* @gsxtmgraphics-pipeline387 to i8*
call i32 (i8*, ...) @printf(i8* %var9226)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var9227 = bitcast [178 x i8]* @gsxtmgraphics-pipeline387 to i8*
call i32 (i8*, ...) @printf(i8* %var9227)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to float*
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var9228 = bitcast [178 x i8]* @gsxtmgraphics-pipeline387 to i8*
call i32 (i8*, ...) @printf(i8* %var9228)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to float*
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_cptr(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var9229 = bitcast [178 x i8]* @gsxtmgraphics-pipeline387 to i8*
call i32 (i8*, ...) @printf(i8* %var9229)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%ttv_7 = call ccc i8* @cptr_value(i8* %arg_7_val)
%arg_7 = bitcast i8* %ttv_7 to float*
%arg_8_val = call ccc i8* @list_ref(i8* %_sc, i32 8,i8* %args)
%arg_8_rt_check = call i32 @is_cptr(i8* %arg_8_val)
%arg_8_bool = icmp ne i32 %arg_8_rt_check, 0
br i1 %arg_8_bool, label %arg_8_true, label %arg_8_false

arg_8_true:
br label %arg_8_continue

arg_8_false:
%var9230 = bitcast [178 x i8]* @gsxtmgraphics-pipeline387 to i8*
call i32 (i8*, ...) @printf(i8* %var9230)
%arg_8_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_8_errret

arg_8_continue:
%ttv_8 = call ccc i8* @cptr_value(i8* %arg_8_val)
%arg_8 = bitcast i8* %ttv_8 to float*
%arg_9_val = call ccc i8* @list_ref(i8* %_sc, i32 9,i8* %args)
%arg_9_rt_check = call i32 @is_integer(i8* %arg_9_val)
%arg_9_bool = icmp ne i32 %arg_9_rt_check, 0
br i1 %arg_9_bool, label %arg_9_true, label %arg_9_false

arg_9_true:
br label %arg_9_continue

arg_9_false:
%var9231 = bitcast [178 x i8]* @gsxtmgraphics-pipeline387 to i8*
call i32 (i8*, ...) @printf(i8* %var9231)
%arg_9_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_9_errret

arg_9_continue:
%arg_9 = call ccc i32  @i32value(i8* %arg_9_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*,  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8, i32 %arg_9)
%tmpres = bitcast %xtm_lights* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}*
%arg_p_0 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 5
%arg_5 = load float*, float** %arg_p_5
%arg_p_6 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 6
%arg_6 = load float*, float** %arg_p_6
%arg_p_7 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 7
%arg_7 = load float*, float** %arg_p_7
%arg_p_8 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 8
%arg_8 = load float*, float** %arg_p_8
%arg_p_9 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 9
%arg_9 = load i32, i32* %arg_p_9
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*,  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8, i32 %arg_9)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline388 = hidden constant [127 x i8] c"xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0\00"
define dllexport fastcc %xtm_lights* @xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0__9232(i8* %_impz,i8* %_impenv, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8, i32 %arg_9) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9233 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}*
%xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}* %impenv, i32 0, i32 0
%xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0Ptr = load {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**** %xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca float*
store float* %arg_0, float** %arg_0Ptr
%arg_1Ptr = alloca float*
store float* %arg_1, float** %arg_1Ptr
%arg_2Ptr = alloca float*
store float* %arg_2, float** %arg_2Ptr
%arg_3Ptr = alloca float*
store float* %arg_3, float** %arg_3Ptr
%arg_4Ptr = alloca float*
store float* %arg_4, float** %arg_4Ptr
%arg_5Ptr = alloca float*
store float* %arg_5, float** %arg_5Ptr
%arg_6Ptr = alloca float*
store float* %arg_6, float** %arg_6Ptr
%arg_7Ptr = alloca float*
store float* %arg_7, float** %arg_7Ptr
%arg_8Ptr = alloca float*
store float* %arg_8, float** %arg_8Ptr
%arg_9Ptr = alloca i32
store i32 %arg_9, i32* %arg_9Ptr


%tzone9238 = load i8*, i8** %_impzPtr
%zone9239 = bitcast i8* %tzone9238 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %xtm_lights*
%tzone9234 = load i8*, i8** %_impzPtr
%zone9235 = bitcast i8* %tzone9234 to %mzone*
%dat9236 = call i8* @llvm_zone_malloc(%mzone* %zone9235, i64 80)
call i8* @memset(i8* %dat9236, i32 0, i64 80)
%val9237 = bitcast i8* %dat9236 to %xtm_lights*

; let value assignment
%obj = select i1 true, %xtm_lights* %val9237, %xtm_lights* %val9237
store %xtm_lights* %obj, %xtm_lights** %objPtr

%val9240 = load %xtm_lights*, %xtm_lights** %objPtr
%val9241 = load float*, float** %arg_0Ptr
; set tuple
%val9242 = getelementptr %xtm_lights, %xtm_lights* %val9240, i64 0, i32 0
store float* %val9241, float** %val9242
%val9243 = load %xtm_lights*, %xtm_lights** %objPtr
%val9244 = load float*, float** %arg_1Ptr
; set tuple
%val9245 = getelementptr %xtm_lights, %xtm_lights* %val9243, i64 0, i32 1
store float* %val9244, float** %val9245
%val9246 = load %xtm_lights*, %xtm_lights** %objPtr
%val9247 = load float*, float** %arg_2Ptr
; set tuple
%val9248 = getelementptr %xtm_lights, %xtm_lights* %val9246, i64 0, i32 2
store float* %val9247, float** %val9248
%val9249 = load %xtm_lights*, %xtm_lights** %objPtr
%val9250 = load float*, float** %arg_3Ptr
; set tuple
%val9251 = getelementptr %xtm_lights, %xtm_lights* %val9249, i64 0, i32 3
store float* %val9250, float** %val9251
%val9252 = load %xtm_lights*, %xtm_lights** %objPtr
%val9253 = load float*, float** %arg_4Ptr
; set tuple
%val9254 = getelementptr %xtm_lights, %xtm_lights* %val9252, i64 0, i32 4
store float* %val9253, float** %val9254
%val9255 = load %xtm_lights*, %xtm_lights** %objPtr
%val9256 = load float*, float** %arg_5Ptr
; set tuple
%val9257 = getelementptr %xtm_lights, %xtm_lights* %val9255, i64 0, i32 5
store float* %val9256, float** %val9257
%val9258 = load %xtm_lights*, %xtm_lights** %objPtr
%val9259 = load float*, float** %arg_6Ptr
; set tuple
%val9260 = getelementptr %xtm_lights, %xtm_lights* %val9258, i64 0, i32 6
store float* %val9259, float** %val9260
%val9261 = load %xtm_lights*, %xtm_lights** %objPtr
%val9262 = load float*, float** %arg_7Ptr
; set tuple
%val9263 = getelementptr %xtm_lights, %xtm_lights* %val9261, i64 0, i32 7
store float* %val9262, float** %val9263
%val9264 = load %xtm_lights*, %xtm_lights** %objPtr
%val9265 = load float*, float** %arg_8Ptr
; set tuple
%val9266 = getelementptr %xtm_lights, %xtm_lights* %val9264, i64 0, i32 8
store float* %val9265, float** %val9266
%val9267 = load %xtm_lights*, %xtm_lights** %objPtr
%val9268 = load i32, i32* %arg_9Ptr
; set tuple
%val9269 = getelementptr %xtm_lights, %xtm_lights* %val9267, i64 0, i32 9
store i32 %val9268, i32* %val9269
%val9270 = load %xtm_lights*, %xtm_lights** %objPtr
ret %xtm_lights* %val9270
}
@gsxtmgraphics-pipeline389 = hidden constant [180 x i8] c"xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** @xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9290 = load i8*, i8** %_impzPtr
%zone9291 = bitcast i8* %tzone9290 to %mzone*

; let assign value to symbol xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0
%dat_xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone9291, i64 8)
%xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0Ptr = bitcast i8* %dat_xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0 to { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***
%tzone9271 = load i8*, i8** %_impzPtr
%zone9272 = bitcast i8* %tzone9271 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9272)
; malloc closure structure
%clsptr9273 = call i8* @llvm_zone_malloc(%mzone* %zone9272, i64 24)
%closure9274 = bitcast i8* %clsptr9273 to { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*

; malloc environment structure
%envptr9275 = call i8* @llvm_zone_malloc(%mzone* %zone9272, i64 8)
%environment9276 = bitcast i8* %envptr9275 to {{i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}*

; malloc closure address table
%addytable9277 = call %clsvar* @new_address_table()
%var9278 = bitcast [127 x i8]* @gsxtmgraphics-pipeline388 to i8*
%var9279 = bitcast [116 x i8]* @gsxtmgraphics-pipeline386 to i8*
%addytable9280 = call %clsvar* @add_address_table(%mzone* %zone9272, i8* %var9278, i32 0, i8* %var9279, i32 3, %clsvar* %addytable9277)
%address-table9281 = bitcast %clsvar* %addytable9280 to i8*

; insert table, function and environment into closure struct
%closure.table9284 = getelementptr { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure9274, i32 0, i32 0
store i8* %address-table9281, i8** %closure.table9284
%closure.env9285 = getelementptr { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure9274, i32 0, i32 1
store i8* %envptr9275, i8** %closure.env9285
%closure.func9286 = getelementptr { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure9274, i32 0, i32 2
store %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)* @xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0__9232, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)** %closure.func9286
%closure_size9287 = call i64 @llvm_zone_mark_size(%mzone* %zone9272)
call void @llvm_zone_ptr_set_size(i8* %clsptr9273, i64 %closure_size9287)
%wrapper_ptr9288 = call i8* @llvm_zone_malloc(%mzone* %zone9272, i64 8)
%closure_wrapper9289 = bitcast i8* %wrapper_ptr9288 to { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**
store { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure9274, { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_wrapper9289

; let value assignment
%xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0 = select i1 true, { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_wrapper9289, { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_wrapper9289
store { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0, { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*** %xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0
%tmp_envptr9283 = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}* %environment9276, i32 0, i32 0
store {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*** %xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0Ptr, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**** %tmp_envptr9283


%val9292 = load {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*** %xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0Ptr
ret {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %val9292
}


@xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** @xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %xtm_lights* @xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0(float* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float* %arg_5,float* %arg_6,float* %arg_7,float* %arg_8,i32 %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*,  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8, i32 %arg_9)
ret %xtm_lights* %result
}


define dllexport ccc %xtm_lights* @xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_native(float* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float* %arg_5,float* %arg_6,float* %arg_7,float* %arg_8,i32 %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*,  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8, i32 %arg_9)
ret %xtm_lights* %result
}


define dllexport ccc i8*  @xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var9293 = bitcast [180 x i8]* @gsxtmgraphics-pipeline389 to i8*
call i32 (i8*, ...) @printf(i8* %var9293)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var9294 = bitcast [180 x i8]* @gsxtmgraphics-pipeline389 to i8*
call i32 (i8*, ...) @printf(i8* %var9294)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var9295 = bitcast [180 x i8]* @gsxtmgraphics-pipeline389 to i8*
call i32 (i8*, ...) @printf(i8* %var9295)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var9296 = bitcast [180 x i8]* @gsxtmgraphics-pipeline389 to i8*
call i32 (i8*, ...) @printf(i8* %var9296)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var9297 = bitcast [180 x i8]* @gsxtmgraphics-pipeline389 to i8*
call i32 (i8*, ...) @printf(i8* %var9297)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var9298 = bitcast [180 x i8]* @gsxtmgraphics-pipeline389 to i8*
call i32 (i8*, ...) @printf(i8* %var9298)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to float*
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var9299 = bitcast [180 x i8]* @gsxtmgraphics-pipeline389 to i8*
call i32 (i8*, ...) @printf(i8* %var9299)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to float*
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_cptr(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var9300 = bitcast [180 x i8]* @gsxtmgraphics-pipeline389 to i8*
call i32 (i8*, ...) @printf(i8* %var9300)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%ttv_7 = call ccc i8* @cptr_value(i8* %arg_7_val)
%arg_7 = bitcast i8* %ttv_7 to float*
%arg_8_val = call ccc i8* @list_ref(i8* %_sc, i32 8,i8* %args)
%arg_8_rt_check = call i32 @is_cptr(i8* %arg_8_val)
%arg_8_bool = icmp ne i32 %arg_8_rt_check, 0
br i1 %arg_8_bool, label %arg_8_true, label %arg_8_false

arg_8_true:
br label %arg_8_continue

arg_8_false:
%var9301 = bitcast [180 x i8]* @gsxtmgraphics-pipeline389 to i8*
call i32 (i8*, ...) @printf(i8* %var9301)
%arg_8_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_8_errret

arg_8_continue:
%ttv_8 = call ccc i8* @cptr_value(i8* %arg_8_val)
%arg_8 = bitcast i8* %ttv_8 to float*
%arg_9_val = call ccc i8* @list_ref(i8* %_sc, i32 9,i8* %args)
%arg_9_rt_check = call i32 @is_integer(i8* %arg_9_val)
%arg_9_bool = icmp ne i32 %arg_9_rt_check, 0
br i1 %arg_9_bool, label %arg_9_true, label %arg_9_false

arg_9_true:
br label %arg_9_continue

arg_9_false:
%var9302 = bitcast [180 x i8]* @gsxtmgraphics-pipeline389 to i8*
call i32 (i8*, ...) @printf(i8* %var9302)
%arg_9_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_9_errret

arg_9_continue:
%arg_9 = call ccc i32  @i32value(i8* %arg_9_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*,  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8, i32 %arg_9)
%tmpres = bitcast %xtm_lights* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}*
%arg_p_0 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 5
%arg_5 = load float*, float** %arg_p_5
%arg_p_6 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 6
%arg_6 = load float*, float** %arg_p_6
%arg_p_7 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 7
%arg_7 = load float*, float** %arg_p_7
%arg_p_8 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 8
%arg_8 = load float*, float** %arg_p_8
%arg_p_9 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 9
%arg_9 = load i32, i32* %arg_p_9
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_z_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*,  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8, i32 %arg_9)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline390 = hidden constant [127 x i8] c"xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0\00"
define dllexport fastcc %xtm_lights* @xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0__9303(i8* %_impz,i8* %_impenv, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8, i32 %arg_9) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9304 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}*
%xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}* %impenv, i32 0, i32 0
%xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0Ptr = load {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**** %xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca float*
store float* %arg_0, float** %arg_0Ptr
%arg_1Ptr = alloca float*
store float* %arg_1, float** %arg_1Ptr
%arg_2Ptr = alloca float*
store float* %arg_2, float** %arg_2Ptr
%arg_3Ptr = alloca float*
store float* %arg_3, float** %arg_3Ptr
%arg_4Ptr = alloca float*
store float* %arg_4, float** %arg_4Ptr
%arg_5Ptr = alloca float*
store float* %arg_5, float** %arg_5Ptr
%arg_6Ptr = alloca float*
store float* %arg_6, float** %arg_6Ptr
%arg_7Ptr = alloca float*
store float* %arg_7, float** %arg_7Ptr
%arg_8Ptr = alloca float*
store float* %arg_8, float** %arg_8Ptr
%arg_9Ptr = alloca i32
store i32 %arg_9, i32* %arg_9Ptr


%tzone9307 = load i8*, i8** %_impzPtr
%zone9308 = bitcast i8* %tzone9307 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %xtm_lights*
%dat9305 = call i8* @malloc(i64 80)
call i8* @memset(i8* %dat9305, i32 0, i64 80)
%val9306 = bitcast i8* %dat9305 to %xtm_lights*

; let value assignment
%obj = select i1 true, %xtm_lights* %val9306, %xtm_lights* %val9306
store %xtm_lights* %obj, %xtm_lights** %objPtr

%val9309 = load %xtm_lights*, %xtm_lights** %objPtr
%val9310 = load float*, float** %arg_0Ptr
; set tuple
%val9311 = getelementptr %xtm_lights, %xtm_lights* %val9309, i64 0, i32 0
store float* %val9310, float** %val9311
%val9312 = load %xtm_lights*, %xtm_lights** %objPtr
%val9313 = load float*, float** %arg_1Ptr
; set tuple
%val9314 = getelementptr %xtm_lights, %xtm_lights* %val9312, i64 0, i32 1
store float* %val9313, float** %val9314
%val9315 = load %xtm_lights*, %xtm_lights** %objPtr
%val9316 = load float*, float** %arg_2Ptr
; set tuple
%val9317 = getelementptr %xtm_lights, %xtm_lights* %val9315, i64 0, i32 2
store float* %val9316, float** %val9317
%val9318 = load %xtm_lights*, %xtm_lights** %objPtr
%val9319 = load float*, float** %arg_3Ptr
; set tuple
%val9320 = getelementptr %xtm_lights, %xtm_lights* %val9318, i64 0, i32 3
store float* %val9319, float** %val9320
%val9321 = load %xtm_lights*, %xtm_lights** %objPtr
%val9322 = load float*, float** %arg_4Ptr
; set tuple
%val9323 = getelementptr %xtm_lights, %xtm_lights* %val9321, i64 0, i32 4
store float* %val9322, float** %val9323
%val9324 = load %xtm_lights*, %xtm_lights** %objPtr
%val9325 = load float*, float** %arg_5Ptr
; set tuple
%val9326 = getelementptr %xtm_lights, %xtm_lights* %val9324, i64 0, i32 5
store float* %val9325, float** %val9326
%val9327 = load %xtm_lights*, %xtm_lights** %objPtr
%val9328 = load float*, float** %arg_6Ptr
; set tuple
%val9329 = getelementptr %xtm_lights, %xtm_lights* %val9327, i64 0, i32 6
store float* %val9328, float** %val9329
%val9330 = load %xtm_lights*, %xtm_lights** %objPtr
%val9331 = load float*, float** %arg_7Ptr
; set tuple
%val9332 = getelementptr %xtm_lights, %xtm_lights* %val9330, i64 0, i32 7
store float* %val9331, float** %val9332
%val9333 = load %xtm_lights*, %xtm_lights** %objPtr
%val9334 = load float*, float** %arg_8Ptr
; set tuple
%val9335 = getelementptr %xtm_lights, %xtm_lights* %val9333, i64 0, i32 8
store float* %val9334, float** %val9335
%val9336 = load %xtm_lights*, %xtm_lights** %objPtr
%val9337 = load i32, i32* %arg_9Ptr
; set tuple
%val9338 = getelementptr %xtm_lights, %xtm_lights* %val9336, i64 0, i32 9
store i32 %val9337, i32* %val9338
%val9339 = load %xtm_lights*, %xtm_lights** %objPtr
ret %xtm_lights* %val9339
}
@gsxtmgraphics-pipeline391 = hidden constant [180 x i8] c"xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** @xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9359 = load i8*, i8** %_impzPtr
%zone9360 = bitcast i8* %tzone9359 to %mzone*

; let assign value to symbol xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0
%dat_xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone9360, i64 8)
%xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0Ptr = bitcast i8* %dat_xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0 to { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***
%tzone9340 = load i8*, i8** %_impzPtr
%zone9341 = bitcast i8* %tzone9340 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9341)
; malloc closure structure
%clsptr9342 = call i8* @llvm_zone_malloc(%mzone* %zone9341, i64 24)
%closure9343 = bitcast i8* %clsptr9342 to { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*

; malloc environment structure
%envptr9344 = call i8* @llvm_zone_malloc(%mzone* %zone9341, i64 8)
%environment9345 = bitcast i8* %envptr9344 to {{i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}*

; malloc closure address table
%addytable9346 = call %clsvar* @new_address_table()
%var9347 = bitcast [127 x i8]* @gsxtmgraphics-pipeline390 to i8*
%var9348 = bitcast [116 x i8]* @gsxtmgraphics-pipeline386 to i8*
%addytable9349 = call %clsvar* @add_address_table(%mzone* %zone9341, i8* %var9347, i32 0, i8* %var9348, i32 3, %clsvar* %addytable9346)
%address-table9350 = bitcast %clsvar* %addytable9349 to i8*

; insert table, function and environment into closure struct
%closure.table9353 = getelementptr { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure9343, i32 0, i32 0
store i8* %address-table9350, i8** %closure.table9353
%closure.env9354 = getelementptr { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure9343, i32 0, i32 1
store i8* %envptr9344, i8** %closure.env9354
%closure.func9355 = getelementptr { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure9343, i32 0, i32 2
store %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)* @xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0__9303, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)** %closure.func9355
%closure_size9356 = call i64 @llvm_zone_mark_size(%mzone* %zone9341)
call void @llvm_zone_ptr_set_size(i8* %clsptr9342, i64 %closure_size9356)
%wrapper_ptr9357 = call i8* @llvm_zone_malloc(%mzone* %zone9341, i64 8)
%closure_wrapper9358 = bitcast i8* %wrapper_ptr9357 to { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**
store { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure9343, { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_wrapper9358

; let value assignment
%xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0 = select i1 true, { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_wrapper9358, { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_wrapper9358
store { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0, { i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*** %xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0
%tmp_envptr9352 = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}* %environment9345, i32 0, i32 0
store {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*** %xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0Ptr, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**** %tmp_envptr9352


%val9361 = load {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*** %xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0Ptr
ret {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %val9361
}


@xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** @xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %xtm_lights* @xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0(float* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float* %arg_5,float* %arg_6,float* %arg_7,float* %arg_8,i32 %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*,  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8, i32 %arg_9)
ret %xtm_lights* %result
}


define dllexport ccc %xtm_lights* @xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_native(float* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float* %arg_5,float* %arg_6,float* %arg_7,float* %arg_8,i32 %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*,  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8, i32 %arg_9)
ret %xtm_lights* %result
}


define dllexport ccc i8*  @xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var9362 = bitcast [180 x i8]* @gsxtmgraphics-pipeline391 to i8*
call i32 (i8*, ...) @printf(i8* %var9362)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var9363 = bitcast [180 x i8]* @gsxtmgraphics-pipeline391 to i8*
call i32 (i8*, ...) @printf(i8* %var9363)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var9364 = bitcast [180 x i8]* @gsxtmgraphics-pipeline391 to i8*
call i32 (i8*, ...) @printf(i8* %var9364)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var9365 = bitcast [180 x i8]* @gsxtmgraphics-pipeline391 to i8*
call i32 (i8*, ...) @printf(i8* %var9365)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var9366 = bitcast [180 x i8]* @gsxtmgraphics-pipeline391 to i8*
call i32 (i8*, ...) @printf(i8* %var9366)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var9367 = bitcast [180 x i8]* @gsxtmgraphics-pipeline391 to i8*
call i32 (i8*, ...) @printf(i8* %var9367)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to float*
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var9368 = bitcast [180 x i8]* @gsxtmgraphics-pipeline391 to i8*
call i32 (i8*, ...) @printf(i8* %var9368)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to float*
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_cptr(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var9369 = bitcast [180 x i8]* @gsxtmgraphics-pipeline391 to i8*
call i32 (i8*, ...) @printf(i8* %var9369)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%ttv_7 = call ccc i8* @cptr_value(i8* %arg_7_val)
%arg_7 = bitcast i8* %ttv_7 to float*
%arg_8_val = call ccc i8* @list_ref(i8* %_sc, i32 8,i8* %args)
%arg_8_rt_check = call i32 @is_cptr(i8* %arg_8_val)
%arg_8_bool = icmp ne i32 %arg_8_rt_check, 0
br i1 %arg_8_bool, label %arg_8_true, label %arg_8_false

arg_8_true:
br label %arg_8_continue

arg_8_false:
%var9370 = bitcast [180 x i8]* @gsxtmgraphics-pipeline391 to i8*
call i32 (i8*, ...) @printf(i8* %var9370)
%arg_8_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_8_errret

arg_8_continue:
%ttv_8 = call ccc i8* @cptr_value(i8* %arg_8_val)
%arg_8 = bitcast i8* %ttv_8 to float*
%arg_9_val = call ccc i8* @list_ref(i8* %_sc, i32 9,i8* %args)
%arg_9_rt_check = call i32 @is_integer(i8* %arg_9_val)
%arg_9_bool = icmp ne i32 %arg_9_rt_check, 0
br i1 %arg_9_bool, label %arg_9_true, label %arg_9_false

arg_9_true:
br label %arg_9_continue

arg_9_false:
%var9371 = bitcast [180 x i8]* @gsxtmgraphics-pipeline391 to i8*
call i32 (i8*, ...) @printf(i8* %var9371)
%arg_9_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_9_errret

arg_9_continue:
%arg_9 = call ccc i32  @i32value(i8* %arg_9_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*,  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8, i32 %arg_9)
%tmpres = bitcast %xtm_lights* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}*
%arg_p_0 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 5
%arg_5 = load float*, float** %arg_p_5
%arg_p_6 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 6
%arg_6 = load float*, float** %arg_p_6
%arg_p_7 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 7
%arg_7 = load float*, float** %arg_p_7
%arg_p_8 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 8
%arg_8 = load float*, float** %arg_p_8
%arg_p_9 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 9
%arg_9 = load i32, i32* %arg_p_9
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_h_adhoc_W3h0bV9saWdodHMqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*,  %xtm_lights* (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8, i32 %arg_9)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline392 = hidden constant [18 x i8] c"<xtm_lights:null>\00"
@gsxtmgraphics-pipeline393 = hidden constant [13 x i8] c"<xtm_lights:\00"
@gsxtmgraphics-pipeline394 = hidden constant [44 x i8] c"toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd\00"
@gsxtmgraphics-pipeline395 = hidden constant [49 x i8] c"{i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd__9372(i8* %_impz,i8* %_impenv, %xtm_lights* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9373 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}***}*
%toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypdPtr = load {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}***, {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}**** %toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypdPtr_

; setup arguments
%xPtr = alloca %xtm_lights*
store %xtm_lights* %x, %xtm_lights** %xPtr


%val9375 = load %xtm_lights*, %xtm_lights** %xPtr
%val9376 = icmp eq %xtm_lights* %val9375, null
br i1 %val9376, label %then9374, label %else9374

then9374:
%zone9377 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone9377)
%zone_ptr9378 = bitcast %mzone* %zone9377 to i8*
store i8* %zone_ptr9378, i8** %_impzPtr
%tzone9388 = load i8*, i8** %_impzPtr
%zone9389 = bitcast i8* %tzone9388 to %mzone*

; let assign value to symbol res6
%res6Ptr = alloca %String*
%tzone9393 = load i8*, i8** %_impzPtr
%zone9394 = bitcast i8* %tzone9393 to %mzone*

; let assign value to symbol zone6
%zone6Ptr = alloca %mzone*
%tzone9396 = load i8*, i8** %_impzPtr
%zone9397 = bitcast i8* %tzone9396 to %mzone*

; let assign value to symbol newz6
%newz6Ptr = alloca %mzone*
%tzone9380 = load i8*, i8** %_impzPtr
%zone9381 = bitcast i8* %tzone9380 to %mzone*

; let assign value to symbol xx_t_mst
%xx_t_mstPtr = alloca i8*
%dat9379 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst = select i1 true, i8* %dat9379, i8* %dat9379
store i8* %xx_t_mst, i8** %xx_t_mstPtr

%val9382 = load i8*, i8** %xx_t_mstPtr
%var9383 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9384 = bitcast [18 x i8]* @gsxtmgraphics-pipeline392 to i8*

%val9385 = call i32 (i8*,i8*, ...) @sprintf(i8* %val9382, i8* %var9383, i8* %var9384)
%val9386 = load i8*, i8** %xx_t_mstPtr
%res9387 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val9386)

; let value assignment
%res6 = select i1 true, %String* %res9387, %String* %res9387
store %String* %res6, %String** %res6Ptr

%oldzone9390 = call %mzone* @llvm_pop_zone_stack()
%newzone9391 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr9392 = bitcast %mzone* %newzone9391 to i8*
store i8* %zone_ptr9392, i8** %_impzPtr

; let value assignment
%zone6 = select i1 true, %mzone* %oldzone9390, %mzone* %oldzone9390
store %mzone* %zone6, %mzone** %zone6Ptr

%res9395 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz6 = select i1 true, %mzone* %res9395, %mzone* %res9395
store %mzone* %newz6, %mzone** %newz6Ptr

%tzone9402 = load i8*, i8** %_impzPtr
%zone9403 = bitcast i8* %tzone9402 to %mzone*

; let assign value to symbol rescopy6
%rescopy6Ptr = alloca %String*
%tzone9408 = load i8*, i8** %_impzPtr
%zone9409 = bitcast i8* %tzone9408 to %mzone*

; let assign value to symbol hook
%hookPtr = alloca {i64,i8*,i8*}*
%tzone9411 = load i8*, i8** %_impzPtr
%zone9412 = bitcast i8* %tzone9411 to %mzone*

; let assign value to symbol f
%fPtr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val9398 = load %String*, %String** %res6Ptr
%val9399 = load %mzone*, %mzone** %zone6Ptr
%val9400 = load %mzone*, %mzone** %newz6Ptr
%res9401 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val9398, %mzone* %val9399, %mzone* %val9400)

; let value assignment
%rescopy6 = select i1 true, %String* %res9401, %String* %res9401
store %String* %rescopy6, %String** %rescopy6Ptr

%val9404 = load %mzone*, %mzone** %zone6Ptr
; tuple ref
%val9405 = getelementptr %mzone, %mzone* %val9404, i64 0, i32 4
%val9406 = load i8*, i8** %val9405
%val9407 = bitcast i8* %val9406 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val9407, {i64,i8*,i8*}* %val9407
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%null9410 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null9410, {i8*, i8*, void (i8*, i8*)*}** %null9410
store {i8*, i8*, void (i8*, i8*)*}** %f, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; promote local stack var allocations
%tzone9448 = load i8*, i8** %_impzPtr
%zone9449 = bitcast i8* %tzone9448 to %mzone*
%ifptr9438 = alloca i1
%ifptr9414 = alloca i1
; while loop
%val9415 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val9416 = icmp eq {i64,i8*,i8*}* %val9415, null
br i1 %val9416, label %then9414, label %else9414

then9414:
%res9417 = call ccc i1 @impc_false()
store i1 %res9417, i1* %ifptr9414
br label %ifcont9414

else9414:
%res9418 = call ccc i1 @impc_true()
store i1 %res9418, i1* %ifptr9414
br label %ifcont9414

ifcont9414:
%ifres9419 = load i1, i1* %ifptr9414

br i1 %ifres9419, label %loop9413, label %after9413

loop9413:
; do set!
%val9420 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val9421 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val9420, i64 0, i32 1
%val9422 = load i8*, i8** %val9421
%val9423 = bitcast i8* %val9422 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val9423, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; apply closure 
%vval9424 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val9425 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval9424
%fPtr9426 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val9425, i32 0, i32 2
%ePtr9427 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val9425, i32 0, i32 1
%f9428 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr9426
%e9429 = load i8*, i8** %ePtr9427
%tzone9430 = load i8*, i8** %_impzPtr
%zone9431 = bitcast i8* %tzone9430 to %mzone*
%z9432 = bitcast %mzone* %zone9431 to i8*
tail call fastcc void %f9428(i8* %z9432, i8* %e9429)
; do set!
%val9434 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val9435 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val9434, i64 0, i32 2
%val9436 = load i8*, i8** %val9435
%val9437 = bitcast i8* %val9436 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val9437, {i64,i8*,i8*}** %hookPtr
%val9439 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val9440 = icmp eq {i64,i8*,i8*}* %val9439, null
br i1 %val9440, label %then9438, label %else9438

then9438:
%res9441 = call ccc i1 @impc_false()
store i1 %res9441, i1* %ifptr9438
br label %ifcont9438

else9438:
%res9442 = call ccc i1 @impc_true()
store i1 %res9442, i1* %ifptr9438
br label %ifcont9438

ifcont9438:
%ifres9443 = load i1, i1* %ifptr9438

br i1 %ifres9443, label %loop9413, label %after9413

after9413:
%val9445 = load %mzone*, %mzone** %zone6Ptr
call ccc void @llvm_zone_destroy(%mzone* %val9445)
%val9447 = load %String*, %String** %rescopy6Ptr
ret %String* %val9447

else9374:
%zone9450 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone9450)
%zone_ptr9451 = bitcast %mzone* %zone9450 to i8*
store i8* %zone_ptr9451, i8** %_impzPtr
%tzone9611 = load i8*, i8** %_impzPtr
%zone9612 = bitcast i8* %tzone9611 to %mzone*

; let assign value to symbol res7
%res7Ptr = alloca %String*
%tzone9616 = load i8*, i8** %_impzPtr
%zone9617 = bitcast i8* %tzone9616 to %mzone*

; let assign value to symbol zone7
%zone7Ptr = alloca %mzone*
%tzone9619 = load i8*, i8** %_impzPtr
%zone9620 = bitcast i8* %tzone9619 to %mzone*

; let assign value to symbol newz7
%newz7Ptr = alloca %mzone*
%tzone9453 = load i8*, i8** %_impzPtr
%zone9454 = bitcast i8* %tzone9453 to %mzone*

; let assign value to symbol xx_t_mst_s_35
%xx_t_mst_s_35Ptr = alloca i8*
%dat9452 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_35 = select i1 true, i8* %dat9452, i8* %dat9452
store i8* %xx_t_mst_s_35, i8** %xx_t_mst_s_35Ptr

%val9455 = load i8*, i8** %xx_t_mst_s_35Ptr
%var9456 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9457 = bitcast [13 x i8]* @gsxtmgraphics-pipeline393 to i8*

%val9458 = call i32 (i8*,i8*, ...) @sprintf(i8* %val9455, i8* %var9456, i8* %var9457)
%val9459 = load i8*, i8** %xx_t_mst_s_35Ptr
%res9460 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val9459)
%val9461 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9462 = getelementptr %xtm_lights, %xtm_lights* %val9461, i64 0, i32 0
%val9463 = load float*, float** %val9462
%res9464 = call fastcc %String* @toString_poly_W1N0cmluZyosZmxvYXQqXSo(float* %val9463)
%res9465 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res9460, %String* %res9464)
%tzone9467 = load i8*, i8** %_impzPtr
%zone9468 = bitcast i8* %tzone9467 to %mzone*

; let assign value to symbol xx_t_mst_s_36
%xx_t_mst_s_36Ptr = alloca i8*
%dat9466 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_36 = select i1 true, i8* %dat9466, i8* %dat9466
store i8* %xx_t_mst_s_36, i8** %xx_t_mst_s_36Ptr

%val9469 = load i8*, i8** %xx_t_mst_s_36Ptr
%var9470 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9471 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val9472 = call i32 (i8*,i8*, ...) @sprintf(i8* %val9469, i8* %var9470, i8* %var9471)
%val9473 = load i8*, i8** %xx_t_mst_s_36Ptr
%res9474 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val9473)
%res9475 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res9465, %String* %res9474)
%val9476 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9477 = getelementptr %xtm_lights, %xtm_lights* %val9476, i64 0, i32 1
%val9478 = load float*, float** %val9477
%res9479 = call fastcc %String* @toString_poly_W1N0cmluZyosZmxvYXQqXSo(float* %val9478)
%res9480 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res9475, %String* %res9479)
%tzone9482 = load i8*, i8** %_impzPtr
%zone9483 = bitcast i8* %tzone9482 to %mzone*

; let assign value to symbol xx_t_mst_s_37
%xx_t_mst_s_37Ptr = alloca i8*
%dat9481 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_37 = select i1 true, i8* %dat9481, i8* %dat9481
store i8* %xx_t_mst_s_37, i8** %xx_t_mst_s_37Ptr

%val9484 = load i8*, i8** %xx_t_mst_s_37Ptr
%var9485 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9486 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val9487 = call i32 (i8*,i8*, ...) @sprintf(i8* %val9484, i8* %var9485, i8* %var9486)
%val9488 = load i8*, i8** %xx_t_mst_s_37Ptr
%res9489 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val9488)
%res9490 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res9480, %String* %res9489)
%val9491 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9492 = getelementptr %xtm_lights, %xtm_lights* %val9491, i64 0, i32 2
%val9493 = load float*, float** %val9492
%res9494 = call fastcc %String* @toString_poly_W1N0cmluZyosZmxvYXQqXSo(float* %val9493)
%res9495 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res9490, %String* %res9494)
%tzone9497 = load i8*, i8** %_impzPtr
%zone9498 = bitcast i8* %tzone9497 to %mzone*

; let assign value to symbol xx_t_mst_s_38
%xx_t_mst_s_38Ptr = alloca i8*
%dat9496 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_38 = select i1 true, i8* %dat9496, i8* %dat9496
store i8* %xx_t_mst_s_38, i8** %xx_t_mst_s_38Ptr

%val9499 = load i8*, i8** %xx_t_mst_s_38Ptr
%var9500 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9501 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val9502 = call i32 (i8*,i8*, ...) @sprintf(i8* %val9499, i8* %var9500, i8* %var9501)
%val9503 = load i8*, i8** %xx_t_mst_s_38Ptr
%res9504 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val9503)
%res9505 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res9495, %String* %res9504)
%val9506 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9507 = getelementptr %xtm_lights, %xtm_lights* %val9506, i64 0, i32 3
%val9508 = load float*, float** %val9507
%res9509 = call fastcc %String* @toString_poly_W1N0cmluZyosZmxvYXQqXSo(float* %val9508)
%res9510 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res9505, %String* %res9509)
%tzone9512 = load i8*, i8** %_impzPtr
%zone9513 = bitcast i8* %tzone9512 to %mzone*

; let assign value to symbol xx_t_mst_s_39
%xx_t_mst_s_39Ptr = alloca i8*
%dat9511 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_39 = select i1 true, i8* %dat9511, i8* %dat9511
store i8* %xx_t_mst_s_39, i8** %xx_t_mst_s_39Ptr

%val9514 = load i8*, i8** %xx_t_mst_s_39Ptr
%var9515 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9516 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val9517 = call i32 (i8*,i8*, ...) @sprintf(i8* %val9514, i8* %var9515, i8* %var9516)
%val9518 = load i8*, i8** %xx_t_mst_s_39Ptr
%res9519 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val9518)
%res9520 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res9510, %String* %res9519)
%val9521 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9522 = getelementptr %xtm_lights, %xtm_lights* %val9521, i64 0, i32 4
%val9523 = load float*, float** %val9522
%res9524 = call fastcc %String* @toString_poly_W1N0cmluZyosZmxvYXQqXSo(float* %val9523)
%res9525 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res9520, %String* %res9524)
%tzone9527 = load i8*, i8** %_impzPtr
%zone9528 = bitcast i8* %tzone9527 to %mzone*

; let assign value to symbol xx_t_mst_s_40
%xx_t_mst_s_40Ptr = alloca i8*
%dat9526 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_40 = select i1 true, i8* %dat9526, i8* %dat9526
store i8* %xx_t_mst_s_40, i8** %xx_t_mst_s_40Ptr

%val9529 = load i8*, i8** %xx_t_mst_s_40Ptr
%var9530 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9531 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val9532 = call i32 (i8*,i8*, ...) @sprintf(i8* %val9529, i8* %var9530, i8* %var9531)
%val9533 = load i8*, i8** %xx_t_mst_s_40Ptr
%res9534 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val9533)
%res9535 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res9525, %String* %res9534)
%val9536 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9537 = getelementptr %xtm_lights, %xtm_lights* %val9536, i64 0, i32 5
%val9538 = load float*, float** %val9537
%res9539 = call fastcc %String* @toString_poly_W1N0cmluZyosZmxvYXQqXSo(float* %val9538)
%res9540 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res9535, %String* %res9539)
%tzone9542 = load i8*, i8** %_impzPtr
%zone9543 = bitcast i8* %tzone9542 to %mzone*

; let assign value to symbol xx_t_mst_s_41
%xx_t_mst_s_41Ptr = alloca i8*
%dat9541 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_41 = select i1 true, i8* %dat9541, i8* %dat9541
store i8* %xx_t_mst_s_41, i8** %xx_t_mst_s_41Ptr

%val9544 = load i8*, i8** %xx_t_mst_s_41Ptr
%var9545 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9546 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val9547 = call i32 (i8*,i8*, ...) @sprintf(i8* %val9544, i8* %var9545, i8* %var9546)
%val9548 = load i8*, i8** %xx_t_mst_s_41Ptr
%res9549 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val9548)
%res9550 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res9540, %String* %res9549)
%val9551 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9552 = getelementptr %xtm_lights, %xtm_lights* %val9551, i64 0, i32 6
%val9553 = load float*, float** %val9552
%res9554 = call fastcc %String* @toString_poly_W1N0cmluZyosZmxvYXQqXSo(float* %val9553)
%res9555 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res9550, %String* %res9554)
%tzone9557 = load i8*, i8** %_impzPtr
%zone9558 = bitcast i8* %tzone9557 to %mzone*

; let assign value to symbol xx_t_mst_s_42
%xx_t_mst_s_42Ptr = alloca i8*
%dat9556 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_42 = select i1 true, i8* %dat9556, i8* %dat9556
store i8* %xx_t_mst_s_42, i8** %xx_t_mst_s_42Ptr

%val9559 = load i8*, i8** %xx_t_mst_s_42Ptr
%var9560 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9561 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val9562 = call i32 (i8*,i8*, ...) @sprintf(i8* %val9559, i8* %var9560, i8* %var9561)
%val9563 = load i8*, i8** %xx_t_mst_s_42Ptr
%res9564 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val9563)
%res9565 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res9555, %String* %res9564)
%val9566 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9567 = getelementptr %xtm_lights, %xtm_lights* %val9566, i64 0, i32 7
%val9568 = load float*, float** %val9567
%res9569 = call fastcc %String* @toString_poly_W1N0cmluZyosZmxvYXQqXSo(float* %val9568)
%res9570 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res9565, %String* %res9569)
%tzone9572 = load i8*, i8** %_impzPtr
%zone9573 = bitcast i8* %tzone9572 to %mzone*

; let assign value to symbol xx_t_mst_s_43
%xx_t_mst_s_43Ptr = alloca i8*
%dat9571 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_43 = select i1 true, i8* %dat9571, i8* %dat9571
store i8* %xx_t_mst_s_43, i8** %xx_t_mst_s_43Ptr

%val9574 = load i8*, i8** %xx_t_mst_s_43Ptr
%var9575 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9576 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val9577 = call i32 (i8*,i8*, ...) @sprintf(i8* %val9574, i8* %var9575, i8* %var9576)
%val9578 = load i8*, i8** %xx_t_mst_s_43Ptr
%res9579 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val9578)
%res9580 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res9570, %String* %res9579)
%val9581 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9582 = getelementptr %xtm_lights, %xtm_lights* %val9581, i64 0, i32 8
%val9583 = load float*, float** %val9582
%res9584 = call fastcc %String* @toString_poly_W1N0cmluZyosZmxvYXQqXSo(float* %val9583)
%res9585 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res9580, %String* %res9584)
%tzone9587 = load i8*, i8** %_impzPtr
%zone9588 = bitcast i8* %tzone9587 to %mzone*

; let assign value to symbol xx_t_mst_s_44
%xx_t_mst_s_44Ptr = alloca i8*
%dat9586 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_44 = select i1 true, i8* %dat9586, i8* %dat9586
store i8* %xx_t_mst_s_44, i8** %xx_t_mst_s_44Ptr

%val9589 = load i8*, i8** %xx_t_mst_s_44Ptr
%var9590 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9591 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val9592 = call i32 (i8*,i8*, ...) @sprintf(i8* %val9589, i8* %var9590, i8* %var9591)
%val9593 = load i8*, i8** %xx_t_mst_s_44Ptr
%res9594 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val9593)
%res9595 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res9585, %String* %res9594)
%val9596 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9597 = getelementptr %xtm_lights, %xtm_lights* %val9596, i64 0, i32 9
%val9598 = load i32, i32* %val9597
%res9599 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val9598)
%res9600 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res9595, %String* %res9599)
%tzone9602 = load i8*, i8** %_impzPtr
%zone9603 = bitcast i8* %tzone9602 to %mzone*

; let assign value to symbol xx_t_mst_s_45
%xx_t_mst_s_45Ptr = alloca i8*
%dat9601 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_45 = select i1 true, i8* %dat9601, i8* %dat9601
store i8* %xx_t_mst_s_45, i8** %xx_t_mst_s_45Ptr

%val9604 = load i8*, i8** %xx_t_mst_s_45Ptr
%var9605 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9606 = bitcast [2 x i8]* @gsxtmgraphics-pipeline56 to i8*

%val9607 = call i32 (i8*,i8*, ...) @sprintf(i8* %val9604, i8* %var9605, i8* %var9606)
%val9608 = load i8*, i8** %xx_t_mst_s_45Ptr
%res9609 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val9608)
%res9610 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res9600, %String* %res9609)

; let value assignment
%res7 = select i1 true, %String* %res9610, %String* %res9610
store %String* %res7, %String** %res7Ptr

%oldzone9613 = call %mzone* @llvm_pop_zone_stack()
%newzone9614 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr9615 = bitcast %mzone* %newzone9614 to i8*
store i8* %zone_ptr9615, i8** %_impzPtr

; let value assignment
%zone7 = select i1 true, %mzone* %oldzone9613, %mzone* %oldzone9613
store %mzone* %zone7, %mzone** %zone7Ptr

%res9618 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz7 = select i1 true, %mzone* %res9618, %mzone* %res9618
store %mzone* %newz7, %mzone** %newz7Ptr

%tzone9625 = load i8*, i8** %_impzPtr
%zone9626 = bitcast i8* %tzone9625 to %mzone*

; let assign value to symbol rescopy7
%rescopy7Ptr = alloca %String*
%tzone9631 = load i8*, i8** %_impzPtr
%zone9632 = bitcast i8* %tzone9631 to %mzone*

; let assign value to symbol hook_s_46
%hook_s_46Ptr = alloca {i64,i8*,i8*}*
%tzone9634 = load i8*, i8** %_impzPtr
%zone9635 = bitcast i8* %tzone9634 to %mzone*

; let assign value to symbol f_s_47
%f_s_47Ptr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val9621 = load %String*, %String** %res7Ptr
%val9622 = load %mzone*, %mzone** %zone7Ptr
%val9623 = load %mzone*, %mzone** %newz7Ptr
%res9624 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val9621, %mzone* %val9622, %mzone* %val9623)

; let value assignment
%rescopy7 = select i1 true, %String* %res9624, %String* %res9624
store %String* %rescopy7, %String** %rescopy7Ptr

%val9627 = load %mzone*, %mzone** %zone7Ptr
; tuple ref
%val9628 = getelementptr %mzone, %mzone* %val9627, i64 0, i32 4
%val9629 = load i8*, i8** %val9628
%val9630 = bitcast i8* %val9629 to {i64,i8*,i8*}*

; let value assignment
%hook_s_46 = select i1 true, {i64,i8*,i8*}* %val9630, {i64,i8*,i8*}* %val9630
store {i64,i8*,i8*}* %hook_s_46, {i64,i8*,i8*}** %hook_s_46Ptr

%null9633 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f_s_47 = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null9633, {i8*, i8*, void (i8*, i8*)*}** %null9633
store {i8*, i8*, void (i8*, i8*)*}** %f_s_47, {i8*, i8*, void (i8*, i8*)*}*** %f_s_47Ptr

; promote local stack var allocations
%tzone9671 = load i8*, i8** %_impzPtr
%zone9672 = bitcast i8* %tzone9671 to %mzone*
%ifptr9661 = alloca i1
%ifptr9637 = alloca i1
; while loop
%val9638 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_46Ptr
%val9639 = icmp eq {i64,i8*,i8*}* %val9638, null
br i1 %val9639, label %then9637, label %else9637

then9637:
%res9640 = call ccc i1 @impc_false()
store i1 %res9640, i1* %ifptr9637
br label %ifcont9637

else9637:
%res9641 = call ccc i1 @impc_true()
store i1 %res9641, i1* %ifptr9637
br label %ifcont9637

ifcont9637:
%ifres9642 = load i1, i1* %ifptr9637

br i1 %ifres9642, label %loop9636, label %after9636

loop9636:
; do set!
%val9643 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_46Ptr
; tuple ref
%val9644 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val9643, i64 0, i32 1
%val9645 = load i8*, i8** %val9644
%val9646 = bitcast i8* %val9645 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val9646, {i8*, i8*, void (i8*, i8*)*}*** %f_s_47Ptr

; apply closure 
%vval9647 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %f_s_47Ptr
%val9648 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval9647
%fPtr9649 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val9648, i32 0, i32 2
%ePtr9650 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val9648, i32 0, i32 1
%f9651 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr9649
%e9652 = load i8*, i8** %ePtr9650
%tzone9653 = load i8*, i8** %_impzPtr
%zone9654 = bitcast i8* %tzone9653 to %mzone*
%z9655 = bitcast %mzone* %zone9654 to i8*
tail call fastcc void %f9651(i8* %z9655, i8* %e9652)
; do set!
%val9657 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_46Ptr
; tuple ref
%val9658 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val9657, i64 0, i32 2
%val9659 = load i8*, i8** %val9658
%val9660 = bitcast i8* %val9659 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val9660, {i64,i8*,i8*}** %hook_s_46Ptr
%val9662 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_46Ptr
%val9663 = icmp eq {i64,i8*,i8*}* %val9662, null
br i1 %val9663, label %then9661, label %else9661

then9661:
%res9664 = call ccc i1 @impc_false()
store i1 %res9664, i1* %ifptr9661
br label %ifcont9661

else9661:
%res9665 = call ccc i1 @impc_true()
store i1 %res9665, i1* %ifptr9661
br label %ifcont9661

ifcont9661:
%ifres9666 = load i1, i1* %ifptr9661

br i1 %ifres9666, label %loop9636, label %after9636

after9636:
%val9668 = load %mzone*, %mzone** %zone7Ptr
call ccc void @llvm_zone_destroy(%mzone* %val9668)
%val9670 = load %String*, %String** %rescopy7Ptr
ret %String* %val9670
}
@gsxtmgraphics-pipeline396 = hidden constant [97 x i8] c"toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}** @toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9692 = load i8*, i8** %_impzPtr
%zone9693 = bitcast i8* %tzone9692 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd
%dat_toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd = call i8* @llvm_zone_malloc(%mzone* %zone9693, i64 8)
%toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypdPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd to { i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}***
%tzone9673 = load i8*, i8** %_impzPtr
%zone9674 = bitcast i8* %tzone9673 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9674)
; malloc closure structure
%clsptr9675 = call i8* @llvm_zone_malloc(%mzone* %zone9674, i64 24)
%closure9676 = bitcast i8* %clsptr9675 to { i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}*

; malloc environment structure
%envptr9677 = call i8* @llvm_zone_malloc(%mzone* %zone9674, i64 8)
%environment9678 = bitcast i8* %envptr9677 to {{i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}***}*

; malloc closure address table
%addytable9679 = call %clsvar* @new_address_table()
%var9680 = bitcast [44 x i8]* @gsxtmgraphics-pipeline394 to i8*
%var9681 = bitcast [49 x i8]* @gsxtmgraphics-pipeline395 to i8*
%addytable9682 = call %clsvar* @add_address_table(%mzone* %zone9674, i8* %var9680, i32 0, i8* %var9681, i32 3, %clsvar* %addytable9679)
%address-table9683 = bitcast %clsvar* %addytable9682 to i8*

; insert table, function and environment into closure struct
%closure.table9686 = getelementptr { i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}, { i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}* %closure9676, i32 0, i32 0
store i8* %address-table9683, i8** %closure.table9686
%closure.env9687 = getelementptr { i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}, { i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}* %closure9676, i32 0, i32 1
store i8* %envptr9677, i8** %closure.env9687
%closure.func9688 = getelementptr { i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}, { i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}* %closure9676, i32 0, i32 2
store %String* (i8*, i8*, %xtm_lights*)* @toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd__9372, %String* (i8*, i8*, %xtm_lights*)** %closure.func9688
%closure_size9689 = call i64 @llvm_zone_mark_size(%mzone* %zone9674)
call void @llvm_zone_ptr_set_size(i8* %clsptr9675, i64 %closure_size9689)
%wrapper_ptr9690 = call i8* @llvm_zone_malloc(%mzone* %zone9674, i64 8)
%closure_wrapper9691 = bitcast i8* %wrapper_ptr9690 to { i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}**
store { i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}* %closure9676, { i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}** %closure_wrapper9691

; let value assignment
%toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd = select i1 true, { i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}** %closure_wrapper9691, { i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}** %closure_wrapper9691
store { i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}** %toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd, { i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}*** %toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypdPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd
%tmp_envptr9685 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}***}* %environment9678, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}*** %toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypdPtr, {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}**** %tmp_envptr9685


%val9694 = load {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}**, {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}*** %toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypdPtr
ret {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}** %val9694
}


@toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}** @toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd(%xtm_lights* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}*, {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %xtm_lights*)*,  %String* (i8*, i8*, %xtm_lights*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %xtm_lights* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd_native(%xtm_lights* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}*, {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %xtm_lights*)*,  %String* (i8*, i8*, %xtm_lights*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %xtm_lights* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var9695 = bitcast [97 x i8]* @gsxtmgraphics-pipeline396 to i8*
call i32 (i8*, ...) @printf(i8* %var9695)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %xtm_lights*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}*, {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %xtm_lights*)*,  %String* (i8*, i8*, %xtm_lights*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %xtm_lights* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%xtm_lights*}*
%arg_p_0 = getelementptr {%xtm_lights*}, {%xtm_lights*}* %fstruct, i32 0, i32 0
%arg_0 = load %xtm_lights*, %xtm_lights** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyoseHRtX2xpZ2h0cypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}*, {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, %String* (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %xtm_lights*)*,  %String* (i8*, i8*, %xtm_lights*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %xtm_lights* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline397 = hidden constant [37 x i8] c"print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd\00"
@gsxtmgraphics-pipeline398 = hidden constant [45 x i8] c"{i8*, i8*, void (i8*, i8*, %xtm_lights*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd__9696(i8* %_impz,i8* %_impenv, %xtm_lights* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9697 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %xtm_lights*)*}***}*
%print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %xtm_lights*)*}***}, {{i8*, i8*, void (i8*, i8*, %xtm_lights*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypdPtr = load {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}***, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}**** %print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypdPtr_

; setup arguments
%xPtr = alloca %xtm_lights*
store %xtm_lights* %x, %xtm_lights** %xPtr


%val9699 = load %xtm_lights*, %xtm_lights** %xPtr
%val9700 = icmp eq %xtm_lights* %val9699, null
br i1 %val9700, label %then9698, label %else9698

then9698:
%var9701 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9702 = bitcast [18 x i8]* @gsxtmgraphics-pipeline392 to i8*

%val9703 = call i32 (i8*, ...) @printf(i8* %var9701, i8* %var9702)
br label %ifcont9698

else9698:
%var9705 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9706 = bitcast [13 x i8]* @gsxtmgraphics-pipeline393 to i8*

%val9707 = call i32 (i8*, ...) @printf(i8* %var9705, i8* %var9706)
%val9708 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9709 = getelementptr %xtm_lights, %xtm_lights* %val9708, i64 0, i32 0
%val9710 = load float*, float** %val9709
call fastcc void @print_poly_W3ZvaWQsZmxvYXQqXSo(float* %val9710)
%var9712 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9713 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val9714 = call i32 (i8*, ...) @printf(i8* %var9712, i8* %var9713)
%val9715 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9716 = getelementptr %xtm_lights, %xtm_lights* %val9715, i64 0, i32 1
%val9717 = load float*, float** %val9716
call fastcc void @print_poly_W3ZvaWQsZmxvYXQqXSo(float* %val9717)
%var9719 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9720 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val9721 = call i32 (i8*, ...) @printf(i8* %var9719, i8* %var9720)
%val9722 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9723 = getelementptr %xtm_lights, %xtm_lights* %val9722, i64 0, i32 2
%val9724 = load float*, float** %val9723
call fastcc void @print_poly_W3ZvaWQsZmxvYXQqXSo(float* %val9724)
%var9726 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9727 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val9728 = call i32 (i8*, ...) @printf(i8* %var9726, i8* %var9727)
%val9729 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9730 = getelementptr %xtm_lights, %xtm_lights* %val9729, i64 0, i32 3
%val9731 = load float*, float** %val9730
call fastcc void @print_poly_W3ZvaWQsZmxvYXQqXSo(float* %val9731)
%var9733 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9734 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val9735 = call i32 (i8*, ...) @printf(i8* %var9733, i8* %var9734)
%val9736 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9737 = getelementptr %xtm_lights, %xtm_lights* %val9736, i64 0, i32 4
%val9738 = load float*, float** %val9737
call fastcc void @print_poly_W3ZvaWQsZmxvYXQqXSo(float* %val9738)
%var9740 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9741 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val9742 = call i32 (i8*, ...) @printf(i8* %var9740, i8* %var9741)
%val9743 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9744 = getelementptr %xtm_lights, %xtm_lights* %val9743, i64 0, i32 5
%val9745 = load float*, float** %val9744
call fastcc void @print_poly_W3ZvaWQsZmxvYXQqXSo(float* %val9745)
%var9747 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9748 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val9749 = call i32 (i8*, ...) @printf(i8* %var9747, i8* %var9748)
%val9750 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9751 = getelementptr %xtm_lights, %xtm_lights* %val9750, i64 0, i32 6
%val9752 = load float*, float** %val9751
call fastcc void @print_poly_W3ZvaWQsZmxvYXQqXSo(float* %val9752)
%var9754 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9755 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val9756 = call i32 (i8*, ...) @printf(i8* %var9754, i8* %var9755)
%val9757 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9758 = getelementptr %xtm_lights, %xtm_lights* %val9757, i64 0, i32 7
%val9759 = load float*, float** %val9758
call fastcc void @print_poly_W3ZvaWQsZmxvYXQqXSo(float* %val9759)
%var9761 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9762 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val9763 = call i32 (i8*, ...) @printf(i8* %var9761, i8* %var9762)
%val9764 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9765 = getelementptr %xtm_lights, %xtm_lights* %val9764, i64 0, i32 8
%val9766 = load float*, float** %val9765
call fastcc void @print_poly_W3ZvaWQsZmxvYXQqXSo(float* %val9766)
%var9768 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9769 = bitcast [2 x i8]* @gsxtmgraphics-pipeline55 to i8*

%val9770 = call i32 (i8*, ...) @printf(i8* %var9768, i8* %var9769)
%val9771 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9772 = getelementptr %xtm_lights, %xtm_lights* %val9771, i64 0, i32 9
%val9773 = load i32, i32* %val9772
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val9773)
%var9775 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var9776 = bitcast [2 x i8]* @gsxtmgraphics-pipeline56 to i8*

%val9777 = call i32 (i8*, ...) @printf(i8* %var9775, i8* %var9776)
br label %ifcont9698

ifcont9698:
ret void
}
@gsxtmgraphics-pipeline399 = hidden constant [90 x i8] c"print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** @print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9799 = load i8*, i8** %_impzPtr
%zone9800 = bitcast i8* %tzone9799 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd
%dat_print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd = call i8* @llvm_zone_malloc(%mzone* %zone9800, i64 8)
%print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd to { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}***
%tzone9780 = load i8*, i8** %_impzPtr
%zone9781 = bitcast i8* %tzone9780 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9781)
; malloc closure structure
%clsptr9782 = call i8* @llvm_zone_malloc(%mzone* %zone9781, i64 24)
%closure9783 = bitcast i8* %clsptr9782 to { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}*

; malloc environment structure
%envptr9784 = call i8* @llvm_zone_malloc(%mzone* %zone9781, i64 8)
%environment9785 = bitcast i8* %envptr9784 to {{i8*, i8*, void (i8*, i8*, %xtm_lights*)*}***}*

; malloc closure address table
%addytable9786 = call %clsvar* @new_address_table()
%var9787 = bitcast [37 x i8]* @gsxtmgraphics-pipeline397 to i8*
%var9788 = bitcast [45 x i8]* @gsxtmgraphics-pipeline398 to i8*
%addytable9789 = call %clsvar* @add_address_table(%mzone* %zone9781, i8* %var9787, i32 0, i8* %var9788, i32 3, %clsvar* %addytable9786)
%address-table9790 = bitcast %clsvar* %addytable9789 to i8*

; insert table, function and environment into closure struct
%closure.table9793 = getelementptr { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure9783, i32 0, i32 0
store i8* %address-table9790, i8** %closure.table9793
%closure.env9794 = getelementptr { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure9783, i32 0, i32 1
store i8* %envptr9784, i8** %closure.env9794
%closure.func9795 = getelementptr { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure9783, i32 0, i32 2
store void (i8*, i8*, %xtm_lights*)* @print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd__9696, void (i8*, i8*, %xtm_lights*)** %closure.func9795
%closure_size9796 = call i64 @llvm_zone_mark_size(%mzone* %zone9781)
call void @llvm_zone_ptr_set_size(i8* %clsptr9782, i64 %closure_size9796)
%wrapper_ptr9797 = call i8* @llvm_zone_malloc(%mzone* %zone9781, i64 8)
%closure_wrapper9798 = bitcast i8* %wrapper_ptr9797 to { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}**
store { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure9783, { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** %closure_wrapper9798

; let value assignment
%print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd = select i1 true, { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** %closure_wrapper9798, { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** %closure_wrapper9798
store { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** %print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd, { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}*** %print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd
%tmp_envptr9792 = getelementptr {{i8*, i8*, void (i8*, i8*, %xtm_lights*)*}***}, {{i8*, i8*, void (i8*, i8*, %xtm_lights*)*}***}* %environment9785, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}*** %print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypdPtr, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}**** %tmp_envptr9792


%val9801 = load {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}**, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}*** %print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypdPtr
ret {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** %val9801
}


@print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** @print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd(%xtm_lights* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}*, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %xtm_lights*)*,  void (i8*, i8*, %xtm_lights*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %xtm_lights* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_native(%xtm_lights* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}*, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %xtm_lights*)*,  void (i8*, i8*, %xtm_lights*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %xtm_lights* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var9802 = bitcast [90 x i8]* @gsxtmgraphics-pipeline399 to i8*
call i32 (i8*, ...) @printf(i8* %var9802)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %xtm_lights*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}*, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %xtm_lights*)*,  void (i8*, i8*, %xtm_lights*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %xtm_lights* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%xtm_lights*}*
%arg_p_0 = getelementptr {%xtm_lights*}, {%xtm_lights*}* %fstruct, i32 0, i32 0
%arg_0 = load %xtm_lights*, %xtm_lights** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}*, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %xtm_lights*)*,  void (i8*, i8*, %xtm_lights*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %xtm_lights* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline400 = hidden constant [128 x i8] c"xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ\00"
@gsxtmgraphics-pipeline401 = hidden constant [115 x i8] c"{i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**\00"
define dllexport fastcc %xtm_lights @xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ__9803(i8* %_impz,i8* %_impenv, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8, i32 %arg_9) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9804 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}*
%xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQPtr_ = getelementptr {{i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}, {{i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}* %impenv, i32 0, i32 0
%xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQPtr = load {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***, {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**** %xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQPtr_

; setup arguments
%arg_0Ptr = alloca float*
store float* %arg_0, float** %arg_0Ptr
%arg_1Ptr = alloca float*
store float* %arg_1, float** %arg_1Ptr
%arg_2Ptr = alloca float*
store float* %arg_2, float** %arg_2Ptr
%arg_3Ptr = alloca float*
store float* %arg_3, float** %arg_3Ptr
%arg_4Ptr = alloca float*
store float* %arg_4, float** %arg_4Ptr
%arg_5Ptr = alloca float*
store float* %arg_5, float** %arg_5Ptr
%arg_6Ptr = alloca float*
store float* %arg_6, float** %arg_6Ptr
%arg_7Ptr = alloca float*
store float* %arg_7, float** %arg_7Ptr
%arg_8Ptr = alloca float*
store float* %arg_8, float** %arg_8Ptr
%arg_9Ptr = alloca i32
store i32 %arg_9, i32* %arg_9Ptr


%tzone9806 = load i8*, i8** %_impzPtr
%zone9807 = bitcast i8* %tzone9806 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %xtm_lights*
%dat9805 = alloca %xtm_lights, align 16

; let value assignment
%obj = select i1 true, %xtm_lights* %dat9805, %xtm_lights* %dat9805
store %xtm_lights* %obj, %xtm_lights** %objPtr

%val9808 = load %xtm_lights*, %xtm_lights** %objPtr
%val9809 = load float*, float** %arg_0Ptr
; set tuple
%val9810 = getelementptr %xtm_lights, %xtm_lights* %val9808, i64 0, i32 0
store float* %val9809, float** %val9810
%val9811 = load %xtm_lights*, %xtm_lights** %objPtr
%val9812 = load float*, float** %arg_1Ptr
; set tuple
%val9813 = getelementptr %xtm_lights, %xtm_lights* %val9811, i64 0, i32 1
store float* %val9812, float** %val9813
%val9814 = load %xtm_lights*, %xtm_lights** %objPtr
%val9815 = load float*, float** %arg_2Ptr
; set tuple
%val9816 = getelementptr %xtm_lights, %xtm_lights* %val9814, i64 0, i32 2
store float* %val9815, float** %val9816
%val9817 = load %xtm_lights*, %xtm_lights** %objPtr
%val9818 = load float*, float** %arg_3Ptr
; set tuple
%val9819 = getelementptr %xtm_lights, %xtm_lights* %val9817, i64 0, i32 3
store float* %val9818, float** %val9819
%val9820 = load %xtm_lights*, %xtm_lights** %objPtr
%val9821 = load float*, float** %arg_4Ptr
; set tuple
%val9822 = getelementptr %xtm_lights, %xtm_lights* %val9820, i64 0, i32 4
store float* %val9821, float** %val9822
%val9823 = load %xtm_lights*, %xtm_lights** %objPtr
%val9824 = load float*, float** %arg_5Ptr
; set tuple
%val9825 = getelementptr %xtm_lights, %xtm_lights* %val9823, i64 0, i32 5
store float* %val9824, float** %val9825
%val9826 = load %xtm_lights*, %xtm_lights** %objPtr
%val9827 = load float*, float** %arg_6Ptr
; set tuple
%val9828 = getelementptr %xtm_lights, %xtm_lights* %val9826, i64 0, i32 6
store float* %val9827, float** %val9828
%val9829 = load %xtm_lights*, %xtm_lights** %objPtr
%val9830 = load float*, float** %arg_7Ptr
; set tuple
%val9831 = getelementptr %xtm_lights, %xtm_lights* %val9829, i64 0, i32 7
store float* %val9830, float** %val9831
%val9832 = load %xtm_lights*, %xtm_lights** %objPtr
%val9833 = load float*, float** %arg_8Ptr
; set tuple
%val9834 = getelementptr %xtm_lights, %xtm_lights* %val9832, i64 0, i32 8
store float* %val9833, float** %val9834
%val9835 = load %xtm_lights*, %xtm_lights** %objPtr
%val9836 = load i32, i32* %arg_9Ptr
; set tuple
%val9837 = getelementptr %xtm_lights, %xtm_lights* %val9835, i64 0, i32 9
store i32 %val9836, i32* %val9837
%val9838 = load %xtm_lights*, %xtm_lights** %objPtr
; pointer ref
%val9839 = getelementptr %xtm_lights, %xtm_lights* %val9838, i64 0
%val9840 = load %xtm_lights, %xtm_lights* %val9839
ret %xtm_lights %val9840
}
@gsxtmgraphics-pipeline402 = hidden constant [181 x i8] c"xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** @xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9860 = load i8*, i8** %_impzPtr
%zone9861 = bitcast i8* %tzone9860 to %mzone*

; let assign value to symbol xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ
%dat_xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone9861, i64 8)
%xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQPtr = bitcast i8* %dat_xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ to { i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***
%tzone9841 = load i8*, i8** %_impzPtr
%zone9842 = bitcast i8* %tzone9841 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9842)
; malloc closure structure
%clsptr9843 = call i8* @llvm_zone_malloc(%mzone* %zone9842, i64 24)
%closure9844 = bitcast i8* %clsptr9843 to { i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*

; malloc environment structure
%envptr9845 = call i8* @llvm_zone_malloc(%mzone* %zone9842, i64 8)
%environment9846 = bitcast i8* %envptr9845 to {{i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}*

; malloc closure address table
%addytable9847 = call %clsvar* @new_address_table()
%var9848 = bitcast [128 x i8]* @gsxtmgraphics-pipeline400 to i8*
%var9849 = bitcast [115 x i8]* @gsxtmgraphics-pipeline401 to i8*
%addytable9850 = call %clsvar* @add_address_table(%mzone* %zone9842, i8* %var9848, i32 0, i8* %var9849, i32 3, %clsvar* %addytable9847)
%address-table9851 = bitcast %clsvar* %addytable9850 to i8*

; insert table, function and environment into closure struct
%closure.table9854 = getelementptr { i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, { i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure9844, i32 0, i32 0
store i8* %address-table9851, i8** %closure.table9854
%closure.env9855 = getelementptr { i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, { i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure9844, i32 0, i32 1
store i8* %envptr9845, i8** %closure.env9855
%closure.func9856 = getelementptr { i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, { i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure9844, i32 0, i32 2
store %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)* @xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ__9803, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)** %closure.func9856
%closure_size9857 = call i64 @llvm_zone_mark_size(%mzone* %zone9842)
call void @llvm_zone_ptr_set_size(i8* %clsptr9843, i64 %closure_size9857)
%wrapper_ptr9858 = call i8* @llvm_zone_malloc(%mzone* %zone9842, i64 8)
%closure_wrapper9859 = bitcast i8* %wrapper_ptr9858 to { i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**
store { i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure9844, { i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_wrapper9859

; let value assignment
%xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ = select i1 true, { i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_wrapper9859, { i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_wrapper9859
store { i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ, { i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*** %xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQPtr

; add data to environment
; don't need to alloc for env var xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ
%tmp_envptr9853 = getelementptr {{i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}, {{i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}***}* %environment9846, i32 0, i32 0
store {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*** %xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQPtr, {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**** %tmp_envptr9853


%val9862 = load {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**, {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*** %xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQPtr
ret {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %val9862
}


@xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** @xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %xtm_lights @xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ(float* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float* %arg_5,float* %arg_6,float* %arg_7,float* %arg_8,i32 %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**
%closure = load {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*, {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*,  %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8, i32 %arg_9)
ret %xtm_lights %result
}


define dllexport ccc %xtm_lights @xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ_native(float* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float* %arg_5,float* %arg_6,float* %arg_7,float* %arg_8,i32 %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**
%closure = load {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*, {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*,  %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8, i32 %arg_9)
ret %xtm_lights %result
}


define dllexport ccc void @xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}*
%arg_p_0 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 5
%arg_5 = load float*, float** %arg_p_5
%arg_p_6 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 6
%arg_6 = load float*, float** %arg_p_6
%arg_p_7 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 7
%arg_7 = load float*, float** %arg_p_7
%arg_p_8 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 8
%arg_8 = load float*, float** %arg_p_8
%arg_p_9 = getelementptr {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}, {float*, float*, float*, float*, float*, float*, float*, float*, float*, i32}* %fstruct, i32 0, i32 9
%arg_9 = load i32, i32* %arg_p_9
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lights_val_adhoc_W3h0bV9saWdodHMsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}**
%closure = load {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}*, {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}, {i8*, i8*, %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)*,  %xtm_lights (i8*, i8*, float*, float*, float*, float*, float*, float*, float*, float*, float*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5, float* %arg_6, float* %arg_7, float* %arg_8, i32 %arg_9)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline403 = hidden constant [47 x i8] c"hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ\00"
@gsxtmgraphics-pipeline404 = hidden constant [53 x i8] c"{i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}**\00"
define dllexport fastcc %xtm_lights* @hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ__9873(i8* %_impz,i8* %_impenv, %xtm_lights* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9874 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}***}*
%hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQPtr_ = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQPtr = load {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}***, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}**** %hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQPtr_

; setup arguments
%xPtr = alloca %xtm_lights*
store %xtm_lights* %x, %xtm_lights** %xPtr


%tzone9877 = load i8*, i8** %_impzPtr
%zone9878 = bitcast i8* %tzone9877 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %xtm_lights*
%dat9875 = call i8* @malloc(i64 80)
call i8* @memset(i8* %dat9875, i32 0, i64 80)
%val9876 = bitcast i8* %dat9875 to %xtm_lights*

; let value assignment
%obj = select i1 true, %xtm_lights* %val9876, %xtm_lights* %val9876
store %xtm_lights* %obj, %xtm_lights** %objPtr

%val9879 = load %xtm_lights*, %xtm_lights** %objPtr
%val9880 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9881 = getelementptr %xtm_lights, %xtm_lights* %val9880, i64 0, i32 0
%val9882 = load float*, float** %val9881
; set tuple
%val9883 = getelementptr %xtm_lights, %xtm_lights* %val9879, i64 0, i32 0
store float* %val9882, float** %val9883
%val9884 = load %xtm_lights*, %xtm_lights** %objPtr
%val9885 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9886 = getelementptr %xtm_lights, %xtm_lights* %val9885, i64 0, i32 1
%val9887 = load float*, float** %val9886
; set tuple
%val9888 = getelementptr %xtm_lights, %xtm_lights* %val9884, i64 0, i32 1
store float* %val9887, float** %val9888
%val9889 = load %xtm_lights*, %xtm_lights** %objPtr
%val9890 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9891 = getelementptr %xtm_lights, %xtm_lights* %val9890, i64 0, i32 2
%val9892 = load float*, float** %val9891
; set tuple
%val9893 = getelementptr %xtm_lights, %xtm_lights* %val9889, i64 0, i32 2
store float* %val9892, float** %val9893
%val9894 = load %xtm_lights*, %xtm_lights** %objPtr
%val9895 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9896 = getelementptr %xtm_lights, %xtm_lights* %val9895, i64 0, i32 3
%val9897 = load float*, float** %val9896
; set tuple
%val9898 = getelementptr %xtm_lights, %xtm_lights* %val9894, i64 0, i32 3
store float* %val9897, float** %val9898
%val9899 = load %xtm_lights*, %xtm_lights** %objPtr
%val9900 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9901 = getelementptr %xtm_lights, %xtm_lights* %val9900, i64 0, i32 4
%val9902 = load float*, float** %val9901
; set tuple
%val9903 = getelementptr %xtm_lights, %xtm_lights* %val9899, i64 0, i32 4
store float* %val9902, float** %val9903
%val9904 = load %xtm_lights*, %xtm_lights** %objPtr
%val9905 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9906 = getelementptr %xtm_lights, %xtm_lights* %val9905, i64 0, i32 5
%val9907 = load float*, float** %val9906
; set tuple
%val9908 = getelementptr %xtm_lights, %xtm_lights* %val9904, i64 0, i32 5
store float* %val9907, float** %val9908
%val9909 = load %xtm_lights*, %xtm_lights** %objPtr
%val9910 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9911 = getelementptr %xtm_lights, %xtm_lights* %val9910, i64 0, i32 6
%val9912 = load float*, float** %val9911
; set tuple
%val9913 = getelementptr %xtm_lights, %xtm_lights* %val9909, i64 0, i32 6
store float* %val9912, float** %val9913
%val9914 = load %xtm_lights*, %xtm_lights** %objPtr
%val9915 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9916 = getelementptr %xtm_lights, %xtm_lights* %val9915, i64 0, i32 7
%val9917 = load float*, float** %val9916
; set tuple
%val9918 = getelementptr %xtm_lights, %xtm_lights* %val9914, i64 0, i32 7
store float* %val9917, float** %val9918
%val9919 = load %xtm_lights*, %xtm_lights** %objPtr
%val9920 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9921 = getelementptr %xtm_lights, %xtm_lights* %val9920, i64 0, i32 8
%val9922 = load float*, float** %val9921
; set tuple
%val9923 = getelementptr %xtm_lights, %xtm_lights* %val9919, i64 0, i32 8
store float* %val9922, float** %val9923
%val9924 = load %xtm_lights*, %xtm_lights** %objPtr
%val9925 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val9926 = getelementptr %xtm_lights, %xtm_lights* %val9925, i64 0, i32 9
%val9927 = load i32, i32* %val9926
; set tuple
%val9928 = getelementptr %xtm_lights, %xtm_lights* %val9924, i64 0, i32 9
store i32 %val9927, i32* %val9928
%val9929 = load %xtm_lights*, %xtm_lights** %objPtr
ret %xtm_lights* %val9929
}
@gsxtmgraphics-pipeline405 = hidden constant [100 x i8] c"hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}** @hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9949 = load i8*, i8** %_impzPtr
%zone9950 = bitcast i8* %tzone9949 to %mzone*

; let assign value to symbol hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ
%dat_hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ = call i8* @llvm_zone_malloc(%mzone* %zone9950, i64 8)
%hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQPtr = bitcast i8* %dat_hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ to { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}***
%tzone9930 = load i8*, i8** %_impzPtr
%zone9931 = bitcast i8* %tzone9930 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9931)
; malloc closure structure
%clsptr9932 = call i8* @llvm_zone_malloc(%mzone* %zone9931, i64 24)
%closure9933 = bitcast i8* %clsptr9932 to { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}*

; malloc environment structure
%envptr9934 = call i8* @llvm_zone_malloc(%mzone* %zone9931, i64 8)
%environment9935 = bitcast i8* %envptr9934 to {{i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}***}*

; malloc closure address table
%addytable9936 = call %clsvar* @new_address_table()
%var9937 = bitcast [47 x i8]* @gsxtmgraphics-pipeline403 to i8*
%var9938 = bitcast [53 x i8]* @gsxtmgraphics-pipeline404 to i8*
%addytable9939 = call %clsvar* @add_address_table(%mzone* %zone9931, i8* %var9937, i32 0, i8* %var9938, i32 3, %clsvar* %addytable9936)
%address-table9940 = bitcast %clsvar* %addytable9939 to i8*

; insert table, function and environment into closure struct
%closure.table9943 = getelementptr { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}, { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}* %closure9933, i32 0, i32 0
store i8* %address-table9940, i8** %closure.table9943
%closure.env9944 = getelementptr { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}, { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}* %closure9933, i32 0, i32 1
store i8* %envptr9934, i8** %closure.env9944
%closure.func9945 = getelementptr { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}, { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}* %closure9933, i32 0, i32 2
store %xtm_lights* (i8*, i8*, %xtm_lights*)* @hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ__9873, %xtm_lights* (i8*, i8*, %xtm_lights*)** %closure.func9945
%closure_size9946 = call i64 @llvm_zone_mark_size(%mzone* %zone9931)
call void @llvm_zone_ptr_set_size(i8* %clsptr9932, i64 %closure_size9946)
%wrapper_ptr9947 = call i8* @llvm_zone_malloc(%mzone* %zone9931, i64 8)
%closure_wrapper9948 = bitcast i8* %wrapper_ptr9947 to { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}**
store { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}* %closure9933, { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}** %closure_wrapper9948

; let value assignment
%hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ = select i1 true, { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}** %closure_wrapper9948, { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}** %closure_wrapper9948
store { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}** %hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ, { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}*** %hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ
%tmp_envptr9942 = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}***}* %environment9935, i32 0, i32 0
store {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}*** %hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQPtr, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}**** %tmp_envptr9942


%val9951 = load {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}**, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}*** %hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQPtr
ret {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}** %val9951
}


@hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}** @hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %xtm_lights* @hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ(%xtm_lights* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*, %xtm_lights*)*,  %xtm_lights* (i8*, i8*, %xtm_lights*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee, %xtm_lights* %arg_0)
ret %xtm_lights* %result
}


define dllexport ccc %xtm_lights* @hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ_native(%xtm_lights* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*, %xtm_lights*)*,  %xtm_lights* (i8*, i8*, %xtm_lights*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee, %xtm_lights* %arg_0)
ret %xtm_lights* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var9952 = bitcast [100 x i8]* @gsxtmgraphics-pipeline405 to i8*
call i32 (i8*, ...) @printf(i8* %var9952)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %xtm_lights*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*, %xtm_lights*)*,  %xtm_lights* (i8*, i8*, %xtm_lights*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee, %xtm_lights* %arg_0)
%tmpres = bitcast %xtm_lights* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%xtm_lights*}*
%arg_p_0 = getelementptr {%xtm_lights*}, {%xtm_lights*}* %fstruct, i32 0, i32 0
%arg_0 = load %xtm_lights*, %xtm_lights** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*, %xtm_lights*)*,  %xtm_lights* (i8*, i8*, %xtm_lights*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee, %xtm_lights* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline406 = hidden constant [37 x i8] c"hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd__9953(i8* %_impz,i8* %_impenv, %xtm_lights* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9954 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %xtm_lights*)*}***}*
%hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %xtm_lights*)*}***}, {{i8*, i8*, void (i8*, i8*, %xtm_lights*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypdPtr = load {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}***, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}**** %hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypdPtr_

; setup arguments
%xPtr = alloca %xtm_lights*
store %xtm_lights* %x, %xtm_lights** %xPtr


%val9955 = load %xtm_lights*, %xtm_lights** %xPtr
%val9956 = bitcast %xtm_lights* %val9955 to i8*
call ccc void @free(i8* %val9956)
ret void
}
@gsxtmgraphics-pipeline407 = hidden constant [90 x i8] c"hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** @hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone9978 = load i8*, i8** %_impzPtr
%zone9979 = bitcast i8* %tzone9978 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd
%dat_hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd = call i8* @llvm_zone_malloc(%mzone* %zone9979, i64 8)
%hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypdPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd to { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}***
%tzone9959 = load i8*, i8** %_impzPtr
%zone9960 = bitcast i8* %tzone9959 to %mzone*
call void @llvm_zone_mark(%mzone* %zone9960)
; malloc closure structure
%clsptr9961 = call i8* @llvm_zone_malloc(%mzone* %zone9960, i64 24)
%closure9962 = bitcast i8* %clsptr9961 to { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}*

; malloc environment structure
%envptr9963 = call i8* @llvm_zone_malloc(%mzone* %zone9960, i64 8)
%environment9964 = bitcast i8* %envptr9963 to {{i8*, i8*, void (i8*, i8*, %xtm_lights*)*}***}*

; malloc closure address table
%addytable9965 = call %clsvar* @new_address_table()
%var9966 = bitcast [37 x i8]* @gsxtmgraphics-pipeline406 to i8*
%var9967 = bitcast [45 x i8]* @gsxtmgraphics-pipeline398 to i8*
%addytable9968 = call %clsvar* @add_address_table(%mzone* %zone9960, i8* %var9966, i32 0, i8* %var9967, i32 3, %clsvar* %addytable9965)
%address-table9969 = bitcast %clsvar* %addytable9968 to i8*

; insert table, function and environment into closure struct
%closure.table9972 = getelementptr { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure9962, i32 0, i32 0
store i8* %address-table9969, i8** %closure.table9972
%closure.env9973 = getelementptr { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure9962, i32 0, i32 1
store i8* %envptr9963, i8** %closure.env9973
%closure.func9974 = getelementptr { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure9962, i32 0, i32 2
store void (i8*, i8*, %xtm_lights*)* @hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd__9953, void (i8*, i8*, %xtm_lights*)** %closure.func9974
%closure_size9975 = call i64 @llvm_zone_mark_size(%mzone* %zone9960)
call void @llvm_zone_ptr_set_size(i8* %clsptr9961, i64 %closure_size9975)
%wrapper_ptr9976 = call i8* @llvm_zone_malloc(%mzone* %zone9960, i64 8)
%closure_wrapper9977 = bitcast i8* %wrapper_ptr9976 to { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}**
store { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure9962, { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** %closure_wrapper9977

; let value assignment
%hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd = select i1 true, { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** %closure_wrapper9977, { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** %closure_wrapper9977
store { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** %hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd, { i8*, i8*, void (i8*, i8*, %xtm_lights*)*}*** %hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypdPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd
%tmp_envptr9971 = getelementptr {{i8*, i8*, void (i8*, i8*, %xtm_lights*)*}***}, {{i8*, i8*, void (i8*, i8*, %xtm_lights*)*}***}* %environment9964, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}*** %hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypdPtr, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}**** %tmp_envptr9971


%val9980 = load {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}**, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}*** %hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypdPtr
ret {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** %val9980
}


@hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** @hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd(%xtm_lights* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}*, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %xtm_lights*)*,  void (i8*, i8*, %xtm_lights*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %xtm_lights* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_native(%xtm_lights* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}*, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %xtm_lights*)*,  void (i8*, i8*, %xtm_lights*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %xtm_lights* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var9981 = bitcast [90 x i8]* @gsxtmgraphics-pipeline407 to i8*
call i32 (i8*, ...) @printf(i8* %var9981)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %xtm_lights*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}*, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %xtm_lights*)*,  void (i8*, i8*, %xtm_lights*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %xtm_lights* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%xtm_lights*}*
%arg_p_0 = getelementptr {%xtm_lights*}, {%xtm_lights*}* %fstruct, i32 0, i32 0
%arg_0 = load %xtm_lights*, %xtm_lights** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQseHRtX2xpZ2h0cypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}*, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}, {i8*, i8*, void (i8*, i8*, %xtm_lights*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %xtm_lights*)*,  void (i8*, i8*, %xtm_lights*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %xtm_lights* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline408 = hidden constant [65 x i8] c"zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd\00"
@gsxtmgraphics-pipeline409 = hidden constant [71 x i8] c"{i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %xtm_lights* @zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd__9982(i8* %_impz,i8* %_impenv, %xtm_lights* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone9983 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpdPtr = load {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}***, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpdPtr_

; setup arguments
%xPtr = alloca %xtm_lights*
store %xtm_lights* %x, %xtm_lights** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val9985 = load %mzone*, %mzone** %fromzPtr
%val9986 = load %xtm_lights*, %xtm_lights** %xPtr
%val9987 = bitcast %xtm_lights* %val9986 to i8*
%res9988 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val9985, i8* %val9987)
br i1 %res9988, label %then9984, label %else9984

then9984:
%val9989 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val9989)
%zone_ptr9990 = bitcast %mzone* %val9989 to i8*
store i8* %zone_ptr9990, i8** %_impzPtr
%tzone9996 = load i8*, i8** %_impzPtr
%zone9997 = bitcast i8* %tzone9996 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %xtm_lights*
%tzone9992 = load i8*, i8** %_impzPtr
%zone9993 = bitcast i8* %tzone9992 to %mzone*
%dat9994 = call i8* @llvm_zone_malloc(%mzone* %zone9993, i64 80)
call i8* @memset(i8* %dat9994, i32 0, i64 80)
%val9995 = bitcast i8* %dat9994 to %xtm_lights*

; let value assignment
%obj = select i1 true, %xtm_lights* %val9995, %xtm_lights* %val9995
store %xtm_lights* %obj, %xtm_lights** %objPtr

; promote local stack var allocations
%tzone10268 = load i8*, i8** %_impzPtr
%zone10269 = bitcast i8* %tzone10268 to %mzone*
%ifptr10230 = alloca float*
%ifptr10201 = alloca float*
%ifptr10172 = alloca float*
%ifptr10143 = alloca float*
%ifptr10114 = alloca float*
%ifptr10085 = alloca float*
%ifptr10056 = alloca float*
%ifptr10027 = alloca float*
%ifptr9998 = alloca float*
%val9999 = load %mzone*, %mzone** %fromzPtr
%val10000 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10001 = getelementptr %xtm_lights, %xtm_lights* %val10000, i64 0, i32 0
%val10002 = load float*, float** %val10001
%val10003 = bitcast float* %val10002 to i8*
%res10004 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val9999, i8* %val10003)
br i1 %res10004, label %then9998, label %else9998

then9998:
%tzone10009 = load i8*, i8** %_impzPtr
%zone10010 = bitcast i8* %tzone10009 to %mzone*

; let assign value to symbol newptr
%newptrPtr = alloca float*
%tzone10005 = load i8*, i8** %_impzPtr
%zone10006 = bitcast i8* %tzone10005 to %mzone*
%dat10007 = call i8* @llvm_zone_malloc(%mzone* %zone10006, i64 4)
call i8* @memset(i8* %dat10007, i32 0, i64 4)
%val10008 = bitcast i8* %dat10007 to float*

; let value assignment
%newptr = select i1 true, float* %val10008, float* %val10008
store float* %newptr, float** %newptrPtr

%val10011 = load float*, float** %newptrPtr
%val10012 = bitcast float* %val10011 to i8*
%val10013 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10014 = getelementptr %xtm_lights, %xtm_lights* %val10013, i64 0, i32 0
%val10015 = load float*, float** %val10014
%val10016 = bitcast float* %val10015 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val10012, i8* %val10016, i64 4, i32 1, i1 0)
%val10018 = load %xtm_lights*, %xtm_lights** %objPtr
%val10019 = load float*, float** %newptrPtr
; set tuple
%val10020 = getelementptr %xtm_lights, %xtm_lights* %val10018, i64 0, i32 0
store float* %val10019, float** %val10020
store float* %val10019, float** %ifptr9998
br label %ifcont9998

else9998:
%val10021 = load %xtm_lights*, %xtm_lights** %objPtr
%val10022 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10023 = getelementptr %xtm_lights, %xtm_lights* %val10022, i64 0, i32 0
%val10024 = load float*, float** %val10023
; set tuple
%val10025 = getelementptr %xtm_lights, %xtm_lights* %val10021, i64 0, i32 0
store float* %val10024, float** %val10025
store float* %val10024, float** %ifptr9998
br label %ifcont9998

ifcont9998:
%ifres10026 = load float*, float** %ifptr9998

%val10028 = load %mzone*, %mzone** %fromzPtr
%val10029 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10030 = getelementptr %xtm_lights, %xtm_lights* %val10029, i64 0, i32 1
%val10031 = load float*, float** %val10030
%val10032 = bitcast float* %val10031 to i8*
%res10033 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val10028, i8* %val10032)
br i1 %res10033, label %then10027, label %else10027

then10027:
%tzone10038 = load i8*, i8** %_impzPtr
%zone10039 = bitcast i8* %tzone10038 to %mzone*

; let assign value to symbol newptr_s_48
%newptr_s_48Ptr = alloca float*
%tzone10034 = load i8*, i8** %_impzPtr
%zone10035 = bitcast i8* %tzone10034 to %mzone*
%dat10036 = call i8* @llvm_zone_malloc(%mzone* %zone10035, i64 4)
call i8* @memset(i8* %dat10036, i32 0, i64 4)
%val10037 = bitcast i8* %dat10036 to float*

; let value assignment
%newptr_s_48 = select i1 true, float* %val10037, float* %val10037
store float* %newptr_s_48, float** %newptr_s_48Ptr

%val10040 = load float*, float** %newptr_s_48Ptr
%val10041 = bitcast float* %val10040 to i8*
%val10042 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10043 = getelementptr %xtm_lights, %xtm_lights* %val10042, i64 0, i32 1
%val10044 = load float*, float** %val10043
%val10045 = bitcast float* %val10044 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val10041, i8* %val10045, i64 4, i32 1, i1 0)
%val10047 = load %xtm_lights*, %xtm_lights** %objPtr
%val10048 = load float*, float** %newptr_s_48Ptr
; set tuple
%val10049 = getelementptr %xtm_lights, %xtm_lights* %val10047, i64 0, i32 1
store float* %val10048, float** %val10049
store float* %val10048, float** %ifptr10027
br label %ifcont10027

else10027:
%val10050 = load %xtm_lights*, %xtm_lights** %objPtr
%val10051 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10052 = getelementptr %xtm_lights, %xtm_lights* %val10051, i64 0, i32 1
%val10053 = load float*, float** %val10052
; set tuple
%val10054 = getelementptr %xtm_lights, %xtm_lights* %val10050, i64 0, i32 1
store float* %val10053, float** %val10054
store float* %val10053, float** %ifptr10027
br label %ifcont10027

ifcont10027:
%ifres10055 = load float*, float** %ifptr10027

%val10057 = load %mzone*, %mzone** %fromzPtr
%val10058 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10059 = getelementptr %xtm_lights, %xtm_lights* %val10058, i64 0, i32 2
%val10060 = load float*, float** %val10059
%val10061 = bitcast float* %val10060 to i8*
%res10062 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val10057, i8* %val10061)
br i1 %res10062, label %then10056, label %else10056

then10056:
%tzone10067 = load i8*, i8** %_impzPtr
%zone10068 = bitcast i8* %tzone10067 to %mzone*

; let assign value to symbol newptr_s_49
%newptr_s_49Ptr = alloca float*
%tzone10063 = load i8*, i8** %_impzPtr
%zone10064 = bitcast i8* %tzone10063 to %mzone*
%dat10065 = call i8* @llvm_zone_malloc(%mzone* %zone10064, i64 4)
call i8* @memset(i8* %dat10065, i32 0, i64 4)
%val10066 = bitcast i8* %dat10065 to float*

; let value assignment
%newptr_s_49 = select i1 true, float* %val10066, float* %val10066
store float* %newptr_s_49, float** %newptr_s_49Ptr

%val10069 = load float*, float** %newptr_s_49Ptr
%val10070 = bitcast float* %val10069 to i8*
%val10071 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10072 = getelementptr %xtm_lights, %xtm_lights* %val10071, i64 0, i32 2
%val10073 = load float*, float** %val10072
%val10074 = bitcast float* %val10073 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val10070, i8* %val10074, i64 4, i32 1, i1 0)
%val10076 = load %xtm_lights*, %xtm_lights** %objPtr
%val10077 = load float*, float** %newptr_s_49Ptr
; set tuple
%val10078 = getelementptr %xtm_lights, %xtm_lights* %val10076, i64 0, i32 2
store float* %val10077, float** %val10078
store float* %val10077, float** %ifptr10056
br label %ifcont10056

else10056:
%val10079 = load %xtm_lights*, %xtm_lights** %objPtr
%val10080 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10081 = getelementptr %xtm_lights, %xtm_lights* %val10080, i64 0, i32 2
%val10082 = load float*, float** %val10081
; set tuple
%val10083 = getelementptr %xtm_lights, %xtm_lights* %val10079, i64 0, i32 2
store float* %val10082, float** %val10083
store float* %val10082, float** %ifptr10056
br label %ifcont10056

ifcont10056:
%ifres10084 = load float*, float** %ifptr10056

%val10086 = load %mzone*, %mzone** %fromzPtr
%val10087 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10088 = getelementptr %xtm_lights, %xtm_lights* %val10087, i64 0, i32 3
%val10089 = load float*, float** %val10088
%val10090 = bitcast float* %val10089 to i8*
%res10091 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val10086, i8* %val10090)
br i1 %res10091, label %then10085, label %else10085

then10085:
%tzone10096 = load i8*, i8** %_impzPtr
%zone10097 = bitcast i8* %tzone10096 to %mzone*

; let assign value to symbol newptr_s_50
%newptr_s_50Ptr = alloca float*
%tzone10092 = load i8*, i8** %_impzPtr
%zone10093 = bitcast i8* %tzone10092 to %mzone*
%dat10094 = call i8* @llvm_zone_malloc(%mzone* %zone10093, i64 4)
call i8* @memset(i8* %dat10094, i32 0, i64 4)
%val10095 = bitcast i8* %dat10094 to float*

; let value assignment
%newptr_s_50 = select i1 true, float* %val10095, float* %val10095
store float* %newptr_s_50, float** %newptr_s_50Ptr

%val10098 = load float*, float** %newptr_s_50Ptr
%val10099 = bitcast float* %val10098 to i8*
%val10100 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10101 = getelementptr %xtm_lights, %xtm_lights* %val10100, i64 0, i32 3
%val10102 = load float*, float** %val10101
%val10103 = bitcast float* %val10102 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val10099, i8* %val10103, i64 4, i32 1, i1 0)
%val10105 = load %xtm_lights*, %xtm_lights** %objPtr
%val10106 = load float*, float** %newptr_s_50Ptr
; set tuple
%val10107 = getelementptr %xtm_lights, %xtm_lights* %val10105, i64 0, i32 3
store float* %val10106, float** %val10107
store float* %val10106, float** %ifptr10085
br label %ifcont10085

else10085:
%val10108 = load %xtm_lights*, %xtm_lights** %objPtr
%val10109 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10110 = getelementptr %xtm_lights, %xtm_lights* %val10109, i64 0, i32 3
%val10111 = load float*, float** %val10110
; set tuple
%val10112 = getelementptr %xtm_lights, %xtm_lights* %val10108, i64 0, i32 3
store float* %val10111, float** %val10112
store float* %val10111, float** %ifptr10085
br label %ifcont10085

ifcont10085:
%ifres10113 = load float*, float** %ifptr10085

%val10115 = load %mzone*, %mzone** %fromzPtr
%val10116 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10117 = getelementptr %xtm_lights, %xtm_lights* %val10116, i64 0, i32 4
%val10118 = load float*, float** %val10117
%val10119 = bitcast float* %val10118 to i8*
%res10120 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val10115, i8* %val10119)
br i1 %res10120, label %then10114, label %else10114

then10114:
%tzone10125 = load i8*, i8** %_impzPtr
%zone10126 = bitcast i8* %tzone10125 to %mzone*

; let assign value to symbol newptr_s_51
%newptr_s_51Ptr = alloca float*
%tzone10121 = load i8*, i8** %_impzPtr
%zone10122 = bitcast i8* %tzone10121 to %mzone*
%dat10123 = call i8* @llvm_zone_malloc(%mzone* %zone10122, i64 4)
call i8* @memset(i8* %dat10123, i32 0, i64 4)
%val10124 = bitcast i8* %dat10123 to float*

; let value assignment
%newptr_s_51 = select i1 true, float* %val10124, float* %val10124
store float* %newptr_s_51, float** %newptr_s_51Ptr

%val10127 = load float*, float** %newptr_s_51Ptr
%val10128 = bitcast float* %val10127 to i8*
%val10129 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10130 = getelementptr %xtm_lights, %xtm_lights* %val10129, i64 0, i32 4
%val10131 = load float*, float** %val10130
%val10132 = bitcast float* %val10131 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val10128, i8* %val10132, i64 4, i32 1, i1 0)
%val10134 = load %xtm_lights*, %xtm_lights** %objPtr
%val10135 = load float*, float** %newptr_s_51Ptr
; set tuple
%val10136 = getelementptr %xtm_lights, %xtm_lights* %val10134, i64 0, i32 4
store float* %val10135, float** %val10136
store float* %val10135, float** %ifptr10114
br label %ifcont10114

else10114:
%val10137 = load %xtm_lights*, %xtm_lights** %objPtr
%val10138 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10139 = getelementptr %xtm_lights, %xtm_lights* %val10138, i64 0, i32 4
%val10140 = load float*, float** %val10139
; set tuple
%val10141 = getelementptr %xtm_lights, %xtm_lights* %val10137, i64 0, i32 4
store float* %val10140, float** %val10141
store float* %val10140, float** %ifptr10114
br label %ifcont10114

ifcont10114:
%ifres10142 = load float*, float** %ifptr10114

%val10144 = load %mzone*, %mzone** %fromzPtr
%val10145 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10146 = getelementptr %xtm_lights, %xtm_lights* %val10145, i64 0, i32 5
%val10147 = load float*, float** %val10146
%val10148 = bitcast float* %val10147 to i8*
%res10149 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val10144, i8* %val10148)
br i1 %res10149, label %then10143, label %else10143

then10143:
%tzone10154 = load i8*, i8** %_impzPtr
%zone10155 = bitcast i8* %tzone10154 to %mzone*

; let assign value to symbol newptr_s_52
%newptr_s_52Ptr = alloca float*
%tzone10150 = load i8*, i8** %_impzPtr
%zone10151 = bitcast i8* %tzone10150 to %mzone*
%dat10152 = call i8* @llvm_zone_malloc(%mzone* %zone10151, i64 4)
call i8* @memset(i8* %dat10152, i32 0, i64 4)
%val10153 = bitcast i8* %dat10152 to float*

; let value assignment
%newptr_s_52 = select i1 true, float* %val10153, float* %val10153
store float* %newptr_s_52, float** %newptr_s_52Ptr

%val10156 = load float*, float** %newptr_s_52Ptr
%val10157 = bitcast float* %val10156 to i8*
%val10158 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10159 = getelementptr %xtm_lights, %xtm_lights* %val10158, i64 0, i32 5
%val10160 = load float*, float** %val10159
%val10161 = bitcast float* %val10160 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val10157, i8* %val10161, i64 4, i32 1, i1 0)
%val10163 = load %xtm_lights*, %xtm_lights** %objPtr
%val10164 = load float*, float** %newptr_s_52Ptr
; set tuple
%val10165 = getelementptr %xtm_lights, %xtm_lights* %val10163, i64 0, i32 5
store float* %val10164, float** %val10165
store float* %val10164, float** %ifptr10143
br label %ifcont10143

else10143:
%val10166 = load %xtm_lights*, %xtm_lights** %objPtr
%val10167 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10168 = getelementptr %xtm_lights, %xtm_lights* %val10167, i64 0, i32 5
%val10169 = load float*, float** %val10168
; set tuple
%val10170 = getelementptr %xtm_lights, %xtm_lights* %val10166, i64 0, i32 5
store float* %val10169, float** %val10170
store float* %val10169, float** %ifptr10143
br label %ifcont10143

ifcont10143:
%ifres10171 = load float*, float** %ifptr10143

%val10173 = load %mzone*, %mzone** %fromzPtr
%val10174 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10175 = getelementptr %xtm_lights, %xtm_lights* %val10174, i64 0, i32 6
%val10176 = load float*, float** %val10175
%val10177 = bitcast float* %val10176 to i8*
%res10178 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val10173, i8* %val10177)
br i1 %res10178, label %then10172, label %else10172

then10172:
%tzone10183 = load i8*, i8** %_impzPtr
%zone10184 = bitcast i8* %tzone10183 to %mzone*

; let assign value to symbol newptr_s_53
%newptr_s_53Ptr = alloca float*
%tzone10179 = load i8*, i8** %_impzPtr
%zone10180 = bitcast i8* %tzone10179 to %mzone*
%dat10181 = call i8* @llvm_zone_malloc(%mzone* %zone10180, i64 4)
call i8* @memset(i8* %dat10181, i32 0, i64 4)
%val10182 = bitcast i8* %dat10181 to float*

; let value assignment
%newptr_s_53 = select i1 true, float* %val10182, float* %val10182
store float* %newptr_s_53, float** %newptr_s_53Ptr

%val10185 = load float*, float** %newptr_s_53Ptr
%val10186 = bitcast float* %val10185 to i8*
%val10187 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10188 = getelementptr %xtm_lights, %xtm_lights* %val10187, i64 0, i32 6
%val10189 = load float*, float** %val10188
%val10190 = bitcast float* %val10189 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val10186, i8* %val10190, i64 4, i32 1, i1 0)
%val10192 = load %xtm_lights*, %xtm_lights** %objPtr
%val10193 = load float*, float** %newptr_s_53Ptr
; set tuple
%val10194 = getelementptr %xtm_lights, %xtm_lights* %val10192, i64 0, i32 6
store float* %val10193, float** %val10194
store float* %val10193, float** %ifptr10172
br label %ifcont10172

else10172:
%val10195 = load %xtm_lights*, %xtm_lights** %objPtr
%val10196 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10197 = getelementptr %xtm_lights, %xtm_lights* %val10196, i64 0, i32 6
%val10198 = load float*, float** %val10197
; set tuple
%val10199 = getelementptr %xtm_lights, %xtm_lights* %val10195, i64 0, i32 6
store float* %val10198, float** %val10199
store float* %val10198, float** %ifptr10172
br label %ifcont10172

ifcont10172:
%ifres10200 = load float*, float** %ifptr10172

%val10202 = load %mzone*, %mzone** %fromzPtr
%val10203 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10204 = getelementptr %xtm_lights, %xtm_lights* %val10203, i64 0, i32 7
%val10205 = load float*, float** %val10204
%val10206 = bitcast float* %val10205 to i8*
%res10207 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val10202, i8* %val10206)
br i1 %res10207, label %then10201, label %else10201

then10201:
%tzone10212 = load i8*, i8** %_impzPtr
%zone10213 = bitcast i8* %tzone10212 to %mzone*

; let assign value to symbol newptr_s_54
%newptr_s_54Ptr = alloca float*
%tzone10208 = load i8*, i8** %_impzPtr
%zone10209 = bitcast i8* %tzone10208 to %mzone*
%dat10210 = call i8* @llvm_zone_malloc(%mzone* %zone10209, i64 4)
call i8* @memset(i8* %dat10210, i32 0, i64 4)
%val10211 = bitcast i8* %dat10210 to float*

; let value assignment
%newptr_s_54 = select i1 true, float* %val10211, float* %val10211
store float* %newptr_s_54, float** %newptr_s_54Ptr

%val10214 = load float*, float** %newptr_s_54Ptr
%val10215 = bitcast float* %val10214 to i8*
%val10216 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10217 = getelementptr %xtm_lights, %xtm_lights* %val10216, i64 0, i32 7
%val10218 = load float*, float** %val10217
%val10219 = bitcast float* %val10218 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val10215, i8* %val10219, i64 4, i32 1, i1 0)
%val10221 = load %xtm_lights*, %xtm_lights** %objPtr
%val10222 = load float*, float** %newptr_s_54Ptr
; set tuple
%val10223 = getelementptr %xtm_lights, %xtm_lights* %val10221, i64 0, i32 7
store float* %val10222, float** %val10223
store float* %val10222, float** %ifptr10201
br label %ifcont10201

else10201:
%val10224 = load %xtm_lights*, %xtm_lights** %objPtr
%val10225 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10226 = getelementptr %xtm_lights, %xtm_lights* %val10225, i64 0, i32 7
%val10227 = load float*, float** %val10226
; set tuple
%val10228 = getelementptr %xtm_lights, %xtm_lights* %val10224, i64 0, i32 7
store float* %val10227, float** %val10228
store float* %val10227, float** %ifptr10201
br label %ifcont10201

ifcont10201:
%ifres10229 = load float*, float** %ifptr10201

%val10231 = load %mzone*, %mzone** %fromzPtr
%val10232 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10233 = getelementptr %xtm_lights, %xtm_lights* %val10232, i64 0, i32 8
%val10234 = load float*, float** %val10233
%val10235 = bitcast float* %val10234 to i8*
%res10236 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val10231, i8* %val10235)
br i1 %res10236, label %then10230, label %else10230

then10230:
%tzone10241 = load i8*, i8** %_impzPtr
%zone10242 = bitcast i8* %tzone10241 to %mzone*

; let assign value to symbol newptr_s_55
%newptr_s_55Ptr = alloca float*
%tzone10237 = load i8*, i8** %_impzPtr
%zone10238 = bitcast i8* %tzone10237 to %mzone*
%dat10239 = call i8* @llvm_zone_malloc(%mzone* %zone10238, i64 4)
call i8* @memset(i8* %dat10239, i32 0, i64 4)
%val10240 = bitcast i8* %dat10239 to float*

; let value assignment
%newptr_s_55 = select i1 true, float* %val10240, float* %val10240
store float* %newptr_s_55, float** %newptr_s_55Ptr

%val10243 = load float*, float** %newptr_s_55Ptr
%val10244 = bitcast float* %val10243 to i8*
%val10245 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10246 = getelementptr %xtm_lights, %xtm_lights* %val10245, i64 0, i32 8
%val10247 = load float*, float** %val10246
%val10248 = bitcast float* %val10247 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val10244, i8* %val10248, i64 4, i32 1, i1 0)
%val10250 = load %xtm_lights*, %xtm_lights** %objPtr
%val10251 = load float*, float** %newptr_s_55Ptr
; set tuple
%val10252 = getelementptr %xtm_lights, %xtm_lights* %val10250, i64 0, i32 8
store float* %val10251, float** %val10252
store float* %val10251, float** %ifptr10230
br label %ifcont10230

else10230:
%val10253 = load %xtm_lights*, %xtm_lights** %objPtr
%val10254 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10255 = getelementptr %xtm_lights, %xtm_lights* %val10254, i64 0, i32 8
%val10256 = load float*, float** %val10255
; set tuple
%val10257 = getelementptr %xtm_lights, %xtm_lights* %val10253, i64 0, i32 8
store float* %val10256, float** %val10257
store float* %val10256, float** %ifptr10230
br label %ifcont10230

ifcont10230:
%ifres10258 = load float*, float** %ifptr10230

%val10259 = load %xtm_lights*, %xtm_lights** %objPtr
%val10260 = load %xtm_lights*, %xtm_lights** %xPtr
; tuple ref
%val10261 = getelementptr %xtm_lights, %xtm_lights* %val10260, i64 0, i32 9
%val10262 = load i32, i32* %val10261
; set tuple
%val10263 = getelementptr %xtm_lights, %xtm_lights* %val10259, i64 0, i32 9
store i32 %val10262, i32* %val10263
%oldzone10264 = call %mzone* @llvm_pop_zone_stack()
%newzone10265 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr10266 = bitcast %mzone* %newzone10265 to i8*
store i8* %zone_ptr10266, i8** %_impzPtr
%val10267 = load %xtm_lights*, %xtm_lights** %objPtr
ret %xtm_lights* %val10267

else9984:
%val10270 = load %xtm_lights*, %xtm_lights** %xPtr
ret %xtm_lights* %val10270
}
@gsxtmgraphics-pipeline410 = hidden constant [118 x i8] c"zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}** @zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10290 = load i8*, i8** %_impzPtr
%zone10291 = bitcast i8* %tzone10290 to %mzone*

; let assign value to symbol zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd
%dat_zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone10291, i64 8)
%zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpdPtr = bitcast i8* %dat_zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd to { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}***
%tzone10271 = load i8*, i8** %_impzPtr
%zone10272 = bitcast i8* %tzone10271 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10272)
; malloc closure structure
%clsptr10273 = call i8* @llvm_zone_malloc(%mzone* %zone10272, i64 24)
%closure10274 = bitcast i8* %clsptr10273 to { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr10275 = call i8* @llvm_zone_malloc(%mzone* %zone10272, i64 8)
%environment10276 = bitcast i8* %envptr10275 to {{i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable10277 = call %clsvar* @new_address_table()
%var10278 = bitcast [65 x i8]* @gsxtmgraphics-pipeline408 to i8*
%var10279 = bitcast [71 x i8]* @gsxtmgraphics-pipeline409 to i8*
%addytable10280 = call %clsvar* @add_address_table(%mzone* %zone10272, i8* %var10278, i32 0, i8* %var10279, i32 3, %clsvar* %addytable10277)
%address-table10281 = bitcast %clsvar* %addytable10280 to i8*

; insert table, function and environment into closure struct
%closure.table10284 = getelementptr { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}, { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}* %closure10274, i32 0, i32 0
store i8* %address-table10281, i8** %closure.table10284
%closure.env10285 = getelementptr { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}, { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}* %closure10274, i32 0, i32 1
store i8* %envptr10275, i8** %closure.env10285
%closure.func10286 = getelementptr { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}, { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}* %closure10274, i32 0, i32 2
store %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)* @zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd__9982, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)** %closure.func10286
%closure_size10287 = call i64 @llvm_zone_mark_size(%mzone* %zone10272)
call void @llvm_zone_ptr_set_size(i8* %clsptr10273, i64 %closure_size10287)
%wrapper_ptr10288 = call i8* @llvm_zone_malloc(%mzone* %zone10272, i64 8)
%closure_wrapper10289 = bitcast i8* %wrapper_ptr10288 to { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}**
store { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}* %closure10274, { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}** %closure_wrapper10289

; let value assignment
%zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd = select i1 true, { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}** %closure_wrapper10289, { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}** %closure_wrapper10289
store { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}** %zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd, { i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd
%tmp_envptr10283 = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}***}* %environment10276, i32 0, i32 0
store {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpdPtr, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}**** %tmp_envptr10283


%val10292 = load {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}**, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpdPtr
ret {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}** %val10292
}


@zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}** @zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %xtm_lights* @zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd(%xtm_lights* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*,  %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee, %xtm_lights* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %xtm_lights* %result
}


define dllexport ccc %xtm_lights* @zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd_native(%xtm_lights* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*,  %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee, %xtm_lights* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %xtm_lights* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var10293 = bitcast [118 x i8]* @gsxtmgraphics-pipeline410 to i8*
call i32 (i8*, ...) @printf(i8* %var10293)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %xtm_lights*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var10294 = bitcast [118 x i8]* @gsxtmgraphics-pipeline410 to i8*
call i32 (i8*, ...) @printf(i8* %var10294)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var10295 = bitcast [118 x i8]* @gsxtmgraphics-pipeline410 to i8*
call i32 (i8*, ...) @printf(i8* %var10295)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*,  %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee, %xtm_lights* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %xtm_lights* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%xtm_lights*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%xtm_lights*, %mzone*, %mzone*}, {%xtm_lights*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %xtm_lights*, %xtm_lights** %arg_p_0
%arg_p_1 = getelementptr {%xtm_lights*, %mzone*, %mzone*}, {%xtm_lights*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%xtm_lights*, %mzone*, %mzone*}, {%xtm_lights*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W3h0bV9saWdodHMqLHh0bV9saWdodHMqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)*,  %xtm_lights* (i8*, i8*, %xtm_lights*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee, %xtm_lights* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline411 = hidden constant [40 x i8] c"xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ\00"
@gsxtmgraphics-pipeline412 = hidden constant [39 x i8] c"{i8*, i8*, %xtm_lights* (i8*, i8*)*}**\00"
@gsxtmgraphics-pipeline413 = hidden constant [9 x i8] c"matrices\00"
@gsxtmgraphics-pipeline414 = hidden constant [5 x i8] c"angs\00"
@gsxtmgraphics-pipeline415 = hidden constant [5 x i8] c"pows\00"
@gsxtmgraphics-pipeline416 = hidden constant [2 x i8] c"s\00"
@gsxtmgraphics-pipeline417 = hidden constant [2 x i8] c"d\00"
@gsxtmgraphics-pipeline418 = hidden constant [2 x i8] c"a\00"
@gsxtmgraphics-pipeline419 = hidden constant [7 x i8] c"lights\00"
@gsxtmgraphics-pipeline420 = hidden constant [13 x i8] c"%xtm_lights*\00"
@gsxtmgraphics-pipeline421 = hidden constant [4 x i8] c"i64\00"
@gsxtmgraphics-pipeline422 = hidden constant [16 x i8] c"_anon_lambda_11\00"
define dllexport fastcc %xtm_lights* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ__10296(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10563 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}*
%xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQPtr_ = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQPtr = load {i8*, i8*, %xtm_lights* (i8*, i8*)*}***, {i8*, i8*, %xtm_lights* (i8*, i8*)*}**** %xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQPtr_
%matricesPtr_ = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %impenv, i32 0, i32 1
%matricesPtr = load float**, float*** %matricesPtr_
%angsPtr_ = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %impenv, i32 0, i32 2
%angsPtr = load float**, float*** %angsPtr_
%powsPtr_ = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %impenv, i32 0, i32 3
%powsPtr = load float**, float*** %powsPtr_
%sPtr_ = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %impenv, i32 0, i32 4
%sPtr = load float**, float*** %sPtr_
%dPtr_ = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %impenv, i32 0, i32 5
%dPtr = load float**, float*** %dPtr_
%aPtr_ = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %impenv, i32 0, i32 6
%aPtr = load float**, float*** %aPtr_
%uPtr_ = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %impenv, i32 0, i32 7
%uPtr = load float**, float*** %uPtr_
%tPtr_ = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %impenv, i32 0, i32 8
%tPtr = load float**, float*** %tPtr_
%pPtr_ = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %impenv, i32 0, i32 9
%pPtr = load float**, float*** %pPtr_
%lightsPtr_ = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %impenv, i32 0, i32 10
%lightsPtr = load %xtm_lights**, %xtm_lights*** %lightsPtr_
%iPtr_ = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %impenv, i32 0, i32 11
%iPtr = load i64*, i64** %iPtr_
%_anon_lambda_11Ptr_ = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %impenv, i32 0, i32 12
%_anon_lambda_11Ptr = load {i8*, i8*, %xtm_lights* (i8*, i8*)*}***, {i8*, i8*, %xtm_lights* (i8*, i8*)*}**** %_anon_lambda_11Ptr_

; setup arguments


%val10564 = load %xtm_lights*, %xtm_lights** %lightsPtr
ret %xtm_lights* %val10564
}
define dllexport ccc {i8*, i8*, %xtm_lights* (i8*, i8*)*}** @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10647 = load i8*, i8** %_impzPtr
%zone10648 = bitcast i8* %tzone10647 to %mzone*

; let assign value to symbol xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ
%dat_xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ = call i8* @llvm_zone_malloc(%mzone* %zone10648, i64 8)
%xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQPtr = bitcast i8* %dat_xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ to {i8*, i8*, %xtm_lights* (i8*, i8*)*}***
%tzone10297 = load i8*, i8** %_impzPtr
%zone10298 = bitcast i8* %tzone10297 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone10298, i64 8)
%iPtr = bitcast i8* %dat_i to i64*
%tzone10303 = load i8*, i8** %_impzPtr
%zone10304 = bitcast i8* %tzone10303 to %mzone*

; let assign value to symbol lights
%dat_lights = call i8* @llvm_zone_malloc(%mzone* %zone10304, i64 8)
%lightsPtr = bitcast i8* %dat_lights to %xtm_lights**
%tzone10312 = load i8*, i8** %_impzPtr
%zone10313 = bitcast i8* %tzone10312 to %mzone*

; let assign value to symbol p
%dat_p = call i8* @llvm_zone_malloc(%mzone* %zone10313, i64 8)
%pPtr = bitcast i8* %dat_p to float**
%tzone10321 = load i8*, i8** %_impzPtr
%zone10322 = bitcast i8* %tzone10321 to %mzone*

; let assign value to symbol t
%dat_t = call i8* @llvm_zone_malloc(%mzone* %zone10322, i64 8)
%tPtr = bitcast i8* %dat_t to float**
%tzone10330 = load i8*, i8** %_impzPtr
%zone10331 = bitcast i8* %tzone10330 to %mzone*

; let assign value to symbol u
%dat_u = call i8* @llvm_zone_malloc(%mzone* %zone10331, i64 8)
%uPtr = bitcast i8* %dat_u to float**
%tzone10339 = load i8*, i8** %_impzPtr
%zone10340 = bitcast i8* %tzone10339 to %mzone*

; let assign value to symbol a
%dat_a = call i8* @llvm_zone_malloc(%mzone* %zone10340, i64 8)
%aPtr = bitcast i8* %dat_a to float**
%tzone10348 = load i8*, i8** %_impzPtr
%zone10349 = bitcast i8* %tzone10348 to %mzone*

; let assign value to symbol d
%dat_d = call i8* @llvm_zone_malloc(%mzone* %zone10349, i64 8)
%dPtr = bitcast i8* %dat_d to float**
%tzone10357 = load i8*, i8** %_impzPtr
%zone10358 = bitcast i8* %tzone10357 to %mzone*

; let assign value to symbol s
%dat_s = call i8* @llvm_zone_malloc(%mzone* %zone10358, i64 8)
%sPtr = bitcast i8* %dat_s to float**
%tzone10365 = load i8*, i8** %_impzPtr
%zone10366 = bitcast i8* %tzone10365 to %mzone*

; let assign value to symbol pows
%dat_pows = call i8* @llvm_zone_malloc(%mzone* %zone10366, i64 8)
%powsPtr = bitcast i8* %dat_pows to float**
%tzone10373 = load i8*, i8** %_impzPtr
%zone10374 = bitcast i8* %tzone10373 to %mzone*

; let assign value to symbol angs
%dat_angs = call i8* @llvm_zone_malloc(%mzone* %zone10374, i64 8)
%angsPtr = bitcast i8* %dat_angs to float**
%tzone10382 = load i8*, i8** %_impzPtr
%zone10383 = bitcast i8* %tzone10382 to %mzone*

; let assign value to symbol matrices
%dat_matrices = call i8* @llvm_zone_malloc(%mzone* %zone10383, i64 8)
%matricesPtr = bitcast i8* %dat_matrices to float**

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

%tzone10299 = load i8*, i8** %_impzPtr
%zone10300 = bitcast i8* %tzone10299 to %mzone*
%dat10301 = call i8* @llvm_zone_malloc(%mzone* %zone10300, i64 80)
call i8* @memset(i8* %dat10301, i32 0, i64 80)
%val10302 = bitcast i8* %dat10301 to %xtm_lights*

; let value assignment
%lights = select i1 true, %xtm_lights* %val10302, %xtm_lights* %val10302
store %xtm_lights* %lights, %xtm_lights** %lightsPtr

%val10305 = mul i64 10, 4
%val10306 = getelementptr i64, i64* null, i32 1
%zonesize10307 = mul i64 4, %val10305
%tzone10308 = load i8*, i8** %_impzPtr
%zone10309 = bitcast i8* %tzone10308 to %mzone*
%dat10310 = call i8* @llvm_zone_malloc(%mzone* %zone10309, i64 %zonesize10307)
call i8* @memset(i8* %dat10310, i32 0, i64 %zonesize10307)
%val10311 = bitcast i8* %dat10310 to float*

; let value assignment
%p = select i1 true, float* %val10311, float* %val10311
store float* %p, float** %pPtr

%val10314 = mul i64 10, 4
%val10315 = getelementptr i64, i64* null, i32 1
%zonesize10316 = mul i64 4, %val10314
%tzone10317 = load i8*, i8** %_impzPtr
%zone10318 = bitcast i8* %tzone10317 to %mzone*
%dat10319 = call i8* @llvm_zone_malloc(%mzone* %zone10318, i64 %zonesize10316)
call i8* @memset(i8* %dat10319, i32 0, i64 %zonesize10316)
%val10320 = bitcast i8* %dat10319 to float*

; let value assignment
%t = select i1 true, float* %val10320, float* %val10320
store float* %t, float** %tPtr

%val10323 = mul i64 10, 4
%val10324 = getelementptr i64, i64* null, i32 1
%zonesize10325 = mul i64 4, %val10323
%tzone10326 = load i8*, i8** %_impzPtr
%zone10327 = bitcast i8* %tzone10326 to %mzone*
%dat10328 = call i8* @llvm_zone_malloc(%mzone* %zone10327, i64 %zonesize10325)
call i8* @memset(i8* %dat10328, i32 0, i64 %zonesize10325)
%val10329 = bitcast i8* %dat10328 to float*

; let value assignment
%u = select i1 true, float* %val10329, float* %val10329
store float* %u, float** %uPtr

%val10332 = mul i64 10, 4
%val10333 = getelementptr i64, i64* null, i32 1
%zonesize10334 = mul i64 4, %val10332
%tzone10335 = load i8*, i8** %_impzPtr
%zone10336 = bitcast i8* %tzone10335 to %mzone*
%dat10337 = call i8* @llvm_zone_malloc(%mzone* %zone10336, i64 %zonesize10334)
call i8* @memset(i8* %dat10337, i32 0, i64 %zonesize10334)
%val10338 = bitcast i8* %dat10337 to float*

; let value assignment
%a = select i1 true, float* %val10338, float* %val10338
store float* %a, float** %aPtr

%val10341 = mul i64 10, 4
%val10342 = getelementptr i64, i64* null, i32 1
%zonesize10343 = mul i64 4, %val10341
%tzone10344 = load i8*, i8** %_impzPtr
%zone10345 = bitcast i8* %tzone10344 to %mzone*
%dat10346 = call i8* @llvm_zone_malloc(%mzone* %zone10345, i64 %zonesize10343)
call i8* @memset(i8* %dat10346, i32 0, i64 %zonesize10343)
%val10347 = bitcast i8* %dat10346 to float*

; let value assignment
%d = select i1 true, float* %val10347, float* %val10347
store float* %d, float** %dPtr

%val10350 = mul i64 10, 4
%val10351 = getelementptr i64, i64* null, i32 1
%zonesize10352 = mul i64 4, %val10350
%tzone10353 = load i8*, i8** %_impzPtr
%zone10354 = bitcast i8* %tzone10353 to %mzone*
%dat10355 = call i8* @llvm_zone_malloc(%mzone* %zone10354, i64 %zonesize10352)
call i8* @memset(i8* %dat10355, i32 0, i64 %zonesize10352)
%val10356 = bitcast i8* %dat10355 to float*

; let value assignment
%s = select i1 true, float* %val10356, float* %val10356
store float* %s, float** %sPtr

%val10359 = getelementptr i64, i64* null, i32 1
%zonesize10360 = mul i64 4, 10
%tzone10361 = load i8*, i8** %_impzPtr
%zone10362 = bitcast i8* %tzone10361 to %mzone*
%dat10363 = call i8* @llvm_zone_malloc(%mzone* %zone10362, i64 %zonesize10360)
call i8* @memset(i8* %dat10363, i32 0, i64 %zonesize10360)
%val10364 = bitcast i8* %dat10363 to float*

; let value assignment
%pows = select i1 true, float* %val10364, float* %val10364
store float* %pows, float** %powsPtr

%val10367 = getelementptr i64, i64* null, i32 1
%zonesize10368 = mul i64 4, 10
%tzone10369 = load i8*, i8** %_impzPtr
%zone10370 = bitcast i8* %tzone10369 to %mzone*
%dat10371 = call i8* @llvm_zone_malloc(%mzone* %zone10370, i64 %zonesize10368)
call i8* @memset(i8* %dat10371, i32 0, i64 %zonesize10368)
%val10372 = bitcast i8* %dat10371 to float*

; let value assignment
%angs = select i1 true, float* %val10372, float* %val10372
store float* %angs, float** %angsPtr

%val10375 = mul i64 10, 16
%val10376 = getelementptr i64, i64* null, i32 1
%zonesize10377 = mul i64 4, %val10375
%tzone10378 = load i8*, i8** %_impzPtr
%zone10379 = bitcast i8* %tzone10378 to %mzone*
%dat10380 = call i8* @llvm_zone_malloc(%mzone* %zone10379, i64 %zonesize10377)
call i8* @memset(i8* %dat10380, i32 0, i64 %zonesize10377)
%val10381 = bitcast i8* %dat10380 to float*

; let value assignment
%matrices = select i1 true, float* %val10381, float* %val10381
store float* %matrices, float** %matricesPtr

; setup loop
store i64 0, i64* %iPtr
%val10530 = load i64, i64* %iPtr
%num10531 = add i64 10, %val10530
%comp10532 = icmp ult i64 10, 1
br i1 %comp10532, label %after10384, label %loop10384

loop10384:
%val10385 = load i64, i64* %iPtr
%val10386 = mul i64 %val10385, 4
%val10387 = load float*, float** %dPtr
; pointer ref
%val10388 = getelementptr float, float* %val10387, i64 %val10386
; set pointer
%val10389 = getelementptr float, float* %val10388, i64 0
store float 0x3ff0000000000000, float* %val10389
%val10390 = load i64, i64* %iPtr
%val10391 = mul i64 %val10390, 4
%val10392 = load float*, float** %dPtr
; pointer ref
%val10393 = getelementptr float, float* %val10392, i64 %val10391
; set pointer
%val10394 = getelementptr float, float* %val10393, i64 1
store float 0x3fe99999a0000000, float* %val10394
%val10395 = load i64, i64* %iPtr
%val10396 = mul i64 %val10395, 4
%val10397 = load float*, float** %dPtr
; pointer ref
%val10398 = getelementptr float, float* %val10397, i64 %val10396
; set pointer
%val10399 = getelementptr float, float* %val10398, i64 2
store float 0x3fe0000000000000, float* %val10399
%val10400 = load i64, i64* %iPtr
%val10401 = mul i64 %val10400, 4
%val10402 = load float*, float** %dPtr
; pointer ref
%val10403 = getelementptr float, float* %val10402, i64 %val10401
; set pointer
%val10404 = getelementptr float, float* %val10403, i64 3
store float 0x3ff0000000000000, float* %val10404
%val10405 = load i64, i64* %iPtr
%val10406 = mul i64 %val10405, 4
%val10407 = load float*, float** %sPtr
; pointer ref
%val10408 = getelementptr float, float* %val10407, i64 %val10406
; set pointer
%val10409 = getelementptr float, float* %val10408, i64 0
store float 0x3ff0000000000000, float* %val10409
%val10410 = load i64, i64* %iPtr
%val10411 = mul i64 %val10410, 4
%val10412 = load float*, float** %sPtr
; pointer ref
%val10413 = getelementptr float, float* %val10412, i64 %val10411
; set pointer
%val10414 = getelementptr float, float* %val10413, i64 1
store float 0x3ff0000000000000, float* %val10414
%val10415 = load i64, i64* %iPtr
%val10416 = mul i64 %val10415, 4
%val10417 = load float*, float** %sPtr
; pointer ref
%val10418 = getelementptr float, float* %val10417, i64 %val10416
; set pointer
%val10419 = getelementptr float, float* %val10418, i64 2
store float 0x3ff0000000000000, float* %val10419
%val10420 = load i64, i64* %iPtr
%val10421 = mul i64 %val10420, 4
%val10422 = load float*, float** %sPtr
; pointer ref
%val10423 = getelementptr float, float* %val10422, i64 %val10421
; set pointer
%val10424 = getelementptr float, float* %val10423, i64 3
store float 0x3ff0000000000000, float* %val10424
%val10425 = load i64, i64* %iPtr
%val10426 = mul i64 %val10425, 4
%val10427 = load float*, float** %aPtr
; pointer ref
%val10428 = getelementptr float, float* %val10427, i64 %val10426
; set pointer
%val10429 = getelementptr float, float* %val10428, i64 0
store float 0x3ff0000000000000, float* %val10429
%val10430 = load i64, i64* %iPtr
%val10431 = mul i64 %val10430, 4
%val10432 = load float*, float** %aPtr
; pointer ref
%val10433 = getelementptr float, float* %val10432, i64 %val10431
; set pointer
%val10434 = getelementptr float, float* %val10433, i64 1
store float 0x3fe99999a0000000, float* %val10434
%val10435 = load i64, i64* %iPtr
%val10436 = mul i64 %val10435, 4
%val10437 = load float*, float** %aPtr
; pointer ref
%val10438 = getelementptr float, float* %val10437, i64 %val10436
; set pointer
%val10439 = getelementptr float, float* %val10438, i64 2
store float 0x3fe0000000000000, float* %val10439
%val10440 = load i64, i64* %iPtr
%val10441 = mul i64 %val10440, 4
%val10442 = load float*, float** %aPtr
; pointer ref
%val10443 = getelementptr float, float* %val10442, i64 %val10441
; set pointer
%val10444 = getelementptr float, float* %val10443, i64 3
store float 0x3ff0000000000000, float* %val10444
%val10445 = load i64, i64* %iPtr
%val10446 = mul i64 %val10445, 4
%val10447 = load float*, float** %pPtr
; pointer ref
%val10448 = getelementptr float, float* %val10447, i64 %val10446
; set pointer
%val10449 = getelementptr float, float* %val10448, i64 0
store float 0x3ff0000000000000, float* %val10449
%val10450 = load i64, i64* %iPtr
%val10451 = mul i64 %val10450, 4
%val10452 = load float*, float** %pPtr
; pointer ref
%val10453 = getelementptr float, float* %val10452, i64 %val10451
; set pointer
%val10454 = getelementptr float, float* %val10453, i64 1
store float 0x4024000000000000, float* %val10454
%val10455 = load i64, i64* %iPtr
%val10456 = mul i64 %val10455, 4
%val10457 = load float*, float** %pPtr
; pointer ref
%val10458 = getelementptr float, float* %val10457, i64 %val10456
; set pointer
%val10459 = getelementptr float, float* %val10458, i64 2
store float 0x4024000000000000, float* %val10459
%val10460 = load i64, i64* %iPtr
%val10461 = mul i64 %val10460, 4
%val10462 = load float*, float** %pPtr
; pointer ref
%val10463 = getelementptr float, float* %val10462, i64 %val10461
; set pointer
%val10464 = getelementptr float, float* %val10463, i64 3
store float 0x3ff0000000000000, float* %val10464
%val10465 = load i64, i64* %iPtr
%val10466 = mul i64 %val10465, 4
%val10467 = load float*, float** %tPtr
; pointer ref
%val10468 = getelementptr float, float* %val10467, i64 %val10466
; set pointer
%val10469 = getelementptr float, float* %val10468, i64 0
store float 0x0, float* %val10469
%val10470 = load i64, i64* %iPtr
%val10471 = mul i64 %val10470, 4
%val10472 = load float*, float** %tPtr
; pointer ref
%val10473 = getelementptr float, float* %val10472, i64 %val10471
; set pointer
%val10474 = getelementptr float, float* %val10473, i64 1
store float 0x0, float* %val10474
%val10475 = load i64, i64* %iPtr
%val10476 = mul i64 %val10475, 4
%val10477 = load float*, float** %tPtr
; pointer ref
%val10478 = getelementptr float, float* %val10477, i64 %val10476
; set pointer
%val10479 = getelementptr float, float* %val10478, i64 2
store float 0x0, float* %val10479
%val10480 = load i64, i64* %iPtr
%val10481 = mul i64 %val10480, 4
%val10482 = load float*, float** %tPtr
; pointer ref
%val10483 = getelementptr float, float* %val10482, i64 %val10481
; set pointer
%val10484 = getelementptr float, float* %val10483, i64 3
store float 0x3ff0000000000000, float* %val10484
%val10485 = load i64, i64* %iPtr
%val10486 = mul i64 %val10485, 4
%val10487 = load float*, float** %uPtr
; pointer ref
%val10488 = getelementptr float, float* %val10487, i64 %val10486
; set pointer
%val10489 = getelementptr float, float* %val10488, i64 0
store float 0x0, float* %val10489
%val10490 = load i64, i64* %iPtr
%val10491 = mul i64 %val10490, 4
%val10492 = load float*, float** %uPtr
; pointer ref
%val10493 = getelementptr float, float* %val10492, i64 %val10491
; set pointer
%val10494 = getelementptr float, float* %val10493, i64 1
store float 0x3ff0000000000000, float* %val10494
%val10495 = load i64, i64* %iPtr
%val10496 = mul i64 %val10495, 4
%val10497 = load float*, float** %uPtr
; pointer ref
%val10498 = getelementptr float, float* %val10497, i64 %val10496
; set pointer
%val10499 = getelementptr float, float* %val10498, i64 2
store float 0x0, float* %val10499
%val10500 = load i64, i64* %iPtr
%val10501 = mul i64 %val10500, 4
%val10502 = load float*, float** %uPtr
; pointer ref
%val10503 = getelementptr float, float* %val10502, i64 %val10501
; set pointer
%val10504 = getelementptr float, float* %val10503, i64 3
store float 0x0, float* %val10504
%val10505 = load i64, i64* %iPtr
%val10506 = load float*, float** %angsPtr
; pointer ref
%val10507 = getelementptr float, float* %val10506, i64 %val10505
; set pointer
%val10508 = getelementptr float, float* %val10507, i64 0
store float 0x404e000000000000, float* %val10508
%val10509 = load i64, i64* %iPtr
%val10510 = load float*, float** %powsPtr
; pointer ref
%val10511 = getelementptr float, float* %val10510, i64 %val10509
; set pointer
%val10512 = getelementptr float, float* %val10511, i64 0
store float 0x403e000000000000, float* %val10512
%val10513 = load i64, i64* %iPtr
%val10514 = mul i64 %val10513, 16
%val10515 = load float*, float** %matricesPtr
; pointer ref
%val10516 = getelementptr float, float* %val10515, i64 %val10514
%val10517 = load i64, i64* %iPtr
%val10518 = mul i64 %val10517, 4
%val10519 = load float*, float** %pPtr
; pointer ref
%val10520 = getelementptr float, float* %val10519, i64 %val10518
%val10521 = load i64, i64* %iPtr
%val10522 = mul i64 %val10521, 4
%val10523 = load float*, float** %tPtr
; pointer ref
%val10524 = getelementptr float, float* %val10523, i64 %val10522
%val10525 = load i64, i64* %iPtr
%val10526 = mul i64 %val10525, 4
%val10527 = load float*, float** %uPtr
; pointer ref
%val10528 = getelementptr float, float* %val10527, i64 %val10526
call fastcc void @fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ(float* %val10516, float* %val10520, float* %val10524, float* %val10528)
%loop_cnt10384 = load i64, i64* %iPtr
%next10384 = add i64 %loop_cnt10384, 1
store i64 %next10384, i64* %iPtr
%cmp10384 = icmp ult i64 %next10384, %num10531
br i1 %cmp10384, label %loop10384, label %after10384

after10384:
%val10534 = load %xtm_lights*, %xtm_lights** %lightsPtr
%val10535 = load float*, float** %pPtr
; set tuple
%val10536 = getelementptr %xtm_lights, %xtm_lights* %val10534, i64 0, i32 0
store float* %val10535, float** %val10536
%val10537 = load %xtm_lights*, %xtm_lights** %lightsPtr
%val10538 = load float*, float** %tPtr
; set tuple
%val10539 = getelementptr %xtm_lights, %xtm_lights* %val10537, i64 0, i32 1
store float* %val10538, float** %val10539
%val10540 = load %xtm_lights*, %xtm_lights** %lightsPtr
%val10541 = load float*, float** %uPtr
; set tuple
%val10542 = getelementptr %xtm_lights, %xtm_lights* %val10540, i64 0, i32 2
store float* %val10541, float** %val10542
%val10543 = load %xtm_lights*, %xtm_lights** %lightsPtr
%val10544 = load float*, float** %aPtr
; set tuple
%val10545 = getelementptr %xtm_lights, %xtm_lights* %val10543, i64 0, i32 3
store float* %val10544, float** %val10545
%val10546 = load %xtm_lights*, %xtm_lights** %lightsPtr
%val10547 = load float*, float** %dPtr
; set tuple
%val10548 = getelementptr %xtm_lights, %xtm_lights* %val10546, i64 0, i32 4
store float* %val10547, float** %val10548
%val10549 = load %xtm_lights*, %xtm_lights** %lightsPtr
%val10550 = load float*, float** %sPtr
; set tuple
%val10551 = getelementptr %xtm_lights, %xtm_lights* %val10549, i64 0, i32 5
store float* %val10550, float** %val10551
%val10552 = load %xtm_lights*, %xtm_lights** %lightsPtr
%val10553 = load float*, float** %powsPtr
; set tuple
%val10554 = getelementptr %xtm_lights, %xtm_lights* %val10552, i64 0, i32 6
store float* %val10553, float** %val10554
%val10555 = load %xtm_lights*, %xtm_lights** %lightsPtr
%val10556 = load float*, float** %angsPtr
; set tuple
%val10557 = getelementptr %xtm_lights, %xtm_lights* %val10555, i64 0, i32 7
store float* %val10556, float** %val10557
%val10558 = load %xtm_lights*, %xtm_lights** %lightsPtr
%val10559 = load float*, float** %matricesPtr
; set tuple
%val10560 = getelementptr %xtm_lights, %xtm_lights* %val10558, i64 0, i32 8
store float* %val10559, float** %val10560
%val10561 = load %xtm_lights*, %xtm_lights** %lightsPtr
; set tuple
%val10562 = getelementptr %xtm_lights, %xtm_lights* %val10561, i64 0, i32 9
store i32 0, i32* %val10562
%tzone10644 = load i8*, i8** %_impzPtr
%zone10645 = bitcast i8* %tzone10644 to %mzone*

; let assign value to symbol _anon_lambda_11
%dat__anon_lambda_11 = call i8* @llvm_zone_malloc(%mzone* %zone10645, i64 8)
%_anon_lambda_11Ptr = bitcast i8* %dat__anon_lambda_11 to { i8*, i8*, %xtm_lights* (i8*, i8*)*}***
%tzone10565 = load i8*, i8** %_impzPtr
%zone10566 = bitcast i8* %tzone10565 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10566)
; malloc closure structure
%clsptr10567 = call i8* @llvm_zone_malloc(%mzone* %zone10566, i64 24)
%closure10568 = bitcast i8* %clsptr10567 to { i8*, i8*, %xtm_lights* (i8*, i8*)*}*

; malloc environment structure
%envptr10569 = call i8* @llvm_zone_malloc(%mzone* %zone10566, i64 104)
%environment10570 = bitcast i8* %envptr10569 to {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}*

; malloc closure address table
%addytable10571 = call %clsvar* @new_address_table()
%var10572 = bitcast [40 x i8]* @gsxtmgraphics-pipeline411 to i8*
%var10573 = bitcast [39 x i8]* @gsxtmgraphics-pipeline412 to i8*
%addytable10574 = call %clsvar* @add_address_table(%mzone* %zone10566, i8* %var10572, i32 0, i8* %var10573, i32 3, %clsvar* %addytable10571)
%var10575 = bitcast [9 x i8]* @gsxtmgraphics-pipeline413 to i8*
%var10576 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable10577 = call %clsvar* @add_address_table(%mzone* %zone10566, i8* %var10575, i32 8, i8* %var10576, i32 3, %clsvar* %addytable10574)
%var10578 = bitcast [5 x i8]* @gsxtmgraphics-pipeline414 to i8*
%var10579 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable10580 = call %clsvar* @add_address_table(%mzone* %zone10566, i8* %var10578, i32 16, i8* %var10579, i32 3, %clsvar* %addytable10577)
%var10581 = bitcast [5 x i8]* @gsxtmgraphics-pipeline415 to i8*
%var10582 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable10583 = call %clsvar* @add_address_table(%mzone* %zone10566, i8* %var10581, i32 24, i8* %var10582, i32 3, %clsvar* %addytable10580)
%var10584 = bitcast [2 x i8]* @gsxtmgraphics-pipeline416 to i8*
%var10585 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable10586 = call %clsvar* @add_address_table(%mzone* %zone10566, i8* %var10584, i32 32, i8* %var10585, i32 3, %clsvar* %addytable10583)
%var10587 = bitcast [2 x i8]* @gsxtmgraphics-pipeline417 to i8*
%var10588 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable10589 = call %clsvar* @add_address_table(%mzone* %zone10566, i8* %var10587, i32 40, i8* %var10588, i32 3, %clsvar* %addytable10586)
%var10590 = bitcast [2 x i8]* @gsxtmgraphics-pipeline418 to i8*
%var10591 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable10592 = call %clsvar* @add_address_table(%mzone* %zone10566, i8* %var10590, i32 48, i8* %var10591, i32 3, %clsvar* %addytable10589)
%var10593 = bitcast [2 x i8]* @gsxtmgraphics-pipeline363 to i8*
%var10594 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable10595 = call %clsvar* @add_address_table(%mzone* %zone10566, i8* %var10593, i32 56, i8* %var10594, i32 3, %clsvar* %addytable10592)
%var10596 = bitcast [2 x i8]* @gsxtmgraphics-pipeline364 to i8*
%var10597 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable10598 = call %clsvar* @add_address_table(%mzone* %zone10566, i8* %var10596, i32 64, i8* %var10597, i32 3, %clsvar* %addytable10595)
%var10599 = bitcast [2 x i8]* @gsxtmgraphics-pipeline365 to i8*
%var10600 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable10601 = call %clsvar* @add_address_table(%mzone* %zone10566, i8* %var10599, i32 72, i8* %var10600, i32 3, %clsvar* %addytable10598)
%var10602 = bitcast [7 x i8]* @gsxtmgraphics-pipeline419 to i8*
%var10603 = bitcast [13 x i8]* @gsxtmgraphics-pipeline420 to i8*
%addytable10604 = call %clsvar* @add_address_table(%mzone* %zone10566, i8* %var10602, i32 80, i8* %var10603, i32 3, %clsvar* %addytable10601)
%var10605 = bitcast [2 x i8]* @gsxtmgraphics-pipeline240 to i8*
%var10606 = bitcast [4 x i8]* @gsxtmgraphics-pipeline421 to i8*
%addytable10607 = call %clsvar* @add_address_table(%mzone* %zone10566, i8* %var10605, i32 88, i8* %var10606, i32 3, %clsvar* %addytable10604)
%var10608 = bitcast [16 x i8]* @gsxtmgraphics-pipeline422 to i8*
%var10609 = bitcast [39 x i8]* @gsxtmgraphics-pipeline412 to i8*
%addytable10610 = call %clsvar* @add_address_table(%mzone* %zone10566, i8* %var10608, i32 96, i8* %var10609, i32 3, %clsvar* %addytable10607)
%address-table10611 = bitcast %clsvar* %addytable10610 to i8*

; insert table, function and environment into closure struct
%closure.table10638 = getelementptr { i8*, i8*, %xtm_lights* (i8*, i8*)*}, { i8*, i8*, %xtm_lights* (i8*, i8*)*}* %closure10568, i32 0, i32 0
store i8* %address-table10611, i8** %closure.table10638
%closure.env10639 = getelementptr { i8*, i8*, %xtm_lights* (i8*, i8*)*}, { i8*, i8*, %xtm_lights* (i8*, i8*)*}* %closure10568, i32 0, i32 1
store i8* %envptr10569, i8** %closure.env10639
%closure.func10640 = getelementptr { i8*, i8*, %xtm_lights* (i8*, i8*)*}, { i8*, i8*, %xtm_lights* (i8*, i8*)*}* %closure10568, i32 0, i32 2
store %xtm_lights* (i8*, i8*)* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ__10296, %xtm_lights* (i8*, i8*)** %closure.func10640
%closure_size10641 = call i64 @llvm_zone_mark_size(%mzone* %zone10566)
call void @llvm_zone_ptr_set_size(i8* %clsptr10567, i64 %closure_size10641)
%wrapper_ptr10642 = call i8* @llvm_zone_malloc(%mzone* %zone10566, i64 8)
%closure_wrapper10643 = bitcast i8* %wrapper_ptr10642 to { i8*, i8*, %xtm_lights* (i8*, i8*)*}**
store { i8*, i8*, %xtm_lights* (i8*, i8*)*}* %closure10568, { i8*, i8*, %xtm_lights* (i8*, i8*)*}** %closure_wrapper10643

; let value assignment
%_anon_lambda_11 = select i1 true, { i8*, i8*, %xtm_lights* (i8*, i8*)*}** %closure_wrapper10643, { i8*, i8*, %xtm_lights* (i8*, i8*)*}** %closure_wrapper10643
store { i8*, i8*, %xtm_lights* (i8*, i8*)*}** %_anon_lambda_11, { i8*, i8*, %xtm_lights* (i8*, i8*)*}*** %_anon_lambda_11Ptr

; add data to environment
; don't need to alloc for env var xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ
%tmp_envptr10613 = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %environment10570, i32 0, i32 0
store {i8*, i8*, %xtm_lights* (i8*, i8*)*}*** %xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQPtr, {i8*, i8*, %xtm_lights* (i8*, i8*)*}**** %tmp_envptr10613

; don't need to alloc for env var matrices
%tmp_envptr10615 = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %environment10570, i32 0, i32 1
store float** %matricesPtr, float*** %tmp_envptr10615

; don't need to alloc for env var angs
%tmp_envptr10617 = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %environment10570, i32 0, i32 2
store float** %angsPtr, float*** %tmp_envptr10617

; don't need to alloc for env var pows
%tmp_envptr10619 = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %environment10570, i32 0, i32 3
store float** %powsPtr, float*** %tmp_envptr10619

; don't need to alloc for env var s
%tmp_envptr10621 = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %environment10570, i32 0, i32 4
store float** %sPtr, float*** %tmp_envptr10621

; don't need to alloc for env var d
%tmp_envptr10623 = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %environment10570, i32 0, i32 5
store float** %dPtr, float*** %tmp_envptr10623

; don't need to alloc for env var a
%tmp_envptr10625 = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %environment10570, i32 0, i32 6
store float** %aPtr, float*** %tmp_envptr10625

; don't need to alloc for env var u
%tmp_envptr10627 = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %environment10570, i32 0, i32 7
store float** %uPtr, float*** %tmp_envptr10627

; don't need to alloc for env var t
%tmp_envptr10629 = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %environment10570, i32 0, i32 8
store float** %tPtr, float*** %tmp_envptr10629

; don't need to alloc for env var p
%tmp_envptr10631 = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %environment10570, i32 0, i32 9
store float** %pPtr, float*** %tmp_envptr10631

; don't need to alloc for env var lights
%tmp_envptr10633 = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %environment10570, i32 0, i32 10
store %xtm_lights** %lightsPtr, %xtm_lights*** %tmp_envptr10633

; don't need to alloc for env var i
%tmp_envptr10635 = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %environment10570, i32 0, i32 11
store i64* %iPtr, i64** %tmp_envptr10635

; don't need to alloc for env var _anon_lambda_11
%tmp_envptr10637 = getelementptr {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}, {{i8*, i8*, %xtm_lights* (i8*, i8*)*}***, float**, float**, float**, float**, float**, float**, float**, float**, float**, %xtm_lights**, i64*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}***}* %environment10570, i32 0, i32 12
store {i8*, i8*, %xtm_lights* (i8*, i8*)*}*** %_anon_lambda_11Ptr, {i8*, i8*, %xtm_lights* (i8*, i8*)*}**** %tmp_envptr10637


%val10646 = load {i8*, i8*, %xtm_lights* (i8*, i8*)*}**, {i8*, i8*, %xtm_lights* (i8*, i8*)*}*** %_anon_lambda_11Ptr

; let value assignment
%xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ = select i1 true, {i8*, i8*, %xtm_lights* (i8*, i8*)*}** %val10646, {i8*, i8*, %xtm_lights* (i8*, i8*)*}** %val10646
store {i8*, i8*, %xtm_lights* (i8*, i8*)*}** %xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ, {i8*, i8*, %xtm_lights* (i8*, i8*)*}*** %xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQPtr

%val10649 = load {i8*, i8*, %xtm_lights* (i8*, i8*)*}**, {i8*, i8*, %xtm_lights* (i8*, i8*)*}*** %xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQPtr
ret {i8*, i8*, %xtm_lights* (i8*, i8*)*}** %val10649
}


@xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %xtm_lights* (i8*, i8*)*}** @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %xtm_lights* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %xtm_lights* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*)*,  %xtm_lights* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee)
ret %xtm_lights* %result
}


define dllexport ccc %xtm_lights* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*)*,  %xtm_lights* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee)
ret %xtm_lights* %result
}


define dllexport ccc i8*  @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*)*,  %xtm_lights* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast %xtm_lights* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %xtm_lights* (i8*, i8*)*}**
%closure = load {i8*, i8*, %xtm_lights* (i8*, i8*)*}*, {i8*, i8*, %xtm_lights* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %xtm_lights* (i8*, i8*)*}, {i8*, i8*, %xtm_lights* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %xtm_lights* (i8*, i8*)*,  %xtm_lights* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %xtm_lights* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline423 = hidden constant [16 x i8] c"No such light!
\00"
@gsxtmgraphics-pipeline424 = hidden constant [59 x i8] c"xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
@gsxtmgraphics-pipeline425 = hidden constant [57 x i8] c"{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**\00"
@gsxtmgraphics-pipeline426 = hidden constant [16 x i8] c"_anon_lambda_12\00"
define dllexport fastcc void @xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ__10650(i8* %_impz,i8* %_impenv, i32 %light, float %x, float %y, float %z) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10654 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}*
%xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}* %impenv, i32 0, i32 0
%xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**** %xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQPtr_
%lightsPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}* %impenv, i32 0, i32 1
%lightsPtr = load %xtm_lights**, %xtm_lights*** %lightsPtr_
%_anon_lambda_12Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_12Ptr = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**** %_anon_lambda_12Ptr_

; setup arguments
%lightPtr = alloca i32
store i32 %light, i32* %lightPtr
%xPtr = alloca float
store float %x, float* %xPtr
%yPtr = alloca float
store float %y, float* %yPtr
%zPtr = alloca float
store float %z, float* %zPtr

; promote local stack var allocations
%tzone10705 = load i8*, i8** %_impzPtr
%zone10706 = bitcast i8* %tzone10705 to %mzone*
%ifptr10669 = alloca i1
%ifptr10674 = alloca i1
%ifptr10656 = alloca i32

; do set!
%res10655 = call fastcc %xtm_lights* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ()
store %xtm_lights* %res10655, %xtm_lights** %lightsPtr
%val10657 = load i32, i32* %lightPtr
%val10658 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val10659 = getelementptr %xtm_lights, %xtm_lights* %val10658, i64 0, i32 9
%val10660 = load i32, i32* %val10659
%cmp10661 = icmp sgt i32 %val10657, %val10660
br i1 %cmp10661, label %then10656, label %else10656

then10656:
%val10662 = load %xtm_lights*, %xtm_lights** %lightsPtr
%val10663 = load i32, i32* %lightPtr
; set tuple
%val10664 = getelementptr %xtm_lights, %xtm_lights* %val10662, i64 0, i32 9
store i32 %val10663, i32* %val10664
store i32 %val10663, i32* %ifptr10656
br label %ifcont10656

else10656:
br label %ifcont10656

ifcont10656:
%ifres10665 = load i32, i32* %ifptr10656

; do set!
%val10666 = load i32, i32* %lightPtr
%val10667 = sub i32 %val10666, 1
store i32 %val10667, i32* %lightPtr
%val10670 = load i32, i32* %lightPtr
%cmp10671 = icmp slt i32 %val10670, 0
br i1 %cmp10671, label %then10669, label %else10669

then10669:
%val10672 = load i32, i32* %lightPtr
%cmp10673 = icmp slt i32 %val10672, 0
store i1 %cmp10673, i1* %ifptr10669
br label %ifcont10669

else10669:
%val10675 = load i32, i32* %lightPtr
%cmp10676 = icmp sgt i32 %val10675, 9
br i1 %cmp10676, label %then10674, label %else10674

then10674:
%val10677 = load i32, i32* %lightPtr
%cmp10678 = icmp sgt i32 %val10677, 9
store i1 %cmp10678, i1* %ifptr10674
br label %ifcont10674

else10674:
%res10679 = call ccc i1 @impc_false()
store i1 %res10679, i1* %ifptr10674
br label %ifcont10674

ifcont10674:
%ifres10680 = load i1, i1* %ifptr10674

store i1 %ifres10680, i1* %ifptr10669
br label %ifcont10669

ifcont10669:
%ifres10681 = load i1, i1* %ifptr10669

br i1 %ifres10681, label %then10668, label %else10668

then10668:
%var10682 = bitcast [16 x i8]* @gsxtmgraphics-pipeline423 to i8*

%val10683 = call i32 (i8*, ...) @printf(i8* %var10682)
ret void

else10668:
%tzone10691 = load i8*, i8** %_impzPtr
%zone10692 = bitcast i8* %tzone10691 to %mzone*

; let assign value to symbol a
%aPtr = alloca float*
%val10685 = load i32, i32* %lightPtr
%val10686 = mul i32 %val10685, 4
%val10687 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val10688 = getelementptr %xtm_lights, %xtm_lights* %val10687, i64 0, i32 0
%val10689 = load float*, float** %val10688
; pointer ref
%val10690 = getelementptr float, float* %val10689, i32 %val10686

; let value assignment
%a = select i1 true, float* %val10690, float* %val10690
store float* %a, float** %aPtr

%val10693 = load float*, float** %aPtr
%val10694 = load float, float* %xPtr
; set pointer
%val10695 = getelementptr float, float* %val10693, i64 0
store float %val10694, float* %val10695
%val10696 = load float*, float** %aPtr
%val10697 = load float, float* %yPtr
; set pointer
%val10698 = getelementptr float, float* %val10696, i64 1
store float %val10697, float* %val10698
%val10699 = load float*, float** %aPtr
%val10700 = load float, float* %zPtr
; set pointer
%val10701 = getelementptr float, float* %val10699, i64 2
store float %val10700, float* %val10701
%val10702 = load float*, float** %aPtr
; set pointer
%val10703 = getelementptr float, float* %val10702, i64 3
store float 0x3ff0000000000000, float* %val10703
ret void
}
@gsxtmgraphics-pipeline427 = hidden constant [112 x i8] c"xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** @xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10739 = load i8*, i8** %_impzPtr
%zone10740 = bitcast i8* %tzone10739 to %mzone*

; let assign value to symbol xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone10740, i64 8)
%xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ to {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***
%tzone10652 = load i8*, i8** %_impzPtr
%zone10653 = bitcast i8* %tzone10652 to %mzone*

; let assign value to symbol lights
%dat_lights = call i8* @llvm_zone_malloc(%mzone* %zone10653, i64 8)
%lightsPtr = bitcast i8* %dat_lights to %xtm_lights**
%null10651 = bitcast i8* null to %xtm_lights*

; let value assignment
%lights = select i1 true, %xtm_lights* %null10651, %xtm_lights* %null10651
store %xtm_lights* %lights, %xtm_lights** %lightsPtr

%tzone10736 = load i8*, i8** %_impzPtr
%zone10737 = bitcast i8* %tzone10736 to %mzone*

; let assign value to symbol _anon_lambda_12
%dat__anon_lambda_12 = call i8* @llvm_zone_malloc(%mzone* %zone10737, i64 8)
%_anon_lambda_12Ptr = bitcast i8* %dat__anon_lambda_12 to { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***
%tzone10707 = load i8*, i8** %_impzPtr
%zone10708 = bitcast i8* %tzone10707 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10708)
; malloc closure structure
%clsptr10709 = call i8* @llvm_zone_malloc(%mzone* %zone10708, i64 24)
%closure10710 = bitcast i8* %clsptr10709 to { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*

; malloc environment structure
%envptr10711 = call i8* @llvm_zone_malloc(%mzone* %zone10708, i64 24)
%environment10712 = bitcast i8* %envptr10711 to {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}*

; malloc closure address table
%addytable10713 = call %clsvar* @new_address_table()
%var10714 = bitcast [59 x i8]* @gsxtmgraphics-pipeline424 to i8*
%var10715 = bitcast [57 x i8]* @gsxtmgraphics-pipeline425 to i8*
%addytable10716 = call %clsvar* @add_address_table(%mzone* %zone10708, i8* %var10714, i32 0, i8* %var10715, i32 3, %clsvar* %addytable10713)
%var10717 = bitcast [7 x i8]* @gsxtmgraphics-pipeline419 to i8*
%var10718 = bitcast [13 x i8]* @gsxtmgraphics-pipeline420 to i8*
%addytable10719 = call %clsvar* @add_address_table(%mzone* %zone10708, i8* %var10717, i32 8, i8* %var10718, i32 3, %clsvar* %addytable10716)
%var10720 = bitcast [16 x i8]* @gsxtmgraphics-pipeline426 to i8*
%var10721 = bitcast [57 x i8]* @gsxtmgraphics-pipeline425 to i8*
%addytable10722 = call %clsvar* @add_address_table(%mzone* %zone10708, i8* %var10720, i32 16, i8* %var10721, i32 3, %clsvar* %addytable10719)
%address-table10723 = bitcast %clsvar* %addytable10722 to i8*

; insert table, function and environment into closure struct
%closure.table10730 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure10710, i32 0, i32 0
store i8* %address-table10723, i8** %closure.table10730
%closure.env10731 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure10710, i32 0, i32 1
store i8* %envptr10711, i8** %closure.env10731
%closure.func10732 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure10710, i32 0, i32 2
store void (i8*, i8*, i32, float, float, float)* @xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ__10650, void (i8*, i8*, i32, float, float, float)** %closure.func10732
%closure_size10733 = call i64 @llvm_zone_mark_size(%mzone* %zone10708)
call void @llvm_zone_ptr_set_size(i8* %clsptr10709, i64 %closure_size10733)
%wrapper_ptr10734 = call i8* @llvm_zone_malloc(%mzone* %zone10708, i64 8)
%closure_wrapper10735 = bitcast i8* %wrapper_ptr10734 to { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure10710, { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure_wrapper10735

; let value assignment
%_anon_lambda_12 = select i1 true, { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure_wrapper10735, { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure_wrapper10735
store { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %_anon_lambda_12, { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*** %_anon_lambda_12Ptr

; add data to environment
; don't need to alloc for env var xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr10725 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}* %environment10712, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*** %xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**** %tmp_envptr10725

; don't need to alloc for env var lights
%tmp_envptr10727 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}* %environment10712, i32 0, i32 1
store %xtm_lights** %lightsPtr, %xtm_lights*** %tmp_envptr10727

; don't need to alloc for env var _anon_lambda_12
%tmp_envptr10729 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}* %environment10712, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*** %_anon_lambda_12Ptr, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**** %tmp_envptr10729


%val10738 = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*** %_anon_lambda_12Ptr

; let value assignment
%xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %val10738, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %val10738
store {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*** %xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQPtr

%val10741 = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*** %xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %val10741
}


@xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** @xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ(i32 %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float)*,  void (i8*, i8*, i32, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret void
}


define dllexport ccc void @xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_native(i32 %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float)*,  void (i8*, i8*, i32, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret void
}


define dllexport ccc i8*  @xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var10742 = bitcast [112 x i8]* @gsxtmgraphics-pipeline427 to i8*
call i32 (i8*, ...) @printf(i8* %var10742)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var10743 = bitcast [112 x i8]* @gsxtmgraphics-pipeline427 to i8*
call i32 (i8*, ...) @printf(i8* %var10743)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var10744 = bitcast [112 x i8]* @gsxtmgraphics-pipeline427 to i8*
call i32 (i8*, ...) @printf(i8* %var10744)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var10745 = bitcast [112 x i8]* @gsxtmgraphics-pipeline427 to i8*
call i32 (i8*, ...) @printf(i8* %var10745)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float)*,  void (i8*, i8*, i32, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, float, float, float}*
%arg_p_0 = getelementptr {i32, float, float, float}, {i32, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, float, float, float}, {i32, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {i32, float, float, float}, {i32, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {i32, float, float, float}, {i32, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_pos_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float)*,  void (i8*, i8*, i32, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline428 = hidden constant [59 x i8] c"xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
@gsxtmgraphics-pipeline429 = hidden constant [16 x i8] c"_anon_lambda_13\00"
define dllexport fastcc void @xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ__10746(i8* %_impz,i8* %_impenv, i32 %light, float %x, float %y, float %z) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10750 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}*
%xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}* %impenv, i32 0, i32 0
%xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**** %xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQPtr_
%lightsPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}* %impenv, i32 0, i32 1
%lightsPtr = load %xtm_lights**, %xtm_lights*** %lightsPtr_
%_anon_lambda_13Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_13Ptr = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**** %_anon_lambda_13Ptr_

; setup arguments
%lightPtr = alloca i32
store i32 %light, i32* %lightPtr
%xPtr = alloca float
store float %x, float* %xPtr
%yPtr = alloca float
store float %y, float* %yPtr
%zPtr = alloca float
store float %z, float* %zPtr

; promote local stack var allocations
%tzone10801 = load i8*, i8** %_impzPtr
%zone10802 = bitcast i8* %tzone10801 to %mzone*
%ifptr10765 = alloca i1
%ifptr10770 = alloca i1
%ifptr10752 = alloca i32

; do set!
%res10751 = call fastcc %xtm_lights* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ()
store %xtm_lights* %res10751, %xtm_lights** %lightsPtr
%val10753 = load i32, i32* %lightPtr
%val10754 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val10755 = getelementptr %xtm_lights, %xtm_lights* %val10754, i64 0, i32 9
%val10756 = load i32, i32* %val10755
%cmp10757 = icmp sgt i32 %val10753, %val10756
br i1 %cmp10757, label %then10752, label %else10752

then10752:
%val10758 = load %xtm_lights*, %xtm_lights** %lightsPtr
%val10759 = load i32, i32* %lightPtr
; set tuple
%val10760 = getelementptr %xtm_lights, %xtm_lights* %val10758, i64 0, i32 9
store i32 %val10759, i32* %val10760
store i32 %val10759, i32* %ifptr10752
br label %ifcont10752

else10752:
br label %ifcont10752

ifcont10752:
%ifres10761 = load i32, i32* %ifptr10752

; do set!
%val10762 = load i32, i32* %lightPtr
%val10763 = sub i32 %val10762, 1
store i32 %val10763, i32* %lightPtr
%val10766 = load i32, i32* %lightPtr
%cmp10767 = icmp slt i32 %val10766, 0
br i1 %cmp10767, label %then10765, label %else10765

then10765:
%val10768 = load i32, i32* %lightPtr
%cmp10769 = icmp slt i32 %val10768, 0
store i1 %cmp10769, i1* %ifptr10765
br label %ifcont10765

else10765:
%val10771 = load i32, i32* %lightPtr
%cmp10772 = icmp sgt i32 %val10771, 9
br i1 %cmp10772, label %then10770, label %else10770

then10770:
%val10773 = load i32, i32* %lightPtr
%cmp10774 = icmp sgt i32 %val10773, 9
store i1 %cmp10774, i1* %ifptr10770
br label %ifcont10770

else10770:
%res10775 = call ccc i1 @impc_false()
store i1 %res10775, i1* %ifptr10770
br label %ifcont10770

ifcont10770:
%ifres10776 = load i1, i1* %ifptr10770

store i1 %ifres10776, i1* %ifptr10765
br label %ifcont10765

ifcont10765:
%ifres10777 = load i1, i1* %ifptr10765

br i1 %ifres10777, label %then10764, label %else10764

then10764:
%var10778 = bitcast [16 x i8]* @gsxtmgraphics-pipeline423 to i8*

%val10779 = call i32 (i8*, ...) @printf(i8* %var10778)
ret void

else10764:
%tzone10787 = load i8*, i8** %_impzPtr
%zone10788 = bitcast i8* %tzone10787 to %mzone*

; let assign value to symbol a
%aPtr = alloca float*
%val10781 = load i32, i32* %lightPtr
%val10782 = mul i32 %val10781, 4
%val10783 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val10784 = getelementptr %xtm_lights, %xtm_lights* %val10783, i64 0, i32 1
%val10785 = load float*, float** %val10784
; pointer ref
%val10786 = getelementptr float, float* %val10785, i32 %val10782

; let value assignment
%a = select i1 true, float* %val10786, float* %val10786
store float* %a, float** %aPtr

%val10789 = load float*, float** %aPtr
%val10790 = load float, float* %xPtr
; set pointer
%val10791 = getelementptr float, float* %val10789, i64 0
store float %val10790, float* %val10791
%val10792 = load float*, float** %aPtr
%val10793 = load float, float* %yPtr
; set pointer
%val10794 = getelementptr float, float* %val10792, i64 1
store float %val10793, float* %val10794
%val10795 = load float*, float** %aPtr
%val10796 = load float, float* %zPtr
; set pointer
%val10797 = getelementptr float, float* %val10795, i64 2
store float %val10796, float* %val10797
%val10798 = load float*, float** %aPtr
; set pointer
%val10799 = getelementptr float, float* %val10798, i64 3
store float 0x3ff0000000000000, float* %val10799
ret void
}
@gsxtmgraphics-pipeline430 = hidden constant [112 x i8] c"xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** @xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10835 = load i8*, i8** %_impzPtr
%zone10836 = bitcast i8* %tzone10835 to %mzone*

; let assign value to symbol xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone10836, i64 8)
%xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ to {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***
%tzone10748 = load i8*, i8** %_impzPtr
%zone10749 = bitcast i8* %tzone10748 to %mzone*

; let assign value to symbol lights
%dat_lights = call i8* @llvm_zone_malloc(%mzone* %zone10749, i64 8)
%lightsPtr = bitcast i8* %dat_lights to %xtm_lights**
%null10747 = bitcast i8* null to %xtm_lights*

; let value assignment
%lights = select i1 true, %xtm_lights* %null10747, %xtm_lights* %null10747
store %xtm_lights* %lights, %xtm_lights** %lightsPtr

%tzone10832 = load i8*, i8** %_impzPtr
%zone10833 = bitcast i8* %tzone10832 to %mzone*

; let assign value to symbol _anon_lambda_13
%dat__anon_lambda_13 = call i8* @llvm_zone_malloc(%mzone* %zone10833, i64 8)
%_anon_lambda_13Ptr = bitcast i8* %dat__anon_lambda_13 to { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***
%tzone10803 = load i8*, i8** %_impzPtr
%zone10804 = bitcast i8* %tzone10803 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10804)
; malloc closure structure
%clsptr10805 = call i8* @llvm_zone_malloc(%mzone* %zone10804, i64 24)
%closure10806 = bitcast i8* %clsptr10805 to { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*

; malloc environment structure
%envptr10807 = call i8* @llvm_zone_malloc(%mzone* %zone10804, i64 24)
%environment10808 = bitcast i8* %envptr10807 to {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}*

; malloc closure address table
%addytable10809 = call %clsvar* @new_address_table()
%var10810 = bitcast [59 x i8]* @gsxtmgraphics-pipeline428 to i8*
%var10811 = bitcast [57 x i8]* @gsxtmgraphics-pipeline425 to i8*
%addytable10812 = call %clsvar* @add_address_table(%mzone* %zone10804, i8* %var10810, i32 0, i8* %var10811, i32 3, %clsvar* %addytable10809)
%var10813 = bitcast [7 x i8]* @gsxtmgraphics-pipeline419 to i8*
%var10814 = bitcast [13 x i8]* @gsxtmgraphics-pipeline420 to i8*
%addytable10815 = call %clsvar* @add_address_table(%mzone* %zone10804, i8* %var10813, i32 8, i8* %var10814, i32 3, %clsvar* %addytable10812)
%var10816 = bitcast [16 x i8]* @gsxtmgraphics-pipeline429 to i8*
%var10817 = bitcast [57 x i8]* @gsxtmgraphics-pipeline425 to i8*
%addytable10818 = call %clsvar* @add_address_table(%mzone* %zone10804, i8* %var10816, i32 16, i8* %var10817, i32 3, %clsvar* %addytable10815)
%address-table10819 = bitcast %clsvar* %addytable10818 to i8*

; insert table, function and environment into closure struct
%closure.table10826 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure10806, i32 0, i32 0
store i8* %address-table10819, i8** %closure.table10826
%closure.env10827 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure10806, i32 0, i32 1
store i8* %envptr10807, i8** %closure.env10827
%closure.func10828 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure10806, i32 0, i32 2
store void (i8*, i8*, i32, float, float, float)* @xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ__10746, void (i8*, i8*, i32, float, float, float)** %closure.func10828
%closure_size10829 = call i64 @llvm_zone_mark_size(%mzone* %zone10804)
call void @llvm_zone_ptr_set_size(i8* %clsptr10805, i64 %closure_size10829)
%wrapper_ptr10830 = call i8* @llvm_zone_malloc(%mzone* %zone10804, i64 8)
%closure_wrapper10831 = bitcast i8* %wrapper_ptr10830 to { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure10806, { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure_wrapper10831

; let value assignment
%_anon_lambda_13 = select i1 true, { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure_wrapper10831, { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure_wrapper10831
store { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %_anon_lambda_13, { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*** %_anon_lambda_13Ptr

; add data to environment
; don't need to alloc for env var xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr10821 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}* %environment10808, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*** %xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**** %tmp_envptr10821

; don't need to alloc for env var lights
%tmp_envptr10823 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}* %environment10808, i32 0, i32 1
store %xtm_lights** %lightsPtr, %xtm_lights*** %tmp_envptr10823

; don't need to alloc for env var _anon_lambda_13
%tmp_envptr10825 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}* %environment10808, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*** %_anon_lambda_13Ptr, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**** %tmp_envptr10825


%val10834 = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*** %_anon_lambda_13Ptr

; let value assignment
%xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %val10834, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %val10834
store {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*** %xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQPtr

%val10837 = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*** %xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %val10837
}


@xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** @xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ(i32 %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float)*,  void (i8*, i8*, i32, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret void
}


define dllexport ccc void @xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_native(i32 %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float)*,  void (i8*, i8*, i32, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret void
}


define dllexport ccc i8*  @xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var10838 = bitcast [112 x i8]* @gsxtmgraphics-pipeline430 to i8*
call i32 (i8*, ...) @printf(i8* %var10838)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var10839 = bitcast [112 x i8]* @gsxtmgraphics-pipeline430 to i8*
call i32 (i8*, ...) @printf(i8* %var10839)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var10840 = bitcast [112 x i8]* @gsxtmgraphics-pipeline430 to i8*
call i32 (i8*, ...) @printf(i8* %var10840)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var10841 = bitcast [112 x i8]* @gsxtmgraphics-pipeline430 to i8*
call i32 (i8*, ...) @printf(i8* %var10841)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float)*,  void (i8*, i8*, i32, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, float, float, float}*
%arg_p_0 = getelementptr {i32, float, float, float}, {i32, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, float, float, float}, {i32, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {i32, float, float, float}, {i32, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {i32, float, float, float}, {i32, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_tgt_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float)*,  void (i8*, i8*, i32, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline431 = hidden constant [58 x i8] c"xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
@gsxtmgraphics-pipeline432 = hidden constant [16 x i8] c"_anon_lambda_14\00"
define dllexport fastcc void @xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ__10842(i8* %_impz,i8* %_impenv, i32 %light, float %x, float %y, float %z) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10846 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}*
%xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}* %impenv, i32 0, i32 0
%xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**** %xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQPtr_
%lightsPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}* %impenv, i32 0, i32 1
%lightsPtr = load %xtm_lights**, %xtm_lights*** %lightsPtr_
%_anon_lambda_14Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_14Ptr = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**** %_anon_lambda_14Ptr_

; setup arguments
%lightPtr = alloca i32
store i32 %light, i32* %lightPtr
%xPtr = alloca float
store float %x, float* %xPtr
%yPtr = alloca float
store float %y, float* %yPtr
%zPtr = alloca float
store float %z, float* %zPtr

; promote local stack var allocations
%tzone10887 = load i8*, i8** %_impzPtr
%zone10888 = bitcast i8* %tzone10887 to %mzone*
%ifptr10851 = alloca i1
%ifptr10856 = alloca i1

; do set!
%res10847 = call fastcc %xtm_lights* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ()
store %xtm_lights* %res10847, %xtm_lights** %lightsPtr
; do set!
%val10848 = load i32, i32* %lightPtr
%val10849 = sub i32 %val10848, 1
store i32 %val10849, i32* %lightPtr
%val10852 = load i32, i32* %lightPtr
%cmp10853 = icmp slt i32 %val10852, 0
br i1 %cmp10853, label %then10851, label %else10851

then10851:
%val10854 = load i32, i32* %lightPtr
%cmp10855 = icmp slt i32 %val10854, 0
store i1 %cmp10855, i1* %ifptr10851
br label %ifcont10851

else10851:
%val10857 = load i32, i32* %lightPtr
%cmp10858 = icmp sgt i32 %val10857, 9
br i1 %cmp10858, label %then10856, label %else10856

then10856:
%val10859 = load i32, i32* %lightPtr
%cmp10860 = icmp sgt i32 %val10859, 9
store i1 %cmp10860, i1* %ifptr10856
br label %ifcont10856

else10856:
%res10861 = call ccc i1 @impc_false()
store i1 %res10861, i1* %ifptr10856
br label %ifcont10856

ifcont10856:
%ifres10862 = load i1, i1* %ifptr10856

store i1 %ifres10862, i1* %ifptr10851
br label %ifcont10851

ifcont10851:
%ifres10863 = load i1, i1* %ifptr10851

br i1 %ifres10863, label %then10850, label %else10850

then10850:
%var10864 = bitcast [16 x i8]* @gsxtmgraphics-pipeline423 to i8*

%val10865 = call i32 (i8*, ...) @printf(i8* %var10864)
ret void

else10850:
%tzone10873 = load i8*, i8** %_impzPtr
%zone10874 = bitcast i8* %tzone10873 to %mzone*

; let assign value to symbol a
%aPtr = alloca float*
%val10867 = load i32, i32* %lightPtr
%val10868 = mul i32 %val10867, 4
%val10869 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val10870 = getelementptr %xtm_lights, %xtm_lights* %val10869, i64 0, i32 2
%val10871 = load float*, float** %val10870
; pointer ref
%val10872 = getelementptr float, float* %val10871, i32 %val10868

; let value assignment
%a = select i1 true, float* %val10872, float* %val10872
store float* %a, float** %aPtr

%val10875 = load float*, float** %aPtr
%val10876 = load float, float* %xPtr
; set pointer
%val10877 = getelementptr float, float* %val10875, i64 0
store float %val10876, float* %val10877
%val10878 = load float*, float** %aPtr
%val10879 = load float, float* %yPtr
; set pointer
%val10880 = getelementptr float, float* %val10878, i64 1
store float %val10879, float* %val10880
%val10881 = load float*, float** %aPtr
%val10882 = load float, float* %zPtr
; set pointer
%val10883 = getelementptr float, float* %val10881, i64 2
store float %val10882, float* %val10883
%val10884 = load float*, float** %aPtr
; set pointer
%val10885 = getelementptr float, float* %val10884, i64 3
store float 0x0, float* %val10885
ret void
}
@gsxtmgraphics-pipeline433 = hidden constant [111 x i8] c"xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** @xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone10921 = load i8*, i8** %_impzPtr
%zone10922 = bitcast i8* %tzone10921 to %mzone*

; let assign value to symbol xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone10922, i64 8)
%xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ to {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***
%tzone10844 = load i8*, i8** %_impzPtr
%zone10845 = bitcast i8* %tzone10844 to %mzone*

; let assign value to symbol lights
%dat_lights = call i8* @llvm_zone_malloc(%mzone* %zone10845, i64 8)
%lightsPtr = bitcast i8* %dat_lights to %xtm_lights**
%null10843 = bitcast i8* null to %xtm_lights*

; let value assignment
%lights = select i1 true, %xtm_lights* %null10843, %xtm_lights* %null10843
store %xtm_lights* %lights, %xtm_lights** %lightsPtr

%tzone10918 = load i8*, i8** %_impzPtr
%zone10919 = bitcast i8* %tzone10918 to %mzone*

; let assign value to symbol _anon_lambda_14
%dat__anon_lambda_14 = call i8* @llvm_zone_malloc(%mzone* %zone10919, i64 8)
%_anon_lambda_14Ptr = bitcast i8* %dat__anon_lambda_14 to { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***
%tzone10889 = load i8*, i8** %_impzPtr
%zone10890 = bitcast i8* %tzone10889 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10890)
; malloc closure structure
%clsptr10891 = call i8* @llvm_zone_malloc(%mzone* %zone10890, i64 24)
%closure10892 = bitcast i8* %clsptr10891 to { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*

; malloc environment structure
%envptr10893 = call i8* @llvm_zone_malloc(%mzone* %zone10890, i64 24)
%environment10894 = bitcast i8* %envptr10893 to {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}*

; malloc closure address table
%addytable10895 = call %clsvar* @new_address_table()
%var10896 = bitcast [58 x i8]* @gsxtmgraphics-pipeline431 to i8*
%var10897 = bitcast [57 x i8]* @gsxtmgraphics-pipeline425 to i8*
%addytable10898 = call %clsvar* @add_address_table(%mzone* %zone10890, i8* %var10896, i32 0, i8* %var10897, i32 3, %clsvar* %addytable10895)
%var10899 = bitcast [7 x i8]* @gsxtmgraphics-pipeline419 to i8*
%var10900 = bitcast [13 x i8]* @gsxtmgraphics-pipeline420 to i8*
%addytable10901 = call %clsvar* @add_address_table(%mzone* %zone10890, i8* %var10899, i32 8, i8* %var10900, i32 3, %clsvar* %addytable10898)
%var10902 = bitcast [16 x i8]* @gsxtmgraphics-pipeline432 to i8*
%var10903 = bitcast [57 x i8]* @gsxtmgraphics-pipeline425 to i8*
%addytable10904 = call %clsvar* @add_address_table(%mzone* %zone10890, i8* %var10902, i32 16, i8* %var10903, i32 3, %clsvar* %addytable10901)
%address-table10905 = bitcast %clsvar* %addytable10904 to i8*

; insert table, function and environment into closure struct
%closure.table10912 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure10892, i32 0, i32 0
store i8* %address-table10905, i8** %closure.table10912
%closure.env10913 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure10892, i32 0, i32 1
store i8* %envptr10893, i8** %closure.env10913
%closure.func10914 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure10892, i32 0, i32 2
store void (i8*, i8*, i32, float, float, float)* @xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ__10842, void (i8*, i8*, i32, float, float, float)** %closure.func10914
%closure_size10915 = call i64 @llvm_zone_mark_size(%mzone* %zone10890)
call void @llvm_zone_ptr_set_size(i8* %clsptr10891, i64 %closure_size10915)
%wrapper_ptr10916 = call i8* @llvm_zone_malloc(%mzone* %zone10890, i64 8)
%closure_wrapper10917 = bitcast i8* %wrapper_ptr10916 to { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure10892, { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure_wrapper10917

; let value assignment
%_anon_lambda_14 = select i1 true, { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure_wrapper10917, { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure_wrapper10917
store { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %_anon_lambda_14, { i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*** %_anon_lambda_14Ptr

; add data to environment
; don't need to alloc for env var xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr10907 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}* %environment10894, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*** %xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**** %tmp_envptr10907

; don't need to alloc for env var lights
%tmp_envptr10909 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}* %environment10894, i32 0, i32 1
store %xtm_lights** %lightsPtr, %xtm_lights*** %tmp_envptr10909

; don't need to alloc for env var _anon_lambda_14
%tmp_envptr10911 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}***}* %environment10894, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*** %_anon_lambda_14Ptr, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**** %tmp_envptr10911


%val10920 = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*** %_anon_lambda_14Ptr

; let value assignment
%xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %val10920, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %val10920
store {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*** %xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQPtr

%val10923 = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*** %xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %val10923
}


@xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** @xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ(i32 %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float)*,  void (i8*, i8*, i32, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret void
}


define dllexport ccc void @xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_native(i32 %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float)*,  void (i8*, i8*, i32, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret void
}


define dllexport ccc i8*  @xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var10924 = bitcast [111 x i8]* @gsxtmgraphics-pipeline433 to i8*
call i32 (i8*, ...) @printf(i8* %var10924)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var10925 = bitcast [111 x i8]* @gsxtmgraphics-pipeline433 to i8*
call i32 (i8*, ...) @printf(i8* %var10925)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var10926 = bitcast [111 x i8]* @gsxtmgraphics-pipeline433 to i8*
call i32 (i8*, ...) @printf(i8* %var10926)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var10927 = bitcast [111 x i8]* @gsxtmgraphics-pipeline433 to i8*
call i32 (i8*, ...) @printf(i8* %var10927)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float)*,  void (i8*, i8*, i32, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, float, float, float}*
%arg_p_0 = getelementptr {i32, float, float, float}, {i32, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, float, float, float}, {i32, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {i32, float, float, float}, {i32, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {i32, float, float, float}, {i32, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_up_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float)*,  void (i8*, i8*, i32, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline434 = hidden constant [71 x i8] c"xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
@gsxtmgraphics-pipeline435 = hidden constant [64 x i8] c"{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**\00"
@gsxtmgraphics-pipeline436 = hidden constant [16 x i8] c"_anon_lambda_15\00"
define dllexport fastcc void @xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__10928(i8* %_impz,i8* %_impenv, i32 %light, float %r, float %g, float %b, float %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone10932 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}*
%xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**** %xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_
%lightsPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}* %impenv, i32 0, i32 1
%lightsPtr = load %xtm_lights**, %xtm_lights*** %lightsPtr_
%_anon_lambda_15Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_15Ptr = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**** %_anon_lambda_15Ptr_

; setup arguments
%lightPtr = alloca i32
store i32 %light, i32* %lightPtr
%rPtr = alloca float
store float %r, float* %rPtr
%gPtr = alloca float
store float %g, float* %gPtr
%bPtr = alloca float
store float %b, float* %bPtr
%aPtr = alloca float
store float %a, float* %aPtr

; promote local stack var allocations
%tzone10974 = load i8*, i8** %_impzPtr
%zone10975 = bitcast i8* %tzone10974 to %mzone*
%ifptr10937 = alloca i1
%ifptr10942 = alloca i1

; do set!
%res10933 = call fastcc %xtm_lights* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ()
store %xtm_lights* %res10933, %xtm_lights** %lightsPtr
; do set!
%val10934 = load i32, i32* %lightPtr
%val10935 = sub i32 %val10934, 1
store i32 %val10935, i32* %lightPtr
%val10938 = load i32, i32* %lightPtr
%cmp10939 = icmp slt i32 %val10938, 0
br i1 %cmp10939, label %then10937, label %else10937

then10937:
%val10940 = load i32, i32* %lightPtr
%cmp10941 = icmp slt i32 %val10940, 0
store i1 %cmp10941, i1* %ifptr10937
br label %ifcont10937

else10937:
%val10943 = load i32, i32* %lightPtr
%cmp10944 = icmp sgt i32 %val10943, 9
br i1 %cmp10944, label %then10942, label %else10942

then10942:
%val10945 = load i32, i32* %lightPtr
%cmp10946 = icmp sgt i32 %val10945, 9
store i1 %cmp10946, i1* %ifptr10942
br label %ifcont10942

else10942:
%res10947 = call ccc i1 @impc_false()
store i1 %res10947, i1* %ifptr10942
br label %ifcont10942

ifcont10942:
%ifres10948 = load i1, i1* %ifptr10942

store i1 %ifres10948, i1* %ifptr10937
br label %ifcont10937

ifcont10937:
%ifres10949 = load i1, i1* %ifptr10937

br i1 %ifres10949, label %then10936, label %else10936

then10936:
%var10950 = bitcast [16 x i8]* @gsxtmgraphics-pipeline423 to i8*

%val10951 = call i32 (i8*, ...) @printf(i8* %var10950)
ret void

else10936:
%tzone10959 = load i8*, i8** %_impzPtr
%zone10960 = bitcast i8* %tzone10959 to %mzone*

; let assign value to symbol arr
%arrPtr = alloca float*
%val10953 = load i32, i32* %lightPtr
%val10954 = mul i32 %val10953, 4
%val10955 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val10956 = getelementptr %xtm_lights, %xtm_lights* %val10955, i64 0, i32 3
%val10957 = load float*, float** %val10956
; pointer ref
%val10958 = getelementptr float, float* %val10957, i32 %val10954

; let value assignment
%arr = select i1 true, float* %val10958, float* %val10958
store float* %arr, float** %arrPtr

%val10961 = load float*, float** %arrPtr
%val10962 = load float, float* %rPtr
; set pointer
%val10963 = getelementptr float, float* %val10961, i64 0
store float %val10962, float* %val10963
%val10964 = load float*, float** %arrPtr
%val10965 = load float, float* %gPtr
; set pointer
%val10966 = getelementptr float, float* %val10964, i64 1
store float %val10965, float* %val10966
%val10967 = load float*, float** %arrPtr
%val10968 = load float, float* %bPtr
; set pointer
%val10969 = getelementptr float, float* %val10967, i64 2
store float %val10968, float* %val10969
%val10970 = load float*, float** %arrPtr
%val10971 = load float, float* %aPtr
; set pointer
%val10972 = getelementptr float, float* %val10970, i64 3
store float %val10971, float* %val10972
ret void
}
@gsxtmgraphics-pipeline437 = hidden constant [124 x i8] c"xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** @xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11008 = load i8*, i8** %_impzPtr
%zone11009 = bitcast i8* %tzone11008 to %mzone*

; let assign value to symbol xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone11009, i64 8)
%xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ to {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***
%tzone10930 = load i8*, i8** %_impzPtr
%zone10931 = bitcast i8* %tzone10930 to %mzone*

; let assign value to symbol lights
%dat_lights = call i8* @llvm_zone_malloc(%mzone* %zone10931, i64 8)
%lightsPtr = bitcast i8* %dat_lights to %xtm_lights**
%null10929 = bitcast i8* null to %xtm_lights*

; let value assignment
%lights = select i1 true, %xtm_lights* %null10929, %xtm_lights* %null10929
store %xtm_lights* %lights, %xtm_lights** %lightsPtr

%tzone11005 = load i8*, i8** %_impzPtr
%zone11006 = bitcast i8* %tzone11005 to %mzone*

; let assign value to symbol _anon_lambda_15
%dat__anon_lambda_15 = call i8* @llvm_zone_malloc(%mzone* %zone11006, i64 8)
%_anon_lambda_15Ptr = bitcast i8* %dat__anon_lambda_15 to { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***
%tzone10976 = load i8*, i8** %_impzPtr
%zone10977 = bitcast i8* %tzone10976 to %mzone*
call void @llvm_zone_mark(%mzone* %zone10977)
; malloc closure structure
%clsptr10978 = call i8* @llvm_zone_malloc(%mzone* %zone10977, i64 24)
%closure10979 = bitcast i8* %clsptr10978 to { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*

; malloc environment structure
%envptr10980 = call i8* @llvm_zone_malloc(%mzone* %zone10977, i64 24)
%environment10981 = bitcast i8* %envptr10980 to {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}*

; malloc closure address table
%addytable10982 = call %clsvar* @new_address_table()
%var10983 = bitcast [71 x i8]* @gsxtmgraphics-pipeline434 to i8*
%var10984 = bitcast [64 x i8]* @gsxtmgraphics-pipeline435 to i8*
%addytable10985 = call %clsvar* @add_address_table(%mzone* %zone10977, i8* %var10983, i32 0, i8* %var10984, i32 3, %clsvar* %addytable10982)
%var10986 = bitcast [7 x i8]* @gsxtmgraphics-pipeline419 to i8*
%var10987 = bitcast [13 x i8]* @gsxtmgraphics-pipeline420 to i8*
%addytable10988 = call %clsvar* @add_address_table(%mzone* %zone10977, i8* %var10986, i32 8, i8* %var10987, i32 3, %clsvar* %addytable10985)
%var10989 = bitcast [16 x i8]* @gsxtmgraphics-pipeline436 to i8*
%var10990 = bitcast [64 x i8]* @gsxtmgraphics-pipeline435 to i8*
%addytable10991 = call %clsvar* @add_address_table(%mzone* %zone10977, i8* %var10989, i32 16, i8* %var10990, i32 3, %clsvar* %addytable10988)
%address-table10992 = bitcast %clsvar* %addytable10991 to i8*

; insert table, function and environment into closure struct
%closure.table10999 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure10979, i32 0, i32 0
store i8* %address-table10992, i8** %closure.table10999
%closure.env11000 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure10979, i32 0, i32 1
store i8* %envptr10980, i8** %closure.env11000
%closure.func11001 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure10979, i32 0, i32 2
store void (i8*, i8*, i32, float, float, float, float)* @xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__10928, void (i8*, i8*, i32, float, float, float, float)** %closure.func11001
%closure_size11002 = call i64 @llvm_zone_mark_size(%mzone* %zone10977)
call void @llvm_zone_ptr_set_size(i8* %clsptr10978, i64 %closure_size11002)
%wrapper_ptr11003 = call i8* @llvm_zone_malloc(%mzone* %zone10977, i64 8)
%closure_wrapper11004 = bitcast i8* %wrapper_ptr11003 to { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure10979, { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure_wrapper11004

; let value assignment
%_anon_lambda_15 = select i1 true, { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure_wrapper11004, { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure_wrapper11004
store { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %_anon_lambda_15, { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*** %_anon_lambda_15Ptr

; add data to environment
; don't need to alloc for env var xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr10994 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}* %environment10981, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*** %xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**** %tmp_envptr10994

; don't need to alloc for env var lights
%tmp_envptr10996 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}* %environment10981, i32 0, i32 1
store %xtm_lights** %lightsPtr, %xtm_lights*** %tmp_envptr10996

; don't need to alloc for env var _anon_lambda_15
%tmp_envptr10998 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}* %environment10981, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*** %_anon_lambda_15Ptr, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**** %tmp_envptr10998


%val11007 = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*** %_anon_lambda_15Ptr

; let value assignment
%xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %val11007, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %val11007
store {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*** %xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr

%val11010 = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*** %xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %val11010
}


@xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** @xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ(i32 %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float, float)*,  void (i8*, i8*, i32, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
ret void
}


define dllexport ccc void @xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_native(i32 %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float, float)*,  void (i8*, i8*, i32, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
ret void
}


define dllexport ccc i8*  @xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11011 = bitcast [124 x i8]* @gsxtmgraphics-pipeline437 to i8*
call i32 (i8*, ...) @printf(i8* %var11011)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var11012 = bitcast [124 x i8]* @gsxtmgraphics-pipeline437 to i8*
call i32 (i8*, ...) @printf(i8* %var11012)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var11013 = bitcast [124 x i8]* @gsxtmgraphics-pipeline437 to i8*
call i32 (i8*, ...) @printf(i8* %var11013)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var11014 = bitcast [124 x i8]* @gsxtmgraphics-pipeline437 to i8*
call i32 (i8*, ...) @printf(i8* %var11014)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var11015 = bitcast [124 x i8]* @gsxtmgraphics-pipeline437 to i8*
call i32 (i8*, ...) @printf(i8* %var11015)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float, float)*,  void (i8*, i8*, i32, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, float, float, float, float}*
%arg_p_0 = getelementptr {i32, float, float, float, float}, {i32, float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, float, float, float, float}, {i32, float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {i32, float, float, float, float}, {i32, float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {i32, float, float, float, float}, {i32, float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {i32, float, float, float, float}, {i32, float, float, float, float}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_ambient_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float, float)*,  void (i8*, i8*, i32, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline438 = hidden constant [71 x i8] c"xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
@gsxtmgraphics-pipeline439 = hidden constant [16 x i8] c"_anon_lambda_16\00"
define dllexport fastcc void @xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__11016(i8* %_impz,i8* %_impenv, i32 %light, float %r, float %g, float %b, float %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11020 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}*
%xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**** %xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_
%lightsPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}* %impenv, i32 0, i32 1
%lightsPtr = load %xtm_lights**, %xtm_lights*** %lightsPtr_
%_anon_lambda_16Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_16Ptr = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**** %_anon_lambda_16Ptr_

; setup arguments
%lightPtr = alloca i32
store i32 %light, i32* %lightPtr
%rPtr = alloca float
store float %r, float* %rPtr
%gPtr = alloca float
store float %g, float* %gPtr
%bPtr = alloca float
store float %b, float* %bPtr
%aPtr = alloca float
store float %a, float* %aPtr

; promote local stack var allocations
%tzone11072 = load i8*, i8** %_impzPtr
%zone11073 = bitcast i8* %tzone11072 to %mzone*
%ifptr11035 = alloca i1
%ifptr11040 = alloca i1
%ifptr11022 = alloca i32

; do set!
%res11021 = call fastcc %xtm_lights* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ()
store %xtm_lights* %res11021, %xtm_lights** %lightsPtr
%val11023 = load i32, i32* %lightPtr
%val11024 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11025 = getelementptr %xtm_lights, %xtm_lights* %val11024, i64 0, i32 9
%val11026 = load i32, i32* %val11025
%cmp11027 = icmp sgt i32 %val11023, %val11026
br i1 %cmp11027, label %then11022, label %else11022

then11022:
%val11028 = load %xtm_lights*, %xtm_lights** %lightsPtr
%val11029 = load i32, i32* %lightPtr
; set tuple
%val11030 = getelementptr %xtm_lights, %xtm_lights* %val11028, i64 0, i32 9
store i32 %val11029, i32* %val11030
store i32 %val11029, i32* %ifptr11022
br label %ifcont11022

else11022:
br label %ifcont11022

ifcont11022:
%ifres11031 = load i32, i32* %ifptr11022

; do set!
%val11032 = load i32, i32* %lightPtr
%val11033 = sub i32 %val11032, 1
store i32 %val11033, i32* %lightPtr
%val11036 = load i32, i32* %lightPtr
%cmp11037 = icmp slt i32 %val11036, 0
br i1 %cmp11037, label %then11035, label %else11035

then11035:
%val11038 = load i32, i32* %lightPtr
%cmp11039 = icmp slt i32 %val11038, 0
store i1 %cmp11039, i1* %ifptr11035
br label %ifcont11035

else11035:
%val11041 = load i32, i32* %lightPtr
%cmp11042 = icmp sgt i32 %val11041, 9
br i1 %cmp11042, label %then11040, label %else11040

then11040:
%val11043 = load i32, i32* %lightPtr
%cmp11044 = icmp sgt i32 %val11043, 9
store i1 %cmp11044, i1* %ifptr11040
br label %ifcont11040

else11040:
%res11045 = call ccc i1 @impc_false()
store i1 %res11045, i1* %ifptr11040
br label %ifcont11040

ifcont11040:
%ifres11046 = load i1, i1* %ifptr11040

store i1 %ifres11046, i1* %ifptr11035
br label %ifcont11035

ifcont11035:
%ifres11047 = load i1, i1* %ifptr11035

br i1 %ifres11047, label %then11034, label %else11034

then11034:
%var11048 = bitcast [16 x i8]* @gsxtmgraphics-pipeline423 to i8*

%val11049 = call i32 (i8*, ...) @printf(i8* %var11048)
ret void

else11034:
%tzone11057 = load i8*, i8** %_impzPtr
%zone11058 = bitcast i8* %tzone11057 to %mzone*

; let assign value to symbol arr
%arrPtr = alloca float*
%val11051 = load i32, i32* %lightPtr
%val11052 = mul i32 %val11051, 4
%val11053 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11054 = getelementptr %xtm_lights, %xtm_lights* %val11053, i64 0, i32 4
%val11055 = load float*, float** %val11054
; pointer ref
%val11056 = getelementptr float, float* %val11055, i32 %val11052

; let value assignment
%arr = select i1 true, float* %val11056, float* %val11056
store float* %arr, float** %arrPtr

%val11059 = load float*, float** %arrPtr
%val11060 = load float, float* %rPtr
; set pointer
%val11061 = getelementptr float, float* %val11059, i64 0
store float %val11060, float* %val11061
%val11062 = load float*, float** %arrPtr
%val11063 = load float, float* %gPtr
; set pointer
%val11064 = getelementptr float, float* %val11062, i64 1
store float %val11063, float* %val11064
%val11065 = load float*, float** %arrPtr
%val11066 = load float, float* %bPtr
; set pointer
%val11067 = getelementptr float, float* %val11065, i64 2
store float %val11066, float* %val11067
%val11068 = load float*, float** %arrPtr
%val11069 = load float, float* %aPtr
; set pointer
%val11070 = getelementptr float, float* %val11068, i64 3
store float %val11069, float* %val11070
ret void
}
@gsxtmgraphics-pipeline440 = hidden constant [124 x i8] c"xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** @xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11106 = load i8*, i8** %_impzPtr
%zone11107 = bitcast i8* %tzone11106 to %mzone*

; let assign value to symbol xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone11107, i64 8)
%xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ to {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***
%tzone11018 = load i8*, i8** %_impzPtr
%zone11019 = bitcast i8* %tzone11018 to %mzone*

; let assign value to symbol lights
%dat_lights = call i8* @llvm_zone_malloc(%mzone* %zone11019, i64 8)
%lightsPtr = bitcast i8* %dat_lights to %xtm_lights**
%null11017 = bitcast i8* null to %xtm_lights*

; let value assignment
%lights = select i1 true, %xtm_lights* %null11017, %xtm_lights* %null11017
store %xtm_lights* %lights, %xtm_lights** %lightsPtr

%tzone11103 = load i8*, i8** %_impzPtr
%zone11104 = bitcast i8* %tzone11103 to %mzone*

; let assign value to symbol _anon_lambda_16
%dat__anon_lambda_16 = call i8* @llvm_zone_malloc(%mzone* %zone11104, i64 8)
%_anon_lambda_16Ptr = bitcast i8* %dat__anon_lambda_16 to { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***
%tzone11074 = load i8*, i8** %_impzPtr
%zone11075 = bitcast i8* %tzone11074 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11075)
; malloc closure structure
%clsptr11076 = call i8* @llvm_zone_malloc(%mzone* %zone11075, i64 24)
%closure11077 = bitcast i8* %clsptr11076 to { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*

; malloc environment structure
%envptr11078 = call i8* @llvm_zone_malloc(%mzone* %zone11075, i64 24)
%environment11079 = bitcast i8* %envptr11078 to {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}*

; malloc closure address table
%addytable11080 = call %clsvar* @new_address_table()
%var11081 = bitcast [71 x i8]* @gsxtmgraphics-pipeline438 to i8*
%var11082 = bitcast [64 x i8]* @gsxtmgraphics-pipeline435 to i8*
%addytable11083 = call %clsvar* @add_address_table(%mzone* %zone11075, i8* %var11081, i32 0, i8* %var11082, i32 3, %clsvar* %addytable11080)
%var11084 = bitcast [7 x i8]* @gsxtmgraphics-pipeline419 to i8*
%var11085 = bitcast [13 x i8]* @gsxtmgraphics-pipeline420 to i8*
%addytable11086 = call %clsvar* @add_address_table(%mzone* %zone11075, i8* %var11084, i32 8, i8* %var11085, i32 3, %clsvar* %addytable11083)
%var11087 = bitcast [16 x i8]* @gsxtmgraphics-pipeline439 to i8*
%var11088 = bitcast [64 x i8]* @gsxtmgraphics-pipeline435 to i8*
%addytable11089 = call %clsvar* @add_address_table(%mzone* %zone11075, i8* %var11087, i32 16, i8* %var11088, i32 3, %clsvar* %addytable11086)
%address-table11090 = bitcast %clsvar* %addytable11089 to i8*

; insert table, function and environment into closure struct
%closure.table11097 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure11077, i32 0, i32 0
store i8* %address-table11090, i8** %closure.table11097
%closure.env11098 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure11077, i32 0, i32 1
store i8* %envptr11078, i8** %closure.env11098
%closure.func11099 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure11077, i32 0, i32 2
store void (i8*, i8*, i32, float, float, float, float)* @xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__11016, void (i8*, i8*, i32, float, float, float, float)** %closure.func11099
%closure_size11100 = call i64 @llvm_zone_mark_size(%mzone* %zone11075)
call void @llvm_zone_ptr_set_size(i8* %clsptr11076, i64 %closure_size11100)
%wrapper_ptr11101 = call i8* @llvm_zone_malloc(%mzone* %zone11075, i64 8)
%closure_wrapper11102 = bitcast i8* %wrapper_ptr11101 to { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure11077, { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure_wrapper11102

; let value assignment
%_anon_lambda_16 = select i1 true, { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure_wrapper11102, { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure_wrapper11102
store { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %_anon_lambda_16, { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*** %_anon_lambda_16Ptr

; add data to environment
; don't need to alloc for env var xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr11092 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}* %environment11079, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*** %xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**** %tmp_envptr11092

; don't need to alloc for env var lights
%tmp_envptr11094 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}* %environment11079, i32 0, i32 1
store %xtm_lights** %lightsPtr, %xtm_lights*** %tmp_envptr11094

; don't need to alloc for env var _anon_lambda_16
%tmp_envptr11096 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}* %environment11079, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*** %_anon_lambda_16Ptr, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**** %tmp_envptr11096


%val11105 = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*** %_anon_lambda_16Ptr

; let value assignment
%xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %val11105, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %val11105
store {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*** %xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr

%val11108 = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*** %xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %val11108
}


@xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** @xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ(i32 %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float, float)*,  void (i8*, i8*, i32, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
ret void
}


define dllexport ccc void @xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_native(i32 %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float, float)*,  void (i8*, i8*, i32, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
ret void
}


define dllexport ccc i8*  @xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11109 = bitcast [124 x i8]* @gsxtmgraphics-pipeline440 to i8*
call i32 (i8*, ...) @printf(i8* %var11109)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var11110 = bitcast [124 x i8]* @gsxtmgraphics-pipeline440 to i8*
call i32 (i8*, ...) @printf(i8* %var11110)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var11111 = bitcast [124 x i8]* @gsxtmgraphics-pipeline440 to i8*
call i32 (i8*, ...) @printf(i8* %var11111)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var11112 = bitcast [124 x i8]* @gsxtmgraphics-pipeline440 to i8*
call i32 (i8*, ...) @printf(i8* %var11112)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var11113 = bitcast [124 x i8]* @gsxtmgraphics-pipeline440 to i8*
call i32 (i8*, ...) @printf(i8* %var11113)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float, float)*,  void (i8*, i8*, i32, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, float, float, float, float}*
%arg_p_0 = getelementptr {i32, float, float, float, float}, {i32, float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, float, float, float, float}, {i32, float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {i32, float, float, float, float}, {i32, float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {i32, float, float, float, float}, {i32, float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {i32, float, float, float, float}, {i32, float, float, float, float}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_diffuse_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float, float)*,  void (i8*, i8*, i32, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline441 = hidden constant [72 x i8] c"xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ\00"
@gsxtmgraphics-pipeline442 = hidden constant [16 x i8] c"_anon_lambda_17\00"
define dllexport fastcc void @xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__11114(i8* %_impz,i8* %_impenv, i32 %light, float %r, float %g, float %b, float %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11118 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}*
%xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**** %xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr_
%lightsPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}* %impenv, i32 0, i32 1
%lightsPtr = load %xtm_lights**, %xtm_lights*** %lightsPtr_
%_anon_lambda_17Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_17Ptr = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**** %_anon_lambda_17Ptr_

; setup arguments
%lightPtr = alloca i32
store i32 %light, i32* %lightPtr
%rPtr = alloca float
store float %r, float* %rPtr
%gPtr = alloca float
store float %g, float* %gPtr
%bPtr = alloca float
store float %b, float* %bPtr
%aPtr = alloca float
store float %a, float* %aPtr

; promote local stack var allocations
%tzone11160 = load i8*, i8** %_impzPtr
%zone11161 = bitcast i8* %tzone11160 to %mzone*
%ifptr11123 = alloca i1
%ifptr11128 = alloca i1

; do set!
%res11119 = call fastcc %xtm_lights* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ()
store %xtm_lights* %res11119, %xtm_lights** %lightsPtr
; do set!
%val11120 = load i32, i32* %lightPtr
%val11121 = sub i32 %val11120, 1
store i32 %val11121, i32* %lightPtr
%val11124 = load i32, i32* %lightPtr
%cmp11125 = icmp slt i32 %val11124, 0
br i1 %cmp11125, label %then11123, label %else11123

then11123:
%val11126 = load i32, i32* %lightPtr
%cmp11127 = icmp slt i32 %val11126, 0
store i1 %cmp11127, i1* %ifptr11123
br label %ifcont11123

else11123:
%val11129 = load i32, i32* %lightPtr
%cmp11130 = icmp sgt i32 %val11129, 9
br i1 %cmp11130, label %then11128, label %else11128

then11128:
%val11131 = load i32, i32* %lightPtr
%cmp11132 = icmp sgt i32 %val11131, 9
store i1 %cmp11132, i1* %ifptr11128
br label %ifcont11128

else11128:
%res11133 = call ccc i1 @impc_false()
store i1 %res11133, i1* %ifptr11128
br label %ifcont11128

ifcont11128:
%ifres11134 = load i1, i1* %ifptr11128

store i1 %ifres11134, i1* %ifptr11123
br label %ifcont11123

ifcont11123:
%ifres11135 = load i1, i1* %ifptr11123

br i1 %ifres11135, label %then11122, label %else11122

then11122:
%var11136 = bitcast [16 x i8]* @gsxtmgraphics-pipeline423 to i8*

%val11137 = call i32 (i8*, ...) @printf(i8* %var11136)
ret void

else11122:
%tzone11145 = load i8*, i8** %_impzPtr
%zone11146 = bitcast i8* %tzone11145 to %mzone*

; let assign value to symbol arr
%arrPtr = alloca float*
%val11139 = load i32, i32* %lightPtr
%val11140 = mul i32 %val11139, 4
%val11141 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11142 = getelementptr %xtm_lights, %xtm_lights* %val11141, i64 0, i32 5
%val11143 = load float*, float** %val11142
; pointer ref
%val11144 = getelementptr float, float* %val11143, i32 %val11140

; let value assignment
%arr = select i1 true, float* %val11144, float* %val11144
store float* %arr, float** %arrPtr

%val11147 = load float*, float** %arrPtr
%val11148 = load float, float* %rPtr
; set pointer
%val11149 = getelementptr float, float* %val11147, i64 0
store float %val11148, float* %val11149
%val11150 = load float*, float** %arrPtr
%val11151 = load float, float* %gPtr
; set pointer
%val11152 = getelementptr float, float* %val11150, i64 1
store float %val11151, float* %val11152
%val11153 = load float*, float** %arrPtr
%val11154 = load float, float* %bPtr
; set pointer
%val11155 = getelementptr float, float* %val11153, i64 2
store float %val11154, float* %val11155
%val11156 = load float*, float** %arrPtr
%val11157 = load float, float* %aPtr
; set pointer
%val11158 = getelementptr float, float* %val11156, i64 3
store float %val11157, float* %val11158
ret void
}
@gsxtmgraphics-pipeline443 = hidden constant [125 x i8] c"xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** @xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11194 = load i8*, i8** %_impzPtr
%zone11195 = bitcast i8* %tzone11194 to %mzone*

; let assign value to symbol xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%dat_xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone11195, i64 8)
%xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr = bitcast i8* %dat_xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ to {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***
%tzone11116 = load i8*, i8** %_impzPtr
%zone11117 = bitcast i8* %tzone11116 to %mzone*

; let assign value to symbol lights
%dat_lights = call i8* @llvm_zone_malloc(%mzone* %zone11117, i64 8)
%lightsPtr = bitcast i8* %dat_lights to %xtm_lights**
%null11115 = bitcast i8* null to %xtm_lights*

; let value assignment
%lights = select i1 true, %xtm_lights* %null11115, %xtm_lights* %null11115
store %xtm_lights* %lights, %xtm_lights** %lightsPtr

%tzone11191 = load i8*, i8** %_impzPtr
%zone11192 = bitcast i8* %tzone11191 to %mzone*

; let assign value to symbol _anon_lambda_17
%dat__anon_lambda_17 = call i8* @llvm_zone_malloc(%mzone* %zone11192, i64 8)
%_anon_lambda_17Ptr = bitcast i8* %dat__anon_lambda_17 to { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***
%tzone11162 = load i8*, i8** %_impzPtr
%zone11163 = bitcast i8* %tzone11162 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11163)
; malloc closure structure
%clsptr11164 = call i8* @llvm_zone_malloc(%mzone* %zone11163, i64 24)
%closure11165 = bitcast i8* %clsptr11164 to { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*

; malloc environment structure
%envptr11166 = call i8* @llvm_zone_malloc(%mzone* %zone11163, i64 24)
%environment11167 = bitcast i8* %envptr11166 to {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}*

; malloc closure address table
%addytable11168 = call %clsvar* @new_address_table()
%var11169 = bitcast [72 x i8]* @gsxtmgraphics-pipeline441 to i8*
%var11170 = bitcast [64 x i8]* @gsxtmgraphics-pipeline435 to i8*
%addytable11171 = call %clsvar* @add_address_table(%mzone* %zone11163, i8* %var11169, i32 0, i8* %var11170, i32 3, %clsvar* %addytable11168)
%var11172 = bitcast [7 x i8]* @gsxtmgraphics-pipeline419 to i8*
%var11173 = bitcast [13 x i8]* @gsxtmgraphics-pipeline420 to i8*
%addytable11174 = call %clsvar* @add_address_table(%mzone* %zone11163, i8* %var11172, i32 8, i8* %var11173, i32 3, %clsvar* %addytable11171)
%var11175 = bitcast [16 x i8]* @gsxtmgraphics-pipeline442 to i8*
%var11176 = bitcast [64 x i8]* @gsxtmgraphics-pipeline435 to i8*
%addytable11177 = call %clsvar* @add_address_table(%mzone* %zone11163, i8* %var11175, i32 16, i8* %var11176, i32 3, %clsvar* %addytable11174)
%address-table11178 = bitcast %clsvar* %addytable11177 to i8*

; insert table, function and environment into closure struct
%closure.table11185 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure11165, i32 0, i32 0
store i8* %address-table11178, i8** %closure.table11185
%closure.env11186 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure11165, i32 0, i32 1
store i8* %envptr11166, i8** %closure.env11186
%closure.func11187 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure11165, i32 0, i32 2
store void (i8*, i8*, i32, float, float, float, float)* @xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ__11114, void (i8*, i8*, i32, float, float, float, float)** %closure.func11187
%closure_size11188 = call i64 @llvm_zone_mark_size(%mzone* %zone11163)
call void @llvm_zone_ptr_set_size(i8* %clsptr11164, i64 %closure_size11188)
%wrapper_ptr11189 = call i8* @llvm_zone_malloc(%mzone* %zone11163, i64 8)
%closure_wrapper11190 = bitcast i8* %wrapper_ptr11189 to { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure11165, { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure_wrapper11190

; let value assignment
%_anon_lambda_17 = select i1 true, { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure_wrapper11190, { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure_wrapper11190
store { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %_anon_lambda_17, { i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*** %_anon_lambda_17Ptr

; add data to environment
; don't need to alloc for env var xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ
%tmp_envptr11180 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}* %environment11167, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*** %xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**** %tmp_envptr11180

; don't need to alloc for env var lights
%tmp_envptr11182 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}* %environment11167, i32 0, i32 1
store %xtm_lights** %lightsPtr, %xtm_lights*** %tmp_envptr11182

; don't need to alloc for env var _anon_lambda_17
%tmp_envptr11184 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}***}* %environment11167, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*** %_anon_lambda_17Ptr, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**** %tmp_envptr11184


%val11193 = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*** %_anon_lambda_17Ptr

; let value assignment
%xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ = select i1 true, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %val11193, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %val11193
store {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*** %xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr

%val11196 = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*** %xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQPtr
ret {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %val11196
}


@xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** @xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ(i32 %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float, float)*,  void (i8*, i8*, i32, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
ret void
}


define dllexport ccc void @xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_native(i32 %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float, float)*,  void (i8*, i8*, i32, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
ret void
}


define dllexport ccc i8*  @xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11197 = bitcast [125 x i8]* @gsxtmgraphics-pipeline443 to i8*
call i32 (i8*, ...) @printf(i8* %var11197)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var11198 = bitcast [125 x i8]* @gsxtmgraphics-pipeline443 to i8*
call i32 (i8*, ...) @printf(i8* %var11198)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var11199 = bitcast [125 x i8]* @gsxtmgraphics-pipeline443 to i8*
call i32 (i8*, ...) @printf(i8* %var11199)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var11200 = bitcast [125 x i8]* @gsxtmgraphics-pipeline443 to i8*
call i32 (i8*, ...) @printf(i8* %var11200)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var11201 = bitcast [125 x i8]* @gsxtmgraphics-pipeline443 to i8*
call i32 (i8*, ...) @printf(i8* %var11201)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float, float)*,  void (i8*, i8*, i32, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, float, float, float, float}*
%arg_p_0 = getelementptr {i32, float, float, float, float}, {i32, float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, float, float, float, float}, {i32, float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {i32, float, float, float, float}, {i32, float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {i32, float, float, float, float}, {i32, float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {i32, float, float, float, float}, {i32, float, float, float, float}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_specular_adhoc_W3ZvaWQsaTMyLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, i32, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float, float, float, float)*,  void (i8*, i8*, i32, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline444 = hidden constant [45 x i8] c"xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ\00"
@gsxtmgraphics-pipeline445 = hidden constant [43 x i8] c"{i8*, i8*, void (i8*, i8*, i32, float)*}**\00"
@gsxtmgraphics-pipeline446 = hidden constant [16 x i8] c"_anon_lambda_18\00"
define dllexport fastcc void @xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ__11202(i8* %_impz,i8* %_impenv, i32 %light, float %power) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11206 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}*
%xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}* %impenv, i32 0, i32 0
%xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQPtr = load {i8*, i8*, void (i8*, i8*, i32, float)*}***, {i8*, i8*, void (i8*, i8*, i32, float)*}**** %xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQPtr_
%lightsPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}* %impenv, i32 0, i32 1
%lightsPtr = load %xtm_lights**, %xtm_lights*** %lightsPtr_
%_anon_lambda_18Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_18Ptr = load {i8*, i8*, void (i8*, i8*, i32, float)*}***, {i8*, i8*, void (i8*, i8*, i32, float)*}**** %_anon_lambda_18Ptr_

; setup arguments
%lightPtr = alloca i32
store i32 %light, i32* %lightPtr
%powerPtr = alloca float
store float %power, float* %powerPtr

; promote local stack var allocations
%tzone11244 = load i8*, i8** %_impzPtr
%zone11245 = bitcast i8* %tzone11244 to %mzone*
%ifptr11221 = alloca i1
%ifptr11226 = alloca i1
%ifptr11208 = alloca i32

; do set!
%res11207 = call fastcc %xtm_lights* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ()
store %xtm_lights* %res11207, %xtm_lights** %lightsPtr
%val11209 = load i32, i32* %lightPtr
%val11210 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11211 = getelementptr %xtm_lights, %xtm_lights* %val11210, i64 0, i32 9
%val11212 = load i32, i32* %val11211
%cmp11213 = icmp sgt i32 %val11209, %val11212
br i1 %cmp11213, label %then11208, label %else11208

then11208:
%val11214 = load %xtm_lights*, %xtm_lights** %lightsPtr
%val11215 = load i32, i32* %lightPtr
; set tuple
%val11216 = getelementptr %xtm_lights, %xtm_lights* %val11214, i64 0, i32 9
store i32 %val11215, i32* %val11216
store i32 %val11215, i32* %ifptr11208
br label %ifcont11208

else11208:
br label %ifcont11208

ifcont11208:
%ifres11217 = load i32, i32* %ifptr11208

; do set!
%val11218 = load i32, i32* %lightPtr
%val11219 = sub i32 %val11218, 1
store i32 %val11219, i32* %lightPtr
%val11222 = load i32, i32* %lightPtr
%cmp11223 = icmp slt i32 %val11222, 0
br i1 %cmp11223, label %then11221, label %else11221

then11221:
%val11224 = load i32, i32* %lightPtr
%cmp11225 = icmp slt i32 %val11224, 0
store i1 %cmp11225, i1* %ifptr11221
br label %ifcont11221

else11221:
%val11227 = load i32, i32* %lightPtr
%cmp11228 = icmp sgt i32 %val11227, 9
br i1 %cmp11228, label %then11226, label %else11226

then11226:
%val11229 = load i32, i32* %lightPtr
%cmp11230 = icmp sgt i32 %val11229, 9
store i1 %cmp11230, i1* %ifptr11226
br label %ifcont11226

else11226:
%res11231 = call ccc i1 @impc_false()
store i1 %res11231, i1* %ifptr11226
br label %ifcont11226

ifcont11226:
%ifres11232 = load i1, i1* %ifptr11226

store i1 %ifres11232, i1* %ifptr11221
br label %ifcont11221

ifcont11221:
%ifres11233 = load i1, i1* %ifptr11221

br i1 %ifres11233, label %then11220, label %else11220

then11220:
%var11234 = bitcast [16 x i8]* @gsxtmgraphics-pipeline423 to i8*

%val11235 = call i32 (i8*, ...) @printf(i8* %var11234)
ret void

else11220:
%val11237 = load i32, i32* %lightPtr
%val11238 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11239 = getelementptr %xtm_lights, %xtm_lights* %val11238, i64 0, i32 6
%val11240 = load float*, float** %val11239
%val11241 = load float, float* %powerPtr
; set pointer
%val11242 = getelementptr float, float* %val11240, i32 %val11237
store float %val11241, float* %val11242
ret void
}
@gsxtmgraphics-pipeline447 = hidden constant [98 x i8] c"xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i32, float)*}** @xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11278 = load i8*, i8** %_impzPtr
%zone11279 = bitcast i8* %tzone11278 to %mzone*

; let assign value to symbol xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ
%dat_xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone11279, i64 8)
%xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQPtr = bitcast i8* %dat_xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ to {i8*, i8*, void (i8*, i8*, i32, float)*}***
%tzone11204 = load i8*, i8** %_impzPtr
%zone11205 = bitcast i8* %tzone11204 to %mzone*

; let assign value to symbol lights
%dat_lights = call i8* @llvm_zone_malloc(%mzone* %zone11205, i64 8)
%lightsPtr = bitcast i8* %dat_lights to %xtm_lights**
%null11203 = bitcast i8* null to %xtm_lights*

; let value assignment
%lights = select i1 true, %xtm_lights* %null11203, %xtm_lights* %null11203
store %xtm_lights* %lights, %xtm_lights** %lightsPtr

%tzone11275 = load i8*, i8** %_impzPtr
%zone11276 = bitcast i8* %tzone11275 to %mzone*

; let assign value to symbol _anon_lambda_18
%dat__anon_lambda_18 = call i8* @llvm_zone_malloc(%mzone* %zone11276, i64 8)
%_anon_lambda_18Ptr = bitcast i8* %dat__anon_lambda_18 to { i8*, i8*, void (i8*, i8*, i32, float)*}***
%tzone11246 = load i8*, i8** %_impzPtr
%zone11247 = bitcast i8* %tzone11246 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11247)
; malloc closure structure
%clsptr11248 = call i8* @llvm_zone_malloc(%mzone* %zone11247, i64 24)
%closure11249 = bitcast i8* %clsptr11248 to { i8*, i8*, void (i8*, i8*, i32, float)*}*

; malloc environment structure
%envptr11250 = call i8* @llvm_zone_malloc(%mzone* %zone11247, i64 24)
%environment11251 = bitcast i8* %envptr11250 to {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}*

; malloc closure address table
%addytable11252 = call %clsvar* @new_address_table()
%var11253 = bitcast [45 x i8]* @gsxtmgraphics-pipeline444 to i8*
%var11254 = bitcast [43 x i8]* @gsxtmgraphics-pipeline445 to i8*
%addytable11255 = call %clsvar* @add_address_table(%mzone* %zone11247, i8* %var11253, i32 0, i8* %var11254, i32 3, %clsvar* %addytable11252)
%var11256 = bitcast [7 x i8]* @gsxtmgraphics-pipeline419 to i8*
%var11257 = bitcast [13 x i8]* @gsxtmgraphics-pipeline420 to i8*
%addytable11258 = call %clsvar* @add_address_table(%mzone* %zone11247, i8* %var11256, i32 8, i8* %var11257, i32 3, %clsvar* %addytable11255)
%var11259 = bitcast [16 x i8]* @gsxtmgraphics-pipeline446 to i8*
%var11260 = bitcast [43 x i8]* @gsxtmgraphics-pipeline445 to i8*
%addytable11261 = call %clsvar* @add_address_table(%mzone* %zone11247, i8* %var11259, i32 16, i8* %var11260, i32 3, %clsvar* %addytable11258)
%address-table11262 = bitcast %clsvar* %addytable11261 to i8*

; insert table, function and environment into closure struct
%closure.table11269 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float)*}, { i8*, i8*, void (i8*, i8*, i32, float)*}* %closure11249, i32 0, i32 0
store i8* %address-table11262, i8** %closure.table11269
%closure.env11270 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float)*}, { i8*, i8*, void (i8*, i8*, i32, float)*}* %closure11249, i32 0, i32 1
store i8* %envptr11250, i8** %closure.env11270
%closure.func11271 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float)*}, { i8*, i8*, void (i8*, i8*, i32, float)*}* %closure11249, i32 0, i32 2
store void (i8*, i8*, i32, float)* @xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ__11202, void (i8*, i8*, i32, float)** %closure.func11271
%closure_size11272 = call i64 @llvm_zone_mark_size(%mzone* %zone11247)
call void @llvm_zone_ptr_set_size(i8* %clsptr11248, i64 %closure_size11272)
%wrapper_ptr11273 = call i8* @llvm_zone_malloc(%mzone* %zone11247, i64 8)
%closure_wrapper11274 = bitcast i8* %wrapper_ptr11273 to { i8*, i8*, void (i8*, i8*, i32, float)*}**
store { i8*, i8*, void (i8*, i8*, i32, float)*}* %closure11249, { i8*, i8*, void (i8*, i8*, i32, float)*}** %closure_wrapper11274

; let value assignment
%_anon_lambda_18 = select i1 true, { i8*, i8*, void (i8*, i8*, i32, float)*}** %closure_wrapper11274, { i8*, i8*, void (i8*, i8*, i32, float)*}** %closure_wrapper11274
store { i8*, i8*, void (i8*, i8*, i32, float)*}** %_anon_lambda_18, { i8*, i8*, void (i8*, i8*, i32, float)*}*** %_anon_lambda_18Ptr

; add data to environment
; don't need to alloc for env var xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ
%tmp_envptr11264 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}* %environment11251, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i32, float)*}*** %xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQPtr, {i8*, i8*, void (i8*, i8*, i32, float)*}**** %tmp_envptr11264

; don't need to alloc for env var lights
%tmp_envptr11266 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}* %environment11251, i32 0, i32 1
store %xtm_lights** %lightsPtr, %xtm_lights*** %tmp_envptr11266

; don't need to alloc for env var _anon_lambda_18
%tmp_envptr11268 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}* %environment11251, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, i32, float)*}*** %_anon_lambda_18Ptr, {i8*, i8*, void (i8*, i8*, i32, float)*}**** %tmp_envptr11268


%val11277 = load {i8*, i8*, void (i8*, i8*, i32, float)*}**, {i8*, i8*, void (i8*, i8*, i32, float)*}*** %_anon_lambda_18Ptr

; let value assignment
%xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ = select i1 true, {i8*, i8*, void (i8*, i8*, i32, float)*}** %val11277, {i8*, i8*, void (i8*, i8*, i32, float)*}** %val11277
store {i8*, i8*, void (i8*, i8*, i32, float)*}** %xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ, {i8*, i8*, void (i8*, i8*, i32, float)*}*** %xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQPtr

%val11280 = load {i8*, i8*, void (i8*, i8*, i32, float)*}**, {i8*, i8*, void (i8*, i8*, i32, float)*}*** %xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQPtr
ret {i8*, i8*, void (i8*, i8*, i32, float)*}** %val11280
}


@xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i32, float)*}** @xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i32, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float)*}, {i8*, i8*, void (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float)*}, {i8*, i8*, void (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float)*,  void (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
ret void
}


define dllexport ccc void @xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_native(i32 %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float)*}, {i8*, i8*, void (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float)*}, {i8*, i8*, void (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float)*,  void (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
ret void
}


define dllexport ccc i8*  @xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11281 = bitcast [98 x i8]* @gsxtmgraphics-pipeline447 to i8*
call i32 (i8*, ...) @printf(i8* %var11281)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var11282 = bitcast [98 x i8]* @gsxtmgraphics-pipeline447 to i8*
call i32 (i8*, ...) @printf(i8* %var11282)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float)*}, {i8*, i8*, void (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float)*}, {i8*, i8*, void (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float)*,  void (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, float}*
%arg_p_0 = getelementptr {i32, float}, {i32, float}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, float}, {i32, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_power_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float)*}, {i8*, i8*, void (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float)*}, {i8*, i8*, void (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float)*,  void (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline448 = hidden constant [45 x i8] c"xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ\00"
@gsxtmgraphics-pipeline449 = hidden constant [16 x i8] c"_anon_lambda_19\00"
define dllexport fastcc void @xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ__11283(i8* %_impz,i8* %_impenv, i32 %light, float %angle) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11287 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}*
%xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}* %impenv, i32 0, i32 0
%xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQPtr = load {i8*, i8*, void (i8*, i8*, i32, float)*}***, {i8*, i8*, void (i8*, i8*, i32, float)*}**** %xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQPtr_
%lightsPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}* %impenv, i32 0, i32 1
%lightsPtr = load %xtm_lights**, %xtm_lights*** %lightsPtr_
%_anon_lambda_19Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_19Ptr = load {i8*, i8*, void (i8*, i8*, i32, float)*}***, {i8*, i8*, void (i8*, i8*, i32, float)*}**** %_anon_lambda_19Ptr_

; setup arguments
%lightPtr = alloca i32
store i32 %light, i32* %lightPtr
%anglePtr = alloca float
store float %angle, float* %anglePtr

; promote local stack var allocations
%tzone11325 = load i8*, i8** %_impzPtr
%zone11326 = bitcast i8* %tzone11325 to %mzone*
%ifptr11302 = alloca i1
%ifptr11307 = alloca i1
%ifptr11289 = alloca i32

; do set!
%res11288 = call fastcc %xtm_lights* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ()
store %xtm_lights* %res11288, %xtm_lights** %lightsPtr
%val11290 = load i32, i32* %lightPtr
%val11291 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11292 = getelementptr %xtm_lights, %xtm_lights* %val11291, i64 0, i32 9
%val11293 = load i32, i32* %val11292
%cmp11294 = icmp sgt i32 %val11290, %val11293
br i1 %cmp11294, label %then11289, label %else11289

then11289:
%val11295 = load %xtm_lights*, %xtm_lights** %lightsPtr
%val11296 = load i32, i32* %lightPtr
; set tuple
%val11297 = getelementptr %xtm_lights, %xtm_lights* %val11295, i64 0, i32 9
store i32 %val11296, i32* %val11297
store i32 %val11296, i32* %ifptr11289
br label %ifcont11289

else11289:
br label %ifcont11289

ifcont11289:
%ifres11298 = load i32, i32* %ifptr11289

; do set!
%val11299 = load i32, i32* %lightPtr
%val11300 = sub i32 %val11299, 1
store i32 %val11300, i32* %lightPtr
%val11303 = load i32, i32* %lightPtr
%cmp11304 = icmp slt i32 %val11303, 0
br i1 %cmp11304, label %then11302, label %else11302

then11302:
%val11305 = load i32, i32* %lightPtr
%cmp11306 = icmp slt i32 %val11305, 0
store i1 %cmp11306, i1* %ifptr11302
br label %ifcont11302

else11302:
%val11308 = load i32, i32* %lightPtr
%cmp11309 = icmp sgt i32 %val11308, 9
br i1 %cmp11309, label %then11307, label %else11307

then11307:
%val11310 = load i32, i32* %lightPtr
%cmp11311 = icmp sgt i32 %val11310, 9
store i1 %cmp11311, i1* %ifptr11307
br label %ifcont11307

else11307:
%res11312 = call ccc i1 @impc_false()
store i1 %res11312, i1* %ifptr11307
br label %ifcont11307

ifcont11307:
%ifres11313 = load i1, i1* %ifptr11307

store i1 %ifres11313, i1* %ifptr11302
br label %ifcont11302

ifcont11302:
%ifres11314 = load i1, i1* %ifptr11302

br i1 %ifres11314, label %then11301, label %else11301

then11301:
%var11315 = bitcast [16 x i8]* @gsxtmgraphics-pipeline423 to i8*

%val11316 = call i32 (i8*, ...) @printf(i8* %var11315)
ret void

else11301:
%val11318 = load i32, i32* %lightPtr
%val11319 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11320 = getelementptr %xtm_lights, %xtm_lights* %val11319, i64 0, i32 7
%val11321 = load float*, float** %val11320
%val11322 = load float, float* %anglePtr
; set pointer
%val11323 = getelementptr float, float* %val11321, i32 %val11318
store float %val11322, float* %val11323
ret void
}
@gsxtmgraphics-pipeline450 = hidden constant [98 x i8] c"xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i32, float)*}** @xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11359 = load i8*, i8** %_impzPtr
%zone11360 = bitcast i8* %tzone11359 to %mzone*

; let assign value to symbol xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ
%dat_xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone11360, i64 8)
%xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQPtr = bitcast i8* %dat_xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ to {i8*, i8*, void (i8*, i8*, i32, float)*}***
%tzone11285 = load i8*, i8** %_impzPtr
%zone11286 = bitcast i8* %tzone11285 to %mzone*

; let assign value to symbol lights
%dat_lights = call i8* @llvm_zone_malloc(%mzone* %zone11286, i64 8)
%lightsPtr = bitcast i8* %dat_lights to %xtm_lights**
%null11284 = bitcast i8* null to %xtm_lights*

; let value assignment
%lights = select i1 true, %xtm_lights* %null11284, %xtm_lights* %null11284
store %xtm_lights* %lights, %xtm_lights** %lightsPtr

%tzone11356 = load i8*, i8** %_impzPtr
%zone11357 = bitcast i8* %tzone11356 to %mzone*

; let assign value to symbol _anon_lambda_19
%dat__anon_lambda_19 = call i8* @llvm_zone_malloc(%mzone* %zone11357, i64 8)
%_anon_lambda_19Ptr = bitcast i8* %dat__anon_lambda_19 to { i8*, i8*, void (i8*, i8*, i32, float)*}***
%tzone11327 = load i8*, i8** %_impzPtr
%zone11328 = bitcast i8* %tzone11327 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11328)
; malloc closure structure
%clsptr11329 = call i8* @llvm_zone_malloc(%mzone* %zone11328, i64 24)
%closure11330 = bitcast i8* %clsptr11329 to { i8*, i8*, void (i8*, i8*, i32, float)*}*

; malloc environment structure
%envptr11331 = call i8* @llvm_zone_malloc(%mzone* %zone11328, i64 24)
%environment11332 = bitcast i8* %envptr11331 to {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}*

; malloc closure address table
%addytable11333 = call %clsvar* @new_address_table()
%var11334 = bitcast [45 x i8]* @gsxtmgraphics-pipeline448 to i8*
%var11335 = bitcast [43 x i8]* @gsxtmgraphics-pipeline445 to i8*
%addytable11336 = call %clsvar* @add_address_table(%mzone* %zone11328, i8* %var11334, i32 0, i8* %var11335, i32 3, %clsvar* %addytable11333)
%var11337 = bitcast [7 x i8]* @gsxtmgraphics-pipeline419 to i8*
%var11338 = bitcast [13 x i8]* @gsxtmgraphics-pipeline420 to i8*
%addytable11339 = call %clsvar* @add_address_table(%mzone* %zone11328, i8* %var11337, i32 8, i8* %var11338, i32 3, %clsvar* %addytable11336)
%var11340 = bitcast [16 x i8]* @gsxtmgraphics-pipeline449 to i8*
%var11341 = bitcast [43 x i8]* @gsxtmgraphics-pipeline445 to i8*
%addytable11342 = call %clsvar* @add_address_table(%mzone* %zone11328, i8* %var11340, i32 16, i8* %var11341, i32 3, %clsvar* %addytable11339)
%address-table11343 = bitcast %clsvar* %addytable11342 to i8*

; insert table, function and environment into closure struct
%closure.table11350 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float)*}, { i8*, i8*, void (i8*, i8*, i32, float)*}* %closure11330, i32 0, i32 0
store i8* %address-table11343, i8** %closure.table11350
%closure.env11351 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float)*}, { i8*, i8*, void (i8*, i8*, i32, float)*}* %closure11330, i32 0, i32 1
store i8* %envptr11331, i8** %closure.env11351
%closure.func11352 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float)*}, { i8*, i8*, void (i8*, i8*, i32, float)*}* %closure11330, i32 0, i32 2
store void (i8*, i8*, i32, float)* @xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ__11283, void (i8*, i8*, i32, float)** %closure.func11352
%closure_size11353 = call i64 @llvm_zone_mark_size(%mzone* %zone11328)
call void @llvm_zone_ptr_set_size(i8* %clsptr11329, i64 %closure_size11353)
%wrapper_ptr11354 = call i8* @llvm_zone_malloc(%mzone* %zone11328, i64 8)
%closure_wrapper11355 = bitcast i8* %wrapper_ptr11354 to { i8*, i8*, void (i8*, i8*, i32, float)*}**
store { i8*, i8*, void (i8*, i8*, i32, float)*}* %closure11330, { i8*, i8*, void (i8*, i8*, i32, float)*}** %closure_wrapper11355

; let value assignment
%_anon_lambda_19 = select i1 true, { i8*, i8*, void (i8*, i8*, i32, float)*}** %closure_wrapper11355, { i8*, i8*, void (i8*, i8*, i32, float)*}** %closure_wrapper11355
store { i8*, i8*, void (i8*, i8*, i32, float)*}** %_anon_lambda_19, { i8*, i8*, void (i8*, i8*, i32, float)*}*** %_anon_lambda_19Ptr

; add data to environment
; don't need to alloc for env var xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ
%tmp_envptr11345 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}* %environment11332, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i32, float)*}*** %xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQPtr, {i8*, i8*, void (i8*, i8*, i32, float)*}**** %tmp_envptr11345

; don't need to alloc for env var lights
%tmp_envptr11347 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}* %environment11332, i32 0, i32 1
store %xtm_lights** %lightsPtr, %xtm_lights*** %tmp_envptr11347

; don't need to alloc for env var _anon_lambda_19
%tmp_envptr11349 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float)*}***}* %environment11332, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, i32, float)*}*** %_anon_lambda_19Ptr, {i8*, i8*, void (i8*, i8*, i32, float)*}**** %tmp_envptr11349


%val11358 = load {i8*, i8*, void (i8*, i8*, i32, float)*}**, {i8*, i8*, void (i8*, i8*, i32, float)*}*** %_anon_lambda_19Ptr

; let value assignment
%xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ = select i1 true, {i8*, i8*, void (i8*, i8*, i32, float)*}** %val11358, {i8*, i8*, void (i8*, i8*, i32, float)*}** %val11358
store {i8*, i8*, void (i8*, i8*, i32, float)*}** %xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ, {i8*, i8*, void (i8*, i8*, i32, float)*}*** %xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQPtr

%val11361 = load {i8*, i8*, void (i8*, i8*, i32, float)*}**, {i8*, i8*, void (i8*, i8*, i32, float)*}*** %xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQPtr
ret {i8*, i8*, void (i8*, i8*, i32, float)*}** %val11361
}


@xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i32, float)*}** @xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i32, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float)*}, {i8*, i8*, void (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float)*}, {i8*, i8*, void (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float)*,  void (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
ret void
}


define dllexport ccc void @xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_native(i32 %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float)*}, {i8*, i8*, void (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float)*}, {i8*, i8*, void (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float)*,  void (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
ret void
}


define dllexport ccc i8*  @xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11362 = bitcast [98 x i8]* @gsxtmgraphics-pipeline450 to i8*
call i32 (i8*, ...) @printf(i8* %var11362)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var11363 = bitcast [98 x i8]* @gsxtmgraphics-pipeline450 to i8*
call i32 (i8*, ...) @printf(i8* %var11363)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float)*}, {i8*, i8*, void (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float)*}, {i8*, i8*, void (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float)*,  void (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, float}*
%arg_p_0 = getelementptr {i32, float}, {i32, float}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, float}, {i32, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_angle_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float)*}*, {i8*, i8*, void (i8*, i8*, i32, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float)*}, {i8*, i8*, void (i8*, i8*, i32, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float)*}, {i8*, i8*, void (i8*, i8*, i32, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float)*,  void (i8*, i8*, i32, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline451 = hidden constant [45 x i8] c"xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0\00"
@gsxtmgraphics-pipeline452 = hidden constant [44 x i8] c"{i8*, i8*, void (i8*, i8*, i32, float*)*}**\00"
@gsxtmgraphics-pipeline453 = hidden constant [16 x i8] c"_anon_lambda_20\00"
define dllexport fastcc void @xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0__11364(i8* %_impz,i8* %_impenv, i32 %light, float* %view) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11368 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i32, float*)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float*)*}***}*
%xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float*)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float*)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float*)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float*)*}***}* %impenv, i32 0, i32 0
%xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0Ptr = load {i8*, i8*, void (i8*, i8*, i32, float*)*}***, {i8*, i8*, void (i8*, i8*, i32, float*)*}**** %xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0Ptr_
%lightsPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float*)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float*)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float*)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float*)*}***}* %impenv, i32 0, i32 1
%lightsPtr = load %xtm_lights**, %xtm_lights*** %lightsPtr_
%_anon_lambda_20Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float*)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float*)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float*)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float*)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_20Ptr = load {i8*, i8*, void (i8*, i8*, i32, float*)*}***, {i8*, i8*, void (i8*, i8*, i32, float*)*}**** %_anon_lambda_20Ptr_

; setup arguments
%lightPtr = alloca i32
store i32 %light, i32* %lightPtr
%viewPtr = alloca float*
store float* %view, float** %viewPtr

; promote local stack var allocations
%tzone11430 = load i8*, i8** %_impzPtr
%zone11431 = bitcast i8* %tzone11430 to %mzone*
%ifptr11415 = alloca i1
%ifptr11373 = alloca i1
%ifptr11378 = alloca i1

; do set!
%res11369 = call fastcc %xtm_lights* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ()
store %xtm_lights* %res11369, %xtm_lights** %lightsPtr
; do set!
%val11370 = load i32, i32* %lightPtr
%val11371 = sub i32 %val11370, 1
store i32 %val11371, i32* %lightPtr
%val11374 = load i32, i32* %lightPtr
%cmp11375 = icmp slt i32 %val11374, 0
br i1 %cmp11375, label %then11373, label %else11373

then11373:
%val11376 = load i32, i32* %lightPtr
%cmp11377 = icmp slt i32 %val11376, 0
store i1 %cmp11377, i1* %ifptr11373
br label %ifcont11373

else11373:
%val11379 = load i32, i32* %lightPtr
%cmp11380 = icmp sgt i32 %val11379, 9
br i1 %cmp11380, label %then11378, label %else11378

then11378:
%val11381 = load i32, i32* %lightPtr
%cmp11382 = icmp sgt i32 %val11381, 9
store i1 %cmp11382, i1* %ifptr11378
br label %ifcont11378

else11378:
%res11383 = call ccc i1 @impc_false()
store i1 %res11383, i1* %ifptr11378
br label %ifcont11378

ifcont11378:
%ifres11384 = load i1, i1* %ifptr11378

store i1 %ifres11384, i1* %ifptr11373
br label %ifcont11373

ifcont11373:
%ifres11385 = load i1, i1* %ifptr11373

br i1 %ifres11385, label %then11372, label %else11372

then11372:
%var11386 = bitcast [16 x i8]* @gsxtmgraphics-pipeline423 to i8*

%val11387 = call i32 (i8*, ...) @printf(i8* %var11386)
ret void

else11372:
%val11389 = load i32, i32* %lightPtr
%val11390 = mul i32 %val11389, 16
%val11391 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11392 = getelementptr %xtm_lights, %xtm_lights* %val11391, i64 0, i32 8
%val11393 = load float*, float** %val11392
; pointer ref
%val11394 = getelementptr float, float* %val11393, i32 %val11390
%val11395 = load i32, i32* %lightPtr
%val11396 = mul i32 %val11395, 4
%val11397 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11398 = getelementptr %xtm_lights, %xtm_lights* %val11397, i64 0, i32 0
%val11399 = load float*, float** %val11398
; pointer ref
%val11400 = getelementptr float, float* %val11399, i32 %val11396
%val11401 = load i32, i32* %lightPtr
%val11402 = mul i32 %val11401, 4
%val11403 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11404 = getelementptr %xtm_lights, %xtm_lights* %val11403, i64 0, i32 1
%val11405 = load float*, float** %val11404
; pointer ref
%val11406 = getelementptr float, float* %val11405, i32 %val11402
%val11407 = load i32, i32* %lightPtr
%val11408 = mul i32 %val11407, 4
%val11409 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11410 = getelementptr %xtm_lights, %xtm_lights* %val11409, i64 0, i32 2
%val11411 = load float*, float** %val11410
; pointer ref
%val11412 = getelementptr float, float* %val11411, i32 %val11408
call fastcc void @fill_view_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ(float* %val11394, float* %val11400, float* %val11406, float* %val11412)
%val11416 = load float*, float** %viewPtr
%val11417 = icmp eq float* %val11416, null
br i1 %val11417, label %then11415, label %else11415

then11415:
%res11418 = call ccc i1 @impc_false()
store i1 %res11418, i1* %ifptr11415
br label %ifcont11415

else11415:
%res11419 = call ccc i1 @impc_true()
store i1 %res11419, i1* %ifptr11415
br label %ifcont11415

ifcont11415:
%ifres11420 = load i1, i1* %ifptr11415

br i1 %ifres11420, label %then11414, label %else11414

then11414:
%val11421 = load i32, i32* %lightPtr
%val11422 = mul i32 %val11421, 16
%val11423 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11424 = getelementptr %xtm_lights, %xtm_lights* %val11423, i64 0, i32 8
%val11425 = load float*, float** %val11424
; pointer ref
%val11426 = getelementptr float, float* %val11425, i32 %val11422
%val11427 = load float*, float** %viewPtr
call fastcc void @mcopy_adhoc_W3ZvaWQsZmxvYXQqLGk2NCxpNjQsZmxvYXQqXQ(float* %val11426, i64 4, i64 4, float* %val11427)
br label %ifcont11414

else11414:
br label %ifcont11414

ifcont11414:
ret void
}
@gsxtmgraphics-pipeline454 = hidden constant [98 x i8] c"xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i32, float*)*}** @xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11464 = load i8*, i8** %_impzPtr
%zone11465 = bitcast i8* %tzone11464 to %mzone*

; let assign value to symbol xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0
%dat_xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone11465, i64 8)
%xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0Ptr = bitcast i8* %dat_xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0 to {i8*, i8*, void (i8*, i8*, i32, float*)*}***
%tzone11366 = load i8*, i8** %_impzPtr
%zone11367 = bitcast i8* %tzone11366 to %mzone*

; let assign value to symbol lights
%dat_lights = call i8* @llvm_zone_malloc(%mzone* %zone11367, i64 8)
%lightsPtr = bitcast i8* %dat_lights to %xtm_lights**
%null11365 = bitcast i8* null to %xtm_lights*

; let value assignment
%lights = select i1 true, %xtm_lights* %null11365, %xtm_lights* %null11365
store %xtm_lights* %lights, %xtm_lights** %lightsPtr

%tzone11461 = load i8*, i8** %_impzPtr
%zone11462 = bitcast i8* %tzone11461 to %mzone*

; let assign value to symbol _anon_lambda_20
%dat__anon_lambda_20 = call i8* @llvm_zone_malloc(%mzone* %zone11462, i64 8)
%_anon_lambda_20Ptr = bitcast i8* %dat__anon_lambda_20 to { i8*, i8*, void (i8*, i8*, i32, float*)*}***
%tzone11432 = load i8*, i8** %_impzPtr
%zone11433 = bitcast i8* %tzone11432 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11433)
; malloc closure structure
%clsptr11434 = call i8* @llvm_zone_malloc(%mzone* %zone11433, i64 24)
%closure11435 = bitcast i8* %clsptr11434 to { i8*, i8*, void (i8*, i8*, i32, float*)*}*

; malloc environment structure
%envptr11436 = call i8* @llvm_zone_malloc(%mzone* %zone11433, i64 24)
%environment11437 = bitcast i8* %envptr11436 to {{i8*, i8*, void (i8*, i8*, i32, float*)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float*)*}***}*

; malloc closure address table
%addytable11438 = call %clsvar* @new_address_table()
%var11439 = bitcast [45 x i8]* @gsxtmgraphics-pipeline451 to i8*
%var11440 = bitcast [44 x i8]* @gsxtmgraphics-pipeline452 to i8*
%addytable11441 = call %clsvar* @add_address_table(%mzone* %zone11433, i8* %var11439, i32 0, i8* %var11440, i32 3, %clsvar* %addytable11438)
%var11442 = bitcast [7 x i8]* @gsxtmgraphics-pipeline419 to i8*
%var11443 = bitcast [13 x i8]* @gsxtmgraphics-pipeline420 to i8*
%addytable11444 = call %clsvar* @add_address_table(%mzone* %zone11433, i8* %var11442, i32 8, i8* %var11443, i32 3, %clsvar* %addytable11441)
%var11445 = bitcast [16 x i8]* @gsxtmgraphics-pipeline453 to i8*
%var11446 = bitcast [44 x i8]* @gsxtmgraphics-pipeline452 to i8*
%addytable11447 = call %clsvar* @add_address_table(%mzone* %zone11433, i8* %var11445, i32 16, i8* %var11446, i32 3, %clsvar* %addytable11444)
%address-table11448 = bitcast %clsvar* %addytable11447 to i8*

; insert table, function and environment into closure struct
%closure.table11455 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float*)*}, { i8*, i8*, void (i8*, i8*, i32, float*)*}* %closure11435, i32 0, i32 0
store i8* %address-table11448, i8** %closure.table11455
%closure.env11456 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float*)*}, { i8*, i8*, void (i8*, i8*, i32, float*)*}* %closure11435, i32 0, i32 1
store i8* %envptr11436, i8** %closure.env11456
%closure.func11457 = getelementptr { i8*, i8*, void (i8*, i8*, i32, float*)*}, { i8*, i8*, void (i8*, i8*, i32, float*)*}* %closure11435, i32 0, i32 2
store void (i8*, i8*, i32, float*)* @xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0__11364, void (i8*, i8*, i32, float*)** %closure.func11457
%closure_size11458 = call i64 @llvm_zone_mark_size(%mzone* %zone11433)
call void @llvm_zone_ptr_set_size(i8* %clsptr11434, i64 %closure_size11458)
%wrapper_ptr11459 = call i8* @llvm_zone_malloc(%mzone* %zone11433, i64 8)
%closure_wrapper11460 = bitcast i8* %wrapper_ptr11459 to { i8*, i8*, void (i8*, i8*, i32, float*)*}**
store { i8*, i8*, void (i8*, i8*, i32, float*)*}* %closure11435, { i8*, i8*, void (i8*, i8*, i32, float*)*}** %closure_wrapper11460

; let value assignment
%_anon_lambda_20 = select i1 true, { i8*, i8*, void (i8*, i8*, i32, float*)*}** %closure_wrapper11460, { i8*, i8*, void (i8*, i8*, i32, float*)*}** %closure_wrapper11460
store { i8*, i8*, void (i8*, i8*, i32, float*)*}** %_anon_lambda_20, { i8*, i8*, void (i8*, i8*, i32, float*)*}*** %_anon_lambda_20Ptr

; add data to environment
; don't need to alloc for env var xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0
%tmp_envptr11450 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float*)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float*)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float*)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float*)*}***}* %environment11437, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i32, float*)*}*** %xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0Ptr, {i8*, i8*, void (i8*, i8*, i32, float*)*}**** %tmp_envptr11450

; don't need to alloc for env var lights
%tmp_envptr11452 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float*)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float*)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float*)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float*)*}***}* %environment11437, i32 0, i32 1
store %xtm_lights** %lightsPtr, %xtm_lights*** %tmp_envptr11452

; don't need to alloc for env var _anon_lambda_20
%tmp_envptr11454 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, float*)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float*)*}***}, {{i8*, i8*, void (i8*, i8*, i32, float*)*}***, %xtm_lights**, {i8*, i8*, void (i8*, i8*, i32, float*)*}***}* %environment11437, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, i32, float*)*}*** %_anon_lambda_20Ptr, {i8*, i8*, void (i8*, i8*, i32, float*)*}**** %tmp_envptr11454


%val11463 = load {i8*, i8*, void (i8*, i8*, i32, float*)*}**, {i8*, i8*, void (i8*, i8*, i32, float*)*}*** %_anon_lambda_20Ptr

; let value assignment
%xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0 = select i1 true, {i8*, i8*, void (i8*, i8*, i32, float*)*}** %val11463, {i8*, i8*, void (i8*, i8*, i32, float*)*}** %val11463
store {i8*, i8*, void (i8*, i8*, i32, float*)*}** %xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0, {i8*, i8*, void (i8*, i8*, i32, float*)*}*** %xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0Ptr

%val11466 = load {i8*, i8*, void (i8*, i8*, i32, float*)*}**, {i8*, i8*, void (i8*, i8*, i32, float*)*}*** %xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, i32, float*)*}** %val11466
}


@xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i32, float*)*}** @xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i32, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0(i32 %arg_0,float* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float*)*}*, {i8*, i8*, void (i8*, i8*, i32, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float*)*}, {i8*, i8*, void (i8*, i8*, i32, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float*)*}, {i8*, i8*, void (i8*, i8*, i32, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float*)*,  void (i8*, i8*, i32, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float* %arg_1)
ret void
}


define dllexport ccc void @xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0_native(i32 %arg_0,float* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float*)*}*, {i8*, i8*, void (i8*, i8*, i32, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float*)*}, {i8*, i8*, void (i8*, i8*, i32, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float*)*}, {i8*, i8*, void (i8*, i8*, i32, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float*)*,  void (i8*, i8*, i32, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float* %arg_1)
ret void
}


define dllexport ccc i8*  @xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11467 = bitcast [98 x i8]* @gsxtmgraphics-pipeline454 to i8*
call i32 (i8*, ...) @printf(i8* %var11467)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var11468 = bitcast [98 x i8]* @gsxtmgraphics-pipeline454 to i8*
call i32 (i8*, ...) @printf(i8* %var11468)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float*)*}*, {i8*, i8*, void (i8*, i8*, i32, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float*)*}, {i8*, i8*, void (i8*, i8*, i32, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float*)*}, {i8*, i8*, void (i8*, i8*, i32, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float*)*,  void (i8*, i8*, i32, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, float*}*
%arg_p_0 = getelementptr {i32, float*}, {i32, float*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, float*}, {i32, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, float*)*}*, {i8*, i8*, void (i8*, i8*, i32, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float*)*}, {i8*, i8*, void (i8*, i8*, i32, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, float*)*}, {i8*, i8*, void (i8*, i8*, i32, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, float*)*,  void (i8*, i8*, i32, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, float* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline455 = hidden constant [53 x i8] c"xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd\00"
define dllexport fastcc void @xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd__11469(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11470 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}*
%xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}* %impenv, i32 0, i32 0
%xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**** %xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr


%tzone11472 = load i8*, i8** %_impzPtr
%zone11473 = bitcast i8* %tzone11472 to %mzone*

; let assign value to symbol lights
%lightsPtr = alloca %xtm_lights*
%res11471 = call fastcc %xtm_lights* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ()

; let value assignment
%lights = select i1 true, %xtm_lights* %res11471, %xtm_lights* %res11471
store %xtm_lights* %lights, %xtm_lights** %lightsPtr

%val11474 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val11475 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11476 = getelementptr %xtm_lights, %xtm_lights* %val11475, i64 0, i32 9
%val11477 = load i32, i32* %val11476
%val11478 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11479 = getelementptr %xtm_lights, %xtm_lights* %val11478, i64 0, i32 0
%val11480 = load float*, float** %val11479
%val11481 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11482 = getelementptr %xtm_lights, %xtm_lights* %val11481, i64 0, i32 1
%val11483 = load float*, float** %val11482
%val11484 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11485 = getelementptr %xtm_lights, %xtm_lights* %val11484, i64 0, i32 7
%val11486 = load float*, float** %val11485
%val11487 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11488 = getelementptr %xtm_lights, %xtm_lights* %val11487, i64 0, i32 6
%val11489 = load float*, float** %val11488
%val11490 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11491 = getelementptr %xtm_lights, %xtm_lights* %val11490, i64 0, i32 3
%val11492 = load float*, float** %val11491
%val11493 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11494 = getelementptr %xtm_lights, %xtm_lights* %val11493, i64 0, i32 4
%val11495 = load float*, float** %val11494
%val11496 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11497 = getelementptr %xtm_lights, %xtm_lights* %val11496, i64 0, i32 5
%val11498 = load float*, float** %val11497
call fastcc void @shader_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(%ShaderProgram* %val11474, i32 %val11477, float* %val11480, float* %val11483, float* %val11486, float* %val11489, float* %val11492, float* %val11495, float* %val11498)
ret void
}
@gsxtmgraphics-pipeline456 = hidden constant [106 x i8] c"xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** @xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11519 = load i8*, i8** %_impzPtr
%zone11520 = bitcast i8* %tzone11519 to %mzone*

; let assign value to symbol xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd
%dat_xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd = call i8* @llvm_zone_malloc(%mzone* %zone11520, i64 8)
%xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr = bitcast i8* %dat_xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd to { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***
%tzone11500 = load i8*, i8** %_impzPtr
%zone11501 = bitcast i8* %tzone11500 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11501)
; malloc closure structure
%clsptr11502 = call i8* @llvm_zone_malloc(%mzone* %zone11501, i64 24)
%closure11503 = bitcast i8* %clsptr11502 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*

; malloc environment structure
%envptr11504 = call i8* @llvm_zone_malloc(%mzone* %zone11501, i64 8)
%environment11505 = bitcast i8* %envptr11504 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}*

; malloc closure address table
%addytable11506 = call %clsvar* @new_address_table()
%var11507 = bitcast [53 x i8]* @gsxtmgraphics-pipeline455 to i8*
%var11508 = bitcast [48 x i8]* @gsxtmgraphics-pipeline327 to i8*
%addytable11509 = call %clsvar* @add_address_table(%mzone* %zone11501, i8* %var11507, i32 0, i8* %var11508, i32 3, %clsvar* %addytable11506)
%address-table11510 = bitcast %clsvar* %addytable11509 to i8*

; insert table, function and environment into closure struct
%closure.table11513 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure11503, i32 0, i32 0
store i8* %address-table11510, i8** %closure.table11513
%closure.env11514 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure11503, i32 0, i32 1
store i8* %envptr11504, i8** %closure.env11514
%closure.func11515 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure11503, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*)* @xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd__11469, void (i8*, i8*, %ShaderProgram*)** %closure.func11515
%closure_size11516 = call i64 @llvm_zone_mark_size(%mzone* %zone11501)
call void @llvm_zone_ptr_set_size(i8* %clsptr11502, i64 %closure_size11516)
%wrapper_ptr11517 = call i8* @llvm_zone_malloc(%mzone* %zone11501, i64 8)
%closure_wrapper11518 = bitcast i8* %wrapper_ptr11517 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure11503, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper11518

; let value assignment
%xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper11518, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper11518
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr

; add data to environment
; don't need to alloc for env var xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd
%tmp_envptr11512 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}* %environment11505, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**** %tmp_envptr11512


%val11521 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %val11521
}


@xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** @xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
ret void
}


define dllexport ccc void @xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_native(%ShaderProgram* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
ret void
}


define dllexport ccc i8*  @xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11522 = bitcast [106 x i8]* @gsxtmgraphics-pipeline456 to i8*
call i32 (i8*, ...) @printf(i8* %var11522)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*}*
%arg_p_0 = getelementptr {%ShaderProgram*}, {%ShaderProgram*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline457 = hidden constant [83 x i8] c"xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd\00"
define dllexport fastcc void @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd__11523(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, float* %model, float* %view, float* %projection) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11524 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}***}*
%xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}**** %xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%modelPtr = alloca float*
store float* %model, float** %modelPtr
%viewPtr = alloca float*
store float* %view, float** %viewPtr
%projectionPtr = alloca float*
store float* %projection, float** %projectionPtr


%tzone11526 = load i8*, i8** %_impzPtr
%zone11527 = bitcast i8* %tzone11526 to %mzone*

; let assign value to symbol lights
%lightsPtr = alloca %xtm_lights*
%res11525 = call fastcc %xtm_lights* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ()

; let value assignment
%lights = select i1 true, %xtm_lights* %res11525, %xtm_lights* %res11525
store %xtm_lights* %lights, %xtm_lights** %lightsPtr

%val11528 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val11529 = load float*, float** %modelPtr
%val11530 = load float*, float** %viewPtr
%val11531 = load float*, float** %projectionPtr
%val11532 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11533 = getelementptr %xtm_lights, %xtm_lights* %val11532, i64 0, i32 9
%val11534 = load i32, i32* %val11533
%val11535 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val11536 = getelementptr %xtm_lights, %xtm_lights* %val11535, i64 0, i32 8
%val11537 = load float*, float** %val11536
call fastcc void @shader_update_matrices_lvs_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTMyLGZsb2F0Kl0(%ShaderProgram* %val11528, float* %val11529, float* %val11530, float* %val11531, i32 %val11534, float* %val11537)
ret void
}
@gsxtmgraphics-pipeline458 = hidden constant [136 x i8] c"xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11558 = load i8*, i8** %_impzPtr
%zone11559 = bitcast i8* %tzone11558 to %mzone*

; let assign value to symbol xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd
%dat_xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd = call i8* @llvm_zone_malloc(%mzone* %zone11559, i64 8)
%xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr = bitcast i8* %dat_xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}***
%tzone11539 = load i8*, i8** %_impzPtr
%zone11540 = bitcast i8* %tzone11539 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11540)
; malloc closure structure
%clsptr11541 = call i8* @llvm_zone_malloc(%mzone* %zone11540, i64 24)
%closure11542 = bitcast i8* %clsptr11541 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}*

; malloc environment structure
%envptr11543 = call i8* @llvm_zone_malloc(%mzone* %zone11540, i64 8)
%environment11544 = bitcast i8* %envptr11543 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}***}*

; malloc closure address table
%addytable11545 = call %clsvar* @new_address_table()
%var11546 = bitcast [83 x i8]* @gsxtmgraphics-pipeline457 to i8*
%var11547 = bitcast [72 x i8]* @gsxtmgraphics-pipeline251 to i8*
%addytable11548 = call %clsvar* @add_address_table(%mzone* %zone11540, i8* %var11546, i32 0, i8* %var11547, i32 3, %clsvar* %addytable11545)
%address-table11549 = bitcast %clsvar* %addytable11548 to i8*

; insert table, function and environment into closure struct
%closure.table11552 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure11542, i32 0, i32 0
store i8* %address-table11549, i8** %closure.table11552
%closure.env11553 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure11542, i32 0, i32 1
store i8* %envptr11543, i8** %closure.env11553
%closure.func11554 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure11542, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, float*, float*, float*)* @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd__11523, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)** %closure.func11554
%closure_size11555 = call i64 @llvm_zone_mark_size(%mzone* %zone11540)
call void @llvm_zone_ptr_set_size(i8* %clsptr11541, i64 %closure_size11555)
%wrapper_ptr11556 = call i8* @llvm_zone_malloc(%mzone* %zone11540, i64 8)
%closure_wrapper11557 = bitcast i8* %wrapper_ptr11556 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure11542, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** %closure_wrapper11557

; let value assignment
%xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** %closure_wrapper11557, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** %closure_wrapper11557
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** %xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}*** %xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr

; add data to environment
; don't need to alloc for env var xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd
%tmp_envptr11551 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}***}* %environment11544, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}*** %xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}**** %tmp_envptr11551


%val11560 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}*** %xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** %val11560
}


@xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd(%ShaderProgram* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
ret void
}


define dllexport ccc void @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_native(%ShaderProgram* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
ret void
}


define dllexport ccc i8*  @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11561 = bitcast [136 x i8]* @gsxtmgraphics-pipeline458 to i8*
call i32 (i8*, ...) @printf(i8* %var11561)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var11562 = bitcast [136 x i8]* @gsxtmgraphics-pipeline458 to i8*
call i32 (i8*, ...) @printf(i8* %var11562)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var11563 = bitcast [136 x i8]* @gsxtmgraphics-pipeline458 to i8*
call i32 (i8*, ...) @printf(i8* %var11563)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var11564 = bitcast [136 x i8]* @gsxtmgraphics-pipeline458 to i8*
call i32 (i8*, ...) @printf(i8* %var11564)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, float*, float*, float*}*
%arg_p_0 = getelementptr {%ShaderProgram*, float*, float*, float*}, {%ShaderProgram*, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, float*, float*, float*}, {%ShaderProgram*, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, float*, float*, float*}, {%ShaderProgram*, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%ShaderProgram*, float*, float*, float*}, {%ShaderProgram*, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline459 = hidden constant [116 x i8] c"xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd\00"
@gsxtmgraphics-pipeline460 = hidden constant [110 x i8] c"{i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}**\00"
define dllexport fastcc void @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd__11565(i8* %_impz,i8* %_impenv, %VAO* %vao, %ShaderProgram* %shader, float* %m, float* %v, float* %p, i32 %type_s_56, i1 %update_data, float %sz, %Texture* %tex, i1 %blend) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11566 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}***}*
%xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}***}* %impenv, i32 0, i32 0
%xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFdPtr = load {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}***, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}**** %xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFdPtr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%mPtr = alloca float*
store float* %m, float** %mPtr
%vPtr = alloca float*
store float* %v, float** %vPtr
%pPtr = alloca float*
store float* %p, float** %pPtr
%type_s_56Ptr = alloca i32
store i32 %type_s_56, i32* %type_s_56Ptr
%update_dataPtr = alloca i1
store i1 %update_data, i1* %update_dataPtr
%szPtr = alloca float
store float %sz, float* %szPtr
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr
%blendPtr = alloca i1
store i1 %blend, i1* %blendPtr


%val11567 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val11568 = load float*, float** %mPtr
%val11569 = load float*, float** %vPtr
%val11570 = load float*, float** %pPtr
call fastcc void @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd(%ShaderProgram* %val11567, float* %val11568, float* %val11569, float* %val11570)
%tzone11574 = load i8*, i8** %_impzPtr
%zone11575 = bitcast i8* %tzone11574 to %mzone*

; let assign value to symbol vbo
%vboPtr = alloca %VBO*
%tzone11579 = load i8*, i8** %_impzPtr
%zone11580 = bitcast i8* %tzone11579 to %mzone*

; let assign value to symbol elmts
%elmtsPtr = alloca i32
%val11572 = load %VAO*, %VAO** %vaoPtr
%res11573 = call fastcc %VBO* @get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd(%VAO* %val11572, i64 0)

; let value assignment
%vbo = select i1 true, %VBO* %res11573, %VBO* %res11573
store %VBO* %vbo, %VBO** %vboPtr

%val11576 = load %VBO*, %VBO** %vboPtr
%res11577 = call fastcc i64 @elements_adhoc_W2k2NCxWQk8qXQ(%VBO* %val11576)
%res11578 = call ccc i32 @i64toi32(i64 %res11577)

; let value assignment
%elmts = select i1 true, i32 %res11578, i32 %res11578
store i32 %elmts, i32* %elmtsPtr

; promote local stack var allocations
%tzone11639 = load i8*, i8** %_impzPtr
%zone11640 = bitcast i8* %tzone11639 to %mzone*
%ifptr11625 = alloca i1
%ifptr11612 = alloca i1
%ifptr11599 = alloca i32
%ifptr11600 = alloca i1
%val11582 = load i1, i1* %update_dataPtr
br i1 %val11582, label %then11581, label %else11581

then11581:
%val11583 = load %VBO*, %VBO** %vboPtr
call fastcc void @update_adhoc_W3ZvaWQsVkJPKl0(%VBO* %val11583)
br label %ifcont11581

else11581:
br label %ifcont11581

ifcont11581:
%val11586 = load i32, i32* %type_s_56Ptr
%val11587 = load i32, i32* @GL_POINTS
%cmp11588 = icmp eq i32 %val11586, %val11587
br i1 %cmp11588, label %then11585, label %else11585

then11585:
%val11589 = load float, float* %szPtr
call fastcc void @glPointSize_adhoc_W3ZvaWQsZmxvYXRd(float %val11589)
br label %ifcont11585

else11585:
call fastcc void @glLineWidth_adhoc_W3ZvaWQsZmxvYXRd(float 0x3ff0000000000000)
br label %ifcont11585

ifcont11585:
%val11593 = load i1, i1* %blendPtr
br i1 %val11593, label %then11592, label %else11592

then11592:
%val11594 = load i32, i32* @GL_BLEND
call fastcc void @glEnable_adhoc_W3ZvaWQsaTMyXQ(i32 %val11594)
%val11596 = load i32, i32* @GL_SRC_ALPHA
%val11597 = load i32, i32* @GL_ONE_MINUS_SRC_ALPHA
call fastcc void @glBlendFunc_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val11596, i32 %val11597)
br label %ifcont11592

else11592:
br label %ifcont11592

ifcont11592:
%val11601 = load %Texture*, %Texture** %texPtr
%val11602 = icmp eq %Texture* %val11601, null
br i1 %val11602, label %then11600, label %else11600

then11600:
%res11603 = call ccc i1 @impc_false()
store i1 %res11603, i1* %ifptr11600
br label %ifcont11600

else11600:
%res11604 = call ccc i1 @impc_true()
store i1 %res11604, i1* %ifptr11600
br label %ifcont11600

ifcont11600:
%ifres11605 = load i1, i1* %ifptr11600

br i1 %ifres11605, label %then11599, label %else11599

then11599:
%val11606 = load %Texture*, %Texture** %texPtr
%val11607 = trunc i64 1 to i32
%res11608 = call fastcc i32 @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd(%Texture* %val11606, i32 %val11607)
store i32 %res11608, i32* %ifptr11599
br label %ifcont11599

else11599:
br label %ifcont11599

ifcont11599:
%ifres11609 = load i32, i32* %ifptr11599

%val11610 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val11611 = load %Texture*, %Texture** %texPtr
%val11613 = load i32, i32* %type_s_56Ptr
%val11614 = load i32, i32* @GL_POINTS
%cmp11615 = icmp eq i32 %val11613, %val11614
br i1 %cmp11615, label %then11612, label %else11612

then11612:
%res11616 = call ccc i1 @impc_true()
store i1 %res11616, i1* %ifptr11612
br label %ifcont11612

else11612:
%res11617 = call ccc i1 @impc_false()
store i1 %res11617, i1* %ifptr11612
br label %ifcont11612

ifcont11612:
%ifres11618 = load i1, i1* %ifptr11612

call fastcc void @shader_prepare_draw_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTMyLGkxXQ(%ShaderProgram* %val11610, %Texture* %val11611, i32 0, i1 %ifres11618)
%val11620 = load %VAO*, %VAO** %vaoPtr
%val11621 = load i32, i32* %type_s_56Ptr
%val11622 = load i32, i32* %elmtsPtr
call fastcc void @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd(%VAO* %val11620, i32 %val11621, i32 0, i32 %val11622, i32 0)
%val11626 = load %Texture*, %Texture** %texPtr
%val11627 = icmp eq %Texture* %val11626, null
br i1 %val11627, label %then11625, label %else11625

then11625:
%res11628 = call ccc i1 @impc_false()
store i1 %res11628, i1* %ifptr11625
br label %ifcont11625

else11625:
%res11629 = call ccc i1 @impc_true()
store i1 %res11629, i1* %ifptr11625
br label %ifcont11625

ifcont11625:
%ifres11630 = load i1, i1* %ifptr11625

br i1 %ifres11630, label %then11624, label %else11624

then11624:
%val11631 = load %Texture*, %Texture** %texPtr
%val11632 = trunc i64 1 to i32
call fastcc void @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ(%Texture* %val11631, i32 %val11632)
br label %ifcont11624

else11624:
br label %ifcont11624

ifcont11624:
%val11635 = load i1, i1* %blendPtr
br i1 %val11635, label %then11634, label %else11634

then11634:
%val11636 = load i32, i32* @GL_BLEND
call fastcc void @glDisable_adhoc_W3ZvaWQsaTMyXQ(i32 %val11636)
br label %ifcont11634

else11634:
br label %ifcont11634

ifcont11634:
ret void
}
@gsxtmgraphics-pipeline461 = hidden constant [169 x i8] c"xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}** @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11660 = load i8*, i8** %_impzPtr
%zone11661 = bitcast i8* %tzone11660 to %mzone*

; let assign value to symbol xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd
%dat_xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd = call i8* @llvm_zone_malloc(%mzone* %zone11661, i64 8)
%xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFdPtr = bitcast i8* %dat_xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd to { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}***
%tzone11641 = load i8*, i8** %_impzPtr
%zone11642 = bitcast i8* %tzone11641 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11642)
; malloc closure structure
%clsptr11643 = call i8* @llvm_zone_malloc(%mzone* %zone11642, i64 24)
%closure11644 = bitcast i8* %clsptr11643 to { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}*

; malloc environment structure
%envptr11645 = call i8* @llvm_zone_malloc(%mzone* %zone11642, i64 8)
%environment11646 = bitcast i8* %envptr11645 to {{i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}***}*

; malloc closure address table
%addytable11647 = call %clsvar* @new_address_table()
%var11648 = bitcast [116 x i8]* @gsxtmgraphics-pipeline459 to i8*
%var11649 = bitcast [110 x i8]* @gsxtmgraphics-pipeline460 to i8*
%addytable11650 = call %clsvar* @add_address_table(%mzone* %zone11642, i8* %var11648, i32 0, i8* %var11649, i32 3, %clsvar* %addytable11647)
%address-table11651 = bitcast %clsvar* %addytable11650 to i8*

; insert table, function and environment into closure struct
%closure.table11654 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}* %closure11644, i32 0, i32 0
store i8* %address-table11651, i8** %closure.table11654
%closure.env11655 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}* %closure11644, i32 0, i32 1
store i8* %envptr11645, i8** %closure.env11655
%closure.func11656 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}* %closure11644, i32 0, i32 2
store void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)* @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd__11565, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)** %closure.func11656
%closure_size11657 = call i64 @llvm_zone_mark_size(%mzone* %zone11642)
call void @llvm_zone_ptr_set_size(i8* %clsptr11643, i64 %closure_size11657)
%wrapper_ptr11658 = call i8* @llvm_zone_malloc(%mzone* %zone11642, i64 8)
%closure_wrapper11659 = bitcast i8* %wrapper_ptr11658 to { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}**
store { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}* %closure11644, { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}** %closure_wrapper11659

; let value assignment
%xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd = select i1 true, { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}** %closure_wrapper11659, { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}** %closure_wrapper11659
store { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}** %xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd, { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}*** %xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFdPtr

; add data to environment
; don't need to alloc for env var xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd
%tmp_envptr11653 = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}***}* %environment11646, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}*** %xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFdPtr, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}**** %tmp_envptr11653


%val11662 = load {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}**, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}*** %xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFdPtr
ret {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}** %val11662
}


@xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}** @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd(%VAO* %arg_0,%ShaderProgram* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,i32 %arg_5,i1 %arg_6,float %arg_7,%Texture* %arg_8,i1 %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*,  void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %ShaderProgram* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, i32 %arg_5, i1 %arg_6, float %arg_7, %Texture* %arg_8, i1 %arg_9)
ret void
}


define dllexport ccc void @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd_native(%VAO* %arg_0,%ShaderProgram* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,i32 %arg_5,i1 %arg_6,float %arg_7,%Texture* %arg_8,i1 %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*,  void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %ShaderProgram* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, i32 %arg_5, i1 %arg_6, float %arg_7, %Texture* %arg_8, i1 %arg_9)
ret void
}


define dllexport ccc i8*  @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11663 = bitcast [169 x i8]* @gsxtmgraphics-pipeline461 to i8*
call i32 (i8*, ...) @printf(i8* %var11663)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var11664 = bitcast [169 x i8]* @gsxtmgraphics-pipeline461 to i8*
call i32 (i8*, ...) @printf(i8* %var11664)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %ShaderProgram*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var11665 = bitcast [169 x i8]* @gsxtmgraphics-pipeline461 to i8*
call i32 (i8*, ...) @printf(i8* %var11665)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var11666 = bitcast [169 x i8]* @gsxtmgraphics-pipeline461 to i8*
call i32 (i8*, ...) @printf(i8* %var11666)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var11667 = bitcast [169 x i8]* @gsxtmgraphics-pipeline461 to i8*
call i32 (i8*, ...) @printf(i8* %var11667)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var11668 = bitcast [169 x i8]* @gsxtmgraphics-pipeline461 to i8*
call i32 (i8*, ...) @printf(i8* %var11668)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_integer(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var11669 = bitcast [169 x i8]* @gsxtmgraphics-pipeline461 to i8*
call i32 (i8*, ...) @printf(i8* %var11669)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%arg_6 = call ccc i1  @i1value(i8* %arg_6_val)
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_real(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var11670 = bitcast [169 x i8]* @gsxtmgraphics-pipeline461 to i8*
call i32 (i8*, ...) @printf(i8* %var11670)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%arg_7 = call ccc float  @r32value(i8* %arg_7_val)
%arg_8_val = call ccc i8* @list_ref(i8* %_sc, i32 8,i8* %args)
%arg_8_rt_check = call i32 @is_cptr(i8* %arg_8_val)
%arg_8_bool = icmp ne i32 %arg_8_rt_check, 0
br i1 %arg_8_bool, label %arg_8_true, label %arg_8_false

arg_8_true:
br label %arg_8_continue

arg_8_false:
%var11671 = bitcast [169 x i8]* @gsxtmgraphics-pipeline461 to i8*
call i32 (i8*, ...) @printf(i8* %var11671)
%arg_8_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_8_errret

arg_8_continue:
%ttv_8 = call ccc i8* @cptr_value(i8* %arg_8_val)
%arg_8 = bitcast i8* %ttv_8 to %Texture*
%arg_9_val = call ccc i8* @list_ref(i8* %_sc, i32 9,i8* %args)
%arg_9_rt_check = call i32 @is_integer(i8* %arg_9_val)
%arg_9_bool = icmp ne i32 %arg_9_rt_check, 0
br i1 %arg_9_bool, label %arg_9_true, label %arg_9_false

arg_9_true:
br label %arg_9_continue

arg_9_false:
%var11672 = bitcast [169 x i8]* @gsxtmgraphics-pipeline461 to i8*
call i32 (i8*, ...) @printf(i8* %var11672)
%arg_9_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_9_errret

arg_9_continue:
%arg_9 = call ccc i1  @i1value(i8* %arg_9_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*,  void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %ShaderProgram* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, i32 %arg_5, i1 %arg_6, float %arg_7, %Texture* %arg_8, i1 %arg_9)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1}*
%arg_p_0 = getelementptr {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1}, {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
%arg_p_1 = getelementptr {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1}, {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1}* %fstruct, i32 0, i32 1
%arg_1 = load %ShaderProgram*, %ShaderProgram** %arg_p_1
%arg_p_2 = getelementptr {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1}, {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1}, {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1}, {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1}, {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
%arg_p_6 = getelementptr {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1}, {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1}* %fstruct, i32 0, i32 6
%arg_6 = load i1, i1* %arg_p_6
%arg_p_7 = getelementptr {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1}, {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1}* %fstruct, i32 0, i32 7
%arg_7 = load float, float* %arg_p_7
%arg_p_8 = getelementptr {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1}, {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1}* %fstruct, i32 0, i32 8
%arg_8 = load %Texture*, %Texture** %arg_p_8
%arg_p_9 = getelementptr {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1}, {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1}* %fstruct, i32 0, i32 9
%arg_9 = load i1, i1* %arg_p_9
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)*,  void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1, float, %Texture*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %ShaderProgram* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, i32 %arg_5, i1 %arg_6, float %arg_7, %Texture* %arg_8, i1 %arg_9)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline462 = hidden constant [92 x i8] c"xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd\00"
@gsxtmgraphics-pipeline463 = hidden constant [88 x i8] c"{i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}**\00"
define dllexport fastcc void @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd__11673(i8* %_impz,i8* %_impenv, %VAO* %vao, %ShaderProgram* %shader, float* %m, float* %v, float* %p, i32 %type_s_57, i1 %update_s_58) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11674 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}***}*
%xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}***}* %impenv, i32 0, i32 0
%xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFdPtr = load {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}***, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}**** %xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFdPtr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%mPtr = alloca float*
store float* %m, float** %mPtr
%vPtr = alloca float*
store float* %v, float** %vPtr
%pPtr = alloca float*
store float* %p, float** %pPtr
%type_s_57Ptr = alloca i32
store i32 %type_s_57, i32* %type_s_57Ptr
%update_s_58Ptr = alloca i1
store i1 %update_s_58, i1* %update_s_58Ptr


%val11675 = load %VAO*, %VAO** %vaoPtr
%val11676 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val11677 = load float*, float** %mPtr
%val11678 = load float*, float** %vPtr
%val11679 = load float*, float** %pPtr
%val11680 = load i32, i32* %type_s_57Ptr
%val11681 = load i1, i1* %update_s_58Ptr
%null11682 = bitcast i8* null to %Texture*
call fastcc void @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTEsZmxvYXQsVGV4dHVyZSosaTFd(%VAO* %val11675, %ShaderProgram* %val11676, float* %val11677, float* %val11678, float* %val11679, i32 %val11680, i1 %val11681, float 0x3ff0000000000000, %Texture* %null11682, i1 0)
ret void
}
@gsxtmgraphics-pipeline464 = hidden constant [145 x i8] c"xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}** @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11703 = load i8*, i8** %_impzPtr
%zone11704 = bitcast i8* %tzone11703 to %mzone*

; let assign value to symbol xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd
%dat_xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd = call i8* @llvm_zone_malloc(%mzone* %zone11704, i64 8)
%xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFdPtr = bitcast i8* %dat_xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd to { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}***
%tzone11684 = load i8*, i8** %_impzPtr
%zone11685 = bitcast i8* %tzone11684 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11685)
; malloc closure structure
%clsptr11686 = call i8* @llvm_zone_malloc(%mzone* %zone11685, i64 24)
%closure11687 = bitcast i8* %clsptr11686 to { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}*

; malloc environment structure
%envptr11688 = call i8* @llvm_zone_malloc(%mzone* %zone11685, i64 8)
%environment11689 = bitcast i8* %envptr11688 to {{i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}***}*

; malloc closure address table
%addytable11690 = call %clsvar* @new_address_table()
%var11691 = bitcast [92 x i8]* @gsxtmgraphics-pipeline462 to i8*
%var11692 = bitcast [88 x i8]* @gsxtmgraphics-pipeline463 to i8*
%addytable11693 = call %clsvar* @add_address_table(%mzone* %zone11685, i8* %var11691, i32 0, i8* %var11692, i32 3, %clsvar* %addytable11690)
%address-table11694 = bitcast %clsvar* %addytable11693 to i8*

; insert table, function and environment into closure struct
%closure.table11697 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}* %closure11687, i32 0, i32 0
store i8* %address-table11694, i8** %closure.table11697
%closure.env11698 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}* %closure11687, i32 0, i32 1
store i8* %envptr11688, i8** %closure.env11698
%closure.func11699 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}* %closure11687, i32 0, i32 2
store void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)* @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd__11673, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)** %closure.func11699
%closure_size11700 = call i64 @llvm_zone_mark_size(%mzone* %zone11685)
call void @llvm_zone_ptr_set_size(i8* %clsptr11686, i64 %closure_size11700)
%wrapper_ptr11701 = call i8* @llvm_zone_malloc(%mzone* %zone11685, i64 8)
%closure_wrapper11702 = bitcast i8* %wrapper_ptr11701 to { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}**
store { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}* %closure11687, { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}** %closure_wrapper11702

; let value assignment
%xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd = select i1 true, { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}** %closure_wrapper11702, { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}** %closure_wrapper11702
store { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}** %xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd, { i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}*** %xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFdPtr

; add data to environment
; don't need to alloc for env var xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd
%tmp_envptr11696 = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}***}* %environment11689, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}*** %xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFdPtr, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}**** %tmp_envptr11696


%val11705 = load {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}**, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}*** %xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFdPtr
ret {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}** %val11705
}


@xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}** @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd(%VAO* %arg_0,%ShaderProgram* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,i32 %arg_5,i1 %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*,  void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %ShaderProgram* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, i32 %arg_5, i1 %arg_6)
ret void
}


define dllexport ccc void @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd_native(%VAO* %arg_0,%ShaderProgram* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,i32 %arg_5,i1 %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*,  void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %ShaderProgram* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, i32 %arg_5, i1 %arg_6)
ret void
}


define dllexport ccc i8*  @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11706 = bitcast [145 x i8]* @gsxtmgraphics-pipeline464 to i8*
call i32 (i8*, ...) @printf(i8* %var11706)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var11707 = bitcast [145 x i8]* @gsxtmgraphics-pipeline464 to i8*
call i32 (i8*, ...) @printf(i8* %var11707)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %ShaderProgram*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var11708 = bitcast [145 x i8]* @gsxtmgraphics-pipeline464 to i8*
call i32 (i8*, ...) @printf(i8* %var11708)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var11709 = bitcast [145 x i8]* @gsxtmgraphics-pipeline464 to i8*
call i32 (i8*, ...) @printf(i8* %var11709)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var11710 = bitcast [145 x i8]* @gsxtmgraphics-pipeline464 to i8*
call i32 (i8*, ...) @printf(i8* %var11710)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var11711 = bitcast [145 x i8]* @gsxtmgraphics-pipeline464 to i8*
call i32 (i8*, ...) @printf(i8* %var11711)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_integer(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var11712 = bitcast [145 x i8]* @gsxtmgraphics-pipeline464 to i8*
call i32 (i8*, ...) @printf(i8* %var11712)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%arg_6 = call ccc i1  @i1value(i8* %arg_6_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*,  void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %ShaderProgram* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, i32 %arg_5, i1 %arg_6)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1}*
%arg_p_0 = getelementptr {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1}, {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
%arg_p_1 = getelementptr {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1}, {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1}* %fstruct, i32 0, i32 1
%arg_1 = load %ShaderProgram*, %ShaderProgram** %arg_p_1
%arg_p_2 = getelementptr {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1}, {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1}, {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1}, {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1}, {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
%arg_p_6 = getelementptr {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1}, {%VAO*, %ShaderProgram*, float*, float*, float*, i32, i1}* %fstruct, i32 0, i32 6
%arg_6 = load i1, i1* %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_vao_adhoc_W3ZvaWQsVkFPKixTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpMzIsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)*,  void (i8*, i8*, %VAO*, %ShaderProgram*, float*, float*, float*, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %ShaderProgram* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, i32 %arg_5, i1 %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline465 = hidden constant [30 x i8] c"Error BEFORE drawing XTMMesh!\00"
@gsxtmgraphics-pipeline466 = hidden constant [41 x i8] c"Error setting uniforms! in xtm_draw_mesh\00"
@gsxtmgraphics-pipeline467 = hidden constant [47 x i8] c"Error setting instance attrib in xtm_draw_mesh\00"
@gsxtmgraphics-pipeline468 = hidden constant [23 x i8] c"Error drawing XTMMesh!\00"
@gsxtmgraphics-pipeline469 = hidden constant [73 x i8] c"xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd\00"
@gsxtmgraphics-pipeline470 = hidden constant [71 x i8] c"{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}**\00"
@gsxtmgraphics-pipeline471 = hidden constant [6 x i8] c"color\00"
@gsxtmgraphics-pipeline472 = hidden constant [4 x i8] c"uvw\00"
@gsxtmgraphics-pipeline473 = hidden constant [5 x i8] c"norm\00"
@gsxtmgraphics-pipeline474 = hidden constant [13 x i8] c"instancesvbo\00"
@gsxtmgraphics-pipeline475 = hidden constant [6 x i8] c"%VBO*\00"
@gsxtmgraphics-pipeline476 = hidden constant [5 x i8] c"vert\00"
@gsxtmgraphics-pipeline477 = hidden constant [16 x i8] c"_anon_lambda_21\00"
define dllexport fastcc void @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd__11713(i8* %_impz,i8* %_impenv, %XTMMesh* %mesh, %ShaderProgram* %shader, i32 %instances, %VBO* %vbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11725 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}*
%xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}* %impenv, i32 0, i32 0
%xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypdPtr = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}**** %xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypdPtr_
%colorPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}* %impenv, i32 0, i32 1
%colorPtr = load i32*, i32** %colorPtr_
%uvwPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}* %impenv, i32 0, i32 2
%uvwPtr = load i32*, i32** %uvwPtr_
%normPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}* %impenv, i32 0, i32 3
%normPtr = load i32*, i32** %normPtr_
%instancesvboPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}* %impenv, i32 0, i32 4
%instancesvboPtr = load %VBO**, %VBO*** %instancesvboPtr_
%vertPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}* %impenv, i32 0, i32 5
%vertPtr = load i32*, i32** %vertPtr_
%_anon_lambda_21Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}* %impenv, i32 0, i32 6
%_anon_lambda_21Ptr = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}**** %_anon_lambda_21Ptr_

; setup arguments
%meshPtr = alloca %XTMMesh*
store %XTMMesh* %mesh, %XTMMesh** %meshPtr
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%instancesPtr = alloca i32
store i32 %instances, i32* %instancesPtr
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr


%var11726 = bitcast [30 x i8]* @gsxtmgraphics-pipeline465 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var11726)
%tzone11731 = load i8*, i8** %_impzPtr
%zone11732 = bitcast i8* %tzone11731 to %mzone*

; let assign value to symbol vao
%vaoPtr = alloca %VAO*
%tzone11736 = load i8*, i8** %_impzPtr
%zone11737 = bitcast i8* %tzone11736 to %mzone*

; let assign value to symbol texture
%texturePtr = alloca %Texture*
%tzone11741 = load i8*, i8** %_impzPtr
%zone11742 = bitcast i8* %tzone11741 to %mzone*

; let assign value to symbol diffuse
%diffusePtr = alloca float*
%tzone11746 = load i8*, i8** %_impzPtr
%zone11747 = bitcast i8* %tzone11746 to %mzone*

; let assign value to symbol ambient
%ambientPtr = alloca float*
%tzone11751 = load i8*, i8** %_impzPtr
%zone11752 = bitcast i8* %tzone11751 to %mzone*

; let assign value to symbol specular
%specularPtr = alloca float*
%tzone11756 = load i8*, i8** %_impzPtr
%zone11757 = bitcast i8* %tzone11756 to %mzone*

; let assign value to symbol emissive
%emissivePtr = alloca float*
%tzone11761 = load i8*, i8** %_impzPtr
%zone11762 = bitcast i8* %tzone11761 to %mzone*

; let assign value to symbol shininess
%shininessPtr = alloca float
%tzone11766 = load i8*, i8** %_impzPtr
%zone11767 = bitcast i8* %tzone11766 to %mzone*

; let assign value to symbol facemode
%facemodePtr = alloca i32
%val11728 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val11729 = getelementptr %XTMMesh, %XTMMesh* %val11728, i64 0, i32 10
%val11730 = load %VAO*, %VAO** %val11729

; let value assignment
%vao = select i1 true, %VAO* %val11730, %VAO* %val11730
store %VAO* %vao, %VAO** %vaoPtr

%val11733 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val11734 = getelementptr %XTMMesh, %XTMMesh* %val11733, i64 0, i32 1
%val11735 = load %Texture*, %Texture** %val11734

; let value assignment
%texture = select i1 true, %Texture* %val11735, %Texture* %val11735
store %Texture* %texture, %Texture** %texturePtr

%val11738 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val11739 = getelementptr %XTMMesh, %XTMMesh* %val11738, i64 0, i32 2
%val11740 = load float*, float** %val11739

; let value assignment
%diffuse = select i1 true, float* %val11740, float* %val11740
store float* %diffuse, float** %diffusePtr

%val11743 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val11744 = getelementptr %XTMMesh, %XTMMesh* %val11743, i64 0, i32 3
%val11745 = load float*, float** %val11744

; let value assignment
%ambient = select i1 true, float* %val11745, float* %val11745
store float* %ambient, float** %ambientPtr

%val11748 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val11749 = getelementptr %XTMMesh, %XTMMesh* %val11748, i64 0, i32 4
%val11750 = load float*, float** %val11749

; let value assignment
%specular = select i1 true, float* %val11750, float* %val11750
store float* %specular, float** %specularPtr

%val11753 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val11754 = getelementptr %XTMMesh, %XTMMesh* %val11753, i64 0, i32 5
%val11755 = load float*, float** %val11754

; let value assignment
%emissive = select i1 true, float* %val11755, float* %val11755
store float* %emissive, float** %emissivePtr

%val11758 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val11759 = getelementptr %XTMMesh, %XTMMesh* %val11758, i64 0, i32 6
%val11760 = load float, float* %val11759

; let value assignment
%shininess = select i1 true, float %val11760, float %val11760
store float %shininess, float* %shininessPtr

%val11763 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val11764 = getelementptr %XTMMesh, %XTMMesh* %val11763, i64 0, i32 8
%val11765 = load i32, i32* %val11764

; let value assignment
%facemode = select i1 true, i32 %val11765, i32 %val11765
store i32 %facemode, i32* %facemodePtr

; promote local stack var allocations
%tzone11936 = load i8*, i8** %_impzPtr
%zone11937 = bitcast i8* %tzone11936 to %mzone*
%ifptr11877 = alloca i1
%ifptr11880 = alloca i1
%ifptr11808 = alloca i1
%ifptr11795 = alloca i1
%ifptr11782 = alloca i1
%ifptr11769 = alloca i1
%val11770 = load float*, float** %ambientPtr
%val11771 = icmp eq float* %val11770, null
br i1 %val11771, label %then11769, label %else11769

then11769:
%res11772 = call ccc i1 @impc_false()
store i1 %res11772, i1* %ifptr11769
br label %ifcont11769

else11769:
%res11773 = call ccc i1 @impc_true()
store i1 %res11773, i1* %ifptr11769
br label %ifcont11769

ifcont11769:
%ifres11774 = load i1, i1* %ifptr11769

br i1 %ifres11774, label %then11768, label %else11768

then11768:
%val11775 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res11776 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val11775)
%var11777 = bitcast [16 x i8]* @gsxtmgraphics-pipeline271 to i8*
%res11778 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res11776, i8* %var11777)
%val11779 = load float*, float** %ambientPtr
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res11778, i32 1, float* %val11779)
br label %ifcont11768

else11768:
br label %ifcont11768

ifcont11768:
%val11783 = load float*, float** %diffusePtr
%val11784 = icmp eq float* %val11783, null
br i1 %val11784, label %then11782, label %else11782

then11782:
%res11785 = call ccc i1 @impc_false()
store i1 %res11785, i1* %ifptr11782
br label %ifcont11782

else11782:
%res11786 = call ccc i1 @impc_true()
store i1 %res11786, i1* %ifptr11782
br label %ifcont11782

ifcont11782:
%ifres11787 = load i1, i1* %ifptr11782

br i1 %ifres11787, label %then11781, label %else11781

then11781:
%val11788 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res11789 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val11788)
%var11790 = bitcast [16 x i8]* @gsxtmgraphics-pipeline272 to i8*
%res11791 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res11789, i8* %var11790)
%val11792 = load float*, float** %diffusePtr
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res11791, i32 1, float* %val11792)
br label %ifcont11781

else11781:
br label %ifcont11781

ifcont11781:
%val11796 = load float*, float** %specularPtr
%val11797 = icmp eq float* %val11796, null
br i1 %val11797, label %then11795, label %else11795

then11795:
%res11798 = call ccc i1 @impc_false()
store i1 %res11798, i1* %ifptr11795
br label %ifcont11795

else11795:
%res11799 = call ccc i1 @impc_true()
store i1 %res11799, i1* %ifptr11795
br label %ifcont11795

ifcont11795:
%ifres11800 = load i1, i1* %ifptr11795

br i1 %ifres11800, label %then11794, label %else11794

then11794:
%val11801 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res11802 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val11801)
%var11803 = bitcast [17 x i8]* @gsxtmgraphics-pipeline273 to i8*
%res11804 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res11802, i8* %var11803)
%val11805 = load float*, float** %specularPtr
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res11804, i32 1, float* %val11805)
br label %ifcont11794

else11794:
br label %ifcont11794

ifcont11794:
%val11809 = load float*, float** %specularPtr
%val11810 = icmp eq float* %val11809, null
br i1 %val11810, label %then11808, label %else11808

then11808:
%res11811 = call ccc i1 @impc_false()
store i1 %res11811, i1* %ifptr11808
br label %ifcont11808

else11808:
%res11812 = call ccc i1 @impc_true()
store i1 %res11812, i1* %ifptr11808
br label %ifcont11808

ifcont11808:
%ifres11813 = load i1, i1* %ifptr11808

br i1 %ifres11813, label %then11807, label %else11807

then11807:
%val11814 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res11815 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val11814)
%var11816 = bitcast [17 x i8]* @gsxtmgraphics-pipeline274 to i8*
%res11817 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res11815, i8* %var11816)
%val11818 = load float*, float** %emissivePtr
call fastcc void @glUniform4fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res11817, i32 1, float* %val11818)
br label %ifcont11807

else11807:
br label %ifcont11807

ifcont11807:
%val11820 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res11821 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val11820)
%var11822 = bitcast [18 x i8]* @gsxtmgraphics-pipeline275 to i8*
%res11823 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res11821, i8* %var11822)
%val11824 = load float, float* %shininessPtr
call fastcc void @glUniform1f_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %res11823, float %val11824)
%val11826 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res11827 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val11826)
%var11828 = bitcast [10 x i8]* @gsxtmgraphics-pipeline313 to i8*
%res11829 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res11827, i8* %var11828)
%val11830 = load i32, i32* %instancesPtr
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res11829, i32 %val11830)
%val11832 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res11833 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val11832)
%var11834 = bitcast [12 x i8]* @gsxtmgraphics-pipeline276 to i8*
%res11835 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res11833, i8* %var11834)
%val11836 = load i32, i32* @XTM_EMIT_VCOLOUR
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res11835, i32 %val11836)
%val11838 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res11839 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val11838)
%var11840 = bitcast [9 x i8]* @gsxtmgraphics-pipeline311 to i8*
%res11841 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res11839, i8* %var11840)
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res11841, i32 0)
%val11844 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val11845 = getelementptr %XTMMesh, %XTMMesh* %val11844, i64 0, i32 14
%val11846 = load i32, i32* %val11845
%cmp11847 = icmp sgt i32 %val11846, 0
br i1 %cmp11847, label %then11843, label %else11843

then11843:
%val11848 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val11849 = load %XTMMesh*, %XTMMesh** %meshPtr
call fastcc void @shader_update_bones_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosWFRNTWVzaCpd(%ShaderProgram* %val11848, %XTMMesh* %val11849)
br label %ifcont11843

else11843:
br label %ifcont11843

ifcont11843:
%val11852 = load %Texture*, %Texture** %texturePtr
%res11853 = call fastcc i32 @id_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val11852)
%cmp11854 = icmp sgt i32 %res11853, 0
br i1 %cmp11854, label %then11851, label %else11851

then11851:
%val11855 = load %Texture*, %Texture** %texturePtr
%res11856 = call fastcc i32 @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd(%Texture* %val11855, i32 1)
%val11857 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res11858 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val11857)
%var11859 = bitcast [11 x i8]* @gsxtmgraphics-pipeline312 to i8*
%res11860 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res11858, i8* %var11859)
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res11860, i32 1)
%val11862 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res11863 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val11862)
%var11864 = bitcast [15 x i8]* @gsxtmgraphics-pipeline209 to i8*
%res11865 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res11863, i8* %var11864)
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res11865, i32 1)
br label %ifcont11851

else11851:
%val11867 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res11868 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val11867)
%var11869 = bitcast [11 x i8]* @gsxtmgraphics-pipeline312 to i8*
%res11870 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res11868, i8* %var11869)
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res11870, i32 0)
br label %ifcont11851

ifcont11851:
%var11872 = bitcast [41 x i8]* @gsxtmgraphics-pipeline466 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var11872)
; do set!
%val11874 = load %VAO*, %VAO** %vaoPtr
%res11875 = call fastcc %VBO* @get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd(%VAO* %val11874, i64 4)
store %VBO* %res11875, %VBO** %instancesvboPtr
%val11878 = load i32, i32* %instancesPtr
%cmp11879 = icmp sgt i32 %val11878, 0
br i1 %cmp11879, label %then11877, label %else11877

then11877:
%val11881 = load %VBO*, %VBO** %instancesvboPtr
%val11882 = bitcast %VBO* %val11881 to i8*
%res11883 = call ccc i64 @ptrtoi64(i8* %val11882)
%val11884 = load %VBO*, %VBO** %vboPtr
%val11885 = bitcast %VBO* %val11884 to i8*
%res11886 = call ccc i64 @ptrtoi64(i8* %val11885)
%cmp11887 = icmp ne i64 %res11883, %res11886
br i1 %cmp11887, label %then11880, label %else11880

then11880:
%val11888 = load %VBO*, %VBO** %instancesvboPtr
%val11889 = bitcast %VBO* %val11888 to i8*
%res11890 = call ccc i64 @ptrtoi64(i8* %val11889)
%val11891 = load %VBO*, %VBO** %vboPtr
%val11892 = bitcast %VBO* %val11891 to i8*
%res11893 = call ccc i64 @ptrtoi64(i8* %val11892)
%cmp11894 = icmp ne i64 %res11890, %res11893
store i1 %cmp11894, i1* %ifptr11880
br label %ifcont11880

else11880:
%res11895 = call ccc i1 @impc_false()
store i1 %res11895, i1* %ifptr11880
br label %ifcont11880

ifcont11880:
%ifres11896 = load i1, i1* %ifptr11880

store i1 %ifres11896, i1* %ifptr11877
br label %ifcont11877

else11877:
%res11897 = call ccc i1 @impc_false()
store i1 %res11897, i1* %ifptr11877
br label %ifcont11877

ifcont11877:
%ifres11898 = load i1, i1* %ifptr11877

br i1 %ifres11898, label %then11876, label %else11876

then11876:
%val11899 = load %VAO*, %VAO** %vaoPtr
%val11900 = load %VBO*, %VBO** %vboPtr
%res11901 = call ccc i1 @impc_true()
call fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0(%VAO* %val11899, %VBO* %val11900, i32 4, i32 16, i32 36, i32 0, i1 %res11901)
%val11903 = load %VAO*, %VAO** %vaoPtr
%val11904 = load %VBO*, %VBO** %vboPtr
%res11905 = call ccc i1 @impc_true()
call fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0(%VAO* %val11903, %VBO* %val11904, i32 8, i32 4, i32 36, i32 16, i1 %res11905)
%val11907 = load %VAO*, %VAO** %vaoPtr
%val11908 = load %VBO*, %VBO** %vboPtr
%res11909 = call ccc i1 @impc_true()
call fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0(%VAO* %val11907, %VBO* %val11908, i32 9, i32 16, i32 36, i32 20, i1 %res11909)
br label %ifcont11876

else11876:
br label %ifcont11876

ifcont11876:
%var11911 = bitcast [47 x i8]* @gsxtmgraphics-pipeline467 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var11911)
%val11914 = load i32, i32* %instancesPtr
%cmp11915 = icmp sgt i32 %val11914, 0
br i1 %cmp11915, label %then11913, label %else11913

then11913:
%val11916 = load %VAO*, %VAO** %vaoPtr
%val11917 = load i32, i32* %facemodePtr
%val11918 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val11919 = getelementptr %XTMMesh, %XTMMesh* %val11918, i64 0, i32 9
%val11920 = load i64, i64* %val11919
%val11921 = trunc i64 %val11920 to i32
%val11922 = load i32, i32* %instancesPtr
call fastcc void @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd(%VAO* %val11916, i32 %val11917, i32 0, i32 %val11921, i32 %val11922)
br label %ifcont11913

else11913:
%val11924 = load %VAO*, %VAO** %vaoPtr
%val11925 = load i32, i32* %facemodePtr
%val11926 = load %XTMMesh*, %XTMMesh** %meshPtr
; tuple ref
%val11927 = getelementptr %XTMMesh, %XTMMesh* %val11926, i64 0, i32 9
%val11928 = load i64, i64* %val11927
%val11929 = trunc i64 %val11928 to i32
call fastcc void @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0(%VAO* %val11924, i32 %val11925, i32 0, i32 %val11929)
br label %ifcont11913

ifcont11913:
%val11931 = load %Texture*, %Texture** %texturePtr
call fastcc void @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ(%Texture* %val11931, i32 1)
%var11933 = bitcast [23 x i8]* @gsxtmgraphics-pipeline468 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var11933)
ret void
}
@gsxtmgraphics-pipeline478 = hidden constant [126 x i8] c"xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}** @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone11990 = load i8*, i8** %_impzPtr
%zone11991 = bitcast i8* %tzone11990 to %mzone*

; let assign value to symbol xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd
%dat_xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd = call i8* @llvm_zone_malloc(%mzone* %zone11991, i64 8)
%xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypdPtr = bitcast i8* %dat_xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd to {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***
%tzone11714 = load i8*, i8** %_impzPtr
%zone11715 = bitcast i8* %tzone11714 to %mzone*

; let assign value to symbol vert
%dat_vert = call i8* @llvm_zone_malloc(%mzone* %zone11715, i64 4)
%vertPtr = bitcast i8* %dat_vert to i32*
%tzone11717 = load i8*, i8** %_impzPtr
%zone11718 = bitcast i8* %tzone11717 to %mzone*

; let assign value to symbol instancesvbo
%dat_instancesvbo = call i8* @llvm_zone_malloc(%mzone* %zone11718, i64 8)
%instancesvboPtr = bitcast i8* %dat_instancesvbo to %VBO**
%tzone11719 = load i8*, i8** %_impzPtr
%zone11720 = bitcast i8* %tzone11719 to %mzone*

; let assign value to symbol norm
%dat_norm = call i8* @llvm_zone_malloc(%mzone* %zone11720, i64 4)
%normPtr = bitcast i8* %dat_norm to i32*
%tzone11721 = load i8*, i8** %_impzPtr
%zone11722 = bitcast i8* %tzone11721 to %mzone*

; let assign value to symbol uvw
%dat_uvw = call i8* @llvm_zone_malloc(%mzone* %zone11722, i64 4)
%uvwPtr = bitcast i8* %dat_uvw to i32*
%tzone11723 = load i8*, i8** %_impzPtr
%zone11724 = bitcast i8* %tzone11723 to %mzone*

; let assign value to symbol color
%dat_color = call i8* @llvm_zone_malloc(%mzone* %zone11724, i64 4)
%colorPtr = bitcast i8* %dat_color to i32*

; let value assignment
%vert = select i1 true, i32 0, i32 0
store i32 %vert, i32* %vertPtr

%null11716 = bitcast i8* null to %VBO*

; let value assignment
%instancesvbo = select i1 true, %VBO* %null11716, %VBO* %null11716
store %VBO* %instancesvbo, %VBO** %instancesvboPtr


; let value assignment
%norm = select i1 true, i32 1, i32 1
store i32 %norm, i32* %normPtr


; let value assignment
%uvw = select i1 true, i32 2, i32 2
store i32 %uvw, i32* %uvwPtr


; let value assignment
%color = select i1 true, i32 3, i32 3
store i32 %color, i32* %colorPtr

%tzone11987 = load i8*, i8** %_impzPtr
%zone11988 = bitcast i8* %tzone11987 to %mzone*

; let assign value to symbol _anon_lambda_21
%dat__anon_lambda_21 = call i8* @llvm_zone_malloc(%mzone* %zone11988, i64 8)
%_anon_lambda_21Ptr = bitcast i8* %dat__anon_lambda_21 to { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***
%tzone11938 = load i8*, i8** %_impzPtr
%zone11939 = bitcast i8* %tzone11938 to %mzone*
call void @llvm_zone_mark(%mzone* %zone11939)
; malloc closure structure
%clsptr11940 = call i8* @llvm_zone_malloc(%mzone* %zone11939, i64 24)
%closure11941 = bitcast i8* %clsptr11940 to { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}*

; malloc environment structure
%envptr11942 = call i8* @llvm_zone_malloc(%mzone* %zone11939, i64 56)
%environment11943 = bitcast i8* %envptr11942 to {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}*

; malloc closure address table
%addytable11944 = call %clsvar* @new_address_table()
%var11945 = bitcast [73 x i8]* @gsxtmgraphics-pipeline469 to i8*
%var11946 = bitcast [71 x i8]* @gsxtmgraphics-pipeline470 to i8*
%addytable11947 = call %clsvar* @add_address_table(%mzone* %zone11939, i8* %var11945, i32 0, i8* %var11946, i32 3, %clsvar* %addytable11944)
%var11948 = bitcast [6 x i8]* @gsxtmgraphics-pipeline471 to i8*
%var11949 = bitcast [4 x i8]* @gsxtmgraphics-pipeline241 to i8*
%addytable11950 = call %clsvar* @add_address_table(%mzone* %zone11939, i8* %var11948, i32 8, i8* %var11949, i32 3, %clsvar* %addytable11947)
%var11951 = bitcast [4 x i8]* @gsxtmgraphics-pipeline472 to i8*
%var11952 = bitcast [4 x i8]* @gsxtmgraphics-pipeline241 to i8*
%addytable11953 = call %clsvar* @add_address_table(%mzone* %zone11939, i8* %var11951, i32 16, i8* %var11952, i32 3, %clsvar* %addytable11950)
%var11954 = bitcast [5 x i8]* @gsxtmgraphics-pipeline473 to i8*
%var11955 = bitcast [4 x i8]* @gsxtmgraphics-pipeline241 to i8*
%addytable11956 = call %clsvar* @add_address_table(%mzone* %zone11939, i8* %var11954, i32 24, i8* %var11955, i32 3, %clsvar* %addytable11953)
%var11957 = bitcast [13 x i8]* @gsxtmgraphics-pipeline474 to i8*
%var11958 = bitcast [6 x i8]* @gsxtmgraphics-pipeline475 to i8*
%addytable11959 = call %clsvar* @add_address_table(%mzone* %zone11939, i8* %var11957, i32 32, i8* %var11958, i32 3, %clsvar* %addytable11956)
%var11960 = bitcast [5 x i8]* @gsxtmgraphics-pipeline476 to i8*
%var11961 = bitcast [4 x i8]* @gsxtmgraphics-pipeline241 to i8*
%addytable11962 = call %clsvar* @add_address_table(%mzone* %zone11939, i8* %var11960, i32 40, i8* %var11961, i32 3, %clsvar* %addytable11959)
%var11963 = bitcast [16 x i8]* @gsxtmgraphics-pipeline477 to i8*
%var11964 = bitcast [71 x i8]* @gsxtmgraphics-pipeline470 to i8*
%addytable11965 = call %clsvar* @add_address_table(%mzone* %zone11939, i8* %var11963, i32 48, i8* %var11964, i32 3, %clsvar* %addytable11962)
%address-table11966 = bitcast %clsvar* %addytable11965 to i8*

; insert table, function and environment into closure struct
%closure.table11981 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}* %closure11941, i32 0, i32 0
store i8* %address-table11966, i8** %closure.table11981
%closure.env11982 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}* %closure11941, i32 0, i32 1
store i8* %envptr11942, i8** %closure.env11982
%closure.func11983 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}* %closure11941, i32 0, i32 2
store void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)* @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd__11713, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)** %closure.func11983
%closure_size11984 = call i64 @llvm_zone_mark_size(%mzone* %zone11939)
call void @llvm_zone_ptr_set_size(i8* %clsptr11940, i64 %closure_size11984)
%wrapper_ptr11985 = call i8* @llvm_zone_malloc(%mzone* %zone11939, i64 8)
%closure_wrapper11986 = bitcast i8* %wrapper_ptr11985 to { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}**
store { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}* %closure11941, { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}** %closure_wrapper11986

; let value assignment
%_anon_lambda_21 = select i1 true, { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}** %closure_wrapper11986, { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}** %closure_wrapper11986
store { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}** %_anon_lambda_21, { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}*** %_anon_lambda_21Ptr

; add data to environment
; don't need to alloc for env var xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd
%tmp_envptr11968 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}* %environment11943, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}*** %xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypdPtr, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}**** %tmp_envptr11968

; don't need to alloc for env var color
%tmp_envptr11970 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}* %environment11943, i32 0, i32 1
store i32* %colorPtr, i32** %tmp_envptr11970

; don't need to alloc for env var uvw
%tmp_envptr11972 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}* %environment11943, i32 0, i32 2
store i32* %uvwPtr, i32** %tmp_envptr11972

; don't need to alloc for env var norm
%tmp_envptr11974 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}* %environment11943, i32 0, i32 3
store i32* %normPtr, i32** %tmp_envptr11974

; don't need to alloc for env var instancesvbo
%tmp_envptr11976 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}* %environment11943, i32 0, i32 4
store %VBO** %instancesvboPtr, %VBO*** %tmp_envptr11976

; don't need to alloc for env var vert
%tmp_envptr11978 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}* %environment11943, i32 0, i32 5
store i32* %vertPtr, i32** %tmp_envptr11978

; don't need to alloc for env var _anon_lambda_21
%tmp_envptr11980 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***, i32*, i32*, i32*, %VBO**, i32*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}***}* %environment11943, i32 0, i32 6
store {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}*** %_anon_lambda_21Ptr, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}**** %tmp_envptr11980


%val11989 = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}**, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}*** %_anon_lambda_21Ptr

; let value assignment
%xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd = select i1 true, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}** %val11989, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}** %val11989
store {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}** %xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}*** %xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypdPtr

%val11992 = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}**, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}*** %xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypdPtr
ret {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}** %val11992
}


@xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}** @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd(%XTMMesh* %arg_0,%ShaderProgram* %arg_1,i32 %arg_2,%VBO* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*,  void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, %ShaderProgram* %arg_1, i32 %arg_2, %VBO* %arg_3)
ret void
}


define dllexport ccc void @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd_native(%XTMMesh* %arg_0,%ShaderProgram* %arg_1,i32 %arg_2,%VBO* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*,  void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, %ShaderProgram* %arg_1, i32 %arg_2, %VBO* %arg_3)
ret void
}


define dllexport ccc i8*  @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var11993 = bitcast [126 x i8]* @gsxtmgraphics-pipeline478 to i8*
call i32 (i8*, ...) @printf(i8* %var11993)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMMesh*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var11994 = bitcast [126 x i8]* @gsxtmgraphics-pipeline478 to i8*
call i32 (i8*, ...) @printf(i8* %var11994)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %ShaderProgram*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var11995 = bitcast [126 x i8]* @gsxtmgraphics-pipeline478 to i8*
call i32 (i8*, ...) @printf(i8* %var11995)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var11996 = bitcast [126 x i8]* @gsxtmgraphics-pipeline478 to i8*
call i32 (i8*, ...) @printf(i8* %var11996)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*,  void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, %ShaderProgram* %arg_1, i32 %arg_2, %VBO* %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMMesh*, %ShaderProgram*, i32, %VBO*}*
%arg_p_0 = getelementptr {%XTMMesh*, %ShaderProgram*, i32, %VBO*}, {%XTMMesh*, %ShaderProgram*, i32, %VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMMesh*, %XTMMesh** %arg_p_0
%arg_p_1 = getelementptr {%XTMMesh*, %ShaderProgram*, i32, %VBO*}, {%XTMMesh*, %ShaderProgram*, i32, %VBO*}* %fstruct, i32 0, i32 1
%arg_1 = load %ShaderProgram*, %ShaderProgram** %arg_p_1
%arg_p_2 = getelementptr {%XTMMesh*, %ShaderProgram*, i32, %VBO*}, {%XTMMesh*, %ShaderProgram*, i32, %VBO*}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {%XTMMesh*, %ShaderProgram*, i32, %VBO*}, {%XTMMesh*, %ShaderProgram*, i32, %VBO*}* %fstruct, i32 0, i32 3
%arg_3 = load %VBO*, %VBO** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)*,  void (i8*, i8*, %XTMMesh*, %ShaderProgram*, i32, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, %ShaderProgram* %arg_1, i32 %arg_2, %VBO* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline479 = hidden constant [61 x i8] c"xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd\00"
@gsxtmgraphics-pipeline480 = hidden constant [59 x i8] c"{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}**\00"
define dllexport fastcc void @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd__11997(i8* %_impz,i8* %_impenv, %XTMMesh* %mesh, %ShaderProgram* %shader) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone11998 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}***}*
%xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}***}* %impenv, i32 0, i32 0
%xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpdPtr = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}***, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}**** %xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpdPtr_

; setup arguments
%meshPtr = alloca %XTMMesh*
store %XTMMesh* %mesh, %XTMMesh** %meshPtr
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr


%val11999 = load %XTMMesh*, %XTMMesh** %meshPtr
%val12000 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%null12001 = bitcast i8* null to %VBO*
call fastcc void @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd(%XTMMesh* %val11999, %ShaderProgram* %val12000, i32 0, %VBO* %null12001)
ret void
}
@gsxtmgraphics-pipeline481 = hidden constant [114 x i8] c"xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}** @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12022 = load i8*, i8** %_impzPtr
%zone12023 = bitcast i8* %tzone12022 to %mzone*

; let assign value to symbol xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd
%dat_xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd = call i8* @llvm_zone_malloc(%mzone* %zone12023, i64 8)
%xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpdPtr = bitcast i8* %dat_xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd to { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}***
%tzone12003 = load i8*, i8** %_impzPtr
%zone12004 = bitcast i8* %tzone12003 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12004)
; malloc closure structure
%clsptr12005 = call i8* @llvm_zone_malloc(%mzone* %zone12004, i64 24)
%closure12006 = bitcast i8* %clsptr12005 to { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}*

; malloc environment structure
%envptr12007 = call i8* @llvm_zone_malloc(%mzone* %zone12004, i64 8)
%environment12008 = bitcast i8* %envptr12007 to {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}***}*

; malloc closure address table
%addytable12009 = call %clsvar* @new_address_table()
%var12010 = bitcast [61 x i8]* @gsxtmgraphics-pipeline479 to i8*
%var12011 = bitcast [59 x i8]* @gsxtmgraphics-pipeline480 to i8*
%addytable12012 = call %clsvar* @add_address_table(%mzone* %zone12004, i8* %var12010, i32 0, i8* %var12011, i32 3, %clsvar* %addytable12009)
%address-table12013 = bitcast %clsvar* %addytable12012 to i8*

; insert table, function and environment into closure struct
%closure.table12016 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}* %closure12006, i32 0, i32 0
store i8* %address-table12013, i8** %closure.table12016
%closure.env12017 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}* %closure12006, i32 0, i32 1
store i8* %envptr12007, i8** %closure.env12017
%closure.func12018 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}* %closure12006, i32 0, i32 2
store void (i8*, i8*, %XTMMesh*, %ShaderProgram*)* @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd__11997, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)** %closure.func12018
%closure_size12019 = call i64 @llvm_zone_mark_size(%mzone* %zone12004)
call void @llvm_zone_ptr_set_size(i8* %clsptr12005, i64 %closure_size12019)
%wrapper_ptr12020 = call i8* @llvm_zone_malloc(%mzone* %zone12004, i64 8)
%closure_wrapper12021 = bitcast i8* %wrapper_ptr12020 to { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}**
store { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}* %closure12006, { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}** %closure_wrapper12021

; let value assignment
%xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd = select i1 true, { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}** %closure_wrapper12021, { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}** %closure_wrapper12021
store { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}** %xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd, { i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}*** %xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpdPtr

; add data to environment
; don't need to alloc for env var xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd
%tmp_envptr12015 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}***}* %environment12008, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}*** %xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpdPtr, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}**** %tmp_envptr12015


%val12024 = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}**, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}*** %xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpdPtr
ret {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}** %val12024
}


@xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}** @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd(%XTMMesh* %arg_0,%ShaderProgram* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*,  void (i8*, i8*, %XTMMesh*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, %ShaderProgram* %arg_1)
ret void
}


define dllexport ccc void @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd_native(%XTMMesh* %arg_0,%ShaderProgram* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*,  void (i8*, i8*, %XTMMesh*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, %ShaderProgram* %arg_1)
ret void
}


define dllexport ccc i8*  @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12025 = bitcast [114 x i8]* @gsxtmgraphics-pipeline481 to i8*
call i32 (i8*, ...) @printf(i8* %var12025)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMMesh*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12026 = bitcast [114 x i8]* @gsxtmgraphics-pipeline481 to i8*
call i32 (i8*, ...) @printf(i8* %var12026)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %ShaderProgram*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*,  void (i8*, i8*, %XTMMesh*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, %ShaderProgram* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMMesh*, %ShaderProgram*}*
%arg_p_0 = getelementptr {%XTMMesh*, %ShaderProgram*}, {%XTMMesh*, %ShaderProgram*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMMesh*, %XTMMesh** %arg_p_0
%arg_p_1 = getelementptr {%XTMMesh*, %ShaderProgram*}, {%XTMMesh*, %ShaderProgram*}* %fstruct, i32 0, i32 1
%arg_1 = load %ShaderProgram*, %ShaderProgram** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMMesh*, %ShaderProgram*)*,  void (i8*, i8*, %XTMMesh*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMMesh* %arg_0, %ShaderProgram* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline482 = hidden constant [30 x i8] c"Error before drawing XTMModel\00"
@gsxtmgraphics-pipeline483 = hidden constant [24 x i8] c"Error drawing XTMModel!\00"
@gsxtmgraphics-pipeline484 = hidden constant [104 x i8] c"xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ\00"
@gsxtmgraphics-pipeline485 = hidden constant [96 x i8] c"{i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}**\00"
define dllexport fastcc void @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ__12027(i8* %_impz,i8* %_impenv, %XTMModel* %node, %ShaderProgram* %shader, float* %model, float* %view, float* %projection, i32 %instances, %VBO* %vbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12028 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}***}*
%xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}***}* %impenv, i32 0, i32 0
%xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQPtr = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}***, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}**** %xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQPtr_

; setup arguments
%nodePtr = alloca %XTMModel*
store %XTMModel* %node, %XTMModel** %nodePtr
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%modelPtr = alloca float*
store float* %model, float** %modelPtr
%viewPtr = alloca float*
store float* %view, float** %viewPtr
%projectionPtr = alloca float*
store float* %projection, float** %projectionPtr
%instancesPtr = alloca i32
store i32 %instances, i32* %instancesPtr
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr


%var12029 = bitcast [30 x i8]* @gsxtmgraphics-pipeline482 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var12029)
%tzone12031 = load i8*, i8** %_impzPtr
%zone12032 = bitcast i8* %tzone12031 to %mzone*

; let assign value to symbol i
%iPtr = alloca i32
%tzone12034 = load i8*, i8** %_impzPtr
%zone12035 = bitcast i8* %tzone12034 to %mzone*

; let assign value to symbol lights
%lightsPtr = alloca %xtm_lights*
%tzone12039 = load i8*, i8** %_impzPtr
%zone12040 = bitcast i8* %tzone12039 to %mzone*

; let assign value to symbol children
%childrenPtr = alloca %XTMModel*
%tzone12044 = load i8*, i8** %_impzPtr
%zone12045 = bitcast i8* %tzone12044 to %mzone*

; let assign value to symbol meshes
%meshesPtr = alloca %XTMMesh*
%tzone12049 = load i8*, i8** %_impzPtr
%zone12050 = bitcast i8* %tzone12049 to %mzone*

; let assign value to symbol transmat
%transmatPtr = alloca float*
%tzone12052 = load i8*, i8** %_impzPtr
%zone12053 = bitcast i8* %tzone12052 to %mzone*

; let assign value to symbol m2
%m2Ptr = alloca float*
%tzone12055 = load i8*, i8** %_impzPtr
%zone12056 = bitcast i8* %tzone12055 to %mzone*

; let assign value to symbol m
%mPtr = alloca float*

; let value assignment
%i = select i1 true, i32 0, i32 0
store i32 %i, i32* %iPtr

%res12033 = call fastcc %xtm_lights* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ()

; let value assignment
%lights = select i1 true, %xtm_lights* %res12033, %xtm_lights* %res12033
store %xtm_lights* %lights, %xtm_lights** %lightsPtr

%val12036 = load %XTMModel*, %XTMModel** %nodePtr
; tuple ref
%val12037 = getelementptr %XTMModel, %XTMModel* %val12036, i64 0, i32 4
%val12038 = load %XTMModel*, %XTMModel** %val12037

; let value assignment
%children = select i1 true, %XTMModel* %val12038, %XTMModel* %val12038
store %XTMModel* %children, %XTMModel** %childrenPtr

%val12041 = load %XTMModel*, %XTMModel** %nodePtr
; tuple ref
%val12042 = getelementptr %XTMModel, %XTMModel* %val12041, i64 0, i32 6
%val12043 = load %XTMMesh*, %XTMMesh** %val12042

; let value assignment
%meshes = select i1 true, %XTMMesh* %val12043, %XTMMesh* %val12043
store %XTMMesh* %meshes, %XTMMesh** %meshesPtr

%val12046 = load %XTMModel*, %XTMModel** %nodePtr
; tuple ref
%val12047 = getelementptr %XTMModel, %XTMModel* %val12046, i64 0, i32 1
%val12048 = load float*, float** %val12047

; let value assignment
%transmat = select i1 true, float* %val12048, float* %val12048
store float* %transmat, float** %transmatPtr

%dat12051 = alloca float, i64 16, align 16

; let value assignment
%m2 = select i1 true, float* %dat12051, float* %dat12051
store float* %m2, float** %m2Ptr

%dat12054 = alloca float, i64 16, align 16

; let value assignment
%m = select i1 true, float* %dat12054, float* %dat12054
store float* %m, float** %mPtr

; promote local stack var allocations
%tzone12132 = load i8*, i8** %_impzPtr
%zone12133 = bitcast i8* %tzone12132 to %mzone*
%ifptr12057 = alloca i64
%val12058 = load float*, float** %transmatPtr
%val12059 = icmp eq float* %val12058, null
br i1 %val12059, label %then12057, label %else12057

then12057:
%val12060 = load float*, float** %mPtr
%val12061 = bitcast float* %val12060 to i8*
%val12062 = load float*, float** %modelPtr
%val12063 = bitcast float* %val12062 to i8*
%val12064 = mul i64 4, 16
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val12061, i8* %val12063, i64 %val12064, i32 1, i1 0)
store i64 1, i64* %ifptr12057
br label %ifcont12057

else12057:
%val12066 = load float*, float** %transmatPtr
%val12067 = load float*, float** %m2Ptr
%res12068 = call fastcc float* @mtrans_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCpd(float* %val12066, i64 4, i64 4, float* %val12067)
%val12069 = load float*, float** %m2Ptr
%val12070 = load float*, float** %modelPtr
%val12071 = load float*, float** %mPtr
%res12072 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val12069, float* %val12070, float* %val12071)
store i64 1, i64* %ifptr12057
br label %ifcont12057

ifcont12057:
%ifres12073 = load i64, i64* %ifptr12057

%val12074 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val12075 = load float*, float** %mPtr
%val12076 = load float*, float** %viewPtr
%val12077 = load float*, float** %projectionPtr
call fastcc void @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd(%ShaderProgram* %val12074, float* %val12075, float* %val12076, float* %val12077)
; setup loop
%val12083 = load %XTMModel*, %XTMModel** %nodePtr
; tuple ref
%val12084 = getelementptr %XTMModel, %XTMModel* %val12083, i64 0, i32 5
%val12085 = load i32, i32* %val12084
store i32 0, i32* %iPtr
%val12093 = load i32, i32* %iPtr
%num12094 = add i32 %val12085, %val12093
%comp12095 = icmp ult i32 %val12085, 1
br i1 %comp12095, label %after12079, label %loop12079

loop12079:
%val12086 = load i32, i32* %iPtr
%val12087 = load %XTMMesh*, %XTMMesh** %meshesPtr
; pointer ref
%val12088 = getelementptr %XTMMesh, %XTMMesh* %val12087, i32 %val12086
%val12089 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val12090 = load i32, i32* %instancesPtr
%val12091 = load %VBO*, %VBO** %vboPtr
call fastcc void @xtm_draw_mesh_adhoc_W3ZvaWQsWFRNTWVzaCosU2hhZGVyUHJvZ3JhbSosaTMyLFZCTypd(%XTMMesh* %val12088, %ShaderProgram* %val12089, i32 %val12090, %VBO* %val12091)
%loop_cnt12079 = load i32, i32* %iPtr
%next12079 = add i32 %loop_cnt12079, 1
store i32 %next12079, i32* %iPtr
%cmp12079 = icmp ult i32 %next12079, %num12094
br i1 %cmp12079, label %loop12079, label %after12079

after12079:
%var12097 = bitcast [23 x i8]* @gsxtmgraphics-pipeline468 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var12097)
; setup loop
%val12103 = load %XTMModel*, %XTMModel** %nodePtr
; tuple ref
%val12104 = getelementptr %XTMModel, %XTMModel* %val12103, i64 0, i32 3
%val12105 = load i32, i32* %val12104
store i32 0, i32* %iPtr
%val12125 = load i32, i32* %iPtr
%num12126 = add i32 %val12105, %val12125
%comp12127 = icmp ult i32 %val12105, 1
br i1 %comp12127, label %after12099, label %loop12099

loop12099:
%val12106 = load i32, i32* %iPtr
%val12107 = load %XTMModel*, %XTMModel** %childrenPtr
; pointer ref
%val12108 = getelementptr %XTMModel, %XTMModel* %val12107, i32 %val12106
%val12109 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val12110 = load float*, float** %modelPtr
%val12111 = load float*, float** %viewPtr
%val12112 = load float*, float** %projectionPtr
%val12113 = load i32, i32* %instancesPtr
%val12114 = load %VBO*, %VBO** %vboPtr

; apply closure 
%vval12115 = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}**, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}*** %xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQPtr
%val12116 = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}*,{i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}** %vval12115
%fPtr12117 = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}* %val12116, i32 0, i32 2
%ePtr12118 = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}* %val12116, i32 0, i32 1
%f12119 = load void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)** %fPtr12117
%e12120 = load i8*, i8** %ePtr12118
%tzone12121 = load i8*, i8** %_impzPtr
%zone12122 = bitcast i8* %tzone12121 to %mzone*
%z12123 = bitcast %mzone* %zone12122 to i8*
tail call fastcc void %f12119(i8* %z12123, i8* %e12120, %XTMModel* %val12108, %ShaderProgram* %val12109, float* %val12110, float* %val12111, float* %val12112, i32 %val12113, %VBO* %val12114)
%loop_cnt12099 = load i32, i32* %iPtr
%next12099 = add i32 %loop_cnt12099, 1
store i32 %next12099, i32* %iPtr
%cmp12099 = icmp ult i32 %next12099, %num12126
br i1 %cmp12099, label %loop12099, label %after12099

after12099:
%var12129 = bitcast [24 x i8]* @gsxtmgraphics-pipeline483 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var12129)
ret void
}
@gsxtmgraphics-pipeline486 = hidden constant [157 x i8] c"xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}** @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12153 = load i8*, i8** %_impzPtr
%zone12154 = bitcast i8* %tzone12153 to %mzone*

; let assign value to symbol xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ
%dat_xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone12154, i64 8)
%xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQPtr = bitcast i8* %dat_xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ to { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}***
%tzone12134 = load i8*, i8** %_impzPtr
%zone12135 = bitcast i8* %tzone12134 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12135)
; malloc closure structure
%clsptr12136 = call i8* @llvm_zone_malloc(%mzone* %zone12135, i64 24)
%closure12137 = bitcast i8* %clsptr12136 to { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}*

; malloc environment structure
%envptr12138 = call i8* @llvm_zone_malloc(%mzone* %zone12135, i64 8)
%environment12139 = bitcast i8* %envptr12138 to {{i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}***}*

; malloc closure address table
%addytable12140 = call %clsvar* @new_address_table()
%var12141 = bitcast [104 x i8]* @gsxtmgraphics-pipeline484 to i8*
%var12142 = bitcast [96 x i8]* @gsxtmgraphics-pipeline485 to i8*
%addytable12143 = call %clsvar* @add_address_table(%mzone* %zone12135, i8* %var12141, i32 0, i8* %var12142, i32 3, %clsvar* %addytable12140)
%address-table12144 = bitcast %clsvar* %addytable12143 to i8*

; insert table, function and environment into closure struct
%closure.table12147 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}* %closure12137, i32 0, i32 0
store i8* %address-table12144, i8** %closure.table12147
%closure.env12148 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}* %closure12137, i32 0, i32 1
store i8* %envptr12138, i8** %closure.env12148
%closure.func12149 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}* %closure12137, i32 0, i32 2
store void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)* @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ__12027, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)** %closure.func12149
%closure_size12150 = call i64 @llvm_zone_mark_size(%mzone* %zone12135)
call void @llvm_zone_ptr_set_size(i8* %clsptr12136, i64 %closure_size12150)
%wrapper_ptr12151 = call i8* @llvm_zone_malloc(%mzone* %zone12135, i64 8)
%closure_wrapper12152 = bitcast i8* %wrapper_ptr12151 to { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}**
store { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}* %closure12137, { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}** %closure_wrapper12152

; let value assignment
%xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}** %closure_wrapper12152, { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}** %closure_wrapper12152
store { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}** %xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ, { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}*** %xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQPtr

; add data to environment
; don't need to alloc for env var xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ
%tmp_envptr12146 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}***}* %environment12139, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}*** %xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQPtr, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}**** %tmp_envptr12146


%val12155 = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}**, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}*** %xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQPtr
ret {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}** %val12155
}


@xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}** @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ(%XTMModel* %arg_0,%ShaderProgram* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,i32 %arg_5,%VBO* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*,  void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, %ShaderProgram* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, i32 %arg_5, %VBO* %arg_6)
ret void
}


define dllexport ccc void @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ_native(%XTMModel* %arg_0,%ShaderProgram* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,i32 %arg_5,%VBO* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*,  void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, %ShaderProgram* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, i32 %arg_5, %VBO* %arg_6)
ret void
}


define dllexport ccc i8*  @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12156 = bitcast [157 x i8]* @gsxtmgraphics-pipeline486 to i8*
call i32 (i8*, ...) @printf(i8* %var12156)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMModel*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12157 = bitcast [157 x i8]* @gsxtmgraphics-pipeline486 to i8*
call i32 (i8*, ...) @printf(i8* %var12157)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %ShaderProgram*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var12158 = bitcast [157 x i8]* @gsxtmgraphics-pipeline486 to i8*
call i32 (i8*, ...) @printf(i8* %var12158)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var12159 = bitcast [157 x i8]* @gsxtmgraphics-pipeline486 to i8*
call i32 (i8*, ...) @printf(i8* %var12159)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var12160 = bitcast [157 x i8]* @gsxtmgraphics-pipeline486 to i8*
call i32 (i8*, ...) @printf(i8* %var12160)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var12161 = bitcast [157 x i8]* @gsxtmgraphics-pipeline486 to i8*
call i32 (i8*, ...) @printf(i8* %var12161)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var12162 = bitcast [157 x i8]* @gsxtmgraphics-pipeline486 to i8*
call i32 (i8*, ...) @printf(i8* %var12162)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*,  void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, %ShaderProgram* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, i32 %arg_5, %VBO* %arg_6)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*}*
%arg_p_0 = getelementptr {%XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*}, {%XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMModel*, %XTMModel** %arg_p_0
%arg_p_1 = getelementptr {%XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*}, {%XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*}* %fstruct, i32 0, i32 1
%arg_1 = load %ShaderProgram*, %ShaderProgram** %arg_p_1
%arg_p_2 = getelementptr {%XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*}, {%XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*}, {%XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {%XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*}, {%XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {%XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*}, {%XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
%arg_p_6 = getelementptr {%XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*}, {%XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*}* %fstruct, i32 0, i32 6
%arg_6 = load %VBO*, %VBO** %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)*,  void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*, i32, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, %ShaderProgram* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, i32 %arg_5, %VBO* %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline487 = hidden constant [92 x i8] c"xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ\00"
@gsxtmgraphics-pipeline488 = hidden constant [84 x i8] c"{i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}**\00"
define dllexport fastcc void @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ__12163(i8* %_impz,i8* %_impenv, %XTMModel* %node, %ShaderProgram* %shader, float* %model, float* %view, float* %projection) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12164 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}***}*
%xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}**** %xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_

; setup arguments
%nodePtr = alloca %XTMModel*
store %XTMModel* %node, %XTMModel** %nodePtr
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%modelPtr = alloca float*
store float* %model, float** %modelPtr
%viewPtr = alloca float*
store float* %view, float** %viewPtr
%projectionPtr = alloca float*
store float* %projection, float** %projectionPtr


%val12165 = load %XTMModel*, %XTMModel** %nodePtr
%val12166 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val12167 = load float*, float** %modelPtr
%val12168 = load float*, float** %viewPtr
%val12169 = load float*, float** %projectionPtr
%null12170 = bitcast i8* null to %VBO*
call fastcc void @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGkzMixWQk8qXQ(%XTMModel* %val12165, %ShaderProgram* %val12166, float* %val12167, float* %val12168, float* %val12169, i32 0, %VBO* %null12170)
ret void
}
@gsxtmgraphics-pipeline489 = hidden constant [145 x i8] c"xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}** @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12191 = load i8*, i8** %_impzPtr
%zone12192 = bitcast i8* %tzone12191 to %mzone*

; let assign value to symbol xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%dat_xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone12192, i64 8)
%xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = bitcast i8* %dat_xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ to { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}***
%tzone12172 = load i8*, i8** %_impzPtr
%zone12173 = bitcast i8* %tzone12172 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12173)
; malloc closure structure
%clsptr12174 = call i8* @llvm_zone_malloc(%mzone* %zone12173, i64 24)
%closure12175 = bitcast i8* %clsptr12174 to { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}*

; malloc environment structure
%envptr12176 = call i8* @llvm_zone_malloc(%mzone* %zone12173, i64 8)
%environment12177 = bitcast i8* %envptr12176 to {{i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}***}*

; malloc closure address table
%addytable12178 = call %clsvar* @new_address_table()
%var12179 = bitcast [92 x i8]* @gsxtmgraphics-pipeline487 to i8*
%var12180 = bitcast [84 x i8]* @gsxtmgraphics-pipeline488 to i8*
%addytable12181 = call %clsvar* @add_address_table(%mzone* %zone12173, i8* %var12179, i32 0, i8* %var12180, i32 3, %clsvar* %addytable12178)
%address-table12182 = bitcast %clsvar* %addytable12181 to i8*

; insert table, function and environment into closure struct
%closure.table12185 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}* %closure12175, i32 0, i32 0
store i8* %address-table12182, i8** %closure.table12185
%closure.env12186 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}* %closure12175, i32 0, i32 1
store i8* %envptr12176, i8** %closure.env12186
%closure.func12187 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}* %closure12175, i32 0, i32 2
store void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)* @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ__12163, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)** %closure.func12187
%closure_size12188 = call i64 @llvm_zone_mark_size(%mzone* %zone12173)
call void @llvm_zone_ptr_set_size(i8* %clsptr12174, i64 %closure_size12188)
%wrapper_ptr12189 = call i8* @llvm_zone_malloc(%mzone* %zone12173, i64 8)
%closure_wrapper12190 = bitcast i8* %wrapper_ptr12189 to { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}* %closure12175, { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}** %closure_wrapper12190

; let value assignment
%xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}** %closure_wrapper12190, { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}** %closure_wrapper12190
store { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}** %xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ, { i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}*** %xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr

; add data to environment
; don't need to alloc for env var xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%tmp_envptr12184 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}***}* %environment12177, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}*** %xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}**** %tmp_envptr12184


%val12193 = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}*** %xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr
ret {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}** %val12193
}


@xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}** @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ(%XTMModel* %arg_0,%ShaderProgram* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*,  void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, %ShaderProgram* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4)
ret void
}


define dllexport ccc void @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_native(%XTMModel* %arg_0,%ShaderProgram* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*,  void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, %ShaderProgram* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4)
ret void
}


define dllexport ccc i8*  @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12194 = bitcast [145 x i8]* @gsxtmgraphics-pipeline489 to i8*
call i32 (i8*, ...) @printf(i8* %var12194)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMModel*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12195 = bitcast [145 x i8]* @gsxtmgraphics-pipeline489 to i8*
call i32 (i8*, ...) @printf(i8* %var12195)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %ShaderProgram*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var12196 = bitcast [145 x i8]* @gsxtmgraphics-pipeline489 to i8*
call i32 (i8*, ...) @printf(i8* %var12196)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var12197 = bitcast [145 x i8]* @gsxtmgraphics-pipeline489 to i8*
call i32 (i8*, ...) @printf(i8* %var12197)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var12198 = bitcast [145 x i8]* @gsxtmgraphics-pipeline489 to i8*
call i32 (i8*, ...) @printf(i8* %var12198)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*,  void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, %ShaderProgram* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMModel*, %ShaderProgram*, float*, float*, float*}*
%arg_p_0 = getelementptr {%XTMModel*, %ShaderProgram*, float*, float*, float*}, {%XTMModel*, %ShaderProgram*, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMModel*, %XTMModel** %arg_p_0
%arg_p_1 = getelementptr {%XTMModel*, %ShaderProgram*, float*, float*, float*}, {%XTMModel*, %ShaderProgram*, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load %ShaderProgram*, %ShaderProgram** %arg_p_1
%arg_p_2 = getelementptr {%XTMModel*, %ShaderProgram*, float*, float*, float*}, {%XTMModel*, %ShaderProgram*, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%XTMModel*, %ShaderProgram*, float*, float*, float*}, {%XTMModel*, %ShaderProgram*, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {%XTMModel*, %ShaderProgram*, float*, float*, float*}, {%XTMModel*, %ShaderProgram*, float*, float*, float*}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)*,  void (i8*, i8*, %XTMModel*, %ShaderProgram*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, %ShaderProgram* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@xtm_render_light_shader = dllexport global %ShaderProgram* zeroinitializer
@xtm_render_simple_shader = dllexport global %ShaderProgram* zeroinitializer
@xtm_render_simple_bone_shader = dllexport global %ShaderProgram* zeroinitializer
@xtm_render_quad_shader = dllexport global %ShaderProgram* zeroinitializer
@xtm_render_dof_shader = dllexport global %ShaderProgram* zeroinitializer
@xtm_render_skybox_shader = dllexport global %ShaderProgram* zeroinitializer
@xtm_render_x = dllexport global i32 0
@xtm_render_y = dllexport global i32 0
@xtm_render_w = dllexport global i32 1024
@xtm_render_h = dllexport global i32 768
@xtm_render_angle = dllexport global float 0x4041800000000000
@xtm_render_near = dllexport global float 0x3fb99999a0000000
@xtm_render_far = dllexport global float 0x408f400000000000
@gsxtmgraphics-pipeline490 = hidden constant [74 x i8] c"xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0\00"
@gsxtmgraphics-pipeline491 = hidden constant [71 x i8] c"{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}**\00"
define dllexport fastcc void @xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0__12199(i8* %_impz,i8* %_impenv, float* %pt_in, float* %pt_out, float* %model, float* %view, float* %projection) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12200 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}***}*
%xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}**** %xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr_

; setup arguments
%pt_inPtr = alloca float*
store float* %pt_in, float** %pt_inPtr
%pt_outPtr = alloca float*
store float* %pt_out, float** %pt_outPtr
%modelPtr = alloca float*
store float* %model, float** %modelPtr
%viewPtr = alloca float*
store float* %view, float** %viewPtr
%projectionPtr = alloca float*
store float* %projection, float** %projectionPtr


%tzone12204 = load i8*, i8** %_impzPtr
%zone12205 = bitcast i8* %tzone12204 to %mzone*

; let assign value to symbol x
%xPtr = alloca float
%tzone12209 = load i8*, i8** %_impzPtr
%zone12210 = bitcast i8* %tzone12209 to %mzone*

; let assign value to symbol y
%yPtr = alloca float
%tzone12214 = load i8*, i8** %_impzPtr
%zone12215 = bitcast i8* %tzone12214 to %mzone*

; let assign value to symbol z
%zPtr = alloca float
%tzone12218 = load i8*, i8** %_impzPtr
%zone12219 = bitcast i8* %tzone12218 to %mzone*

; let assign value to symbol vp_x
%vp_xPtr = alloca float
%tzone12222 = load i8*, i8** %_impzPtr
%zone12223 = bitcast i8* %tzone12222 to %mzone*

; let assign value to symbol vp_y
%vp_yPtr = alloca float
%tzone12226 = load i8*, i8** %_impzPtr
%zone12227 = bitcast i8* %tzone12226 to %mzone*

; let assign value to symbol vp_w
%vp_wPtr = alloca float
%tzone12230 = load i8*, i8** %_impzPtr
%zone12231 = bitcast i8* %tzone12230 to %mzone*

; let assign value to symbol vp_h
%vp_hPtr = alloca float
%tzone12233 = load i8*, i8** %_impzPtr
%zone12234 = bitcast i8* %tzone12233 to %mzone*

; let assign value to symbol vp_n
%vp_nPtr = alloca float
%tzone12236 = load i8*, i8** %_impzPtr
%zone12237 = bitcast i8* %tzone12236 to %mzone*

; let assign value to symbol vp_f
%vp_fPtr = alloca float
%tzone12239 = load i8*, i8** %_impzPtr
%zone12240 = bitcast i8* %tzone12239 to %mzone*

; let assign value to symbol mvp
%mvpPtr = alloca float*
%tzone12242 = load i8*, i8** %_impzPtr
%zone12243 = bitcast i8* %tzone12242 to %mzone*

; let assign value to symbol tmp
%tmpPtr = alloca float*
%tzone12245 = load i8*, i8** %_impzPtr
%zone12246 = bitcast i8* %tzone12245 to %mzone*

; let assign value to symbol vec
%vecPtr = alloca float*
%val12201 = load float*, float** %pt_inPtr
; pointer ref
%val12202 = getelementptr float, float* %val12201, i64 0
%val12203 = load float, float* %val12202

; let value assignment
%x = select i1 true, float %val12203, float %val12203
store float %x, float* %xPtr

%val12206 = load float*, float** %pt_inPtr
; pointer ref
%val12207 = getelementptr float, float* %val12206, i64 1
%val12208 = load float, float* %val12207

; let value assignment
%y = select i1 true, float %val12208, float %val12208
store float %y, float* %yPtr

%val12211 = load float*, float** %pt_inPtr
; pointer ref
%val12212 = getelementptr float, float* %val12211, i64 2
%val12213 = load float, float* %val12212

; let value assignment
%z = select i1 true, float %val12213, float %val12213
store float %z, float* %zPtr

%val12216 = load i32, i32* @xtm_render_x
%res12217 = call ccc float @i32tof(i32 %val12216)

; let value assignment
%vp_x = select i1 true, float %res12217, float %res12217
store float %vp_x, float* %vp_xPtr

%val12220 = load i32, i32* @xtm_render_y
%res12221 = call ccc float @i32tof(i32 %val12220)

; let value assignment
%vp_y = select i1 true, float %res12221, float %res12221
store float %vp_y, float* %vp_yPtr

%val12224 = load i32, i32* @xtm_render_w
%res12225 = call ccc float @i32tof(i32 %val12224)

; let value assignment
%vp_w = select i1 true, float %res12225, float %res12225
store float %vp_w, float* %vp_wPtr

%val12228 = load i32, i32* @xtm_render_h
%res12229 = call ccc float @i32tof(i32 %val12228)

; let value assignment
%vp_h = select i1 true, float %res12229, float %res12229
store float %vp_h, float* %vp_hPtr

%val12232 = load float, float* @xtm_render_near

; let value assignment
%vp_n = select i1 true, float %val12232, float %val12232
store float %vp_n, float* %vp_nPtr

%val12235 = load float, float* @xtm_render_far

; let value assignment
%vp_f = select i1 true, float %val12235, float %val12235
store float %vp_f, float* %vp_fPtr

%dat12238 = alloca float, i64 16, align 16

; let value assignment
%mvp = select i1 true, float* %dat12238, float* %dat12238
store float* %mvp, float** %mvpPtr

%dat12241 = alloca float, i64 16, align 16

; let value assignment
%tmp = select i1 true, float* %dat12241, float* %dat12241
store float* %tmp, float** %tmpPtr

%dat12244 = alloca float, i64 4, align 16

; let value assignment
%vec = select i1 true, float* %dat12244, float* %dat12244
store float* %vec, float** %vecPtr

%val12247 = load float*, float** %modelPtr
%val12248 = load float*, float** %viewPtr
%val12249 = load float*, float** %tmpPtr
%res12250 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val12247, float* %val12248, float* %val12249)
%val12251 = load float*, float** %tmpPtr
%val12252 = load float*, float** %projectionPtr
%val12253 = load float*, float** %mvpPtr
%res12254 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val12251, float* %val12252, float* %val12253)
%val12255 = load float*, float** %pt_inPtr
%val12256 = load float*, float** %mvpPtr
%val12257 = load float*, float** %vecPtr
%res12258 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd(float* %val12255, i64 1, i64 4, float* %val12256, i64 4, i64 4, float* %val12257)
%val12260 = load float*, float** %vecPtr
; pointer ref
%val12261 = getelementptr float, float* %val12260, i64 3
%val12262 = load float, float* %val12261
%cmp12263 = fcmp une float %val12262, 0x0
br i1 %cmp12263, label %then12259, label %else12259

then12259:
%val12264 = load float*, float** %vecPtr
%val12265 = load float*, float** %vecPtr
; pointer ref
%val12266 = getelementptr float, float* %val12265, i64 3
%val12267 = load float, float* %val12266
%val12268 = fdiv float 0x3ff0000000000000, %val12267
%val12269 = load float*, float** %pt_outPtr
call fastcc void @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd(float* %val12264, float %val12268, i64 4, float* %val12269)
br label %ifcont12259

else12259:
br label %ifcont12259

ifcont12259:
%val12271 = load float*, float** %pt_outPtr
%val12272 = load float*, float** %pt_outPtr
; pointer ref
%val12273 = getelementptr float, float* %val12272, i64 0
%val12274 = load float, float* %val12273
%val12275 = fadd float 0x3ff0000000000000, %val12274
%val12276 = fmul float %val12275, 0x3fe0000000000000
%val12277 = load float, float* %vp_wPtr
%val12278 = fmul float %val12276, %val12277
; set pointer
%val12279 = getelementptr float, float* %val12271, i64 0
store float %val12278, float* %val12279
%val12280 = load float*, float** %pt_outPtr
%val12281 = load float*, float** %pt_outPtr
; pointer ref
%val12282 = getelementptr float, float* %val12281, i64 1
%val12283 = load float, float* %val12282
%val12284 = fadd float 0x3ff0000000000000, %val12283
%val12285 = fmul float %val12284, 0x3fe0000000000000
%val12286 = load float, float* %vp_hPtr
%val12287 = fmul float %val12285, %val12286
; set pointer
%val12288 = getelementptr float, float* %val12280, i64 1
store float %val12287, float* %val12288
%val12289 = load float*, float** %pt_outPtr
%val12290 = load float*, float** %pt_outPtr
; pointer ref
%val12291 = getelementptr float, float* %val12290, i64 2
%val12292 = load float, float* %val12291
%val12293 = load float, float* %vp_fPtr
%val12294 = load float, float* %vp_nPtr
%val12295 = fsub float %val12293, %val12294
%val12296 = fmul float %val12292, %val12295
%val12297 = load float, float* %vp_nPtr
%val12298 = fadd float %val12296, %val12297
; set pointer
%val12299 = getelementptr float, float* %val12289, i64 2
store float %val12298, float* %val12299
ret void
}
@gsxtmgraphics-pipeline492 = hidden constant [127 x i8] c"xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** @xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12320 = load i8*, i8** %_impzPtr
%zone12321 = bitcast i8* %tzone12320 to %mzone*

; let assign value to symbol xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0
%dat_xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone12321, i64 8)
%xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr = bitcast i8* %dat_xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 to { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}***
%tzone12301 = load i8*, i8** %_impzPtr
%zone12302 = bitcast i8* %tzone12301 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12302)
; malloc closure structure
%clsptr12303 = call i8* @llvm_zone_malloc(%mzone* %zone12302, i64 24)
%closure12304 = bitcast i8* %clsptr12303 to { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}*

; malloc environment structure
%envptr12305 = call i8* @llvm_zone_malloc(%mzone* %zone12302, i64 8)
%environment12306 = bitcast i8* %envptr12305 to {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}***}*

; malloc closure address table
%addytable12307 = call %clsvar* @new_address_table()
%var12308 = bitcast [74 x i8]* @gsxtmgraphics-pipeline490 to i8*
%var12309 = bitcast [71 x i8]* @gsxtmgraphics-pipeline491 to i8*
%addytable12310 = call %clsvar* @add_address_table(%mzone* %zone12302, i8* %var12308, i32 0, i8* %var12309, i32 3, %clsvar* %addytable12307)
%address-table12311 = bitcast %clsvar* %addytable12310 to i8*

; insert table, function and environment into closure struct
%closure.table12314 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure12304, i32 0, i32 0
store i8* %address-table12311, i8** %closure.table12314
%closure.env12315 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure12304, i32 0, i32 1
store i8* %envptr12305, i8** %closure.env12315
%closure.func12316 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure12304, i32 0, i32 2
store void (i8*, i8*, float*, float*, float*, float*, float*)* @xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0__12199, void (i8*, i8*, float*, float*, float*, float*, float*)** %closure.func12316
%closure_size12317 = call i64 @llvm_zone_mark_size(%mzone* %zone12302)
call void @llvm_zone_ptr_set_size(i8* %clsptr12303, i64 %closure_size12317)
%wrapper_ptr12318 = call i8* @llvm_zone_malloc(%mzone* %zone12302, i64 8)
%closure_wrapper12319 = bitcast i8* %wrapper_ptr12318 to { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure12304, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** %closure_wrapper12319

; let value assignment
%xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** %closure_wrapper12319, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** %closure_wrapper12319
store { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** %xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}*** %xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr

; add data to environment
; don't need to alloc for env var xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0
%tmp_envptr12313 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}***}* %environment12306, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}*** %xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}**** %tmp_envptr12313


%val12322 = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}*** %xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** %val12322
}


@xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** @xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4)
ret void
}


define dllexport ccc void @xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_native(float* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4)
ret void
}


define dllexport ccc i8*  @xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12323 = bitcast [127 x i8]* @gsxtmgraphics-pipeline492 to i8*
call i32 (i8*, ...) @printf(i8* %var12323)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12324 = bitcast [127 x i8]* @gsxtmgraphics-pipeline492 to i8*
call i32 (i8*, ...) @printf(i8* %var12324)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var12325 = bitcast [127 x i8]* @gsxtmgraphics-pipeline492 to i8*
call i32 (i8*, ...) @printf(i8* %var12325)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var12326 = bitcast [127 x i8]* @gsxtmgraphics-pipeline492 to i8*
call i32 (i8*, ...) @printf(i8* %var12326)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var12327 = bitcast [127 x i8]* @gsxtmgraphics-pipeline492 to i8*
call i32 (i8*, ...) @printf(i8* %var12327)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, float*, float*, float*}*
%arg_p_0 = getelementptr {float*, float*, float*, float*, float*}, {float*, float*, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, float*, float*, float*}, {float*, float*, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, float*, float*, float*}, {float*, float*, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {float*, float*, float*, float*, float*}, {float*, float*, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {float*, float*, float*, float*, float*}, {float*, float*, float*, float*, float*}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_project_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline493 = hidden constant [76 x i8] c"xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0\00"
define dllexport fastcc void @xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0__12328(i8* %_impz,i8* %_impenv, float* %pt_in, float* %pt_out, float* %model, float* %view, float* %projection) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12329 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}***}*
%xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}**** %xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr_

; setup arguments
%pt_inPtr = alloca float*
store float* %pt_in, float** %pt_inPtr
%pt_outPtr = alloca float*
store float* %pt_out, float** %pt_outPtr
%modelPtr = alloca float*
store float* %model, float** %modelPtr
%viewPtr = alloca float*
store float* %view, float** %viewPtr
%projectionPtr = alloca float*
store float* %projection, float** %projectionPtr


%tzone12333 = load i8*, i8** %_impzPtr
%zone12334 = bitcast i8* %tzone12333 to %mzone*

; let assign value to symbol x
%xPtr = alloca float
%tzone12338 = load i8*, i8** %_impzPtr
%zone12339 = bitcast i8* %tzone12338 to %mzone*

; let assign value to symbol y
%yPtr = alloca float
%tzone12343 = load i8*, i8** %_impzPtr
%zone12344 = bitcast i8* %tzone12343 to %mzone*

; let assign value to symbol z
%zPtr = alloca float
%tzone12347 = load i8*, i8** %_impzPtr
%zone12348 = bitcast i8* %tzone12347 to %mzone*

; let assign value to symbol vp_x
%vp_xPtr = alloca float
%tzone12351 = load i8*, i8** %_impzPtr
%zone12352 = bitcast i8* %tzone12351 to %mzone*

; let assign value to symbol vp_y
%vp_yPtr = alloca float
%tzone12355 = load i8*, i8** %_impzPtr
%zone12356 = bitcast i8* %tzone12355 to %mzone*

; let assign value to symbol vp_w
%vp_wPtr = alloca float
%tzone12359 = load i8*, i8** %_impzPtr
%zone12360 = bitcast i8* %tzone12359 to %mzone*

; let assign value to symbol vp_h
%vp_hPtr = alloca float
%tzone12362 = load i8*, i8** %_impzPtr
%zone12363 = bitcast i8* %tzone12362 to %mzone*

; let assign value to symbol tmp
%tmpPtr = alloca float*
%tzone12365 = load i8*, i8** %_impzPtr
%zone12366 = bitcast i8* %tzone12365 to %mzone*

; let assign value to symbol tmp2
%tmp2Ptr = alloca float*
%tzone12368 = load i8*, i8** %_impzPtr
%zone12369 = bitcast i8* %tzone12368 to %mzone*

; let assign value to symbol imvp
%imvpPtr = alloca float*
%tzone12371 = load i8*, i8** %_impzPtr
%zone12372 = bitcast i8* %tzone12371 to %mzone*

; let assign value to symbol vec
%vecPtr = alloca float*
%tzone12374 = load i8*, i8** %_impzPtr
%zone12375 = bitcast i8* %tzone12374 to %mzone*

; let assign value to symbol out
%outPtr = alloca float*
%val12330 = load float*, float** %pt_inPtr
; pointer ref
%val12331 = getelementptr float, float* %val12330, i64 0
%val12332 = load float, float* %val12331

; let value assignment
%x = select i1 true, float %val12332, float %val12332
store float %x, float* %xPtr

%val12335 = load float*, float** %pt_inPtr
; pointer ref
%val12336 = getelementptr float, float* %val12335, i64 1
%val12337 = load float, float* %val12336

; let value assignment
%y = select i1 true, float %val12337, float %val12337
store float %y, float* %yPtr

%val12340 = load float*, float** %pt_inPtr
; pointer ref
%val12341 = getelementptr float, float* %val12340, i64 2
%val12342 = load float, float* %val12341

; let value assignment
%z = select i1 true, float %val12342, float %val12342
store float %z, float* %zPtr

%val12345 = load i32, i32* @xtm_render_x
%res12346 = call ccc float @i32tof(i32 %val12345)

; let value assignment
%vp_x = select i1 true, float %res12346, float %res12346
store float %vp_x, float* %vp_xPtr

%val12349 = load i32, i32* @xtm_render_y
%res12350 = call ccc float @i32tof(i32 %val12349)

; let value assignment
%vp_y = select i1 true, float %res12350, float %res12350
store float %vp_y, float* %vp_yPtr

%val12353 = load i32, i32* @xtm_render_w
%res12354 = call ccc float @i32tof(i32 %val12353)

; let value assignment
%vp_w = select i1 true, float %res12354, float %res12354
store float %vp_w, float* %vp_wPtr

%val12357 = load i32, i32* @xtm_render_h
%res12358 = call ccc float @i32tof(i32 %val12357)

; let value assignment
%vp_h = select i1 true, float %res12358, float %res12358
store float %vp_h, float* %vp_hPtr

%dat12361 = alloca float, i64 16, align 16

; let value assignment
%tmp = select i1 true, float* %dat12361, float* %dat12361
store float* %tmp, float** %tmpPtr

%dat12364 = alloca float, i64 16, align 16

; let value assignment
%tmp2 = select i1 true, float* %dat12364, float* %dat12364
store float* %tmp2, float** %tmp2Ptr

%dat12367 = alloca float, i64 16, align 16

; let value assignment
%imvp = select i1 true, float* %dat12367, float* %dat12367
store float* %imvp, float** %imvpPtr

%dat12370 = alloca float, i64 4, align 16

; let value assignment
%vec = select i1 true, float* %dat12370, float* %dat12370
store float* %vec, float** %vecPtr

%dat12373 = alloca float, i64 4, align 16

; let value assignment
%out = select i1 true, float* %dat12373, float* %dat12373
store float* %out, float** %outPtr

%val12376 = load float*, float** %modelPtr
%val12377 = load float*, float** %viewPtr
%val12378 = load float*, float** %tmpPtr
%res12379 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val12376, float* %val12377, float* %val12378)
%val12380 = load float*, float** %tmpPtr
%val12381 = load float*, float** %projectionPtr
%val12382 = load float*, float** %imvpPtr
%res12383 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %val12380, float* %val12381, float* %val12382)
%val12384 = load float*, float** %imvpPtr
call fastcc void @invert_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %val12384)
%val12386 = load float*, float** %vecPtr
%val12387 = load float, float* %xPtr
%val12388 = load float, float* %vp_wPtr
%val12389 = fdiv float %val12387, %val12388
%val12390 = fmul float %val12389, 0x4000000000000000
%val12391 = fsub float %val12390, 0x3ff0000000000000
; set pointer
%val12392 = getelementptr float, float* %val12386, i64 0
store float %val12391, float* %val12392
%val12393 = load float*, float** %vecPtr
%val12394 = load float, float* %yPtr
%val12395 = load float, float* %vp_hPtr
%val12396 = fdiv float %val12394, %val12395
%val12397 = fmul float %val12396, 0x4000000000000000
%val12398 = fsub float %val12397, 0x3ff0000000000000
; set pointer
%val12399 = getelementptr float, float* %val12393, i64 1
store float %val12398, float* %val12399
%val12400 = load float*, float** %vecPtr
%val12401 = load float, float* %zPtr
%val12402 = fmul float 0x4000000000000000, %val12401
%val12403 = fsub float %val12402, 0x3ff0000000000000
; set pointer
%val12404 = getelementptr float, float* %val12400, i64 2
store float %val12403, float* %val12404
%val12405 = load float*, float** %vecPtr
; set pointer
%val12406 = getelementptr float, float* %val12405, i64 3
store float 0x3ff0000000000000, float* %val12406
%val12407 = load float*, float** %vecPtr
%val12408 = load float*, float** %imvpPtr
%val12409 = load float*, float** %outPtr
%res12410 = call fastcc float* @mmmul_adhoc_W2Zsb2F0KixmbG9hdCosaTY0LGk2NCxmbG9hdCosaTY0LGk2NCxmbG9hdCpd(float* %val12407, i64 1, i64 4, float* %val12408, i64 4, i64 4, float* %val12409)
%val12412 = load float*, float** %outPtr
; pointer ref
%val12413 = getelementptr float, float* %val12412, i64 3
%val12414 = load float, float* %val12413
%cmp12415 = fcmp ueq float %val12414, 0x0
br i1 %cmp12415, label %then12411, label %else12411

then12411:
ret void

else12411:
%val12417 = load float*, float** %outPtr
%val12418 = load float*, float** %outPtr
; pointer ref
%val12419 = getelementptr float, float* %val12418, i64 3
%val12420 = load float, float* %val12419
%val12421 = fdiv float 0x3ff0000000000000, %val12420
%val12422 = load float*, float** %pt_outPtr
call fastcc void @vsmul_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGk2NCxmbG9hdCpd(float* %val12417, float %val12421, i64 4, float* %val12422)
ret void
}
@gsxtmgraphics-pipeline494 = hidden constant [129 x i8] c"xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** @xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12444 = load i8*, i8** %_impzPtr
%zone12445 = bitcast i8* %tzone12444 to %mzone*

; let assign value to symbol xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0
%dat_xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone12445, i64 8)
%xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr = bitcast i8* %dat_xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 to { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}***
%tzone12425 = load i8*, i8** %_impzPtr
%zone12426 = bitcast i8* %tzone12425 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12426)
; malloc closure structure
%clsptr12427 = call i8* @llvm_zone_malloc(%mzone* %zone12426, i64 24)
%closure12428 = bitcast i8* %clsptr12427 to { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}*

; malloc environment structure
%envptr12429 = call i8* @llvm_zone_malloc(%mzone* %zone12426, i64 8)
%environment12430 = bitcast i8* %envptr12429 to {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}***}*

; malloc closure address table
%addytable12431 = call %clsvar* @new_address_table()
%var12432 = bitcast [76 x i8]* @gsxtmgraphics-pipeline493 to i8*
%var12433 = bitcast [71 x i8]* @gsxtmgraphics-pipeline491 to i8*
%addytable12434 = call %clsvar* @add_address_table(%mzone* %zone12426, i8* %var12432, i32 0, i8* %var12433, i32 3, %clsvar* %addytable12431)
%address-table12435 = bitcast %clsvar* %addytable12434 to i8*

; insert table, function and environment into closure struct
%closure.table12438 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure12428, i32 0, i32 0
store i8* %address-table12435, i8** %closure.table12438
%closure.env12439 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure12428, i32 0, i32 1
store i8* %envptr12429, i8** %closure.env12439
%closure.func12440 = getelementptr { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure12428, i32 0, i32 2
store void (i8*, i8*, float*, float*, float*, float*, float*)* @xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0__12328, void (i8*, i8*, float*, float*, float*, float*, float*)** %closure.func12440
%closure_size12441 = call i64 @llvm_zone_mark_size(%mzone* %zone12426)
call void @llvm_zone_ptr_set_size(i8* %clsptr12427, i64 %closure_size12441)
%wrapper_ptr12442 = call i8* @llvm_zone_malloc(%mzone* %zone12426, i64 8)
%closure_wrapper12443 = bitcast i8* %wrapper_ptr12442 to { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure12428, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** %closure_wrapper12443

; let value assignment
%xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** %closure_wrapper12443, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** %closure_wrapper12443
store { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** %xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0, { i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}*** %xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr

; add data to environment
; don't need to alloc for env var xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0
%tmp_envptr12437 = getelementptr {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}***}* %environment12430, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}*** %xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}**** %tmp_envptr12437


%val12446 = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}*** %xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** %val12446
}


@xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** @xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(float* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4)
ret void
}


define dllexport ccc void @xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_native(float* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4)
ret void
}


define dllexport ccc i8*  @xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12447 = bitcast [129 x i8]* @gsxtmgraphics-pipeline494 to i8*
call i32 (i8*, ...) @printf(i8* %var12447)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12448 = bitcast [129 x i8]* @gsxtmgraphics-pipeline494 to i8*
call i32 (i8*, ...) @printf(i8* %var12448)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var12449 = bitcast [129 x i8]* @gsxtmgraphics-pipeline494 to i8*
call i32 (i8*, ...) @printf(i8* %var12449)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var12450 = bitcast [129 x i8]* @gsxtmgraphics-pipeline494 to i8*
call i32 (i8*, ...) @printf(i8* %var12450)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var12451 = bitcast [129 x i8]* @gsxtmgraphics-pipeline494 to i8*
call i32 (i8*, ...) @printf(i8* %var12451)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, float*, float*, float*, float*}*
%arg_p_0 = getelementptr {float*, float*, float*, float*, float*}, {float*, float*, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, float*, float*, float*, float*}, {float*, float*, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {float*, float*, float*, float*, float*}, {float*, float*, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {float*, float*, float*, float*, float*}, {float*, float*, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {float*, float*, float*, float*, float*}, {float*, float*, float*, float*, float*}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_unproject_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, float*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float*, float*, float*, float*, float*)*,  void (i8*, i8*, float*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline495 = hidden constant [13 x i8] c"Light-Shader\00"
@gsxtmgraphics-pipeline496 = hidden constant [32 x i8] c"Error initializing light shader\00"
@gsxtmgraphics-pipeline497 = hidden constant [55 x i8] c"xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0\00"
@gsxtmgraphics-pipeline498 = hidden constant [41 x i8] c"{i8*, i8*, void (i8*, i8*, i8*, i8*)*}**\00"
define dllexport fastcc void @xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0__12452(i8* %_impz,i8* %_impenv, i8* %a1, i8* %a2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12453 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}*
%xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**** %xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr_

; setup arguments
%a1Ptr = alloca i8*
store i8* %a1, i8** %a1Ptr
%a2Ptr = alloca i8*
store i8* %a2, i8** %a2Ptr


; do set!
%var12454 = bitcast [13 x i8]* @gsxtmgraphics-pipeline495 to i8*
%res12455 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %var12454)
%val12456 = load i8*, i8** %a1Ptr
%res12457 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val12456)
%val12458 = load i8*, i8** %a2Ptr
%res12459 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val12458)
%res12460 = call fastcc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res12455, %String* %res12457, %String* %res12459)
store %ShaderProgram* %res12460, %ShaderProgram** @xtm_render_light_shader
%var12461 = bitcast [32 x i8]* @gsxtmgraphics-pipeline496 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var12461)
ret void
}
@gsxtmgraphics-pipeline499 = hidden constant [108 x i8] c"xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** @xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12483 = load i8*, i8** %_impzPtr
%zone12484 = bitcast i8* %tzone12483 to %mzone*

; let assign value to symbol xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0
%dat_xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone12484, i64 8)
%xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr = bitcast i8* %dat_xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 to { i8*, i8*, void (i8*, i8*, i8*, i8*)*}***
%tzone12464 = load i8*, i8** %_impzPtr
%zone12465 = bitcast i8* %tzone12464 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12465)
; malloc closure structure
%clsptr12466 = call i8* @llvm_zone_malloc(%mzone* %zone12465, i64 24)
%closure12467 = bitcast i8* %clsptr12466 to { i8*, i8*, void (i8*, i8*, i8*, i8*)*}*

; malloc environment structure
%envptr12468 = call i8* @llvm_zone_malloc(%mzone* %zone12465, i64 8)
%environment12469 = bitcast i8* %envptr12468 to {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable12470 = call %clsvar* @new_address_table()
%var12471 = bitcast [55 x i8]* @gsxtmgraphics-pipeline497 to i8*
%var12472 = bitcast [41 x i8]* @gsxtmgraphics-pipeline498 to i8*
%addytable12473 = call %clsvar* @add_address_table(%mzone* %zone12465, i8* %var12471, i32 0, i8* %var12472, i32 3, %clsvar* %addytable12470)
%address-table12474 = bitcast %clsvar* %addytable12473 to i8*

; insert table, function and environment into closure struct
%closure.table12477 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12467, i32 0, i32 0
store i8* %address-table12474, i8** %closure.table12477
%closure.env12478 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12467, i32 0, i32 1
store i8* %envptr12468, i8** %closure.env12478
%closure.func12479 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12467, i32 0, i32 2
store void (i8*, i8*, i8*, i8*)* @xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0__12452, void (i8*, i8*, i8*, i8*)** %closure.func12479
%closure_size12480 = call i64 @llvm_zone_mark_size(%mzone* %zone12465)
call void @llvm_zone_ptr_set_size(i8* %clsptr12466, i64 %closure_size12480)
%wrapper_ptr12481 = call i8* @llvm_zone_malloc(%mzone* %zone12465, i64 8)
%closure_wrapper12482 = bitcast i8* %wrapper_ptr12481 to { i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12467, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_wrapper12482

; let value assignment
%xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_wrapper12482, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_wrapper12482
store { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}*** %xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0
%tmp_envptr12476 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}* %environment12469, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*** %xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**** %tmp_envptr12476


%val12485 = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*** %xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %val12485
}


@xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** @xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0(i8* %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
ret void
}


define dllexport ccc void @xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_native(i8* %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
ret void
}


define dllexport ccc i8*  @xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12486 = bitcast [108 x i8]* @gsxtmgraphics-pipeline499 to i8*
call i32 (i8*, ...) @printf(i8* %var12486)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12487 = bitcast [108 x i8]* @gsxtmgraphics-pipeline499 to i8*
call i32 (i8*, ...) @printf(i8* %var12487)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i8*}*
%arg_p_0 = getelementptr {i8*, i8*}, {i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i8*}, {i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline500 = hidden constant [14 x i8] c"Simple-Shader\00"
@gsxtmgraphics-pipeline501 = hidden constant [33 x i8] c"Error initializing simple shader\00"
@gsxtmgraphics-pipeline502 = hidden constant [56 x i8] c"xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0\00"
define dllexport fastcc void @xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0__12488(i8* %_impz,i8* %_impenv, i8* %v, i8* %f) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12489 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}*
%xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**** %xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr_

; setup arguments
%vPtr = alloca i8*
store i8* %v, i8** %vPtr
%fPtr = alloca i8*
store i8* %f, i8** %fPtr


; do set!
%var12490 = bitcast [14 x i8]* @gsxtmgraphics-pipeline500 to i8*
%res12491 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %var12490)
%val12492 = load i8*, i8** %vPtr
%res12493 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val12492)
%val12494 = load i8*, i8** %fPtr
%res12495 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val12494)
%res12496 = call fastcc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res12491, %String* %res12493, %String* %res12495)
store %ShaderProgram* %res12496, %ShaderProgram** @xtm_render_simple_shader
%var12497 = bitcast [33 x i8]* @gsxtmgraphics-pipeline501 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var12497)
ret void
}
@gsxtmgraphics-pipeline503 = hidden constant [109 x i8] c"xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** @xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12519 = load i8*, i8** %_impzPtr
%zone12520 = bitcast i8* %tzone12519 to %mzone*

; let assign value to symbol xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0
%dat_xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone12520, i64 8)
%xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr = bitcast i8* %dat_xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 to { i8*, i8*, void (i8*, i8*, i8*, i8*)*}***
%tzone12500 = load i8*, i8** %_impzPtr
%zone12501 = bitcast i8* %tzone12500 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12501)
; malloc closure structure
%clsptr12502 = call i8* @llvm_zone_malloc(%mzone* %zone12501, i64 24)
%closure12503 = bitcast i8* %clsptr12502 to { i8*, i8*, void (i8*, i8*, i8*, i8*)*}*

; malloc environment structure
%envptr12504 = call i8* @llvm_zone_malloc(%mzone* %zone12501, i64 8)
%environment12505 = bitcast i8* %envptr12504 to {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable12506 = call %clsvar* @new_address_table()
%var12507 = bitcast [56 x i8]* @gsxtmgraphics-pipeline502 to i8*
%var12508 = bitcast [41 x i8]* @gsxtmgraphics-pipeline498 to i8*
%addytable12509 = call %clsvar* @add_address_table(%mzone* %zone12501, i8* %var12507, i32 0, i8* %var12508, i32 3, %clsvar* %addytable12506)
%address-table12510 = bitcast %clsvar* %addytable12509 to i8*

; insert table, function and environment into closure struct
%closure.table12513 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12503, i32 0, i32 0
store i8* %address-table12510, i8** %closure.table12513
%closure.env12514 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12503, i32 0, i32 1
store i8* %envptr12504, i8** %closure.env12514
%closure.func12515 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12503, i32 0, i32 2
store void (i8*, i8*, i8*, i8*)* @xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0__12488, void (i8*, i8*, i8*, i8*)** %closure.func12515
%closure_size12516 = call i64 @llvm_zone_mark_size(%mzone* %zone12501)
call void @llvm_zone_ptr_set_size(i8* %clsptr12502, i64 %closure_size12516)
%wrapper_ptr12517 = call i8* @llvm_zone_malloc(%mzone* %zone12501, i64 8)
%closure_wrapper12518 = bitcast i8* %wrapper_ptr12517 to { i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12503, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_wrapper12518

; let value assignment
%xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_wrapper12518, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_wrapper12518
store { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}*** %xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0
%tmp_envptr12512 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}* %environment12505, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*** %xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**** %tmp_envptr12512


%val12521 = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*** %xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %val12521
}


@xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** @xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0(i8* %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
ret void
}


define dllexport ccc void @xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_native(i8* %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
ret void
}


define dllexport ccc i8*  @xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12522 = bitcast [109 x i8]* @gsxtmgraphics-pipeline503 to i8*
call i32 (i8*, ...) @printf(i8* %var12522)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12523 = bitcast [109 x i8]* @gsxtmgraphics-pipeline503 to i8*
call i32 (i8*, ...) @printf(i8* %var12523)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i8*}*
%arg_p_0 = getelementptr {i8*, i8*}, {i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i8*}, {i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline504 = hidden constant [19 x i8] c"Simple-Bone-Shader\00"
@gsxtmgraphics-pipeline505 = hidden constant [38 x i8] c"Error initializing simple bone shader\00"
@gsxtmgraphics-pipeline506 = hidden constant [61 x i8] c"xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0\00"
define dllexport fastcc void @xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0__12524(i8* %_impz,i8* %_impenv, i8* %v, i8* %f) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12525 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}*
%xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**** %xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr_

; setup arguments
%vPtr = alloca i8*
store i8* %v, i8** %vPtr
%fPtr = alloca i8*
store i8* %f, i8** %fPtr


; do set!
%var12526 = bitcast [19 x i8]* @gsxtmgraphics-pipeline504 to i8*
%res12527 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %var12526)
%val12528 = load i8*, i8** %vPtr
%res12529 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val12528)
%val12530 = load i8*, i8** %fPtr
%res12531 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val12530)
%res12532 = call fastcc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res12527, %String* %res12529, %String* %res12531)
store %ShaderProgram* %res12532, %ShaderProgram** @xtm_render_simple_bone_shader
%var12533 = bitcast [38 x i8]* @gsxtmgraphics-pipeline505 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var12533)
ret void
}
@gsxtmgraphics-pipeline507 = hidden constant [114 x i8] c"xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** @xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12555 = load i8*, i8** %_impzPtr
%zone12556 = bitcast i8* %tzone12555 to %mzone*

; let assign value to symbol xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0
%dat_xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone12556, i64 8)
%xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr = bitcast i8* %dat_xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 to { i8*, i8*, void (i8*, i8*, i8*, i8*)*}***
%tzone12536 = load i8*, i8** %_impzPtr
%zone12537 = bitcast i8* %tzone12536 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12537)
; malloc closure structure
%clsptr12538 = call i8* @llvm_zone_malloc(%mzone* %zone12537, i64 24)
%closure12539 = bitcast i8* %clsptr12538 to { i8*, i8*, void (i8*, i8*, i8*, i8*)*}*

; malloc environment structure
%envptr12540 = call i8* @llvm_zone_malloc(%mzone* %zone12537, i64 8)
%environment12541 = bitcast i8* %envptr12540 to {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable12542 = call %clsvar* @new_address_table()
%var12543 = bitcast [61 x i8]* @gsxtmgraphics-pipeline506 to i8*
%var12544 = bitcast [41 x i8]* @gsxtmgraphics-pipeline498 to i8*
%addytable12545 = call %clsvar* @add_address_table(%mzone* %zone12537, i8* %var12543, i32 0, i8* %var12544, i32 3, %clsvar* %addytable12542)
%address-table12546 = bitcast %clsvar* %addytable12545 to i8*

; insert table, function and environment into closure struct
%closure.table12549 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12539, i32 0, i32 0
store i8* %address-table12546, i8** %closure.table12549
%closure.env12550 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12539, i32 0, i32 1
store i8* %envptr12540, i8** %closure.env12550
%closure.func12551 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12539, i32 0, i32 2
store void (i8*, i8*, i8*, i8*)* @xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0__12524, void (i8*, i8*, i8*, i8*)** %closure.func12551
%closure_size12552 = call i64 @llvm_zone_mark_size(%mzone* %zone12537)
call void @llvm_zone_ptr_set_size(i8* %clsptr12538, i64 %closure_size12552)
%wrapper_ptr12553 = call i8* @llvm_zone_malloc(%mzone* %zone12537, i64 8)
%closure_wrapper12554 = bitcast i8* %wrapper_ptr12553 to { i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12539, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_wrapper12554

; let value assignment
%xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_wrapper12554, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_wrapper12554
store { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}*** %xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0
%tmp_envptr12548 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}* %environment12541, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*** %xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**** %tmp_envptr12548


%val12557 = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*** %xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %val12557
}


@xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** @xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0(i8* %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
ret void
}


define dllexport ccc void @xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_native(i8* %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
ret void
}


define dllexport ccc i8*  @xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12558 = bitcast [114 x i8]* @gsxtmgraphics-pipeline507 to i8*
call i32 (i8*, ...) @printf(i8* %var12558)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12559 = bitcast [114 x i8]* @gsxtmgraphics-pipeline507 to i8*
call i32 (i8*, ...) @printf(i8* %var12559)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i8*}*
%arg_p_0 = getelementptr {i8*, i8*}, {i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i8*}, {i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_simple_bone_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline508 = hidden constant [12 x i8] c"QUAD-Shader\00"
@gsxtmgraphics-pipeline509 = hidden constant [31 x i8] c"Error initializing quad shader\00"
@gsxtmgraphics-pipeline510 = hidden constant [54 x i8] c"xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0\00"
define dllexport fastcc void @xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0__12560(i8* %_impz,i8* %_impenv, i8* %v, i8* %f) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12561 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}*
%xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**** %xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr_

; setup arguments
%vPtr = alloca i8*
store i8* %v, i8** %vPtr
%fPtr = alloca i8*
store i8* %f, i8** %fPtr


; do set!
%var12562 = bitcast [12 x i8]* @gsxtmgraphics-pipeline508 to i8*
%res12563 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %var12562)
%val12564 = load i8*, i8** %vPtr
%res12565 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val12564)
%val12566 = load i8*, i8** %fPtr
%res12567 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val12566)
%res12568 = call fastcc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res12563, %String* %res12565, %String* %res12567)
store %ShaderProgram* %res12568, %ShaderProgram** @xtm_render_quad_shader
%var12569 = bitcast [31 x i8]* @gsxtmgraphics-pipeline509 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var12569)
ret void
}
@gsxtmgraphics-pipeline511 = hidden constant [107 x i8] c"xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** @xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12591 = load i8*, i8** %_impzPtr
%zone12592 = bitcast i8* %tzone12591 to %mzone*

; let assign value to symbol xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0
%dat_xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone12592, i64 8)
%xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr = bitcast i8* %dat_xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 to { i8*, i8*, void (i8*, i8*, i8*, i8*)*}***
%tzone12572 = load i8*, i8** %_impzPtr
%zone12573 = bitcast i8* %tzone12572 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12573)
; malloc closure structure
%clsptr12574 = call i8* @llvm_zone_malloc(%mzone* %zone12573, i64 24)
%closure12575 = bitcast i8* %clsptr12574 to { i8*, i8*, void (i8*, i8*, i8*, i8*)*}*

; malloc environment structure
%envptr12576 = call i8* @llvm_zone_malloc(%mzone* %zone12573, i64 8)
%environment12577 = bitcast i8* %envptr12576 to {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable12578 = call %clsvar* @new_address_table()
%var12579 = bitcast [54 x i8]* @gsxtmgraphics-pipeline510 to i8*
%var12580 = bitcast [41 x i8]* @gsxtmgraphics-pipeline498 to i8*
%addytable12581 = call %clsvar* @add_address_table(%mzone* %zone12573, i8* %var12579, i32 0, i8* %var12580, i32 3, %clsvar* %addytable12578)
%address-table12582 = bitcast %clsvar* %addytable12581 to i8*

; insert table, function and environment into closure struct
%closure.table12585 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12575, i32 0, i32 0
store i8* %address-table12582, i8** %closure.table12585
%closure.env12586 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12575, i32 0, i32 1
store i8* %envptr12576, i8** %closure.env12586
%closure.func12587 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12575, i32 0, i32 2
store void (i8*, i8*, i8*, i8*)* @xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0__12560, void (i8*, i8*, i8*, i8*)** %closure.func12587
%closure_size12588 = call i64 @llvm_zone_mark_size(%mzone* %zone12573)
call void @llvm_zone_ptr_set_size(i8* %clsptr12574, i64 %closure_size12588)
%wrapper_ptr12589 = call i8* @llvm_zone_malloc(%mzone* %zone12573, i64 8)
%closure_wrapper12590 = bitcast i8* %wrapper_ptr12589 to { i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12575, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_wrapper12590

; let value assignment
%xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_wrapper12590, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_wrapper12590
store { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}*** %xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0
%tmp_envptr12584 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}* %environment12577, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*** %xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**** %tmp_envptr12584


%val12593 = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*** %xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %val12593
}


@xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** @xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0(i8* %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
ret void
}


define dllexport ccc void @xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_native(i8* %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
ret void
}


define dllexport ccc i8*  @xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12594 = bitcast [107 x i8]* @gsxtmgraphics-pipeline511 to i8*
call i32 (i8*, ...) @printf(i8* %var12594)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12595 = bitcast [107 x i8]* @gsxtmgraphics-pipeline511 to i8*
call i32 (i8*, ...) @printf(i8* %var12595)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i8*}*
%arg_p_0 = getelementptr {i8*, i8*}, {i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i8*}, {i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline512 = hidden constant [11 x i8] c"DOF-Shader\00"
@gsxtmgraphics-pipeline513 = hidden constant [41 x i8] c"Error initializing depth of field shader\00"
@gsxtmgraphics-pipeline514 = hidden constant [53 x i8] c"xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0\00"
define dllexport fastcc void @xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0__12596(i8* %_impz,i8* %_impenv, i8* %v, i8* %f) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12597 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}*
%xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**** %xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr_

; setup arguments
%vPtr = alloca i8*
store i8* %v, i8** %vPtr
%fPtr = alloca i8*
store i8* %f, i8** %fPtr


; do set!
%var12598 = bitcast [11 x i8]* @gsxtmgraphics-pipeline512 to i8*
%res12599 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %var12598)
%val12600 = load i8*, i8** %vPtr
%res12601 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val12600)
%val12602 = load i8*, i8** %fPtr
%res12603 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val12602)
%res12604 = call fastcc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res12599, %String* %res12601, %String* %res12603)
store %ShaderProgram* %res12604, %ShaderProgram** @xtm_render_dof_shader
%var12605 = bitcast [41 x i8]* @gsxtmgraphics-pipeline513 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var12605)
ret void
}
@gsxtmgraphics-pipeline515 = hidden constant [106 x i8] c"xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** @xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12627 = load i8*, i8** %_impzPtr
%zone12628 = bitcast i8* %tzone12627 to %mzone*

; let assign value to symbol xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0
%dat_xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone12628, i64 8)
%xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr = bitcast i8* %dat_xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 to { i8*, i8*, void (i8*, i8*, i8*, i8*)*}***
%tzone12608 = load i8*, i8** %_impzPtr
%zone12609 = bitcast i8* %tzone12608 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12609)
; malloc closure structure
%clsptr12610 = call i8* @llvm_zone_malloc(%mzone* %zone12609, i64 24)
%closure12611 = bitcast i8* %clsptr12610 to { i8*, i8*, void (i8*, i8*, i8*, i8*)*}*

; malloc environment structure
%envptr12612 = call i8* @llvm_zone_malloc(%mzone* %zone12609, i64 8)
%environment12613 = bitcast i8* %envptr12612 to {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable12614 = call %clsvar* @new_address_table()
%var12615 = bitcast [53 x i8]* @gsxtmgraphics-pipeline514 to i8*
%var12616 = bitcast [41 x i8]* @gsxtmgraphics-pipeline498 to i8*
%addytable12617 = call %clsvar* @add_address_table(%mzone* %zone12609, i8* %var12615, i32 0, i8* %var12616, i32 3, %clsvar* %addytable12614)
%address-table12618 = bitcast %clsvar* %addytable12617 to i8*

; insert table, function and environment into closure struct
%closure.table12621 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12611, i32 0, i32 0
store i8* %address-table12618, i8** %closure.table12621
%closure.env12622 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12611, i32 0, i32 1
store i8* %envptr12612, i8** %closure.env12622
%closure.func12623 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12611, i32 0, i32 2
store void (i8*, i8*, i8*, i8*)* @xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0__12596, void (i8*, i8*, i8*, i8*)** %closure.func12623
%closure_size12624 = call i64 @llvm_zone_mark_size(%mzone* %zone12609)
call void @llvm_zone_ptr_set_size(i8* %clsptr12610, i64 %closure_size12624)
%wrapper_ptr12625 = call i8* @llvm_zone_malloc(%mzone* %zone12609, i64 8)
%closure_wrapper12626 = bitcast i8* %wrapper_ptr12625 to { i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12611, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_wrapper12626

; let value assignment
%xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_wrapper12626, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_wrapper12626
store { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}*** %xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0
%tmp_envptr12620 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}* %environment12613, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*** %xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**** %tmp_envptr12620


%val12629 = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*** %xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %val12629
}


@xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** @xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0(i8* %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
ret void
}


define dllexport ccc void @xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_native(i8* %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
ret void
}


define dllexport ccc i8*  @xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12630 = bitcast [106 x i8]* @gsxtmgraphics-pipeline515 to i8*
call i32 (i8*, ...) @printf(i8* %var12630)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12631 = bitcast [106 x i8]* @gsxtmgraphics-pipeline515 to i8*
call i32 (i8*, ...) @printf(i8* %var12631)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i8*}*
%arg_p_0 = getelementptr {i8*, i8*}, {i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i8*}, {i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline516 = hidden constant [14 x i8] c"SkyBox-Shader\00"
@gsxtmgraphics-pipeline517 = hidden constant [33 x i8] c"Error initializing skybox shader\00"
@gsxtmgraphics-pipeline518 = hidden constant [56 x i8] c"xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0\00"
define dllexport fastcc void @xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0__12632(i8* %_impz,i8* %_impenv, i8* %v, i8* %f) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12633 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}*
%xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**** %xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr_

; setup arguments
%vPtr = alloca i8*
store i8* %v, i8** %vPtr
%fPtr = alloca i8*
store i8* %f, i8** %fPtr


; do set!
%var12634 = bitcast [14 x i8]* @gsxtmgraphics-pipeline516 to i8*
%res12635 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %var12634)
%val12636 = load i8*, i8** %vPtr
%res12637 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val12636)
%val12638 = load i8*, i8** %fPtr
%res12639 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val12638)
%res12640 = call fastcc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res12635, %String* %res12637, %String* %res12639)
store %ShaderProgram* %res12640, %ShaderProgram** @xtm_render_skybox_shader
%var12641 = bitcast [33 x i8]* @gsxtmgraphics-pipeline517 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var12641)
ret void
}
@gsxtmgraphics-pipeline519 = hidden constant [109 x i8] c"xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** @xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12663 = load i8*, i8** %_impzPtr
%zone12664 = bitcast i8* %tzone12663 to %mzone*

; let assign value to symbol xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0
%dat_xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone12664, i64 8)
%xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr = bitcast i8* %dat_xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 to { i8*, i8*, void (i8*, i8*, i8*, i8*)*}***
%tzone12644 = load i8*, i8** %_impzPtr
%zone12645 = bitcast i8* %tzone12644 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12645)
; malloc closure structure
%clsptr12646 = call i8* @llvm_zone_malloc(%mzone* %zone12645, i64 24)
%closure12647 = bitcast i8* %clsptr12646 to { i8*, i8*, void (i8*, i8*, i8*, i8*)*}*

; malloc environment structure
%envptr12648 = call i8* @llvm_zone_malloc(%mzone* %zone12645, i64 8)
%environment12649 = bitcast i8* %envptr12648 to {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable12650 = call %clsvar* @new_address_table()
%var12651 = bitcast [56 x i8]* @gsxtmgraphics-pipeline518 to i8*
%var12652 = bitcast [41 x i8]* @gsxtmgraphics-pipeline498 to i8*
%addytable12653 = call %clsvar* @add_address_table(%mzone* %zone12645, i8* %var12651, i32 0, i8* %var12652, i32 3, %clsvar* %addytable12650)
%address-table12654 = bitcast %clsvar* %addytable12653 to i8*

; insert table, function and environment into closure struct
%closure.table12657 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12647, i32 0, i32 0
store i8* %address-table12654, i8** %closure.table12657
%closure.env12658 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12647, i32 0, i32 1
store i8* %envptr12648, i8** %closure.env12658
%closure.func12659 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12647, i32 0, i32 2
store void (i8*, i8*, i8*, i8*)* @xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0__12632, void (i8*, i8*, i8*, i8*)** %closure.func12659
%closure_size12660 = call i64 @llvm_zone_mark_size(%mzone* %zone12645)
call void @llvm_zone_ptr_set_size(i8* %clsptr12646, i64 %closure_size12660)
%wrapper_ptr12661 = call i8* @llvm_zone_malloc(%mzone* %zone12645, i64 8)
%closure_wrapper12662 = bitcast i8* %wrapper_ptr12661 to { i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure12647, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_wrapper12662

; let value assignment
%xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_wrapper12662, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_wrapper12662
store { i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0, { i8*, i8*, void (i8*, i8*, i8*, i8*)*}*** %xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0
%tmp_envptr12656 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i8*)*}***}* %environment12649, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*** %xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**** %tmp_envptr12656


%val12665 = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*** %xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %val12665
}


@xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** @xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0(i8* %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
ret void
}


define dllexport ccc void @xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_native(i8* %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
ret void
}


define dllexport ccc i8*  @xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12666 = bitcast [109 x i8]* @gsxtmgraphics-pipeline519 to i8*
call i32 (i8*, ...) @printf(i8* %var12666)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12667 = bitcast [109 x i8]* @gsxtmgraphics-pipeline519 to i8*
call i32 (i8*, ...) @printf(i8* %var12667)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i8*}*
%arg_p_0 = getelementptr {i8*, i8*}, {i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i8*}, {i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i8*)*,  void (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@DRAW_QUAD_VAO = dllexport global %VAO* zeroinitializer
@DRAW_QUAD_VBO = dllexport global %VBO* zeroinitializer
@gsxtmgraphics-pipeline520 = hidden constant [23 x i8] c"Error drawing QUAD vao\00"
@gsxtmgraphics-pipeline521 = hidden constant [55 x i8] c"draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ\00"
define dllexport fastcc void @draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ__12668(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, float* %uvmat) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12669 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}***}*
%draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}***}* %impenv, i32 0, i32 0
%draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}**** %draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQPtr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%uvmatPtr = alloca float*
store float* %uvmat, float** %uvmatPtr


%val12670 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val12671 = load float*, float** %uvmatPtr
call fastcc void @shader_update_uvwmatrix_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ(%ShaderProgram* %val12670, float* %val12671)
%val12673 = load %VAO*, %VAO** @DRAW_QUAD_VAO
%val12674 = load i32, i32* @GL_TRIANGLE_STRIP
call fastcc void @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0(%VAO* %val12673, i32 %val12674, i32 0, i32 4)
%var12676 = bitcast [23 x i8]* @gsxtmgraphics-pipeline520 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var12676)
ret void
}
@gsxtmgraphics-pipeline522 = hidden constant [108 x i8] c"draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** @draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12698 = load i8*, i8** %_impzPtr
%zone12699 = bitcast i8* %tzone12698 to %mzone*

; let assign value to symbol draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ
%dat_draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone12699, i64 8)
%draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQPtr = bitcast i8* %dat_draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}***
%tzone12679 = load i8*, i8** %_impzPtr
%zone12680 = bitcast i8* %tzone12679 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12680)
; malloc closure structure
%clsptr12681 = call i8* @llvm_zone_malloc(%mzone* %zone12680, i64 24)
%closure12682 = bitcast i8* %clsptr12681 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}*

; malloc environment structure
%envptr12683 = call i8* @llvm_zone_malloc(%mzone* %zone12680, i64 8)
%environment12684 = bitcast i8* %envptr12683 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}***}*

; malloc closure address table
%addytable12685 = call %clsvar* @new_address_table()
%var12686 = bitcast [55 x i8]* @gsxtmgraphics-pipeline521 to i8*
%var12687 = bitcast [56 x i8]* @gsxtmgraphics-pipeline255 to i8*
%addytable12688 = call %clsvar* @add_address_table(%mzone* %zone12680, i8* %var12686, i32 0, i8* %var12687, i32 3, %clsvar* %addytable12685)
%address-table12689 = bitcast %clsvar* %addytable12688 to i8*

; insert table, function and environment into closure struct
%closure.table12692 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure12682, i32 0, i32 0
store i8* %address-table12689, i8** %closure.table12692
%closure.env12693 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure12682, i32 0, i32 1
store i8* %envptr12683, i8** %closure.env12693
%closure.func12694 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure12682, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, float*)* @draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ__12668, void (i8*, i8*, %ShaderProgram*, float*)** %closure.func12694
%closure_size12695 = call i64 @llvm_zone_mark_size(%mzone* %zone12680)
call void @llvm_zone_ptr_set_size(i8* %clsptr12681, i64 %closure_size12695)
%wrapper_ptr12696 = call i8* @llvm_zone_malloc(%mzone* %zone12680, i64 8)
%closure_wrapper12697 = bitcast i8* %wrapper_ptr12696 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure12682, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** %closure_wrapper12697

; let value assignment
%draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** %closure_wrapper12697, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** %closure_wrapper12697
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** %draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}*** %draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQPtr

; add data to environment
; don't need to alloc for env var draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ
%tmp_envptr12691 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}***}* %environment12684, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}*** %draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}**** %tmp_envptr12691


%val12700 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}*** %draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** %val12700
}


@draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** @draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ(%ShaderProgram* %arg_0,float* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1)
ret void
}


define dllexport ccc void @draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_native(%ShaderProgram* %arg_0,float* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1)
ret void
}


define dllexport ccc i8*  @draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12701 = bitcast [108 x i8]* @gsxtmgraphics-pipeline522 to i8*
call i32 (i8*, ...) @printf(i8* %var12701)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12702 = bitcast [108 x i8]* @gsxtmgraphics-pipeline522 to i8*
call i32 (i8*, ...) @printf(i8* %var12702)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, float*}*
%arg_p_0 = getelementptr {%ShaderProgram*, float*}, {%ShaderProgram*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, float*}, {%ShaderProgram*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, float*)*,  void (i8*, i8*, %ShaderProgram*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, float* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline523 = hidden constant [33 x i8] c"Error Initializing DRAW QUAD vao\00"
@gsxtmgraphics-pipeline524 = hidden constant [30 x i8] c"init_draw_quad_adhoc_W3ZvaWRd\00"
@gsxtmgraphics-pipeline525 = hidden constant [31 x i8] c"{i8*, i8*, void (i8*, i8*)*}**\00"
define dllexport fastcc void @init_draw_quad_adhoc_W3ZvaWRd__12703(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12704 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*)*}***}*
%init_draw_quad_adhoc_W3ZvaWRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%init_draw_quad_adhoc_W3ZvaWRdPtr = load {i8*, i8*, void (i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*)*}**** %init_draw_quad_adhoc_W3ZvaWRdPtr_

; setup arguments


%tzone12711 = load i8*, i8** %_impzPtr
%zone12712 = bitcast i8* %tzone12711 to %mzone*

; let assign value to symbol data_s_59
%data_s_59Ptr = alloca float*
%val12705 = getelementptr i64, i64* null, i32 1
%zonesize12706 = mul i64 4, 28
%tzone12707 = load i8*, i8** %_impzPtr
%zone12708 = bitcast i8* %tzone12707 to %mzone*
%dat12709 = call i8* @llvm_zone_malloc(%mzone* %zone12708, i64 %zonesize12706)
call i8* @memset(i8* %dat12709, i32 0, i64 %zonesize12706)
%val12710 = bitcast i8* %dat12709 to float*

; let value assignment
%data_s_59 = select i1 true, float* %val12710, float* %val12710
store float* %data_s_59, float** %data_s_59Ptr

%val12713 = load float*, float** %data_s_59Ptr
; set pointer
%val12714 = getelementptr float, float* %val12713, i64 0
store float 0xbff0000000000000, float* %val12714
%val12715 = load float*, float** %data_s_59Ptr
; set pointer
%val12716 = getelementptr float, float* %val12715, i64 1
store float 0xbff0000000000000, float* %val12716
%val12717 = load float*, float** %data_s_59Ptr
; set pointer
%val12718 = getelementptr float, float* %val12717, i64 2
store float 0x0, float* %val12718
%val12719 = load float*, float** %data_s_59Ptr
; set pointer
%val12720 = getelementptr float, float* %val12719, i64 3
store float 0x3ff0000000000000, float* %val12720
%val12721 = load float*, float** %data_s_59Ptr
; set pointer
%val12722 = getelementptr float, float* %val12721, i64 4
store float 0x0, float* %val12722
%val12723 = load float*, float** %data_s_59Ptr
; set pointer
%val12724 = getelementptr float, float* %val12723, i64 5
store float 0x0, float* %val12724
%val12725 = load float*, float** %data_s_59Ptr
; set pointer
%val12726 = getelementptr float, float* %val12725, i64 6
store float 0x0, float* %val12726
%val12727 = load float*, float** %data_s_59Ptr
; set pointer
%val12728 = getelementptr float, float* %val12727, i64 7
store float 0xbff0000000000000, float* %val12728
%val12729 = load float*, float** %data_s_59Ptr
; set pointer
%val12730 = getelementptr float, float* %val12729, i64 8
store float 0x3ff0000000000000, float* %val12730
%val12731 = load float*, float** %data_s_59Ptr
; set pointer
%val12732 = getelementptr float, float* %val12731, i64 9
store float 0x0, float* %val12732
%val12733 = load float*, float** %data_s_59Ptr
; set pointer
%val12734 = getelementptr float, float* %val12733, i64 10
store float 0x3ff0000000000000, float* %val12734
%val12735 = load float*, float** %data_s_59Ptr
; set pointer
%val12736 = getelementptr float, float* %val12735, i64 11
store float 0x0, float* %val12736
%val12737 = load float*, float** %data_s_59Ptr
; set pointer
%val12738 = getelementptr float, float* %val12737, i64 12
store float 0x3ff0000000000000, float* %val12738
%val12739 = load float*, float** %data_s_59Ptr
; set pointer
%val12740 = getelementptr float, float* %val12739, i64 13
store float 0x0, float* %val12740
%val12741 = load float*, float** %data_s_59Ptr
; set pointer
%val12742 = getelementptr float, float* %val12741, i64 14
store float 0x3ff0000000000000, float* %val12742
%val12743 = load float*, float** %data_s_59Ptr
; set pointer
%val12744 = getelementptr float, float* %val12743, i64 15
store float 0xbff0000000000000, float* %val12744
%val12745 = load float*, float** %data_s_59Ptr
; set pointer
%val12746 = getelementptr float, float* %val12745, i64 16
store float 0x0, float* %val12746
%val12747 = load float*, float** %data_s_59Ptr
; set pointer
%val12748 = getelementptr float, float* %val12747, i64 17
store float 0x3ff0000000000000, float* %val12748
%val12749 = load float*, float** %data_s_59Ptr
; set pointer
%val12750 = getelementptr float, float* %val12749, i64 18
store float 0x3ff0000000000000, float* %val12750
%val12751 = load float*, float** %data_s_59Ptr
; set pointer
%val12752 = getelementptr float, float* %val12751, i64 19
store float 0x0, float* %val12752
%val12753 = load float*, float** %data_s_59Ptr
; set pointer
%val12754 = getelementptr float, float* %val12753, i64 20
store float 0x0, float* %val12754
%val12755 = load float*, float** %data_s_59Ptr
; set pointer
%val12756 = getelementptr float, float* %val12755, i64 21
store float 0x3ff0000000000000, float* %val12756
%val12757 = load float*, float** %data_s_59Ptr
; set pointer
%val12758 = getelementptr float, float* %val12757, i64 22
store float 0x3ff0000000000000, float* %val12758
%val12759 = load float*, float** %data_s_59Ptr
; set pointer
%val12760 = getelementptr float, float* %val12759, i64 23
store float 0x0, float* %val12760
%val12761 = load float*, float** %data_s_59Ptr
; set pointer
%val12762 = getelementptr float, float* %val12761, i64 24
store float 0x3ff0000000000000, float* %val12762
%val12763 = load float*, float** %data_s_59Ptr
; set pointer
%val12764 = getelementptr float, float* %val12763, i64 25
store float 0x3ff0000000000000, float* %val12764
%val12765 = load float*, float** %data_s_59Ptr
; set pointer
%val12766 = getelementptr float, float* %val12765, i64 26
store float 0x3ff0000000000000, float* %val12766
%val12767 = load float*, float** %data_s_59Ptr
; set pointer
%val12768 = getelementptr float, float* %val12767, i64 27
store float 0x0, float* %val12768
; do set!
%res12769 = call fastcc %VAO* @VAO_adhoc_W1ZBTypd()
store %VAO* %res12769, %VAO** @DRAW_QUAD_VAO
; do set!
%val12770 = load float*, float** %data_s_59Ptr
%res12771 = call fastcc %VBO* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0(float* %val12770, i64 28)
store %VBO* %res12771, %VBO** @DRAW_QUAD_VBO
%val12772 = load %VAO*, %VAO** @DRAW_QUAD_VAO
%val12773 = load %VBO*, %VBO** @DRAW_QUAD_VBO
%val12774 = trunc i64 7 to i32
call fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0(%VAO* %val12772, %VBO* %val12773, i32 0, i32 4, i32 %val12774, i32 0)
%val12776 = load %VAO*, %VAO** @DRAW_QUAD_VAO
%val12777 = load %VBO*, %VBO** @DRAW_QUAD_VBO
%val12778 = trunc i64 7 to i32
call fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0(%VAO* %val12776, %VBO* %val12777, i32 2, i32 3, i32 %val12778, i32 4)
%var12780 = bitcast [33 x i8]* @gsxtmgraphics-pipeline523 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var12780)
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*)*}** @init_draw_quad_adhoc_W3ZvaWRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12802 = load i8*, i8** %_impzPtr
%zone12803 = bitcast i8* %tzone12802 to %mzone*

; let assign value to symbol init_draw_quad_adhoc_W3ZvaWRd
%dat_init_draw_quad_adhoc_W3ZvaWRd = call i8* @llvm_zone_malloc(%mzone* %zone12803, i64 8)
%init_draw_quad_adhoc_W3ZvaWRdPtr = bitcast i8* %dat_init_draw_quad_adhoc_W3ZvaWRd to { i8*, i8*, void (i8*, i8*)*}***
%tzone12783 = load i8*, i8** %_impzPtr
%zone12784 = bitcast i8* %tzone12783 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12784)
; malloc closure structure
%clsptr12785 = call i8* @llvm_zone_malloc(%mzone* %zone12784, i64 24)
%closure12786 = bitcast i8* %clsptr12785 to { i8*, i8*, void (i8*, i8*)*}*

; malloc environment structure
%envptr12787 = call i8* @llvm_zone_malloc(%mzone* %zone12784, i64 8)
%environment12788 = bitcast i8* %envptr12787 to {{i8*, i8*, void (i8*, i8*)*}***}*

; malloc closure address table
%addytable12789 = call %clsvar* @new_address_table()
%var12790 = bitcast [30 x i8]* @gsxtmgraphics-pipeline524 to i8*
%var12791 = bitcast [31 x i8]* @gsxtmgraphics-pipeline525 to i8*
%addytable12792 = call %clsvar* @add_address_table(%mzone* %zone12784, i8* %var12790, i32 0, i8* %var12791, i32 3, %clsvar* %addytable12789)
%address-table12793 = bitcast %clsvar* %addytable12792 to i8*

; insert table, function and environment into closure struct
%closure.table12796 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure12786, i32 0, i32 0
store i8* %address-table12793, i8** %closure.table12796
%closure.env12797 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure12786, i32 0, i32 1
store i8* %envptr12787, i8** %closure.env12797
%closure.func12798 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure12786, i32 0, i32 2
store void (i8*, i8*)* @init_draw_quad_adhoc_W3ZvaWRd__12703, void (i8*, i8*)** %closure.func12798
%closure_size12799 = call i64 @llvm_zone_mark_size(%mzone* %zone12784)
call void @llvm_zone_ptr_set_size(i8* %clsptr12785, i64 %closure_size12799)
%wrapper_ptr12800 = call i8* @llvm_zone_malloc(%mzone* %zone12784, i64 8)
%closure_wrapper12801 = bitcast i8* %wrapper_ptr12800 to { i8*, i8*, void (i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*)*}* %closure12786, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper12801

; let value assignment
%init_draw_quad_adhoc_W3ZvaWRd = select i1 true, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper12801, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper12801
store { i8*, i8*, void (i8*, i8*)*}** %init_draw_quad_adhoc_W3ZvaWRd, { i8*, i8*, void (i8*, i8*)*}*** %init_draw_quad_adhoc_W3ZvaWRdPtr

; add data to environment
; don't need to alloc for env var init_draw_quad_adhoc_W3ZvaWRd
%tmp_envptr12795 = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %environment12788, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*)*}*** %init_draw_quad_adhoc_W3ZvaWRdPtr, {i8*, i8*, void (i8*, i8*)*}**** %tmp_envptr12795


%val12804 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %init_draw_quad_adhoc_W3ZvaWRdPtr
ret {i8*, i8*, void (i8*, i8*)*}** %val12804
}


@init_draw_quad_adhoc_W3ZvaWRd_var = dllexport global [1 x i8*] [ i8* null ]

@init_draw_quad_adhoc_W3ZvaWRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @init_draw_quad_adhoc_W3ZvaWRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @init_draw_quad_adhoc_W3ZvaWRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*)*}** @init_draw_quad_adhoc_W3ZvaWRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @init_draw_quad_adhoc_W3ZvaWRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @init_draw_quad_adhoc_W3ZvaWRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @init_draw_quad_adhoc_W3ZvaWRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @init_draw_quad_adhoc_W3ZvaWRd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @init_draw_quad_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc void @init_draw_quad_adhoc_W3ZvaWRd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @init_draw_quad_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc i8*  @init_draw_quad_adhoc_W3ZvaWRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @init_draw_quad_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @init_draw_quad_adhoc_W3ZvaWRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @init_draw_quad_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline526 = hidden constant [5 x i8] c"tex1\00"
@gsxtmgraphics-pipeline527 = hidden constant [15 x i8] c"override_alpha\00"
@gsxtmgraphics-pipeline528 = hidden constant [6 x i8] c"alpha\00"
@gsxtmgraphics-pipeline529 = hidden constant [110 x i8] c"xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ\00"
@gsxtmgraphics-pipeline530 = hidden constant [102 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}**\00"
@gsxtmgraphics-pipeline531 = hidden constant [6 x i8] c"idmat\00"
@gsxtmgraphics-pipeline532 = hidden constant [16 x i8] c"_anon_lambda_22\00"
define dllexport fastcc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ__12805(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, %Texture* %tex, float* %uvmat, i1 %push_new_data, float %alpha, float* %m, float* %v, float* %p) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12816 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***}*
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}**** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_
%idmatPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***}* %impenv, i32 0, i32 1
%idmatPtr = load float**, float*** %idmatPtr_
%_anon_lambda_22Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_22Ptr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}**** %_anon_lambda_22Ptr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr
%uvmatPtr = alloca float*
store float* %uvmat, float** %uvmatPtr
%push_new_dataPtr = alloca i1
store i1 %push_new_data, i1* %push_new_dataPtr
%alphaPtr = alloca float
store float %alpha, float* %alphaPtr
%mPtr = alloca float*
store float* %m, float** %mPtr
%vPtr = alloca float*
store float* %v, float** %vPtr
%pPtr = alloca float*
store float* %p, float** %pPtr


%val12817 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
call fastcc void @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %val12817)
%val12819 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val12820 = load float*, float** %mPtr
%val12821 = load float*, float** %vPtr
%val12822 = load float*, float** %pPtr
call fastcc void @shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd(%ShaderProgram* %val12819, float* %val12820, float* %val12821, float* %val12822)
%val12825 = load i1, i1* %push_new_dataPtr
br i1 %val12825, label %then12824, label %else12824

then12824:
%val12826 = load %Texture*, %Texture** %texPtr
call fastcc void @update_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val12826)
br label %ifcont12824

else12824:
br label %ifcont12824

ifcont12824:
%val12828 = load %Texture*, %Texture** %texPtr
%res12829 = call fastcc i32 @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd(%Texture* %val12828, i32 0)
%val12830 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res12831 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val12830)
%var12832 = bitcast [5 x i8]* @gsxtmgraphics-pipeline526 to i8*
%res12833 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res12831, i8* %var12832)
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res12833, i32 0)
%val12836 = load float, float* %alphaPtr
%cmp12837 = fcmp ult float %val12836, 0x0
br i1 %cmp12837, label %then12835, label %else12835

then12835:
%val12838 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res12839 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val12838)
%var12840 = bitcast [15 x i8]* @gsxtmgraphics-pipeline527 to i8*
%res12841 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res12839, i8* %var12840)
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res12841, i32 0)
br label %ifcont12835

else12835:
%val12843 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res12844 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val12843)
%var12845 = bitcast [15 x i8]* @gsxtmgraphics-pipeline527 to i8*
%res12846 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res12844, i8* %var12845)
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res12846, i32 1)
%val12848 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res12849 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val12848)
%var12850 = bitcast [6 x i8]* @gsxtmgraphics-pipeline528 to i8*
%res12851 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res12849, i8* %var12850)
%val12852 = load float, float* %alphaPtr
call fastcc void @glUniform1f_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %res12851, float %val12852)
br label %ifcont12835

ifcont12835:
%val12855 = load float*, float** %uvmatPtr
%val12856 = icmp eq float* %val12855, null
br i1 %val12856, label %then12854, label %else12854

then12854:
%val12857 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val12858 = load float*, float** %idmatPtr
call fastcc void @draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ(%ShaderProgram* %val12857, float* %val12858)
br label %ifcont12854

else12854:
%val12860 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val12861 = load float*, float** %uvmatPtr
call fastcc void @draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ(%ShaderProgram* %val12860, float* %val12861)
br label %ifcont12854

ifcont12854:
%val12863 = load %Texture*, %Texture** %texPtr
call fastcc void @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ(%Texture* %val12863, i32 0)
%val12865 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
call fastcc void @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %val12865)
ret void
}
@gsxtmgraphics-pipeline533 = hidden constant [163 x i8] c"xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}** @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12900 = load i8*, i8** %_impzPtr
%zone12901 = bitcast i8* %tzone12900 to %mzone*

; let assign value to symbol xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%dat_xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone12901, i64 8)
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = bitcast i8* %dat_xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***
%tzone12812 = load i8*, i8** %_impzPtr
%zone12813 = bitcast i8* %tzone12812 to %mzone*

; let assign value to symbol idmat
%dat_idmat = call i8* @llvm_zone_malloc(%mzone* %zone12813, i64 8)
%idmatPtr = bitcast i8* %dat_idmat to float**
%val12806 = getelementptr i64, i64* null, i32 1
%zonesize12807 = mul i64 4, 16
%tzone12808 = load i8*, i8** %_impzPtr
%zone12809 = bitcast i8* %tzone12808 to %mzone*
%dat12810 = call i8* @llvm_zone_malloc(%mzone* %zone12809, i64 %zonesize12807)
call i8* @memset(i8* %dat12810, i32 0, i64 %zonesize12807)
%val12811 = bitcast i8* %dat12810 to float*

; let value assignment
%idmat = select i1 true, float* %val12811, float* %val12811
store float* %idmat, float** %idmatPtr

%val12814 = load float*, float** %idmatPtr
call fastcc void @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %val12814)
%tzone12897 = load i8*, i8** %_impzPtr
%zone12898 = bitcast i8* %tzone12897 to %mzone*

; let assign value to symbol _anon_lambda_22
%dat__anon_lambda_22 = call i8* @llvm_zone_malloc(%mzone* %zone12898, i64 8)
%_anon_lambda_22Ptr = bitcast i8* %dat__anon_lambda_22 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***
%tzone12868 = load i8*, i8** %_impzPtr
%zone12869 = bitcast i8* %tzone12868 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12869)
; malloc closure structure
%clsptr12870 = call i8* @llvm_zone_malloc(%mzone* %zone12869, i64 24)
%closure12871 = bitcast i8* %clsptr12870 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}*

; malloc environment structure
%envptr12872 = call i8* @llvm_zone_malloc(%mzone* %zone12869, i64 24)
%environment12873 = bitcast i8* %envptr12872 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***}*

; malloc closure address table
%addytable12874 = call %clsvar* @new_address_table()
%var12875 = bitcast [110 x i8]* @gsxtmgraphics-pipeline529 to i8*
%var12876 = bitcast [102 x i8]* @gsxtmgraphics-pipeline530 to i8*
%addytable12877 = call %clsvar* @add_address_table(%mzone* %zone12869, i8* %var12875, i32 0, i8* %var12876, i32 3, %clsvar* %addytable12874)
%var12878 = bitcast [6 x i8]* @gsxtmgraphics-pipeline531 to i8*
%var12879 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable12880 = call %clsvar* @add_address_table(%mzone* %zone12869, i8* %var12878, i32 8, i8* %var12879, i32 3, %clsvar* %addytable12877)
%var12881 = bitcast [16 x i8]* @gsxtmgraphics-pipeline532 to i8*
%var12882 = bitcast [102 x i8]* @gsxtmgraphics-pipeline530 to i8*
%addytable12883 = call %clsvar* @add_address_table(%mzone* %zone12869, i8* %var12881, i32 16, i8* %var12882, i32 3, %clsvar* %addytable12880)
%address-table12884 = bitcast %clsvar* %addytable12883 to i8*

; insert table, function and environment into closure struct
%closure.table12891 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}* %closure12871, i32 0, i32 0
store i8* %address-table12884, i8** %closure.table12891
%closure.env12892 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}* %closure12871, i32 0, i32 1
store i8* %envptr12872, i8** %closure.env12892
%closure.func12893 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}* %closure12871, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ__12805, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)** %closure.func12893
%closure_size12894 = call i64 @llvm_zone_mark_size(%mzone* %zone12869)
call void @llvm_zone_ptr_set_size(i8* %clsptr12870, i64 %closure_size12894)
%wrapper_ptr12895 = call i8* @llvm_zone_malloc(%mzone* %zone12869, i64 8)
%closure_wrapper12896 = bitcast i8* %wrapper_ptr12895 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}* %closure12871, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}** %closure_wrapper12896

; let value assignment
%_anon_lambda_22 = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}** %closure_wrapper12896, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}** %closure_wrapper12896
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}** %_anon_lambda_22, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}*** %_anon_lambda_22Ptr

; add data to environment
; don't need to alloc for env var xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%tmp_envptr12886 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***}* %environment12873, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}*** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}**** %tmp_envptr12886

; don't need to alloc for env var idmat
%tmp_envptr12888 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***}* %environment12873, i32 0, i32 1
store float** %idmatPtr, float*** %tmp_envptr12888

; don't need to alloc for env var _anon_lambda_22
%tmp_envptr12890 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}***}* %environment12873, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}*** %_anon_lambda_22Ptr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}**** %tmp_envptr12890


%val12899 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}*** %_anon_lambda_22Ptr

; let value assignment
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ = select i1 true, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}** %val12899, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}** %val12899
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}*** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr

%val12902 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}*** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}** %val12902
}


@xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}** @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ(%ShaderProgram* %arg_0,%Texture* %arg_1,float* %arg_2,i1 %arg_3,float %arg_4,float* %arg_5,float* %arg_6,float* %arg_7) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float* %arg_2, i1 %arg_3, float %arg_4, float* %arg_5, float* %arg_6, float* %arg_7)
ret void
}


define dllexport ccc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_native(%ShaderProgram* %arg_0,%Texture* %arg_1,float* %arg_2,i1 %arg_3,float %arg_4,float* %arg_5,float* %arg_6,float* %arg_7) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float* %arg_2, i1 %arg_3, float %arg_4, float* %arg_5, float* %arg_6, float* %arg_7)
ret void
}


define dllexport ccc i8*  @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12903 = bitcast [163 x i8]* @gsxtmgraphics-pipeline533 to i8*
call i32 (i8*, ...) @printf(i8* %var12903)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12904 = bitcast [163 x i8]* @gsxtmgraphics-pipeline533 to i8*
call i32 (i8*, ...) @printf(i8* %var12904)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Texture*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var12905 = bitcast [163 x i8]* @gsxtmgraphics-pipeline533 to i8*
call i32 (i8*, ...) @printf(i8* %var12905)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var12906 = bitcast [163 x i8]* @gsxtmgraphics-pipeline533 to i8*
call i32 (i8*, ...) @printf(i8* %var12906)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i1  @i1value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var12907 = bitcast [163 x i8]* @gsxtmgraphics-pipeline533 to i8*
call i32 (i8*, ...) @printf(i8* %var12907)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var12908 = bitcast [163 x i8]* @gsxtmgraphics-pipeline533 to i8*
call i32 (i8*, ...) @printf(i8* %var12908)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to float*
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var12909 = bitcast [163 x i8]* @gsxtmgraphics-pipeline533 to i8*
call i32 (i8*, ...) @printf(i8* %var12909)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to float*
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_cptr(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var12910 = bitcast [163 x i8]* @gsxtmgraphics-pipeline533 to i8*
call i32 (i8*, ...) @printf(i8* %var12910)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%ttv_7 = call ccc i8* @cptr_value(i8* %arg_7_val)
%arg_7 = bitcast i8* %ttv_7 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float* %arg_2, i1 %arg_3, float %arg_4, float* %arg_5, float* %arg_6, float* %arg_7)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*}*
%arg_p_0 = getelementptr {%ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load %Texture*, %Texture** %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load i1, i1* %arg_p_3
%arg_p_4 = getelementptr {%ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
%arg_p_5 = getelementptr {%ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*}* %fstruct, i32 0, i32 5
%arg_5 = load float*, float** %arg_p_5
%arg_p_6 = getelementptr {%ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*}* %fstruct, i32 0, i32 6
%arg_6 = load float*, float** %arg_p_6
%arg_p_7 = getelementptr {%ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*}* %fstruct, i32 0, i32 7
%arg_7 = load float*, float** %arg_p_7
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float* %arg_2, i1 %arg_3, float %arg_4, float* %arg_5, float* %arg_6, float* %arg_7)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline534 = hidden constant [102 x i8] c"xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ\00"
@gsxtmgraphics-pipeline535 = hidden constant [95 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}**\00"
define dllexport fastcc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ__12911(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, %Texture* %tex, float* %uvmat, i1 %update_s_60, float* %m, float* %v, float* %p) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12912 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}***}*
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}**** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr
%uvmatPtr = alloca float*
store float* %uvmat, float** %uvmatPtr
%update_s_60Ptr = alloca i1
store i1 %update_s_60, i1* %update_s_60Ptr
%mPtr = alloca float*
store float* %m, float** %mPtr
%vPtr = alloca float*
store float* %v, float** %vPtr
%pPtr = alloca float*
store float* %p, float** %pPtr


%val12913 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val12914 = load %Texture*, %Texture** %texPtr
%val12915 = load float*, float** %uvmatPtr
%val12916 = load i1, i1* %update_s_60Ptr
%val12917 = load float*, float** %mPtr
%val12918 = load float*, float** %vPtr
%val12919 = load float*, float** %pPtr
call fastcc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ(%ShaderProgram* %val12913, %Texture* %val12914, float* %val12915, i1 %val12916, float 0xbff0000000000000, float* %val12917, float* %val12918, float* %val12919)
ret void
}
@gsxtmgraphics-pipeline536 = hidden constant [155 x i8] c"xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}** @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12941 = load i8*, i8** %_impzPtr
%zone12942 = bitcast i8* %tzone12941 to %mzone*

; let assign value to symbol xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%dat_xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone12942, i64 8)
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = bitcast i8* %dat_xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}***
%tzone12922 = load i8*, i8** %_impzPtr
%zone12923 = bitcast i8* %tzone12922 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12923)
; malloc closure structure
%clsptr12924 = call i8* @llvm_zone_malloc(%mzone* %zone12923, i64 24)
%closure12925 = bitcast i8* %clsptr12924 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}*

; malloc environment structure
%envptr12926 = call i8* @llvm_zone_malloc(%mzone* %zone12923, i64 8)
%environment12927 = bitcast i8* %envptr12926 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}***}*

; malloc closure address table
%addytable12928 = call %clsvar* @new_address_table()
%var12929 = bitcast [102 x i8]* @gsxtmgraphics-pipeline534 to i8*
%var12930 = bitcast [95 x i8]* @gsxtmgraphics-pipeline535 to i8*
%addytable12931 = call %clsvar* @add_address_table(%mzone* %zone12923, i8* %var12929, i32 0, i8* %var12930, i32 3, %clsvar* %addytable12928)
%address-table12932 = bitcast %clsvar* %addytable12931 to i8*

; insert table, function and environment into closure struct
%closure.table12935 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}* %closure12925, i32 0, i32 0
store i8* %address-table12932, i8** %closure.table12935
%closure.env12936 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}* %closure12925, i32 0, i32 1
store i8* %envptr12926, i8** %closure.env12936
%closure.func12937 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}* %closure12925, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ__12911, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)** %closure.func12937
%closure_size12938 = call i64 @llvm_zone_mark_size(%mzone* %zone12923)
call void @llvm_zone_ptr_set_size(i8* %clsptr12924, i64 %closure_size12938)
%wrapper_ptr12939 = call i8* @llvm_zone_malloc(%mzone* %zone12923, i64 8)
%closure_wrapper12940 = bitcast i8* %wrapper_ptr12939 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}* %closure12925, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}** %closure_wrapper12940

; let value assignment
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}** %closure_wrapper12940, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}** %closure_wrapper12940
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}*** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr

; add data to environment
; don't need to alloc for env var xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%tmp_envptr12934 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}***}* %environment12927, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}*** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}**** %tmp_envptr12934


%val12943 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}*** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}** %val12943
}


@xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}** @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ(%ShaderProgram* %arg_0,%Texture* %arg_1,float* %arg_2,i1 %arg_3,float* %arg_4,float* %arg_5,float* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float* %arg_2, i1 %arg_3, float* %arg_4, float* %arg_5, float* %arg_6)
ret void
}


define dllexport ccc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_native(%ShaderProgram* %arg_0,%Texture* %arg_1,float* %arg_2,i1 %arg_3,float* %arg_4,float* %arg_5,float* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float* %arg_2, i1 %arg_3, float* %arg_4, float* %arg_5, float* %arg_6)
ret void
}


define dllexport ccc i8*  @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12944 = bitcast [155 x i8]* @gsxtmgraphics-pipeline536 to i8*
call i32 (i8*, ...) @printf(i8* %var12944)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12945 = bitcast [155 x i8]* @gsxtmgraphics-pipeline536 to i8*
call i32 (i8*, ...) @printf(i8* %var12945)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Texture*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var12946 = bitcast [155 x i8]* @gsxtmgraphics-pipeline536 to i8*
call i32 (i8*, ...) @printf(i8* %var12946)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var12947 = bitcast [155 x i8]* @gsxtmgraphics-pipeline536 to i8*
call i32 (i8*, ...) @printf(i8* %var12947)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i1  @i1value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var12948 = bitcast [155 x i8]* @gsxtmgraphics-pipeline536 to i8*
call i32 (i8*, ...) @printf(i8* %var12948)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var12949 = bitcast [155 x i8]* @gsxtmgraphics-pipeline536 to i8*
call i32 (i8*, ...) @printf(i8* %var12949)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to float*
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var12950 = bitcast [155 x i8]* @gsxtmgraphics-pipeline536 to i8*
call i32 (i8*, ...) @printf(i8* %var12950)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float* %arg_2, i1 %arg_3, float* %arg_4, float* %arg_5, float* %arg_6)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, %Texture*, float*, i1, float*, float*, float*}*
%arg_p_0 = getelementptr {%ShaderProgram*, %Texture*, float*, i1, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, i1, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, %Texture*, float*, i1, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, i1, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load %Texture*, %Texture** %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, %Texture*, float*, i1, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, i1, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%ShaderProgram*, %Texture*, float*, i1, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, i1, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load i1, i1* %arg_p_3
%arg_p_4 = getelementptr {%ShaderProgram*, %Texture*, float*, i1, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, i1, float*, float*, float*}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {%ShaderProgram*, %Texture*, float*, i1, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, i1, float*, float*, float*}* %fstruct, i32 0, i32 5
%arg_5 = load float*, float** %arg_p_5
%arg_p_6 = getelementptr {%ShaderProgram*, %Texture*, float*, i1, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, i1, float*, float*, float*}* %fstruct, i32 0, i32 6
%arg_6 = load float*, float** %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, i1, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float* %arg_2, i1 %arg_3, float* %arg_4, float* %arg_5, float* %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline537 = hidden constant [106 x i8] c"xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ\00"
@gsxtmgraphics-pipeline538 = hidden constant [98 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}**\00"
define dllexport fastcc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ__12951(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, %Texture* %tex, float* %uvmat, float %alpha, float* %m, float* %v, float* %p) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12952 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}***}*
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}**** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr
%uvmatPtr = alloca float*
store float* %uvmat, float** %uvmatPtr
%alphaPtr = alloca float
store float %alpha, float* %alphaPtr
%mPtr = alloca float*
store float* %m, float** %mPtr
%vPtr = alloca float*
store float* %v, float** %vPtr
%pPtr = alloca float*
store float* %p, float** %pPtr


%val12953 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val12954 = load %Texture*, %Texture** %texPtr
%val12955 = load float*, float** %uvmatPtr
%res12956 = call ccc i1 @impc_false()
%val12957 = load float, float* %alphaPtr
%val12958 = load float*, float** %mPtr
%val12959 = load float*, float** %vPtr
%val12960 = load float*, float** %pPtr
call fastcc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ(%ShaderProgram* %val12953, %Texture* %val12954, float* %val12955, i1 %res12956, float %val12957, float* %val12958, float* %val12959, float* %val12960)
ret void
}
@gsxtmgraphics-pipeline539 = hidden constant [159 x i8] c"xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}** @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone12982 = load i8*, i8** %_impzPtr
%zone12983 = bitcast i8* %tzone12982 to %mzone*

; let assign value to symbol xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%dat_xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone12983, i64 8)
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = bitcast i8* %dat_xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}***
%tzone12963 = load i8*, i8** %_impzPtr
%zone12964 = bitcast i8* %tzone12963 to %mzone*
call void @llvm_zone_mark(%mzone* %zone12964)
; malloc closure structure
%clsptr12965 = call i8* @llvm_zone_malloc(%mzone* %zone12964, i64 24)
%closure12966 = bitcast i8* %clsptr12965 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}*

; malloc environment structure
%envptr12967 = call i8* @llvm_zone_malloc(%mzone* %zone12964, i64 8)
%environment12968 = bitcast i8* %envptr12967 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}***}*

; malloc closure address table
%addytable12969 = call %clsvar* @new_address_table()
%var12970 = bitcast [106 x i8]* @gsxtmgraphics-pipeline537 to i8*
%var12971 = bitcast [98 x i8]* @gsxtmgraphics-pipeline538 to i8*
%addytable12972 = call %clsvar* @add_address_table(%mzone* %zone12964, i8* %var12970, i32 0, i8* %var12971, i32 3, %clsvar* %addytable12969)
%address-table12973 = bitcast %clsvar* %addytable12972 to i8*

; insert table, function and environment into closure struct
%closure.table12976 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}* %closure12966, i32 0, i32 0
store i8* %address-table12973, i8** %closure.table12976
%closure.env12977 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}* %closure12966, i32 0, i32 1
store i8* %envptr12967, i8** %closure.env12977
%closure.func12978 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}* %closure12966, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ__12951, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)** %closure.func12978
%closure_size12979 = call i64 @llvm_zone_mark_size(%mzone* %zone12964)
call void @llvm_zone_ptr_set_size(i8* %clsptr12965, i64 %closure_size12979)
%wrapper_ptr12980 = call i8* @llvm_zone_malloc(%mzone* %zone12964, i64 8)
%closure_wrapper12981 = bitcast i8* %wrapper_ptr12980 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}* %closure12966, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}** %closure_wrapper12981

; let value assignment
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}** %closure_wrapper12981, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}** %closure_wrapper12981
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}*** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr

; add data to environment
; don't need to alloc for env var xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%tmp_envptr12975 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}***}* %environment12968, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}*** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}**** %tmp_envptr12975


%val12984 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}*** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}** %val12984
}


@xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}** @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ(%ShaderProgram* %arg_0,%Texture* %arg_1,float* %arg_2,float %arg_3,float* %arg_4,float* %arg_5,float* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float* %arg_2, float %arg_3, float* %arg_4, float* %arg_5, float* %arg_6)
ret void
}


define dllexport ccc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_native(%ShaderProgram* %arg_0,%Texture* %arg_1,float* %arg_2,float %arg_3,float* %arg_4,float* %arg_5,float* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float* %arg_2, float %arg_3, float* %arg_4, float* %arg_5, float* %arg_6)
ret void
}


define dllexport ccc i8*  @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var12985 = bitcast [159 x i8]* @gsxtmgraphics-pipeline539 to i8*
call i32 (i8*, ...) @printf(i8* %var12985)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var12986 = bitcast [159 x i8]* @gsxtmgraphics-pipeline539 to i8*
call i32 (i8*, ...) @printf(i8* %var12986)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Texture*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var12987 = bitcast [159 x i8]* @gsxtmgraphics-pipeline539 to i8*
call i32 (i8*, ...) @printf(i8* %var12987)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var12988 = bitcast [159 x i8]* @gsxtmgraphics-pipeline539 to i8*
call i32 (i8*, ...) @printf(i8* %var12988)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var12989 = bitcast [159 x i8]* @gsxtmgraphics-pipeline539 to i8*
call i32 (i8*, ...) @printf(i8* %var12989)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var12990 = bitcast [159 x i8]* @gsxtmgraphics-pipeline539 to i8*
call i32 (i8*, ...) @printf(i8* %var12990)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to float*
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var12991 = bitcast [159 x i8]* @gsxtmgraphics-pipeline539 to i8*
call i32 (i8*, ...) @printf(i8* %var12991)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float* %arg_2, float %arg_3, float* %arg_4, float* %arg_5, float* %arg_6)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, %Texture*, float*, float, float*, float*, float*}*
%arg_p_0 = getelementptr {%ShaderProgram*, %Texture*, float*, float, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, float, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, %Texture*, float*, float, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, float, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load %Texture*, %Texture** %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, %Texture*, float*, float, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, float, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%ShaderProgram*, %Texture*, float*, float, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, float, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {%ShaderProgram*, %Texture*, float*, float, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, float, float*, float*, float*}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {%ShaderProgram*, %Texture*, float*, float, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, float, float*, float*, float*}* %fstruct, i32 0, i32 5
%arg_5 = load float*, float** %arg_p_5
%arg_p_6 = getelementptr {%ShaderProgram*, %Texture*, float*, float, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, float, float*, float*, float*}* %fstruct, i32 0, i32 6
%arg_6 = load float*, float** %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float* %arg_2, float %arg_3, float* %arg_4, float* %arg_5, float* %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline540 = hidden constant [98 x i8] c"xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ\00"
@gsxtmgraphics-pipeline541 = hidden constant [91 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}**\00"
define dllexport fastcc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ__12992(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, %Texture* %tex, float* %uvmat, float* %m, float* %v, float* %p) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone12993 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}***}*
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}**** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr
%uvmatPtr = alloca float*
store float* %uvmat, float** %uvmatPtr
%mPtr = alloca float*
store float* %m, float** %mPtr
%vPtr = alloca float*
store float* %v, float** %vPtr
%pPtr = alloca float*
store float* %p, float** %pPtr


%val12994 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val12995 = load %Texture*, %Texture** %texPtr
%val12996 = load float*, float** %uvmatPtr
%res12997 = call ccc i1 @impc_false()
%val12998 = load float*, float** %mPtr
%val12999 = load float*, float** %vPtr
%val13000 = load float*, float** %pPtr
call fastcc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ(%ShaderProgram* %val12994, %Texture* %val12995, float* %val12996, i1 %res12997, float 0xbff0000000000000, float* %val12998, float* %val12999, float* %val13000)
ret void
}
@gsxtmgraphics-pipeline542 = hidden constant [151 x i8] c"xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}** @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13022 = load i8*, i8** %_impzPtr
%zone13023 = bitcast i8* %tzone13022 to %mzone*

; let assign value to symbol xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%dat_xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone13023, i64 8)
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = bitcast i8* %dat_xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}***
%tzone13003 = load i8*, i8** %_impzPtr
%zone13004 = bitcast i8* %tzone13003 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13004)
; malloc closure structure
%clsptr13005 = call i8* @llvm_zone_malloc(%mzone* %zone13004, i64 24)
%closure13006 = bitcast i8* %clsptr13005 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}*

; malloc environment structure
%envptr13007 = call i8* @llvm_zone_malloc(%mzone* %zone13004, i64 8)
%environment13008 = bitcast i8* %envptr13007 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}***}*

; malloc closure address table
%addytable13009 = call %clsvar* @new_address_table()
%var13010 = bitcast [98 x i8]* @gsxtmgraphics-pipeline540 to i8*
%var13011 = bitcast [91 x i8]* @gsxtmgraphics-pipeline541 to i8*
%addytable13012 = call %clsvar* @add_address_table(%mzone* %zone13004, i8* %var13010, i32 0, i8* %var13011, i32 3, %clsvar* %addytable13009)
%address-table13013 = bitcast %clsvar* %addytable13012 to i8*

; insert table, function and environment into closure struct
%closure.table13016 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}* %closure13006, i32 0, i32 0
store i8* %address-table13013, i8** %closure.table13016
%closure.env13017 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}* %closure13006, i32 0, i32 1
store i8* %envptr13007, i8** %closure.env13017
%closure.func13018 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}* %closure13006, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ__12992, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)** %closure.func13018
%closure_size13019 = call i64 @llvm_zone_mark_size(%mzone* %zone13004)
call void @llvm_zone_ptr_set_size(i8* %clsptr13005, i64 %closure_size13019)
%wrapper_ptr13020 = call i8* @llvm_zone_malloc(%mzone* %zone13004, i64 8)
%closure_wrapper13021 = bitcast i8* %wrapper_ptr13020 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}* %closure13006, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}** %closure_wrapper13021

; let value assignment
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}** %closure_wrapper13021, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}** %closure_wrapper13021
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}*** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr

; add data to environment
; don't need to alloc for env var xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%tmp_envptr13015 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}***}* %environment13008, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}*** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}**** %tmp_envptr13015


%val13024 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}*** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}** %val13024
}


@xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}** @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ(%ShaderProgram* %arg_0,%Texture* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float* %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5)
ret void
}


define dllexport ccc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_native(%ShaderProgram* %arg_0,%Texture* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4,float* %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5)
ret void
}


define dllexport ccc i8*  @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13025 = bitcast [151 x i8]* @gsxtmgraphics-pipeline542 to i8*
call i32 (i8*, ...) @printf(i8* %var13025)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var13026 = bitcast [151 x i8]* @gsxtmgraphics-pipeline542 to i8*
call i32 (i8*, ...) @printf(i8* %var13026)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Texture*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var13027 = bitcast [151 x i8]* @gsxtmgraphics-pipeline542 to i8*
call i32 (i8*, ...) @printf(i8* %var13027)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var13028 = bitcast [151 x i8]* @gsxtmgraphics-pipeline542 to i8*
call i32 (i8*, ...) @printf(i8* %var13028)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var13029 = bitcast [151 x i8]* @gsxtmgraphics-pipeline542 to i8*
call i32 (i8*, ...) @printf(i8* %var13029)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var13030 = bitcast [151 x i8]* @gsxtmgraphics-pipeline542 to i8*
call i32 (i8*, ...) @printf(i8* %var13030)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, %Texture*, float*, float*, float*, float*}*
%arg_p_0 = getelementptr {%ShaderProgram*, %Texture*, float*, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, %Texture*, float*, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load %Texture*, %Texture** %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, %Texture*, float*, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%ShaderProgram*, %Texture*, float*, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {%ShaderProgram*, %Texture*, float*, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, float*, float*, float*}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {%ShaderProgram*, %Texture*, float*, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, float*, float*, float*}* %fstruct, i32 0, i32 5
%arg_5 = load float*, float** %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4, float* %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline543 = hidden constant [92 x i8] c"xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd\00"
@gsxtmgraphics-pipeline544 = hidden constant [87 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}**\00"
define dllexport fastcc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd__13031(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, %Texture* %tex, i1 %update_s_61, float* %m, float* %v, float* %p) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13032 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}***}*
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}**** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr
%update_s_61Ptr = alloca i1
store i1 %update_s_61, i1* %update_s_61Ptr
%mPtr = alloca float*
store float* %m, float** %mPtr
%vPtr = alloca float*
store float* %v, float** %vPtr
%pPtr = alloca float*
store float* %p, float** %pPtr


%val13033 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val13034 = load %Texture*, %Texture** %texPtr
%null13035 = bitcast i8* null to float*
%val13036 = load i1, i1* %update_s_61Ptr
%val13037 = load float*, float** %mPtr
%val13038 = load float*, float** %vPtr
%val13039 = load float*, float** %pPtr
call fastcc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ(%ShaderProgram* %val13033, %Texture* %val13034, float* %null13035, i1 %val13036, float 0xbff0000000000000, float* %val13037, float* %val13038, float* %val13039)
ret void
}
@gsxtmgraphics-pipeline545 = hidden constant [145 x i8] c"xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}** @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13061 = load i8*, i8** %_impzPtr
%zone13062 = bitcast i8* %tzone13061 to %mzone*

; let assign value to symbol xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd
%dat_xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd = call i8* @llvm_zone_malloc(%mzone* %zone13062, i64 8)
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr = bitcast i8* %dat_xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}***
%tzone13042 = load i8*, i8** %_impzPtr
%zone13043 = bitcast i8* %tzone13042 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13043)
; malloc closure structure
%clsptr13044 = call i8* @llvm_zone_malloc(%mzone* %zone13043, i64 24)
%closure13045 = bitcast i8* %clsptr13044 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}*

; malloc environment structure
%envptr13046 = call i8* @llvm_zone_malloc(%mzone* %zone13043, i64 8)
%environment13047 = bitcast i8* %envptr13046 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}***}*

; malloc closure address table
%addytable13048 = call %clsvar* @new_address_table()
%var13049 = bitcast [92 x i8]* @gsxtmgraphics-pipeline543 to i8*
%var13050 = bitcast [87 x i8]* @gsxtmgraphics-pipeline544 to i8*
%addytable13051 = call %clsvar* @add_address_table(%mzone* %zone13043, i8* %var13049, i32 0, i8* %var13050, i32 3, %clsvar* %addytable13048)
%address-table13052 = bitcast %clsvar* %addytable13051 to i8*

; insert table, function and environment into closure struct
%closure.table13055 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}* %closure13045, i32 0, i32 0
store i8* %address-table13052, i8** %closure.table13055
%closure.env13056 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}* %closure13045, i32 0, i32 1
store i8* %envptr13046, i8** %closure.env13056
%closure.func13057 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}* %closure13045, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd__13031, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)** %closure.func13057
%closure_size13058 = call i64 @llvm_zone_mark_size(%mzone* %zone13043)
call void @llvm_zone_ptr_set_size(i8* %clsptr13044, i64 %closure_size13058)
%wrapper_ptr13059 = call i8* @llvm_zone_malloc(%mzone* %zone13043, i64 8)
%closure_wrapper13060 = bitcast i8* %wrapper_ptr13059 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}* %closure13045, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}** %closure_wrapper13060

; let value assignment
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}** %closure_wrapper13060, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}** %closure_wrapper13060
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}*** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr

; add data to environment
; don't need to alloc for env var xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd
%tmp_envptr13054 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}***}* %environment13047, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}*** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}**** %tmp_envptr13054


%val13063 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}*** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}** %val13063
}


@xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}** @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd(%ShaderProgram* %arg_0,%Texture* %arg_1,i1 %arg_2,float* %arg_3,float* %arg_4,float* %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, i1 %arg_2, float* %arg_3, float* %arg_4, float* %arg_5)
ret void
}


define dllexport ccc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_native(%ShaderProgram* %arg_0,%Texture* %arg_1,i1 %arg_2,float* %arg_3,float* %arg_4,float* %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, i1 %arg_2, float* %arg_3, float* %arg_4, float* %arg_5)
ret void
}


define dllexport ccc i8*  @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13064 = bitcast [145 x i8]* @gsxtmgraphics-pipeline545 to i8*
call i32 (i8*, ...) @printf(i8* %var13064)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var13065 = bitcast [145 x i8]* @gsxtmgraphics-pipeline545 to i8*
call i32 (i8*, ...) @printf(i8* %var13065)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Texture*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var13066 = bitcast [145 x i8]* @gsxtmgraphics-pipeline545 to i8*
call i32 (i8*, ...) @printf(i8* %var13066)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i1  @i1value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var13067 = bitcast [145 x i8]* @gsxtmgraphics-pipeline545 to i8*
call i32 (i8*, ...) @printf(i8* %var13067)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var13068 = bitcast [145 x i8]* @gsxtmgraphics-pipeline545 to i8*
call i32 (i8*, ...) @printf(i8* %var13068)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var13069 = bitcast [145 x i8]* @gsxtmgraphics-pipeline545 to i8*
call i32 (i8*, ...) @printf(i8* %var13069)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, i1 %arg_2, float* %arg_3, float* %arg_4, float* %arg_5)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, %Texture*, i1, float*, float*, float*}*
%arg_p_0 = getelementptr {%ShaderProgram*, %Texture*, i1, float*, float*, float*}, {%ShaderProgram*, %Texture*, i1, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, %Texture*, i1, float*, float*, float*}, {%ShaderProgram*, %Texture*, i1, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load %Texture*, %Texture** %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, %Texture*, i1, float*, float*, float*}, {%ShaderProgram*, %Texture*, i1, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load i1, i1* %arg_p_2
%arg_p_3 = getelementptr {%ShaderProgram*, %Texture*, i1, float*, float*, float*}, {%ShaderProgram*, %Texture*, i1, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {%ShaderProgram*, %Texture*, i1, float*, float*, float*}, {%ShaderProgram*, %Texture*, i1, float*, float*, float*}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {%ShaderProgram*, %Texture*, i1, float*, float*, float*}, {%ShaderProgram*, %Texture*, i1, float*, float*, float*}* %fstruct, i32 0, i32 5
%arg_5 = load float*, float** %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosaTEsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, i1, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, i1 %arg_2, float* %arg_3, float* %arg_4, float* %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline546 = hidden constant [96 x i8] c"xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd\00"
@gsxtmgraphics-pipeline547 = hidden constant [90 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}**\00"
define dllexport fastcc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd__13070(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, %Texture* %tex, float %alpha, float* %m, float* %v, float* %p) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13071 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}***}*
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}**** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr
%alphaPtr = alloca float
store float %alpha, float* %alphaPtr
%mPtr = alloca float*
store float* %m, float** %mPtr
%vPtr = alloca float*
store float* %v, float** %vPtr
%pPtr = alloca float*
store float* %p, float** %pPtr


%val13072 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val13073 = load %Texture*, %Texture** %texPtr
%null13074 = bitcast i8* null to float*
%res13075 = call ccc i1 @impc_false()
%val13076 = load float, float* %alphaPtr
%val13077 = load float*, float** %mPtr
%val13078 = load float*, float** %vPtr
%val13079 = load float*, float** %pPtr
call fastcc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ(%ShaderProgram* %val13072, %Texture* %val13073, float* %null13074, i1 %res13075, float %val13076, float* %val13077, float* %val13078, float* %val13079)
ret void
}
@gsxtmgraphics-pipeline548 = hidden constant [149 x i8] c"xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}** @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13101 = load i8*, i8** %_impzPtr
%zone13102 = bitcast i8* %tzone13101 to %mzone*

; let assign value to symbol xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd
%dat_xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd = call i8* @llvm_zone_malloc(%mzone* %zone13102, i64 8)
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr = bitcast i8* %dat_xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}***
%tzone13082 = load i8*, i8** %_impzPtr
%zone13083 = bitcast i8* %tzone13082 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13083)
; malloc closure structure
%clsptr13084 = call i8* @llvm_zone_malloc(%mzone* %zone13083, i64 24)
%closure13085 = bitcast i8* %clsptr13084 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}*

; malloc environment structure
%envptr13086 = call i8* @llvm_zone_malloc(%mzone* %zone13083, i64 8)
%environment13087 = bitcast i8* %envptr13086 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}***}*

; malloc closure address table
%addytable13088 = call %clsvar* @new_address_table()
%var13089 = bitcast [96 x i8]* @gsxtmgraphics-pipeline546 to i8*
%var13090 = bitcast [90 x i8]* @gsxtmgraphics-pipeline547 to i8*
%addytable13091 = call %clsvar* @add_address_table(%mzone* %zone13083, i8* %var13089, i32 0, i8* %var13090, i32 3, %clsvar* %addytable13088)
%address-table13092 = bitcast %clsvar* %addytable13091 to i8*

; insert table, function and environment into closure struct
%closure.table13095 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}* %closure13085, i32 0, i32 0
store i8* %address-table13092, i8** %closure.table13095
%closure.env13096 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}* %closure13085, i32 0, i32 1
store i8* %envptr13086, i8** %closure.env13096
%closure.func13097 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}* %closure13085, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd__13070, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)** %closure.func13097
%closure_size13098 = call i64 @llvm_zone_mark_size(%mzone* %zone13083)
call void @llvm_zone_ptr_set_size(i8* %clsptr13084, i64 %closure_size13098)
%wrapper_ptr13099 = call i8* @llvm_zone_malloc(%mzone* %zone13083, i64 8)
%closure_wrapper13100 = bitcast i8* %wrapper_ptr13099 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}* %closure13085, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}** %closure_wrapper13100

; let value assignment
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}** %closure_wrapper13100, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}** %closure_wrapper13100
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}*** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr

; add data to environment
; don't need to alloc for env var xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd
%tmp_envptr13094 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}***}* %environment13087, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}*** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}**** %tmp_envptr13094


%val13103 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}*** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}** %val13103
}


@xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}** @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd(%ShaderProgram* %arg_0,%Texture* %arg_1,float %arg_2,float* %arg_3,float* %arg_4,float* %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float %arg_2, float* %arg_3, float* %arg_4, float* %arg_5)
ret void
}


define dllexport ccc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_native(%ShaderProgram* %arg_0,%Texture* %arg_1,float %arg_2,float* %arg_3,float* %arg_4,float* %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float %arg_2, float* %arg_3, float* %arg_4, float* %arg_5)
ret void
}


define dllexport ccc i8*  @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13104 = bitcast [149 x i8]* @gsxtmgraphics-pipeline548 to i8*
call i32 (i8*, ...) @printf(i8* %var13104)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var13105 = bitcast [149 x i8]* @gsxtmgraphics-pipeline548 to i8*
call i32 (i8*, ...) @printf(i8* %var13105)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Texture*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var13106 = bitcast [149 x i8]* @gsxtmgraphics-pipeline548 to i8*
call i32 (i8*, ...) @printf(i8* %var13106)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var13107 = bitcast [149 x i8]* @gsxtmgraphics-pipeline548 to i8*
call i32 (i8*, ...) @printf(i8* %var13107)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var13108 = bitcast [149 x i8]* @gsxtmgraphics-pipeline548 to i8*
call i32 (i8*, ...) @printf(i8* %var13108)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var13109 = bitcast [149 x i8]* @gsxtmgraphics-pipeline548 to i8*
call i32 (i8*, ...) @printf(i8* %var13109)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float %arg_2, float* %arg_3, float* %arg_4, float* %arg_5)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, %Texture*, float, float*, float*, float*}*
%arg_p_0 = getelementptr {%ShaderProgram*, %Texture*, float, float*, float*, float*}, {%ShaderProgram*, %Texture*, float, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, %Texture*, float, float*, float*, float*}, {%ShaderProgram*, %Texture*, float, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load %Texture*, %Texture** %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, %Texture*, float, float*, float*, float*}, {%ShaderProgram*, %Texture*, float, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {%ShaderProgram*, %Texture*, float, float*, float*, float*}, {%ShaderProgram*, %Texture*, float, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {%ShaderProgram*, %Texture*, float, float*, float*, float*}, {%ShaderProgram*, %Texture*, float, float*, float*, float*}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {%ShaderProgram*, %Texture*, float, float*, float*, float*}, {%ShaderProgram*, %Texture*, float, float*, float*, float*}* %fstruct, i32 0, i32 5
%arg_5 = load float*, float** %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float %arg_2, float* %arg_3, float* %arg_4, float* %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline549 = hidden constant [88 x i8] c"xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd\00"
@gsxtmgraphics-pipeline550 = hidden constant [83 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}**\00"
define dllexport fastcc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd__13110(i8* %_impz,i8* %_impenv, %ShaderProgram* %shader, %Texture* %tex, float* %m, float* %v, float* %p) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13111 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}***}*
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}**** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr_

; setup arguments
%shaderPtr = alloca %ShaderProgram*
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr
%mPtr = alloca float*
store float* %m, float** %mPtr
%vPtr = alloca float*
store float* %v, float** %vPtr
%pPtr = alloca float*
store float* %p, float** %pPtr


%val13112 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val13113 = load %Texture*, %Texture** %texPtr
%null13114 = bitcast i8* null to float*
%res13115 = call ccc i1 @impc_false()
%val13116 = load float*, float** %mPtr
%val13117 = load float*, float** %vPtr
%val13118 = load float*, float** %pPtr
call fastcc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGkxLGZsb2F0LGZsb2F0KixmbG9hdCosZmxvYXQqXQ(%ShaderProgram* %val13112, %Texture* %val13113, float* %null13114, i1 %res13115, float 0xbff0000000000000, float* %val13116, float* %val13117, float* %val13118)
ret void
}
@gsxtmgraphics-pipeline551 = hidden constant [141 x i8] c"xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}** @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13140 = load i8*, i8** %_impzPtr
%zone13141 = bitcast i8* %tzone13140 to %mzone*

; let assign value to symbol xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd
%dat_xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd = call i8* @llvm_zone_malloc(%mzone* %zone13141, i64 8)
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr = bitcast i8* %dat_xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}***
%tzone13121 = load i8*, i8** %_impzPtr
%zone13122 = bitcast i8* %tzone13121 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13122)
; malloc closure structure
%clsptr13123 = call i8* @llvm_zone_malloc(%mzone* %zone13122, i64 24)
%closure13124 = bitcast i8* %clsptr13123 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}*

; malloc environment structure
%envptr13125 = call i8* @llvm_zone_malloc(%mzone* %zone13122, i64 8)
%environment13126 = bitcast i8* %envptr13125 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}***}*

; malloc closure address table
%addytable13127 = call %clsvar* @new_address_table()
%var13128 = bitcast [88 x i8]* @gsxtmgraphics-pipeline549 to i8*
%var13129 = bitcast [83 x i8]* @gsxtmgraphics-pipeline550 to i8*
%addytable13130 = call %clsvar* @add_address_table(%mzone* %zone13122, i8* %var13128, i32 0, i8* %var13129, i32 3, %clsvar* %addytable13127)
%address-table13131 = bitcast %clsvar* %addytable13130 to i8*

; insert table, function and environment into closure struct
%closure.table13134 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}* %closure13124, i32 0, i32 0
store i8* %address-table13131, i8** %closure.table13134
%closure.env13135 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}* %closure13124, i32 0, i32 1
store i8* %envptr13125, i8** %closure.env13135
%closure.func13136 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}* %closure13124, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd__13110, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)** %closure.func13136
%closure_size13137 = call i64 @llvm_zone_mark_size(%mzone* %zone13122)
call void @llvm_zone_ptr_set_size(i8* %clsptr13123, i64 %closure_size13137)
%wrapper_ptr13138 = call i8* @llvm_zone_malloc(%mzone* %zone13122, i64 8)
%closure_wrapper13139 = bitcast i8* %wrapper_ptr13138 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}* %closure13124, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}** %closure_wrapper13139

; let value assignment
%xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}** %closure_wrapper13139, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}** %closure_wrapper13139
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd, { i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}*** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr

; add data to environment
; don't need to alloc for env var xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd
%tmp_envptr13133 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}***}* %environment13126, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}*** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}**** %tmp_envptr13133


%val13142 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}*** %xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}** %val13142
}


@xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}** @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd(%ShaderProgram* %arg_0,%Texture* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4)
ret void
}


define dllexport ccc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_native(%ShaderProgram* %arg_0,%Texture* %arg_1,float* %arg_2,float* %arg_3,float* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4)
ret void
}


define dllexport ccc i8*  @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13143 = bitcast [141 x i8]* @gsxtmgraphics-pipeline551 to i8*
call i32 (i8*, ...) @printf(i8* %var13143)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var13144 = bitcast [141 x i8]* @gsxtmgraphics-pipeline551 to i8*
call i32 (i8*, ...) @printf(i8* %var13144)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Texture*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var13145 = bitcast [141 x i8]* @gsxtmgraphics-pipeline551 to i8*
call i32 (i8*, ...) @printf(i8* %var13145)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var13146 = bitcast [141 x i8]* @gsxtmgraphics-pipeline551 to i8*
call i32 (i8*, ...) @printf(i8* %var13146)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var13147 = bitcast [141 x i8]* @gsxtmgraphics-pipeline551 to i8*
call i32 (i8*, ...) @printf(i8* %var13147)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, %Texture*, float*, float*, float*}*
%arg_p_0 = getelementptr {%ShaderProgram*, %Texture*, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, %Texture*, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load %Texture*, %Texture** %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, %Texture*, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%ShaderProgram*, %Texture*, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
%arg_p_4 = getelementptr {%ShaderProgram*, %Texture*, float*, float*, float*}, {%ShaderProgram*, %Texture*, float*, float*, float*}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)*,  void (i8*, i8*, %ShaderProgram*, %Texture*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %Texture* %arg_1, float* %arg_2, float* %arg_3, float* %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@XTM_BACKGROUND_COLOUR = dllexport global <4 x float> zeroinitializer
@SKY_BOX_MODEL = dllexport global %XTMModel* zeroinitializer
@SKY_BOX_TEXTURE = dllexport global %Texture* zeroinitializer
@SKY_BOX = dllexport global i1 zeroinitializer
@SKY_BOX_SCALE = dllexport global float 0x407f400000000000
@gsxtmgraphics-pipeline552 = hidden constant [113 x i8] c"xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ\00"
@gsxtmgraphics-pipeline553 = hidden constant [107 x i8] c"{i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}**\00"
define dllexport fastcc void @xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ__13148(i8* %_impz,i8* %_impenv, %XTMModel* %model, i1 %flipped, %String* %front, %String* %back, %String* %top, %String* %bottom, %String* %left, %String* %right) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13149 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}***}*
%xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}***}* %impenv, i32 0, i32 0
%xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr = load {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}***, {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}**** %xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr_

; setup arguments
%modelPtr = alloca %XTMModel*
store %XTMModel* %model, %XTMModel** %modelPtr
%flippedPtr = alloca i1
store i1 %flipped, i1* %flippedPtr
%frontPtr = alloca %String*
store %String* %front, %String** %frontPtr
%backPtr = alloca %String*
store %String* %back, %String** %backPtr
%topPtr = alloca %String*
store %String* %top, %String** %topPtr
%bottomPtr = alloca %String*
store %String* %bottom, %String** %bottomPtr
%leftPtr = alloca %String*
store %String* %left, %String** %leftPtr
%rightPtr = alloca %String*
store %String* %right, %String** %rightPtr


; do set!
%val13150 = load %XTMModel*, %XTMModel** %modelPtr
store %XTMModel* %val13150, %XTMModel** @SKY_BOX_MODEL
; do set!
%res13151 = call fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqXQ()
store %Texture* %res13151, %Texture** @SKY_BOX_TEXTURE
%val13152 = load %Texture*, %Texture** @SKY_BOX_TEXTURE
%val13153 = load i1, i1* %flippedPtr
%res13154 = call ccc i32 @i1toi32(i1 %val13153)
%val13155 = load %String*, %String** %frontPtr
%val13156 = load %String*, %String** %backPtr
%val13157 = load %String*, %String** %topPtr
%val13158 = load %String*, %String** %bottomPtr
%val13159 = load %String*, %String** %leftPtr
%val13160 = load %String*, %String** %rightPtr
call fastcc void @load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%Texture* %val13152, i32 %res13154, %String* %val13155, %String* %val13156, %String* %val13157, %String* %val13158, %String* %val13159, %String* %val13160)
%val13162 = load %Texture*, %Texture** @SKY_BOX_TEXTURE
call fastcc void @update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val13162)
; do set!
%res13164 = call ccc i1 @impc_true()
store i1 %res13164, i1* @SKY_BOX
ret void
}
@gsxtmgraphics-pipeline554 = hidden constant [166 x i8] c"xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** @xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13185 = load i8*, i8** %_impzPtr
%zone13186 = bitcast i8* %tzone13185 to %mzone*

; let assign value to symbol xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ
%dat_xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ = call i8* @llvm_zone_malloc(%mzone* %zone13186, i64 8)
%xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr = bitcast i8* %dat_xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ to { i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}***
%tzone13166 = load i8*, i8** %_impzPtr
%zone13167 = bitcast i8* %tzone13166 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13167)
; malloc closure structure
%clsptr13168 = call i8* @llvm_zone_malloc(%mzone* %zone13167, i64 24)
%closure13169 = bitcast i8* %clsptr13168 to { i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}*

; malloc environment structure
%envptr13170 = call i8* @llvm_zone_malloc(%mzone* %zone13167, i64 8)
%environment13171 = bitcast i8* %envptr13170 to {{i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}***}*

; malloc closure address table
%addytable13172 = call %clsvar* @new_address_table()
%var13173 = bitcast [113 x i8]* @gsxtmgraphics-pipeline552 to i8*
%var13174 = bitcast [107 x i8]* @gsxtmgraphics-pipeline553 to i8*
%addytable13175 = call %clsvar* @add_address_table(%mzone* %zone13167, i8* %var13173, i32 0, i8* %var13174, i32 3, %clsvar* %addytable13172)
%address-table13176 = bitcast %clsvar* %addytable13175 to i8*

; insert table, function and environment into closure struct
%closure.table13179 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, { i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure13169, i32 0, i32 0
store i8* %address-table13176, i8** %closure.table13179
%closure.env13180 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, { i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure13169, i32 0, i32 1
store i8* %envptr13170, i8** %closure.env13180
%closure.func13181 = getelementptr { i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, { i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure13169, i32 0, i32 2
store void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)* @xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ__13148, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)** %closure.func13181
%closure_size13182 = call i64 @llvm_zone_mark_size(%mzone* %zone13167)
call void @llvm_zone_ptr_set_size(i8* %clsptr13168, i64 %closure_size13182)
%wrapper_ptr13183 = call i8* @llvm_zone_malloc(%mzone* %zone13167, i64 8)
%closure_wrapper13184 = bitcast i8* %wrapper_ptr13183 to { i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}**
store { i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure13169, { i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure_wrapper13184

; let value assignment
%xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure_wrapper13184, { i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure_wrapper13184
store { i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** %xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ, { i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}*** %xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr

; add data to environment
; don't need to alloc for env var xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ
%tmp_envptr13178 = getelementptr {{i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}***}* %environment13171, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}*** %xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr, {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}**** %tmp_envptr13178


%val13187 = load {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}**, {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}*** %xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr
ret {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** %val13187
}


@xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** @xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%XTMModel* %arg_0,i1 %arg_1,%String* %arg_2,%String* %arg_3,%String* %arg_4,%String* %arg_5,%String* %arg_6,%String* %arg_7) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*,  void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, i1 %arg_1, %String* %arg_2, %String* %arg_3, %String* %arg_4, %String* %arg_5, %String* %arg_6, %String* %arg_7)
ret void
}


define dllexport ccc void @xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_native(%XTMModel* %arg_0,i1 %arg_1,%String* %arg_2,%String* %arg_3,%String* %arg_4,%String* %arg_5,%String* %arg_6,%String* %arg_7) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*,  void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, i1 %arg_1, %String* %arg_2, %String* %arg_3, %String* %arg_4, %String* %arg_5, %String* %arg_6, %String* %arg_7)
ret void
}


define dllexport ccc i8*  @xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13188 = bitcast [166 x i8]* @gsxtmgraphics-pipeline554 to i8*
call i32 (i8*, ...) @printf(i8* %var13188)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %XTMModel*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var13189 = bitcast [166 x i8]* @gsxtmgraphics-pipeline554 to i8*
call i32 (i8*, ...) @printf(i8* %var13189)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i1  @i1value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var13190 = bitcast [166 x i8]* @gsxtmgraphics-pipeline554 to i8*
call i32 (i8*, ...) @printf(i8* %var13190)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %String*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var13191 = bitcast [166 x i8]* @gsxtmgraphics-pipeline554 to i8*
call i32 (i8*, ...) @printf(i8* %var13191)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to %String*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var13192 = bitcast [166 x i8]* @gsxtmgraphics-pipeline554 to i8*
call i32 (i8*, ...) @printf(i8* %var13192)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to %String*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var13193 = bitcast [166 x i8]* @gsxtmgraphics-pipeline554 to i8*
call i32 (i8*, ...) @printf(i8* %var13193)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to %String*
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var13194 = bitcast [166 x i8]* @gsxtmgraphics-pipeline554 to i8*
call i32 (i8*, ...) @printf(i8* %var13194)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to %String*
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_cptr(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var13195 = bitcast [166 x i8]* @gsxtmgraphics-pipeline554 to i8*
call i32 (i8*, ...) @printf(i8* %var13195)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%ttv_7 = call ccc i8* @cptr_value(i8* %arg_7_val)
%arg_7 = bitcast i8* %ttv_7 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*,  void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, i1 %arg_1, %String* %arg_2, %String* %arg_3, %String* %arg_4, %String* %arg_5, %String* %arg_6, %String* %arg_7)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*}*
%arg_p_0 = getelementptr {%XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*}, {%XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %XTMModel*, %XTMModel** %arg_p_0
%arg_p_1 = getelementptr {%XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*}, {%XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load i1, i1* %arg_p_1
%arg_p_2 = getelementptr {%XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*}, {%XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 2
%arg_2 = load %String*, %String** %arg_p_2
%arg_p_3 = getelementptr {%XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*}, {%XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 3
%arg_3 = load %String*, %String** %arg_p_3
%arg_p_4 = getelementptr {%XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*}, {%XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 4
%arg_4 = load %String*, %String** %arg_p_4
%arg_p_5 = getelementptr {%XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*}, {%XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 5
%arg_5 = load %String*, %String** %arg_p_5
%arg_p_6 = getelementptr {%XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*}, {%XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 6
%arg_6 = load %String*, %String** %arg_p_6
%arg_p_7 = getelementptr {%XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*}, {%XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 7
%arg_7 = load %String*, %String** %arg_p_7
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_skybox_init_adhoc_W3ZvaWQsWFRNTW9kZWwqLGkxLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*,  void (i8*, i8*, %XTMModel*, i1, %String*, %String*, %String*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %XTMModel* %arg_0, i1 %arg_1, %String* %arg_2, %String* %arg_3, %String* %arg_4, %String* %arg_5, %String* %arg_6, %String* %arg_7)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline555 = hidden constant [64 x i8] c"xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0\00"
@gsxtmgraphics-pipeline556 = hidden constant [62 x i8] c"{i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}**\00"
define dllexport fastcc void @xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0__13196(i8* %_impz,i8* %_impenv, %FBO* %fbo, float* %model, float* %view, float* %projection) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13197 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}***}*
%xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr = load {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}**** %xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr
%modelPtr = alloca float*
store float* %model, float** %modelPtr
%viewPtr = alloca float*
store float* %view, float** %viewPtr
%projectionPtr = alloca float*
store float* %projection, float** %projectionPtr


%tzone13199 = load i8*, i8** %_impzPtr
%zone13200 = bitcast i8* %tzone13199 to %mzone*

; let assign value to symbol shader
%shaderPtr = alloca %ShaderProgram*
%tzone13204 = load i8*, i8** %_impzPtr
%zone13205 = bitcast i8* %tzone13204 to %mzone*

; let assign value to symbol camera_pos
%camera_posPtr = alloca float*
%val13198 = load %ShaderProgram*, %ShaderProgram** @xtm_render_skybox_shader

; let value assignment
%shader = select i1 true, %ShaderProgram* %val13198, %ShaderProgram* %val13198
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr

%res13201 = call fastcc %xtm_camera* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ()
; tuple ref
%val13202 = getelementptr %xtm_camera, %xtm_camera* %res13201, i64 0, i32 0
%val13203 = load float*, float** %val13202

; let value assignment
%camera_pos = select i1 true, float* %val13203, float* %val13203
store float* %camera_pos, float** %camera_posPtr

%val13206 = load %FBO*, %FBO** %fboPtr
%res13207 = call fastcc i32 @bind_adhoc_W2kzMixGQk8qXQ(%FBO* %val13206)
%val13208 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
call fastcc void @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %val13208)
%val13210 = load float*, float** %modelPtr
call fastcc void @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %val13210)
%val13212 = load float*, float** %modelPtr
%val13213 = load float*, float** %camera_posPtr
; pointer ref
%val13214 = getelementptr float, float* %val13213, i64 0
%val13215 = load float, float* %val13214
%val13216 = load float*, float** %camera_posPtr
; pointer ref
%val13217 = getelementptr float, float* %val13216, i64 1
%val13218 = load float, float* %val13217
%val13219 = load float*, float** %camera_posPtr
; pointer ref
%val13220 = getelementptr float, float* %val13219, i64 2
%val13221 = load float, float* %val13220
%val13222 = load float, float* @SKY_BOX_SCALE
%val13223 = load float, float* @SKY_BOX_SCALE
%val13224 = load float, float* @SKY_BOX_SCALE
call fastcc void @fill_pos_scale_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ(float* %val13212, float %val13215, float %val13218, float %val13221, float %val13222, float %val13223, float %val13224)
%val13226 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val13227 = load float*, float** %modelPtr
%val13228 = load float*, float** %viewPtr
%val13229 = load float*, float** %projectionPtr
call fastcc void @shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd(%ShaderProgram* %val13226, float* %val13227, float* %val13228, float* %val13229)
%val13231 = load %Texture*, %Texture** @SKY_BOX_TEXTURE
%res13232 = call fastcc i32 @bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd(%Texture* %val13231, i32 0)
%val13233 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res13234 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val13233)
%var13235 = bitcast [5 x i8]* @gsxtmgraphics-pipeline526 to i8*
%res13236 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res13234, i8* %var13235)
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res13236, i32 0)
%val13238 = load %XTMModel*, %XTMModel** @SKY_BOX_MODEL
%val13239 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val13240 = load float*, float** %modelPtr
%val13241 = load float*, float** %viewPtr
%val13242 = load float*, float** %projectionPtr
call fastcc void @xtm_draw_model_adhoc_W3ZvaWQsWFRNTW9kZWwqLFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqXQ(%XTMModel* %val13238, %ShaderProgram* %val13239, float* %val13240, float* %val13241, float* %val13242)
%val13244 = load %Texture*, %Texture** @SKY_BOX_TEXTURE
call fastcc void @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ(%Texture* %val13244, i32 0)
%val13246 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
call fastcc void @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %val13246)
%val13248 = load %FBO*, %FBO** %fboPtr
%res13249 = call fastcc i32 @unbind_adhoc_W2kzMixGQk8qXQ(%FBO* %val13248)
ret void
}
@gsxtmgraphics-pipeline557 = hidden constant [117 x i8] c"xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}** @xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13270 = load i8*, i8** %_impzPtr
%zone13271 = bitcast i8* %tzone13270 to %mzone*

; let assign value to symbol xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0
%dat_xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone13271, i64 8)
%xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr = bitcast i8* %dat_xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 to { i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}***
%tzone13251 = load i8*, i8** %_impzPtr
%zone13252 = bitcast i8* %tzone13251 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13252)
; malloc closure structure
%clsptr13253 = call i8* @llvm_zone_malloc(%mzone* %zone13252, i64 24)
%closure13254 = bitcast i8* %clsptr13253 to { i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}*

; malloc environment structure
%envptr13255 = call i8* @llvm_zone_malloc(%mzone* %zone13252, i64 8)
%environment13256 = bitcast i8* %envptr13255 to {{i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}***}*

; malloc closure address table
%addytable13257 = call %clsvar* @new_address_table()
%var13258 = bitcast [64 x i8]* @gsxtmgraphics-pipeline555 to i8*
%var13259 = bitcast [62 x i8]* @gsxtmgraphics-pipeline556 to i8*
%addytable13260 = call %clsvar* @add_address_table(%mzone* %zone13252, i8* %var13258, i32 0, i8* %var13259, i32 3, %clsvar* %addytable13257)
%address-table13261 = bitcast %clsvar* %addytable13260 to i8*

; insert table, function and environment into closure struct
%closure.table13264 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}* %closure13254, i32 0, i32 0
store i8* %address-table13261, i8** %closure.table13264
%closure.env13265 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}* %closure13254, i32 0, i32 1
store i8* %envptr13255, i8** %closure.env13265
%closure.func13266 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}* %closure13254, i32 0, i32 2
store void (i8*, i8*, %FBO*, float*, float*, float*)* @xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0__13196, void (i8*, i8*, %FBO*, float*, float*, float*)** %closure.func13266
%closure_size13267 = call i64 @llvm_zone_mark_size(%mzone* %zone13252)
call void @llvm_zone_ptr_set_size(i8* %clsptr13253, i64 %closure_size13267)
%wrapper_ptr13268 = call i8* @llvm_zone_malloc(%mzone* %zone13252, i64 8)
%closure_wrapper13269 = bitcast i8* %wrapper_ptr13268 to { i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}* %closure13254, { i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}** %closure_wrapper13269

; let value assignment
%xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}** %closure_wrapper13269, { i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}** %closure_wrapper13269
store { i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}** %xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0, { i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}*** %xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr

; add data to environment
; don't need to alloc for env var xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0
%tmp_envptr13263 = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}***}* %environment13256, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}*** %xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr, {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}**** %tmp_envptr13263


%val13272 = load {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}*** %xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}** %val13272
}


@xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}** @xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(%FBO* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, float*, float*, float*)*,  void (i8*, i8*, %FBO*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
ret void
}


define dllexport ccc void @xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_native(%FBO* %arg_0,float* %arg_1,float* %arg_2,float* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, float*, float*, float*)*,  void (i8*, i8*, %FBO*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
ret void
}


define dllexport ccc i8*  @xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13273 = bitcast [117 x i8]* @gsxtmgraphics-pipeline557 to i8*
call i32 (i8*, ...) @printf(i8* %var13273)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var13274 = bitcast [117 x i8]* @gsxtmgraphics-pipeline557 to i8*
call i32 (i8*, ...) @printf(i8* %var13274)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var13275 = bitcast [117 x i8]* @gsxtmgraphics-pipeline557 to i8*
call i32 (i8*, ...) @printf(i8* %var13275)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to float*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var13276 = bitcast [117 x i8]* @gsxtmgraphics-pipeline557 to i8*
call i32 (i8*, ...) @printf(i8* %var13276)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, float*, float*, float*)*,  void (i8*, i8*, %FBO*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*, float*, float*, float*}*
%arg_p_0 = getelementptr {%FBO*, float*, float*, float*}, {%FBO*, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
%arg_p_1 = getelementptr {%FBO*, float*, float*, float*}, {%FBO*, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {%FBO*, float*, float*, float*}, {%FBO*, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float*, float** %arg_p_2
%arg_p_3 = getelementptr {%FBO*, float*, float*, float*}, {%FBO*, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float*, float** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, float*, float*, float*)*,  void (i8*, i8*, %FBO*, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, float* %arg_1, float* %arg_2, float* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@PROJECTION_TEXTURE = dllexport global %Texture* zeroinitializer
@PROJECTION_TEXTURE_ON = dllexport global i1 zeroinitializer
@gsxtmgraphics-pipeline558 = hidden constant [58 x i8] c"xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0\00"
@gsxtmgraphics-pipeline559 = hidden constant [45 x i8] c"{i8*, i8*, void (i8*, i8*, i1, %String*)*}**\00"
define dllexport fastcc void @xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0__13277(i8* %_impz,i8* %_impenv, i1 %flipped, %String* %filename) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13278 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i1, %String*)*}***}*
%xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i1, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, i1, %String*)*}***}* %impenv, i32 0, i32 0
%xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0Ptr = load {i8*, i8*, void (i8*, i8*, i1, %String*)*}***, {i8*, i8*, void (i8*, i8*, i1, %String*)*}**** %xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0Ptr_

; setup arguments
%flippedPtr = alloca i1
store i1 %flipped, i1* %flippedPtr
%filenamePtr = alloca %String*
store %String* %filename, %String** %filenamePtr


; do set!
%res13279 = call fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqXQ()
store %Texture* %res13279, %Texture** @PROJECTION_TEXTURE
%val13280 = load %Texture*, %Texture** @PROJECTION_TEXTURE
%val13281 = load i1, i1* %flippedPtr
%res13282 = call ccc i32 @i1toi32(i1 %val13281)
%val13283 = load %String*, %String** %filenamePtr
call fastcc void @load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd(%Texture* %val13280, i32 %res13282, %String* %val13283)
%val13285 = load %Texture*, %Texture** @PROJECTION_TEXTURE
call fastcc void @update_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val13285)
; do set!
%res13287 = call ccc i1 @impc_true()
store i1 %res13287, i1* @PROJECTION_TEXTURE_ON
; do set!
%val13288 = fptrunc double 0.50000000000000000000 to float
store float %val13288, float* @PROJECTION_TEXTURE_WEIGHT
ret void
}
@gsxtmgraphics-pipeline560 = hidden constant [111 x i8] c"xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i1, %String*)*}** @xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13309 = load i8*, i8** %_impzPtr
%zone13310 = bitcast i8* %tzone13309 to %mzone*

; let assign value to symbol xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0
%dat_xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone13310, i64 8)
%xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0Ptr = bitcast i8* %dat_xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0 to { i8*, i8*, void (i8*, i8*, i1, %String*)*}***
%tzone13290 = load i8*, i8** %_impzPtr
%zone13291 = bitcast i8* %tzone13290 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13291)
; malloc closure structure
%clsptr13292 = call i8* @llvm_zone_malloc(%mzone* %zone13291, i64 24)
%closure13293 = bitcast i8* %clsptr13292 to { i8*, i8*, void (i8*, i8*, i1, %String*)*}*

; malloc environment structure
%envptr13294 = call i8* @llvm_zone_malloc(%mzone* %zone13291, i64 8)
%environment13295 = bitcast i8* %envptr13294 to {{i8*, i8*, void (i8*, i8*, i1, %String*)*}***}*

; malloc closure address table
%addytable13296 = call %clsvar* @new_address_table()
%var13297 = bitcast [58 x i8]* @gsxtmgraphics-pipeline558 to i8*
%var13298 = bitcast [45 x i8]* @gsxtmgraphics-pipeline559 to i8*
%addytable13299 = call %clsvar* @add_address_table(%mzone* %zone13291, i8* %var13297, i32 0, i8* %var13298, i32 3, %clsvar* %addytable13296)
%address-table13300 = bitcast %clsvar* %addytable13299 to i8*

; insert table, function and environment into closure struct
%closure.table13303 = getelementptr { i8*, i8*, void (i8*, i8*, i1, %String*)*}, { i8*, i8*, void (i8*, i8*, i1, %String*)*}* %closure13293, i32 0, i32 0
store i8* %address-table13300, i8** %closure.table13303
%closure.env13304 = getelementptr { i8*, i8*, void (i8*, i8*, i1, %String*)*}, { i8*, i8*, void (i8*, i8*, i1, %String*)*}* %closure13293, i32 0, i32 1
store i8* %envptr13294, i8** %closure.env13304
%closure.func13305 = getelementptr { i8*, i8*, void (i8*, i8*, i1, %String*)*}, { i8*, i8*, void (i8*, i8*, i1, %String*)*}* %closure13293, i32 0, i32 2
store void (i8*, i8*, i1, %String*)* @xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0__13277, void (i8*, i8*, i1, %String*)** %closure.func13305
%closure_size13306 = call i64 @llvm_zone_mark_size(%mzone* %zone13291)
call void @llvm_zone_ptr_set_size(i8* %clsptr13292, i64 %closure_size13306)
%wrapper_ptr13307 = call i8* @llvm_zone_malloc(%mzone* %zone13291, i64 8)
%closure_wrapper13308 = bitcast i8* %wrapper_ptr13307 to { i8*, i8*, void (i8*, i8*, i1, %String*)*}**
store { i8*, i8*, void (i8*, i8*, i1, %String*)*}* %closure13293, { i8*, i8*, void (i8*, i8*, i1, %String*)*}** %closure_wrapper13308

; let value assignment
%xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, i1, %String*)*}** %closure_wrapper13308, { i8*, i8*, void (i8*, i8*, i1, %String*)*}** %closure_wrapper13308
store { i8*, i8*, void (i8*, i8*, i1, %String*)*}** %xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0, { i8*, i8*, void (i8*, i8*, i1, %String*)*}*** %xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0
%tmp_envptr13302 = getelementptr {{i8*, i8*, void (i8*, i8*, i1, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, i1, %String*)*}***}* %environment13295, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i1, %String*)*}*** %xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0Ptr, {i8*, i8*, void (i8*, i8*, i1, %String*)*}**** %tmp_envptr13302


%val13311 = load {i8*, i8*, void (i8*, i8*, i1, %String*)*}**, {i8*, i8*, void (i8*, i8*, i1, %String*)*}*** %xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0Ptr
ret {i8*, i8*, void (i8*, i8*, i1, %String*)*}** %val13311
}


@xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i1, %String*)*}** @xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i1, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0(i1 %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i1, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i1, %String*)*}*, {i8*, i8*, void (i8*, i8*, i1, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i1, %String*)*}, {i8*, i8*, void (i8*, i8*, i1, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i1, %String*)*}, {i8*, i8*, void (i8*, i8*, i1, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i1, %String*)*,  void (i8*, i8*, i1, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i1 %arg_0, %String* %arg_1)
ret void
}


define dllexport ccc void @xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0_native(i1 %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i1, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i1, %String*)*}*, {i8*, i8*, void (i8*, i8*, i1, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i1, %String*)*}, {i8*, i8*, void (i8*, i8*, i1, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i1, %String*)*}, {i8*, i8*, void (i8*, i8*, i1, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i1, %String*)*,  void (i8*, i8*, i1, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i1 %arg_0, %String* %arg_1)
ret void
}


define dllexport ccc i8*  @xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13312 = bitcast [111 x i8]* @gsxtmgraphics-pipeline560 to i8*
call i32 (i8*, ...) @printf(i8* %var13312)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i1  @i1value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var13313 = bitcast [111 x i8]* @gsxtmgraphics-pipeline560 to i8*
call i32 (i8*, ...) @printf(i8* %var13313)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i1, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i1, %String*)*}*, {i8*, i8*, void (i8*, i8*, i1, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i1, %String*)*}, {i8*, i8*, void (i8*, i8*, i1, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i1, %String*)*}, {i8*, i8*, void (i8*, i8*, i1, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i1, %String*)*,  void (i8*, i8*, i1, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i1 %arg_0, %String* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i1, %String*}*
%arg_p_0 = getelementptr {i1, %String*}, {i1, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load i1, i1* %arg_p_0
%arg_p_1 = getelementptr {i1, %String*}, {i1, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %String*, %String** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_projection_texture_load_adhoc_W3ZvaWQsaTEsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i1, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i1, %String*)*}*, {i8*, i8*, void (i8*, i8*, i1, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i1, %String*)*}, {i8*, i8*, void (i8*, i8*, i1, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i1, %String*)*}, {i8*, i8*, void (i8*, i8*, i1, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i1, %String*)*,  void (i8*, i8*, i1, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i1 %arg_0, %String* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline561 = hidden constant [52 x i8] c"xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd\00"
@gsxtmgraphics-pipeline562 = hidden constant [38 x i8] c"{i8*, i8*, void (i8*, i8*, float)*}**\00"
define dllexport fastcc void @xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd__13314(i8* %_impz,i8* %_impenv, float %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13315 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float)*}***}*
%xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float)*}***}, {{i8*, i8*, void (i8*, i8*, float)*}***}* %impenv, i32 0, i32 0
%xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRdPtr = load {i8*, i8*, void (i8*, i8*, float)*}***, {i8*, i8*, void (i8*, i8*, float)*}**** %xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRdPtr_

; setup arguments
%xPtr = alloca float
store float %x, float* %xPtr


; do set!
%val13316 = load float, float* %xPtr
store float %val13316, float* @PROJECTION_TEXTURE_WEIGHT
ret void
}
@gsxtmgraphics-pipeline563 = hidden constant [105 x i8] c"xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float)*}** @xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13337 = load i8*, i8** %_impzPtr
%zone13338 = bitcast i8* %tzone13337 to %mzone*

; let assign value to symbol xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd
%dat_xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone13338, i64 8)
%xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRdPtr = bitcast i8* %dat_xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd to { i8*, i8*, void (i8*, i8*, float)*}***
%tzone13318 = load i8*, i8** %_impzPtr
%zone13319 = bitcast i8* %tzone13318 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13319)
; malloc closure structure
%clsptr13320 = call i8* @llvm_zone_malloc(%mzone* %zone13319, i64 24)
%closure13321 = bitcast i8* %clsptr13320 to { i8*, i8*, void (i8*, i8*, float)*}*

; malloc environment structure
%envptr13322 = call i8* @llvm_zone_malloc(%mzone* %zone13319, i64 8)
%environment13323 = bitcast i8* %envptr13322 to {{i8*, i8*, void (i8*, i8*, float)*}***}*

; malloc closure address table
%addytable13324 = call %clsvar* @new_address_table()
%var13325 = bitcast [52 x i8]* @gsxtmgraphics-pipeline561 to i8*
%var13326 = bitcast [38 x i8]* @gsxtmgraphics-pipeline562 to i8*
%addytable13327 = call %clsvar* @add_address_table(%mzone* %zone13319, i8* %var13325, i32 0, i8* %var13326, i32 3, %clsvar* %addytable13324)
%address-table13328 = bitcast %clsvar* %addytable13327 to i8*

; insert table, function and environment into closure struct
%closure.table13331 = getelementptr { i8*, i8*, void (i8*, i8*, float)*}, { i8*, i8*, void (i8*, i8*, float)*}* %closure13321, i32 0, i32 0
store i8* %address-table13328, i8** %closure.table13331
%closure.env13332 = getelementptr { i8*, i8*, void (i8*, i8*, float)*}, { i8*, i8*, void (i8*, i8*, float)*}* %closure13321, i32 0, i32 1
store i8* %envptr13322, i8** %closure.env13332
%closure.func13333 = getelementptr { i8*, i8*, void (i8*, i8*, float)*}, { i8*, i8*, void (i8*, i8*, float)*}* %closure13321, i32 0, i32 2
store void (i8*, i8*, float)* @xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd__13314, void (i8*, i8*, float)** %closure.func13333
%closure_size13334 = call i64 @llvm_zone_mark_size(%mzone* %zone13319)
call void @llvm_zone_ptr_set_size(i8* %clsptr13320, i64 %closure_size13334)
%wrapper_ptr13335 = call i8* @llvm_zone_malloc(%mzone* %zone13319, i64 8)
%closure_wrapper13336 = bitcast i8* %wrapper_ptr13335 to { i8*, i8*, void (i8*, i8*, float)*}**
store { i8*, i8*, void (i8*, i8*, float)*}* %closure13321, { i8*, i8*, void (i8*, i8*, float)*}** %closure_wrapper13336

; let value assignment
%xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd = select i1 true, { i8*, i8*, void (i8*, i8*, float)*}** %closure_wrapper13336, { i8*, i8*, void (i8*, i8*, float)*}** %closure_wrapper13336
store { i8*, i8*, void (i8*, i8*, float)*}** %xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd, { i8*, i8*, void (i8*, i8*, float)*}*** %xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd
%tmp_envptr13330 = getelementptr {{i8*, i8*, void (i8*, i8*, float)*}***}, {{i8*, i8*, void (i8*, i8*, float)*}***}* %environment13323, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float)*}*** %xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRdPtr, {i8*, i8*, void (i8*, i8*, float)*}**** %tmp_envptr13330


%val13339 = load {i8*, i8*, void (i8*, i8*, float)*}**, {i8*, i8*, void (i8*, i8*, float)*}*** %xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRdPtr
ret {i8*, i8*, void (i8*, i8*, float)*}** %val13339
}


@xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float)*}** @xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd(float %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float)*}*, {i8*, i8*, void (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float)*,  void (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0)
ret void
}


define dllexport ccc void @xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd_native(float %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float)*}*, {i8*, i8*, void (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float)*,  void (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0)
ret void
}


define dllexport ccc i8*  @xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13340 = bitcast [105 x i8]* @gsxtmgraphics-pipeline563 to i8*
call i32 (i8*, ...) @printf(i8* %var13340)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float)*}*, {i8*, i8*, void (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float)*,  void (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float}*
%arg_p_0 = getelementptr {float}, {float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_projecton_texture_weight_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float)*}*, {i8*, i8*, void (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float)*,  void (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@ENV_MAP_TEXTURE = dllexport global %Texture* zeroinitializer
@ENV_MAP = dllexport global i1 zeroinitializer
@gsxtmgraphics-pipeline564 = hidden constant [99 x i8] c"xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd\00"
@gsxtmgraphics-pipeline565 = hidden constant [95 x i8] c"{i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}**\00"
define dllexport fastcc void @xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd__13341(i8* %_impz,i8* %_impenv, i1 %flipped, %String* %front, %String* %back, %String* %top, %String* %bottom, %String* %left, %String* %right) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13342 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}***}*
%xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}***}* %impenv, i32 0, i32 0
%xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr = load {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}***, {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}**** %xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr_

; setup arguments
%flippedPtr = alloca i1
store i1 %flipped, i1* %flippedPtr
%frontPtr = alloca %String*
store %String* %front, %String** %frontPtr
%backPtr = alloca %String*
store %String* %back, %String** %backPtr
%topPtr = alloca %String*
store %String* %top, %String** %topPtr
%bottomPtr = alloca %String*
store %String* %bottom, %String** %bottomPtr
%leftPtr = alloca %String*
store %String* %left, %String** %leftPtr
%rightPtr = alloca %String*
store %String* %right, %String** %rightPtr


; do set!
%res13343 = call fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqXQ()
store %Texture* %res13343, %Texture** @ENV_MAP_TEXTURE
%val13344 = load %Texture*, %Texture** @ENV_MAP_TEXTURE
%val13345 = load i1, i1* %flippedPtr
%res13346 = call ccc i32 @i1toi32(i1 %val13345)
%val13347 = load %String*, %String** %frontPtr
%val13348 = load %String*, %String** %backPtr
%val13349 = load %String*, %String** %topPtr
%val13350 = load %String*, %String** %bottomPtr
%val13351 = load %String*, %String** %leftPtr
%val13352 = load %String*, %String** %rightPtr
call fastcc void @load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%Texture* %val13344, i32 %res13346, %String* %val13347, %String* %val13348, %String* %val13349, %String* %val13350, %String* %val13351, %String* %val13352)
%val13354 = load %Texture*, %Texture** @ENV_MAP_TEXTURE
call fastcc void @update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val13354)
; do set!
%res13356 = call ccc i1 @impc_true()
store i1 %res13356, i1* @ENV_MAP
; do set!
%val13357 = fptrunc double 1.0000000000000000000 to float
store float %val13357, float* @ENV_MAP_WEIGHT
ret void
}
@gsxtmgraphics-pipeline566 = hidden constant [152 x i8] c"xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** @xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13378 = load i8*, i8** %_impzPtr
%zone13379 = bitcast i8* %tzone13378 to %mzone*

; let assign value to symbol xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd
%dat_xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone13379, i64 8)
%xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr = bitcast i8* %dat_xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd to { i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}***
%tzone13359 = load i8*, i8** %_impzPtr
%zone13360 = bitcast i8* %tzone13359 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13360)
; malloc closure structure
%clsptr13361 = call i8* @llvm_zone_malloc(%mzone* %zone13360, i64 24)
%closure13362 = bitcast i8* %clsptr13361 to { i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}*

; malloc environment structure
%envptr13363 = call i8* @llvm_zone_malloc(%mzone* %zone13360, i64 8)
%environment13364 = bitcast i8* %envptr13363 to {{i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}***}*

; malloc closure address table
%addytable13365 = call %clsvar* @new_address_table()
%var13366 = bitcast [99 x i8]* @gsxtmgraphics-pipeline564 to i8*
%var13367 = bitcast [95 x i8]* @gsxtmgraphics-pipeline565 to i8*
%addytable13368 = call %clsvar* @add_address_table(%mzone* %zone13360, i8* %var13366, i32 0, i8* %var13367, i32 3, %clsvar* %addytable13365)
%address-table13369 = bitcast %clsvar* %addytable13368 to i8*

; insert table, function and environment into closure struct
%closure.table13372 = getelementptr { i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, { i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure13362, i32 0, i32 0
store i8* %address-table13369, i8** %closure.table13372
%closure.env13373 = getelementptr { i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, { i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure13362, i32 0, i32 1
store i8* %envptr13363, i8** %closure.env13373
%closure.func13374 = getelementptr { i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, { i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure13362, i32 0, i32 2
store void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)* @xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd__13341, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)** %closure.func13374
%closure_size13375 = call i64 @llvm_zone_mark_size(%mzone* %zone13360)
call void @llvm_zone_ptr_set_size(i8* %clsptr13361, i64 %closure_size13375)
%wrapper_ptr13376 = call i8* @llvm_zone_malloc(%mzone* %zone13360, i64 8)
%closure_wrapper13377 = bitcast i8* %wrapper_ptr13376 to { i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}**
store { i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure13362, { i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure_wrapper13377

; let value assignment
%xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd = select i1 true, { i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure_wrapper13377, { i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure_wrapper13377
store { i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** %xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd, { i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}*** %xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr

; add data to environment
; don't need to alloc for env var xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd
%tmp_envptr13371 = getelementptr {{i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}***}* %environment13364, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}*** %xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr, {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}**** %tmp_envptr13371


%val13380 = load {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}**, {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}*** %xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr
ret {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** %val13380
}


@xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** @xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd(i1 %arg_0,%String* %arg_1,%String* %arg_2,%String* %arg_3,%String* %arg_4,%String* %arg_5,%String* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}*, {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*,  void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i1 %arg_0, %String* %arg_1, %String* %arg_2, %String* %arg_3, %String* %arg_4, %String* %arg_5, %String* %arg_6)
ret void
}


define dllexport ccc void @xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_native(i1 %arg_0,%String* %arg_1,%String* %arg_2,%String* %arg_3,%String* %arg_4,%String* %arg_5,%String* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}*, {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*,  void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i1 %arg_0, %String* %arg_1, %String* %arg_2, %String* %arg_3, %String* %arg_4, %String* %arg_5, %String* %arg_6)
ret void
}


define dllexport ccc i8*  @xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13381 = bitcast [152 x i8]* @gsxtmgraphics-pipeline566 to i8*
call i32 (i8*, ...) @printf(i8* %var13381)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i1  @i1value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var13382 = bitcast [152 x i8]* @gsxtmgraphics-pipeline566 to i8*
call i32 (i8*, ...) @printf(i8* %var13382)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %String*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var13383 = bitcast [152 x i8]* @gsxtmgraphics-pipeline566 to i8*
call i32 (i8*, ...) @printf(i8* %var13383)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %String*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var13384 = bitcast [152 x i8]* @gsxtmgraphics-pipeline566 to i8*
call i32 (i8*, ...) @printf(i8* %var13384)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to %String*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var13385 = bitcast [152 x i8]* @gsxtmgraphics-pipeline566 to i8*
call i32 (i8*, ...) @printf(i8* %var13385)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to %String*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var13386 = bitcast [152 x i8]* @gsxtmgraphics-pipeline566 to i8*
call i32 (i8*, ...) @printf(i8* %var13386)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to %String*
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var13387 = bitcast [152 x i8]* @gsxtmgraphics-pipeline566 to i8*
call i32 (i8*, ...) @printf(i8* %var13387)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}*, {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*,  void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i1 %arg_0, %String* %arg_1, %String* %arg_2, %String* %arg_3, %String* %arg_4, %String* %arg_5, %String* %arg_6)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i1, %String*, %String*, %String*, %String*, %String*, %String*}*
%arg_p_0 = getelementptr {i1, %String*, %String*, %String*, %String*, %String*, %String*}, {i1, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load i1, i1* %arg_p_0
%arg_p_1 = getelementptr {i1, %String*, %String*, %String*, %String*, %String*, %String*}, {i1, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %String*, %String** %arg_p_1
%arg_p_2 = getelementptr {i1, %String*, %String*, %String*, %String*, %String*, %String*}, {i1, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 2
%arg_2 = load %String*, %String** %arg_p_2
%arg_p_3 = getelementptr {i1, %String*, %String*, %String*, %String*, %String*, %String*}, {i1, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 3
%arg_3 = load %String*, %String** %arg_p_3
%arg_p_4 = getelementptr {i1, %String*, %String*, %String*, %String*, %String*, %String*}, {i1, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 4
%arg_4 = load %String*, %String** %arg_p_4
%arg_p_5 = getelementptr {i1, %String*, %String*, %String*, %String*, %String*, %String*}, {i1, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 5
%arg_5 = load %String*, %String** %arg_p_5
%arg_p_6 = getelementptr {i1, %String*, %String*, %String*, %String*, %String*, %String*}, {i1, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 6
%arg_6 = load %String*, %String** %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_envmap_init_adhoc_W3ZvaWQsaTEsU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}*, {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)*,  void (i8*, i8*, i1, %String*, %String*, %String*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i1 %arg_0, %String* %arg_1, %String* %arg_2, %String* %arg_3, %String* %arg_4, %String* %arg_5, %String* %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline567 = hidden constant [41 x i8] c"xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd\00"
define dllexport fastcc void @xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd__13388(i8* %_impz,i8* %_impenv, float %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13389 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float)*}***}*
%xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float)*}***}, {{i8*, i8*, void (i8*, i8*, float)*}***}* %impenv, i32 0, i32 0
%xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRdPtr = load {i8*, i8*, void (i8*, i8*, float)*}***, {i8*, i8*, void (i8*, i8*, float)*}**** %xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRdPtr_

; setup arguments
%xPtr = alloca float
store float %x, float* %xPtr


; do set!
%val13390 = load float, float* %xPtr
store float %val13390, float* @ENV_MAP_WEIGHT
ret void
}
@gsxtmgraphics-pipeline568 = hidden constant [94 x i8] c"xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float)*}** @xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13411 = load i8*, i8** %_impzPtr
%zone13412 = bitcast i8* %tzone13411 to %mzone*

; let assign value to symbol xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd
%dat_xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone13412, i64 8)
%xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRdPtr = bitcast i8* %dat_xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd to { i8*, i8*, void (i8*, i8*, float)*}***
%tzone13392 = load i8*, i8** %_impzPtr
%zone13393 = bitcast i8* %tzone13392 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13393)
; malloc closure structure
%clsptr13394 = call i8* @llvm_zone_malloc(%mzone* %zone13393, i64 24)
%closure13395 = bitcast i8* %clsptr13394 to { i8*, i8*, void (i8*, i8*, float)*}*

; malloc environment structure
%envptr13396 = call i8* @llvm_zone_malloc(%mzone* %zone13393, i64 8)
%environment13397 = bitcast i8* %envptr13396 to {{i8*, i8*, void (i8*, i8*, float)*}***}*

; malloc closure address table
%addytable13398 = call %clsvar* @new_address_table()
%var13399 = bitcast [41 x i8]* @gsxtmgraphics-pipeline567 to i8*
%var13400 = bitcast [38 x i8]* @gsxtmgraphics-pipeline562 to i8*
%addytable13401 = call %clsvar* @add_address_table(%mzone* %zone13393, i8* %var13399, i32 0, i8* %var13400, i32 3, %clsvar* %addytable13398)
%address-table13402 = bitcast %clsvar* %addytable13401 to i8*

; insert table, function and environment into closure struct
%closure.table13405 = getelementptr { i8*, i8*, void (i8*, i8*, float)*}, { i8*, i8*, void (i8*, i8*, float)*}* %closure13395, i32 0, i32 0
store i8* %address-table13402, i8** %closure.table13405
%closure.env13406 = getelementptr { i8*, i8*, void (i8*, i8*, float)*}, { i8*, i8*, void (i8*, i8*, float)*}* %closure13395, i32 0, i32 1
store i8* %envptr13396, i8** %closure.env13406
%closure.func13407 = getelementptr { i8*, i8*, void (i8*, i8*, float)*}, { i8*, i8*, void (i8*, i8*, float)*}* %closure13395, i32 0, i32 2
store void (i8*, i8*, float)* @xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd__13388, void (i8*, i8*, float)** %closure.func13407
%closure_size13408 = call i64 @llvm_zone_mark_size(%mzone* %zone13393)
call void @llvm_zone_ptr_set_size(i8* %clsptr13394, i64 %closure_size13408)
%wrapper_ptr13409 = call i8* @llvm_zone_malloc(%mzone* %zone13393, i64 8)
%closure_wrapper13410 = bitcast i8* %wrapper_ptr13409 to { i8*, i8*, void (i8*, i8*, float)*}**
store { i8*, i8*, void (i8*, i8*, float)*}* %closure13395, { i8*, i8*, void (i8*, i8*, float)*}** %closure_wrapper13410

; let value assignment
%xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd = select i1 true, { i8*, i8*, void (i8*, i8*, float)*}** %closure_wrapper13410, { i8*, i8*, void (i8*, i8*, float)*}** %closure_wrapper13410
store { i8*, i8*, void (i8*, i8*, float)*}** %xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd, { i8*, i8*, void (i8*, i8*, float)*}*** %xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd
%tmp_envptr13404 = getelementptr {{i8*, i8*, void (i8*, i8*, float)*}***}, {{i8*, i8*, void (i8*, i8*, float)*}***}* %environment13397, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float)*}*** %xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRdPtr, {i8*, i8*, void (i8*, i8*, float)*}**** %tmp_envptr13404


%val13413 = load {i8*, i8*, void (i8*, i8*, float)*}**, {i8*, i8*, void (i8*, i8*, float)*}*** %xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRdPtr
ret {i8*, i8*, void (i8*, i8*, float)*}** %val13413
}


@xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float)*}** @xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd(float %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float)*}*, {i8*, i8*, void (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float)*,  void (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0)
ret void
}


define dllexport ccc void @xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd_native(float %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float)*}*, {i8*, i8*, void (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float)*,  void (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0)
ret void
}


define dllexport ccc i8*  @xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13414 = bitcast [94 x i8]* @gsxtmgraphics-pipeline568 to i8*
call i32 (i8*, ...) @printf(i8* %var13414)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float)*}*, {i8*, i8*, void (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float)*,  void (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float}*
%arg_p_0 = getelementptr {float}, {float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_envmap_weight_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float)*}*, {i8*, i8*, void (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float)*,  void (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline569 = hidden constant [36 x i8] c"xtm_envmap_as_skybox_adhoc_W3ZvaWRd\00"
define dllexport fastcc void @xtm_envmap_as_skybox_adhoc_W3ZvaWRd__13415(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13416 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*)*}***}*
%xtm_envmap_as_skybox_adhoc_W3ZvaWRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%xtm_envmap_as_skybox_adhoc_W3ZvaWRdPtr = load {i8*, i8*, void (i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*)*}**** %xtm_envmap_as_skybox_adhoc_W3ZvaWRdPtr_

; setup arguments


; do set!
%val13417 = load %Texture*, %Texture** @SKY_BOX_TEXTURE
store %Texture* %val13417, %Texture** @ENV_MAP_TEXTURE
; do set!
%res13418 = call ccc i1 @impc_true()
store i1 %res13418, i1* @ENV_MAP
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*)*}** @xtm_envmap_as_skybox_adhoc_W3ZvaWRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13439 = load i8*, i8** %_impzPtr
%zone13440 = bitcast i8* %tzone13439 to %mzone*

; let assign value to symbol xtm_envmap_as_skybox_adhoc_W3ZvaWRd
%dat_xtm_envmap_as_skybox_adhoc_W3ZvaWRd = call i8* @llvm_zone_malloc(%mzone* %zone13440, i64 8)
%xtm_envmap_as_skybox_adhoc_W3ZvaWRdPtr = bitcast i8* %dat_xtm_envmap_as_skybox_adhoc_W3ZvaWRd to { i8*, i8*, void (i8*, i8*)*}***
%tzone13420 = load i8*, i8** %_impzPtr
%zone13421 = bitcast i8* %tzone13420 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13421)
; malloc closure structure
%clsptr13422 = call i8* @llvm_zone_malloc(%mzone* %zone13421, i64 24)
%closure13423 = bitcast i8* %clsptr13422 to { i8*, i8*, void (i8*, i8*)*}*

; malloc environment structure
%envptr13424 = call i8* @llvm_zone_malloc(%mzone* %zone13421, i64 8)
%environment13425 = bitcast i8* %envptr13424 to {{i8*, i8*, void (i8*, i8*)*}***}*

; malloc closure address table
%addytable13426 = call %clsvar* @new_address_table()
%var13427 = bitcast [36 x i8]* @gsxtmgraphics-pipeline569 to i8*
%var13428 = bitcast [31 x i8]* @gsxtmgraphics-pipeline525 to i8*
%addytable13429 = call %clsvar* @add_address_table(%mzone* %zone13421, i8* %var13427, i32 0, i8* %var13428, i32 3, %clsvar* %addytable13426)
%address-table13430 = bitcast %clsvar* %addytable13429 to i8*

; insert table, function and environment into closure struct
%closure.table13433 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure13423, i32 0, i32 0
store i8* %address-table13430, i8** %closure.table13433
%closure.env13434 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure13423, i32 0, i32 1
store i8* %envptr13424, i8** %closure.env13434
%closure.func13435 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure13423, i32 0, i32 2
store void (i8*, i8*)* @xtm_envmap_as_skybox_adhoc_W3ZvaWRd__13415, void (i8*, i8*)** %closure.func13435
%closure_size13436 = call i64 @llvm_zone_mark_size(%mzone* %zone13421)
call void @llvm_zone_ptr_set_size(i8* %clsptr13422, i64 %closure_size13436)
%wrapper_ptr13437 = call i8* @llvm_zone_malloc(%mzone* %zone13421, i64 8)
%closure_wrapper13438 = bitcast i8* %wrapper_ptr13437 to { i8*, i8*, void (i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*)*}* %closure13423, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper13438

; let value assignment
%xtm_envmap_as_skybox_adhoc_W3ZvaWRd = select i1 true, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper13438, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper13438
store { i8*, i8*, void (i8*, i8*)*}** %xtm_envmap_as_skybox_adhoc_W3ZvaWRd, { i8*, i8*, void (i8*, i8*)*}*** %xtm_envmap_as_skybox_adhoc_W3ZvaWRdPtr

; add data to environment
; don't need to alloc for env var xtm_envmap_as_skybox_adhoc_W3ZvaWRd
%tmp_envptr13432 = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %environment13425, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*)*}*** %xtm_envmap_as_skybox_adhoc_W3ZvaWRdPtr, {i8*, i8*, void (i8*, i8*)*}**** %tmp_envptr13432


%val13441 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %xtm_envmap_as_skybox_adhoc_W3ZvaWRdPtr
ret {i8*, i8*, void (i8*, i8*)*}** %val13441
}


@xtm_envmap_as_skybox_adhoc_W3ZvaWRd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_envmap_as_skybox_adhoc_W3ZvaWRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_envmap_as_skybox_adhoc_W3ZvaWRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_envmap_as_skybox_adhoc_W3ZvaWRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*)*}** @xtm_envmap_as_skybox_adhoc_W3ZvaWRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_envmap_as_skybox_adhoc_W3ZvaWRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_envmap_as_skybox_adhoc_W3ZvaWRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_envmap_as_skybox_adhoc_W3ZvaWRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_envmap_as_skybox_adhoc_W3ZvaWRd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_envmap_as_skybox_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc void @xtm_envmap_as_skybox_adhoc_W3ZvaWRd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_envmap_as_skybox_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc i8*  @xtm_envmap_as_skybox_adhoc_W3ZvaWRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_envmap_as_skybox_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_envmap_as_skybox_adhoc_W3ZvaWRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_envmap_as_skybox_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@XTM_DOF_ON = dllexport global i1 zeroinitializer
@XTM_DOF_DEBUG = dllexport global i1 zeroinitializer
@XTM_DOF_AUTOFOCUS = dllexport global i1 zeroinitializer
@XTM_DOF_DISTANCE = dllexport global float 0x0
@XTM_DOF_X = dllexport global float 0x3fe0000000000000
@XTM_DOF_Y = dllexport global float 0x3fe0000000000000
@XTM_DOF_FSTOP = dllexport global float 0x4010000000000000
@XTM_DOF_FLENGTH = dllexport global float 0x4049000000000000
@gsxtmgraphics-pipeline570 = hidden constant [51 x i8] c"xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd\00"
@gsxtmgraphics-pipeline571 = hidden constant [56 x i8] c"{i8*, i8*, void (i8*, i8*, float, float, float, i1)*}**\00"
define dllexport fastcc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd__13442(i8* %_impz,i8* %_impenv, float %distance, float %fstop, float %flength, i1 %debug) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13443 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float, float, float, i1)*}***}*
%xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float, float, float, i1)*}***}, {{i8*, i8*, void (i8*, i8*, float, float, float, i1)*}***}* %impenv, i32 0, i32 0
%xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFdPtr = load {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}***, {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}**** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFdPtr_

; setup arguments
%distancePtr = alloca float
store float %distance, float* %distancePtr
%fstopPtr = alloca float
store float %fstop, float* %fstopPtr
%flengthPtr = alloca float
store float %flength, float* %flengthPtr
%debugPtr = alloca i1
store i1 %debug, i1* %debugPtr


; do set!
%res13444 = call ccc i1 @impc_true()
store i1 %res13444, i1* @XTM_DOF_ON
; do set!
%val13445 = load i1, i1* %debugPtr
store i1 %val13445, i1* @XTM_DOF_DEBUG
; do set!
%res13446 = call ccc i1 @impc_false()
store i1 %res13446, i1* @XTM_DOF_AUTOFOCUS
; do set!
%val13447 = load float, float* %distancePtr
store float %val13447, float* @XTM_DOF_DISTANCE
; do set!
%val13448 = load float, float* %fstopPtr
store float %val13448, float* @XTM_DOF_FSTOP
; do set!
%val13449 = load float, float* %flengthPtr
store float %val13449, float* @XTM_DOF_FLENGTH
ret void
}
@gsxtmgraphics-pipeline572 = hidden constant [104 x i8] c"xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}** @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13470 = load i8*, i8** %_impzPtr
%zone13471 = bitcast i8* %tzone13470 to %mzone*

; let assign value to symbol xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd
%dat_xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd = call i8* @llvm_zone_malloc(%mzone* %zone13471, i64 8)
%xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFdPtr = bitcast i8* %dat_xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd to { i8*, i8*, void (i8*, i8*, float, float, float, i1)*}***
%tzone13451 = load i8*, i8** %_impzPtr
%zone13452 = bitcast i8* %tzone13451 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13452)
; malloc closure structure
%clsptr13453 = call i8* @llvm_zone_malloc(%mzone* %zone13452, i64 24)
%closure13454 = bitcast i8* %clsptr13453 to { i8*, i8*, void (i8*, i8*, float, float, float, i1)*}*

; malloc environment structure
%envptr13455 = call i8* @llvm_zone_malloc(%mzone* %zone13452, i64 8)
%environment13456 = bitcast i8* %envptr13455 to {{i8*, i8*, void (i8*, i8*, float, float, float, i1)*}***}*

; malloc closure address table
%addytable13457 = call %clsvar* @new_address_table()
%var13458 = bitcast [51 x i8]* @gsxtmgraphics-pipeline570 to i8*
%var13459 = bitcast [56 x i8]* @gsxtmgraphics-pipeline571 to i8*
%addytable13460 = call %clsvar* @add_address_table(%mzone* %zone13452, i8* %var13458, i32 0, i8* %var13459, i32 3, %clsvar* %addytable13457)
%address-table13461 = bitcast %clsvar* %addytable13460 to i8*

; insert table, function and environment into closure struct
%closure.table13464 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float, i1)*}, { i8*, i8*, void (i8*, i8*, float, float, float, i1)*}* %closure13454, i32 0, i32 0
store i8* %address-table13461, i8** %closure.table13464
%closure.env13465 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float, i1)*}, { i8*, i8*, void (i8*, i8*, float, float, float, i1)*}* %closure13454, i32 0, i32 1
store i8* %envptr13455, i8** %closure.env13465
%closure.func13466 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float, i1)*}, { i8*, i8*, void (i8*, i8*, float, float, float, i1)*}* %closure13454, i32 0, i32 2
store void (i8*, i8*, float, float, float, i1)* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd__13442, void (i8*, i8*, float, float, float, i1)** %closure.func13466
%closure_size13467 = call i64 @llvm_zone_mark_size(%mzone* %zone13452)
call void @llvm_zone_ptr_set_size(i8* %clsptr13453, i64 %closure_size13467)
%wrapper_ptr13468 = call i8* @llvm_zone_malloc(%mzone* %zone13452, i64 8)
%closure_wrapper13469 = bitcast i8* %wrapper_ptr13468 to { i8*, i8*, void (i8*, i8*, float, float, float, i1)*}**
store { i8*, i8*, void (i8*, i8*, float, float, float, i1)*}* %closure13454, { i8*, i8*, void (i8*, i8*, float, float, float, i1)*}** %closure_wrapper13469

; let value assignment
%xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd = select i1 true, { i8*, i8*, void (i8*, i8*, float, float, float, i1)*}** %closure_wrapper13469, { i8*, i8*, void (i8*, i8*, float, float, float, i1)*}** %closure_wrapper13469
store { i8*, i8*, void (i8*, i8*, float, float, float, i1)*}** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd, { i8*, i8*, void (i8*, i8*, float, float, float, i1)*}*** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFdPtr

; add data to environment
; don't need to alloc for env var xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd
%tmp_envptr13463 = getelementptr {{i8*, i8*, void (i8*, i8*, float, float, float, i1)*}***}, {{i8*, i8*, void (i8*, i8*, float, float, float, i1)*}***}* %environment13456, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}*** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFdPtr, {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}**** %tmp_envptr13463


%val13472 = load {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}**, {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}*** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFdPtr
ret {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}** %val13472
}


@xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}** @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd(float %arg_0,float %arg_1,float %arg_2,i1 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}*, {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}, {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}, {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float, i1)*,  void (i8*, i8*, float, float, float, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, i1 %arg_3)
ret void
}


define dllexport ccc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_native(float %arg_0,float %arg_1,float %arg_2,i1 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}*, {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}, {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}, {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float, i1)*,  void (i8*, i8*, float, float, float, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, i1 %arg_3)
ret void
}


define dllexport ccc i8*  @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13473 = bitcast [104 x i8]* @gsxtmgraphics-pipeline572 to i8*
call i32 (i8*, ...) @printf(i8* %var13473)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var13474 = bitcast [104 x i8]* @gsxtmgraphics-pipeline572 to i8*
call i32 (i8*, ...) @printf(i8* %var13474)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var13475 = bitcast [104 x i8]* @gsxtmgraphics-pipeline572 to i8*
call i32 (i8*, ...) @printf(i8* %var13475)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var13476 = bitcast [104 x i8]* @gsxtmgraphics-pipeline572 to i8*
call i32 (i8*, ...) @printf(i8* %var13476)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i1  @i1value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}*, {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}, {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}, {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float, i1)*,  void (i8*, i8*, float, float, float, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, i1 %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float, float, i1}*
%arg_p_0 = getelementptr {float, float, float, i1}, {float, float, float, i1}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float, float, i1}, {float, float, float, i1}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float, float, float, i1}, {float, float, float, i1}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float, float, float, i1}, {float, float, float, i1}* %fstruct, i32 0, i32 3
%arg_3 = load i1, i1* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}*, {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}, {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}, {i8*, i8*, void (i8*, i8*, float, float, float, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float, i1)*,  void (i8*, i8*, float, float, float, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, i1 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline573 = hidden constant [59 x i8] c"xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd\00"
@gsxtmgraphics-pipeline574 = hidden constant [63 x i8] c"{i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}**\00"
define dllexport fastcc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd__13477(i8* %_impz,i8* %_impenv, float %x, float %y, float %fstop, float %flength, i1 %debug) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13478 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}***}*
%xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}***}, {{i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}***}* %impenv, i32 0, i32 0
%xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFdPtr = load {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}***, {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}**** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFdPtr_

; setup arguments
%xPtr = alloca float
store float %x, float* %xPtr
%yPtr = alloca float
store float %y, float* %yPtr
%fstopPtr = alloca float
store float %fstop, float* %fstopPtr
%flengthPtr = alloca float
store float %flength, float* %flengthPtr
%debugPtr = alloca i1
store i1 %debug, i1* %debugPtr


; do set!
%res13479 = call ccc i1 @impc_true()
store i1 %res13479, i1* @XTM_DOF_ON
; do set!
%val13480 = load i1, i1* %debugPtr
store i1 %val13480, i1* @XTM_DOF_DEBUG
; do set!
%res13481 = call ccc i1 @impc_true()
store i1 %res13481, i1* @XTM_DOF_AUTOFOCUS
; do set!
%val13482 = load float, float* %xPtr
store float %val13482, float* @XTM_DOF_X
; do set!
%val13483 = load float, float* %yPtr
store float %val13483, float* @XTM_DOF_X
; do set!
%val13484 = load float, float* %fstopPtr
store float %val13484, float* @XTM_DOF_FSTOP
; do set!
%val13485 = load float, float* %flengthPtr
store float %val13485, float* @XTM_DOF_FLENGTH
ret void
}
@gsxtmgraphics-pipeline575 = hidden constant [112 x i8] c"xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}** @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13506 = load i8*, i8** %_impzPtr
%zone13507 = bitcast i8* %tzone13506 to %mzone*

; let assign value to symbol xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd
%dat_xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd = call i8* @llvm_zone_malloc(%mzone* %zone13507, i64 8)
%xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFdPtr = bitcast i8* %dat_xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd to { i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}***
%tzone13487 = load i8*, i8** %_impzPtr
%zone13488 = bitcast i8* %tzone13487 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13488)
; malloc closure structure
%clsptr13489 = call i8* @llvm_zone_malloc(%mzone* %zone13488, i64 24)
%closure13490 = bitcast i8* %clsptr13489 to { i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}*

; malloc environment structure
%envptr13491 = call i8* @llvm_zone_malloc(%mzone* %zone13488, i64 8)
%environment13492 = bitcast i8* %envptr13491 to {{i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}***}*

; malloc closure address table
%addytable13493 = call %clsvar* @new_address_table()
%var13494 = bitcast [59 x i8]* @gsxtmgraphics-pipeline573 to i8*
%var13495 = bitcast [63 x i8]* @gsxtmgraphics-pipeline574 to i8*
%addytable13496 = call %clsvar* @add_address_table(%mzone* %zone13488, i8* %var13494, i32 0, i8* %var13495, i32 3, %clsvar* %addytable13493)
%address-table13497 = bitcast %clsvar* %addytable13496 to i8*

; insert table, function and environment into closure struct
%closure.table13500 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}, { i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}* %closure13490, i32 0, i32 0
store i8* %address-table13497, i8** %closure.table13500
%closure.env13501 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}, { i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}* %closure13490, i32 0, i32 1
store i8* %envptr13491, i8** %closure.env13501
%closure.func13502 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}, { i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}* %closure13490, i32 0, i32 2
store void (i8*, i8*, float, float, float, float, i1)* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd__13477, void (i8*, i8*, float, float, float, float, i1)** %closure.func13502
%closure_size13503 = call i64 @llvm_zone_mark_size(%mzone* %zone13488)
call void @llvm_zone_ptr_set_size(i8* %clsptr13489, i64 %closure_size13503)
%wrapper_ptr13504 = call i8* @llvm_zone_malloc(%mzone* %zone13488, i64 8)
%closure_wrapper13505 = bitcast i8* %wrapper_ptr13504 to { i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}**
store { i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}* %closure13490, { i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}** %closure_wrapper13505

; let value assignment
%xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd = select i1 true, { i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}** %closure_wrapper13505, { i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}** %closure_wrapper13505
store { i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd, { i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}*** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFdPtr

; add data to environment
; don't need to alloc for env var xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd
%tmp_envptr13499 = getelementptr {{i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}***}, {{i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}***}* %environment13492, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}*** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFdPtr, {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}**** %tmp_envptr13499


%val13508 = load {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}**, {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}*** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFdPtr
ret {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}** %val13508
}


@xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}** @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd(float %arg_0,float %arg_1,float %arg_2,float %arg_3,i1 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}*, {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float, float, i1)*,  void (i8*, i8*, float, float, float, float, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3, i1 %arg_4)
ret void
}


define dllexport ccc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_native(float %arg_0,float %arg_1,float %arg_2,float %arg_3,i1 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}*, {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float, float, i1)*,  void (i8*, i8*, float, float, float, float, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3, i1 %arg_4)
ret void
}


define dllexport ccc i8*  @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13509 = bitcast [112 x i8]* @gsxtmgraphics-pipeline575 to i8*
call i32 (i8*, ...) @printf(i8* %var13509)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var13510 = bitcast [112 x i8]* @gsxtmgraphics-pipeline575 to i8*
call i32 (i8*, ...) @printf(i8* %var13510)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var13511 = bitcast [112 x i8]* @gsxtmgraphics-pipeline575 to i8*
call i32 (i8*, ...) @printf(i8* %var13511)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var13512 = bitcast [112 x i8]* @gsxtmgraphics-pipeline575 to i8*
call i32 (i8*, ...) @printf(i8* %var13512)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var13513 = bitcast [112 x i8]* @gsxtmgraphics-pipeline575 to i8*
call i32 (i8*, ...) @printf(i8* %var13513)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i1  @i1value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}*, {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float, float, i1)*,  void (i8*, i8*, float, float, float, float, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3, i1 %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float, float, float, i1}*
%arg_p_0 = getelementptr {float, float, float, float, i1}, {float, float, float, float, i1}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float, float, float, i1}, {float, float, float, float, i1}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float, float, float, float, i1}, {float, float, float, float, i1}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float, float, float, float, i1}, {float, float, float, float, i1}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {float, float, float, float, i1}, {float, float, float, float, i1}* %fstruct, i32 0, i32 4
%arg_4 = load i1, i1* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}*, {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float, float, i1)*,  void (i8*, i8*, float, float, float, float, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3, i1 %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline576 = hidden constant [47 x i8] c"xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd\00"
define dllexport fastcc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd__13514(i8* %_impz,i8* %_impenv, float %distance, float %fstop, float %flength) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13515 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}*
%xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}* %impenv, i32 0, i32 0
%xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = load {i8*, i8*, void (i8*, i8*, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, float, float, float)*}**** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_

; setup arguments
%distancePtr = alloca float
store float %distance, float* %distancePtr
%fstopPtr = alloca float
store float %fstop, float* %fstopPtr
%flengthPtr = alloca float
store float %flength, float* %flengthPtr


%val13516 = load float, float* %distancePtr
%val13517 = load float, float* %fstopPtr
%val13518 = load float, float* %flengthPtr
%res13519 = call ccc i1 @impc_false()
call fastcc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd(float %val13516, float %val13517, float %val13518, i1 %res13519)
ret void
}
@gsxtmgraphics-pipeline577 = hidden constant [100 x i8] c"xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float, float, float)*}** @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13540 = load i8*, i8** %_impzPtr
%zone13541 = bitcast i8* %tzone13540 to %mzone*

; let assign value to symbol xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd
%dat_xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone13541, i64 8)
%xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = bitcast i8* %dat_xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd to { i8*, i8*, void (i8*, i8*, float, float, float)*}***
%tzone13521 = load i8*, i8** %_impzPtr
%zone13522 = bitcast i8* %tzone13521 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13522)
; malloc closure structure
%clsptr13523 = call i8* @llvm_zone_malloc(%mzone* %zone13522, i64 24)
%closure13524 = bitcast i8* %clsptr13523 to { i8*, i8*, void (i8*, i8*, float, float, float)*}*

; malloc environment structure
%envptr13525 = call i8* @llvm_zone_malloc(%mzone* %zone13522, i64 8)
%environment13526 = bitcast i8* %envptr13525 to {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}*

; malloc closure address table
%addytable13527 = call %clsvar* @new_address_table()
%var13528 = bitcast [47 x i8]* @gsxtmgraphics-pipeline576 to i8*
%var13529 = bitcast [52 x i8]* @gsxtmgraphics-pipeline370 to i8*
%addytable13530 = call %clsvar* @add_address_table(%mzone* %zone13522, i8* %var13528, i32 0, i8* %var13529, i32 3, %clsvar* %addytable13527)
%address-table13531 = bitcast %clsvar* %addytable13530 to i8*

; insert table, function and environment into closure struct
%closure.table13534 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure13524, i32 0, i32 0
store i8* %address-table13531, i8** %closure.table13534
%closure.env13535 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure13524, i32 0, i32 1
store i8* %envptr13525, i8** %closure.env13535
%closure.func13536 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure13524, i32 0, i32 2
store void (i8*, i8*, float, float, float)* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd__13514, void (i8*, i8*, float, float, float)** %closure.func13536
%closure_size13537 = call i64 @llvm_zone_mark_size(%mzone* %zone13522)
call void @llvm_zone_ptr_set_size(i8* %clsptr13523, i64 %closure_size13537)
%wrapper_ptr13538 = call i8* @llvm_zone_malloc(%mzone* %zone13522, i64 8)
%closure_wrapper13539 = bitcast i8* %wrapper_ptr13538 to { i8*, i8*, void (i8*, i8*, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure13524, { i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_wrapper13539

; let value assignment
%xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd = select i1 true, { i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_wrapper13539, { i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_wrapper13539
store { i8*, i8*, void (i8*, i8*, float, float, float)*}** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd, { i8*, i8*, void (i8*, i8*, float, float, float)*}*** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd
%tmp_envptr13533 = getelementptr {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}* %environment13526, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float, float, float)*}*** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr, {i8*, i8*, void (i8*, i8*, float, float, float)*}**** %tmp_envptr13533


%val13542 = load {i8*, i8*, void (i8*, i8*, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, float, float, float)*}*** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr
ret {i8*, i8*, void (i8*, i8*, float, float, float)*}** %val13542
}


@xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float, float, float)*}** @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd(float %arg_0,float %arg_1,float %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float)*,  void (i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2)
ret void
}


define dllexport ccc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_native(float %arg_0,float %arg_1,float %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float)*,  void (i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2)
ret void
}


define dllexport ccc i8*  @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13543 = bitcast [100 x i8]* @gsxtmgraphics-pipeline577 to i8*
call i32 (i8*, ...) @printf(i8* %var13543)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var13544 = bitcast [100 x i8]* @gsxtmgraphics-pipeline577 to i8*
call i32 (i8*, ...) @printf(i8* %var13544)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var13545 = bitcast [100 x i8]* @gsxtmgraphics-pipeline577 to i8*
call i32 (i8*, ...) @printf(i8* %var13545)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float)*,  void (i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float, float}*
%arg_p_0 = getelementptr {float, float, float}, {float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float, float}, {float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float, float, float}, {float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float)*,  void (i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline578 = hidden constant [55 x i8] c"xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd\00"
@gsxtmgraphics-pipeline579 = hidden constant [59 x i8] c"{i8*, i8*, void (i8*, i8*, float, float, float, float)*}**\00"
define dllexport fastcc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd__13546(i8* %_impz,i8* %_impenv, float %x, float %y, float %fstop, float %flength) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13547 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float, float, float, float)*}***}*
%xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = load {i8*, i8*, void (i8*, i8*, float, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}**** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_

; setup arguments
%xPtr = alloca float
store float %x, float* %xPtr
%yPtr = alloca float
store float %y, float* %yPtr
%fstopPtr = alloca float
store float %fstop, float* %fstopPtr
%flengthPtr = alloca float
store float %flength, float* %flengthPtr


%val13548 = load float, float* %xPtr
%val13549 = load float, float* %yPtr
%val13550 = load float, float* %fstopPtr
%val13551 = load float, float* %flengthPtr
%res13552 = call ccc i1 @impc_false()
call fastcc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd(float %val13548, float %val13549, float %val13550, float %val13551, i1 %res13552)
ret void
}
@gsxtmgraphics-pipeline580 = hidden constant [108 x i8] c"xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float, float, float, float)*}** @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13573 = load i8*, i8** %_impzPtr
%zone13574 = bitcast i8* %tzone13573 to %mzone*

; let assign value to symbol xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd
%dat_xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone13574, i64 8)
%xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = bitcast i8* %dat_xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd to { i8*, i8*, void (i8*, i8*, float, float, float, float)*}***
%tzone13554 = load i8*, i8** %_impzPtr
%zone13555 = bitcast i8* %tzone13554 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13555)
; malloc closure structure
%clsptr13556 = call i8* @llvm_zone_malloc(%mzone* %zone13555, i64 24)
%closure13557 = bitcast i8* %clsptr13556 to { i8*, i8*, void (i8*, i8*, float, float, float, float)*}*

; malloc environment structure
%envptr13558 = call i8* @llvm_zone_malloc(%mzone* %zone13555, i64 8)
%environment13559 = bitcast i8* %envptr13558 to {{i8*, i8*, void (i8*, i8*, float, float, float, float)*}***}*

; malloc closure address table
%addytable13560 = call %clsvar* @new_address_table()
%var13561 = bitcast [55 x i8]* @gsxtmgraphics-pipeline578 to i8*
%var13562 = bitcast [59 x i8]* @gsxtmgraphics-pipeline579 to i8*
%addytable13563 = call %clsvar* @add_address_table(%mzone* %zone13555, i8* %var13561, i32 0, i8* %var13562, i32 3, %clsvar* %addytable13560)
%address-table13564 = bitcast %clsvar* %addytable13563 to i8*

; insert table, function and environment into closure struct
%closure.table13567 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure13557, i32 0, i32 0
store i8* %address-table13564, i8** %closure.table13567
%closure.env13568 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure13557, i32 0, i32 1
store i8* %envptr13558, i8** %closure.env13568
%closure.func13569 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure13557, i32 0, i32 2
store void (i8*, i8*, float, float, float, float)* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd__13546, void (i8*, i8*, float, float, float, float)** %closure.func13569
%closure_size13570 = call i64 @llvm_zone_mark_size(%mzone* %zone13555)
call void @llvm_zone_ptr_set_size(i8* %clsptr13556, i64 %closure_size13570)
%wrapper_ptr13571 = call i8* @llvm_zone_malloc(%mzone* %zone13555, i64 8)
%closure_wrapper13572 = bitcast i8* %wrapper_ptr13571 to { i8*, i8*, void (i8*, i8*, float, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure13557, { i8*, i8*, void (i8*, i8*, float, float, float, float)*}** %closure_wrapper13572

; let value assignment
%xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd = select i1 true, { i8*, i8*, void (i8*, i8*, float, float, float, float)*}** %closure_wrapper13572, { i8*, i8*, void (i8*, i8*, float, float, float, float)*}** %closure_wrapper13572
store { i8*, i8*, void (i8*, i8*, float, float, float, float)*}** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd, { i8*, i8*, void (i8*, i8*, float, float, float, float)*}*** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd
%tmp_envptr13566 = getelementptr {{i8*, i8*, void (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float, float, float, float)*}***}* %environment13559, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float, float, float, float)*}*** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}**** %tmp_envptr13566


%val13575 = load {i8*, i8*, void (i8*, i8*, float, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}*** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr
ret {i8*, i8*, void (i8*, i8*, float, float, float, float)*}** %val13575
}


@xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float, float, float, float)*}** @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float, float)*,  void (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret void
}


define dllexport ccc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_native(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float, float)*,  void (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret void
}


define dllexport ccc i8*  @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13576 = bitcast [108 x i8]* @gsxtmgraphics-pipeline580 to i8*
call i32 (i8*, ...) @printf(i8* %var13576)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var13577 = bitcast [108 x i8]* @gsxtmgraphics-pipeline580 to i8*
call i32 (i8*, ...) @printf(i8* %var13577)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var13578 = bitcast [108 x i8]* @gsxtmgraphics-pipeline580 to i8*
call i32 (i8*, ...) @printf(i8* %var13578)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var13579 = bitcast [108 x i8]* @gsxtmgraphics-pipeline580 to i8*
call i32 (i8*, ...) @printf(i8* %var13579)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float, float)*,  void (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float, float, float}*
%arg_p_0 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float, float)*,  void (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline581 = hidden constant [31 x i8] c"xtm_dof_adhoc_W3ZvaWQsZmxvYXRd\00"
define dllexport fastcc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXRd__13580(i8* %_impz,i8* %_impenv, float %distance) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13581 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float)*}***}*
%xtm_dof_adhoc_W3ZvaWQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float)*}***}, {{i8*, i8*, void (i8*, i8*, float)*}***}* %impenv, i32 0, i32 0
%xtm_dof_adhoc_W3ZvaWQsZmxvYXRdPtr = load {i8*, i8*, void (i8*, i8*, float)*}***, {i8*, i8*, void (i8*, i8*, float)*}**** %xtm_dof_adhoc_W3ZvaWQsZmxvYXRdPtr_

; setup arguments
%distancePtr = alloca float
store float %distance, float* %distancePtr


%val13582 = load float, float* %distancePtr
%res13583 = call ccc i1 @impc_false()
call fastcc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd(float %val13582, float 0x4010000000000000, float 0x4054000000000000, i1 %res13583)
ret void
}
@gsxtmgraphics-pipeline582 = hidden constant [84 x i8] c"xtm_dof_adhoc_W3ZvaWQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float)*}** @xtm_dof_adhoc_W3ZvaWQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13604 = load i8*, i8** %_impzPtr
%zone13605 = bitcast i8* %tzone13604 to %mzone*

; let assign value to symbol xtm_dof_adhoc_W3ZvaWQsZmxvYXRd
%dat_xtm_dof_adhoc_W3ZvaWQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone13605, i64 8)
%xtm_dof_adhoc_W3ZvaWQsZmxvYXRdPtr = bitcast i8* %dat_xtm_dof_adhoc_W3ZvaWQsZmxvYXRd to { i8*, i8*, void (i8*, i8*, float)*}***
%tzone13585 = load i8*, i8** %_impzPtr
%zone13586 = bitcast i8* %tzone13585 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13586)
; malloc closure structure
%clsptr13587 = call i8* @llvm_zone_malloc(%mzone* %zone13586, i64 24)
%closure13588 = bitcast i8* %clsptr13587 to { i8*, i8*, void (i8*, i8*, float)*}*

; malloc environment structure
%envptr13589 = call i8* @llvm_zone_malloc(%mzone* %zone13586, i64 8)
%environment13590 = bitcast i8* %envptr13589 to {{i8*, i8*, void (i8*, i8*, float)*}***}*

; malloc closure address table
%addytable13591 = call %clsvar* @new_address_table()
%var13592 = bitcast [31 x i8]* @gsxtmgraphics-pipeline581 to i8*
%var13593 = bitcast [38 x i8]* @gsxtmgraphics-pipeline562 to i8*
%addytable13594 = call %clsvar* @add_address_table(%mzone* %zone13586, i8* %var13592, i32 0, i8* %var13593, i32 3, %clsvar* %addytable13591)
%address-table13595 = bitcast %clsvar* %addytable13594 to i8*

; insert table, function and environment into closure struct
%closure.table13598 = getelementptr { i8*, i8*, void (i8*, i8*, float)*}, { i8*, i8*, void (i8*, i8*, float)*}* %closure13588, i32 0, i32 0
store i8* %address-table13595, i8** %closure.table13598
%closure.env13599 = getelementptr { i8*, i8*, void (i8*, i8*, float)*}, { i8*, i8*, void (i8*, i8*, float)*}* %closure13588, i32 0, i32 1
store i8* %envptr13589, i8** %closure.env13599
%closure.func13600 = getelementptr { i8*, i8*, void (i8*, i8*, float)*}, { i8*, i8*, void (i8*, i8*, float)*}* %closure13588, i32 0, i32 2
store void (i8*, i8*, float)* @xtm_dof_adhoc_W3ZvaWQsZmxvYXRd__13580, void (i8*, i8*, float)** %closure.func13600
%closure_size13601 = call i64 @llvm_zone_mark_size(%mzone* %zone13586)
call void @llvm_zone_ptr_set_size(i8* %clsptr13587, i64 %closure_size13601)
%wrapper_ptr13602 = call i8* @llvm_zone_malloc(%mzone* %zone13586, i64 8)
%closure_wrapper13603 = bitcast i8* %wrapper_ptr13602 to { i8*, i8*, void (i8*, i8*, float)*}**
store { i8*, i8*, void (i8*, i8*, float)*}* %closure13588, { i8*, i8*, void (i8*, i8*, float)*}** %closure_wrapper13603

; let value assignment
%xtm_dof_adhoc_W3ZvaWQsZmxvYXRd = select i1 true, { i8*, i8*, void (i8*, i8*, float)*}** %closure_wrapper13603, { i8*, i8*, void (i8*, i8*, float)*}** %closure_wrapper13603
store { i8*, i8*, void (i8*, i8*, float)*}** %xtm_dof_adhoc_W3ZvaWQsZmxvYXRd, { i8*, i8*, void (i8*, i8*, float)*}*** %xtm_dof_adhoc_W3ZvaWQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var xtm_dof_adhoc_W3ZvaWQsZmxvYXRd
%tmp_envptr13597 = getelementptr {{i8*, i8*, void (i8*, i8*, float)*}***}, {{i8*, i8*, void (i8*, i8*, float)*}***}* %environment13590, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float)*}*** %xtm_dof_adhoc_W3ZvaWQsZmxvYXRdPtr, {i8*, i8*, void (i8*, i8*, float)*}**** %tmp_envptr13597


%val13606 = load {i8*, i8*, void (i8*, i8*, float)*}**, {i8*, i8*, void (i8*, i8*, float)*}*** %xtm_dof_adhoc_W3ZvaWQsZmxvYXRdPtr
ret {i8*, i8*, void (i8*, i8*, float)*}** %val13606
}


@xtm_dof_adhoc_W3ZvaWQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_dof_adhoc_W3ZvaWQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float)*}** @xtm_dof_adhoc_W3ZvaWQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_dof_adhoc_W3ZvaWQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXRd(float %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float)*}*, {i8*, i8*, void (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float)*,  void (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0)
ret void
}


define dllexport ccc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXRd_native(float %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float)*}*, {i8*, i8*, void (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float)*,  void (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0)
ret void
}


define dllexport ccc i8*  @xtm_dof_adhoc_W3ZvaWQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13607 = bitcast [84 x i8]* @gsxtmgraphics-pipeline582 to i8*
call i32 (i8*, ...) @printf(i8* %var13607)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float)*}*, {i8*, i8*, void (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float)*,  void (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float}*
%arg_p_0 = getelementptr {float}, {float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float)*}*, {i8*, i8*, void (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float)*,  void (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline583 = hidden constant [39 x i8] c"xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd\00"
@gsxtmgraphics-pipeline584 = hidden constant [45 x i8] c"{i8*, i8*, void (i8*, i8*, float, float)*}**\00"
define dllexport fastcc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd__13608(i8* %_impz,i8* %_impenv, float %x, float %y) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13609 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float, float)*}***}*
%xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float, float)*}***}* %impenv, i32 0, i32 0
%xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRdPtr = load {i8*, i8*, void (i8*, i8*, float, float)*}***, {i8*, i8*, void (i8*, i8*, float, float)*}**** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRdPtr_

; setup arguments
%xPtr = alloca float
store float %x, float* %xPtr
%yPtr = alloca float
store float %y, float* %yPtr


%val13610 = load float, float* %xPtr
%val13611 = load float, float* %yPtr
%res13612 = call ccc i1 @impc_false()
call fastcc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTFd(float %val13610, float %val13611, float 0x4010000000000000, float 0x4054000000000000, i1 %res13612)
ret void
}
@gsxtmgraphics-pipeline585 = hidden constant [92 x i8] c"xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float, float)*}** @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13633 = load i8*, i8** %_impzPtr
%zone13634 = bitcast i8* %tzone13633 to %mzone*

; let assign value to symbol xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd
%dat_xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone13634, i64 8)
%xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRdPtr = bitcast i8* %dat_xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd to { i8*, i8*, void (i8*, i8*, float, float)*}***
%tzone13614 = load i8*, i8** %_impzPtr
%zone13615 = bitcast i8* %tzone13614 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13615)
; malloc closure structure
%clsptr13616 = call i8* @llvm_zone_malloc(%mzone* %zone13615, i64 24)
%closure13617 = bitcast i8* %clsptr13616 to { i8*, i8*, void (i8*, i8*, float, float)*}*

; malloc environment structure
%envptr13618 = call i8* @llvm_zone_malloc(%mzone* %zone13615, i64 8)
%environment13619 = bitcast i8* %envptr13618 to {{i8*, i8*, void (i8*, i8*, float, float)*}***}*

; malloc closure address table
%addytable13620 = call %clsvar* @new_address_table()
%var13621 = bitcast [39 x i8]* @gsxtmgraphics-pipeline583 to i8*
%var13622 = bitcast [45 x i8]* @gsxtmgraphics-pipeline584 to i8*
%addytable13623 = call %clsvar* @add_address_table(%mzone* %zone13615, i8* %var13621, i32 0, i8* %var13622, i32 3, %clsvar* %addytable13620)
%address-table13624 = bitcast %clsvar* %addytable13623 to i8*

; insert table, function and environment into closure struct
%closure.table13627 = getelementptr { i8*, i8*, void (i8*, i8*, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float)*}* %closure13617, i32 0, i32 0
store i8* %address-table13624, i8** %closure.table13627
%closure.env13628 = getelementptr { i8*, i8*, void (i8*, i8*, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float)*}* %closure13617, i32 0, i32 1
store i8* %envptr13618, i8** %closure.env13628
%closure.func13629 = getelementptr { i8*, i8*, void (i8*, i8*, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float)*}* %closure13617, i32 0, i32 2
store void (i8*, i8*, float, float)* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd__13608, void (i8*, i8*, float, float)** %closure.func13629
%closure_size13630 = call i64 @llvm_zone_mark_size(%mzone* %zone13615)
call void @llvm_zone_ptr_set_size(i8* %clsptr13616, i64 %closure_size13630)
%wrapper_ptr13631 = call i8* @llvm_zone_malloc(%mzone* %zone13615, i64 8)
%closure_wrapper13632 = bitcast i8* %wrapper_ptr13631 to { i8*, i8*, void (i8*, i8*, float, float)*}**
store { i8*, i8*, void (i8*, i8*, float, float)*}* %closure13617, { i8*, i8*, void (i8*, i8*, float, float)*}** %closure_wrapper13632

; let value assignment
%xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd = select i1 true, { i8*, i8*, void (i8*, i8*, float, float)*}** %closure_wrapper13632, { i8*, i8*, void (i8*, i8*, float, float)*}** %closure_wrapper13632
store { i8*, i8*, void (i8*, i8*, float, float)*}** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd, { i8*, i8*, void (i8*, i8*, float, float)*}*** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd
%tmp_envptr13626 = getelementptr {{i8*, i8*, void (i8*, i8*, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float, float)*}***}* %environment13619, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float, float)*}*** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRdPtr, {i8*, i8*, void (i8*, i8*, float, float)*}**** %tmp_envptr13626


%val13635 = load {i8*, i8*, void (i8*, i8*, float, float)*}**, {i8*, i8*, void (i8*, i8*, float, float)*}*** %xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRdPtr
ret {i8*, i8*, void (i8*, i8*, float, float)*}** %val13635
}


@xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float, float)*}** @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float)*,  void (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret void
}


define dllexport ccc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd_native(float %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float)*,  void (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
ret void
}


define dllexport ccc i8*  @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13636 = bitcast [92 x i8]* @gsxtmgraphics-pipeline585 to i8*
call i32 (i8*, ...) @printf(i8* %var13636)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var13637 = bitcast [92 x i8]* @gsxtmgraphics-pipeline585 to i8*
call i32 (i8*, ...) @printf(i8* %var13637)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float)*,  void (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float}*
%arg_p_0 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float}, {float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_adhoc_W3ZvaWQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float)*,  void (i8*, i8*, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline586 = hidden constant [17 x i8] c"bgl_DepthTexture\00"
@gsxtmgraphics-pipeline587 = hidden constant [20 x i8] c"bgl_RenderedTexture\00"
@gsxtmgraphics-pipeline588 = hidden constant [6 x i8] c"znear\00"
@gsxtmgraphics-pipeline589 = hidden constant [5 x i8] c"zfar\00"
@gsxtmgraphics-pipeline590 = hidden constant [11 x i8] c"focalDepth\00"
@gsxtmgraphics-pipeline591 = hidden constant [12 x i8] c"focalLength\00"
@gsxtmgraphics-pipeline592 = hidden constant [6 x i8] c"fstop\00"
@gsxtmgraphics-pipeline593 = hidden constant [10 x i8] c"showFocus\00"
@gsxtmgraphics-pipeline594 = hidden constant [10 x i8] c"autofocus\00"
@gsxtmgraphics-pipeline595 = hidden constant [25 x i8] c"bgl_RenderedTextureWidth\00"
@gsxtmgraphics-pipeline596 = hidden constant [26 x i8] c"bgl_RenderedTextureHeight\00"
@gsxtmgraphics-pipeline597 = hidden constant [6 x i8] c"focus\00"
@gsxtmgraphics-pipeline598 = hidden constant [112 x i8] c"xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ\00"
@gsxtmgraphics-pipeline599 = hidden constant [107 x i8] c"{i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}**\00"
@gsxtmgraphics-pipeline600 = hidden constant [16 x i8] c"_anon_lambda_23\00"
define dllexport fastcc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ__13638(i8* %_impz,i8* %_impenv, %FBO* %fbo, i32 %autofocus, float %focusx, float %focusy, float %fdepth, float %flength, float %fstop, i32 %show_focus, float* %model, float* %view, float* %projection) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13649 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***}*
%xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = load {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}**** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr_
%idmatPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***}* %impenv, i32 0, i32 1
%idmatPtr = load float**, float*** %idmatPtr_
%_anon_lambda_23Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_23Ptr = load {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}**** %_anon_lambda_23Ptr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr
%autofocusPtr = alloca i32
store i32 %autofocus, i32* %autofocusPtr
%focusxPtr = alloca float
store float %focusx, float* %focusxPtr
%focusyPtr = alloca float
store float %focusy, float* %focusyPtr
%fdepthPtr = alloca float
store float %fdepth, float* %fdepthPtr
%flengthPtr = alloca float
store float %flength, float* %flengthPtr
%fstopPtr = alloca float
store float %fstop, float* %fstopPtr
%show_focusPtr = alloca i32
store i32 %show_focus, i32* %show_focusPtr
%modelPtr = alloca float*
store float* %model, float** %modelPtr
%viewPtr = alloca float*
store float* %view, float** %viewPtr
%projectionPtr = alloca float*
store float* %projection, float** %projectionPtr


%tzone13651 = load i8*, i8** %_impzPtr
%zone13652 = bitcast i8* %tzone13651 to %mzone*

; let assign value to symbol shader
%shaderPtr = alloca %ShaderProgram*
%tzone13654 = load i8*, i8** %_impzPtr
%zone13655 = bitcast i8* %tzone13654 to %mzone*

; let assign value to symbol focuspt
%focusptPtr = alloca float*
%val13650 = load %ShaderProgram*, %ShaderProgram** @xtm_render_dof_shader

; let value assignment
%shader = select i1 true, %ShaderProgram* %val13650, %ShaderProgram* %val13650
store %ShaderProgram* %shader, %ShaderProgram** %shaderPtr

%dat13653 = alloca float, i64 2, align 16

; let value assignment
%focuspt = select i1 true, float* %dat13653, float* %dat13653
store float* %focuspt, float** %focusptPtr

%val13656 = load float*, float** %idmatPtr
call fastcc void @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %val13656)
%val13658 = load i32, i32* @GL_DEPTH_TEST
call fastcc void @glDisable_adhoc_W3ZvaWQsaTMyXQ(i32 %val13658)
%val13660 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
call fastcc void @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %val13660)
%val13662 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val13663 = load float*, float** %modelPtr
%val13664 = load float*, float** %viewPtr
%val13665 = load float*, float** %projectionPtr
call fastcc void @shader_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd(%ShaderProgram* %val13662, float* %val13663, float* %val13664, float* %val13665)
%val13667 = load %FBO*, %FBO** %fboPtr
%res13668 = call fastcc %Texture* @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd(%FBO* %val13667)
%res13669 = call fastcc i32 @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd(%Texture* %res13668, i32 0)
%val13670 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res13671 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val13670)
%var13672 = bitcast [17 x i8]* @gsxtmgraphics-pipeline586 to i8*
%res13673 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res13671, i8* %var13672)
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res13673, i32 0)
%val13675 = load %FBO*, %FBO** %fboPtr
%res13676 = call fastcc %Texture* @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd(%FBO* %val13675)
%res13677 = call fastcc i32 @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd(%Texture* %res13676, i32 2)
%val13678 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res13679 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val13678)
%var13680 = bitcast [20 x i8]* @gsxtmgraphics-pipeline587 to i8*
%res13681 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res13679, i8* %var13680)
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res13681, i32 2)
%val13683 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res13684 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val13683)
%var13685 = bitcast [6 x i8]* @gsxtmgraphics-pipeline588 to i8*
%res13686 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res13684, i8* %var13685)
%val13687 = load float, float* @xtm_render_near
call fastcc void @glUniform1f_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %res13686, float %val13687)
%val13689 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res13690 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val13689)
%var13691 = bitcast [5 x i8]* @gsxtmgraphics-pipeline589 to i8*
%res13692 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res13690, i8* %var13691)
%val13693 = load float, float* @xtm_render_far
call fastcc void @glUniform1f_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %res13692, float %val13693)
%val13695 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res13696 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val13695)
%var13697 = bitcast [11 x i8]* @gsxtmgraphics-pipeline590 to i8*
%res13698 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res13696, i8* %var13697)
%val13699 = load float, float* %fdepthPtr
call fastcc void @glUniform1f_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %res13698, float %val13699)
%val13701 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res13702 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val13701)
%var13703 = bitcast [12 x i8]* @gsxtmgraphics-pipeline591 to i8*
%res13704 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res13702, i8* %var13703)
%val13705 = load float, float* %flengthPtr
call fastcc void @glUniform1f_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %res13704, float %val13705)
%val13707 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res13708 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val13707)
%var13709 = bitcast [6 x i8]* @gsxtmgraphics-pipeline592 to i8*
%res13710 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res13708, i8* %var13709)
%val13711 = load float, float* %fstopPtr
call fastcc void @glUniform1f_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %res13710, float %val13711)
%val13713 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res13714 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val13713)
%var13715 = bitcast [10 x i8]* @gsxtmgraphics-pipeline593 to i8*
%res13716 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res13714, i8* %var13715)
%val13717 = load i32, i32* %show_focusPtr
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res13716, i32 %val13717)
%val13719 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res13720 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val13719)
%var13721 = bitcast [10 x i8]* @gsxtmgraphics-pipeline594 to i8*
%res13722 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res13720, i8* %var13721)
%val13723 = load i32, i32* %autofocusPtr
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res13722, i32 %val13723)
%val13725 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res13726 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val13725)
%var13727 = bitcast [25 x i8]* @gsxtmgraphics-pipeline595 to i8*
%res13728 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res13726, i8* %var13727)
%val13729 = load i32, i32* @xtm_render_w
%res13730 = call ccc float @i32tof(i32 %val13729)
call fastcc void @glUniform1f_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %res13728, float %res13730)
%val13732 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res13733 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val13732)
%var13734 = bitcast [26 x i8]* @gsxtmgraphics-pipeline596 to i8*
%res13735 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res13733, i8* %var13734)
%val13736 = load i32, i32* @xtm_render_h
%res13737 = call ccc float @i32tof(i32 %val13736)
call fastcc void @glUniform1f_adhoc_W3ZvaWQsaTMyLGZsb2F0XQ(i32 %res13735, float %res13737)
%val13739 = load float*, float** %focusptPtr
%val13740 = load float, float* %focusxPtr
; set pointer
%val13741 = getelementptr float, float* %val13739, i64 0
store float %val13740, float* %val13741
%val13742 = load float*, float** %focusptPtr
%val13743 = load float, float* %focusyPtr
; set pointer
%val13744 = getelementptr float, float* %val13742, i64 1
store float %val13743, float* %val13744
%val13745 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%res13746 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val13745)
%var13747 = bitcast [6 x i8]* @gsxtmgraphics-pipeline597 to i8*
%res13748 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res13746, i8* %var13747)
%val13749 = load float*, float** %focusptPtr
call fastcc void @glUniform2fv_adhoc_W3ZvaWQsaTMyLGkzMixmbG9hdCpd(i32 %res13748, i32 1, float* %val13749)
%val13751 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
%val13752 = load float*, float** %idmatPtr
call fastcc void @draw_quad_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqXQ(%ShaderProgram* %val13751, float* %val13752)
%val13754 = load %FBO*, %FBO** %fboPtr
%res13755 = call fastcc %Texture* @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd(%FBO* %val13754)
call fastcc void @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ(%Texture* %res13755, i32 0)
%val13757 = load %FBO*, %FBO** %fboPtr
%res13758 = call fastcc %Texture* @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd(%FBO* %val13757)
call fastcc void @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ(%Texture* %res13758, i32 2)
%val13760 = load %ShaderProgram*, %ShaderProgram** %shaderPtr
call fastcc void @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %val13760)
ret void
}
@gsxtmgraphics-pipeline601 = hidden constant [165 x i8] c"xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}** @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13795 = load i8*, i8** %_impzPtr
%zone13796 = bitcast i8* %tzone13795 to %mzone*

; let assign value to symbol xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%dat_xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone13796, i64 8)
%xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr = bitcast i8* %dat_xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ to {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***
%tzone13645 = load i8*, i8** %_impzPtr
%zone13646 = bitcast i8* %tzone13645 to %mzone*

; let assign value to symbol idmat
%dat_idmat = call i8* @llvm_zone_malloc(%mzone* %zone13646, i64 8)
%idmatPtr = bitcast i8* %dat_idmat to float**
%val13639 = getelementptr i64, i64* null, i32 1
%zonesize13640 = mul i64 4, 16
%tzone13641 = load i8*, i8** %_impzPtr
%zone13642 = bitcast i8* %tzone13641 to %mzone*
%dat13643 = call i8* @llvm_zone_malloc(%mzone* %zone13642, i64 %zonesize13640)
call i8* @memset(i8* %dat13643, i32 0, i64 %zonesize13640)
%val13644 = bitcast i8* %dat13643 to float*

; let value assignment
%idmat = select i1 true, float* %val13644, float* %val13644
store float* %idmat, float** %idmatPtr

%val13647 = load float*, float** %idmatPtr
call fastcc void @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %val13647)
%tzone13792 = load i8*, i8** %_impzPtr
%zone13793 = bitcast i8* %tzone13792 to %mzone*

; let assign value to symbol _anon_lambda_23
%dat__anon_lambda_23 = call i8* @llvm_zone_malloc(%mzone* %zone13793, i64 8)
%_anon_lambda_23Ptr = bitcast i8* %dat__anon_lambda_23 to { i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***
%tzone13763 = load i8*, i8** %_impzPtr
%zone13764 = bitcast i8* %tzone13763 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13764)
; malloc closure structure
%clsptr13765 = call i8* @llvm_zone_malloc(%mzone* %zone13764, i64 24)
%closure13766 = bitcast i8* %clsptr13765 to { i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}*

; malloc environment structure
%envptr13767 = call i8* @llvm_zone_malloc(%mzone* %zone13764, i64 24)
%environment13768 = bitcast i8* %envptr13767 to {{i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***}*

; malloc closure address table
%addytable13769 = call %clsvar* @new_address_table()
%var13770 = bitcast [112 x i8]* @gsxtmgraphics-pipeline598 to i8*
%var13771 = bitcast [107 x i8]* @gsxtmgraphics-pipeline599 to i8*
%addytable13772 = call %clsvar* @add_address_table(%mzone* %zone13764, i8* %var13770, i32 0, i8* %var13771, i32 3, %clsvar* %addytable13769)
%var13773 = bitcast [6 x i8]* @gsxtmgraphics-pipeline531 to i8*
%var13774 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable13775 = call %clsvar* @add_address_table(%mzone* %zone13764, i8* %var13773, i32 8, i8* %var13774, i32 3, %clsvar* %addytable13772)
%var13776 = bitcast [16 x i8]* @gsxtmgraphics-pipeline600 to i8*
%var13777 = bitcast [107 x i8]* @gsxtmgraphics-pipeline599 to i8*
%addytable13778 = call %clsvar* @add_address_table(%mzone* %zone13764, i8* %var13776, i32 16, i8* %var13777, i32 3, %clsvar* %addytable13775)
%address-table13779 = bitcast %clsvar* %addytable13778 to i8*

; insert table, function and environment into closure struct
%closure.table13786 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}* %closure13766, i32 0, i32 0
store i8* %address-table13779, i8** %closure.table13786
%closure.env13787 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}* %closure13766, i32 0, i32 1
store i8* %envptr13767, i8** %closure.env13787
%closure.func13788 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}* %closure13766, i32 0, i32 2
store void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ__13638, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)** %closure.func13788
%closure_size13789 = call i64 @llvm_zone_mark_size(%mzone* %zone13764)
call void @llvm_zone_ptr_set_size(i8* %clsptr13765, i64 %closure_size13789)
%wrapper_ptr13790 = call i8* @llvm_zone_malloc(%mzone* %zone13764, i64 8)
%closure_wrapper13791 = bitcast i8* %wrapper_ptr13790 to { i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}* %closure13766, { i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}** %closure_wrapper13791

; let value assignment
%_anon_lambda_23 = select i1 true, { i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}** %closure_wrapper13791, { i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}** %closure_wrapper13791
store { i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}** %_anon_lambda_23, { i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}*** %_anon_lambda_23Ptr

; add data to environment
; don't need to alloc for env var xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ
%tmp_envptr13781 = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***}* %environment13768, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}*** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}**** %tmp_envptr13781

; don't need to alloc for env var idmat
%tmp_envptr13783 = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***}* %environment13768, i32 0, i32 1
store float** %idmatPtr, float*** %tmp_envptr13783

; don't need to alloc for env var _anon_lambda_23
%tmp_envptr13785 = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***, float**, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}***}* %environment13768, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}*** %_anon_lambda_23Ptr, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}**** %tmp_envptr13785


%val13794 = load {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}*** %_anon_lambda_23Ptr

; let value assignment
%xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ = select i1 true, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}** %val13794, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}** %val13794
store {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}*** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr

%val13797 = load {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}*** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQPtr
ret {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}** %val13797
}


@xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}** @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ(%FBO* %arg_0,i32 %arg_1,float %arg_2,float %arg_3,float %arg_4,float %arg_5,float %arg_6,i32 %arg_7,float* %arg_8,float* %arg_9,float* %arg_10) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*,  void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, i32 %arg_1, float %arg_2, float %arg_3, float %arg_4, float %arg_5, float %arg_6, i32 %arg_7, float* %arg_8, float* %arg_9, float* %arg_10)
ret void
}


define dllexport ccc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_native(%FBO* %arg_0,i32 %arg_1,float %arg_2,float %arg_3,float %arg_4,float %arg_5,float %arg_6,i32 %arg_7,float* %arg_8,float* %arg_9,float* %arg_10) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*,  void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, i32 %arg_1, float %arg_2, float %arg_3, float %arg_4, float %arg_5, float %arg_6, i32 %arg_7, float* %arg_8, float* %arg_9, float* %arg_10)
ret void
}


define dllexport ccc i8*  @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13798 = bitcast [165 x i8]* @gsxtmgraphics-pipeline601 to i8*
call i32 (i8*, ...) @printf(i8* %var13798)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var13799 = bitcast [165 x i8]* @gsxtmgraphics-pipeline601 to i8*
call i32 (i8*, ...) @printf(i8* %var13799)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var13800 = bitcast [165 x i8]* @gsxtmgraphics-pipeline601 to i8*
call i32 (i8*, ...) @printf(i8* %var13800)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var13801 = bitcast [165 x i8]* @gsxtmgraphics-pipeline601 to i8*
call i32 (i8*, ...) @printf(i8* %var13801)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var13802 = bitcast [165 x i8]* @gsxtmgraphics-pipeline601 to i8*
call i32 (i8*, ...) @printf(i8* %var13802)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_real(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var13803 = bitcast [165 x i8]* @gsxtmgraphics-pipeline601 to i8*
call i32 (i8*, ...) @printf(i8* %var13803)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc float  @r32value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_real(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var13804 = bitcast [165 x i8]* @gsxtmgraphics-pipeline601 to i8*
call i32 (i8*, ...) @printf(i8* %var13804)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%arg_6 = call ccc float  @r32value(i8* %arg_6_val)
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_integer(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var13805 = bitcast [165 x i8]* @gsxtmgraphics-pipeline601 to i8*
call i32 (i8*, ...) @printf(i8* %var13805)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%arg_7 = call ccc i32  @i32value(i8* %arg_7_val)
%arg_8_val = call ccc i8* @list_ref(i8* %_sc, i32 8,i8* %args)
%arg_8_rt_check = call i32 @is_cptr(i8* %arg_8_val)
%arg_8_bool = icmp ne i32 %arg_8_rt_check, 0
br i1 %arg_8_bool, label %arg_8_true, label %arg_8_false

arg_8_true:
br label %arg_8_continue

arg_8_false:
%var13806 = bitcast [165 x i8]* @gsxtmgraphics-pipeline601 to i8*
call i32 (i8*, ...) @printf(i8* %var13806)
%arg_8_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_8_errret

arg_8_continue:
%ttv_8 = call ccc i8* @cptr_value(i8* %arg_8_val)
%arg_8 = bitcast i8* %ttv_8 to float*
%arg_9_val = call ccc i8* @list_ref(i8* %_sc, i32 9,i8* %args)
%arg_9_rt_check = call i32 @is_cptr(i8* %arg_9_val)
%arg_9_bool = icmp ne i32 %arg_9_rt_check, 0
br i1 %arg_9_bool, label %arg_9_true, label %arg_9_false

arg_9_true:
br label %arg_9_continue

arg_9_false:
%var13807 = bitcast [165 x i8]* @gsxtmgraphics-pipeline601 to i8*
call i32 (i8*, ...) @printf(i8* %var13807)
%arg_9_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_9_errret

arg_9_continue:
%ttv_9 = call ccc i8* @cptr_value(i8* %arg_9_val)
%arg_9 = bitcast i8* %ttv_9 to float*
%arg_10_val = call ccc i8* @list_ref(i8* %_sc, i32 10,i8* %args)
%arg_10_rt_check = call i32 @is_cptr(i8* %arg_10_val)
%arg_10_bool = icmp ne i32 %arg_10_rt_check, 0
br i1 %arg_10_bool, label %arg_10_true, label %arg_10_false

arg_10_true:
br label %arg_10_continue

arg_10_false:
%var13808 = bitcast [165 x i8]* @gsxtmgraphics-pipeline601 to i8*
call i32 (i8*, ...) @printf(i8* %var13808)
%arg_10_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_10_errret

arg_10_continue:
%ttv_10 = call ccc i8* @cptr_value(i8* %arg_10_val)
%arg_10 = bitcast i8* %ttv_10 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*,  void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, i32 %arg_1, float %arg_2, float %arg_3, float %arg_4, float %arg_5, float %arg_6, i32 %arg_7, float* %arg_8, float* %arg_9, float* %arg_10)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}*
%arg_p_0 = getelementptr {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}, {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
%arg_p_1 = getelementptr {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}, {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}, {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}, {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}, {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
%arg_p_5 = getelementptr {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}, {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 5
%arg_5 = load float, float* %arg_p_5
%arg_p_6 = getelementptr {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}, {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 6
%arg_6 = load float, float* %arg_p_6
%arg_p_7 = getelementptr {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}, {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 7
%arg_7 = load i32, i32* %arg_p_7
%arg_p_8 = getelementptr {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}, {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 8
%arg_8 = load float*, float** %arg_p_8
%arg_p_9 = getelementptr {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}, {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 9
%arg_9 = load float*, float** %arg_p_9
%arg_p_10 = getelementptr {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}, {%FBO*, i32, float, float, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 10
%arg_10 = load float*, float** %arg_p_10
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)*,  void (i8*, i8*, %FBO*, i32, float, float, float, float, float, i32, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, i32 %arg_1, float %arg_2, float %arg_3, float %arg_4, float %arg_5, float %arg_6, i32 %arg_7, float* %arg_8, float* %arg_9, float* %arg_10)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline602 = hidden constant [85 x i8] c"xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0\00"
@gsxtmgraphics-pipeline603 = hidden constant [83 x i8] c"{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}**\00"
define dllexport fastcc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0__13809(i8* %_impz,i8* %_impenv, %FBO* %fbo, float %fdepth, float %flength, float %fstop, float* %model, float* %view, float* %projection) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13810 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}***}*
%xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}**** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr
%fdepthPtr = alloca float
store float %fdepth, float* %fdepthPtr
%flengthPtr = alloca float
store float %flength, float* %flengthPtr
%fstopPtr = alloca float
store float %fstop, float* %fstopPtr
%modelPtr = alloca float*
store float* %model, float** %modelPtr
%viewPtr = alloca float*
store float* %view, float** %viewPtr
%projectionPtr = alloca float*
store float* %projection, float** %projectionPtr


%val13811 = load %FBO*, %FBO** %fboPtr
%val13812 = load float, float* %fdepthPtr
%val13813 = load float, float* %flengthPtr
%val13814 = load float, float* %fstopPtr
%val13815 = load float*, float** %modelPtr
%val13816 = load float*, float** %viewPtr
%val13817 = load float*, float** %projectionPtr
call fastcc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ(%FBO* %val13811, i32 0, float 0x3fe0000000000000, float 0x3fe0000000000000, float %val13812, float %val13813, float %val13814, i32 0, float* %val13815, float* %val13816, float* %val13817)
ret void
}
@gsxtmgraphics-pipeline604 = hidden constant [138 x i8] c"xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}** @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13838 = load i8*, i8** %_impzPtr
%zone13839 = bitcast i8* %tzone13838 to %mzone*

; let assign value to symbol xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0
%dat_xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone13839, i64 8)
%xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr = bitcast i8* %dat_xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0 to { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}***
%tzone13819 = load i8*, i8** %_impzPtr
%zone13820 = bitcast i8* %tzone13819 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13820)
; malloc closure structure
%clsptr13821 = call i8* @llvm_zone_malloc(%mzone* %zone13820, i64 24)
%closure13822 = bitcast i8* %clsptr13821 to { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}*

; malloc environment structure
%envptr13823 = call i8* @llvm_zone_malloc(%mzone* %zone13820, i64 8)
%environment13824 = bitcast i8* %envptr13823 to {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}***}*

; malloc closure address table
%addytable13825 = call %clsvar* @new_address_table()
%var13826 = bitcast [85 x i8]* @gsxtmgraphics-pipeline602 to i8*
%var13827 = bitcast [83 x i8]* @gsxtmgraphics-pipeline603 to i8*
%addytable13828 = call %clsvar* @add_address_table(%mzone* %zone13820, i8* %var13826, i32 0, i8* %var13827, i32 3, %clsvar* %addytable13825)
%address-table13829 = bitcast %clsvar* %addytable13828 to i8*

; insert table, function and environment into closure struct
%closure.table13832 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}* %closure13822, i32 0, i32 0
store i8* %address-table13829, i8** %closure.table13832
%closure.env13833 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}* %closure13822, i32 0, i32 1
store i8* %envptr13823, i8** %closure.env13833
%closure.func13834 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}* %closure13822, i32 0, i32 2
store void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0__13809, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)** %closure.func13834
%closure_size13835 = call i64 @llvm_zone_mark_size(%mzone* %zone13820)
call void @llvm_zone_ptr_set_size(i8* %clsptr13821, i64 %closure_size13835)
%wrapper_ptr13836 = call i8* @llvm_zone_malloc(%mzone* %zone13820, i64 8)
%closure_wrapper13837 = bitcast i8* %wrapper_ptr13836 to { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}* %closure13822, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}** %closure_wrapper13837

; let value assignment
%xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}** %closure_wrapper13837, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}** %closure_wrapper13837
store { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}*** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr

; add data to environment
; don't need to alloc for env var xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0
%tmp_envptr13831 = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}***}* %environment13824, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}*** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}**** %tmp_envptr13831


%val13840 = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}*** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}** %val13840
}


@xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}** @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0(%FBO* %arg_0,float %arg_1,float %arg_2,float %arg_3,float* %arg_4,float* %arg_5,float* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*,  void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, float %arg_1, float %arg_2, float %arg_3, float* %arg_4, float* %arg_5, float* %arg_6)
ret void
}


define dllexport ccc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_native(%FBO* %arg_0,float %arg_1,float %arg_2,float %arg_3,float* %arg_4,float* %arg_5,float* %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*,  void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, float %arg_1, float %arg_2, float %arg_3, float* %arg_4, float* %arg_5, float* %arg_6)
ret void
}


define dllexport ccc i8*  @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13841 = bitcast [138 x i8]* @gsxtmgraphics-pipeline604 to i8*
call i32 (i8*, ...) @printf(i8* %var13841)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var13842 = bitcast [138 x i8]* @gsxtmgraphics-pipeline604 to i8*
call i32 (i8*, ...) @printf(i8* %var13842)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var13843 = bitcast [138 x i8]* @gsxtmgraphics-pipeline604 to i8*
call i32 (i8*, ...) @printf(i8* %var13843)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var13844 = bitcast [138 x i8]* @gsxtmgraphics-pipeline604 to i8*
call i32 (i8*, ...) @printf(i8* %var13844)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var13845 = bitcast [138 x i8]* @gsxtmgraphics-pipeline604 to i8*
call i32 (i8*, ...) @printf(i8* %var13845)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var13846 = bitcast [138 x i8]* @gsxtmgraphics-pipeline604 to i8*
call i32 (i8*, ...) @printf(i8* %var13846)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to float*
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var13847 = bitcast [138 x i8]* @gsxtmgraphics-pipeline604 to i8*
call i32 (i8*, ...) @printf(i8* %var13847)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*,  void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, float %arg_1, float %arg_2, float %arg_3, float* %arg_4, float* %arg_5, float* %arg_6)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*, float, float, float, float*, float*, float*}*
%arg_p_0 = getelementptr {%FBO*, float, float, float, float*, float*, float*}, {%FBO*, float, float, float, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
%arg_p_1 = getelementptr {%FBO*, float, float, float, float*, float*, float*}, {%FBO*, float, float, float, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {%FBO*, float, float, float, float*, float*, float*}, {%FBO*, float, float, float, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {%FBO*, float, float, float, float*, float*, float*}, {%FBO*, float, float, float, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {%FBO*, float, float, float, float*, float*, float*}, {%FBO*, float, float, float, float*, float*, float*}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {%FBO*, float, float, float, float*, float*, float*}, {%FBO*, float, float, float, float*, float*, float*}* %fstruct, i32 0, i32 5
%arg_5 = load float*, float** %arg_p_5
%arg_p_6 = getelementptr {%FBO*, float, float, float, float*, float*, float*}, {%FBO*, float, float, float, float*, float*, float*}* %fstruct, i32 0, i32 6
%arg_6 = load float*, float** %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)*,  void (i8*, i8*, %FBO*, float, float, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, float %arg_1, float %arg_2, float %arg_3, float* %arg_4, float* %arg_5, float* %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline605 = hidden constant [93 x i8] c"xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0\00"
@gsxtmgraphics-pipeline606 = hidden constant [90 x i8] c"{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}**\00"
define dllexport fastcc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0__13848(i8* %_impz,i8* %_impenv, %FBO* %fbo, float %x, float %y, float %flength, float %fstop, float* %model, float* %view, float* %projection) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13849 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}***}*
%xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}**** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr
%xPtr = alloca float
store float %x, float* %xPtr
%yPtr = alloca float
store float %y, float* %yPtr
%flengthPtr = alloca float
store float %flength, float* %flengthPtr
%fstopPtr = alloca float
store float %fstop, float* %fstopPtr
%modelPtr = alloca float*
store float* %model, float** %modelPtr
%viewPtr = alloca float*
store float* %view, float** %viewPtr
%projectionPtr = alloca float*
store float* %projection, float** %projectionPtr


%val13850 = load %FBO*, %FBO** %fboPtr
%val13851 = load float, float* %xPtr
%val13852 = load float, float* %yPtr
%val13853 = load float, float* %flengthPtr
%val13854 = load float, float* %fstopPtr
%val13855 = load float*, float** %modelPtr
%val13856 = load float*, float** %viewPtr
%val13857 = load float*, float** %projectionPtr
call fastcc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ(%FBO* %val13850, i32 1, float %val13851, float %val13852, float 0x0, float %val13853, float %val13854, i32 0, float* %val13855, float* %val13856, float* %val13857)
ret void
}
@gsxtmgraphics-pipeline607 = hidden constant [146 x i8] c"xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}** @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13878 = load i8*, i8** %_impzPtr
%zone13879 = bitcast i8* %tzone13878 to %mzone*

; let assign value to symbol xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0
%dat_xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone13879, i64 8)
%xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr = bitcast i8* %dat_xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0 to { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}***
%tzone13859 = load i8*, i8** %_impzPtr
%zone13860 = bitcast i8* %tzone13859 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13860)
; malloc closure structure
%clsptr13861 = call i8* @llvm_zone_malloc(%mzone* %zone13860, i64 24)
%closure13862 = bitcast i8* %clsptr13861 to { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}*

; malloc environment structure
%envptr13863 = call i8* @llvm_zone_malloc(%mzone* %zone13860, i64 8)
%environment13864 = bitcast i8* %envptr13863 to {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}***}*

; malloc closure address table
%addytable13865 = call %clsvar* @new_address_table()
%var13866 = bitcast [93 x i8]* @gsxtmgraphics-pipeline605 to i8*
%var13867 = bitcast [90 x i8]* @gsxtmgraphics-pipeline606 to i8*
%addytable13868 = call %clsvar* @add_address_table(%mzone* %zone13860, i8* %var13866, i32 0, i8* %var13867, i32 3, %clsvar* %addytable13865)
%address-table13869 = bitcast %clsvar* %addytable13868 to i8*

; insert table, function and environment into closure struct
%closure.table13872 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}* %closure13862, i32 0, i32 0
store i8* %address-table13869, i8** %closure.table13872
%closure.env13873 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}* %closure13862, i32 0, i32 1
store i8* %envptr13863, i8** %closure.env13873
%closure.func13874 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}* %closure13862, i32 0, i32 2
store void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0__13848, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)** %closure.func13874
%closure_size13875 = call i64 @llvm_zone_mark_size(%mzone* %zone13860)
call void @llvm_zone_ptr_set_size(i8* %clsptr13861, i64 %closure_size13875)
%wrapper_ptr13876 = call i8* @llvm_zone_malloc(%mzone* %zone13860, i64 8)
%closure_wrapper13877 = bitcast i8* %wrapper_ptr13876 to { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}* %closure13862, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}** %closure_wrapper13877

; let value assignment
%xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}** %closure_wrapper13877, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}** %closure_wrapper13877
store { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}*** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr

; add data to environment
; don't need to alloc for env var xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0
%tmp_envptr13871 = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}***}* %environment13864, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}*** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}**** %tmp_envptr13871


%val13880 = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}*** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}** %val13880
}


@xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}** @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0(%FBO* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4,float* %arg_5,float* %arg_6,float* %arg_7) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*,  void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4, float* %arg_5, float* %arg_6, float* %arg_7)
ret void
}


define dllexport ccc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_native(%FBO* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4,float* %arg_5,float* %arg_6,float* %arg_7) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*,  void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4, float* %arg_5, float* %arg_6, float* %arg_7)
ret void
}


define dllexport ccc i8*  @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13881 = bitcast [146 x i8]* @gsxtmgraphics-pipeline607 to i8*
call i32 (i8*, ...) @printf(i8* %var13881)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var13882 = bitcast [146 x i8]* @gsxtmgraphics-pipeline607 to i8*
call i32 (i8*, ...) @printf(i8* %var13882)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var13883 = bitcast [146 x i8]* @gsxtmgraphics-pipeline607 to i8*
call i32 (i8*, ...) @printf(i8* %var13883)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var13884 = bitcast [146 x i8]* @gsxtmgraphics-pipeline607 to i8*
call i32 (i8*, ...) @printf(i8* %var13884)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var13885 = bitcast [146 x i8]* @gsxtmgraphics-pipeline607 to i8*
call i32 (i8*, ...) @printf(i8* %var13885)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var13886 = bitcast [146 x i8]* @gsxtmgraphics-pipeline607 to i8*
call i32 (i8*, ...) @printf(i8* %var13886)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to float*
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var13887 = bitcast [146 x i8]* @gsxtmgraphics-pipeline607 to i8*
call i32 (i8*, ...) @printf(i8* %var13887)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to float*
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_cptr(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var13888 = bitcast [146 x i8]* @gsxtmgraphics-pipeline607 to i8*
call i32 (i8*, ...) @printf(i8* %var13888)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%ttv_7 = call ccc i8* @cptr_value(i8* %arg_7_val)
%arg_7 = bitcast i8* %ttv_7 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*,  void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4, float* %arg_5, float* %arg_6, float* %arg_7)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*, float, float, float, float, float*, float*, float*}*
%arg_p_0 = getelementptr {%FBO*, float, float, float, float, float*, float*, float*}, {%FBO*, float, float, float, float, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
%arg_p_1 = getelementptr {%FBO*, float, float, float, float, float*, float*, float*}, {%FBO*, float, float, float, float, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {%FBO*, float, float, float, float, float*, float*, float*}, {%FBO*, float, float, float, float, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {%FBO*, float, float, float, float, float*, float*, float*}, {%FBO*, float, float, float, float, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {%FBO*, float, float, float, float, float*, float*, float*}, {%FBO*, float, float, float, float, float*, float*, float*}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
%arg_p_5 = getelementptr {%FBO*, float, float, float, float, float*, float*, float*}, {%FBO*, float, float, float, float, float*, float*, float*}* %fstruct, i32 0, i32 5
%arg_5 = load float*, float** %arg_p_5
%arg_p_6 = getelementptr {%FBO*, float, float, float, float, float*, float*, float*}, {%FBO*, float, float, float, float, float*, float*, float*}* %fstruct, i32 0, i32 6
%arg_6 = load float*, float** %arg_p_6
%arg_p_7 = getelementptr {%FBO*, float, float, float, float, float*, float*, float*}, {%FBO*, float, float, float, float, float*, float*, float*}* %fstruct, i32 0, i32 7
%arg_7 = load float*, float** %arg_p_7
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCosZmxvYXQqLGZsb2F0Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)*,  void (i8*, i8*, %FBO*, float, float, float, float, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4, float* %arg_5, float* %arg_6, float* %arg_7)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline608 = hidden constant [90 x i8] c"xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd\00"
@gsxtmgraphics-pipeline609 = hidden constant [88 x i8] c"{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}**\00"
define dllexport fastcc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd__13889(i8* %_impz,i8* %_impenv, %FBO* %fbo, float %fdepth, float %flength, float %fstop, i32 %show_depth, float* %model, float* %view, float* %projection) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13890 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}***}*
%xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}**** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr
%fdepthPtr = alloca float
store float %fdepth, float* %fdepthPtr
%flengthPtr = alloca float
store float %flength, float* %flengthPtr
%fstopPtr = alloca float
store float %fstop, float* %fstopPtr
%show_depthPtr = alloca i32
store i32 %show_depth, i32* %show_depthPtr
%modelPtr = alloca float*
store float* %model, float** %modelPtr
%viewPtr = alloca float*
store float* %view, float** %viewPtr
%projectionPtr = alloca float*
store float* %projection, float** %projectionPtr


%val13891 = load %FBO*, %FBO** %fboPtr
%val13892 = load float, float* %fdepthPtr
%val13893 = load float, float* %flengthPtr
%val13894 = load float, float* %fstopPtr
%val13895 = load i32, i32* %show_depthPtr
%val13896 = load float*, float** %modelPtr
%val13897 = load float*, float** %viewPtr
%val13898 = load float*, float** %projectionPtr
call fastcc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ(%FBO* %val13891, i32 0, float 0x3fe0000000000000, float 0x3fe0000000000000, float %val13892, float %val13893, float %val13894, i32 %val13895, float* %val13896, float* %val13897, float* %val13898)
ret void
}
@gsxtmgraphics-pipeline610 = hidden constant [143 x i8] c"xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}** @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13919 = load i8*, i8** %_impzPtr
%zone13920 = bitcast i8* %tzone13919 to %mzone*

; let assign value to symbol xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd
%dat_xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd = call i8* @llvm_zone_malloc(%mzone* %zone13920, i64 8)
%xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr = bitcast i8* %dat_xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd to { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}***
%tzone13900 = load i8*, i8** %_impzPtr
%zone13901 = bitcast i8* %tzone13900 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13901)
; malloc closure structure
%clsptr13902 = call i8* @llvm_zone_malloc(%mzone* %zone13901, i64 24)
%closure13903 = bitcast i8* %clsptr13902 to { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}*

; malloc environment structure
%envptr13904 = call i8* @llvm_zone_malloc(%mzone* %zone13901, i64 8)
%environment13905 = bitcast i8* %envptr13904 to {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}***}*

; malloc closure address table
%addytable13906 = call %clsvar* @new_address_table()
%var13907 = bitcast [90 x i8]* @gsxtmgraphics-pipeline608 to i8*
%var13908 = bitcast [88 x i8]* @gsxtmgraphics-pipeline609 to i8*
%addytable13909 = call %clsvar* @add_address_table(%mzone* %zone13901, i8* %var13907, i32 0, i8* %var13908, i32 3, %clsvar* %addytable13906)
%address-table13910 = bitcast %clsvar* %addytable13909 to i8*

; insert table, function and environment into closure struct
%closure.table13913 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}* %closure13903, i32 0, i32 0
store i8* %address-table13910, i8** %closure.table13913
%closure.env13914 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}* %closure13903, i32 0, i32 1
store i8* %envptr13904, i8** %closure.env13914
%closure.func13915 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}* %closure13903, i32 0, i32 2
store void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd__13889, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)** %closure.func13915
%closure_size13916 = call i64 @llvm_zone_mark_size(%mzone* %zone13901)
call void @llvm_zone_ptr_set_size(i8* %clsptr13902, i64 %closure_size13916)
%wrapper_ptr13917 = call i8* @llvm_zone_malloc(%mzone* %zone13901, i64 8)
%closure_wrapper13918 = bitcast i8* %wrapper_ptr13917 to { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}* %closure13903, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}** %closure_wrapper13918

; let value assignment
%xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd = select i1 true, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}** %closure_wrapper13918, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}** %closure_wrapper13918
store { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}*** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr

; add data to environment
; don't need to alloc for env var xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd
%tmp_envptr13912 = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}***}* %environment13905, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}*** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}**** %tmp_envptr13912


%val13921 = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}*** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr
ret {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}** %val13921
}


@xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}** @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd(%FBO* %arg_0,float %arg_1,float %arg_2,float %arg_3,i32 %arg_4,float* %arg_5,float* %arg_6,float* %arg_7) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*,  void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, float %arg_1, float %arg_2, float %arg_3, i32 %arg_4, float* %arg_5, float* %arg_6, float* %arg_7)
ret void
}


define dllexport ccc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_native(%FBO* %arg_0,float %arg_1,float %arg_2,float %arg_3,i32 %arg_4,float* %arg_5,float* %arg_6,float* %arg_7) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*,  void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, float %arg_1, float %arg_2, float %arg_3, i32 %arg_4, float* %arg_5, float* %arg_6, float* %arg_7)
ret void
}


define dllexport ccc i8*  @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13922 = bitcast [143 x i8]* @gsxtmgraphics-pipeline610 to i8*
call i32 (i8*, ...) @printf(i8* %var13922)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var13923 = bitcast [143 x i8]* @gsxtmgraphics-pipeline610 to i8*
call i32 (i8*, ...) @printf(i8* %var13923)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var13924 = bitcast [143 x i8]* @gsxtmgraphics-pipeline610 to i8*
call i32 (i8*, ...) @printf(i8* %var13924)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var13925 = bitcast [143 x i8]* @gsxtmgraphics-pipeline610 to i8*
call i32 (i8*, ...) @printf(i8* %var13925)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var13926 = bitcast [143 x i8]* @gsxtmgraphics-pipeline610 to i8*
call i32 (i8*, ...) @printf(i8* %var13926)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var13927 = bitcast [143 x i8]* @gsxtmgraphics-pipeline610 to i8*
call i32 (i8*, ...) @printf(i8* %var13927)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to float*
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var13928 = bitcast [143 x i8]* @gsxtmgraphics-pipeline610 to i8*
call i32 (i8*, ...) @printf(i8* %var13928)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to float*
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_cptr(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var13929 = bitcast [143 x i8]* @gsxtmgraphics-pipeline610 to i8*
call i32 (i8*, ...) @printf(i8* %var13929)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%ttv_7 = call ccc i8* @cptr_value(i8* %arg_7_val)
%arg_7 = bitcast i8* %ttv_7 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*,  void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, float %arg_1, float %arg_2, float %arg_3, i32 %arg_4, float* %arg_5, float* %arg_6, float* %arg_7)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*, float, float, float, i32, float*, float*, float*}*
%arg_p_0 = getelementptr {%FBO*, float, float, float, i32, float*, float*, float*}, {%FBO*, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
%arg_p_1 = getelementptr {%FBO*, float, float, float, i32, float*, float*, float*}, {%FBO*, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {%FBO*, float, float, float, i32, float*, float*, float*}, {%FBO*, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {%FBO*, float, float, float, i32, float*, float*, float*}, {%FBO*, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {%FBO*, float, float, float, i32, float*, float*, float*}, {%FBO*, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
%arg_p_5 = getelementptr {%FBO*, float, float, float, i32, float*, float*, float*}, {%FBO*, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 5
%arg_5 = load float*, float** %arg_p_5
%arg_p_6 = getelementptr {%FBO*, float, float, float, i32, float*, float*, float*}, {%FBO*, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 6
%arg_6 = load float*, float** %arg_p_6
%arg_p_7 = getelementptr {%FBO*, float, float, float, i32, float*, float*, float*}, {%FBO*, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 7
%arg_7 = load float*, float** %arg_p_7
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)*,  void (i8*, i8*, %FBO*, float, float, float, i32, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, float %arg_1, float %arg_2, float %arg_3, i32 %arg_4, float* %arg_5, float* %arg_6, float* %arg_7)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline611 = hidden constant [98 x i8] c"xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd\00"
@gsxtmgraphics-pipeline612 = hidden constant [95 x i8] c"{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}**\00"
define dllexport fastcc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd__13930(i8* %_impz,i8* %_impenv, %FBO* %fbo, float %x, float %y, float %flength, float %fstop, i32 %show_depth, float* %model, float* %view, float* %projection) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13931 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}***}*
%xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}***}* %impenv, i32 0, i32 0
%xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}***, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}**** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr
%xPtr = alloca float
store float %x, float* %xPtr
%yPtr = alloca float
store float %y, float* %yPtr
%flengthPtr = alloca float
store float %flength, float* %flengthPtr
%fstopPtr = alloca float
store float %fstop, float* %fstopPtr
%show_depthPtr = alloca i32
store i32 %show_depth, i32* %show_depthPtr
%modelPtr = alloca float*
store float* %model, float** %modelPtr
%viewPtr = alloca float*
store float* %view, float** %viewPtr
%projectionPtr = alloca float*
store float* %projection, float** %projectionPtr


%val13932 = load %FBO*, %FBO** %fboPtr
%val13933 = load float, float* %xPtr
%val13934 = load float, float* %yPtr
%val13935 = load float, float* %flengthPtr
%val13936 = load float, float* %fstopPtr
%val13937 = load i32, i32* %show_depthPtr
%val13938 = load float*, float** %modelPtr
%val13939 = load float*, float** %viewPtr
%val13940 = load float*, float** %projectionPtr
call fastcc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixpMzIsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXQsaTMyLGZsb2F0KixmbG9hdCosZmxvYXQqXQ(%FBO* %val13932, i32 1, float %val13933, float %val13934, float 0x0, float %val13935, float %val13936, i32 %val13937, float* %val13938, float* %val13939, float* %val13940)
ret void
}
@gsxtmgraphics-pipeline613 = hidden constant [151 x i8] c"xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}** @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone13961 = load i8*, i8** %_impzPtr
%zone13962 = bitcast i8* %tzone13961 to %mzone*

; let assign value to symbol xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd
%dat_xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd = call i8* @llvm_zone_malloc(%mzone* %zone13962, i64 8)
%xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr = bitcast i8* %dat_xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd to { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}***
%tzone13942 = load i8*, i8** %_impzPtr
%zone13943 = bitcast i8* %tzone13942 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13943)
; malloc closure structure
%clsptr13944 = call i8* @llvm_zone_malloc(%mzone* %zone13943, i64 24)
%closure13945 = bitcast i8* %clsptr13944 to { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}*

; malloc environment structure
%envptr13946 = call i8* @llvm_zone_malloc(%mzone* %zone13943, i64 8)
%environment13947 = bitcast i8* %envptr13946 to {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}***}*

; malloc closure address table
%addytable13948 = call %clsvar* @new_address_table()
%var13949 = bitcast [98 x i8]* @gsxtmgraphics-pipeline611 to i8*
%var13950 = bitcast [95 x i8]* @gsxtmgraphics-pipeline612 to i8*
%addytable13951 = call %clsvar* @add_address_table(%mzone* %zone13943, i8* %var13949, i32 0, i8* %var13950, i32 3, %clsvar* %addytable13948)
%address-table13952 = bitcast %clsvar* %addytable13951 to i8*

; insert table, function and environment into closure struct
%closure.table13955 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}* %closure13945, i32 0, i32 0
store i8* %address-table13952, i8** %closure.table13955
%closure.env13956 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}* %closure13945, i32 0, i32 1
store i8* %envptr13946, i8** %closure.env13956
%closure.func13957 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}* %closure13945, i32 0, i32 2
store void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd__13930, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)** %closure.func13957
%closure_size13958 = call i64 @llvm_zone_mark_size(%mzone* %zone13943)
call void @llvm_zone_ptr_set_size(i8* %clsptr13944, i64 %closure_size13958)
%wrapper_ptr13959 = call i8* @llvm_zone_malloc(%mzone* %zone13943, i64 8)
%closure_wrapper13960 = bitcast i8* %wrapper_ptr13959 to { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}**
store { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}* %closure13945, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}** %closure_wrapper13960

; let value assignment
%xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd = select i1 true, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}** %closure_wrapper13960, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}** %closure_wrapper13960
store { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd, { i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}*** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr

; add data to environment
; don't need to alloc for env var xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd
%tmp_envptr13954 = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}***}* %environment13947, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}*** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}**** %tmp_envptr13954


%val13963 = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}**, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}*** %xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpdPtr
ret {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}** %val13963
}


@xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}** @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd(%FBO* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4,i32 %arg_5,float* %arg_6,float* %arg_7,float* %arg_8) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*,  void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4, i32 %arg_5, float* %arg_6, float* %arg_7, float* %arg_8)
ret void
}


define dllexport ccc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_native(%FBO* %arg_0,float %arg_1,float %arg_2,float %arg_3,float %arg_4,i32 %arg_5,float* %arg_6,float* %arg_7,float* %arg_8) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*,  void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4, i32 %arg_5, float* %arg_6, float* %arg_7, float* %arg_8)
ret void
}


define dllexport ccc i8*  @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var13964 = bitcast [151 x i8]* @gsxtmgraphics-pipeline613 to i8*
call i32 (i8*, ...) @printf(i8* %var13964)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var13965 = bitcast [151 x i8]* @gsxtmgraphics-pipeline613 to i8*
call i32 (i8*, ...) @printf(i8* %var13965)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var13966 = bitcast [151 x i8]* @gsxtmgraphics-pipeline613 to i8*
call i32 (i8*, ...) @printf(i8* %var13966)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var13967 = bitcast [151 x i8]* @gsxtmgraphics-pipeline613 to i8*
call i32 (i8*, ...) @printf(i8* %var13967)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var13968 = bitcast [151 x i8]* @gsxtmgraphics-pipeline613 to i8*
call i32 (i8*, ...) @printf(i8* %var13968)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var13969 = bitcast [151 x i8]* @gsxtmgraphics-pipeline613 to i8*
call i32 (i8*, ...) @printf(i8* %var13969)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var13970 = bitcast [151 x i8]* @gsxtmgraphics-pipeline613 to i8*
call i32 (i8*, ...) @printf(i8* %var13970)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to float*
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_cptr(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var13971 = bitcast [151 x i8]* @gsxtmgraphics-pipeline613 to i8*
call i32 (i8*, ...) @printf(i8* %var13971)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%ttv_7 = call ccc i8* @cptr_value(i8* %arg_7_val)
%arg_7 = bitcast i8* %ttv_7 to float*
%arg_8_val = call ccc i8* @list_ref(i8* %_sc, i32 8,i8* %args)
%arg_8_rt_check = call i32 @is_cptr(i8* %arg_8_val)
%arg_8_bool = icmp ne i32 %arg_8_rt_check, 0
br i1 %arg_8_bool, label %arg_8_true, label %arg_8_false

arg_8_true:
br label %arg_8_continue

arg_8_false:
%var13972 = bitcast [151 x i8]* @gsxtmgraphics-pipeline613 to i8*
call i32 (i8*, ...) @printf(i8* %var13972)
%arg_8_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_8_errret

arg_8_continue:
%ttv_8 = call ccc i8* @cptr_value(i8* %arg_8_val)
%arg_8 = bitcast i8* %ttv_8 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*,  void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4, i32 %arg_5, float* %arg_6, float* %arg_7, float* %arg_8)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*, float, float, float, float, i32, float*, float*, float*}*
%arg_p_0 = getelementptr {%FBO*, float, float, float, float, i32, float*, float*, float*}, {%FBO*, float, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
%arg_p_1 = getelementptr {%FBO*, float, float, float, float, i32, float*, float*, float*}, {%FBO*, float, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {%FBO*, float, float, float, float, i32, float*, float*, float*}, {%FBO*, float, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {%FBO*, float, float, float, float, i32, float*, float*, float*}, {%FBO*, float, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
%arg_p_4 = getelementptr {%FBO*, float, float, float, float, i32, float*, float*, float*}, {%FBO*, float, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
%arg_p_5 = getelementptr {%FBO*, float, float, float, float, i32, float*, float*, float*}, {%FBO*, float, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
%arg_p_6 = getelementptr {%FBO*, float, float, float, float, i32, float*, float*, float*}, {%FBO*, float, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 6
%arg_6 = load float*, float** %arg_p_6
%arg_p_7 = getelementptr {%FBO*, float, float, float, float, i32, float*, float*, float*}, {%FBO*, float, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 7
%arg_7 = load float*, float** %arg_p_7
%arg_p_8 = getelementptr {%FBO*, float, float, float, float, i32, float*, float*, float*}, {%FBO*, float, float, float, float, i32, float*, float*, float*}* %fstruct, i32 0, i32 8
%arg_8 = load float*, float** %arg_p_8
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)*,  void (i8*, i8*, %FBO*, float, float, float, float, i32, float*, float*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4, i32 %arg_5, float* %arg_6, float* %arg_7, float* %arg_8)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline614 = hidden constant [30 x i8] c"xtm_render_fbo_adhoc_W0ZCTypd\00"
@gsxtmgraphics-pipeline615 = hidden constant [32 x i8] c"{i8*, i8*, %FBO* (i8*, i8*)*}**\00"
@gsxtmgraphics-pipeline616 = hidden constant [4 x i8] c"fbo\00"
@gsxtmgraphics-pipeline617 = hidden constant [6 x i8] c"%FBO*\00"
@gsxtmgraphics-pipeline618 = hidden constant [16 x i8] c"_anon_lambda_24\00"
define dllexport fastcc %FBO* @xtm_render_fbo_adhoc_W0ZCTypd__13973(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone13977 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}*
%xtm_render_fbo_adhoc_W0ZCTypdPtr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%xtm_render_fbo_adhoc_W0ZCTypdPtr = load {i8*, i8*, %FBO* (i8*, i8*)*}***, {i8*, i8*, %FBO* (i8*, i8*)*}**** %xtm_render_fbo_adhoc_W0ZCTypdPtr_
%fboPtr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}* %impenv, i32 0, i32 1
%fboPtr = load %FBO**, %FBO*** %fboPtr_
%_anon_lambda_24Ptr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_24Ptr = load {i8*, i8*, %FBO* (i8*, i8*)*}***, {i8*, i8*, %FBO* (i8*, i8*)*}**** %_anon_lambda_24Ptr_

; setup arguments

; promote local stack var allocations
%tzone13987 = load i8*, i8** %_impzPtr
%zone13988 = bitcast i8* %tzone13987 to %mzone*
%ifptr13978 = alloca %FBO*

%val13979 = load %FBO*, %FBO** %fboPtr
%val13980 = icmp eq %FBO* %val13979, null
br i1 %val13980, label %then13978, label %else13978

then13978:
; do set!
%val13981 = load i32, i32* @xtm_render_w
%val13982 = load i32, i32* @xtm_render_h
%res13983 = call ccc i1 @impc_true()
%res13984 = call fastcc %FBO* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0(i32 %val13981, i32 %val13982, i1 %res13983)
store %FBO* %res13984, %FBO** %fboPtr
store %FBO* %res13984, %FBO** %ifptr13978
br label %ifcont13978

else13978:
br label %ifcont13978

ifcont13978:
%ifres13985 = load %FBO*, %FBO** %ifptr13978

%val13986 = load %FBO*, %FBO** %fboPtr
ret %FBO* %val13986
}
define dllexport ccc {i8*, i8*, %FBO* (i8*, i8*)*}** @xtm_render_fbo_adhoc_W0ZCTypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone14021 = load i8*, i8** %_impzPtr
%zone14022 = bitcast i8* %tzone14021 to %mzone*

; let assign value to symbol xtm_render_fbo_adhoc_W0ZCTypd
%dat_xtm_render_fbo_adhoc_W0ZCTypd = call i8* @llvm_zone_malloc(%mzone* %zone14022, i64 8)
%xtm_render_fbo_adhoc_W0ZCTypdPtr = bitcast i8* %dat_xtm_render_fbo_adhoc_W0ZCTypd to {i8*, i8*, %FBO* (i8*, i8*)*}***
%tzone13975 = load i8*, i8** %_impzPtr
%zone13976 = bitcast i8* %tzone13975 to %mzone*

; let assign value to symbol fbo
%dat_fbo = call i8* @llvm_zone_malloc(%mzone* %zone13976, i64 8)
%fboPtr = bitcast i8* %dat_fbo to %FBO**
%null13974 = bitcast i8* null to %FBO*

; let value assignment
%fbo = select i1 true, %FBO* %null13974, %FBO* %null13974
store %FBO* %fbo, %FBO** %fboPtr

%tzone14018 = load i8*, i8** %_impzPtr
%zone14019 = bitcast i8* %tzone14018 to %mzone*

; let assign value to symbol _anon_lambda_24
%dat__anon_lambda_24 = call i8* @llvm_zone_malloc(%mzone* %zone14019, i64 8)
%_anon_lambda_24Ptr = bitcast i8* %dat__anon_lambda_24 to { i8*, i8*, %FBO* (i8*, i8*)*}***
%tzone13989 = load i8*, i8** %_impzPtr
%zone13990 = bitcast i8* %tzone13989 to %mzone*
call void @llvm_zone_mark(%mzone* %zone13990)
; malloc closure structure
%clsptr13991 = call i8* @llvm_zone_malloc(%mzone* %zone13990, i64 24)
%closure13992 = bitcast i8* %clsptr13991 to { i8*, i8*, %FBO* (i8*, i8*)*}*

; malloc environment structure
%envptr13993 = call i8* @llvm_zone_malloc(%mzone* %zone13990, i64 24)
%environment13994 = bitcast i8* %envptr13993 to {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}*

; malloc closure address table
%addytable13995 = call %clsvar* @new_address_table()
%var13996 = bitcast [30 x i8]* @gsxtmgraphics-pipeline614 to i8*
%var13997 = bitcast [32 x i8]* @gsxtmgraphics-pipeline615 to i8*
%addytable13998 = call %clsvar* @add_address_table(%mzone* %zone13990, i8* %var13996, i32 0, i8* %var13997, i32 3, %clsvar* %addytable13995)
%var13999 = bitcast [4 x i8]* @gsxtmgraphics-pipeline616 to i8*
%var14000 = bitcast [6 x i8]* @gsxtmgraphics-pipeline617 to i8*
%addytable14001 = call %clsvar* @add_address_table(%mzone* %zone13990, i8* %var13999, i32 8, i8* %var14000, i32 3, %clsvar* %addytable13998)
%var14002 = bitcast [16 x i8]* @gsxtmgraphics-pipeline618 to i8*
%var14003 = bitcast [32 x i8]* @gsxtmgraphics-pipeline615 to i8*
%addytable14004 = call %clsvar* @add_address_table(%mzone* %zone13990, i8* %var14002, i32 16, i8* %var14003, i32 3, %clsvar* %addytable14001)
%address-table14005 = bitcast %clsvar* %addytable14004 to i8*

; insert table, function and environment into closure struct
%closure.table14012 = getelementptr { i8*, i8*, %FBO* (i8*, i8*)*}, { i8*, i8*, %FBO* (i8*, i8*)*}* %closure13992, i32 0, i32 0
store i8* %address-table14005, i8** %closure.table14012
%closure.env14013 = getelementptr { i8*, i8*, %FBO* (i8*, i8*)*}, { i8*, i8*, %FBO* (i8*, i8*)*}* %closure13992, i32 0, i32 1
store i8* %envptr13993, i8** %closure.env14013
%closure.func14014 = getelementptr { i8*, i8*, %FBO* (i8*, i8*)*}, { i8*, i8*, %FBO* (i8*, i8*)*}* %closure13992, i32 0, i32 2
store %FBO* (i8*, i8*)* @xtm_render_fbo_adhoc_W0ZCTypd__13973, %FBO* (i8*, i8*)** %closure.func14014
%closure_size14015 = call i64 @llvm_zone_mark_size(%mzone* %zone13990)
call void @llvm_zone_ptr_set_size(i8* %clsptr13991, i64 %closure_size14015)
%wrapper_ptr14016 = call i8* @llvm_zone_malloc(%mzone* %zone13990, i64 8)
%closure_wrapper14017 = bitcast i8* %wrapper_ptr14016 to { i8*, i8*, %FBO* (i8*, i8*)*}**
store { i8*, i8*, %FBO* (i8*, i8*)*}* %closure13992, { i8*, i8*, %FBO* (i8*, i8*)*}** %closure_wrapper14017

; let value assignment
%_anon_lambda_24 = select i1 true, { i8*, i8*, %FBO* (i8*, i8*)*}** %closure_wrapper14017, { i8*, i8*, %FBO* (i8*, i8*)*}** %closure_wrapper14017
store { i8*, i8*, %FBO* (i8*, i8*)*}** %_anon_lambda_24, { i8*, i8*, %FBO* (i8*, i8*)*}*** %_anon_lambda_24Ptr

; add data to environment
; don't need to alloc for env var xtm_render_fbo_adhoc_W0ZCTypd
%tmp_envptr14007 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}* %environment13994, i32 0, i32 0
store {i8*, i8*, %FBO* (i8*, i8*)*}*** %xtm_render_fbo_adhoc_W0ZCTypdPtr, {i8*, i8*, %FBO* (i8*, i8*)*}**** %tmp_envptr14007

; don't need to alloc for env var fbo
%tmp_envptr14009 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}* %environment13994, i32 0, i32 1
store %FBO** %fboPtr, %FBO*** %tmp_envptr14009

; don't need to alloc for env var _anon_lambda_24
%tmp_envptr14011 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}* %environment13994, i32 0, i32 2
store {i8*, i8*, %FBO* (i8*, i8*)*}*** %_anon_lambda_24Ptr, {i8*, i8*, %FBO* (i8*, i8*)*}**** %tmp_envptr14011


%val14020 = load {i8*, i8*, %FBO* (i8*, i8*)*}**, {i8*, i8*, %FBO* (i8*, i8*)*}*** %_anon_lambda_24Ptr

; let value assignment
%xtm_render_fbo_adhoc_W0ZCTypd = select i1 true, {i8*, i8*, %FBO* (i8*, i8*)*}** %val14020, {i8*, i8*, %FBO* (i8*, i8*)*}** %val14020
store {i8*, i8*, %FBO* (i8*, i8*)*}** %xtm_render_fbo_adhoc_W0ZCTypd, {i8*, i8*, %FBO* (i8*, i8*)*}*** %xtm_render_fbo_adhoc_W0ZCTypdPtr

%val14023 = load {i8*, i8*, %FBO* (i8*, i8*)*}**, {i8*, i8*, %FBO* (i8*, i8*)*}*** %xtm_render_fbo_adhoc_W0ZCTypdPtr
ret {i8*, i8*, %FBO* (i8*, i8*)*}** %val14023
}


@xtm_render_fbo_adhoc_W0ZCTypd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_render_fbo_adhoc_W0ZCTypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_render_fbo_adhoc_W0ZCTypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_fbo_adhoc_W0ZCTypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %FBO* (i8*, i8*)*}** @xtm_render_fbo_adhoc_W0ZCTypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %FBO* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_render_fbo_adhoc_W0ZCTypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_render_fbo_adhoc_W0ZCTypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_fbo_adhoc_W0ZCTypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %FBO* @xtm_render_fbo_adhoc_W0ZCTypd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_fbo_adhoc_W0ZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*)*}*, {i8*, i8*, %FBO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*)*,  %FBO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee)
ret %FBO* %result
}


define dllexport ccc %FBO* @xtm_render_fbo_adhoc_W0ZCTypd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_fbo_adhoc_W0ZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*)*}*, {i8*, i8*, %FBO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*)*,  %FBO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee)
ret %FBO* %result
}


define dllexport ccc i8*  @xtm_render_fbo_adhoc_W0ZCTypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_fbo_adhoc_W0ZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*)*}*, {i8*, i8*, %FBO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*)*,  %FBO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast %FBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @xtm_render_fbo_adhoc_W0ZCTypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_fbo_adhoc_W0ZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*)*}*, {i8*, i8*, %FBO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*)*,  %FBO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline619 = hidden constant [30 x i8] c"xtm_shadow_fbo_adhoc_W0ZCTypd\00"
@gsxtmgraphics-pipeline620 = hidden constant [16 x i8] c"_anon_lambda_25\00"
define dllexport fastcc %FBO* @xtm_shadow_fbo_adhoc_W0ZCTypd__14024(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone14028 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}*
%xtm_shadow_fbo_adhoc_W0ZCTypdPtr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%xtm_shadow_fbo_adhoc_W0ZCTypdPtr = load {i8*, i8*, %FBO* (i8*, i8*)*}***, {i8*, i8*, %FBO* (i8*, i8*)*}**** %xtm_shadow_fbo_adhoc_W0ZCTypdPtr_
%fboPtr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}* %impenv, i32 0, i32 1
%fboPtr = load %FBO**, %FBO*** %fboPtr_
%_anon_lambda_25Ptr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_25Ptr = load {i8*, i8*, %FBO* (i8*, i8*)*}***, {i8*, i8*, %FBO* (i8*, i8*)*}**** %_anon_lambda_25Ptr_

; setup arguments

; promote local stack var allocations
%tzone14040 = load i8*, i8** %_impzPtr
%zone14041 = bitcast i8* %tzone14040 to %mzone*
%ifptr14029 = alloca %FBO*

%val14030 = load %FBO*, %FBO** %fboPtr
%val14031 = icmp eq %FBO* %val14030, null
br i1 %val14031, label %then14029, label %else14029

then14029:
; do set!
%val14032 = fmul float 0x4010000000000000, 0x4090000000000000
%res14033 = call ccc i32 @ftoi32(float %val14032)
%val14034 = fmul float 0x4010000000000000, 0x4090000000000000
%res14035 = call ccc i32 @ftoi32(float %val14034)
%res14036 = call ccc i1 @impc_true()
%res14037 = call fastcc %FBO* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0(i32 %res14033, i32 %res14035, i1 %res14036)
store %FBO* %res14037, %FBO** %fboPtr
store %FBO* %res14037, %FBO** %ifptr14029
br label %ifcont14029

else14029:
br label %ifcont14029

ifcont14029:
%ifres14038 = load %FBO*, %FBO** %ifptr14029

%val14039 = load %FBO*, %FBO** %fboPtr
ret %FBO* %val14039
}
define dllexport ccc {i8*, i8*, %FBO* (i8*, i8*)*}** @xtm_shadow_fbo_adhoc_W0ZCTypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone14074 = load i8*, i8** %_impzPtr
%zone14075 = bitcast i8* %tzone14074 to %mzone*

; let assign value to symbol xtm_shadow_fbo_adhoc_W0ZCTypd
%dat_xtm_shadow_fbo_adhoc_W0ZCTypd = call i8* @llvm_zone_malloc(%mzone* %zone14075, i64 8)
%xtm_shadow_fbo_adhoc_W0ZCTypdPtr = bitcast i8* %dat_xtm_shadow_fbo_adhoc_W0ZCTypd to {i8*, i8*, %FBO* (i8*, i8*)*}***
%tzone14026 = load i8*, i8** %_impzPtr
%zone14027 = bitcast i8* %tzone14026 to %mzone*

; let assign value to symbol fbo
%dat_fbo = call i8* @llvm_zone_malloc(%mzone* %zone14027, i64 8)
%fboPtr = bitcast i8* %dat_fbo to %FBO**
%null14025 = bitcast i8* null to %FBO*

; let value assignment
%fbo = select i1 true, %FBO* %null14025, %FBO* %null14025
store %FBO* %fbo, %FBO** %fboPtr

%tzone14071 = load i8*, i8** %_impzPtr
%zone14072 = bitcast i8* %tzone14071 to %mzone*

; let assign value to symbol _anon_lambda_25
%dat__anon_lambda_25 = call i8* @llvm_zone_malloc(%mzone* %zone14072, i64 8)
%_anon_lambda_25Ptr = bitcast i8* %dat__anon_lambda_25 to { i8*, i8*, %FBO* (i8*, i8*)*}***
%tzone14042 = load i8*, i8** %_impzPtr
%zone14043 = bitcast i8* %tzone14042 to %mzone*
call void @llvm_zone_mark(%mzone* %zone14043)
; malloc closure structure
%clsptr14044 = call i8* @llvm_zone_malloc(%mzone* %zone14043, i64 24)
%closure14045 = bitcast i8* %clsptr14044 to { i8*, i8*, %FBO* (i8*, i8*)*}*

; malloc environment structure
%envptr14046 = call i8* @llvm_zone_malloc(%mzone* %zone14043, i64 24)
%environment14047 = bitcast i8* %envptr14046 to {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}*

; malloc closure address table
%addytable14048 = call %clsvar* @new_address_table()
%var14049 = bitcast [30 x i8]* @gsxtmgraphics-pipeline619 to i8*
%var14050 = bitcast [32 x i8]* @gsxtmgraphics-pipeline615 to i8*
%addytable14051 = call %clsvar* @add_address_table(%mzone* %zone14043, i8* %var14049, i32 0, i8* %var14050, i32 3, %clsvar* %addytable14048)
%var14052 = bitcast [4 x i8]* @gsxtmgraphics-pipeline616 to i8*
%var14053 = bitcast [6 x i8]* @gsxtmgraphics-pipeline617 to i8*
%addytable14054 = call %clsvar* @add_address_table(%mzone* %zone14043, i8* %var14052, i32 8, i8* %var14053, i32 3, %clsvar* %addytable14051)
%var14055 = bitcast [16 x i8]* @gsxtmgraphics-pipeline620 to i8*
%var14056 = bitcast [32 x i8]* @gsxtmgraphics-pipeline615 to i8*
%addytable14057 = call %clsvar* @add_address_table(%mzone* %zone14043, i8* %var14055, i32 16, i8* %var14056, i32 3, %clsvar* %addytable14054)
%address-table14058 = bitcast %clsvar* %addytable14057 to i8*

; insert table, function and environment into closure struct
%closure.table14065 = getelementptr { i8*, i8*, %FBO* (i8*, i8*)*}, { i8*, i8*, %FBO* (i8*, i8*)*}* %closure14045, i32 0, i32 0
store i8* %address-table14058, i8** %closure.table14065
%closure.env14066 = getelementptr { i8*, i8*, %FBO* (i8*, i8*)*}, { i8*, i8*, %FBO* (i8*, i8*)*}* %closure14045, i32 0, i32 1
store i8* %envptr14046, i8** %closure.env14066
%closure.func14067 = getelementptr { i8*, i8*, %FBO* (i8*, i8*)*}, { i8*, i8*, %FBO* (i8*, i8*)*}* %closure14045, i32 0, i32 2
store %FBO* (i8*, i8*)* @xtm_shadow_fbo_adhoc_W0ZCTypd__14024, %FBO* (i8*, i8*)** %closure.func14067
%closure_size14068 = call i64 @llvm_zone_mark_size(%mzone* %zone14043)
call void @llvm_zone_ptr_set_size(i8* %clsptr14044, i64 %closure_size14068)
%wrapper_ptr14069 = call i8* @llvm_zone_malloc(%mzone* %zone14043, i64 8)
%closure_wrapper14070 = bitcast i8* %wrapper_ptr14069 to { i8*, i8*, %FBO* (i8*, i8*)*}**
store { i8*, i8*, %FBO* (i8*, i8*)*}* %closure14045, { i8*, i8*, %FBO* (i8*, i8*)*}** %closure_wrapper14070

; let value assignment
%_anon_lambda_25 = select i1 true, { i8*, i8*, %FBO* (i8*, i8*)*}** %closure_wrapper14070, { i8*, i8*, %FBO* (i8*, i8*)*}** %closure_wrapper14070
store { i8*, i8*, %FBO* (i8*, i8*)*}** %_anon_lambda_25, { i8*, i8*, %FBO* (i8*, i8*)*}*** %_anon_lambda_25Ptr

; add data to environment
; don't need to alloc for env var xtm_shadow_fbo_adhoc_W0ZCTypd
%tmp_envptr14060 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}* %environment14047, i32 0, i32 0
store {i8*, i8*, %FBO* (i8*, i8*)*}*** %xtm_shadow_fbo_adhoc_W0ZCTypdPtr, {i8*, i8*, %FBO* (i8*, i8*)*}**** %tmp_envptr14060

; don't need to alloc for env var fbo
%tmp_envptr14062 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}* %environment14047, i32 0, i32 1
store %FBO** %fboPtr, %FBO*** %tmp_envptr14062

; don't need to alloc for env var _anon_lambda_25
%tmp_envptr14064 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*)*}***, %FBO**, {i8*, i8*, %FBO* (i8*, i8*)*}***}* %environment14047, i32 0, i32 2
store {i8*, i8*, %FBO* (i8*, i8*)*}*** %_anon_lambda_25Ptr, {i8*, i8*, %FBO* (i8*, i8*)*}**** %tmp_envptr14064


%val14073 = load {i8*, i8*, %FBO* (i8*, i8*)*}**, {i8*, i8*, %FBO* (i8*, i8*)*}*** %_anon_lambda_25Ptr

; let value assignment
%xtm_shadow_fbo_adhoc_W0ZCTypd = select i1 true, {i8*, i8*, %FBO* (i8*, i8*)*}** %val14073, {i8*, i8*, %FBO* (i8*, i8*)*}** %val14073
store {i8*, i8*, %FBO* (i8*, i8*)*}** %xtm_shadow_fbo_adhoc_W0ZCTypd, {i8*, i8*, %FBO* (i8*, i8*)*}*** %xtm_shadow_fbo_adhoc_W0ZCTypdPtr

%val14076 = load {i8*, i8*, %FBO* (i8*, i8*)*}**, {i8*, i8*, %FBO* (i8*, i8*)*}*** %xtm_shadow_fbo_adhoc_W0ZCTypdPtr
ret {i8*, i8*, %FBO* (i8*, i8*)*}** %val14076
}


@xtm_shadow_fbo_adhoc_W0ZCTypd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_shadow_fbo_adhoc_W0ZCTypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_shadow_fbo_adhoc_W0ZCTypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_shadow_fbo_adhoc_W0ZCTypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %FBO* (i8*, i8*)*}** @xtm_shadow_fbo_adhoc_W0ZCTypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %FBO* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_shadow_fbo_adhoc_W0ZCTypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_shadow_fbo_adhoc_W0ZCTypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_shadow_fbo_adhoc_W0ZCTypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %FBO* @xtm_shadow_fbo_adhoc_W0ZCTypd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_shadow_fbo_adhoc_W0ZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*)*}*, {i8*, i8*, %FBO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*)*,  %FBO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee)
ret %FBO* %result
}


define dllexport ccc %FBO* @xtm_shadow_fbo_adhoc_W0ZCTypd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_shadow_fbo_adhoc_W0ZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*)*}*, {i8*, i8*, %FBO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*)*,  %FBO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee)
ret %FBO* %result
}


define dllexport ccc i8*  @xtm_shadow_fbo_adhoc_W0ZCTypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_shadow_fbo_adhoc_W0ZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*)*}*, {i8*, i8*, %FBO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*)*,  %FBO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast %FBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @xtm_shadow_fbo_adhoc_W0ZCTypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_shadow_fbo_adhoc_W0ZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*)*}*, {i8*, i8*, %FBO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*)*,  %FBO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline621 = hidden constant [29 x i8] c"libs/external/gl/quad_v.glsl\00"
@gsxtmgraphics-pipeline622 = hidden constant [29 x i8] c"libs/external/gl/quad_f.glsl\00"
@gsxtmgraphics-pipeline623 = hidden constant [28 x i8] c"libs/external/gl/dof_f.glsl\00"
@gsxtmgraphics-pipeline624 = hidden constant [31 x i8] c"libs/external/gl/simple_v.glsl\00"
@gsxtmgraphics-pipeline625 = hidden constant [31 x i8] c"libs/external/gl/simple_f.glsl\00"
@gsxtmgraphics-pipeline626 = hidden constant [31 x i8] c"libs/external/gl/lights_v.glsl\00"
@gsxtmgraphics-pipeline627 = hidden constant [31 x i8] c"libs/external/gl/lights_f.glsl\00"
@gsxtmgraphics-pipeline628 = hidden constant [28 x i8] c"libs/external/gl/sky_v.glsl\00"
@gsxtmgraphics-pipeline629 = hidden constant [28 x i8] c"libs/external/gl/sky_f.glsl\00"
@gsxtmgraphics-pipeline630 = hidden constant [28 x i8] c"XTM RENDER SETUP on thread:\00"
@gsxtmgraphics-pipeline631 = hidden constant [5 x i8] c"init\00"
@gsxtmgraphics-pipeline632 = hidden constant [5 x i8] c"draw\00"
@gsxtmgraphics-pipeline633 = hidden constant [5 x i8] c"quad\00"
@gsxtmgraphics-pipeline634 = hidden constant [5 x i8] c"QUAD\00"
@gsxtmgraphics-pipeline635 = hidden constant [7 x i8] c"shader\00"
@gsxtmgraphics-pipeline636 = hidden constant [4 x i8] c"DOF\00"
@gsxtmgraphics-pipeline637 = hidden constant [7 x i8] c"SIMPLE\00"
@gsxtmgraphics-pipeline638 = hidden constant [6 x i8] c"LIGHT\00"
@gsxtmgraphics-pipeline639 = hidden constant [7 x i8] c"SKYBOX\00"
@gsxtmgraphics-pipeline640 = hidden constant [24 x i8] c"all-shaders-initialized\00"
@gsxtmgraphics-pipeline641 = hidden constant [32 x i8] c"error setting-up xtm_shadow_fbo\00"
@gsxtmgraphics-pipeline642 = hidden constant [32 x i8] c"error setting-up xtm_render_fbo\00"
@gsxtmgraphics-pipeline643 = hidden constant [27 x i8] c"XTM Render Setup Complete
\00"
@gsxtmgraphics-pipeline644 = hidden constant [42 x i8] c"xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0\00"
@gsxtmgraphics-pipeline645 = hidden constant [41 x i8] c"{i8*, i8*, void (i8*, i8*, i32, i32)*}**\00"
define dllexport fastcc void @xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0__14077(i8* %_impz,i8* %_impenv, i32 %w, i32 %h) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone14078 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i32, i32)*}***}*
%xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 0
%xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0Ptr = load {i8*, i8*, void (i8*, i8*, i32, i32)*}***, {i8*, i8*, void (i8*, i8*, i32, i32)*}**** %xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0Ptr_

; setup arguments
%wPtr = alloca i32
store i32 %w, i32* %wPtr
%hPtr = alloca i32
store i32 %h, i32* %hPtr


%tzone14081 = load i8*, i8** %_impzPtr
%zone14082 = bitcast i8* %tzone14081 to %mzone*

; let assign value to symbol quad-vert
%quad-vertPtr = alloca i8*
%tzone14085 = load i8*, i8** %_impzPtr
%zone14086 = bitcast i8* %tzone14085 to %mzone*

; let assign value to symbol quad-frag
%quad-fragPtr = alloca i8*
%tzone14089 = load i8*, i8** %_impzPtr
%zone14090 = bitcast i8* %tzone14089 to %mzone*

; let assign value to symbol dof-frag
%dof-fragPtr = alloca i8*
%tzone14093 = load i8*, i8** %_impzPtr
%zone14094 = bitcast i8* %tzone14093 to %mzone*

; let assign value to symbol simple-vert
%simple-vertPtr = alloca i8*
%tzone14097 = load i8*, i8** %_impzPtr
%zone14098 = bitcast i8* %tzone14097 to %mzone*

; let assign value to symbol simple-frag
%simple-fragPtr = alloca i8*
%tzone14101 = load i8*, i8** %_impzPtr
%zone14102 = bitcast i8* %tzone14101 to %mzone*

; let assign value to symbol lights-vert
%lights-vertPtr = alloca i8*
%tzone14105 = load i8*, i8** %_impzPtr
%zone14106 = bitcast i8* %tzone14105 to %mzone*

; let assign value to symbol lights-frag
%lights-fragPtr = alloca i8*
%tzone14109 = load i8*, i8** %_impzPtr
%zone14110 = bitcast i8* %tzone14109 to %mzone*

; let assign value to symbol skybox-vert
%skybox-vertPtr = alloca i8*
%tzone14113 = load i8*, i8** %_impzPtr
%zone14114 = bitcast i8* %tzone14113 to %mzone*

; let assign value to symbol skybox-frag
%skybox-fragPtr = alloca i8*
%var14079 = bitcast [29 x i8]* @gsxtmgraphics-pipeline621 to i8*
%res14080 = call ccc i8* @sys_slurp_file(i8* %var14079)

; let value assignment
%quad-vert = select i1 true, i8* %res14080, i8* %res14080
store i8* %quad-vert, i8** %quad-vertPtr

%var14083 = bitcast [29 x i8]* @gsxtmgraphics-pipeline622 to i8*
%res14084 = call ccc i8* @sys_slurp_file(i8* %var14083)

; let value assignment
%quad-frag = select i1 true, i8* %res14084, i8* %res14084
store i8* %quad-frag, i8** %quad-fragPtr

%var14087 = bitcast [28 x i8]* @gsxtmgraphics-pipeline623 to i8*
%res14088 = call ccc i8* @sys_slurp_file(i8* %var14087)

; let value assignment
%dof-frag = select i1 true, i8* %res14088, i8* %res14088
store i8* %dof-frag, i8** %dof-fragPtr

%var14091 = bitcast [31 x i8]* @gsxtmgraphics-pipeline624 to i8*
%res14092 = call ccc i8* @sys_slurp_file(i8* %var14091)

; let value assignment
%simple-vert = select i1 true, i8* %res14092, i8* %res14092
store i8* %simple-vert, i8** %simple-vertPtr

%var14095 = bitcast [31 x i8]* @gsxtmgraphics-pipeline625 to i8*
%res14096 = call ccc i8* @sys_slurp_file(i8* %var14095)

; let value assignment
%simple-frag = select i1 true, i8* %res14096, i8* %res14096
store i8* %simple-frag, i8** %simple-fragPtr

%var14099 = bitcast [31 x i8]* @gsxtmgraphics-pipeline626 to i8*
%res14100 = call ccc i8* @sys_slurp_file(i8* %var14099)

; let value assignment
%lights-vert = select i1 true, i8* %res14100, i8* %res14100
store i8* %lights-vert, i8** %lights-vertPtr

%var14103 = bitcast [31 x i8]* @gsxtmgraphics-pipeline627 to i8*
%res14104 = call ccc i8* @sys_slurp_file(i8* %var14103)

; let value assignment
%lights-frag = select i1 true, i8* %res14104, i8* %res14104
store i8* %lights-frag, i8** %lights-fragPtr

%var14107 = bitcast [28 x i8]* @gsxtmgraphics-pipeline628 to i8*
%res14108 = call ccc i8* @sys_slurp_file(i8* %var14107)

; let value assignment
%skybox-vert = select i1 true, i8* %res14108, i8* %res14108
store i8* %skybox-vert, i8** %skybox-vertPtr

%var14111 = bitcast [28 x i8]* @gsxtmgraphics-pipeline629 to i8*
%res14112 = call ccc i8* @sys_slurp_file(i8* %var14111)

; let value assignment
%skybox-frag = select i1 true, i8* %res14112, i8* %res14112
store i8* %skybox-frag, i8** %skybox-fragPtr

%var14115 = bitcast [3 x i8]* @gsxtmgraphics-pipeline52 to i8*
%var14116 = bitcast [28 x i8]* @gsxtmgraphics-pipeline630 to i8*

%val14117 = call i32 (i8*, ...) @printf(i8* %var14115, i8* %var14116)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%res14119 = call ccc i8* @thread_self()
call fastcc void @print_adhoc_W3ZvaWQsaTgqXQ(i8* %res14119)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%var14122 = bitcast [5 x i8]* @gsxtmgraphics-pipeline631 to i8*
%res14123 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var14122)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res14123)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%var14126 = bitcast [5 x i8]* @gsxtmgraphics-pipeline632 to i8*
%res14127 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var14126)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res14127)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%var14130 = bitcast [5 x i8]* @gsxtmgraphics-pipeline633 to i8*
%res14131 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var14130)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res14131)
call fastcc void @print_return_adhoc_W3ZvaWRd()
call fastcc void @init_draw_quad_adhoc_W3ZvaWRd()
%var14135 = bitcast [5 x i8]* @gsxtmgraphics-pipeline631 to i8*
%res14136 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var14135)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res14136)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%var14139 = bitcast [5 x i8]* @gsxtmgraphics-pipeline634 to i8*
%res14140 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var14139)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res14140)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%var14143 = bitcast [7 x i8]* @gsxtmgraphics-pipeline635 to i8*
%res14144 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var14143)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res14144)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val14147 = load i8*, i8** %quad-vertPtr
%val14148 = load i8*, i8** %quad-fragPtr
call fastcc void @xtm_render_init_quad_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0(i8* %val14147, i8* %val14148)
%var14150 = bitcast [5 x i8]* @gsxtmgraphics-pipeline631 to i8*
%res14151 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var14150)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res14151)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%var14154 = bitcast [4 x i8]* @gsxtmgraphics-pipeline636 to i8*
%res14155 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var14154)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res14155)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%var14158 = bitcast [7 x i8]* @gsxtmgraphics-pipeline635 to i8*
%res14159 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var14158)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res14159)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val14162 = load i8*, i8** %quad-vertPtr
%val14163 = load i8*, i8** %dof-fragPtr
call fastcc void @xtm_render_init_dof_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0(i8* %val14162, i8* %val14163)
%var14165 = bitcast [5 x i8]* @gsxtmgraphics-pipeline631 to i8*
%res14166 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var14165)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res14166)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%var14169 = bitcast [7 x i8]* @gsxtmgraphics-pipeline637 to i8*
%res14170 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var14169)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res14170)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%var14173 = bitcast [7 x i8]* @gsxtmgraphics-pipeline635 to i8*
%res14174 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var14173)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res14174)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val14177 = load i8*, i8** %simple-vertPtr
%val14178 = load i8*, i8** %simple-fragPtr
call fastcc void @xtm_render_init_simple_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0(i8* %val14177, i8* %val14178)
%var14180 = bitcast [5 x i8]* @gsxtmgraphics-pipeline631 to i8*
%res14181 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var14180)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res14181)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%var14184 = bitcast [6 x i8]* @gsxtmgraphics-pipeline638 to i8*
%res14185 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var14184)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res14185)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%var14188 = bitcast [7 x i8]* @gsxtmgraphics-pipeline635 to i8*
%res14189 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var14188)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res14189)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val14192 = load i8*, i8** %lights-vertPtr
%val14193 = load i8*, i8** %lights-fragPtr
call fastcc void @xtm_render_init_light_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0(i8* %val14192, i8* %val14193)
%var14195 = bitcast [5 x i8]* @gsxtmgraphics-pipeline631 to i8*
%res14196 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var14195)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res14196)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%var14199 = bitcast [7 x i8]* @gsxtmgraphics-pipeline639 to i8*
%res14200 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var14199)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res14200)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%var14203 = bitcast [7 x i8]* @gsxtmgraphics-pipeline635 to i8*
%res14204 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var14203)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res14204)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val14207 = load i8*, i8** %skybox-vertPtr
%val14208 = load i8*, i8** %skybox-fragPtr
call fastcc void @xtm_render_init_skybox_shader_adhoc_W3ZvaWQsaTgqLGk4Kl0(i8* %val14207, i8* %val14208)
%var14210 = bitcast [24 x i8]* @gsxtmgraphics-pipeline640 to i8*
%res14211 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var14210)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res14211)
call fastcc void @print_return_adhoc_W3ZvaWRd()
; do set!
%val14214 = load i32, i32* %wPtr
store i32 %val14214, i32* @xtm_render_w
; do set!
%val14215 = load i32, i32* %hPtr
store i32 %val14215, i32* @xtm_render_h
; do set!
%val14216 = fptrunc double 0.69999999999999995559 to float
%vecl14217 = insertelement <4 x float> undef, float %val14216, i32 0
%vecl14218 = insertelement <4 x float> %vecl14217, float 0x3fe6666660000000, i32 1
%vecl14219 = insertelement <4 x float> %vecl14218, float 0x3fe6666660000000, i32 2
%vecl14220 = insertelement <4 x float> %vecl14219, float 0x3ff0000000000000, i32 3
store <4 x float> %vecl14220, <4 x float>* @XTM_BACKGROUND_COLOUR
%res14221 = call fastcc %FBO* @xtm_shadow_fbo_adhoc_W0ZCTypd()
%var14222 = bitcast [32 x i8]* @gsxtmgraphics-pipeline641 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var14222)
%res14224 = call fastcc %FBO* @xtm_render_fbo_adhoc_W0ZCTypd()
%var14225 = bitcast [32 x i8]* @gsxtmgraphics-pipeline642 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var14225)
%var14227 = bitcast [27 x i8]* @gsxtmgraphics-pipeline643 to i8*

%val14228 = call i32 (i8*, ...) @printf(i8* %var14227)
ret void
}
@gsxtmgraphics-pipeline646 = hidden constant [95 x i8] c"xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i32, i32)*}** @xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone14249 = load i8*, i8** %_impzPtr
%zone14250 = bitcast i8* %tzone14249 to %mzone*

; let assign value to symbol xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0
%dat_xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone14250, i64 8)
%xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0Ptr = bitcast i8* %dat_xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0 to { i8*, i8*, void (i8*, i8*, i32, i32)*}***
%tzone14230 = load i8*, i8** %_impzPtr
%zone14231 = bitcast i8* %tzone14230 to %mzone*
call void @llvm_zone_mark(%mzone* %zone14231)
; malloc closure structure
%clsptr14232 = call i8* @llvm_zone_malloc(%mzone* %zone14231, i64 24)
%closure14233 = bitcast i8* %clsptr14232 to { i8*, i8*, void (i8*, i8*, i32, i32)*}*

; malloc environment structure
%envptr14234 = call i8* @llvm_zone_malloc(%mzone* %zone14231, i64 8)
%environment14235 = bitcast i8* %envptr14234 to {{i8*, i8*, void (i8*, i8*, i32, i32)*}***}*

; malloc closure address table
%addytable14236 = call %clsvar* @new_address_table()
%var14237 = bitcast [42 x i8]* @gsxtmgraphics-pipeline644 to i8*
%var14238 = bitcast [41 x i8]* @gsxtmgraphics-pipeline645 to i8*
%addytable14239 = call %clsvar* @add_address_table(%mzone* %zone14231, i8* %var14237, i32 0, i8* %var14238, i32 3, %clsvar* %addytable14236)
%address-table14240 = bitcast %clsvar* %addytable14239 to i8*

; insert table, function and environment into closure struct
%closure.table14243 = getelementptr { i8*, i8*, void (i8*, i8*, i32, i32)*}, { i8*, i8*, void (i8*, i8*, i32, i32)*}* %closure14233, i32 0, i32 0
store i8* %address-table14240, i8** %closure.table14243
%closure.env14244 = getelementptr { i8*, i8*, void (i8*, i8*, i32, i32)*}, { i8*, i8*, void (i8*, i8*, i32, i32)*}* %closure14233, i32 0, i32 1
store i8* %envptr14234, i8** %closure.env14244
%closure.func14245 = getelementptr { i8*, i8*, void (i8*, i8*, i32, i32)*}, { i8*, i8*, void (i8*, i8*, i32, i32)*}* %closure14233, i32 0, i32 2
store void (i8*, i8*, i32, i32)* @xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0__14077, void (i8*, i8*, i32, i32)** %closure.func14245
%closure_size14246 = call i64 @llvm_zone_mark_size(%mzone* %zone14231)
call void @llvm_zone_ptr_set_size(i8* %clsptr14232, i64 %closure_size14246)
%wrapper_ptr14247 = call i8* @llvm_zone_malloc(%mzone* %zone14231, i64 8)
%closure_wrapper14248 = bitcast i8* %wrapper_ptr14247 to { i8*, i8*, void (i8*, i8*, i32, i32)*}**
store { i8*, i8*, void (i8*, i8*, i32, i32)*}* %closure14233, { i8*, i8*, void (i8*, i8*, i32, i32)*}** %closure_wrapper14248

; let value assignment
%xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0 = select i1 true, { i8*, i8*, void (i8*, i8*, i32, i32)*}** %closure_wrapper14248, { i8*, i8*, void (i8*, i8*, i32, i32)*}** %closure_wrapper14248
store { i8*, i8*, void (i8*, i8*, i32, i32)*}** %xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0, { i8*, i8*, void (i8*, i8*, i32, i32)*}*** %xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0
%tmp_envptr14242 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, i32, i32)*}***}* %environment14235, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i32, i32)*}*** %xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0Ptr, {i8*, i8*, void (i8*, i8*, i32, i32)*}**** %tmp_envptr14242


%val14251 = load {i8*, i8*, void (i8*, i8*, i32, i32)*}**, {i8*, i8*, void (i8*, i8*, i32, i32)*}*** %xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0Ptr
ret {i8*, i8*, void (i8*, i8*, i32, i32)*}** %val14251
}


@xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i32, i32)*}** @xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, i32)*,  void (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret void
}


define dllexport ccc void @xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0_native(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, i32)*,  void (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret void
}


define dllexport ccc i8*  @xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var14252 = bitcast [95 x i8]* @gsxtmgraphics-pipeline646 to i8*
call i32 (i8*, ...) @printf(i8* %var14252)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var14253 = bitcast [95 x i8]* @gsxtmgraphics-pipeline646 to i8*
call i32 (i8*, ...) @printf(i8* %var14253)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, i32)*,  void (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32}*
%arg_p_0 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_init_adhoc_W3ZvaWQsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, i32)*,  void (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline647 = hidden constant [69 x i8] c"xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd\00"
define dllexport fastcc void @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd__14254(i8* %_impz,i8* %_impenv, float %r, float %g, float %b, float %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone14255 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float, float, float, float)*}***}*
%xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float, float, float, float)*}***}* %impenv, i32 0, i32 0
%xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = load {i8*, i8*, void (i8*, i8*, float, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}**** %xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_

; setup arguments
%rPtr = alloca float
store float %r, float* %rPtr
%gPtr = alloca float
store float %g, float* %gPtr
%bPtr = alloca float
store float %b, float* %bPtr
%aPtr = alloca float
store float %a, float* %aPtr


; do set!
%val14256 = load float, float* %rPtr
%vecl14260 = insertelement <4 x float> undef, float %val14256, i32 0
%val14257 = load float, float* %gPtr
%vecl14261 = insertelement <4 x float> %vecl14260, float %val14257, i32 1
%val14258 = load float, float* %bPtr
%vecl14262 = insertelement <4 x float> %vecl14261, float %val14258, i32 2
%val14259 = load float, float* %aPtr
%vecl14263 = insertelement <4 x float> %vecl14262, float %val14259, i32 3
store <4 x float> %vecl14263, <4 x float>* @XTM_BACKGROUND_COLOUR
ret void
}
@gsxtmgraphics-pipeline648 = hidden constant [122 x i8] c"xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float, float, float, float)*}** @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone14284 = load i8*, i8** %_impzPtr
%zone14285 = bitcast i8* %tzone14284 to %mzone*

; let assign value to symbol xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd
%dat_xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone14285, i64 8)
%xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = bitcast i8* %dat_xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd to { i8*, i8*, void (i8*, i8*, float, float, float, float)*}***
%tzone14265 = load i8*, i8** %_impzPtr
%zone14266 = bitcast i8* %tzone14265 to %mzone*
call void @llvm_zone_mark(%mzone* %zone14266)
; malloc closure structure
%clsptr14267 = call i8* @llvm_zone_malloc(%mzone* %zone14266, i64 24)
%closure14268 = bitcast i8* %clsptr14267 to { i8*, i8*, void (i8*, i8*, float, float, float, float)*}*

; malloc environment structure
%envptr14269 = call i8* @llvm_zone_malloc(%mzone* %zone14266, i64 8)
%environment14270 = bitcast i8* %envptr14269 to {{i8*, i8*, void (i8*, i8*, float, float, float, float)*}***}*

; malloc closure address table
%addytable14271 = call %clsvar* @new_address_table()
%var14272 = bitcast [69 x i8]* @gsxtmgraphics-pipeline647 to i8*
%var14273 = bitcast [59 x i8]* @gsxtmgraphics-pipeline579 to i8*
%addytable14274 = call %clsvar* @add_address_table(%mzone* %zone14266, i8* %var14272, i32 0, i8* %var14273, i32 3, %clsvar* %addytable14271)
%address-table14275 = bitcast %clsvar* %addytable14274 to i8*

; insert table, function and environment into closure struct
%closure.table14278 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure14268, i32 0, i32 0
store i8* %address-table14275, i8** %closure.table14278
%closure.env14279 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure14268, i32 0, i32 1
store i8* %envptr14269, i8** %closure.env14279
%closure.func14280 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure14268, i32 0, i32 2
store void (i8*, i8*, float, float, float, float)* @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd__14254, void (i8*, i8*, float, float, float, float)** %closure.func14280
%closure_size14281 = call i64 @llvm_zone_mark_size(%mzone* %zone14266)
call void @llvm_zone_ptr_set_size(i8* %clsptr14267, i64 %closure_size14281)
%wrapper_ptr14282 = call i8* @llvm_zone_malloc(%mzone* %zone14266, i64 8)
%closure_wrapper14283 = bitcast i8* %wrapper_ptr14282 to { i8*, i8*, void (i8*, i8*, float, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure14268, { i8*, i8*, void (i8*, i8*, float, float, float, float)*}** %closure_wrapper14283

; let value assignment
%xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd = select i1 true, { i8*, i8*, void (i8*, i8*, float, float, float, float)*}** %closure_wrapper14283, { i8*, i8*, void (i8*, i8*, float, float, float, float)*}** %closure_wrapper14283
store { i8*, i8*, void (i8*, i8*, float, float, float, float)*}** %xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd, { i8*, i8*, void (i8*, i8*, float, float, float, float)*}*** %xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd
%tmp_envptr14277 = getelementptr {{i8*, i8*, void (i8*, i8*, float, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float, float, float, float)*}***}* %environment14270, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float, float, float, float)*}*** %xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}**** %tmp_envptr14277


%val14286 = load {i8*, i8*, void (i8*, i8*, float, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}*** %xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRdPtr
ret {i8*, i8*, void (i8*, i8*, float, float, float, float)*}** %val14286
}


@xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float, float, float, float)*}** @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float, float)*,  void (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret void
}


define dllexport ccc void @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_native(float %arg_0,float %arg_1,float %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float, float)*,  void (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
ret void
}


define dllexport ccc i8*  @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var14287 = bitcast [122 x i8]* @gsxtmgraphics-pipeline648 to i8*
call i32 (i8*, ...) @printf(i8* %var14287)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var14288 = bitcast [122 x i8]* @gsxtmgraphics-pipeline648 to i8*
call i32 (i8*, ...) @printf(i8* %var14288)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var14289 = bitcast [122 x i8]* @gsxtmgraphics-pipeline648 to i8*
call i32 (i8*, ...) @printf(i8* %var14289)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var14290 = bitcast [122 x i8]* @gsxtmgraphics-pipeline648 to i8*
call i32 (i8*, ...) @printf(i8* %var14290)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float, float)*,  void (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float, float, float}*
%arg_p_0 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {float, float, float, float}, {float, float, float, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float, float)*,  void (i8*, i8*, float, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline649 = hidden constant [61 x i8] c"xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd\00"
define dllexport fastcc void @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd__14291(i8* %_impz,i8* %_impenv, float %r, float %g, float %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone14292 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}*
%xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}* %impenv, i32 0, i32 0
%xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = load {i8*, i8*, void (i8*, i8*, float, float, float)*}***, {i8*, i8*, void (i8*, i8*, float, float, float)*}**** %xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr_

; setup arguments
%rPtr = alloca float
store float %r, float* %rPtr
%gPtr = alloca float
store float %g, float* %gPtr
%bPtr = alloca float
store float %b, float* %bPtr


; do set!
%val14293 = load float, float* %rPtr
%vecl14296 = insertelement <4 x float> undef, float %val14293, i32 0
%val14294 = load float, float* %gPtr
%vecl14297 = insertelement <4 x float> %vecl14296, float %val14294, i32 1
%val14295 = load float, float* %bPtr
%vecl14298 = insertelement <4 x float> %vecl14297, float %val14295, i32 2
%vecl14299 = insertelement <4 x float> %vecl14298, float 0x3ff0000000000000, i32 3
store <4 x float> %vecl14299, <4 x float>* @XTM_BACKGROUND_COLOUR
ret void
}
@gsxtmgraphics-pipeline650 = hidden constant [114 x i8] c"xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float, float, float)*}** @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone14320 = load i8*, i8** %_impzPtr
%zone14321 = bitcast i8* %tzone14320 to %mzone*

; let assign value to symbol xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd
%dat_xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone14321, i64 8)
%xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr = bitcast i8* %dat_xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd to { i8*, i8*, void (i8*, i8*, float, float, float)*}***
%tzone14301 = load i8*, i8** %_impzPtr
%zone14302 = bitcast i8* %tzone14301 to %mzone*
call void @llvm_zone_mark(%mzone* %zone14302)
; malloc closure structure
%clsptr14303 = call i8* @llvm_zone_malloc(%mzone* %zone14302, i64 24)
%closure14304 = bitcast i8* %clsptr14303 to { i8*, i8*, void (i8*, i8*, float, float, float)*}*

; malloc environment structure
%envptr14305 = call i8* @llvm_zone_malloc(%mzone* %zone14302, i64 8)
%environment14306 = bitcast i8* %envptr14305 to {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}*

; malloc closure address table
%addytable14307 = call %clsvar* @new_address_table()
%var14308 = bitcast [61 x i8]* @gsxtmgraphics-pipeline649 to i8*
%var14309 = bitcast [52 x i8]* @gsxtmgraphics-pipeline370 to i8*
%addytable14310 = call %clsvar* @add_address_table(%mzone* %zone14302, i8* %var14308, i32 0, i8* %var14309, i32 3, %clsvar* %addytable14307)
%address-table14311 = bitcast %clsvar* %addytable14310 to i8*

; insert table, function and environment into closure struct
%closure.table14314 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure14304, i32 0, i32 0
store i8* %address-table14311, i8** %closure.table14314
%closure.env14315 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure14304, i32 0, i32 1
store i8* %envptr14305, i8** %closure.env14315
%closure.func14316 = getelementptr { i8*, i8*, void (i8*, i8*, float, float, float)*}, { i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure14304, i32 0, i32 2
store void (i8*, i8*, float, float, float)* @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd__14291, void (i8*, i8*, float, float, float)** %closure.func14316
%closure_size14317 = call i64 @llvm_zone_mark_size(%mzone* %zone14302)
call void @llvm_zone_ptr_set_size(i8* %clsptr14303, i64 %closure_size14317)
%wrapper_ptr14318 = call i8* @llvm_zone_malloc(%mzone* %zone14302, i64 8)
%closure_wrapper14319 = bitcast i8* %wrapper_ptr14318 to { i8*, i8*, void (i8*, i8*, float, float, float)*}**
store { i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure14304, { i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_wrapper14319

; let value assignment
%xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd = select i1 true, { i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_wrapper14319, { i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_wrapper14319
store { i8*, i8*, void (i8*, i8*, float, float, float)*}** %xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd, { i8*, i8*, void (i8*, i8*, float, float, float)*}*** %xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd
%tmp_envptr14313 = getelementptr {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}, {{i8*, i8*, void (i8*, i8*, float, float, float)*}***}* %environment14306, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float, float, float)*}*** %xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr, {i8*, i8*, void (i8*, i8*, float, float, float)*}**** %tmp_envptr14313


%val14322 = load {i8*, i8*, void (i8*, i8*, float, float, float)*}**, {i8*, i8*, void (i8*, i8*, float, float, float)*}*** %xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRdPtr
ret {i8*, i8*, void (i8*, i8*, float, float, float)*}** %val14322
}


@xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float, float, float)*}** @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd(float %arg_0,float %arg_1,float %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float)*,  void (i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2)
ret void
}


define dllexport ccc void @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_native(float %arg_0,float %arg_1,float %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float)*,  void (i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2)
ret void
}


define dllexport ccc i8*  @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var14323 = bitcast [114 x i8]* @gsxtmgraphics-pipeline650 to i8*
call i32 (i8*, ...) @printf(i8* %var14323)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var14324 = bitcast [114 x i8]* @gsxtmgraphics-pipeline650 to i8*
call i32 (i8*, ...) @printf(i8* %var14324)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var14325 = bitcast [114 x i8]* @gsxtmgraphics-pipeline650 to i8*
call i32 (i8*, ...) @printf(i8* %var14325)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float)*,  void (i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, float, float}*
%arg_p_0 = getelementptr {float, float, float}, {float, float, float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, float, float}, {float, float, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {float, float, float}, {float, float, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_background_colour_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float, float, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float, float, float)*}*, {i8*, i8*, void (i8*, i8*, float, float, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float, float, float)*}, {i8*, i8*, void (i8*, i8*, float, float, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float, float, float)*,  void (i8*, i8*, float, float, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0, float %arg_1, float %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgraphics-pipeline651 = hidden constant [19 x i8] c"prerender gl error\00"
@gsxtmgraphics-pipeline652 = hidden constant [10 x i8] c"shadowMap\00"
@gsxtmgraphics-pipeline653 = hidden constant [40 x i8] c"Error in XTM pipeline rendering Opaque!\00"
@gsxtmgraphics-pipeline654 = hidden constant [45 x i8] c"Error in XTM pipeline rendering Transparent!\00"
@gsxtmgraphics-pipeline655 = hidden constant [20 x i8] c"Error in xtm_render\00"
@gsxtmgraphics-pipeline656 = hidden constant [308 x i8] c"xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ\00"
@gsxtmgraphics-pipeline657 = hidden constant [367 x i8] c"{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}**\00"
@gsxtmgraphics-pipeline658 = hidden constant [11 x i8] c"render_fbo\00"
@gsxtmgraphics-pipeline659 = hidden constant [11 x i8] c"shadow_fbo\00"
@gsxtmgraphics-pipeline660 = hidden constant [11 x i8] c"projection\00"
@gsxtmgraphics-pipeline661 = hidden constant [5 x i8] c"view\00"
@gsxtmgraphics-pipeline662 = hidden constant [6 x i8] c"model\00"
@gsxtmgraphics-pipeline663 = hidden constant [4 x i8] c"sh2\00"
@gsxtmgraphics-pipeline664 = hidden constant [16 x i8] c"%ShaderProgram*\00"
@gsxtmgraphics-pipeline665 = hidden constant [4 x i8] c"sh1\00"
@gsxtmgraphics-pipeline666 = hidden constant [13 x i8] c"framebufsize\00"
@gsxtmgraphics-pipeline667 = hidden constant [13 x i8] c"activelights\00"
@gsxtmgraphics-pipeline668 = hidden constant [6 x i8] c"frame\00"
@gsxtmgraphics-pipeline669 = hidden constant [16 x i8] c"_anon_lambda_26\00"
define dllexport fastcc i64 @xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ__14326(i8* %_impz,i8* %_impenv, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %pre, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %opaque, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %transparent, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %post, i8* %data_s_62) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone14383 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}*
%xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %impenv, i32 0, i32 0
%xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQPtr = load {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}**** %xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQPtr_
%render_fboPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %impenv, i32 0, i32 1
%render_fboPtr = load %FBO**, %FBO*** %render_fboPtr_
%shadow_fboPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %impenv, i32 0, i32 2
%shadow_fboPtr = load %FBO**, %FBO*** %shadow_fboPtr_
%projectionPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %impenv, i32 0, i32 3
%projectionPtr = load float**, float*** %projectionPtr_
%viewPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %impenv, i32 0, i32 4
%viewPtr = load float**, float*** %viewPtr_
%modelPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %impenv, i32 0, i32 5
%modelPtr = load float**, float*** %modelPtr_
%sh2Ptr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %impenv, i32 0, i32 6
%sh2Ptr = load %ShaderProgram**, %ShaderProgram*** %sh2Ptr_
%sh1Ptr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %impenv, i32 0, i32 7
%sh1Ptr = load %ShaderProgram**, %ShaderProgram*** %sh1Ptr_
%framebufsizePtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %impenv, i32 0, i32 8
%framebufsizePtr = load float**, float*** %framebufsizePtr_
%activelightsPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %impenv, i32 0, i32 9
%activelightsPtr = load i32*, i32** %activelightsPtr_
%cameraPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %impenv, i32 0, i32 10
%cameraPtr = load %xtm_camera**, %xtm_camera*** %cameraPtr_
%lightsPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %impenv, i32 0, i32 11
%lightsPtr = load %xtm_lights**, %xtm_lights*** %lightsPtr_
%framePtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %impenv, i32 0, i32 12
%framePtr = load i64*, i64** %framePtr_
%iPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %impenv, i32 0, i32 13
%iPtr = load i32*, i32** %iPtr_
%_anon_lambda_26Ptr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %impenv, i32 0, i32 14
%_anon_lambda_26Ptr = load {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}**** %_anon_lambda_26Ptr_

; setup arguments
%prePtr = alloca {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**
store {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %pre, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*** %prePtr
%opaquePtr = alloca {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**
store {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %opaque, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*** %opaquePtr
%transparentPtr = alloca {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**
store {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %transparent, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*** %transparentPtr
%postPtr = alloca {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**
store {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %post, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*** %postPtr
%data_s_62Ptr = alloca i8*
store i8* %data_s_62, i8** %data_s_62Ptr

; promote local stack var allocations
%tzone14759 = load i8*, i8** %_impzPtr
%zone14760 = bitcast i8* %tzone14759 to %mzone*
%ifptr14634 = alloca i1
%ifptr14585 = alloca i1
%ifptr14543 = alloca i32
%ifptr14440 = alloca i1
%ifptr14399 = alloca i1

; do set!
%res14384 = call fastcc %FBO* @xtm_shadow_fbo_adhoc_W0ZCTypd()
store %FBO* %res14384, %FBO** %shadow_fboPtr
; do set!
%res14385 = call fastcc %FBO* @xtm_render_fbo_adhoc_W0ZCTypd()
store %FBO* %res14385, %FBO** %render_fboPtr
%val14386 = load i32, i32* @GL_DEPTH_TEST
call fastcc void @glEnable_adhoc_W3ZvaWQsaTMyXQ(i32 %val14386)
%val14388 = load float*, float** %projectionPtr
%val14389 = load float, float* @xtm_render_angle
%val14390 = load i32, i32* @xtm_render_w
%res14391 = call ccc float @i32tof(i32 %val14390)
%val14392 = load i32, i32* @xtm_render_h
%res14393 = call ccc float @i32tof(i32 %val14392)
%val14394 = fdiv float %res14391, %res14393
%val14395 = load float, float* @xtm_render_near
%val14396 = load float, float* @xtm_render_far
call fastcc void @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ(float* %val14388, float %val14389, float %val14394, float %val14395, float %val14396)
%val14400 = load {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*** %prePtr
%val14401 = icmp eq {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %val14400, null
br i1 %val14401, label %then14399, label %else14399

then14399:
%res14402 = call ccc i1 @impc_false()
store i1 %res14402, i1* %ifptr14399
br label %ifcont14399

else14399:
%res14403 = call ccc i1 @impc_true()
store i1 %res14403, i1* %ifptr14399
br label %ifcont14399

ifcont14399:
%ifres14404 = load i1, i1* %ifptr14399

br i1 %ifres14404, label %then14398, label %else14398

then14398:
%res14405 = call fastcc %xtm_lights* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ()
; set tuple
%val14406 = getelementptr %xtm_lights, %xtm_lights* %res14405, i64 0, i32 9
store i32 0, i32* %val14406
%val14407 = load float*, float** %viewPtr
call fastcc void @xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %val14407)
%val14409 = load float*, float** %modelPtr
call fastcc void @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %val14409)
%val14411 = load i64, i64* %framePtr
%null14412 = bitcast i8* null to %ShaderProgram*
%val14413 = load float*, float** %modelPtr
%val14414 = load float*, float** %viewPtr
%val14415 = load float*, float** %projectionPtr
%val14416 = load i8*, i8** %data_s_62Ptr

; apply closure 
%vval14417 = load {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*** %prePtr
%val14418 = load {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*,{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %vval14417
%fPtr14419 = getelementptr {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}* %val14418, i32 0, i32 2
%ePtr14420 = getelementptr {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}* %val14418, i32 0, i32 1
%f14421 = load void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)** %fPtr14419
%e14422 = load i8*, i8** %ePtr14420
%tzone14423 = load i8*, i8** %_impzPtr
%zone14424 = bitcast i8* %tzone14423 to %mzone*
%z14425 = bitcast %mzone* %zone14424 to i8*
tail call fastcc void %f14421(i8* %z14425, i8* %e14422, i64 %val14411, %ShaderProgram* %null14412, float* %val14413, float* %val14414, float* %val14415, i8* %val14416)
br label %ifcont14398

else14398:
br label %ifcont14398

ifcont14398:
%var14427 = bitcast [19 x i8]* @gsxtmgraphics-pipeline651 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var14427)
; do set!
%val14429 = load %ShaderProgram*, %ShaderProgram** @xtm_render_simple_shader
store %ShaderProgram* %val14429, %ShaderProgram** %sh1Ptr
%val14430 = load %ShaderProgram*, %ShaderProgram** %sh1Ptr
call fastcc void @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %val14430)
%val14432 = load %FBO*, %FBO** %shadow_fboPtr
%res14433 = call fastcc i32 @bind_adhoc_W2kzMixGQk8qXQ(%FBO* %val14432)
call fastcc void @glClearColor_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd(float 0x0, float 0x3fd0000000000000, float 0x3fd0000000000000, float 0x3ff0000000000000)
%val14435 = load i32, i32* @GL_COLOR_BUFFER_BIT
%val14436 = load i32, i32* @GL_DEPTH_BUFFER_BIT
%val14437 = add i32 %val14435, %val14436
call fastcc void @glClear_adhoc_W3ZvaWQsaTMyXQ(i32 %val14437)
%val14441 = load {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*** %opaquePtr
%val14442 = icmp eq {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %val14441, null
br i1 %val14442, label %then14440, label %else14440

then14440:
%res14443 = call ccc i1 @impc_false()
store i1 %res14443, i1* %ifptr14440
br label %ifcont14440

else14440:
%res14444 = call ccc i1 @impc_true()
store i1 %res14444, i1* %ifptr14440
br label %ifcont14440

ifcont14440:
%ifres14445 = load i1, i1* %ifptr14440

br i1 %ifres14445, label %then14439, label %else14439

then14439:
; setup loop
%val14450 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val14451 = getelementptr %xtm_lights, %xtm_lights* %val14450, i64 0, i32 9
%val14452 = load i32, i32* %val14451
store i32 0, i32* %iPtr
%val14495 = load i32, i32* %iPtr
%num14496 = add i32 %val14452, %val14495
%comp14497 = icmp ult i32 %val14452, 1
br i1 %comp14497, label %after14446, label %loop14446

loop14446:
%val14453 = load i32, i32* %iPtr
%val14454 = srem i32 %val14453, 4
%val14455 = mul i32 %val14454, 1024
%val14456 = load i32, i32* %iPtr
%res14457 = call ccc float @i32tof(i32 %val14456)
%val14458 = fdiv float %res14457, 0x4010000000000000
%res14459 = call ccc i32 @ftoi32(float %val14458)
%val14460 = mul i32 %res14459, 1024
call fastcc void @glViewport_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyXQ(i32 %val14455, i32 %val14460, i32 1024, i32 1024)
%val14462 = load i32, i32* @GL_CULL_FACE
call fastcc void @glEnable_adhoc_W3ZvaWQsaTMyXQ(i32 %val14462)
%val14464 = load i32, i32* @GL_FRONT
call fastcc void @glCullFace_adhoc_W3ZvaWQsaTMyXQ(i32 %val14464)
%val14466 = load float*, float** %modelPtr
call fastcc void @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %val14466)
%val14468 = load i32, i32* %iPtr
%val14469 = add i32 %val14468, 1
%val14470 = load float*, float** %viewPtr
call fastcc void @xtm_light_view_adhoc_W3ZvaWQsaTMyLGZsb2F0Kl0(i32 %val14469, float* %val14470)
%val14472 = load %ShaderProgram*, %ShaderProgram** %sh1Ptr
%val14473 = load float*, float** %modelPtr
%val14474 = load float*, float** %viewPtr
%val14475 = load float*, float** %projectionPtr
call fastcc void @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd(%ShaderProgram* %val14472, float* %val14473, float* %val14474, float* %val14475)
%val14477 = load i64, i64* %framePtr
%val14478 = load %ShaderProgram*, %ShaderProgram** %sh1Ptr
%val14479 = load float*, float** %modelPtr
%val14480 = load float*, float** %viewPtr
%val14481 = load float*, float** %projectionPtr
%val14482 = load i8*, i8** %data_s_62Ptr

; apply closure 
%vval14483 = load {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*** %opaquePtr
%val14484 = load {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*,{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %vval14483
%fPtr14485 = getelementptr {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}* %val14484, i32 0, i32 2
%ePtr14486 = getelementptr {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}* %val14484, i32 0, i32 1
%f14487 = load void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)** %fPtr14485
%e14488 = load i8*, i8** %ePtr14486
%tzone14489 = load i8*, i8** %_impzPtr
%zone14490 = bitcast i8* %tzone14489 to %mzone*
%z14491 = bitcast %mzone* %zone14490 to i8*
tail call fastcc void %f14487(i8* %z14491, i8* %e14488, i64 %val14477, %ShaderProgram* %val14478, float* %val14479, float* %val14480, float* %val14481, i8* %val14482)
call fastcc void @gl_print_error_adhoc_W3ZvaWRd()
%loop_cnt14446 = load i32, i32* %iPtr
%next14446 = add i32 %loop_cnt14446, 1
store i32 %next14446, i32* %iPtr
%cmp14446 = icmp ult i32 %next14446, %num14496
br i1 %cmp14446, label %loop14446, label %after14446

after14446:
br label %ifcont14439

else14439:
br label %ifcont14439

ifcont14439:
%val14499 = load %FBO*, %FBO** %shadow_fboPtr
%res14500 = call fastcc i32 @unbind_adhoc_W2kzMixGQk8qXQ(%FBO* %val14499)
%val14501 = load %ShaderProgram*, %ShaderProgram** %sh1Ptr
call fastcc void @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %val14501)
%val14503 = load %FBO*, %FBO** %render_fboPtr
%res14504 = call fastcc i32 @bind_adhoc_W2kzMixGQk8qXQ(%FBO* %val14503)
%val14505 = select i1 true, <4 x float>* @XTM_BACKGROUND_COLOUR, <4 x float>* @XTM_BACKGROUND_COLOUR
; vector ref
%vect14506 = load <4 x float>, <4 x float>* %val14505
%val14507 = extractelement <4 x float> %vect14506, i32 0
%val14508 = select i1 true, <4 x float>* @XTM_BACKGROUND_COLOUR, <4 x float>* @XTM_BACKGROUND_COLOUR
; vector ref
%vect14509 = load <4 x float>, <4 x float>* %val14508
%val14510 = extractelement <4 x float> %vect14509, i32 1
%val14511 = select i1 true, <4 x float>* @XTM_BACKGROUND_COLOUR, <4 x float>* @XTM_BACKGROUND_COLOUR
; vector ref
%vect14512 = load <4 x float>, <4 x float>* %val14511
%val14513 = extractelement <4 x float> %vect14512, i32 2
%val14514 = select i1 true, <4 x float>* @XTM_BACKGROUND_COLOUR, <4 x float>* @XTM_BACKGROUND_COLOUR
; vector ref
%vect14515 = load <4 x float>, <4 x float>* %val14514
%val14516 = extractelement <4 x float> %vect14515, i32 3
call fastcc void @glClearColor_adhoc_W3ZvaWQsZmxvYXQsZmxvYXQsZmxvYXQsZmxvYXRd(float %val14507, float %val14510, float %val14513, float %val14516)
%val14518 = load i32, i32* @GL_COLOR_BUFFER_BIT
%val14519 = load i32, i32* @GL_DEPTH_BUFFER_BIT
%val14520 = add i32 %val14518, %val14519
call fastcc void @glClear_adhoc_W3ZvaWQsaTMyXQ(i32 %val14520)
%val14522 = load %FBO*, %FBO** %render_fboPtr
%res14523 = call fastcc i32 @unbind_adhoc_W2kzMixGQk8qXQ(%FBO* %val14522)
%val14524 = load i32, i32* @xtm_render_x
%val14525 = load i32, i32* @xtm_render_y
%val14526 = load i32, i32* @xtm_render_w
%val14527 = load i32, i32* @xtm_render_h
call fastcc void @glViewport_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyXQ(i32 %val14524, i32 %val14525, i32 %val14526, i32 %val14527)
%val14530 = load i1, i1* @SKY_BOX
br i1 %val14530, label %then14529, label %else14529

then14529:
%val14531 = load float*, float** %viewPtr
call fastcc void @xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %val14531)
%val14533 = load float*, float** %modelPtr
call fastcc void @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %val14533)
%val14535 = load %FBO*, %FBO** %render_fboPtr
%val14536 = load float*, float** %modelPtr
%val14537 = load float*, float** %viewPtr
%val14538 = load float*, float** %projectionPtr
call fastcc void @xtm_skybox_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCosZmxvYXQqLGZsb2F0Kl0(%FBO* %val14535, float* %val14536, float* %val14537, float* %val14538)
br label %ifcont14529

else14529:
br label %ifcont14529

ifcont14529:
; do set!
%val14540 = load %xtm_lights*, %xtm_lights** %lightsPtr
; tuple ref
%val14541 = getelementptr %xtm_lights, %xtm_lights* %val14540, i64 0, i32 9
%val14542 = load i32, i32* %val14541
store i32 %val14542, i32* %activelightsPtr
%val14544 = load i32, i32* %activelightsPtr
%cmp14545 = icmp sgt i32 %val14544, 5
br i1 %cmp14545, label %then14543, label %else14543

then14543:
; do set!
%res14546 = call ccc i32 @i64toi32(i64 5)
store i32 %res14546, i32* %activelightsPtr
store i32 %res14546, i32* %ifptr14543
br label %ifcont14543

else14543:
br label %ifcont14543

ifcont14543:
%ifres14547 = load i32, i32* %ifptr14543

; do set!
%val14548 = load %ShaderProgram*, %ShaderProgram** @xtm_render_light_shader
store %ShaderProgram* %val14548, %ShaderProgram** %sh2Ptr
%val14549 = load %ShaderProgram*, %ShaderProgram** %sh2Ptr
call fastcc void @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %val14549)
%val14551 = load %FBO*, %FBO** %render_fboPtr
%res14552 = call fastcc i32 @bind_adhoc_W2kzMixGQk8qXQ(%FBO* %val14551)
%val14553 = load %FBO*, %FBO** %shadow_fboPtr
%res14554 = call fastcc %Texture* @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd(%FBO* %val14553)
%res14555 = call fastcc i32 @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd(%Texture* %res14554, i32 0)
%val14556 = load %ShaderProgram*, %ShaderProgram** %sh2Ptr
%res14557 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val14556)
%var14558 = bitcast [10 x i8]* @gsxtmgraphics-pipeline652 to i8*
%res14559 = call fastcc i32 @glGetUniformLocation_adhoc_W2kzMixpMzIsaTgqXQ(i32 %res14557, i8* %var14558)
call fastcc void @glUniform1i_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res14559, i32 0)
%val14562 = load i1, i1* @ENV_MAP
br i1 %val14562, label %then14561, label %else14561

then14561:
%val14563 = load %ShaderProgram*, %ShaderProgram** %sh2Ptr
%val14564 = load %Texture*, %Texture** @ENV_MAP_TEXTURE
call fastcc void @shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ(%ShaderProgram* %val14563, i32 2, %Texture* %val14564)
br label %ifcont14561

else14561:
%val14566 = load %ShaderProgram*, %ShaderProgram** %sh2Ptr
%null14567 = bitcast i8* null to %Texture*
call fastcc void @shader_update_envmap_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ(%ShaderProgram* %val14566, i32 2, %Texture* %null14567)
br label %ifcont14561

ifcont14561:
%val14570 = load i1, i1* @PROJECTION_TEXTURE_ON
br i1 %val14570, label %then14569, label %else14569

then14569:
%val14571 = load %ShaderProgram*, %ShaderProgram** %sh2Ptr
%val14572 = load %Texture*, %Texture** @PROJECTION_TEXTURE
call fastcc void @shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ(%ShaderProgram* %val14571, i32 3, %Texture* %val14572)
br label %ifcont14569

else14569:
%val14574 = load %ShaderProgram*, %ShaderProgram** %sh2Ptr
%null14575 = bitcast i8* null to %Texture*
call fastcc void @shader_update_projection_texture_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosaTMyLFRleHR1cmUqXQ(%ShaderProgram* %val14574, i32 3, %Texture* %null14575)
br label %ifcont14569

ifcont14569:
%val14577 = load i32, i32* @xtm_render_x
%val14578 = load i32, i32* @xtm_render_y
%val14579 = load i32, i32* @xtm_render_w
%val14580 = load i32, i32* @xtm_render_h
call fastcc void @glViewport_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyXQ(i32 %val14577, i32 %val14578, i32 %val14579, i32 %val14580)
%val14582 = load i32, i32* @GL_CULL_FACE
call fastcc void @glDisable_adhoc_W3ZvaWQsaTMyXQ(i32 %val14582)
%val14586 = load {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*** %opaquePtr
%val14587 = icmp eq {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %val14586, null
br i1 %val14587, label %then14585, label %else14585

then14585:
%res14588 = call ccc i1 @impc_false()
store i1 %res14588, i1* %ifptr14585
br label %ifcont14585

else14585:
%res14589 = call ccc i1 @impc_true()
store i1 %res14589, i1* %ifptr14585
br label %ifcont14585

ifcont14585:
%ifres14590 = load i1, i1* %ifptr14585

br i1 %ifres14590, label %then14584, label %else14584

then14584:
%val14591 = load float*, float** %projectionPtr
%val14592 = load float, float* @xtm_render_angle
%val14593 = load i32, i32* @xtm_render_w
%res14594 = call ccc float @i32tof(i32 %val14593)
%val14595 = load i32, i32* @xtm_render_h
%res14596 = call ccc float @i32tof(i32 %val14595)
%val14597 = fdiv float %res14594, %res14596
%val14598 = load float, float* @xtm_render_near
%val14599 = load float, float* @xtm_render_far
call fastcc void @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ(float* %val14591, float %val14592, float %val14597, float %val14598, float %val14599)
%val14601 = load float*, float** %viewPtr
call fastcc void @xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %val14601)
%val14603 = load float*, float** %modelPtr
call fastcc void @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %val14603)
%val14605 = load %ShaderProgram*, %ShaderProgram** %sh2Ptr
call fastcc void @xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %val14605)
%val14607 = load %ShaderProgram*, %ShaderProgram** %sh2Ptr
call fastcc void @xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %val14607)
%val14609 = load %ShaderProgram*, %ShaderProgram** %sh2Ptr
%val14610 = load float*, float** %modelPtr
%val14611 = load float*, float** %viewPtr
%val14612 = load float*, float** %projectionPtr
call fastcc void @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd(%ShaderProgram* %val14609, float* %val14610, float* %val14611, float* %val14612)
%val14614 = load i64, i64* %framePtr
%val14615 = load %ShaderProgram*, %ShaderProgram** %sh2Ptr
%val14616 = load float*, float** %modelPtr
%val14617 = load float*, float** %viewPtr
%val14618 = load float*, float** %projectionPtr
%val14619 = load i8*, i8** %data_s_62Ptr

; apply closure 
%vval14620 = load {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*** %opaquePtr
%val14621 = load {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*,{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %vval14620
%fPtr14622 = getelementptr {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}* %val14621, i32 0, i32 2
%ePtr14623 = getelementptr {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}* %val14621, i32 0, i32 1
%f14624 = load void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)** %fPtr14622
%e14625 = load i8*, i8** %ePtr14623
%tzone14626 = load i8*, i8** %_impzPtr
%zone14627 = bitcast i8* %tzone14626 to %mzone*
%z14628 = bitcast %mzone* %zone14627 to i8*
tail call fastcc void %f14624(i8* %z14628, i8* %e14625, i64 %val14614, %ShaderProgram* %val14615, float* %val14616, float* %val14617, float* %val14618, i8* %val14619)
br label %ifcont14584

else14584:
br label %ifcont14584

ifcont14584:
%var14631 = bitcast [40 x i8]* @gsxtmgraphics-pipeline653 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var14631)
%val14635 = load {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*** %transparentPtr
%val14636 = icmp eq {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %val14635, null
br i1 %val14636, label %then14634, label %else14634

then14634:
%res14637 = call ccc i1 @impc_false()
store i1 %res14637, i1* %ifptr14634
br label %ifcont14634

else14634:
%res14638 = call ccc i1 @impc_true()
store i1 %res14638, i1* %ifptr14634
br label %ifcont14634

ifcont14634:
%ifres14639 = load i1, i1* %ifptr14634

br i1 %ifres14639, label %then14633, label %else14633

then14633:
%val14640 = load float*, float** %projectionPtr
%val14641 = load float, float* @xtm_render_angle
%val14642 = load i32, i32* @xtm_render_w
%res14643 = call ccc float @i32tof(i32 %val14642)
%val14644 = load i32, i32* @xtm_render_h
%res14645 = call ccc float @i32tof(i32 %val14644)
%val14646 = fdiv float %res14643, %res14645
%val14647 = load float, float* @xtm_render_near
%val14648 = load float, float* @xtm_render_far
call fastcc void @fill_projection_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ(float* %val14640, float %val14641, float %val14646, float %val14647, float %val14648)
%val14650 = load float*, float** %viewPtr
call fastcc void @xtm_camera_view_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %val14650)
%val14652 = load float*, float** %modelPtr
call fastcc void @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %val14652)
%val14654 = load %ShaderProgram*, %ShaderProgram** %sh2Ptr
call fastcc void @xtm_update_lights_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %val14654)
%val14656 = load %ShaderProgram*, %ShaderProgram** %sh2Ptr
call fastcc void @xtm_update_camera_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %val14656)
%val14658 = load %ShaderProgram*, %ShaderProgram** %sh2Ptr
%val14659 = load float*, float** %modelPtr
%val14660 = load float*, float** %viewPtr
%val14661 = load float*, float** %projectionPtr
call fastcc void @xtm_update_matrices_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCpd(%ShaderProgram* %val14658, float* %val14659, float* %val14660, float* %val14661)
%val14663 = load i64, i64* %framePtr
%val14664 = load %ShaderProgram*, %ShaderProgram** %sh2Ptr
%val14665 = load float*, float** %modelPtr
%val14666 = load float*, float** %viewPtr
%val14667 = load float*, float** %projectionPtr
%val14668 = load i8*, i8** %data_s_62Ptr

; apply closure 
%vval14669 = load {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*** %transparentPtr
%val14670 = load {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*,{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %vval14669
%fPtr14671 = getelementptr {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}* %val14670, i32 0, i32 2
%ePtr14672 = getelementptr {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}* %val14670, i32 0, i32 1
%f14673 = load void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)** %fPtr14671
%e14674 = load i8*, i8** %ePtr14672
%tzone14675 = load i8*, i8** %_impzPtr
%zone14676 = bitcast i8* %tzone14675 to %mzone*
%z14677 = bitcast %mzone* %zone14676 to i8*
tail call fastcc void %f14673(i8* %z14677, i8* %e14674, i64 %val14663, %ShaderProgram* %val14664, float* %val14665, float* %val14666, float* %val14667, i8* %val14668)
br label %ifcont14633

else14633:
br label %ifcont14633

ifcont14633:
%var14680 = bitcast [45 x i8]* @gsxtmgraphics-pipeline654 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var14680)
%val14682 = load %FBO*, %FBO** %shadow_fboPtr
%res14683 = call fastcc %Texture* @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd(%FBO* %val14682)
call fastcc void @unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %res14683)
%val14685 = load %FBO*, %FBO** %render_fboPtr
%res14686 = call fastcc i32 @unbind_adhoc_W2kzMixGQk8qXQ(%FBO* %val14685)
%val14687 = load %ShaderProgram*, %ShaderProgram** %sh2Ptr
call fastcc void @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %val14687)
%val14689 = load i32, i32* @GL_DEPTH_TEST
call fastcc void @glDisable_adhoc_W3ZvaWQsaTMyXQ(i32 %val14689)
%val14691 = load float*, float** %modelPtr
call fastcc void @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %val14691)
%val14693 = load float*, float** %viewPtr
call fastcc void @fill_identity_matrix_adhoc_W3ZvaWQsZmxvYXQqXQ(float* %val14693)
%val14695 = load float*, float** %projectionPtr
call fastcc void @fill_orthographic_matrix_adhoc_W3ZvaWQsZmxvYXQqLGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0LGZsb2F0XQ(float* %val14695, float 0xbff0000000000000, float 0x3ff0000000000000, float 0xbff0000000000000, float 0x3ff0000000000000, float 0xbff0000000000000, float 0x3ff0000000000000)
%val14697 = load %FBO*, %FBO** %render_fboPtr
%res14698 = call fastcc i32 @bind_adhoc_W2kzMixGQk8qXQ(%FBO* %val14697)
%val14700 = load i1, i1* @XTM_DOF_ON
br i1 %val14700, label %then14699, label %else14699

then14699:
%val14702 = load i1, i1* @XTM_DOF_AUTOFOCUS
br i1 %val14702, label %then14701, label %else14701

then14701:
%val14703 = load %FBO*, %FBO** %render_fboPtr
%val14704 = load float, float* @XTM_DOF_X
%val14705 = load float, float* @XTM_DOF_Y
%val14706 = load float, float* @XTM_DOF_FLENGTH
%val14707 = load float, float* @XTM_DOF_FSTOP
%val14708 = load i1, i1* @XTM_DOF_DEBUG
%res14709 = call ccc i32 @i1toi32(i1 %val14708)
%val14710 = load float*, float** %modelPtr
%val14711 = load float*, float** %viewPtr
%val14712 = load float*, float** %projectionPtr
call fastcc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd(%FBO* %val14703, float %val14704, float %val14705, float %val14706, float %val14707, i32 %res14709, float* %val14710, float* %val14711, float* %val14712)
br label %ifcont14701

else14701:
%val14714 = load %FBO*, %FBO** %render_fboPtr
%val14715 = load float, float* @XTM_DOF_DISTANCE
%val14716 = load float, float* @XTM_DOF_FLENGTH
%val14717 = load float, float* @XTM_DOF_FSTOP
%val14718 = load i1, i1* @XTM_DOF_DEBUG
%res14719 = call ccc i32 @i1toi32(i1 %val14718)
%val14720 = load float*, float** %modelPtr
%val14721 = load float*, float** %viewPtr
%val14722 = load float*, float** %projectionPtr
call fastcc void @xtm_dof_fx_adhoc_W3ZvaWQsRkJPKixmbG9hdCxmbG9hdCxmbG9hdCxpMzIsZmxvYXQqLGZsb2F0KixmbG9hdCpd(%FBO* %val14714, float %val14715, float %val14716, float %val14717, i32 %res14719, float* %val14720, float* %val14721, float* %val14722)
br label %ifcont14701

ifcont14701:
br label %ifcont14699

else14699:
br label %ifcont14699

ifcont14699:
%val14724 = load %FBO*, %FBO** %render_fboPtr
%res14725 = call fastcc i32 @unbind_adhoc_W2kzMixGQk8qXQ(%FBO* %val14724)
%val14727 = load {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*** %postPtr
%val14728 = icmp eq {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %val14727, null
br i1 %val14728, label %then14726, label %else14726

then14726:
%val14729 = load %ShaderProgram*, %ShaderProgram** @xtm_render_quad_shader
%val14730 = load %FBO*, %FBO** %render_fboPtr
%res14731 = call fastcc %Texture* @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd(%FBO* %val14730)
%val14732 = load float*, float** %modelPtr
%val14733 = load float*, float** %viewPtr
%val14734 = load float*, float** %projectionPtr
call fastcc void @xtm_draw_tex_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSosVGV4dHVyZSosZmxvYXQqLGZsb2F0KixmbG9hdCpd(%ShaderProgram* %val14729, %Texture* %res14731, float* %val14732, float* %val14733, float* %val14734)
br label %ifcont14726

else14726:
%val14736 = load i64, i64* %framePtr
%val14737 = load %ShaderProgram*, %ShaderProgram** @xtm_render_quad_shader
%val14738 = load float*, float** %modelPtr
%val14739 = load float*, float** %viewPtr
%val14740 = load float*, float** %projectionPtr
%val14741 = load i8*, i8** %data_s_62Ptr

; apply closure 
%vval14742 = load {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*** %postPtr
%val14743 = load {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*,{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %vval14742
%fPtr14744 = getelementptr {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}* %val14743, i32 0, i32 2
%ePtr14745 = getelementptr {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}* %val14743, i32 0, i32 1
%f14746 = load void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)** %fPtr14744
%e14747 = load i8*, i8** %ePtr14745
%tzone14748 = load i8*, i8** %_impzPtr
%zone14749 = bitcast i8* %tzone14748 to %mzone*
%z14750 = bitcast %mzone* %zone14749 to i8*
tail call fastcc void %f14746(i8* %z14750, i8* %e14747, i64 %val14736, %ShaderProgram* %val14737, float* %val14738, float* %val14739, float* %val14740, i8* %val14741)
br label %ifcont14726

ifcont14726:
%val14752 = load i32, i32* @GL_DEPTH_TEST
call fastcc void @glEnable_adhoc_W3ZvaWQsaTMyXQ(i32 %val14752)
%var14754 = bitcast [20 x i8]* @gsxtmgraphics-pipeline655 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var14754)
; do set!
%res14756 = call ccc i1 @impc_false()
store i1 %res14756, i1* @XTM_DOF_ON
; do set!
%val14757 = load i64, i64* %framePtr
%val14758 = add i64 %val14757, 1
store i64 %val14758, i64* %framePtr
ret i64 %val14758
}
@gsxtmgraphics-pipeline670 = hidden constant [361 x i8] c"xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}** @xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone14853 = load i8*, i8** %_impzPtr
%zone14854 = bitcast i8* %tzone14853 to %mzone*

; let assign value to symbol xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ
%dat_xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone14854, i64 8)
%xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQPtr = bitcast i8* %dat_xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ to {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***
%tzone14327 = load i8*, i8** %_impzPtr
%zone14328 = bitcast i8* %tzone14327 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone14328, i64 4)
%iPtr = bitcast i8* %dat_i to i32*
%tzone14329 = load i8*, i8** %_impzPtr
%zone14330 = bitcast i8* %tzone14329 to %mzone*

; let assign value to symbol frame
%dat_frame = call i8* @llvm_zone_malloc(%mzone* %zone14330, i64 8)
%framePtr = bitcast i8* %dat_frame to i64*
%tzone14332 = load i8*, i8** %_impzPtr
%zone14333 = bitcast i8* %tzone14332 to %mzone*

; let assign value to symbol lights
%dat_lights = call i8* @llvm_zone_malloc(%mzone* %zone14333, i64 8)
%lightsPtr = bitcast i8* %dat_lights to %xtm_lights**
%tzone14335 = load i8*, i8** %_impzPtr
%zone14336 = bitcast i8* %tzone14335 to %mzone*

; let assign value to symbol camera
%dat_camera = call i8* @llvm_zone_malloc(%mzone* %zone14336, i64 8)
%cameraPtr = bitcast i8* %dat_camera to %xtm_camera**
%tzone14337 = load i8*, i8** %_impzPtr
%zone14338 = bitcast i8* %tzone14337 to %mzone*

; let assign value to symbol activelights
%dat_activelights = call i8* @llvm_zone_malloc(%mzone* %zone14338, i64 4)
%activelightsPtr = bitcast i8* %dat_activelights to i32*
%tzone14345 = load i8*, i8** %_impzPtr
%zone14346 = bitcast i8* %tzone14345 to %mzone*

; let assign value to symbol framebufsize
%dat_framebufsize = call i8* @llvm_zone_malloc(%mzone* %zone14346, i64 8)
%framebufsizePtr = bitcast i8* %dat_framebufsize to float**
%tzone14348 = load i8*, i8** %_impzPtr
%zone14349 = bitcast i8* %tzone14348 to %mzone*

; let assign value to symbol sh1
%dat_sh1 = call i8* @llvm_zone_malloc(%mzone* %zone14349, i64 8)
%sh1Ptr = bitcast i8* %dat_sh1 to %ShaderProgram**
%tzone14351 = load i8*, i8** %_impzPtr
%zone14352 = bitcast i8* %tzone14351 to %mzone*

; let assign value to symbol sh2
%dat_sh2 = call i8* @llvm_zone_malloc(%mzone* %zone14352, i64 8)
%sh2Ptr = bitcast i8* %dat_sh2 to %ShaderProgram**
%tzone14359 = load i8*, i8** %_impzPtr
%zone14360 = bitcast i8* %tzone14359 to %mzone*

; let assign value to symbol model
%dat_model = call i8* @llvm_zone_malloc(%mzone* %zone14360, i64 8)
%modelPtr = bitcast i8* %dat_model to float**
%tzone14367 = load i8*, i8** %_impzPtr
%zone14368 = bitcast i8* %tzone14367 to %mzone*

; let assign value to symbol view
%dat_view = call i8* @llvm_zone_malloc(%mzone* %zone14368, i64 8)
%viewPtr = bitcast i8* %dat_view to float**
%tzone14375 = load i8*, i8** %_impzPtr
%zone14376 = bitcast i8* %tzone14375 to %mzone*

; let assign value to symbol projection
%dat_projection = call i8* @llvm_zone_malloc(%mzone* %zone14376, i64 8)
%projectionPtr = bitcast i8* %dat_projection to float**
%tzone14378 = load i8*, i8** %_impzPtr
%zone14379 = bitcast i8* %tzone14378 to %mzone*

; let assign value to symbol shadow_fbo
%dat_shadow_fbo = call i8* @llvm_zone_malloc(%mzone* %zone14379, i64 8)
%shadow_fboPtr = bitcast i8* %dat_shadow_fbo to %FBO**
%tzone14381 = load i8*, i8** %_impzPtr
%zone14382 = bitcast i8* %tzone14381 to %mzone*

; let assign value to symbol render_fbo
%dat_render_fbo = call i8* @llvm_zone_malloc(%mzone* %zone14382, i64 8)
%render_fboPtr = bitcast i8* %dat_render_fbo to %FBO**

; let value assignment
%i = select i1 true, i32 0, i32 0
store i32 %i, i32* %iPtr


; let value assignment
%frame = select i1 true, i64 0, i64 0
store i64 %frame, i64* %framePtr

%res14331 = call fastcc %xtm_lights* @xtm_get_lights_adhoc_W3h0bV9saWdodHMqXQ()

; let value assignment
%lights = select i1 true, %xtm_lights* %res14331, %xtm_lights* %res14331
store %xtm_lights* %lights, %xtm_lights** %lightsPtr

%res14334 = call fastcc %xtm_camera* @xtm_get_camera_adhoc_W3h0bV9jYW1lcmEqXQ()

; let value assignment
%camera = select i1 true, %xtm_camera* %res14334, %xtm_camera* %res14334
store %xtm_camera* %camera, %xtm_camera** %cameraPtr


; let value assignment
%activelights = select i1 true, i32 0, i32 0
store i32 %activelights, i32* %activelightsPtr

%val14339 = getelementptr i64, i64* null, i32 1
%zonesize14340 = mul i64 4, 2
%tzone14341 = load i8*, i8** %_impzPtr
%zone14342 = bitcast i8* %tzone14341 to %mzone*
%dat14343 = call i8* @llvm_zone_malloc(%mzone* %zone14342, i64 %zonesize14340)
call i8* @memset(i8* %dat14343, i32 0, i64 %zonesize14340)
%val14344 = bitcast i8* %dat14343 to float*

; let value assignment
%framebufsize = select i1 true, float* %val14344, float* %val14344
store float* %framebufsize, float** %framebufsizePtr

%null14347 = bitcast i8* null to %ShaderProgram*

; let value assignment
%sh1 = select i1 true, %ShaderProgram* %null14347, %ShaderProgram* %null14347
store %ShaderProgram* %sh1, %ShaderProgram** %sh1Ptr

%null14350 = bitcast i8* null to %ShaderProgram*

; let value assignment
%sh2 = select i1 true, %ShaderProgram* %null14350, %ShaderProgram* %null14350
store %ShaderProgram* %sh2, %ShaderProgram** %sh2Ptr

%val14353 = getelementptr i64, i64* null, i32 1
%zonesize14354 = mul i64 4, 16
%tzone14355 = load i8*, i8** %_impzPtr
%zone14356 = bitcast i8* %tzone14355 to %mzone*
%dat14357 = call i8* @llvm_zone_malloc(%mzone* %zone14356, i64 %zonesize14354)
call i8* @memset(i8* %dat14357, i32 0, i64 %zonesize14354)
%val14358 = bitcast i8* %dat14357 to float*

; let value assignment
%model = select i1 true, float* %val14358, float* %val14358
store float* %model, float** %modelPtr

%val14361 = getelementptr i64, i64* null, i32 1
%zonesize14362 = mul i64 4, 16
%tzone14363 = load i8*, i8** %_impzPtr
%zone14364 = bitcast i8* %tzone14363 to %mzone*
%dat14365 = call i8* @llvm_zone_malloc(%mzone* %zone14364, i64 %zonesize14362)
call i8* @memset(i8* %dat14365, i32 0, i64 %zonesize14362)
%val14366 = bitcast i8* %dat14365 to float*

; let value assignment
%view = select i1 true, float* %val14366, float* %val14366
store float* %view, float** %viewPtr

%val14369 = getelementptr i64, i64* null, i32 1
%zonesize14370 = mul i64 4, 16
%tzone14371 = load i8*, i8** %_impzPtr
%zone14372 = bitcast i8* %tzone14371 to %mzone*
%dat14373 = call i8* @llvm_zone_malloc(%mzone* %zone14372, i64 %zonesize14370)
call i8* @memset(i8* %dat14373, i32 0, i64 %zonesize14370)
%val14374 = bitcast i8* %dat14373 to float*

; let value assignment
%projection = select i1 true, float* %val14374, float* %val14374
store float* %projection, float** %projectionPtr

%null14377 = bitcast i8* null to %FBO*

; let value assignment
%shadow_fbo = select i1 true, %FBO* %null14377, %FBO* %null14377
store %FBO* %shadow_fbo, %FBO** %shadow_fboPtr

%null14380 = bitcast i8* null to %FBO*

; let value assignment
%render_fbo = select i1 true, %FBO* %null14380, %FBO* %null14380
store %FBO* %render_fbo, %FBO** %render_fboPtr

%tzone14850 = load i8*, i8** %_impzPtr
%zone14851 = bitcast i8* %tzone14850 to %mzone*

; let assign value to symbol _anon_lambda_26
%dat__anon_lambda_26 = call i8* @llvm_zone_malloc(%mzone* %zone14851, i64 8)
%_anon_lambda_26Ptr = bitcast i8* %dat__anon_lambda_26 to { i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***
%tzone14761 = load i8*, i8** %_impzPtr
%zone14762 = bitcast i8* %tzone14761 to %mzone*
call void @llvm_zone_mark(%mzone* %zone14762)
; malloc closure structure
%clsptr14763 = call i8* @llvm_zone_malloc(%mzone* %zone14762, i64 24)
%closure14764 = bitcast i8* %clsptr14763 to { i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}*

; malloc environment structure
%envptr14765 = call i8* @llvm_zone_malloc(%mzone* %zone14762, i64 120)
%environment14766 = bitcast i8* %envptr14765 to {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}*

; malloc closure address table
%addytable14767 = call %clsvar* @new_address_table()
%var14768 = bitcast [308 x i8]* @gsxtmgraphics-pipeline656 to i8*
%var14769 = bitcast [367 x i8]* @gsxtmgraphics-pipeline657 to i8*
%addytable14770 = call %clsvar* @add_address_table(%mzone* %zone14762, i8* %var14768, i32 0, i8* %var14769, i32 3, %clsvar* %addytable14767)
%var14771 = bitcast [11 x i8]* @gsxtmgraphics-pipeline658 to i8*
%var14772 = bitcast [6 x i8]* @gsxtmgraphics-pipeline617 to i8*
%addytable14773 = call %clsvar* @add_address_table(%mzone* %zone14762, i8* %var14771, i32 8, i8* %var14772, i32 3, %clsvar* %addytable14770)
%var14774 = bitcast [11 x i8]* @gsxtmgraphics-pipeline659 to i8*
%var14775 = bitcast [6 x i8]* @gsxtmgraphics-pipeline617 to i8*
%addytable14776 = call %clsvar* @add_address_table(%mzone* %zone14762, i8* %var14774, i32 16, i8* %var14775, i32 3, %clsvar* %addytable14773)
%var14777 = bitcast [11 x i8]* @gsxtmgraphics-pipeline660 to i8*
%var14778 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable14779 = call %clsvar* @add_address_table(%mzone* %zone14762, i8* %var14777, i32 24, i8* %var14778, i32 3, %clsvar* %addytable14776)
%var14780 = bitcast [5 x i8]* @gsxtmgraphics-pipeline661 to i8*
%var14781 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable14782 = call %clsvar* @add_address_table(%mzone* %zone14762, i8* %var14780, i32 32, i8* %var14781, i32 3, %clsvar* %addytable14779)
%var14783 = bitcast [6 x i8]* @gsxtmgraphics-pipeline662 to i8*
%var14784 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable14785 = call %clsvar* @add_address_table(%mzone* %zone14762, i8* %var14783, i32 40, i8* %var14784, i32 3, %clsvar* %addytable14782)
%var14786 = bitcast [4 x i8]* @gsxtmgraphics-pipeline663 to i8*
%var14787 = bitcast [16 x i8]* @gsxtmgraphics-pipeline664 to i8*
%addytable14788 = call %clsvar* @add_address_table(%mzone* %zone14762, i8* %var14786, i32 48, i8* %var14787, i32 3, %clsvar* %addytable14785)
%var14789 = bitcast [4 x i8]* @gsxtmgraphics-pipeline665 to i8*
%var14790 = bitcast [16 x i8]* @gsxtmgraphics-pipeline664 to i8*
%addytable14791 = call %clsvar* @add_address_table(%mzone* %zone14762, i8* %var14789, i32 56, i8* %var14790, i32 3, %clsvar* %addytable14788)
%var14792 = bitcast [13 x i8]* @gsxtmgraphics-pipeline666 to i8*
%var14793 = bitcast [7 x i8]* @gsxtmgraphics-pipeline34 to i8*
%addytable14794 = call %clsvar* @add_address_table(%mzone* %zone14762, i8* %var14792, i32 64, i8* %var14793, i32 3, %clsvar* %addytable14791)
%var14795 = bitcast [13 x i8]* @gsxtmgraphics-pipeline667 to i8*
%var14796 = bitcast [4 x i8]* @gsxtmgraphics-pipeline241 to i8*
%addytable14797 = call %clsvar* @add_address_table(%mzone* %zone14762, i8* %var14795, i32 72, i8* %var14796, i32 3, %clsvar* %addytable14794)
%var14798 = bitcast [7 x i8]* @gsxtmgraphics-pipeline366 to i8*
%var14799 = bitcast [13 x i8]* @gsxtmgraphics-pipeline367 to i8*
%addytable14800 = call %clsvar* @add_address_table(%mzone* %zone14762, i8* %var14798, i32 80, i8* %var14799, i32 3, %clsvar* %addytable14797)
%var14801 = bitcast [7 x i8]* @gsxtmgraphics-pipeline419 to i8*
%var14802 = bitcast [13 x i8]* @gsxtmgraphics-pipeline420 to i8*
%addytable14803 = call %clsvar* @add_address_table(%mzone* %zone14762, i8* %var14801, i32 88, i8* %var14802, i32 3, %clsvar* %addytable14800)
%var14804 = bitcast [6 x i8]* @gsxtmgraphics-pipeline668 to i8*
%var14805 = bitcast [4 x i8]* @gsxtmgraphics-pipeline421 to i8*
%addytable14806 = call %clsvar* @add_address_table(%mzone* %zone14762, i8* %var14804, i32 96, i8* %var14805, i32 3, %clsvar* %addytable14803)
%var14807 = bitcast [2 x i8]* @gsxtmgraphics-pipeline240 to i8*
%var14808 = bitcast [4 x i8]* @gsxtmgraphics-pipeline241 to i8*
%addytable14809 = call %clsvar* @add_address_table(%mzone* %zone14762, i8* %var14807, i32 104, i8* %var14808, i32 3, %clsvar* %addytable14806)
%var14810 = bitcast [16 x i8]* @gsxtmgraphics-pipeline669 to i8*
%var14811 = bitcast [367 x i8]* @gsxtmgraphics-pipeline657 to i8*
%addytable14812 = call %clsvar* @add_address_table(%mzone* %zone14762, i8* %var14810, i32 112, i8* %var14811, i32 3, %clsvar* %addytable14809)
%address-table14813 = bitcast %clsvar* %addytable14812 to i8*

; insert table, function and environment into closure struct
%closure.table14844 = getelementptr { i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}, { i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}* %closure14764, i32 0, i32 0
store i8* %address-table14813, i8** %closure.table14844
%closure.env14845 = getelementptr { i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}, { i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}* %closure14764, i32 0, i32 1
store i8* %envptr14765, i8** %closure.env14845
%closure.func14846 = getelementptr { i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}, { i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}* %closure14764, i32 0, i32 2
store i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)* @xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ__14326, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)** %closure.func14846
%closure_size14847 = call i64 @llvm_zone_mark_size(%mzone* %zone14762)
call void @llvm_zone_ptr_set_size(i8* %clsptr14763, i64 %closure_size14847)
%wrapper_ptr14848 = call i8* @llvm_zone_malloc(%mzone* %zone14762, i64 8)
%closure_wrapper14849 = bitcast i8* %wrapper_ptr14848 to { i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}**
store { i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}* %closure14764, { i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}** %closure_wrapper14849

; let value assignment
%_anon_lambda_26 = select i1 true, { i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}** %closure_wrapper14849, { i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}** %closure_wrapper14849
store { i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}** %_anon_lambda_26, { i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}*** %_anon_lambda_26Ptr

; add data to environment
; don't need to alloc for env var xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ
%tmp_envptr14815 = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %environment14766, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}*** %xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQPtr, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}**** %tmp_envptr14815

; don't need to alloc for env var render_fbo
%tmp_envptr14817 = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %environment14766, i32 0, i32 1
store %FBO** %render_fboPtr, %FBO*** %tmp_envptr14817

; don't need to alloc for env var shadow_fbo
%tmp_envptr14819 = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %environment14766, i32 0, i32 2
store %FBO** %shadow_fboPtr, %FBO*** %tmp_envptr14819

; don't need to alloc for env var projection
%tmp_envptr14821 = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %environment14766, i32 0, i32 3
store float** %projectionPtr, float*** %tmp_envptr14821

; don't need to alloc for env var view
%tmp_envptr14823 = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %environment14766, i32 0, i32 4
store float** %viewPtr, float*** %tmp_envptr14823

; don't need to alloc for env var model
%tmp_envptr14825 = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %environment14766, i32 0, i32 5
store float** %modelPtr, float*** %tmp_envptr14825

; don't need to alloc for env var sh2
%tmp_envptr14827 = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %environment14766, i32 0, i32 6
store %ShaderProgram** %sh2Ptr, %ShaderProgram*** %tmp_envptr14827

; don't need to alloc for env var sh1
%tmp_envptr14829 = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %environment14766, i32 0, i32 7
store %ShaderProgram** %sh1Ptr, %ShaderProgram*** %tmp_envptr14829

; don't need to alloc for env var framebufsize
%tmp_envptr14831 = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %environment14766, i32 0, i32 8
store float** %framebufsizePtr, float*** %tmp_envptr14831

; don't need to alloc for env var activelights
%tmp_envptr14833 = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %environment14766, i32 0, i32 9
store i32* %activelightsPtr, i32** %tmp_envptr14833

; don't need to alloc for env var camera
%tmp_envptr14835 = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %environment14766, i32 0, i32 10
store %xtm_camera** %cameraPtr, %xtm_camera*** %tmp_envptr14835

; don't need to alloc for env var lights
%tmp_envptr14837 = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %environment14766, i32 0, i32 11
store %xtm_lights** %lightsPtr, %xtm_lights*** %tmp_envptr14837

; don't need to alloc for env var frame
%tmp_envptr14839 = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %environment14766, i32 0, i32 12
store i64* %framePtr, i64** %tmp_envptr14839

; don't need to alloc for env var i
%tmp_envptr14841 = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %environment14766, i32 0, i32 13
store i32* %iPtr, i32** %tmp_envptr14841

; don't need to alloc for env var _anon_lambda_26
%tmp_envptr14843 = getelementptr {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***, %FBO**, %FBO**, float**, float**, float**, %ShaderProgram**, %ShaderProgram**, float**, i32*, %xtm_camera**, %xtm_lights**, i64*, i32*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}***}* %environment14766, i32 0, i32 14
store {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}*** %_anon_lambda_26Ptr, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}**** %tmp_envptr14843


%val14852 = load {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}**, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}*** %_anon_lambda_26Ptr

; let value assignment
%xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ = select i1 true, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}** %val14852, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}** %val14852
store {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}** %xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}*** %xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQPtr

%val14855 = load {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}**, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}*** %xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQPtr
ret {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}** %val14855
}


@xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}** @xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ({i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_0,{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_1,{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_2,{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_3,i8* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*,  i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_0, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_1, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_2, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_3, i8* %arg_4)
ret i64 %result
}


define dllexport ccc i64 @xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ_native({i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_0,{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_1,{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_2,{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_3,i8* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*,  i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_0, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_1, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_2, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_3, i8* %arg_4)
ret i64 %result
}


define dllexport ccc i8*  @xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var14856 = bitcast [361 x i8]* @gsxtmgraphics-pipeline670 to i8*
call i32 (i8*, ...) @printf(i8* %var14856)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var14857 = bitcast [361 x i8]* @gsxtmgraphics-pipeline670 to i8*
call i32 (i8*, ...) @printf(i8* %var14857)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var14858 = bitcast [361 x i8]* @gsxtmgraphics-pipeline670 to i8*
call i32 (i8*, ...) @printf(i8* %var14858)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var14859 = bitcast [361 x i8]* @gsxtmgraphics-pipeline670 to i8*
call i32 (i8*, ...) @printf(i8* %var14859)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr_or_str(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var14860 = bitcast [361 x i8]* @gsxtmgraphics-pipeline670 to i8*
call i32 (i8*, ...) @printf(i8* %var14860)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i8*  @cptr_value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*,  i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_0, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_1, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_2, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_3, i8* %arg_4)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*}*
%arg_p_0 = getelementptr {{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*}, {{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*** %arg_p_0
%arg_p_1 = getelementptr {{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*}, {{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*** %arg_p_1
%arg_p_2 = getelementptr {{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*}, {{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*** %arg_p_2
%arg_p_3 = getelementptr {{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*}, {{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*}* %fstruct, i32 0, i32 3
%arg_3 = load {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}*** %arg_p_3
%arg_p_4 = getelementptr {{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*}, {{i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*}* %fstruct, i32 0, i32 4
%arg_4 = load i8*, i8** %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_render_adhoc_W2k2NCxbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosW3ZvaWQsaTY0LFNoYWRlclByb2dyYW0qLGZsb2F0KixmbG9hdCosZmxvYXQqLGk4Kl0qLFt2b2lkLGk2NCxTaGFkZXJQcm9ncmFtKixmbG9hdCosZmxvYXQqLGZsb2F0KixpOCpdKixbdm9pZCxpNjQsU2hhZGVyUHJvZ3JhbSosZmxvYXQqLGZsb2F0KixmbG9hdCosaTgqXSosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}*, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}, {i8*, i8*, i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)*,  i64 (i8*, i8*, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}**, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_0, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_1, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_2, {i8*, i8*, void (i8*, i8*, i64, %ShaderProgram*, float*, float*, float*, i8*)*}** %arg_3, i8* %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


