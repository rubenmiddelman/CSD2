;TSM library
;Developed by Timothy Roberts as part of the Griffith University
;Industry Affiliates Program in 2016
;The thesis written in conjunction with this project can be found at
;ftp://ftp.timrobertssound.com.au
;username: TSM@timrobertssound.com.au
;password: extempore
;Currently the library is set to process stereo audio signals.
;The number of channels can be increased, however the channels will slowly drift
;out of phase if additional consideration is not taken.

(sys:load "libs/core/math.xtm")
(sys:load "libs/external/audio_dsp_ext.xtm") ;fft is included here
(sys:load "libs/core/audio_dsp.xtm")


(bind-val TSM_active i64 0)
(bind-val speed float 1.0) ;smaller is slower.  0.5 is half speed and 2 is double speed
(bind-val beta float 1.0) ;beta is a variable used to reduce graininess in sPL
(bind-val range float 0.2) ; making this value with reduce the buzzing in sPL, but increase phasing. The frequency of the buzzing is a function of the FFT length.
(bind-val trigger i64 0) ; value used to trigger diagnostic printing of variables

;Circular shift closure
;Vector rotate named according to convention in math.xtm
(bind-func vrotate:[void,float*,i64,i64]*
  (lambda (ptr:float* buffer_size:i64 shift:i64)
    (let ((temp:float* (salloc buffer_size))
          (i:i64 0))
      (dotimes (i buffer_size) ;rotate the vector
        (pset! temp i (pref ptr (% (+ i shift) buffer_size))))
      (dotimes (i buffer_size) ;copy the vector back to original location
        (pset! ptr i (pref temp i))))))

;find peaks as per Laroche and Dolson (bigger than 4 neighbours)
;In the future, consider the efficiency difference of zero padding a copy of the buffer
;versus maths of accounting for out of bounds indexes
;The code is certainly easier using zero padding
;This code assumes that the peaks memory allocated is correctly sized or bigger
;The number of peaks is returned to allow for easier function use. (ceil(buffer_size/3)) for > 4 neighbours
(bind-func find_peaks:[i64,float*,i64,i64*,i64*,i64*]*
  (lambda (buffer:float* buffer_len:i64 peaks_array:i64* region_lower:i64* region_upper:i64*)
    (let ((n:i64 0);
          (peak_index:i64 0)
          (buff_padded:float* (salloc (+ buffer_len 4))))
      (pset! buff_padded 0 0.0) ;Zero pad the buffer
      (pset! buff_padded 1 0.0)
      (pset! buff_padded (+ buffer_len 2) 0.0)
      (pset! buff_padded (+ buffer_len 3) 0.0)
      (dotimes (n buffer_len)
        (pset! buff_padded (+ n 2) (pref buffer n)))
      (dotimes (n buffer_len) ;peak finding
        (if (> (pref buff_padded (+ n 2)) (pref buff_padded n))
          (if (> (pref buff_padded (+ n 2)) (pref buff_padded (+ n 1)))
            (if (> (pref buff_padded (+ n 2)) (pref buff_padded (+ n 3)))
              (if (> (pref buff_padded (+ n 2)) (pref buff_padded (+ n 4)))
                (begin
                  (pset! peaks_array peak_index n)
                  (set! peak_index (+ peak_index 1))))))))  ;After all peaks are found, peak index becomes the number of peaks
      (if (> peak_index 0)
        (begin
          (pset! region_lower 0 0) ;Set the region_lower bound
          (dotimes (n (- peak_index 1))
            (pset! region_lower (+ n 1) (ftoi64 (ceil (/ (i64tof (+ (pref peaks_array n)
                                                                    (pref peaks_array (+ n 1))))
                                                         (i64tof 2))))))

          (dotimes (n (- peak_index 1)) ;Set the region_upper bound
            (pset! region_upper n (- (pref region_lower (+ n 1)) 1)))
          (pset! region_upper (- peak_index 1) buffer_len)))
      peak_index)))

;Compare a value in an array with neighbours. neighbours is per side
(bind-func greater_than_neighbours
  (lambda (buffer:float* offset:i64 num_neighbours:i64)
    (let ((n:i64 0)
          (peak:i64 1))
      (dotimes (n num_neighbours)
        (cond ((and (= peak 1) (> (pref buffer offset) (pref buffer (+ offset (+ n 1)))) (> (pref buffer offset) (pref buffer (- offset (+ n 1)))))
                (set! peak 1))
              (else
                (set! peak 0))))
      peak)))

; Multiresolution peak picking
; Causes buzzing when used in sPL.  This is an sPL issue not a find_peaks_log issue.
; If number of neighbours < 2 there is minimal buzzing
; This will require more work.  Doesn't give same results as MATLAB implementation
(bind-func find_peaks_log:[i64,float*,i64,i64*,i64*,i64*]*
  (lambda (buffer:float* buffer_len:i64 peaks_array:i64* region_lower:i64* region_upper:i64*)
    (let ((n:i64 0);
          (pad_amount:i64 64)
          (peak_index:i64 0)
          (buff_padded:float* (salloc (+ buffer_len pad_amount)))
          (neighbours:i64 0)
          (dummy:i64 0))
      (dotimes (n pad_amount)
        (pset! buff_padded (+ buffer_len n) 0.0))
      (dotimes (n buffer_len)
        (pset! buff_padded n (pref buffer n)))
      (dotimes (n buffer_len) ;peak finding
        (cond ((< n 17)
                (pset! peaks_array peak_index n)
                (set! peak_index (+ peak_index 1)))
              (else (cond ((< n 33)
                           (cond ((= (greater_than_neighbours buff_padded n 1) 1)
                                  (pset! peaks_array peak_index n)
                                  (set! peak_index (+ peak_index 1)))
                                 (else 0)))
                          (else (cond ((< n 65)
                                       (cond ((= (greater_than_neighbours buff_padded n 2) 1) ;n 2
                                              (pset! peaks_array peak_index n)
                                              (set! peak_index (+ peak_index 1)))
                                             (else 0)))
                                      (else (cond ((< n 129)
                                                   (cond ((= (greater_than_neighbours buff_padded n 4) 1) ;n 4
                                                          (pset! peaks_array peak_index n)
                                                          (set! peak_index (+ peak_index 1)))
                                                         (else 0)))
                                                  (else (cond ((< n 257)
                                                               (cond ((= (greater_than_neighbours buff_padded n 8) 1) ;n 8
                                                                      (pset! peaks_array peak_index n)
                                                                      (set! peak_index (+ peak_index 1)))
                                                                     (else 0)))
                                                              (else (cond ((< n 513)
                                                                           (cond ((= (greater_than_neighbours buff_padded n 16) 1) ;n 16
                                                                                  (pset! peaks_array peak_index n)
                                                                                  (set! peak_index (+ peak_index 1)))
                                                                                 (else 0)))
                                                                          (else (cond ((< n 1025)
                                                                                       (cond ((= (greater_than_neighbours buff_padded n 32) 1) ;n 32
                                                                                              (pset! peaks_array peak_index n)
                                                                                              (set! peak_index (+ peak_index 1)))
                                                                                             (else 0)))
                                                                                      (else (cond ((= (greater_than_neighbours buff_padded n 64) 1) ;n 64
                                                                                                    (pset! peaks_array peak_index n)
                                                                                                    (set! peak_index (+ peak_index 1)))
                                                                                                  (else 0)))))))))))))))))
      (cond ((> peak_index 17)
              (pfill! region_lower 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17) ; The 17 ensures that the regions are continuous for entire range.
              (pfill! region_upper 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16)
              (dotimes (n (- peak_index 18))
                  (pset! region_lower (+ n 18) (ftoi64 (ceil (/ (i64tof (+ (pref peaks_array (+ n 18))
                                                                           (pref peaks_array (+ n 17))))
                                                                 (i64tof 2))))))
              (dotimes (n (- peak_index 18)) ;Set the region_upper bound
                  (pset! region_upper (+ n 17) (- (pref region_lower (+ n 18)) 1)))
                  (pset! region_upper (- peak_index 1) buffer_len))
            (else
              (pfill! peaks_array 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)))
      ;(if (= trigger 1)
      ;  (begin
      ;    (set! trigger 0)
      ;    (println "peaks")
      ;    (dotimes (n peak_index)
      ;      (printf "%d," (pref peaks_array n)))
      ;    (println "\nlower")
      ;    (dotimes (n peak_index)
      ;      (printf "%d," (pref region_lower n)))
      ;    (println "\nupper")
      ;    (dotimes (n peak_index)
      ;      (printf "%d," (pref region_upper n)))
      ;    (println "")))
      peak_index)))

;This returns the position of the max value in a vector
(bind-func vmax_pos:[i64,float*,i64]*
  (lambda (buf:float* len:i64)
    (let ((max_val:float (pref buf 0))
          (i:i64 0)
          (max_pos:i64 0))
      (dotimes (i len)
        (if (> (pref buf i) max_val)
          (begin
            (set! max_val (pref buf i))
            (set! max_pos i))))
      max_pos)))

;This closure returns the lag for maximum cross correlation between 2 vectors.
;A result of 0 means that the initial samples of each vector are aligned.
;Negative numbers place vector 1 before vector 2
;Positive numbers place vector 1 after alignment of vector1(0) and vector2(0)
(bind-func xCorr_max:[i64,float*,i64,float*,i64]*
  (lambda (vector1:float* len1:i64 vector2:float* len2:i64)
    (let ((m:i64 0)
          (n:i64 0)
          (shift:i64 0)
          (lag_max_xCorr:i64 0)
          (max_pos:i64 0)
          (sum_vec1_2:float 0.0)
          (sum_vec2_2:float 0.0)
          (denom:float 0.0)
          (correlations:float* (salloc (- (+ len1 len2) 1)))
          (lags:i64* (salloc (- (+ len1 len2) 1))))
      (dotimes (n (- (+ len1 len2) 1))  ;initialise correlations to 0
        (pset! correlations n 0.0))
      (dotimes (shift (- (+ len1 len2) 1))
        (pset! lags shift (- shift (- len1 1)))  ;store the shift value into lags
        (cond ((< shift len2)
                (dotimes (m (+ shift 1))
                  (pset! correlations shift (+ (pref correlations shift) (* (pref vector2 m) (pref vector1 (+ (- len1 1 shift) m)))))
                  (set! sum_vec1_2 (+ sum_vec1_2 (* (pref vector1 (+ (- len1 1 shift) m)) (pref vector1 (+ (- len1 1 shift) m)))))
                  (set! sum_vec2_2 (+ sum_vec2_2 (* (pref vector2 m) (pref vector2 m))))))
              (else
                (dotimes (m (- (+ len1 len2) (+ 1 shift)))
                  (pset! correlations shift (+ (pref correlations shift) (* (pref vector1 m) (pref vector2 (- (+ m shift 1) len1)))))
                  (set! sum_vec1_2 (+ sum_vec1_2 (* (pref vector1 m) (pref vector1 m))))
                  (set! sum_vec2_2 (+ sum_vec2_2 (* (pref vector2 (- (+ m shift 1) len1)) (pref vector2 (- (+ m shift 1) len1)))))
                  )))
        (set! denom (sqrt (* sum_vec1_2 sum_vec2_2)))
        (cond ((= denom 0.0) (pset! correlations shift 0.0))
              (else (pset! correlations shift (/ (pref correlations shift) denom))))
        (println (pref correlations shift))
        (set! sum_vec1_2 0.0)
        (set! sum_vec2_2 0.0))
      ;return the lag for maximum cross correlation
      (set! max_pos (vmax_pos correlations (- (+ len1 len2) 1)))
      (set! lag_max_xCorr (pref lags max_pos))
      lag_max_xCorr)))

;This function separates even and odd elements of a vector.
(bind-func LR_split:[void,float*,float*,float*,i64]*
  (lambda (frame:float* left:float* right:float* buffer_size:i64)
    (let ((n:i64 0))
      (dotimes (n (/ buffer_size 2))
        (pset! left n (pref frame (* 2 n)))
        (pset! right n (pref frame (+ (* 2 n) 1))))
      void)))

;This function interleaves 2 vectors.
(bind-func LR_combine:[void,float*,float*,float*,i64]*
  (lambda (frame:float* left:float* right:float* buffer_size:i64)
    (let ((n:i64 0))
      (dotimes (n (/ buffer_size 2))
        (pset! frame (* n 2) (pref left n))
        (pset! frame (+ (* n 2) 1) (pref right n)))
      void)))

;Generate a rectangular window function of buffer_size N
(bind-func rectangular_window_func:[void,float*,i64]*
    (lambda (wn:float* N:i64)
      (let ((n:i64 0))
        (dotimes (n N)
          (pset! wn n 1.0))
        void)))

;Generate a half rectangular window function of buffer_size N  1100
(bind-func half_rectangular_window_func:[void,float*,i64]*
    (lambda (wn:float* N:i64)
      (let ((n:i64 0))
        (dotimes (n N)
          (cond ((< n (/ N 2))
                  (pset! wn n 1.0))
                (else (pset! wn n 0.0))))
        void)))

;Generate a half rectangular window function of buffer_size N  0011
(bind-func half_rectangular_window_func2:[void,float*,i64]*
    (lambda (wn:float* N:i64)
      (let ((n:i64 0))
        (dotimes (n N)
          (cond ((> n (/ N 2))
                  (pset! wn n 1.0))
                (else (pset! wn n 0.0))))
        void)))

;Generate hanning window function of buffer_size N
(bind-func hamming_window_func:[void,float*,i64]*
    (lambda (wn:float* N:i64)
      (let ((n:i64 0))
        (dotimes (n N)
          (pset! wn n (- 0.54 (* 0.46 (cos (/ (* TWOPIf (i64tof n)) (i64tof (- N 1))))))))
        (pset! wn 0 (/ (pref wn 0) 2.0))
        (pset! wn (- N 1) (/ (pref wn (- N 1)) 2.0))
        void)))

;Generate hamming window function of buffer_size N
(bind-func hanning_window_func:[void,float*,i64]*
    (lambda (wn:float* N:i64)
      (let ((n:i64 0))
        (dotimes (n N)
          (pset! wn n (* 0.5 (- 1.0 (cos (/ (* TWOPIf (i64tof n)) (i64tof (- N 1))))))))
        void)))

;Generate triangular window function of buffer_size N
(bind-func triangular_window_func:[void,float*,i64]*
    (lambda (wn:float* N:i64)
      (let ((n:i64 0)
            (L:i64 (- N 1)))
        (dotimes (n N)
          (pset! wn n (- 1.0 (fabs (/ (- (i64tof n) (/ (i64tof (- N 1)) 2.0)) (/ (i64tof L) 2.0))))))
        void)))

;Calculate the phase of a real+imaginary complex value
(bind-func Complex_phase2
  (lambda (a:Complexf)
    (atan2 (tref a 1) (tref a 0))))

;transform a whole buffer cart->pol in-place
(bind-func cart_to_pol2
  "transform a whole buffer cart->pol in-place"
  (lambda (a:Complexf* n:i64)
    (let ((temp:float 0.0))
    (doloop (i n)
      (set! temp (sqrt (+ (* (tref (pref a i) 0) (tref (pref a i) 0))
                          (* (tref (pref a i) 1) (tref (pref a i) 1)))))
      (tset! (pref-ptr a i) 1
             (atan2 (tref (pref a i) 1) (tref (pref a i) 0)))
      (tset! (pref-ptr a i) 0 temp))
    void)))

;transform a whole buffer pol->cart in-place
(bind-func pol_to_cart2
  "transform a whole buffer pol->cart in-place"
  (lambda (a:Complexf* n:i64)
    (let ((temp:float 0.0))
    (doloop (i n)
      (set! temp (* (tref (pref a i) 0) (cos (tref (pref a i) 1))))
      (tset! (pref-ptr a i) 1
             (* (tref (pref a i) 0) (sin (tref (pref a i) 1))))
      (tset! (pref-ptr a i) 0 temp))
    void)))

;performs complex multiplication of Complex buffers X*Y=Z
(bind-func Complex_multiplication_polar
  (lambda (X:Complexf* Y:Complexf* Z:Complexf* size:i64)
    (let ((n:i64 0))
      (dotimes (n size)
        (tset! (pref-ptr Z n) 0 (* (tref (pref-ptr X n) 0) (tref (pref-ptr Y n) 0))) ;multiply magnitude
        (tset! (pref-ptr Z n) 1 (+ (tref (pref-ptr X n) 1) (tref (pref-ptr Y n) 1))) ;sum angles
        void))))

;checks if array is empty. Returns 1 if empty.
(bind-func is_empty
  (lambda (buffer:i64* size:i64)
    (let ((n:i64 0)
          (stop:i64 1))
      (while (and (< n size) (= stop 1))
          (cond ((= (pref buffer n) 0)
                  (set! n (+ n 1)))
                (else
                  (set! stop 0))))
      stop)))

;finds the peak of the region in the previous frame to which the current peak belongs to
(bind-func find_previous_peak
  (lambda (current_peak:i64 prev_peaks_array:i64* prev_lower_bound:i64* prev_upper_bound:i64* prev_size:i64)
    (let ((n:i64 0)
          (prev_peak:i64 0))
      (cond ((= (is_empty prev_peaks_array prev_size) 0)
              (while (= (and (<= (pref prev_lower_bound n) current_peak) (<= current_peak (pref prev_upper_bound n))) 0)
                (set! n (+ n 1)))
              (set! prev_peak (pref prev_peaks_array n)))
            (else
               (set! prev_peak -1)))
      prev_peak)))

;creates a copy of the input buffer and pads with zeros
(bind-func zero_pad
  (lambda (buffer:float* buffer_size:i64 padded_buffer:float* padded_size:i64)
    (let ((n:i64 0))
      (dotimes (n padded_size)
        (cond ((< n buffer_size)
                (pset! padded_buffer n (pref buffer n)))
              (else
                (pset! padded_buffer n 0.0))))
      void)))

;make a buffer mono in place
(bind-func make_mono
  (lambda (buffer:float* buffer_size:i64)
    (let ((n:i64 0))
      (dotimes (n (/ buffer_size 2))
        (pset! buffer (* n 2) (/ (+ (pref buffer (* n 2)) (pref buffer (+ (* n 2) 1))) 2.0))
        (pset! buffer (+ (* n 2) 1) (pref buffer (* n 2))))
      void)))

;convert LR interleaved signal to 3 buffers buffer_size/2 in length
(bind-func LR_to_MS_3_channels
  (lambda (buffer:float* buffer_size:i64 mid:float* side_l:float* side_r:float*)
    (let ((n:i64 0))
      (dotimes (n (/ buffer_size 2))
        (pset! mid n (+ (pref buffer (* n 2)) (pref buffer (+ (* n 2) 1)))) ;l+r
        (pset! side_l n (- (pref buffer (* n 2)) (pref buffer (+ (* n 2) 1)))) ;l-r
        (pset! side_r n (- (pref buffer (+ (* n 2) 1)) (pref buffer (* n 2))))) ;r-l
      void)))

;convert 3 buffers buffer_size/2 in length to LR interleaved signal
(bind-func MS_to_LR_3_channels
  (lambda (buffer:float* buffer_size:i64 mid:float* side_l:float* side_r:float*)
    (let ((n:i64 0))
      (dotimes (n (/ buffer_size 2))
        (pset! buffer (* n 2) (/ (+ (pref mid n) (pref side_l n)) 2.0))
        (pset! buffer (+ (* n 2) 1) (/ (+ (pref mid n) (pref side_r n)) 2.0)))
      void)))

;convert LR interleaved signal to 3 buffers buffer_size/2 in length
(bind-func LR_to_MS_2_channels
  (lambda (buffer:float* buffer_size:i64 mid:float* side:float*)
    (let ((n:i64 0))
      (dotimes (n (/ buffer_size 2))
        (pset! mid n (+ (pref buffer (* n 2)) (pref buffer (+ (* n 2) 1)))) ;l+r
        (pset! side n (- (pref buffer (* n 2)) (pref buffer (+ (* n 2) 1))))) ;l-r
      void)))

;convert 3 buffers buffer_size/2 in length to LR interleaved signal
(bind-func MS_to_LR_2_channels
  (lambda (buffer:float* buffer_size:i64 mid:float* side:float*)
    (let ((n:i64 0))
      (dotimes (n (/ buffer_size 2))
        (pset! buffer (* n 2) (/ (+ (pref mid n) (pref side n)) 2.0)) ;l=(M+S)/2
        (pset! buffer (+ (* n 2) 1) (/ (- (pref mid n) (pref side n)) 2.0))) ;r=(M-S)/2
      void)))

;Check to see if the TSM closures are active
(bind-func is_TSM_active
  (lambda()
    (printf "TSM_active=%d\n" (TSM_active))))

;set the speed of playback
(bind-func set_speed
  (lambda (n:float)
    (set! speed n)
    (set! beta (/ (+ 1.0 (* 2.0 n)) (* 3.0 n)))
    (printf "Playback Speed=%g Beta = %g\n" (ftod(speed))(ftod(beta)))))

;set the beta value in sPL
(bind-func set_beta
  (lambda (n:float)
    (set! beta n)
    (printf "Beta = %f\n" (ftod(beta)))))

;set the allowed range for sinsoids to jump
(bind-func set_range
  (lambda (n:float)
    (set! range n)
    (printf "range = %g\n" (ftod(range)))))

;Set the trigger global variable for use in debugging.  Allows for values that
;change rapidly to be printed to terminal once.
(bind-func set_trigger
  (lambda()
    (set! trigger 1)
    (printf "TRIGGER=%d\n" (trigger))))

;--------------------------------------------------------------------------------------------------------------------
;Overlap-Add
;This is only included for demonstration purposes, and whacky effects.
;This is the most basic of algorithms for time stretching, and modifies the pitch as well as time.
;Could include applying a window function.
;If the sample_Sa calculation is set to be the same as every other method, the stereo field signal will flip back and forth.
;--------------------------------------------------------------------------------------------------------------------
(bind-func store_frame_OLA
  (lambda (window_size:i64)
  (let ((read_head:i64 0)
        (write_head:i64 0))
    (lambda (input_buffer:float* in_size:i64 output_buffer:float* out_size:i64 Sa:i64 Ss:i64)
      (let ((n:i64 0)
            (window_buffer:float* (salloc window_size)))
        (dotimes (n window_size)
          (pset! window_buffer n (* 0.5 (pref input_buffer (% (+ n read_head) in_size)))))
        (set! read_head (% (+ read_head Sa ) in_size))   ;Advance the playhead by the Analysis hopsize
        (dotimes (n window_size)  ;Overlap-Add section
          (cond ((< n (- window_size Ss))
                  (pset! output_buffer (% (+ write_head n) out_size) (+ (pref window_buffer n)
                                                                     (pref output_buffer (% (+ write_head n) out_size)))))
                (else
                  (pset! output_buffer (% (+  write_head n) out_size) (pref window_buffer n)))))
        (set! write_head (% (+ write_head Ss ) out_size))
        (set! TSM_active 1)
        void
        )))))

(bind-func TSM_TIM_OLA
  (lambda ()
  (let ((in_offset_ptr:i64 0)
        (out_offset_ptr:i64 0)
        (output_sample:float 0.0)
        (in_size:i64 (bitwise-shift-left 2 20)) ;increase the second argument if audio is wrapping around circular buffer to soon
        (window_size:i64 1024) ;This is split between the number of input channels.  FFT size is window_size/IN_CHANNELS
        (out_size:i64 (* window_size 2))
        (input_buffer:float* (zalloc in_size))
        (output_buffer:float* (zalloc out_size))
        (window_buffer:float* (zalloc window_size))
        (framing (store_frame_OLA window_size))
        (first:i64 1))
  (lambda (in:float)
    (let ((overlap_factor:i64 4)
          (sample_Ss:i64 (/ window_size overlap_factor))
          (sample_Sa:i64 (ftoi64 (+ (% (round (* (i64tof sample_Ss) speed)) 2.0)(round (* (i64tof sample_Ss) speed)))))) ;speed is a global variable adding the modulus ensure even number
    (pset! input_buffer in_offset_ptr in) ;Set 'in' to whatever you want to be time stretched
    (if (= (% in_offset_ptr sample_Ss) 0)
      (if (= first 0)
          (framing input_buffer in_size output_buffer out_size sample_Sa sample_Ss)))
    (if (= in_offset_ptr window_size) ;Start the TSM process after window_size number of samples
          (set! first 0))
    (set! in_offset_ptr (% (+ in_offset_ptr 1) in_size))
    (cond ((= TSM_active 0)
            (set! output_sample 0.0))
          (else (set! output_sample (pref output_buffer out_offset_ptr))
                (set! out_offset_ptr (% (+ out_offset_ptr 1) out_size))
                output_sample)))))))

;--------------------------------------------------------------------------------------------------------------------
;Traditional Phase vocoder
(bind-func phase_vocoder_PV
  (lambda (buffer_size:i64)
    (let ((idx:i64 0)
          (spectrum_size:i64 (+ (/ buffer_size 2) 1))
          (prev_in_phase:float* (zalloc spectrum_size))
          (prev_out_phase:float* (zalloc spectrum_size))
          (omega_k:float* (zalloc spectrum_size))) ;The center frequency of the kth vocoder channel
    (dotimes (idx (+ (/ buffer_size 2) 1))
      (pset! prev_in_phase idx 0.0)
      (pset! prev_out_phase idx 0.0)
      (pset! omega_k idx (/ (* TWOPIf (i64tof idx))
                            (i64tof buffer_size))))
    (lambda (buffer:float* Sa:i64 Ss:i64)
      (let ((temp_buff:float* (salloc buffer_size))
            (wn:float* (salloc buffer_size))
            (spectrum:Complexf* (salloc spectrum_size))
            (mag:float* (salloc spectrum_size))
            (phase:float* (salloc spectrum_size))
            (delta_phi:float* (salloc spectrum_size))
            (k:float* (salloc spectrum_size))
            (delta_phi_adjust:float* (salloc spectrum_size))
            (inst_freq:float* (salloc spectrum_size))
            (synth_phase:float* (salloc spectrum_size))
            (n:i64 0))
      (hanning_window_func wn buffer_size)
      (vvmul buffer wn buffer_size temp_buff) ;Window the incoming audio and overlap by N/4
      (vrotate temp_buff buffer_size (/ buffer_size 2)) ;Circular shift the windowed frame
      (fft temp_buff spectrum buffer_size) ;Compute the DFT of windowed frame
      (dotimes (n spectrum_size) ;Compute the magnitude spectrum
        (pset! mag n (Complex_mag (pref spectrum n))))
      (dotimes (n spectrum_size) ;Compute the phase spectrum
        (pset! phase n (Complex_phase2 (pref spectrum n))))
      (dotimes (n spectrum_size)
        (pset! delta_phi n (- (pref phase n)
                              (pref prev_in_phase n)
                              (* (i64tof Sa) (pref omega_k n)))) ;Unwrap the phase ;Calculate the Instantaneous Phase
        (pset! k n (round (/ (pref delta_phi n) TWOPIf)))
        (pset! delta_phi_adjust n (- (pref delta_phi n)
                                     (* (pref k n) TWOPIf))) ;Adjust to -pi<phase<pi
        (pset! inst_freq n (+ (pref omega_k n) (/ (pref delta_phi_adjust n) (i64tof Sa)))) ;Calculate the Instantaneous Frequency
        (pset! synth_phase n (+ (pref prev_out_phase n) (* (i64tof Ss) (pref inst_freq n))))) ;Set new Synthesis phase
      (if (= speed 1.0) ;restore phase at speed of 1. The audio will still be delayed, but phase inconsistancies no longer exist.
        (begin
          (dotimes (n spectrum_size)
            (pset! synth_phase n (pref phase n)))))
      (dotimes (n spectrum_size) ;Store current input and output phases for next call
        (pset! prev_in_phase n (pref phase n))
        (pset! prev_out_phase n (pref synth_phase n)))
      (Complex_bufferize mag synth_phase spectrum spectrum_size) ;Create output FFT (Ae^j)
      (pol_to_cart2 spectrum spectrum_size)
      (ifft spectrum temp_buff buffer_size) ;take the real part of iFFT (given a scalar output buffer, kiss_fft keeps real part)
      (vsdiv temp_buff (i64tof buffer_size) buffer_size temp_buff) ;this could be changed to a dotimes
      (vrotate temp_buff buffer_size (/ buffer_size 2)) ;Circular shift the time domain Output
      (hanning_window_func wn buffer_size)
      (vvmul temp_buff wn buffer_size buffer) ;Output windowing
      void))))) ;Overlap and add this to the output

;This function extracts a frame from the input buffer, multiplies by a constant,
;splits the signal into left and right, then re-interleaves to reconstruct the frame.
;This frame is then copied to the output buffer.
(bind-func store_frame_PV
  (lambda (window_size:i64)
  (let ((read_head:i64 0)
        (write_head:i64 0)
        ;(PV_left (phase_vocoder_PV (/ window_size IN_CHANNELS)))
        ;(PV_right (phase_vocoder_PV (/ window_size IN_CHANNELS)))
        (PV_mid (phase_vocoder_PV (/ window_size 2))) ;replace 2 with IN_CHANNELS if using 0.7.0 release
        (PV_side (phase_vocoder_PV (/ window_size 2))) ;replace 2 with IN_CHANNELS if using 0.7.0 release
        )
    (lambda (input_buffer:float* in_size:i64 output_buffer:float* out_size:i64 Sa:i64 Ss:i64)
      (let ((n:i64 0)
            (window_buffer_in:float* (salloc window_size))
            (window_buffer_out:float* (salloc window_size))
            (left_right_size:i64 (/ window_size 2)) ;replace 2 with IN_CHANNELS if using 0.7.0 release
            ;(left:float* (salloc left_right_size))
            ;(right:float* (salloc left_right_size))
            (mid:float* (salloc left_right_size))
            (side:float* (salloc left_right_size)))
        (dotimes (n window_size)
          (pset! window_buffer_in n (pref input_buffer (% (+ n read_head) in_size))))
        (set! read_head (% (+ read_head Sa ) in_size))   ;Advance the playhead by the Analysis hopsize
        ;(LR_split window_buffer left right window_size)
        ;(PV_left left (/ Sa IN_CHANNELS) (/ Ss IN_CHANNELS))
        ;(PV_right right (/ Sa IN_CHANNELS) (/ Ss IN_CHANNELS))
        ;(LR_combine window_buffer left right window_size)
        (LR_to_MS_2_channels window_buffer_in window_size mid side)
        (PV_mid mid (/ Sa 2) (/ Ss 2)) ;replace 2 with IN_CHANNELS if using 0.7.0 release
        (PV_side side (/ Sa 2) (/ Ss 2)) ;replace 2 with IN_CHANNELS if using 0.7.0 release
        (MS_to_LR_2_channels window_buffer_out window_size mid side)
        (dotimes (n window_size)  ;Overlap-Add section
          (cond ((< n (- window_size Ss))
                  (pset! output_buffer (% (+ write_head n) out_size) (+ (pref window_buffer_out n)
                                                                     (pref output_buffer (% (+ write_head n) out_size)))))
                (else
                  (pset! output_buffer (% (+  write_head n) out_size) (pref window_buffer_out n)))))
        (set! write_head (% (+ write_head Ss ) out_size))
        (set! TSM_active 1)
        void
        )))))

(bind-func TSM_TIM_PV
  (lambda ()
  (let ((in_offset_ptr:i64 0)
        (out_offset_ptr:i64 0)
        (output_sample:float 0.0)
        (in_size:i64 (bitwise-shift-left 2 20)) ;increase the second argument if audio is wrapping around circular buffer to soon
        (window_size:i64 8192) ;This is split between the number of input channels.  FFT size is window_size/IN_CHANNELS
        (out_size:i64 (* window_size 2))
        (input_buffer:float* (zalloc in_size))
        (output_buffer:float* (zalloc out_size))
        (window_buffer:float* (zalloc window_size))
        (framing (store_frame_PV window_size))
        (first:i64 1))
  (lambda (in:float)
    (let ((overlap_factor:i64 4)
          (sample_Ss:i64 (/ window_size overlap_factor))
          (sample_Sa:i64 (ftoi64 (round (* (i64tof sample_Ss) speed))))) ;speed is a global variable
    (pset! input_buffer in_offset_ptr in) ;Set 'in' to whatever you want to be time stretched
    (if (= (% in_offset_ptr sample_Ss) 0)
      (if (= first 0)
          (framing input_buffer in_size output_buffer out_size sample_Sa sample_Ss)))
    (if (= in_offset_ptr window_size) ;Start the TSM process after window_size number of samples
          (set! first 0))
    (set! in_offset_ptr (% (+ in_offset_ptr 1) in_size))
    (cond ((= TSM_active 0)
            (set! output_sample 0.0))
          (else (set! output_sample (pref output_buffer out_offset_ptr))
                (set! out_offset_ptr (% (+ out_offset_ptr 1) out_size))
                output_sample)))))))

;--------------------------------------------------------------------------------------------------------------------
;-------------------------------Identity Phase Locking Phase vocoder-------------------------------------------------
(bind-func phase_vocoder_iPL
  (lambda (buffer_size:i64)
    (let ((idx:i64 0)
          (spectrum_size:i64 (+ (/ buffer_size 2) 1))
          (peaks_size:i64 (ftoi64 (ceil (/ (i64tof spectrum_size) 3.0)))) ; Assuming peak is greater than 4 neighbours
          (prev_in_phase:float* (zalloc spectrum_size)) ;Need to init this to 0
          (prev_out_phase:float* (zalloc spectrum_size)) ;Need to init this to 0
          (omega_k:float* (zalloc spectrum_size)) ;The center frequency of the kth vocoder channel
          (unity_mag:float* (zalloc spectrum_size)))
    (dotimes (idx (+ (/ buffer_size 2) 1))
      (pset! prev_in_phase idx 0.0)
      (pset! prev_out_phase idx 0.0)
      (pset! omega_k idx (/ (* TWOPIf (i64tof idx))
                            (i64tof buffer_size)))
      (pset! unity_mag idx 1.0))
    (lambda (buffer:float* Sa:i64 Ss:i64)
      (let ((temp_buff:float* (salloc buffer_size))
            (wn:float* (salloc buffer_size))
            (spectrum:Complexf* (salloc spectrum_size))
            (mag:float* (salloc spectrum_size))
            (phase:float* (salloc spectrum_size))
            (delta_phi:float* (salloc spectrum_size))
            (k:float* (salloc spectrum_size))
            (delta_phi_adjust:float* (salloc spectrum_size))
            (inst_freq:float* (salloc spectrum_size))
            (synth_phase:float* (salloc spectrum_size))
            (n:i64 0)
            (l:i64 0)
            (num_peaks:i64 0)
            (peaks_array:i64* (salloc peaks_size))
            (region_lower:i64* (salloc peaks_size))
            (region_upper:i64* (salloc peaks_size))
            (theta:float* (salloc spectrum_size))
            (Z:Complexf* (salloc spectrum_size))
            (spectrum_polar:Complexf* (salloc spectrum_size)))
      (hanning_window_func wn buffer_size)
      (vvmul buffer wn buffer_size temp_buff) ;Apply window function
      (vrotate temp_buff buffer_size (/ buffer_size 2)) ;Circular shift the windowed frame
      (fft temp_buff spectrum buffer_size) ;Compute the DFT of windowed frame
      (dotimes (n spectrum_size) ;Compute the magnitude spectrum
        (pset! mag n (Complex_mag (pref spectrum n))))
      (dotimes (n spectrum_size) ;Compute the phase spectrum
        (pset! phase n (Complex_phase2 (pref spectrum n))))
      (set! num_peaks (find_peaks mag spectrum_size peaks_array region_lower region_upper)) ;Find the peaks and region limits in the magnitude spectrum
      (cond ((> num_peaks 0)
              (dotimes (n num_peaks)
              ;Unwrap the phase at each peak
                (pset! delta_phi n (- (pref phase (pref peaks_array n))
                                      (pref prev_in_phase (pref peaks_array n))
                                      (* (i64tof Sa) (pref omega_k (pref peaks_array n))))) ;Calculate the Instantaneous Phase
                (pset! k n (round (/ (pref delta_phi n) TWOPIf)))
                (pset! delta_phi_adjust n (- (pref delta_phi n)
                                             (* (pref k n) TWOPIf))) ;Adjust to -pi<phase<pi
                (pset! inst_freq n (+ (pref omega_k (pref peaks_array n)) (/ (pref delta_phi_adjust n) (i64tof Sa)))) ;Calculate the Instantaneous Frequency
                (pset! synth_phase n (+ (pref prev_out_phase (pref peaks_array n)) (* (i64tof Ss) (pref inst_freq n)))) ;Calculate the new Synthesis phase
                (dotimes (l (+ 1 (- (pref region_upper n) (pref region_lower n)))) ;Calculate the rotation angle (theta)
                  (pset! theta (+ l (pref region_lower n)) (- (pref synth_phase n) (pref phase (pref peaks_array n))))))
              (Complex_bufferize unity_mag theta Z spectrum_size) ;Calculate Phasor (Z=e^i*theta)
              (Complex_bufferize mag phase spectrum_polar spectrum_size)
              (Complex_multiplication_polar Z spectrum_polar spectrum spectrum_size) ;Apply the Phasor to all channels in the region of the peak
              (dotimes (n spectrum_size) ;Set previous input and output phase ready for next frame
                (pset! prev_in_phase n (pref phase n))
                (pset! prev_out_phase n (tref (pref-ptr spectrum n) 1))))
            (else
              (Complex_bufferize mag phase spectrum spectrum_size)))
      (if (= speed 1.0) ;out=in at speed of 1
        (begin
          (dotimes (n spectrum_size)
            (pset! synth_phase n (pref phase n)))
          (Complex_bufferize mag synth_phase spectrum spectrum_size)))
      (pol_to_cart2 spectrum spectrum_size) ;Convert from polar back to cartesian
      (ifft spectrum temp_buff buffer_size) ;take the real part of iFFT
      (vsdiv temp_buff (i64tof buffer_size) buffer_size temp_buff) ;this could be changed to a dotimes
      (vrotate temp_buff buffer_size (/ buffer_size 2)) ;Circular shift the time domain Output
      (vvmul temp_buff wn buffer_size buffer) ;Apply output window function
      void))))) ;Overlap and add this to the output

;This function extracts a frame from the input buffer, multiplies by a constant,
;splits the signal into left and right, then re-interleaves to reconstruct the frame.
;This frame is then copied to the output buffer.
(bind-func store_frame_iPL
  (lambda (window_size:i64)
  (let ((read_head:i64 0)
        (write_head:i64 0)
        ;(PV_left (phase_vocoder_iPL (/ window_size IN_CHANNELS)))
        ;(PV_right (phase_vocoder_iPL (/ window_size IN_CHANNELS)))
        (PV_mid (phase_vocoder_iPL (/ window_size 2))) ;replace 2 with IN_CHANNELS if using 0.7.0 release
        (PV_side (phase_vocoder_iPL (/ window_size 2)))) ;replace 2 with IN_CHANNELS if using 0.7.0 release
    (lambda (input_buffer:float* in_size:i64 output_buffer:float* out_size:i64 Sa:i64 Ss:i64)
      (let ((n:i64 0)
            (window_buffer_in:float* (salloc window_size))
            (window_buffer_out:float* (salloc window_size))
            (left_right_size:i64 (/ window_size 2)) ;replace 2 with IN_CHANNELS if using 0.7.0 release
            ;(left:float* (salloc left_right_size))
            ;(right:float* (salloc left_right_size))
            (mid:float* (salloc left_right_size))
            (side:float* (salloc left_right_size)))
        (dotimes (n window_size)
          (pset! window_buffer_in n (pref input_buffer (% (+ n read_head) in_size))))
        (set! read_head (% (+ read_head Sa ) in_size))   ;Advance the playhead by the Analysis hopsize
        ;(LR_split window_buffer left right window_size)
        ;(PV_left left (/ Sa IN_CHANNELS) (/ Ss IN_CHANNELS))
        ;(PV_right right (/ Sa IN_CHANNELS) (/ Ss IN_CHANNELS))
        ;(LR_combine window_buffer left right window_size)
        (LR_to_MS_2_channels window_buffer_in window_size mid side)
        (PV_mid mid (/ Sa 2) (/ Ss 2)) ;replace 2 with IN_CHANNELS if using 0.7.0 release
        (PV_side side (/ Sa 2) (/ Ss 2)) ;replace 2 with IN_CHANNELS if using 0.7.0 release
        (MS_to_LR_2_channels window_buffer_out window_size mid side)
        (dotimes (n window_size)  ;Overlap-Add section
          (cond ((< n (- window_size Ss))
                  (pset! output_buffer (% (+ write_head n) out_size) (+ (pref window_buffer_out n)
                                                                     (pref output_buffer (% (+ write_head n) out_size)))))
                (else
                  (pset! output_buffer (% (+  write_head n) out_size) (pref window_buffer_out n)))))
        (set! write_head (% (+ write_head Ss ) out_size))
        (set! TSM_active 1)
        void
        )))))


(bind-func TSM_TIM_iPL
  (lambda ()
  (let ((in_offset_ptr:i64 0)
        (out_offset_ptr:i64 0)
        (output_sample:float 0.0)
        (in_size:i64 (bitwise-shift-left 2 20)) ;increase the second argument if audio is wrapping around circular buffer to soon
        (window_size:i64 8192) ;This is split between the number of input channels.  FFT size is window_size/IN_CHANNELS
        (out_size:i64 (* window_size 2))
        (input_buffer:float* (zalloc in_size))
        (output_buffer:float* (zalloc out_size))
        (window_buffer:float* (zalloc window_size))
        (framing (store_frame_iPL window_size))
        (first:i64 1))
  (lambda (in:float)
    (let ((overlap_factor:i64 4)
          (sample_Ss:i64 (/ window_size overlap_factor))
          (sample_Sa:i64 (ftoi64 (round (* (i64tof sample_Ss) speed))))) ;speed is a global variable
    (pset! input_buffer in_offset_ptr in) ;Set 'in' to whatever you want to be time stretched
    (if (= (% in_offset_ptr sample_Ss) 0)
      (if (= first 0)
          (framing input_buffer in_size output_buffer out_size sample_Sa sample_Ss)))
    (if (= in_offset_ptr window_size) ;Start the TSM process after window_size number of samples
          (set! first 0))
    (set! in_offset_ptr (% (+ in_offset_ptr 1) in_size))
    (cond ((= TSM_active 0)
            (set! output_sample 0.0))
          (else (set! output_sample (pref output_buffer out_offset_ptr))
                (set! out_offset_ptr (% (+ out_offset_ptr 1) out_size))
                output_sample)))))))

;--------------------------------------------------------------------------------------------------------------------------------------------

;-------------------------------------------Scaled Phase Locking Phase vocoder---------------------------------------------------------------
(bind-func phase_vocoder_sPL
  (lambda (buffer_size:i64)
    (let ((idx:i64 0)
          (spectrum_size:i64 (+ (/ buffer_size 2) 1))
          (peaks_size:i64 (ftoi64 (ceil (/ (i64tof spectrum_size) 3.0))))
          (prev_in_phase:float* (zalloc spectrum_size))
          (prev_out_phase:float* (zalloc spectrum_size))
          (omega_k:float* (zalloc spectrum_size)) ;The center frequency of the kth vocoder channel
          (prev_peaks_array:i64* (zalloc peaks_size))
          (prev_region_lower:i64* (zalloc peaks_size))
          (prev_region_upper:i64* (zalloc peaks_size))
          (prev_num_peaks:i64 0))
    (dotimes (idx spectrum_size)
      (pset! prev_in_phase idx 0.0)
      (pset! prev_out_phase idx 0.0)
      (pset! omega_k idx (/ (* TWOPIf (i64tof idx))
                            (i64tof buffer_size)))) ;spectrum_size => acts as low pass filter. buffer size => normal
    (dotimes (idx peaks_size)
      (pset! prev_peaks_array idx 0)
      (pset! prev_region_lower idx 0)
      (pset! prev_region_upper idx 0))
      (lambda (buffer:float* Sa:i64 Ss:i64)
        (let ((temp_buff:float* (salloc buffer_size))
              (wn:float* (salloc buffer_size))
              (spectrum:Complexf* (salloc spectrum_size))
              (mag:float* (salloc spectrum_size))
              (mag_adj:float* (salloc spectrum_size))
              (phase:float* (salloc spectrum_size))
              (delta_phi:float* (salloc spectrum_size))
              (k:float* (salloc spectrum_size))
              (delta_phi_adjust:float* (salloc spectrum_size))
              (inst_freq:float* (salloc spectrum_size))
              (synth_phase:float* (salloc spectrum_size))
              (delta_phi_s:float* (salloc spectrum_size))
              (k_s:float* (salloc spectrum_size))
              (delta_phi_adjust_s:float* (salloc spectrum_size))
              (inst_freq_s:float* (salloc spectrum_size))
              (synth_phase_s:float* (salloc spectrum_size))
              (n:i64 0)
              (l:i64 0)
              (num_peaks:i64 0)
              (peaks_array:i64* (salloc peaks_size))
              (region_lower:i64* (salloc peaks_size))
              (region_upper:i64* (salloc peaks_size))
              (theta:float* (salloc spectrum_size))
              (prev_peak:i64 0)
              (difference:float* (salloc spectrum_size)))
          (hanning_window_func wn buffer_size)
          (vvmul buffer wn buffer_size temp_buff) ;Apply window function
          (vrotate temp_buff buffer_size (/ buffer_size 2)) ;Circular shift the windowed frame
          (fft temp_buff spectrum buffer_size) ;Compute the DFT of windowed frame
          (dotimes (n spectrum_size) ;Compute the magnitude spectrum
            (pset! mag n (Complex_mag (pref spectrum n))))
          (dotimes (n spectrum_size) ;Compute the phase spectrum
            (pset! phase n (Complex_phase2 (pref spectrum n))))
          (set! num_peaks (find_peaks mag spectrum_size peaks_array region_lower region_upper)) ;Find the peaks and region limits in the magnitude spectrum
          (cond ((> num_peaks 0) ;number of current peaks
                  (dotimes (n num_peaks)
                    (set! prev_peak (find_previous_peak (pref peaks_array n) prev_peaks_array prev_region_lower prev_region_upper peaks_size))
                    (cond ((or (= prev_peak -1) (> (fabs (i64tof (- (pref peaks_array n) prev_peak))) (* (i64tof(pref peaks_array n)) range))) ;no previous peaks or outside allowable range
                              ;iPL phase vocoder if no previous peaks, or the previous peak is too far away
                              ;(printf "Current=%d, previous=%d" (pref peaks_array n) prev_peak) ;uncomment these to see how setting the range affects the algorithm used
                              ;(println (fabs (i64tof (- (pref peaks_array n) prev_peak))))
                              (pset! delta_phi_s n (- (pref phase (pref peaks_array n))
                                                    (pref prev_in_phase (pref peaks_array n))
                                                    (* (i64tof Sa) (pref omega_k (pref peaks_array n))))) ;Calculate the Instantaneous Phase
                              (pset! k_s n (round (/ (pref delta_phi_s n) TWOPIf)))
                              (pset! delta_phi_adjust_s n (- (pref delta_phi_s n)
                                                           (* (pref k_s n) TWOPIf))) ;Adjust to -pi<phase<pi
                              (pset! inst_freq_s n (+ (pref omega_k (pref peaks_array n)) (/ (pref delta_phi_adjust_s n) (i64tof Sa)))) ;Calculate the Instantaneous Frequency
                              (pset! synth_phase_s n (+ (pref prev_out_phase (pref peaks_array n)) (* (i64tof Ss) (pref inst_freq_s n)))) ;Calculate the new Synthesis phase
                              (dotimes (l (+ 1 (- (pref region_upper n)(pref region_lower n)))) ;Calculate the rotation angle theta
                                (pset! theta (+ l (pref region_lower n)) (- (pref synth_phase_s n) (pref phase (pref peaks_array n))))
                                (pset! synth_phase (+ l (pref region_lower n)) (+ (pref phase (+ l (pref region_lower n)))
                                                                                  (pref theta (+ l (pref region_lower n)))))))
                          (else
                              ;sPL phase vocoder when a previous peak is found within the acceptable region
                              (pset! delta_phi_s n (- (pref phase (pref peaks_array n))
                                                    (pref prev_in_phase prev_peak)
                                                    (* (i64tof Sa) (pref omega_k (pref peaks_array n)))));Calculate the Instantaneous Phase
                              (pset! k_s n (round (/ (pref delta_phi_s n) TWOPIf)))
                              (pset! delta_phi_adjust_s n (- (pref delta_phi_s n)
                                                           (* (pref k_s n) TWOPIf)));Adjust to -pi<phase<pi
                              (pset! inst_freq_s n (+ (pref omega_k (pref peaks_array n)) (/ (pref delta_phi_adjust_s n) (i64tof Sa))));Calculate the Instantaneous Frequency
                              (pset! synth_phase_s n (+ (pref prev_out_phase prev_peak) (* (i64tof Ss) (pref inst_freq_s n))));Calculate the new Synthesis phase
                              (dotimes (l (+ 1 (- (pref region_upper n)(pref region_lower n))))
                                ;Calculate the difference between the peak channel and all other channels in the current region
                                (pset! difference (+ l (pref region_lower n)) (- (pref phase (+ l (pref region_lower n)))
                                                                                 (pref phase (pref peaks_array n))))
                                ;Calculate the Synthesis phase for each bin
                                (pset! synth_phase (+ l (pref region_lower n)) (+ (pref synth_phase_s n)
                                                                                  (* beta (pref difference (+ l (pref region_lower n))))))))))
                  (dotimes (n spectrum_size) ;account for loss of volume during PV.
                    (pset! mag_adj n (* (pref mag n) 1.2)))
                  (Complex_bufferize mag_adj synth_phase spectrum spectrum_size));Create spectrum
                (else
                  (Complex_bufferize mag phase spectrum spectrum_size)))
          (if (= speed 1.0) ;out=in at speed of 1
            (Complex_bufferize mag phase spectrum spectrum_size))
          ;Store current peaks, region bounds, in phase and out phase for use in the next frame analysis
          (dotimes (n spectrum_size)
            (pset! prev_in_phase n (pref phase n))
            (pset! prev_out_phase n (tref (pref-ptr spectrum n) 1)))
          (dotimes (n peaks_size)
            (pset! prev_peaks_array n 0)
            (pset! prev_region_lower n 0)
            (pset! prev_region_upper n 0))
          (dotimes (n num_peaks)
            (pset! prev_peaks_array n (pref peaks_array n))
            (pset! prev_region_upper n (pref region_upper n))
            (pset! prev_region_lower n (pref region_lower n)))
          (set! prev_num_peaks num_peaks)
          (pol_to_cart2 spectrum spectrum_size) ;Convert from polar back to cartesian
          (ifft spectrum temp_buff buffer_size) ;take the real part of iFFT
          (vsdiv temp_buff (i64tof buffer_size) buffer_size temp_buff) ;this could be changed to a dotimes
          (vrotate temp_buff buffer_size (/ buffer_size 2)) ;Circular shift the time domain Output
          (vvmul temp_buff wn buffer_size buffer) ;Apply output window function. wn is already a hanning window
          void))))) ;Overlap and add this to the output

;This closure extracts a frame from the input buffer, and calls the TSM kernel
;This frame is then copied to the output buffer.
;Provided are 2 separate stereo versions of TSM processing.  The Mid side versions
;give the most accurate stereo image.  The standard LR version requires the least
;processing overhead, but quickly loses phase coherance between the channels.
(bind-func store_frame_sPL
  (lambda (window_size:i64)
  (let ((read_head:i64 0)
        (write_head:i64 0)
        ;(PV_left (phase_vocoder_sPL (/ window_size IN_CHANNELS)))
        ;(PV_right (phase_vocoder_sPL (/ window_size IN_CHANNELS)))
        (PV_mid (phase_vocoder_sPL (/ window_size 2))) ;replace 2 with IN_CHANNELS if using 0.7.0 release
        (PV_side (phase_vocoder_sPL (/ window_size 2)))) ;replace 2 with IN_CHANNELS if using 0.7.0 release
    (lambda (input_buffer:float* in_size:i64 output_buffer:float* out_size:i64 Sa:i64 Ss:i64)
      (let ((n:i64 0)
            (window_buffer_in:float* (salloc window_size))
            (window_buffer_out:float* (salloc window_size))
            (left_right_size:i64 (/ window_size 2)) ;replace 2 with IN_CHANNELS if using 0.7.0 release
            ;(left:float* (salloc left_right_size))
            ;(right:float* (salloc left_right_size))
            (mid:float* (salloc left_right_size))
            (side:float* (salloc left_right_size)))
        (dotimes (n window_size)
          (pset! window_buffer_in n (pref input_buffer (% (+ n read_head) in_size))))
        (set! read_head (% (+ read_head Sa ) in_size))   ;Advance the playhead by the Analysis hopsize
        ;;Standard Left Right processing
        ;(make_mono window_buffer_in window_size)
        ;(LR_split window_buffer_in left right window_size)
        ;(PV_left left (/ Sa IN_CHANNELS) (/ Ss IN_CHANNELS))
        ;(PV_right right (/ Sa IN_CHANNELS) (/ Ss IN_CHANNELS))
        ;(LR_combine window_buffer_out left right window_size)
        ;(make_mono window_buffer_out window_size)
        ;;Two channel MS Processing (best stereo image)
        (LR_to_MS_2_channels window_buffer_in window_size mid side)
        (PV_mid mid (/ Sa 2) (/ Ss 2)) ;replace 2 with IN_CHANNELS if using 0.7.0 release
        (PV_side side (/ Sa 2) (/ Ss 2)) ;replace 2 with IN_CHANNELS if using 0.7.0 release
        (MS_to_LR_2_channels window_buffer_out window_size mid side)
        (dotimes (n window_size)  ;Overlap-Add section
          (cond ((< n (- window_size Ss))
                  (pset! output_buffer (% (+ write_head n) out_size) (+ (pref window_buffer_out n)
                                                                     (pref output_buffer (% (+ write_head n) out_size)))))
                (else
                  (pset! output_buffer (% (+  write_head n) out_size) (pref window_buffer_out n)))))
        (set! write_head (% (+ write_head Ss ) out_size))
        (set! TSM_active 1)
        void
        )))))

(bind-func TSM_TIM_sPL
  (lambda ()
  (let ((in_offset_ptr:i64 0)
        (out_offset_ptr:i64 0)
        (output_sample:float 0.0)
        (in_size:i64 (bitwise-shift-left 2 20)) ;increase the second argument if audio is wrapping around circular buffer to soon
        (window_size:i64 8192) ;This is split between the number of input channels.  FFT size is window_size/IN_CHANNELS
        (out_size:i64 (* window_size 2))
        (input_buffer:float* (zalloc in_size))
        (output_buffer:float* (zalloc out_size))
        (window_buffer:float* (zalloc window_size))
        (framing (store_frame_sPL window_size))
        (first:i64 1))
  (lambda (in:float)
    (let ((overlap_factor:i64 4)
          (sample_Ss:i64 (/ window_size overlap_factor))
          (sample_Sa:i64 (ftoi64 (round (* (i64tof sample_Ss) speed))))) ;speed is a global variable
    (pset! input_buffer in_offset_ptr in) ;Set 'in' to whatever you want to be time stretched
    (if (= (% in_offset_ptr sample_Ss) 0)
      (if (= first 0)
          (framing input_buffer in_size output_buffer out_size sample_Sa sample_Ss)))
    (if (= in_offset_ptr window_size) ;Start the TSM process after window_size number of samples
          (set! first 0))
    (set! in_offset_ptr (% (+ in_offset_ptr 1) in_size))
    (cond ((= TSM_active 0)
            (set! output_sample 0.0))
          (else (set! output_sample (pref output_buffer out_offset_ptr))
                (set! out_offset_ptr (% (+ out_offset_ptr 1) out_size))
                output_sample)))))))

($ (println "TSM library loaded"))
