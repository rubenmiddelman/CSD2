;; make sure this stays in sync with the same variables in
;; libs/external/instruments_ext-scm.xtm

(define *gm-kick* 35)
(define *gm-kick-2* 36)
(define *gm-side-stick* 37)
(define *gm-snare* 38)
(define *gm-hand-clap* 39)
(define *gm-snare-2* 40)
(define *gm-low-floor-tom* 41)
(define *gm-closed-hi-hat* 42)
(define *gm-hi-floor-tom* 43)
(define *gm-pedal-hi-hat* 44)
(define *gm-low-tom* 45)
(define *gm-open-hi-hat* 46)
(define *gm-low-mid-tom* 47)
(define *gm-hi-mid-tom* 48)
(define *gm-crash* 49)
(define *gm-hi-tom* 50)
(define *gm-ride* 51)
(define *gm-chinese* 52)
(define *gm-ride-bell* 53)
(define *gm-tambourine* 54)
(define *gm-splash* 55)
(define *gm-cowbell* 56)
(define *gm-crash-2* 57)
(define *gm-vibraslap* 58)
(define *gm-ride-2* 59)
(define *gm-hi-bongo* 60)
(define *gm-low-bongo* 61)
(define *gm-mute-hi-conga* 62)
(define *gm-hi-conga* 63)
(define *gm-low-conga* 64)
(define *gm-hi-timbale* 65)
(define *gm-low-timbale* 66)
(define *gm-hi-agogo* 67)
(define *gm-low-agogo* 68)
(define *gm-cabasa* 69)
(define *gm-maracas* 70)
(define *gm-short-whistle* 71)
(define *gm-long-whistle* 72)
(define *gm-short-guiro* 73)
(define *gm-long-guiro* 74)
(define *gm-claves* 75)
(define *gm-hi-wood-block* 76)
(define *gm-low-wood-block* 77)
(define *gm-mute-cuica* 78)
(define *gm-open-cuica* 79)
(define *gm-mute-triangle* 80)
(define *gm-open-triangle* 81)
(define *gm-mute-surdo* 86)
(define *gm-open-surdo* 87)

(define *gm-drum-map-alist*
  '(("kick" . 35)
    ("kick-2" . 36)
    ("side-stick" . 37)
    ("snare" . 38)
    ("hand-clap" . 39)
    ("snare-2" . 40)
    ("low-floor-tom" . 41)
    ("closed-hi-hat" . 42)
    ("hi-floor-tom" . 43)
    ("pedal-hi-hat" . 44)
    ("low-tom" . 45)
    ("open-hi-hat" . 46)
    ("low-mid-tom" . 47)
    ("hi-mid-tom" . 48)
    ("crash" . 49)
    ("hi-tom" . 50)
    ("ride" . 51)
    ("chinese" . 52)
    ("ride-bell" . 53)
    ("tambourine" . 54)
    ("splash" . 55)
    ("cowbell" . 56)
    ("crash-2" . 57)
    ("vibraslap" . 58)
    ("ride-2" . 59)
    ("hi-bongo" . 60)
    ("low-bongo" . 61)
    ("mute-hi-conga" . 62)
    ("hi-conga" . 63)
    ("low-conga" . 64)
    ("hi-timbale" . 65)
    ("low-timbale" . 66)
    ("hi-agogo" . 67)
    ("low-agogo" . 68)
    ("cabasa" . 69)
    ("maracas" . 70)
    ("short-whistle" . 71)
    ("long-whistle" . 72)
    ("short-guiro" . 73)
    ("long-guiro" . 74)
    ("claves" . 75)
    ("hi-wood-block" . 76)
    ("low-wood-block" . 77)
    ("mute-cuica" . 78)
    ("open-cuica" . 79)
    ("mute-triangle" . 80)
    ("open-triangle" . 81)
    ("mute-surdo" . 86)
    ("open-surdo" . 87)))


(define sm-assign-indices
  (lambda (partial-map)
    (let loop ((unassigned
                (cl:sort partial-map
                         (lambda (a b)
                           (let ((l1 (length a))
                                 (l2 (length b)))
                             (cond ((and (= l1 2) (= l2 2))
                                    (< (cadr a) (cadr b)))
                                   ((= l1 2) #t)
                                   ((= l2 2) #f)
                                   (else #t))))))
               (current-slot 35)
               (filled-slots '())
               (result '()))
      (if (null? unassigned)
          (reverse result)
          (if (= (length (car unassigned)) 2)
              (loop (cdr unassigned)
                    current-slot
                    (cons (cadar unassigned) filled-slots)
                    (cons (append (car unassigned) '(0 0)) result))
              (if (member current-slot filled-slots)
                  (loop unassigned
                        (+ current-slot 1)
                        filled-slots
                        result)
                  (loop (cdr unassigned)
                        (+ current-slot 1)
                        (cons current-slot filled-slots)
                        (cons (list (caar unassigned) current-slot 0 0) result))))))))

(define sm-sample-get-index
  (lambda (sample)
    (if (< (length sample) 2)
        #f
        (cadr sample))))

(define sm-sample-get-bank
  (lambda (sample)
    (if (< (length sample) 3)
        #f
        (caddr sample))))

;; set-sampler-index args: inst fname index offset lgth bank print?
(define sm-sample-fill-with-defaults
  (lambda (sample next-index)
    (if (< (length sample) 2)
        (append sample (list next-index 0 0 0))
        (if (< (length sample) 3)
            (append sample '(0 0 0))
            (append (cl:butlast sample 1) (list 0 0 (car (cl:last sample 1))))))))

(define sm-fill-partial-map
  (lambda (sample-map)
    (let* ((indexed-samples (cl:remove-if-not sm-sample-get-index sample-map))
           (used-indices (map sm-sample-get-index indexed-samples))
           (unindexed-samples (cl:remove-if sm-sample-get-index sample-map))
           (unused-indices
            (cl:set-difference
             (make-list-with-proc (+ (length sample-map)
                                     (length used-indices))
                                  (lambda (i) (+ i 35)))
             used-indices)))
      (map sm-sample-fill-with-defaults
           (append indexed-samples unindexed-samples)
           (append used-indices unused-indices)))))

(define-macro (sm-load-map sampler sample-map . bank)
  `(let* ((sample-dir (car ,sample-map))
          (sample-bank ,(if (null? bank) 0 (car bank)))
          (processed-samples (sm-fill-partial-map (cdr ,sample-map)))
          (num-banks 20)
          (count-vec (make-vector num-banks 0)))
     (for-each (lambda (sample)
                 (if sample
                     ;; inst fname index offset lgth bank print?
                     (let ((bank (+ sample-bank (list-ref sample 4))))
                       (set-sampler-index ,sampler
                                          (string-append sample-dir "/" (car sample))
                                          (cadr sample)
                                          (caddr sample)
                                          (cadddr sample)
                                          bank
                                          0)
                       (vector-set! count-vec
                                    bank
                                    (+ (vector-ref count-vec bank) 1)))))
               processed-samples)
     (print-with-colors 'cyan 'default #f
                        (make-list-with-proc num-banks
                                             (lambda (bank-index)
                                               (let ((samples-loaded (vector-ref count-vec bank-index)))
                                                 (if (> samples-loaded 0)
                                                     (begin (print "Loaded"
                                                                   samples-loaded
                                                                   "files into bank"
                                                                   bank-index "\n")))))))
     (println)))
